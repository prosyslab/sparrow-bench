/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 104 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
struct mpg123_handle_struct;
#line 109 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
typedef struct mpg123_handle_struct mpg123_handle;
#line 634
enum mpg123_vbr {
    MPG123_CBR = 0,
    MPG123_VBR = 1,
    MPG123_ABR = 2
} ;
#line 739 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
struct __anonstruct_mpg123_string_49 {
   char *p ;
   size_t size ;
   size_t fill ;
};
#line 739 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
typedef struct __anonstruct_mpg123_string_49 mpg123_string;
#line 835 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
struct __anonstruct_mpg123_text_50 {
   char lang[3] ;
   char id[4] ;
   mpg123_string description ;
   mpg123_string text ;
};
#line 835 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
typedef struct __anonstruct_mpg123_text_50 mpg123_text;
#line 848 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
struct __anonstruct_mpg123_id3v2_51 {
   unsigned char version ;
   mpg123_string *title ;
   mpg123_string *artist ;
   mpg123_string *album ;
   mpg123_string *year ;
   mpg123_string *genre ;
   mpg123_string *comment ;
   mpg123_text *comment_list ;
   size_t comments ;
   mpg123_text *text ;
   size_t texts ;
   mpg123_text *extra ;
   size_t extras ;
};
#line 848 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
typedef struct __anonstruct_mpg123_id3v2_51 mpg123_id3v2;
#line 926
struct mpg123_pars_struct;
#line 36 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.h"
enum optdec {
    autodec = 0,
    generic = 1,
    generic_dither = 2,
    idrei = 3,
    ivier = 4,
    ifuenf = 5,
    ifuenf_dither = 6,
    mmx = 7,
    dreidnow = 8,
    dreidnowext = 9,
    altivec = 10,
    sse = 11,
    x86_64 = 12,
    arm = 13,
    nodec = 14
} ;
#line 43
enum optcla {
    nocla = 0,
    normal = 1,
    mmxsse = 2
} ;
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy.h"
struct icy_meta {
   char *data ;
   off_t interval ;
   off_t next ;
};
#line 15 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/reader.h"
struct buffy {
   unsigned char *data ;
   ssize_t size ;
   struct buffy *next ;
};
#line 22 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/reader.h"
struct bufferchain {
   struct buffy *first ;
   struct buffy *last ;
   ssize_t size ;
   ssize_t pos ;
   ssize_t firstpos ;
   off_t fileoff ;
};
#line 34 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/reader.h"
struct reader_data {
   off_t filelen ;
   off_t filepos ;
   int filept ;
   void *iohandle ;
   int flags ;
   long timeout_sec ;
   ssize_t (*fdread)(mpg123_handle * , void * , size_t  ) ;
   ssize_t (*r_read)(int fd , void *buf , size_t count ) ;
   off_t (*r_lseek)(int fd , off_t offset , int whence ) ;
   ssize_t (*r_read_handle)(void *handle , void *buf , size_t count ) ;
   off_t (*r_lseek_handle)(void *handle , off_t offset , int whence ) ;
   void (*cleanup_handle)(void *handle ) ;
   ssize_t (*read)(int fd , void *buf , size_t count ) ;
   off_t (*lseek)(int fd , off_t offset , int whence ) ;
   ssize_t (*fullread)(mpg123_handle * , unsigned char * , ssize_t  ) ;
   struct bufferchain buffer ;
};
#line 62 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/reader.h"
struct reader {
   int (*init)(mpg123_handle * ) ;
   void (*close)(mpg123_handle * ) ;
   ssize_t (*fullread)(mpg123_handle * , unsigned char * , ssize_t  ) ;
   int (*head_read)(mpg123_handle * , unsigned long *newhead ) ;
   int (*head_shift)(mpg123_handle * , unsigned long *head ) ;
   off_t (*skip_bytes)(mpg123_handle * , off_t len ) ;
   int (*read_frame_body)(mpg123_handle * , unsigned char * , int size ) ;
   int (*back_bytes)(mpg123_handle * , off_t bytes ) ;
   int (*seek_frame)(mpg123_handle * , off_t num ) ;
   off_t (*tell)(mpg123_handle * ) ;
   void (*rewind)(mpg123_handle * ) ;
   void (*forget)(mpg123_handle * ) ;
};
#line 26 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.h"
struct frame_index {
   off_t *data ;
   off_t step ;
   off_t next ;
   size_t size ;
   size_t fill ;
   size_t grow_size ;
};
#line 10 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synths.h"
typedef int (*func_synth)(float * , int  , mpg123_handle * , int  );
#line 11 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synths.h"
typedef int (*func_synth_mono)(float * , mpg123_handle * );
#line 12 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synths.h"
typedef int (*func_synth_stereo)(float * , float * , mpg123_handle * );
#line 44 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synths.h"
struct synth_s {
   func_synth plain[4][4] ;
   func_synth_stereo stereo[4][4] ;
   func_synth_mono mono2stereo[4][4] ;
   func_synth_mono mono[4][4] ;
};
#line 32 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct al_table {
   short bits ;
   short d ;
};
#line 39 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct outbuffer {
   unsigned char *data ;
   unsigned char *p ;
   size_t fill ;
   size_t size ;
};
#line 47 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct audioformat {
   int encoding ;
   int encsize ;
   int channels ;
   long rate ;
};
#line 57 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct mpg123_pars_struct {
   int verbose ;
   long flags ;
   long force_rate ;
   int down_sample ;
   int rva ;
   long halfspeed ;
   long doublespeed ;
   long timeout ;
   char audio_caps[2][10][10] ;
   long icy_interval ;
   double outscale ;
   long resync_limit ;
   long index_size ;
   long preframes ;
};
#line 85 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct __anonstruct_cpu_opts_53 {
   void (*dct36)(float * , float * , float * , float * , float * ) ;
   enum optdec type ;
   enum optcla class ;
};
#line 85 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct __anonstruct_rva_54 {
   int level[2] ;
   float gain[2] ;
   float peak[2] ;
};
#line 85 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct __anonstruct_layer1_55 {
   float (*fraction)[32] ;
};
#line 85 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct __anonstruct_layer2_56 {
   float (*fraction)[4][32] ;
};
#line 85 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct __anonstruct_layer3_57 {
   float (*hybrid_in)[32][18] ;
   float (*hybrid_out)[18][32] ;
};
#line 85 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
struct mpg123_handle_struct {
   int fresh ;
   int new_format ;
   float hybrid_block[2][2][576] ;
   int hybrid_blc[2] ;
   short *short_buffs[2][2] ;
   float *real_buffs[2][2] ;
   unsigned char *rawbuffs ;
   int rawbuffss ;
   int bo ;
   int ditherindex ;
   float *dithernoise ;
   unsigned char *rawdecwin ;
   int rawdecwins ;
   float *decwin ;
   float *decwin_mmx ;
   float *decwins ;
   int have_eq_settings ;
   float equalizer[2][32] ;
   unsigned char ssave[34] ;
   int halfphase ;
   unsigned char *conv16to8_buf ;
   unsigned char *conv16to8 ;
   int longLimit[9][23] ;
   int shortLimit[9][14] ;
   float gainpow2[378] ;
   float muls[27][64] ;
   unsigned long ntom_val[2] ;
   unsigned long ntom_step ;
   struct synth_s synths ;
   struct __anonstruct_cpu_opts_53 cpu_opts ;
   int verbose ;
   struct al_table  const  *alloc ;
   int (*synth)(float * , int  , mpg123_handle * , int  ) ;
   int (*synth_stereo)(float * , float * , mpg123_handle * ) ;
   int (*synth_mono)(float * , mpg123_handle * ) ;
   void (*make_decode_tables)(mpg123_handle *fr ) ;
   int stereo ;
   int jsbound ;
   int single ;
   int II_sblimit ;
   int down_sample_sblimit ;
   int lsf ;
   int mpeg25 ;
   int down_sample ;
   int header_change ;
   int lay ;
   int (*do_layer)(mpg123_handle * ) ;
   int error_protection ;
   int bitrate_index ;
   int sampling_frequency ;
   int padding ;
   int extension ;
   int mode ;
   int mode_ext ;
   int copyright ;
   int original ;
   int emphasis ;
   int framesize ;
   int freesize ;
   enum mpg123_vbr vbr ;
   off_t num ;
   off_t playnum ;
   off_t audio_start ;
   char accurate ;
   char silent_resync ;
   unsigned char *xing_toc ;
   int freeformat ;
   long freeformat_framesize ;
   int bitindex ;
   unsigned char *wordpointer ;
   unsigned long ultmp ;
   unsigned char uctmp ;
   double maxoutburst ;
   double lastscale ;
   struct __anonstruct_rva_54 rva ;
   off_t track_frames ;
   off_t track_samples ;
   double mean_framesize ;
   off_t mean_frames ;
   int fsizeold ;
   int ssize ;
   unsigned int bitreservoir ;
   unsigned char bsspace[2][3968] ;
   unsigned char *bsbuf ;
   unsigned char *bsbufold ;
   int bsnum ;
   unsigned long oldhead ;
   unsigned long firsthead ;
   int abr_rate ;
   struct frame_index index ;
   struct outbuffer buffer ;
   struct audioformat af ;
   int own_buffer ;
   size_t outblock ;
   int to_decode ;
   int to_ignore ;
   off_t firstframe ;
   off_t lastframe ;
   off_t ignoreframe ;
   off_t firstoff ;
   off_t lastoff ;
   off_t begin_s ;
   off_t begin_os ;
   off_t end_s ;
   off_t end_os ;
   unsigned int crc ;
   struct reader *rd ;
   struct reader_data rdat ;
   struct mpg123_pars_struct p ;
   int err ;
   int decoder_change ;
   int delayed_change ;
   long clip ;
   int metaflags ;
   unsigned char id3buf[128] ;
   mpg123_id3v2 id3v2 ;
   struct icy_meta icy ;
   float *layerscratch ;
   struct __anonstruct_layer1_55 layer1 ;
   struct __anonstruct_layer2_56 layer2 ;
   struct __anonstruct_layer3_57 layer3 ;
   void *wrapperdata ;
   void (*wrapperclean)(void * ) ;
};
#line 75 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
struct wrap_data {
   long *indextable ;
   int iotype ;
   int fd ;
   int my_fd ;
   ssize_t (*r_read)(int  , void * , size_t  ) ;
   long (*r_lseek)(int  , long  , int  ) ;
   void *handle ;
   ssize_t (*r_h_read)(void * , void * , size_t  ) ;
   long (*r_h_lseek)(void * , long  , int  ) ;
   void (*h_cleanup)(void * ) ;
};
#line 194 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
enum mpg123_feature_set {
    MPG123_FEATURE_ABI_UTF8OPEN = 0,
    MPG123_FEATURE_OUTPUT_8BIT = 1,
    MPG123_FEATURE_OUTPUT_16BIT = 2,
    MPG123_FEATURE_OUTPUT_32BIT = 3,
    MPG123_FEATURE_INDEX = 4,
    MPG123_FEATURE_PARSE_ID3V2 = 5,
    MPG123_FEATURE_DECODE_LAYER1 = 6,
    MPG123_FEATURE_DECODE_LAYER2 = 7,
    MPG123_FEATURE_DECODE_LAYER3 = 8,
    MPG123_FEATURE_DECODE_ACCURATE = 9,
    MPG123_FEATURE_DECODE_DOWNSAMPLE = 10,
    MPG123_FEATURE_DECODE_NTOM = 11,
    MPG123_FEATURE_PARSE_ICY = 12
} ;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/dither.c"
union __anonunion_fi_49 {
   uint32_t i ;
   float f ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
struct newhuff {
   unsigned int linbits ;
   short *table ;
};
#line 50 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
struct gr_info_s {
   int scfsi ;
   unsigned int part2_3_length ;
   unsigned int big_values ;
   unsigned int scalefac_compress ;
   unsigned int block_type ;
   unsigned int mixed_block_flag ;
   unsigned int table_select[3] ;
   unsigned int subblock_gain[3] ;
   unsigned int maxband[3] ;
   unsigned int maxbandl ;
   unsigned int maxb ;
   unsigned int region1start ;
   unsigned int region2start ;
   unsigned int preflag ;
   unsigned int scalefac_scale ;
   unsigned int count1table_select ;
   float *full_gain[3] ;
   float *pow2gain ;
};
#line 72 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
struct __anonstruct_ch_58 {
   struct gr_info_s gr[2] ;
};
#line 72 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
struct III_sideinfo {
   unsigned int main_data_begin ;
   unsigned int private_bits ;
   struct __anonstruct_ch_58 ch[2] ;
};
#line 80 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
struct bandInfoStruct {
   int longIdx[23] ;
   int longDiff[22] ;
   int shortIdx[14] ;
   int shortDiff[13] ;
};
#line 41 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/sample.h"
union __anonunion_u_fi_58 {
   float f ;
   int32_t i ;
};
#line 113 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/compat.h"
typedef unsigned long size_p;
#line 134 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
enum mpg123_parms {
    MPG123_VERBOSE = 0,
    MPG123_FLAGS = 1,
    MPG123_ADD_FLAGS = 2,
    MPG123_FORCE_RATE = 3,
    MPG123_DOWN_SAMPLE = 4,
    MPG123_RVA = 5,
    MPG123_DOWNSPEED = 6,
    MPG123_UPSPEED = 7,
    MPG123_START_FRAME = 8,
    MPG123_DECODE_FRAMES = 9,
    MPG123_ICY_INTERVAL = 10,
    MPG123_OUTSCALE = 11,
    MPG123_TIMEOUT = 12,
    MPG123_REMOVE_FLAGS = 13,
    MPG123_RESYNC_LIMIT = 14,
    MPG123_INDEX_SIZE = 15,
    MPG123_PREFRAMES = 16
} ;
#line 588
enum mpg123_channels {
    MPG123_LEFT = 1,
    MPG123_RIGHT = 2,
    MPG123_LR = 3
} ;
#line 713
enum mpg123_state {
    MPG123_ACCURATE = 1
} ;
#line 787
enum mpg123_text_encoding {
    mpg123_text_unknown = 0,
    mpg123_text_utf8 = 1,
    mpg123_text_latin1 = 2,
    mpg123_text_icy = 3,
    mpg123_text_cp1252 = 4,
    mpg123_text_utf16 = 5,
    mpg123_text_utf16bom = 6,
    mpg123_text_utf16be = 7,
    mpg123_text_max = 7
} ;
#line 871 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
struct __anonstruct_mpg123_id3v1_52 {
   char tag[3] ;
   char title[30] ;
   char artist[30] ;
   char album[30] ;
   char year[4] ;
   char comment[30] ;
   unsigned char genre ;
};
#line 871 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
typedef struct __anonstruct_mpg123_id3v1_52 mpg123_id3v1;
#line 929 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
typedef struct mpg123_pars_struct mpg123_pars;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_6 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_6 fd_set;
#line 14 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synths.h"
enum synth_resample {
    r_none = -1,
    r_1to1 = 0,
    r_2to1 = 1,
    r_4to1 = 2,
    r_ntom = 3,
    r_limit = 4
} ;
#line 27
enum synth_format {
    f_none = -1,
    f_16 = 0,
    f_8 = 1,
    f_real = 2,
    f_32 = 3,
    f_limit = 4
} ;
#line 26 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/getcpuflags.h"
struct cpuflags {
   unsigned int id ;
   unsigned int std ;
   unsigned int std2 ;
   unsigned int ext ;
};
#line 18 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
enum frame_types {
    unknown = -2,
    text = -1,
    comment = 0,
    extra = 1,
    rva2 = 2,
    uslt = 3
} ;
#line 22 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
typedef void (*text_converter)(mpg123_string *sb , unsigned char const   *source ,
                               size_t len , int const   noquiet );
#line 641 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
enum mpg123_version {
    MPG123_1_0 = 0,
    MPG123_2_0 = 1,
    MPG123_2_5 = 2
} ;
#line 650
enum mpg123_mode {
    MPG123_M_STEREO = 0,
    MPG123_M_JOINT = 1,
    MPG123_M_DUAL = 2,
    MPG123_M_MONO = 3
} ;
#line 659
enum mpg123_flags {
    MPG123_CRC = 1,
    MPG123_COPYRIGHT = 2,
    MPG123_PRIVATE = 4,
    MPG123_ORIGINAL = 8
} ;
#line 667 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
struct mpg123_frameinfo {
   enum mpg123_version version ;
   int layer ;
   long rate ;
   enum mpg123_mode mode ;
   int mode_ext ;
   int framesize ;
   enum mpg123_flags flags ;
   int emphasis ;
   int bitrate ;
   int abr_rate ;
   enum mpg123_vbr vbr ;
};
#line 139 "/usr/include/stdint.h"
typedef long long intmax_t;
#line 102 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/compat.h"
typedef intmax_t off_p;
#line 20 "../../src/module.h"
struct audio_output_struct;
#line 22 "../../src/module.h"
struct mpg123_module_struct {
   int const   api_version ;
   char const   *name ;
   char const   *description ;
   char const   *revision ;
   void *handle ;
   int (*init_output)(struct audio_output_struct *ao ) ;
};
#line 22 "../../src/module.h"
typedef struct mpg123_module_struct mpg123_module_t;
#line 39 "../../src/audio.h"
struct audio_output_struct {
   int fn ;
   void *userptr ;
   int (*open)(struct audio_output_struct * ) ;
   int (*get_formats)(struct audio_output_struct * ) ;
   int (*write)(struct audio_output_struct * , unsigned char * , int  ) ;
   void (*flush)(struct audio_output_struct * ) ;
   int (*close)(struct audio_output_struct * ) ;
   int (*deinit)(struct audio_output_struct * ) ;
   mpg123_module_t *module ;
   char *device ;
   int flags ;
   long rate ;
   long gain ;
   int channels ;
   int format ;
   int is_open ;
   int auxflags ;
};
#line 39 "../../src/audio.h"
typedef struct audio_output_struct audio_output_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 186 "/usr/include/bits/types.h"
typedef char *__caddr_t;
#line 117 "/usr/include/sys/types.h"
typedef __caddr_t caddr_t;
#line 85 "../src/libmpg123/compat.h"
typedef unsigned char byte;
#line 28 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.h"
struct __anonstruct_txfermem_49 {
   size_t freeindex ;
   size_t readindex ;
   int fd[2] ;
   int wakeme[2] ;
   byte *data ;
   byte *metadata ;
   size_t size ;
   size_t metasize ;
   long rate ;
   int channels ;
   int format ;
   int justwait ;
};
#line 28 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.h"
typedef struct __anonstruct_txfermem_49 txfermem;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_fmt_58 {
   byte FormatTag[2] ;
   byte Channels[2] ;
   byte SamplesPerSec[4] ;
   byte AvgBytesPerSec[4] ;
   byte BlockAlign[2] ;
   byte BitsPerSample[2] ;
};
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_data_59 {
   byte dataheader[4] ;
   byte datalen[4] ;
};
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_WAVE_57 {
   byte WAVEID[4] ;
   byte fmtheader[4] ;
   byte fmtlen[4] ;
   struct __anonstruct_fmt_58 fmt ;
   struct __anonstruct_data_59 data ;
};
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_RIFF_56 {
   byte riffheader[4] ;
   byte WAVElen[4] ;
   struct __anonstruct_WAVE_57 WAVE ;
};
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_fmt_62 {
   byte FormatTag[2] ;
   byte Channels[2] ;
   byte SamplesPerSec[4] ;
   byte AvgBytesPerSec[4] ;
   byte BlockAlign[2] ;
   byte BitsPerSample[2] ;
   byte cbSize[2] ;
};
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_fact_63 {
   byte samplelen[4] ;
};
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_data_64 {
   byte dataheader[4] ;
   byte datalen[4] ;
};
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_WAVE_61 {
   byte WAVEID[4] ;
   byte fmtheader[4] ;
   byte fmtlen[4] ;
   struct __anonstruct_fmt_62 fmt ;
   byte factheader[4] ;
   byte factlen[4] ;
   struct __anonstruct_fact_63 fact ;
   struct __anonstruct_data_64 data ;
};
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_RIFF_FLOAT_60 {
   byte riffheader[4] ;
   byte WAVElen[4] ;
   struct __anonstruct_WAVE_61 WAVE ;
};
#line 36 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
struct auhead {
   byte magic[4] ;
   byte headlen[4] ;
   byte datalen[4] ;
   byte encoding[4] ;
   byte rate[4] ;
   byte channels[4] ;
   byte dummy[8] ;
};
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
struct parameter {
   int aggressive ;
   int shuffle ;
   int remote ;
   int remote_err ;
   int outmode ;
   int quiet ;
   int xterm_title ;
   long usebuffer ;
   int verbose ;
   char *output_module ;
   char *output_device ;
   int output_flags ;
   int term_ctrl ;
   int checkrange ;
   int force_reopen ;
   int test_cpu ;
   long realtime ;
   char *filename ;
   long listentry ;
   char *listname ;
   int long_id3 ;
   int list_cpu ;
   char *cpu ;
   char *fifo ;
   long timeout ;
   long loop ;
   int delay ;
   int index ;
   int down_sample ;
   long rva ;
   long halfspeed ;
   long doublespeed ;
   long start_frame ;
   long frame_number ;
   long outscale ;
   int flags ;
   long force_rate ;
   int talk_icy ;
   long resync_limit ;
   int smooth ;
   double pitch ;
   int ignore_mime ;
   char *proxyurl ;
   int keep_open ;
   int force_utf8 ;
   long index_size ;
   char *force_encoding ;
   double preload ;
   long preframes ;
   long gain ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 32 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
struct keydef {
   char const   key ;
   char const   key2 ;
   char const   *desc ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 19 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.h"
enum __anonenum_proxystate_54 {
    PROXY_UNKNOWN = 0,
    PROXY_NONE = 1,
    PROXY_HOST = 2,
    PROXY_ADDR = 3
} ;
#line 19 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.h"
struct httpdata {
   mpg123_string content_type ;
   mpg123_string icy_name ;
   mpg123_string icy_url ;
   off_t icy_interval ;
   mpg123_string proxyhost ;
   mpg123_string proxyport ;
   enum __anonenum_proxystate_54 proxystate ;
};
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.h"
enum playlist_type {
    UNKNOWN = 0,
    M3U = 1,
    PLS = 2,
    NO_LIST = 3
} ;
#line 15 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.h"
struct listitem {
   char *url ;
   char freeit ;
   size_t playcount ;
};
#line 22 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.h"
struct playlist_struct {
   FILE *file ;
   size_t entry ;
   size_t playcount ;
   long loop ;
   size_t size ;
   size_t fill ;
   size_t pos ;
   size_t alloc_step ;
   struct listitem *list ;
   mpg123_string linebuf ;
   mpg123_string dir ;
   enum playlist_type type ;
};
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 27 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/metaprint.c"
enum __anonenum_ti_56 {
    TITLE = 0,
    ARTIST = 1,
    ALBUM = 2,
    COMMENT = 3,
    YEAR = 4,
    GENRE = 5,
    FIELDS = 6
} ;
#line 137
enum __anonenum_state_57 {
    nothing = 0,
    number = 1,
    outtahere = 2
} ;
#line 148 "/usr/include/bits/types.h"
typedef unsigned int __id_t;
#line 105 "/usr/include/sys/types.h"
typedef __id_t id_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 45 "/usr/include/sys/resource.h"
typedef int __priority_which_t;
#line 71 "/usr/include/bits/sched.h"
struct sched_param {
   int __sched_priority ;
};
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.h"
struct __anonstruct_topt_61 {
   char sname ;
   char *lname ;
   int flags ;
   void (*func)(char * ) ;
   void *var ;
   long value ;
};
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.h"
typedef struct __anonstruct_topt_61 topt;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 275 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 543 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_5 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_5 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_43 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_43 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 251 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
struct enc_desc {
   int code ;
   char const   *longname ;
   char const   *name ;
   unsigned char const   nlen ;
};
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
#line 350
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 88 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/compat.h"
void *safe_realloc(void *ptr , size_t size ) ;
#line 131
int compat_open(char const   *filename , int mode___0 ) ;
#line 428 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
int __attribute__((__force_align_arg_pointer__))  mpg123_open_64(mpg123_handle *mh___0 ,
                                                                 char const   *path ) ;
#line 433
int __attribute__((__force_align_arg_pointer__))  mpg123_open_fd_64(mpg123_handle *mh___0 ,
                                                                    int fd ) ;
#line 447
int __attribute__((__force_align_arg_pointer__))  mpg123_close(mpg123_handle *mh___0 ) ;
#line 485
int __attribute__((__force_align_arg_pointer__))  mpg123_decode_frame_64(mpg123_handle *mh___0 ,
                                                                         off_t *num ,
                                                                         unsigned char **audio ,
                                                                         size_t *bytes ) ;
#line 494
int __attribute__((__force_align_arg_pointer__))  mpg123_framebyframe_decode_64(mpg123_handle *mh___0 ,
                                                                                off_t *num ,
                                                                                unsigned char **audio ,
                                                                                size_t *bytes ) ;
#line 526
off_t __attribute__((__force_align_arg_pointer__))  mpg123_tell_64(mpg123_handle *mh___0 ) ;
#line 529
off_t __attribute__((__force_align_arg_pointer__))  mpg123_tellframe_64(mpg123_handle *mh___0 ) ;
#line 532
off_t __attribute__((__force_align_arg_pointer__))  mpg123_tell_stream_64(mpg123_handle *mh___0 ) ;
#line 537
off_t __attribute__((__force_align_arg_pointer__))  mpg123_seek_64(mpg123_handle *mh___0 ,
                                                                   off_t sampleoff ,
                                                                   int whence ) ;
#line 544
off_t __attribute__((__force_align_arg_pointer__))  mpg123_feedseek_64(mpg123_handle *mh___0 ,
                                                                       off_t sampleoff ,
                                                                       int whence ,
                                                                       off_t *input_offset ) ;
#line 549
off_t __attribute__((__force_align_arg_pointer__))  mpg123_seek_frame_64(mpg123_handle *mh___0 ,
                                                                         off_t offset___0 ,
                                                                         int whence ) ;
#line 554
off_t __attribute__((__force_align_arg_pointer__))  mpg123_timeframe_64(mpg123_handle *mh___0 ,
                                                                        double seconds ) ;
#line 562
int __attribute__((__force_align_arg_pointer__))  mpg123_index_64(mpg123_handle *mh___0 ,
                                                                  off_t **offsets ,
                                                                  off_t *step___30 ,
                                                                  size_t *fill ) ;
#line 570
int __attribute__((__force_align_arg_pointer__))  mpg123_set_index_64(mpg123_handle *mh___0 ,
                                                                      off_t *offsets ,
                                                                      off_t step___30 ,
                                                                      size_t fill ) ;
#line 578
int __attribute__((__force_align_arg_pointer__))  mpg123_position_64(mpg123_handle *fr ,
                                                                     off_t no , off_t buffsize ,
                                                                     off_t *current_frame ,
                                                                     off_t *frames_left___0 ,
                                                                     double *current_seconds ,
                                                                     double *seconds_left ) ;
#line 698
off_t __attribute__((__force_align_arg_pointer__))  mpg123_length_64(mpg123_handle *mh___0 ) ;
#line 703
int __attribute__((__force_align_arg_pointer__))  mpg123_set_filesize_64(mpg123_handle *mh___0 ,
                                                                         off_t size ) ;
#line 1004
int __attribute__((__force_align_arg_pointer__))  mpg123_replace_reader_handle_64(mpg123_handle *mh___0 ,
                                                                                  ssize_t (*r_read)(void * ,
                                                                                                    void * ,
                                                                                                    size_t  ) ,
                                                                                  off_t (*r_lseek)(void * ,
                                                                                                   off_t  ,
                                                                                                   int  ) ,
                                                                                  void (*cleanup)(void * ) ) ;
#line 81 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/reader.h"
int open_stream_handle(mpg123_handle *fr , void *iohandle ) ;
#line 327 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
int frame_reset(mpg123_handle *fr ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 97 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
static void wrap_io_cleanup(void *handle ) 
{ 
  struct wrap_data *ioh ;

  {
#line 99
  ioh = (struct wrap_data *)handle;
#line 100
  if (ioh->iotype == 2) {
#line 102
    if ((unsigned long )ioh->h_cleanup != (unsigned long )((void *)0)) {
#line 102
      if ((unsigned long )ioh->handle != (unsigned long )((void *)0)) {
        {
#line 103
        (*(ioh->h_cleanup))(ioh->handle);
        }
      }
    }
#line 105
    ioh->handle = (void *)0;
  }
#line 107
  if (ioh->my_fd >= 0) {
    {
#line 109
    close(ioh->my_fd);
#line 110
    ioh->my_fd = -1;
    }
  }
#line 112
  return;
}
}
#line 115 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
static void wrap_destroy(void *handle ) 
{ 
  struct wrap_data *wh ;

  {
  {
#line 117
  wh = (struct wrap_data *)handle;
#line 118
  wrap_io_cleanup(handle);
  }
#line 119
  if ((unsigned long )wh->indextable != (unsigned long )((void *)0)) {
    {
#line 120
    free((void *)wh->indextable);
    }
  }
  {
#line 122
  free((void *)wh);
  }
#line 123
  return;
}
}
#line 126 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
static struct wrap_data *wrap_get(mpg123_handle *mh___0 ) 
{ 
  struct wrap_data *whd ;

  {
#line 129
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 129
    return ((struct wrap_data *)((void *)0));
  }
#line 133
  if ((unsigned long )mh___0->wrapperdata == (unsigned long )((void *)0)) {
    {
#line 136
    mh___0->wrapperdata = malloc((size_t )sizeof(struct wrap_data ));
    }
#line 137
    if ((unsigned long )mh___0->wrapperdata == (unsigned long )((void *)0)) {
#line 139
      mh___0->err = 7;
#line 140
      return ((struct wrap_data *)((void *)0));
    }
#line 143
    mh___0->wrapperclean = & wrap_destroy;
#line 145
    whd = (struct wrap_data *)mh___0->wrapperdata;
#line 146
    whd->indextable = (long *)((void *)0);
#line 147
    whd->iotype = 0;
#line 148
    whd->fd = -1;
#line 149
    whd->my_fd = -1;
#line 150
    whd->r_read = (ssize_t (*)(int  , void * , size_t  ))((void *)0);
#line 151
    whd->r_lseek = (long (*)(int  , long  , int  ))((void *)0);
#line 152
    whd->handle = (void *)0;
#line 153
    whd->r_h_read = (ssize_t (*)(void * , void * , size_t  ))((void *)0);
#line 154
    whd->r_h_lseek = (long (*)(void * , long  , int  ))((void *)0);
#line 155
    whd->h_cleanup = (void (*)(void * ))((void *)0);
  } else {
#line 157
    whd = (struct wrap_data *)mh___0->wrapperdata;
  }
#line 159
  return (whd);
}
}
#line 166 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_decode_frame(mpg123_handle *mh___0 ,
                                                                      long *num ,
                                                                      unsigned char **audio ,
                                                                      size_t *bytes ) 
{ 
  off_t largenum ;
  int err ;

  {
  {
#line 171
  err = (int )mpg123_decode_frame_64(mh___0, & largenum, audio, bytes);
  }
#line 172
  if (err == 0) {
#line 172
    if ((unsigned long )num != (unsigned long )((void *)0)) {
#line 174
      *num = (long )largenum;
#line 175
      if ((off_t )*num != largenum) {
#line 177
        mh___0->err = 42;
#line 178
        err = -1;
      }
    }
  }
#line 181
  return ((int __attribute__((__force_align_arg_pointer__))  )err);
}
}
#line 186 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_framebyframe_decode(mpg123_handle *mh___0 ,
                                                                             long *num ,
                                                                             unsigned char **audio ,
                                                                             size_t *bytes ) 
{ 
  off_t largenum ;
  int err ;

  {
  {
#line 191
  err = (int )mpg123_framebyframe_decode_64(mh___0, & largenum, audio, bytes);
  }
#line 192
  if (err == 0) {
#line 192
    if ((unsigned long )num != (unsigned long )((void *)0)) {
#line 194
      *num = (long )largenum;
#line 195
      if ((off_t )*num != largenum) {
#line 197
        mh___0->err = 42;
#line 198
        err = -1;
      }
    }
  }
#line 201
  return ((int __attribute__((__force_align_arg_pointer__))  )err);
}
}
#line 206 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
long __attribute__((__force_align_arg_pointer__))  mpg123_tell(mpg123_handle *mh___0 ) 
{ 
  long val ;
  off_t largeval ;

  {
  {
#line 211
  largeval = (off_t )mpg123_tell_64(mh___0);
#line 212
  val = (long )largeval;
  }
#line 213
  if ((off_t )val != largeval) {
#line 215
    mh___0->err = 42;
#line 216
    return ((long __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 218
  return ((long __attribute__((__force_align_arg_pointer__))  )val);
}
}
#line 223 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
long __attribute__((__force_align_arg_pointer__))  mpg123_tellframe(mpg123_handle *mh___0 ) 
{ 
  long val ;
  off_t largeval ;

  {
  {
#line 228
  largeval = (off_t )mpg123_tellframe_64(mh___0);
#line 229
  val = (long )largeval;
  }
#line 230
  if ((off_t )val != largeval) {
#line 232
    mh___0->err = 42;
#line 233
    return ((long __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 235
  return ((long __attribute__((__force_align_arg_pointer__))  )val);
}
}
#line 240 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
long __attribute__((__force_align_arg_pointer__))  mpg123_tell_stream(mpg123_handle *mh___0 ) 
{ 
  long val ;
  off_t largeval ;

  {
  {
#line 245
  largeval = (off_t )mpg123_tell_stream_64(mh___0);
#line 246
  val = (long )largeval;
  }
#line 247
  if ((off_t )val != largeval) {
#line 249
    mh___0->err = 42;
#line 250
    return ((long __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 252
  return ((long __attribute__((__force_align_arg_pointer__))  )val);
}
}
#line 257 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
long __attribute__((__force_align_arg_pointer__))  mpg123_seek(mpg123_handle *mh___0 ,
                                                               long sampleoff , int whence ) 
{ 
  long val ;
  off_t largeval ;

  {
  {
#line 262
  largeval = (off_t )mpg123_seek_64(mh___0, (off_t )sampleoff, whence);
#line 263
  val = (long )largeval;
  }
#line 264
  if ((off_t )val != largeval) {
#line 266
    mh___0->err = 42;
#line 267
    return ((long __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 269
  return ((long __attribute__((__force_align_arg_pointer__))  )val);
}
}
#line 274 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
long __attribute__((__force_align_arg_pointer__))  mpg123_feedseek(mpg123_handle *mh___0 ,
                                                                   long sampleoff ,
                                                                   int whence , long *input_offset ) 
{ 
  long val ;
  off_t largeioff ;
  off_t largeval ;

  {
  {
#line 280
  largeval = (off_t )mpg123_feedseek_64(mh___0, (off_t )sampleoff, whence, & largeioff);
  }
#line 282
  if (largeval < 0LL) {
#line 282
    return ((long __attribute__((__force_align_arg_pointer__))  )((long )largeval));
  }
#line 284
  val = (long )largeval;
#line 285
  *input_offset = (long )largeioff;
#line 286
  if ((off_t )val != largeval) {
#line 288
    mh___0->err = 42;
#line 289
    return ((long __attribute__((__force_align_arg_pointer__))  )-1);
  } else
#line 286
  if ((off_t )*input_offset != largeioff) {
#line 288
    mh___0->err = 42;
#line 289
    return ((long __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 291
  return ((long __attribute__((__force_align_arg_pointer__))  )val);
}
}
#line 296 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
long __attribute__((__force_align_arg_pointer__))  mpg123_seek_frame(mpg123_handle *mh___0 ,
                                                                     long frameoff ,
                                                                     int whence ) 
{ 
  long val ;
  off_t largeval ;

  {
  {
#line 301
  largeval = (off_t )mpg123_seek_frame_64(mh___0, (off_t )frameoff, whence);
#line 302
  val = (long )largeval;
  }
#line 303
  if ((off_t )val != largeval) {
#line 305
    mh___0->err = 42;
#line 306
    return ((long __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 308
  return ((long __attribute__((__force_align_arg_pointer__))  )val);
}
}
#line 313 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
long __attribute__((__force_align_arg_pointer__))  mpg123_timeframe(mpg123_handle *mh___0 ,
                                                                    double sec ) 
{ 
  long val ;
  off_t largeval ;

  {
  {
#line 318
  largeval = (off_t )mpg123_timeframe_64(mh___0, sec);
#line 319
  val = (long )largeval;
  }
#line 320
  if ((off_t )val != largeval) {
#line 322
    mh___0->err = 42;
#line 323
    return ((long __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 325
  return ((long __attribute__((__force_align_arg_pointer__))  )val);
}
}
#line 332 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_index(mpg123_handle *mh___0 ,
                                                               long **offsets , long *step___30 ,
                                                               size_t *fill ) 
{ 
  int err ;
  size_t i ;
  long smallstep ;
  size_t thefill ;
  off_t largestep ;
  off_t *largeoffsets ;
  struct wrap_data *whd ;
  void *tmp ;

  {
  {
#line 342
  whd = wrap_get(mh___0);
  }
#line 343
  if ((unsigned long )whd == (unsigned long )((void *)0)) {
#line 343
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 345
  err = (int )mpg123_index_64(mh___0, & largeoffsets, & largestep, & thefill);
  }
#line 346
  if (err != 0) {
#line 346
    return ((int __attribute__((__force_align_arg_pointer__))  )err);
  }
#line 349
  smallstep = (long )largestep;
#line 350
  if ((off_t )smallstep != largestep) {
#line 352
    mh___0->err = 42;
#line 353
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 355
  if ((unsigned long )step___30 != (unsigned long )((void *)0)) {
#line 355
    *step___30 = smallstep;
  }
#line 359
  if (thefill == 0U) {
#line 359
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  }
#line 361
  if ((unsigned long )fill != (unsigned long )((void *)0)) {
#line 361
    *fill = thefill;
  }
  {
#line 364
  tmp = safe_realloc((void *)whd->indextable, (size_t )((unsigned long )*fill * sizeof(long )));
#line 364
  *offsets = (long *)tmp;
  }
#line 365
  if ((unsigned long )*offsets == (unsigned long )((void *)0)) {
#line 367
    mh___0->err = 7;
#line 368
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 370
  whd->indextable = *offsets;
#line 372
  i = (size_t )0;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (i < *fill)) {
#line 372
      goto while_break;
    }
#line 374
    *(whd->indextable + i) = (long )*(largeoffsets + i);
#line 375
    if ((off_t )*(whd->indextable + i) != *(largeoffsets + i)) {
#line 377
      mh___0->err = 42;
#line 378
      return ((int __attribute__((__force_align_arg_pointer__))  )-1);
    }
#line 372
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 389 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_set_index(mpg123_handle *mh___0 ,
                                                                   long *offsets ,
                                                                   long step___30 ,
                                                                   size_t fill ) 
{ 
  int err ;
  size_t i ;
  struct wrap_data *whd ;
  off_t *indextmp ;
  void *tmp ;

  {
  {
#line 396
  whd = wrap_get(mh___0);
  }
#line 397
  if ((unsigned long )whd == (unsigned long )((void *)0)) {
#line 397
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 400
  tmp = malloc((size_t )((unsigned long )fill * sizeof(off_t )));
#line 400
  indextmp = (off_t *)tmp;
  }
#line 401
  if ((unsigned long )indextmp == (unsigned long )((void *)0)) {
#line 403
    mh___0->err = 7;
#line 404
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 407
  if (fill > 0U) {
#line 407
    if ((unsigned long )offsets == (unsigned long )((void *)0)) {
#line 409
      mh___0->err = 26;
#line 410
      err = -1;
    } else {
#line 407
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 415
    i = (size_t )0;
    {
#line 415
    while (1) {
      while_continue: /* CIL Label */ ;
#line 415
      if (! (i < fill)) {
#line 415
        goto while_break;
      }
#line 416
      *(indextmp + i) = (off_t )*(offsets + i);
#line 415
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 418
    err = (int )mpg123_set_index_64(mh___0, indextmp, (off_t )step___30, fill);
    }
  }
  {
#line 420
  free((void *)indextmp);
  }
#line 422
  return ((int __attribute__((__force_align_arg_pointer__))  )err);
}
}
#line 428 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_position(mpg123_handle *mh___0 ,
                                                                  long frame_offset___0 ,
                                                                  long buffered_bytes ,
                                                                  long *current_frame ,
                                                                  long *frames_left___0 ,
                                                                  double *current_seconds ,
                                                                  double *seconds_left ) 
{ 
  off_t curframe ;
  off_t frameleft ;
  long small_curframe ;
  long small_frameleft ;
  int err ;

  {
  {
#line 434
  err = (int )mpg123_position_64(mh___0, (off_t )frame_offset___0, (off_t )buffered_bytes,
                                 & curframe, & frameleft, current_seconds, seconds_left);
  }
#line 435
  if (err != 0) {
#line 435
    return ((int __attribute__((__force_align_arg_pointer__))  )err);
  }
#line 437
  small_curframe = (long )curframe;
#line 438
  small_frameleft = (long )frameleft;
#line 439
  if ((off_t )small_curframe != curframe) {
#line 441
    mh___0->err = 42;
#line 442
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  } else
#line 439
  if ((off_t )small_frameleft != frameleft) {
#line 441
    mh___0->err = 42;
#line 442
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 445
  if ((unsigned long )current_frame != (unsigned long )((void *)0)) {
#line 445
    *current_frame = small_curframe;
  }
#line 447
  if ((unsigned long )frames_left___0 != (unsigned long )((void *)0)) {
#line 447
    *frames_left___0 = small_frameleft;
  }
#line 450
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 455 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
long __attribute__((__force_align_arg_pointer__))  mpg123_length(mpg123_handle *mh___0 ) 
{ 
  long val ;
  off_t largeval ;

  {
  {
#line 460
  largeval = (off_t )mpg123_length_64(mh___0);
#line 461
  val = (long )largeval;
  }
#line 462
  if ((off_t )val != largeval) {
#line 464
    mh___0->err = 42;
#line 465
    return ((long __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 467
  return ((long __attribute__((__force_align_arg_pointer__))  )val);
}
}
#line 473 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_set_filesize(mpg123_handle *mh___0 ,
                                                                      long size ) 
{ 
  int tmp ;

  {
  {
#line 476
  tmp = (int )mpg123_set_filesize_64(mh___0, (off_t )size);
  }
#line 476
  return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
}
}
#line 498 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
ssize_t wrap_read(void *handle , void *buf , size_t count ) 
{ 
  struct wrap_data *ioh ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 500
  ioh = (struct wrap_data *)handle;
  {
#line 503
  if (ioh->iotype == 1) {
#line 503
    goto case_1;
  }
#line 504
  if (ioh->iotype == 2) {
#line 504
    goto case_2;
  }
#line 501
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 503
  tmp = (*(ioh->r_read))(ioh->fd, buf, count);
  }
#line 503
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 504
  tmp___0 = (*(ioh->r_h_read))(ioh->handle, buf, count);
  }
#line 504
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 506
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c:%i] error: Serious breakage - bad IO type in LFS wrapper!\n",
          506);
  }
#line 507
  return (-1);
}
}
#line 511 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
off_t wrap_lseek(void *handle , off_t offset___0 , int whence ) 
{ 
  struct wrap_data *ioh ;
  long smalloff ;
  long tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 513
  ioh = (struct wrap_data *)handle;
#line 514
  smalloff = (long )offset___0;
#line 515
  if ((off_t )smalloff == offset___0) {
    {
#line 519
    if (ioh->iotype == 1) {
#line 519
      goto case_1;
    }
#line 520
    if (ioh->iotype == 2) {
#line 520
      goto case_2;
    }
#line 517
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 519
    tmp = (*(ioh->r_lseek))(ioh->fd, smalloff, whence);
    }
#line 519
    return ((off_t )tmp);
    case_2: /* CIL Label */ 
    {
#line 520
    tmp___0 = (*(ioh->r_h_lseek))(ioh->handle, smalloff, whence);
    }
#line 520
    return ((off_t )tmp___0);
    switch_break: /* CIL Label */ ;
    }
    {
#line 522
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c:%i] error: Serious breakage - bad IO type in LFS wrapper!\n",
            522);
    }
#line 523
    return ((off_t )-1);
  } else {
    {
#line 527
    tmp___1 = __errno_location();
#line 527
    *tmp___1 = 75;
    }
#line 528
    return ((off_t )-1);
  }
}
}
#line 546 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
static ssize_t fallback_read(int fd , void *buf , size_t count ) 
{ 
  ssize_t tmp ;

  {
  {
#line 548
  tmp = read(fd, buf, count);
  }
#line 548
  return (tmp);
}
}
#line 551 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
static long fallback_lseek(int fd , long offset___0 , int whence ) 
{ 
  long newpos_long ;
  off_t newpos ;
  int *tmp ;

  {
  {
#line 556
  newpos = lseek(fd, (__off64_t )offset___0, whence);
#line 557
  newpos_long = (long )newpos;
  }
#line 558
  if ((off_t )newpos_long == newpos) {
#line 559
    return (newpos_long);
  } else {
    {
#line 562
    tmp = __errno_location();
#line 562
    *tmp = 75;
    }
#line 563
    return (-1L);
  }
}
}
#line 568 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_replace_reader(mpg123_handle *mh___0 ,
                                                                        ssize_t (*r_read)(int  ,
                                                                                          void * ,
                                                                                          size_t  ) ,
                                                                        long (*r_lseek)(int  ,
                                                                                        long  ,
                                                                                        int  ) ) 
{ 
  struct wrap_data *ioh ;

  {
#line 572
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 572
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 574
  mpg123_close(mh___0);
#line 575
  ioh = wrap_get(mh___0);
  }
#line 576
  if ((unsigned long )ioh == (unsigned long )((void *)0)) {
#line 576
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 579
  if ((unsigned long )r_read == (unsigned long )((void *)0)) {
#line 579
    if ((unsigned long )r_lseek == (unsigned long )((void *)0)) {
#line 582
      ioh->iotype = 0;
#line 583
      ioh->fd = -1;
#line 584
      ioh->r_read = (ssize_t (*)(int  , void * , size_t  ))((void *)0);
#line 585
      ioh->r_lseek = (long (*)(int  , long  , int  ))((void *)0);
    } else {
#line 579
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 589
    ioh->iotype = 1;
#line 590
    ioh->fd = -1;
#line 591
    if ((unsigned long )r_read != (unsigned long )((void *)0)) {
#line 591
      ioh->r_read = r_read;
    } else {
#line 591
      ioh->r_read = & fallback_read;
    }
#line 592
    if ((unsigned long )r_lseek != (unsigned long )((void *)0)) {
#line 592
      ioh->r_lseek = r_lseek;
    } else {
#line 592
      ioh->r_lseek = & fallback_lseek;
    }
  }
#line 596
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 599 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_replace_reader_handle(mpg123_handle *mh___0 ,
                                                                               ssize_t (*r_read)(void * ,
                                                                                                 void * ,
                                                                                                 size_t  ) ,
                                                                               long (*r_lseek)(void * ,
                                                                                               long  ,
                                                                                               int  ) ,
                                                                               void (*cleanup)(void * ) ) 
{ 
  struct wrap_data *ioh ;

  {
#line 603
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 603
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 605
  mpg123_close(mh___0);
#line 606
  ioh = wrap_get(mh___0);
  }
#line 607
  if ((unsigned long )ioh == (unsigned long )((void *)0)) {
#line 607
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 609
  ioh->iotype = 2;
#line 610
  ioh->handle = (void *)0;
#line 611
  ioh->r_h_read = r_read;
#line 612
  ioh->r_h_lseek = r_lseek;
#line 613
  ioh->h_cleanup = cleanup;
#line 616
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 626 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_open(mpg123_handle *mh___0 ,
                                                              char const   *path ) 
{ 
  struct wrap_data *ioh ;
  int err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 631
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 631
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 633
  ioh = (struct wrap_data *)mh___0->wrapperdata;
#line 636
  if ((unsigned long )ioh != (unsigned long )((void *)0)) {
#line 636
    if (ioh->iotype == 1) {
      {
#line 639
      err = (int )mpg123_replace_reader_handle_64(mh___0, & wrap_read, & wrap_lseek,
                                                  & wrap_io_cleanup);
      }
#line 640
      if (err != 0) {
#line 640
        return ((int __attribute__((__force_align_arg_pointer__))  )-1);
      }
      {
#line 643
      frame_reset(mh___0);
#line 648
      ioh->my_fd = compat_open(path, 0);
      }
#line 649
      if (ioh->my_fd < 0) {
#line 651
        if (! (mh___0->p.flags & 32L)) {
          {
#line 651
          tmp = __errno_location();
#line 651
          tmp___0 = strerror(*tmp);
#line 651
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c:%i] error: Cannot open file %s: %s\n",
                  651, path, tmp___0);
          }
        }
#line 653
        mh___0->err = 22;
#line 654
        return ((int __attribute__((__force_align_arg_pointer__))  )-1);
      }
      {
#line 657
      ioh->fd = ioh->my_fd;
#line 659
      err = open_stream_handle(mh___0, (void *)ioh);
      }
#line 660
      if (err != 0) {
        {
#line 662
        wrap_io_cleanup((void *)ioh);
        }
#line 663
        return ((int __attribute__((__force_align_arg_pointer__))  )-1);
      }
#line 666
      return ((int __attribute__((__force_align_arg_pointer__))  )0);
    } else {
      {
#line 668
      tmp___1 = (int )mpg123_open_64(mh___0, path);
      }
#line 668
      return ((int __attribute__((__force_align_arg_pointer__))  )tmp___1);
    }
  } else {
    {
#line 668
    tmp___1 = (int )mpg123_open_64(mh___0, path);
    }
#line 668
    return ((int __attribute__((__force_align_arg_pointer__))  )tmp___1);
  }
}
}
#line 680 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_open_fd(mpg123_handle *mh___0 ,
                                                                 int fd ) 
{ 
  struct wrap_data *ioh ;
  int err ;
  int tmp ;

  {
#line 685
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 685
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 687
  mpg123_close(mh___0);
#line 688
  ioh = (struct wrap_data *)mh___0->wrapperdata;
  }
#line 689
  if ((unsigned long )ioh != (unsigned long )((void *)0)) {
#line 689
    if (ioh->iotype == 1) {
      {
#line 692
      err = (int )mpg123_replace_reader_handle_64(mh___0, & wrap_read, & wrap_lseek,
                                                  & wrap_io_cleanup);
      }
#line 693
      if (err != 0) {
#line 693
        return ((int __attribute__((__force_align_arg_pointer__))  )-1);
      }
      {
#line 696
      frame_reset(mh___0);
#line 698
      ioh->fd = fd;
#line 700
      err = open_stream_handle(mh___0, (void *)ioh);
      }
#line 701
      if (err != 0) {
        {
#line 703
        wrap_io_cleanup((void *)ioh);
        }
#line 704
        return ((int __attribute__((__force_align_arg_pointer__))  )-1);
      }
#line 707
      return ((int __attribute__((__force_align_arg_pointer__))  )0);
    } else {
      {
#line 709
      tmp = (int )mpg123_open_fd_64(mh___0, fd);
      }
#line 709
      return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
    }
  } else {
    {
#line 709
    tmp = (int )mpg123_open_fd_64(mh___0, fd);
    }
#line 709
    return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
  }
}
}
#line 712 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/lfs_wrap.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_open_handle(mpg123_handle *mh___0 ,
                                                                     void *handle ) 
{ 
  struct wrap_data *ioh ;
  int err ;

  {
#line 717
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 717
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 719
  mpg123_close(mh___0);
#line 720
  ioh = (struct wrap_data *)mh___0->wrapperdata;
  }
#line 721
  if ((unsigned long )ioh != (unsigned long )((void *)0)) {
#line 721
    if (ioh->iotype == 2) {
#line 721
      if ((unsigned long )ioh->r_h_read != (unsigned long )((void *)0)) {
        {
#line 725
        err = (int )mpg123_replace_reader_handle_64(mh___0, & wrap_read, & wrap_lseek,
                                                    & wrap_io_cleanup);
        }
#line 726
        if (err != 0) {
#line 726
          return ((int __attribute__((__force_align_arg_pointer__))  )-1);
        }
        {
#line 728
        ioh->handle = handle;
#line 729
        err = open_stream_handle(mh___0, (void *)ioh);
        }
#line 730
        if (err != 0) {
          {
#line 732
          wrap_io_cleanup((void *)ioh);
          }
#line 733
          return ((int __attribute__((__force_align_arg_pointer__))  )-1);
        }
#line 736
        return ((int __attribute__((__force_align_arg_pointer__))  )0);
      } else {
#line 741
        mh___0->err = 41;
#line 742
        return ((int __attribute__((__force_align_arg_pointer__))  )-1);
      }
    } else {
#line 741
      mh___0->err = 41;
#line 742
      return ((int __attribute__((__force_align_arg_pointer__))  )-1);
    }
  } else {
#line 741
    mh___0->err = 41;
#line 742
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
}
}
#line 212 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
int mpg123_feature(enum mpg123_feature_set  const  key ) ;
#line 4 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/feature.c"
int mpg123_feature(enum mpg123_feature_set  const  key ) 
{ 


  {
  {
#line 8
  if ((unsigned int const   )key == 0U) {
#line 8
    goto case_0;
  }
#line 15
  if ((unsigned int const   )key == 1U) {
#line 15
    goto case_1;
  }
#line 22
  if ((unsigned int const   )key == 2U) {
#line 22
    goto case_2;
  }
#line 29
  if ((unsigned int const   )key == 3U) {
#line 29
    goto case_3;
  }
#line 36
  if ((unsigned int const   )key == 5U) {
#line 36
    goto case_5;
  }
#line 43
  if ((unsigned int const   )key == 6U) {
#line 43
    goto case_6;
  }
#line 50
  if ((unsigned int const   )key == 7U) {
#line 50
    goto case_7;
  }
#line 57
  if ((unsigned int const   )key == 8U) {
#line 57
    goto case_8;
  }
#line 64
  if ((unsigned int const   )key == 9U) {
#line 64
    goto case_9;
  }
#line 71
  if ((unsigned int const   )key == 10U) {
#line 71
    goto case_10;
  }
#line 78
  if ((unsigned int const   )key == 11U) {
#line 78
    goto case_11;
  }
#line 85
  if ((unsigned int const   )key == 12U) {
#line 85
    goto case_12;
  }
#line 92
  if ((unsigned int const   )key == 4U) {
#line 92
    goto case_4;
  }
#line 99
  goto switch_default;
  case_0: /* CIL Label */ 
#line 12
  return (0);
  case_1: /* CIL Label */ 
#line 19
  return (1);
  case_2: /* CIL Label */ 
#line 26
  return (1);
  case_3: /* CIL Label */ 
#line 33
  return (1);
  case_5: /* CIL Label */ 
#line 40
  return (1);
  case_6: /* CIL Label */ 
#line 47
  return (1);
  case_7: /* CIL Label */ 
#line 54
  return (1);
  case_8: /* CIL Label */ 
#line 61
  return (1);
  case_9: /* CIL Label */ 
#line 68
  return (0);
  case_10: /* CIL Label */ 
#line 75
  return (1);
  case_11: /* CIL Label */ 
#line 82
  return (1);
  case_12: /* CIL Label */ 
#line 89
  return (1);
  case_4: /* CIL Label */ 
#line 94
  return (1);
  switch_default: /* CIL Label */ 
#line 99
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 23 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/dither.h"
void dither_table_init(float *dithertable ) ;
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/dither.c"
unsigned int const   init_seed  =    (uint32_t const   )2463534242UL;
#line 22 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/dither.c"
static float rand_xorshift32(uint32_t *seed ) 
{ 
  union __anonunion_fi_49 fi ;

  {
#line 30
  fi.i = *seed;
#line 31
  fi.i ^= fi.i << 13;
#line 32
  fi.i ^= fi.i >> 17;
#line 33
  fi.i ^= fi.i << 5;
#line 34
  *seed = fi.i;
#line 38
  fi.i = (fi.i >> 9) | 1065353216U;
#line 39
  fi.f -= 1.5f;
#line 44
  return (fi.f);
}
}
#line 65 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/dither.c"
static void highpass_tpdf_noise(float *table , size_t count ) 
{ 
  size_t i ;
  uint32_t seed ;
  size_t lap ;
  size_t tmp ;
  float input_noise ;
  float xv[9] ;
  float yv[9] ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
#line 68
  seed = (uint32_t )init_seed;
#line 70
  if (count > 200U) {
#line 70
    tmp = (size_t )100;
  } else {
#line 70
    tmp = count / 2U;
  }
#line 70
  lap = tmp;
#line 75
  i = (size_t )0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < 9U)) {
#line 75
      goto while_break;
    }
#line 77
    tmp___0 = 0.0f;
#line 77
    yv[i] = tmp___0;
#line 77
    xv[i] = tmp___0;
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  i = (size_t )0;
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (i < count + lap)) {
#line 80
      goto while_break___0;
    }
#line 82
    if (i == count) {
#line 82
      seed = (uint32_t )init_seed;
    }
    {
#line 85
    tmp___1 = rand_xorshift32(& seed);
#line 85
    tmp___2 = rand_xorshift32(& seed);
#line 85
    input_noise = tmp___1 + tmp___2;
#line 90
    xv[0] = xv[1];
#line 90
    xv[1] = xv[2];
#line 90
    xv[2] = xv[3];
#line 90
    xv[3] = xv[4];
#line 90
    xv[4] = xv[5];
#line 90
    xv[5] = xv[6];
#line 90
    xv[6] = xv[7];
#line 90
    xv[7] = xv[8];
#line 91
    xv[8] = (float )((double )input_noise / 1.382814179e+07);
#line 92
    yv[0] = yv[1];
#line 92
    yv[1] = yv[2];
#line 92
    yv[2] = yv[3];
#line 92
    yv[3] = yv[4];
#line 92
    yv[4] = yv[5];
#line 92
    yv[5] = yv[6];
#line 92
    yv[6] = yv[7];
#line 92
    yv[7] = yv[8];
#line 93
    yv[8] = (float )(((((((((double )(((((xv[0] + xv[8]) - (float )8 * (xv[1] + xv[7])) + (float )28 * (xv[2] + xv[6])) - (float )56 * (xv[3] + xv[5])) + (float )70 * xv[4]) + - 0.6706204984 * (double )yv[0]) + - 5.3720827038 * (double )yv[1]) + - 19.0865382480 * (double )yv[2]) + - 39.2831607860 * (double )yv[3]) + - 51.2308985070 * (double )yv[4]) + - 43.3590135780 * (double )yv[5]) + - 23.2632305320 * (double )yv[6]) + - 7.2370122050 * (double )yv[7]);
    }
#line 99
    if (i >= lap) {
#line 99
      *(table + (i - lap)) = yv[8] * 3.0f;
    }
#line 80
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  return;
}
}
#line 118 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/dither.c"
void dither_table_init(float *dithertable ) 
{ 


  {
  {
#line 120
  highpass_tpdf_noise(dithertable, (size_t )65536);
  }
#line 121
  return;
}
}
#line 188 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
void dct64_i386(float *a , float *b , float *c ) ;
#line 228
float *pnts[5] ;
#line 19 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/dct64_i386.c"
static void dct64_1(float *out0 , float *out1 , float *b1 , float *b2 , float *samples ) 
{ 
  register float *costab ;
  register float *costab___0 ;
  register float *costab___1 ;
  register float cos0 ;
  register float cos1 ;
  register float cos0___0 ;
  float tmp ;

  {
#line 22
  costab = pnts[0];
#line 24
  *(b1 + 0) = *(samples + 0) + *(samples + 31);
#line 25
  *(b1 + 1) = *(samples + 1) + *(samples + 30);
#line 26
  *(b1 + 31) = (*(samples + 0) - *(samples + 31)) * *(costab + 0);
#line 27
  *(b1 + 30) = (*(samples + 1) - *(samples + 30)) * *(costab + 1);
#line 29
  *(b1 + 2) = *(samples + 2) + *(samples + 29);
#line 30
  *(b1 + 3) = *(samples + 3) + *(samples + 28);
#line 31
  *(b1 + 29) = (*(samples + 2) - *(samples + 29)) * *(costab + 2);
#line 32
  *(b1 + 28) = (*(samples + 3) - *(samples + 28)) * *(costab + 3);
#line 34
  *(b1 + 4) = *(samples + 4) + *(samples + 27);
#line 35
  *(b1 + 5) = *(samples + 5) + *(samples + 26);
#line 36
  *(b1 + 27) = (*(samples + 4) - *(samples + 27)) * *(costab + 4);
#line 37
  *(b1 + 26) = (*(samples + 5) - *(samples + 26)) * *(costab + 5);
#line 39
  *(b1 + 6) = *(samples + 6) + *(samples + 25);
#line 40
  *(b1 + 7) = *(samples + 7) + *(samples + 24);
#line 41
  *(b1 + 25) = (*(samples + 6) - *(samples + 25)) * *(costab + 6);
#line 42
  *(b1 + 24) = (*(samples + 7) - *(samples + 24)) * *(costab + 7);
#line 44
  *(b1 + 8) = *(samples + 8) + *(samples + 23);
#line 45
  *(b1 + 9) = *(samples + 9) + *(samples + 22);
#line 46
  *(b1 + 23) = (*(samples + 8) - *(samples + 23)) * *(costab + 8);
#line 47
  *(b1 + 22) = (*(samples + 9) - *(samples + 22)) * *(costab + 9);
#line 49
  *(b1 + 10) = *(samples + 10) + *(samples + 21);
#line 50
  *(b1 + 11) = *(samples + 11) + *(samples + 20);
#line 51
  *(b1 + 21) = (*(samples + 10) - *(samples + 21)) * *(costab + 10);
#line 52
  *(b1 + 20) = (*(samples + 11) - *(samples + 20)) * *(costab + 11);
#line 54
  *(b1 + 12) = *(samples + 12) + *(samples + 19);
#line 55
  *(b1 + 13) = *(samples + 13) + *(samples + 18);
#line 56
  *(b1 + 19) = (*(samples + 12) - *(samples + 19)) * *(costab + 12);
#line 57
  *(b1 + 18) = (*(samples + 13) - *(samples + 18)) * *(costab + 13);
#line 59
  *(b1 + 14) = *(samples + 14) + *(samples + 17);
#line 60
  *(b1 + 15) = *(samples + 15) + *(samples + 16);
#line 61
  *(b1 + 17) = (*(samples + 14) - *(samples + 17)) * *(costab + 14);
#line 62
  *(b1 + 16) = (*(samples + 15) - *(samples + 16)) * *(costab + 15);
#line 68
  costab___0 = pnts[1];
#line 70
  *(b2 + 0) = *(b1 + 0) + *(b1 + 15);
#line 71
  *(b2 + 1) = *(b1 + 1) + *(b1 + 14);
#line 72
  *(b2 + 15) = (*(b1 + 0) - *(b1 + 15)) * *(costab___0 + 0);
#line 73
  *(b2 + 14) = (*(b1 + 1) - *(b1 + 14)) * *(costab___0 + 1);
#line 75
  *(b2 + 2) = *(b1 + 2) + *(b1 + 13);
#line 76
  *(b2 + 3) = *(b1 + 3) + *(b1 + 12);
#line 77
  *(b2 + 13) = (*(b1 + 2) - *(b1 + 13)) * *(costab___0 + 2);
#line 78
  *(b2 + 12) = (*(b1 + 3) - *(b1 + 12)) * *(costab___0 + 3);
#line 80
  *(b2 + 4) = *(b1 + 4) + *(b1 + 11);
#line 81
  *(b2 + 5) = *(b1 + 5) + *(b1 + 10);
#line 82
  *(b2 + 11) = (*(b1 + 4) - *(b1 + 11)) * *(costab___0 + 4);
#line 83
  *(b2 + 10) = (*(b1 + 5) - *(b1 + 10)) * *(costab___0 + 5);
#line 85
  *(b2 + 6) = *(b1 + 6) + *(b1 + 9);
#line 86
  *(b2 + 7) = *(b1 + 7) + *(b1 + 8);
#line 87
  *(b2 + 9) = (*(b1 + 6) - *(b1 + 9)) * *(costab___0 + 6);
#line 88
  *(b2 + 8) = (*(b1 + 7) - *(b1 + 8)) * *(costab___0 + 7);
#line 92
  *(b2 + 16) = *(b1 + 16) + *(b1 + 31);
#line 93
  *(b2 + 17) = *(b1 + 17) + *(b1 + 30);
#line 94
  *(b2 + 31) = (*(b1 + 31) - *(b1 + 16)) * *(costab___0 + 0);
#line 95
  *(b2 + 30) = (*(b1 + 30) - *(b1 + 17)) * *(costab___0 + 1);
#line 97
  *(b2 + 18) = *(b1 + 18) + *(b1 + 29);
#line 98
  *(b2 + 19) = *(b1 + 19) + *(b1 + 28);
#line 99
  *(b2 + 29) = (*(b1 + 29) - *(b1 + 18)) * *(costab___0 + 2);
#line 100
  *(b2 + 28) = (*(b1 + 28) - *(b1 + 19)) * *(costab___0 + 3);
#line 102
  *(b2 + 20) = *(b1 + 20) + *(b1 + 27);
#line 103
  *(b2 + 21) = *(b1 + 21) + *(b1 + 26);
#line 104
  *(b2 + 27) = (*(b1 + 27) - *(b1 + 20)) * *(costab___0 + 4);
#line 105
  *(b2 + 26) = (*(b1 + 26) - *(b1 + 21)) * *(costab___0 + 5);
#line 107
  *(b2 + 22) = *(b1 + 22) + *(b1 + 25);
#line 108
  *(b2 + 23) = *(b1 + 23) + *(b1 + 24);
#line 109
  *(b2 + 25) = (*(b1 + 25) - *(b1 + 22)) * *(costab___0 + 6);
#line 110
  *(b2 + 24) = (*(b1 + 24) - *(b1 + 23)) * *(costab___0 + 7);
#line 114
  costab___1 = pnts[2];
#line 116
  *(b1 + 0) = *(b2 + 0) + *(b2 + 7);
#line 117
  *(b1 + 7) = (*(b2 + 0) - *(b2 + 7)) * *(costab___1 + 0);
#line 118
  *(b1 + 1) = *(b2 + 1) + *(b2 + 6);
#line 119
  *(b1 + 6) = (*(b2 + 1) - *(b2 + 6)) * *(costab___1 + 1);
#line 120
  *(b1 + 2) = *(b2 + 2) + *(b2 + 5);
#line 121
  *(b1 + 5) = (*(b2 + 2) - *(b2 + 5)) * *(costab___1 + 2);
#line 122
  *(b1 + 3) = *(b2 + 3) + *(b2 + 4);
#line 123
  *(b1 + 4) = (*(b2 + 3) - *(b2 + 4)) * *(costab___1 + 3);
#line 125
  *(b1 + 8) = *(b2 + 8) + *(b2 + 15);
#line 126
  *(b1 + 15) = (*(b2 + 15) - *(b2 + 8)) * *(costab___1 + 0);
#line 127
  *(b1 + 9) = *(b2 + 9) + *(b2 + 14);
#line 128
  *(b1 + 14) = (*(b2 + 14) - *(b2 + 9)) * *(costab___1 + 1);
#line 129
  *(b1 + 10) = *(b2 + 10) + *(b2 + 13);
#line 130
  *(b1 + 13) = (*(b2 + 13) - *(b2 + 10)) * *(costab___1 + 2);
#line 131
  *(b1 + 11) = *(b2 + 11) + *(b2 + 12);
#line 132
  *(b1 + 12) = (*(b2 + 12) - *(b2 + 11)) * *(costab___1 + 3);
#line 134
  *(b1 + 16) = *(b2 + 16) + *(b2 + 23);
#line 135
  *(b1 + 23) = (*(b2 + 16) - *(b2 + 23)) * *(costab___1 + 0);
#line 136
  *(b1 + 17) = *(b2 + 17) + *(b2 + 22);
#line 137
  *(b1 + 22) = (*(b2 + 17) - *(b2 + 22)) * *(costab___1 + 1);
#line 138
  *(b1 + 18) = *(b2 + 18) + *(b2 + 21);
#line 139
  *(b1 + 21) = (*(b2 + 18) - *(b2 + 21)) * *(costab___1 + 2);
#line 140
  *(b1 + 19) = *(b2 + 19) + *(b2 + 20);
#line 141
  *(b1 + 20) = (*(b2 + 19) - *(b2 + 20)) * *(costab___1 + 3);
#line 143
  *(b1 + 24) = *(b2 + 24) + *(b2 + 31);
#line 144
  *(b1 + 31) = (*(b2 + 31) - *(b2 + 24)) * *(costab___1 + 0);
#line 145
  *(b1 + 25) = *(b2 + 25) + *(b2 + 30);
#line 146
  *(b1 + 30) = (*(b2 + 30) - *(b2 + 25)) * *(costab___1 + 1);
#line 147
  *(b1 + 26) = *(b2 + 26) + *(b2 + 29);
#line 148
  *(b1 + 29) = (*(b2 + 29) - *(b2 + 26)) * *(costab___1 + 2);
#line 149
  *(b1 + 27) = *(b2 + 27) + *(b2 + 28);
#line 150
  *(b1 + 28) = (*(b2 + 28) - *(b2 + 27)) * *(costab___1 + 3);
#line 154
  cos0 = *(pnts[3] + 0);
#line 155
  cos1 = *(pnts[3] + 1);
#line 157
  *(b2 + 0) = *(b1 + 0) + *(b1 + 3);
#line 158
  *(b2 + 3) = (*(b1 + 0) - *(b1 + 3)) * cos0;
#line 159
  *(b2 + 1) = *(b1 + 1) + *(b1 + 2);
#line 160
  *(b2 + 2) = (*(b1 + 1) - *(b1 + 2)) * cos1;
#line 162
  *(b2 + 4) = *(b1 + 4) + *(b1 + 7);
#line 163
  *(b2 + 7) = (*(b1 + 7) - *(b1 + 4)) * cos0;
#line 164
  *(b2 + 5) = *(b1 + 5) + *(b1 + 6);
#line 165
  *(b2 + 6) = (*(b1 + 6) - *(b1 + 5)) * cos1;
#line 167
  *(b2 + 8) = *(b1 + 8) + *(b1 + 11);
#line 168
  *(b2 + 11) = (*(b1 + 8) - *(b1 + 11)) * cos0;
#line 169
  *(b2 + 9) = *(b1 + 9) + *(b1 + 10);
#line 170
  *(b2 + 10) = (*(b1 + 9) - *(b1 + 10)) * cos1;
#line 172
  *(b2 + 12) = *(b1 + 12) + *(b1 + 15);
#line 173
  *(b2 + 15) = (*(b1 + 15) - *(b1 + 12)) * cos0;
#line 174
  *(b2 + 13) = *(b1 + 13) + *(b1 + 14);
#line 175
  *(b2 + 14) = (*(b1 + 14) - *(b1 + 13)) * cos1;
#line 177
  *(b2 + 16) = *(b1 + 16) + *(b1 + 19);
#line 178
  *(b2 + 19) = (*(b1 + 16) - *(b1 + 19)) * cos0;
#line 179
  *(b2 + 17) = *(b1 + 17) + *(b1 + 18);
#line 180
  *(b2 + 18) = (*(b1 + 17) - *(b1 + 18)) * cos1;
#line 182
  *(b2 + 20) = *(b1 + 20) + *(b1 + 23);
#line 183
  *(b2 + 23) = (*(b1 + 23) - *(b1 + 20)) * cos0;
#line 184
  *(b2 + 21) = *(b1 + 21) + *(b1 + 22);
#line 185
  *(b2 + 22) = (*(b1 + 22) - *(b1 + 21)) * cos1;
#line 187
  *(b2 + 24) = *(b1 + 24) + *(b1 + 27);
#line 188
  *(b2 + 27) = (*(b1 + 24) - *(b1 + 27)) * cos0;
#line 189
  *(b2 + 25) = *(b1 + 25) + *(b1 + 26);
#line 190
  *(b2 + 26) = (*(b1 + 25) - *(b1 + 26)) * cos1;
#line 192
  *(b2 + 28) = *(b1 + 28) + *(b1 + 31);
#line 193
  *(b2 + 31) = (*(b1 + 31) - *(b1 + 28)) * cos0;
#line 194
  *(b2 + 29) = *(b1 + 29) + *(b1 + 30);
#line 195
  *(b2 + 30) = (*(b1 + 30) - *(b1 + 29)) * cos1;
#line 199
  cos0___0 = *(pnts[4] + 0);
#line 201
  *(b1 + 0) = *(b2 + 0) + *(b2 + 1);
#line 202
  *(b1 + 1) = (*(b2 + 0) - *(b2 + 1)) * cos0___0;
#line 203
  *(b1 + 2) = *(b2 + 2) + *(b2 + 3);
#line 204
  *(b1 + 3) = (*(b2 + 3) - *(b2 + 2)) * cos0___0;
#line 205
  *(b1 + 2) += *(b1 + 3);
#line 207
  *(b1 + 4) = *(b2 + 4) + *(b2 + 5);
#line 208
  *(b1 + 5) = (*(b2 + 4) - *(b2 + 5)) * cos0___0;
#line 209
  *(b1 + 6) = *(b2 + 6) + *(b2 + 7);
#line 210
  *(b1 + 7) = (*(b2 + 7) - *(b2 + 6)) * cos0___0;
#line 211
  *(b1 + 6) += *(b1 + 7);
#line 212
  *(b1 + 4) += *(b1 + 6);
#line 213
  *(b1 + 6) += *(b1 + 5);
#line 214
  *(b1 + 5) += *(b1 + 7);
#line 216
  *(b1 + 8) = *(b2 + 8) + *(b2 + 9);
#line 217
  *(b1 + 9) = (*(b2 + 8) - *(b2 + 9)) * cos0___0;
#line 218
  *(b1 + 10) = *(b2 + 10) + *(b2 + 11);
#line 219
  *(b1 + 11) = (*(b2 + 11) - *(b2 + 10)) * cos0___0;
#line 220
  *(b1 + 10) += *(b1 + 11);
#line 222
  *(b1 + 12) = *(b2 + 12) + *(b2 + 13);
#line 223
  *(b1 + 13) = (*(b2 + 12) - *(b2 + 13)) * cos0___0;
#line 224
  *(b1 + 14) = *(b2 + 14) + *(b2 + 15);
#line 225
  *(b1 + 15) = (*(b2 + 15) - *(b2 + 14)) * cos0___0;
#line 226
  *(b1 + 14) += *(b1 + 15);
#line 227
  *(b1 + 12) += *(b1 + 14);
#line 228
  *(b1 + 14) += *(b1 + 13);
#line 229
  *(b1 + 13) += *(b1 + 15);
#line 231
  *(b1 + 16) = *(b2 + 16) + *(b2 + 17);
#line 232
  *(b1 + 17) = (*(b2 + 16) - *(b2 + 17)) * cos0___0;
#line 233
  *(b1 + 18) = *(b2 + 18) + *(b2 + 19);
#line 234
  *(b1 + 19) = (*(b2 + 19) - *(b2 + 18)) * cos0___0;
#line 235
  *(b1 + 18) += *(b1 + 19);
#line 237
  *(b1 + 20) = *(b2 + 20) + *(b2 + 21);
#line 238
  *(b1 + 21) = (*(b2 + 20) - *(b2 + 21)) * cos0___0;
#line 239
  *(b1 + 22) = *(b2 + 22) + *(b2 + 23);
#line 240
  *(b1 + 23) = (*(b2 + 23) - *(b2 + 22)) * cos0___0;
#line 241
  *(b1 + 22) += *(b1 + 23);
#line 242
  *(b1 + 20) += *(b1 + 22);
#line 243
  *(b1 + 22) += *(b1 + 21);
#line 244
  *(b1 + 21) += *(b1 + 23);
#line 246
  *(b1 + 24) = *(b2 + 24) + *(b2 + 25);
#line 247
  *(b1 + 25) = (*(b2 + 24) - *(b2 + 25)) * cos0___0;
#line 248
  *(b1 + 26) = *(b2 + 26) + *(b2 + 27);
#line 249
  *(b1 + 27) = (*(b2 + 27) - *(b2 + 26)) * cos0___0;
#line 250
  *(b1 + 26) += *(b1 + 27);
#line 252
  *(b1 + 28) = *(b2 + 28) + *(b2 + 29);
#line 253
  *(b1 + 29) = (*(b2 + 28) - *(b2 + 29)) * cos0___0;
#line 254
  *(b1 + 30) = *(b2 + 30) + *(b2 + 31);
#line 255
  *(b1 + 31) = (*(b2 + 31) - *(b2 + 30)) * cos0___0;
#line 256
  *(b1 + 30) += *(b1 + 31);
#line 257
  *(b1 + 28) += *(b1 + 30);
#line 258
  *(b1 + 30) += *(b1 + 29);
#line 259
  *(b1 + 29) += *(b1 + 31);
#line 262
  *(out0 + 256) = *(b1 + 0);
#line 263
  *(out0 + 192) = *(b1 + 4);
#line 264
  *(out0 + 128) = *(b1 + 2);
#line 265
  *(out0 + 64) = *(b1 + 6);
#line 266
  *(out0 + 0) = *(b1 + 1);
#line 267
  *(out1 + 0) = *(b1 + 1);
#line 268
  *(out1 + 64) = *(b1 + 5);
#line 269
  *(out1 + 128) = *(b1 + 3);
#line 270
  *(out1 + 192) = *(b1 + 7);
#line 273
  *(out0 + 224) = *(b1 + 8) + *(b1 + 12);
#line 274
  *(out0 + 160) = *(b1 + 12) + *(b1 + 10);
#line 275
  *(out0 + 96) = *(b1 + 10) + *(b1 + 14);
#line 276
  *(out0 + 32) = *(b1 + 14) + *(b1 + 9);
#line 277
  *(out1 + 32) = *(b1 + 9) + *(b1 + 13);
#line 278
  *(out1 + 96) = *(b1 + 13) + *(b1 + 11);
#line 279
  *(out1 + 160) = *(b1 + 11) + *(b1 + 15);
#line 280
  *(out1 + 224) = *(b1 + 15);
#line 301
  tmp = *(b1 + 24) + *(b1 + 28);
#line 302
  *(out0 + 240) = tmp + *(b1 + 16);
#line 303
  *(out0 + 208) = tmp + *(b1 + 20);
#line 304
  tmp = *(b1 + 28) + *(b1 + 26);
#line 305
  *(out0 + 176) = tmp + *(b1 + 20);
#line 306
  *(out0 + 144) = tmp + *(b1 + 18);
#line 307
  tmp = *(b1 + 26) + *(b1 + 30);
#line 308
  *(out0 + 112) = tmp + *(b1 + 18);
#line 309
  *(out0 + 80) = tmp + *(b1 + 22);
#line 310
  tmp = *(b1 + 30) + *(b1 + 25);
#line 311
  *(out0 + 48) = tmp + *(b1 + 22);
#line 312
  *(out0 + 16) = tmp + *(b1 + 17);
#line 313
  tmp = *(b1 + 25) + *(b1 + 29);
#line 314
  *(out1 + 16) = tmp + *(b1 + 17);
#line 315
  *(out1 + 48) = tmp + *(b1 + 21);
#line 316
  tmp = *(b1 + 29) + *(b1 + 27);
#line 317
  *(out1 + 80) = tmp + *(b1 + 21);
#line 318
  *(out1 + 112) = tmp + *(b1 + 19);
#line 319
  tmp = *(b1 + 27) + *(b1 + 31);
#line 320
  *(out1 + 144) = tmp + *(b1 + 19);
#line 321
  *(out1 + 176) = tmp + *(b1 + 23);
#line 322
  *(out1 + 208) = *(b1 + 23) + *(b1 + 31);
#line 323
  *(out1 + 240) = *(b1 + 31);
#line 325
  return;
}
}
#line 331 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/dct64_i386.c"
void dct64_i386(float *a , float *b , float *c ) 
{ 
  float bufs[64] ;
  void *__cil_tmp5 ;

  {
  {
#line 334
  dct64_1(a, b, bufs, bufs + 32, c);
  }
#line 335
  return;
}
}
#line 125 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
int synth_1to1_real(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 126
int synth_1to1_real_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 127
int synth_1to1_real_sse(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 128
int synth_1to1_real_stereo_sse(float *bandPtr_l , float *bandPtr_r , mpg123_handle *fr ) ;
#line 133
int synth_1to1_real_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 134
int synth_1to1_real_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 136
int synth_2to1_real(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 137
int synth_2to1_real_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 138
int synth_2to1_real_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 139
int synth_2to1_real_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 140
int synth_4to1_real(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 141
int synth_4to1_real_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 142
int synth_4to1_real_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 143
int synth_4to1_real_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 146
int synth_ntom_real(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 147
int synth_ntom_real_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 148
int synth_ntom_real_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 187
void dct64(float *out0 , float *out1 , float *samples ) ;
#line 264
void do_equalizer(float *bandPtr , int channel , float (*equalizer)[32] ) ;
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_1to1_real(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  float *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;

  {
#line 34
  samples = (float *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 16;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    *samples = ((float )1. / (float )32768) * sum;
#line 85
    j --;
#line 85
    b0 += 0;
#line 85
    window += 16;
#line 85
    samples += step;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  *samples = ((float )1. / (float )32768) * sum___0;
#line 141
  samples += step;
#line 142
  b0 -= 16;
#line 143
  window -= 32;
#line 145
  window += bo1 << 1;
#line 147
  j = 15;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    *samples = ((float )1. / (float )32768) * sum___1;
#line 147
    j --;
#line 147
    b0 -= 32;
#line 147
    window -= 16;
#line 147
    samples += step;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 64UL * sizeof(float ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_1to1_real_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  float samples_tmp[64] ;
  float *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[0][2]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 32)) {
#line 37
      goto while_break;
    }
#line 39
    *((float *)samples) = *tmp1;
#line 40
    samples += sizeof(float );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 32UL * sizeof(float ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_1to1_real_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[0][2]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 64UL * sizeof(float );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 32)) {
#line 57
      goto while_break;
    }
#line 59
    *((float *)samples + 1) = *((float *)samples + 0);
#line 60
    samples += 2UL * sizeof(float );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___0  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_1to1_real_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  float *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float sum___0 ;
  float sum___1 ;

  {
#line 34
  samples = (float *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 16;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    *samples = ((float )1. / (float )32768) * sum;
#line 85
    j --;
#line 85
    b0 += 16;
#line 85
    window += 32;
#line 85
    samples += step___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  *samples = ((float )1. / (float )32768) * sum___0;
#line 141
  samples += step___0;
#line 142
  b0 -= 16;
#line 143
  window -= 32;
#line 145
  window += bo1 << 1;
#line 147
  j = 15;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    *samples = ((float )1. / (float )32768) * sum___1;
#line 147
    j --;
#line 147
    b0 -= 16;
#line 147
    window -= 32;
#line 147
    samples += step___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 64UL * sizeof(float ));
  }
#line 192
  return (clip);
}
}
#line 145 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_real.c"
extern int synth_1to1_real_sse_asm(float *window , float *b0 , float *samples , int bo1 ) ;
#line 146
extern int synth_1to1_real_stereo_sse_asm(float *window , float *b0l , float *b0r ,
                                          float *samples , int bo1 ) ;
#line 147
extern void dct64_real_sse(float *out0 , float *out1 , float *samples ) ;
#line 149 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_real.c"
int synth_1to1_real_sse(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  float *samples ;
  float *b0 ;
  float **buf ;
  int bo1 ;

  {
#line 151
  samples = (float *)(fr->buffer.data + fr->buffer.fill);
#line 156
  if (fr->have_eq_settings) {
    {
#line 156
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 158
  if (! channel) {
#line 160
    (fr->bo) --;
#line 161
    fr->bo &= 15;
#line 162
    buf = fr->real_buffs[0];
  } else {
#line 166
    samples ++;
#line 167
    buf = fr->real_buffs[1];
  }
#line 170
  if (fr->bo & 1) {
    {
#line 172
    b0 = *(buf + 0);
#line 173
    bo1 = fr->bo;
#line 174
    dct64_real_sse(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 178
    b0 = *(buf + 1);
#line 179
    bo1 = fr->bo + 1;
#line 180
    dct64_real_sse(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
  {
#line 183
  synth_1to1_real_sse_asm(fr->decwin, b0, samples, bo1);
  }
#line 185
  if (final) {
#line 185
    fr->buffer.fill += 256U;
  }
#line 187
  return (0);
}
}
#line 190 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_real.c"
int synth_1to1_real_stereo_sse(float *bandPtr_l , float *bandPtr_r , mpg123_handle *fr ) 
{ 
  float *samples ;
  float *b0l ;
  float *b0r ;
  float **bufl ;
  float **bufr ;
  int bo1 ;

  {
#line 192
  samples = (float *)(fr->buffer.data + fr->buffer.fill);
#line 197
  if (fr->have_eq_settings) {
    {
#line 199
    do_equalizer(bandPtr_l, 0, (float (*)[32])(fr->equalizer));
#line 200
    do_equalizer(bandPtr_r, 1, (float (*)[32])(fr->equalizer));
    }
  }
#line 203
  (fr->bo) --;
#line 204
  fr->bo &= 15;
#line 205
  bufl = fr->real_buffs[0];
#line 206
  bufr = fr->real_buffs[1];
#line 208
  if (fr->bo & 1) {
    {
#line 210
    b0l = *(bufl + 0);
#line 211
    b0r = *(bufr + 0);
#line 212
    bo1 = fr->bo;
#line 213
    dct64_real_sse(*(bufl + 1) + ((fr->bo + 1) & 15), *(bufl + 0) + fr->bo, bandPtr_l);
#line 214
    dct64_real_sse(*(bufr + 1) + ((fr->bo + 1) & 15), *(bufr + 0) + fr->bo, bandPtr_r);
    }
  } else {
    {
#line 218
    b0l = *(bufl + 1);
#line 219
    b0r = *(bufr + 1);
#line 220
    bo1 = fr->bo + 1;
#line 221
    dct64_real_sse(*(bufl + 0) + fr->bo, (*(bufl + 1) + fr->bo) + 1, bandPtr_l);
#line 222
    dct64_real_sse(*(bufr + 0) + fr->bo, (*(bufr + 1) + fr->bo) + 1, bandPtr_r);
    }
  }
  {
#line 225
  synth_1to1_real_stereo_sse_asm(fr->decwin, b0l, b0r, samples, bo1);
#line 227
  fr->buffer.fill += 256U;
  }
#line 229
  return (0);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___1  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_2to1_real(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  float *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;

  {
#line 34
  samples = (float *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    *samples = ((float )1. / (float )32768) * sum;
#line 85
    j --;
#line 85
    b0 += 16;
#line 85
    window += 48;
#line 85
    samples += step___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  *samples = ((float )1. / (float )32768) * sum___0;
#line 141
  samples += step___1;
#line 142
  b0 -= 32;
#line 143
  window -= 64;
#line 145
  window += bo1 << 1;
#line 147
  j = 7;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    *samples = ((float )1. / (float )32768) * sum___1;
#line 147
    j --;
#line 147
    b0 -= 48;
#line 147
    window -= 48;
#line 147
    samples += step___1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 32UL * sizeof(float ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_2to1_real_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  float samples_tmp[32] ;
  float *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[1][2]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 16)) {
#line 37
      goto while_break;
    }
#line 39
    *((float *)samples) = *tmp1;
#line 40
    samples += sizeof(float );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 16UL * sizeof(float ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_2to1_real_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[1][2]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 32UL * sizeof(float );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 16)) {
#line 57
      goto while_break;
    }
#line 59
    *((float *)samples + 1) = *((float *)samples + 0);
#line 60
    samples += 2UL * sizeof(float );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___2  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_2to1_real_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  float *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float sum___0 ;
  float sum___1 ;

  {
#line 34
  samples = (float *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    *samples = ((float )1. / (float )32768) * sum;
#line 85
    j --;
#line 85
    b0 += 32;
#line 85
    window += 64;
#line 85
    samples += step___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  *samples = ((float )1. / (float )32768) * sum___0;
#line 141
  samples += step___2;
#line 142
  b0 -= 32;
#line 143
  window -= 64;
#line 145
  window += bo1 << 1;
#line 147
  j = 7;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    *samples = ((float )1. / (float )32768) * sum___1;
#line 147
    j --;
#line 147
    b0 -= 32;
#line 147
    window -= 64;
#line 147
    samples += step___2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 32UL * sizeof(float ));
  }
#line 192
  return (clip);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___3  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_4to1_real(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  float *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;

  {
#line 34
  samples = (float *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    *samples = ((float )1. / (float )32768) * sum;
#line 85
    j --;
#line 85
    b0 += 48;
#line 85
    window += 112;
#line 85
    samples += step___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  *samples = ((float )1. / (float )32768) * sum___0;
#line 141
  samples += step___3;
#line 142
  b0 -= 64;
#line 143
  window -= 128;
#line 145
  window += bo1 << 1;
#line 147
  j = 3;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    *samples = ((float )1. / (float )32768) * sum___1;
#line 147
    j --;
#line 147
    b0 -= 80;
#line 147
    window -= 112;
#line 147
    samples += step___3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 16UL * sizeof(float ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_4to1_real_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  float samples_tmp[16] ;
  float *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[2][2]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 8)) {
#line 37
      goto while_break;
    }
#line 39
    *((float *)samples) = *tmp1;
#line 40
    samples += sizeof(float );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 8UL * sizeof(float ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_4to1_real_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[2][2]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 16UL * sizeof(float );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 8)) {
#line 57
      goto while_break;
    }
#line 59
    *((float *)samples + 1) = *((float *)samples + 0);
#line 60
    samples += 2UL * sizeof(float );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___4  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_4to1_real_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  float *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float sum___0 ;
  float sum___1 ;

  {
#line 34
  samples = (float *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    *samples = ((float )1. / (float )32768) * sum;
#line 85
    j --;
#line 85
    b0 += 64;
#line 85
    window += 128;
#line 85
    samples += step___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  *samples = ((float )1. / (float )32768) * sum___0;
#line 141
  samples += step___4;
#line 142
  b0 -= 64;
#line 143
  window -= 128;
#line 145
  window += bo1 << 1;
#line 147
  j = 3;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    *samples = ((float )1. / (float )32768) * sum___1;
#line 147
    j --;
#line 147
    b0 -= 64;
#line 147
    window -= 128;
#line 147
    samples += step___4;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 16UL * sizeof(float ));
  }
#line 192
  return (clip);
}
}
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_real_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  float samples_tmp[512] ;
  float *tmp1 ;
  size_t i ;
  int ret ;
  size_t pnt ;
  unsigned char *samples ;
  void *__cil_tmp9 ;

  {
  {
#line 23
  tmp1 = samples_tmp;
#line 27
  pnt = fr->buffer.fill;
#line 28
  samples = fr->buffer.data;
#line 29
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 30
  fr->buffer.fill = (size_t )0;
#line 31
  ret = synth_ntom_real(bandPtr, 0, fr, 1);
#line 32
  fr->buffer.data = samples;
#line 34
  samples += pnt;
#line 35
  i = (size_t )0;
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((unsigned long )i < (unsigned long )fr->buffer.fill / (2UL * sizeof(float )))) {
#line 35
      goto while_break;
    }
#line 37
    *((float *)samples) = *tmp1;
#line 38
    samples += sizeof(float );
#line 39
    tmp1 += 2;
#line 35
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  fr->buffer.fill = pnt + fr->buffer.fill / 2U;
#line 43
  return (ret);
}
}
#line 47 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_real_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  size_t i ;
  int ret ;
  size_t pnt1 ;
  unsigned char *samples ;

  {
  {
#line 51
  pnt1 = fr->buffer.fill;
#line 52
  samples = fr->buffer.data + pnt1;
#line 54
  ret = synth_ntom_real(bandPtr, 0, fr, 1);
#line 56
  i = (size_t )0;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )i < (unsigned long )(fr->buffer.fill - pnt1) / (2UL * sizeof(float )))) {
#line 56
      goto while_break;
    }
#line 58
    *((float *)samples + 1) = *((float *)samples + 0);
#line 59
    samples += 2UL * sizeof(float );
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (ret);
}
}
#line 68 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
static int const   step___5  =    (int const   )2;
#line 66 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_real(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  float *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  int ntom ;
  unsigned long tmp ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float *tmp___31 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  float *tmp___47 ;
  unsigned long tmp___48 ;

  {
#line 69
  samples = (float *)(fr->buffer.data + fr->buffer.fill);
#line 72
  clip = 0;
#line 76
  if (fr->have_eq_settings) {
    {
#line 76
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 78
  if (! channel) {
#line 80
    (fr->bo) --;
#line 81
    fr->bo &= 15;
#line 82
    buf = fr->real_buffs[0];
#line 83
    tmp = fr->ntom_val[0];
#line 83
    fr->ntom_val[1] = tmp;
#line 83
    ntom = (int )tmp;
  } else {
#line 87
    samples ++;
#line 88
    buf = fr->real_buffs[1];
#line 89
    ntom = (int )fr->ntom_val[1];
  }
#line 92
  if (fr->bo & 1) {
    {
#line 94
    b0 = *(buf + 0);
#line 95
    bo1 = fr->bo;
#line 96
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 100
    b0 = *(buf + 1);
#line 101
    bo1 = fr->bo + 1;
#line 102
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 107
  window = (fr->decwin + 16) - bo1;
#line 109
  j = 16;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! j) {
#line 109
      goto while_break;
    }
#line 113
    ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 114
    if (ntom < 32768) {
#line 116
      window += 16;
#line 117
      b0 += 16;
#line 118
      goto __Cont;
    }
#line 121
    tmp___0 = window;
#line 121
    window ++;
#line 121
    tmp___1 = b0;
#line 121
    b0 ++;
#line 121
    sum = *tmp___0 * *tmp___1;
#line 122
    tmp___2 = window;
#line 122
    window ++;
#line 122
    tmp___3 = b0;
#line 122
    b0 ++;
#line 122
    sum -= *tmp___2 * *tmp___3;
#line 123
    tmp___4 = window;
#line 123
    window ++;
#line 123
    tmp___5 = b0;
#line 123
    b0 ++;
#line 123
    sum += *tmp___4 * *tmp___5;
#line 124
    tmp___6 = window;
#line 124
    window ++;
#line 124
    tmp___7 = b0;
#line 124
    b0 ++;
#line 124
    sum -= *tmp___6 * *tmp___7;
#line 125
    tmp___8 = window;
#line 125
    window ++;
#line 125
    tmp___9 = b0;
#line 125
    b0 ++;
#line 125
    sum += *tmp___8 * *tmp___9;
#line 126
    tmp___10 = window;
#line 126
    window ++;
#line 126
    tmp___11 = b0;
#line 126
    b0 ++;
#line 126
    sum -= *tmp___10 * *tmp___11;
#line 127
    tmp___12 = window;
#line 127
    window ++;
#line 127
    tmp___13 = b0;
#line 127
    b0 ++;
#line 127
    sum += *tmp___12 * *tmp___13;
#line 128
    tmp___14 = window;
#line 128
    window ++;
#line 128
    tmp___15 = b0;
#line 128
    b0 ++;
#line 128
    sum -= *tmp___14 * *tmp___15;
#line 129
    tmp___16 = window;
#line 129
    window ++;
#line 129
    tmp___17 = b0;
#line 129
    b0 ++;
#line 129
    sum += *tmp___16 * *tmp___17;
#line 130
    tmp___18 = window;
#line 130
    window ++;
#line 130
    tmp___19 = b0;
#line 130
    b0 ++;
#line 130
    sum -= *tmp___18 * *tmp___19;
#line 131
    tmp___20 = window;
#line 131
    window ++;
#line 131
    tmp___21 = b0;
#line 131
    b0 ++;
#line 131
    sum += *tmp___20 * *tmp___21;
#line 132
    tmp___22 = window;
#line 132
    window ++;
#line 132
    tmp___23 = b0;
#line 132
    b0 ++;
#line 132
    sum -= *tmp___22 * *tmp___23;
#line 133
    tmp___24 = window;
#line 133
    window ++;
#line 133
    tmp___25 = b0;
#line 133
    b0 ++;
#line 133
    sum += *tmp___24 * *tmp___25;
#line 134
    tmp___26 = window;
#line 134
    window ++;
#line 134
    tmp___27 = b0;
#line 134
    b0 ++;
#line 134
    sum -= *tmp___26 * *tmp___27;
#line 135
    tmp___28 = window;
#line 135
    window ++;
#line 135
    tmp___29 = b0;
#line 135
    b0 ++;
#line 135
    sum += *tmp___28 * *tmp___29;
#line 136
    tmp___30 = window;
#line 136
    window ++;
#line 136
    tmp___31 = b0;
#line 136
    b0 ++;
#line 136
    sum -= *tmp___30 * *tmp___31;
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 138
      if (! (ntom >= 32768)) {
#line 138
        goto while_break___0;
      }
#line 140
      *samples = ((float )1. / (float )32768) * sum;
#line 141
      samples += step___5;
#line 142
      ntom -= 32768;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 109
    j --;
#line 109
    window += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 147
  if (ntom >= 32768) {
#line 150
    sum___0 = *(window + 0) * *(b0 + 0);
#line 151
    sum___0 += *(window + 2) * *(b0 + 2);
#line 152
    sum___0 += *(window + 4) * *(b0 + 4);
#line 153
    sum___0 += *(window + 6) * *(b0 + 6);
#line 154
    sum___0 += *(window + 8) * *(b0 + 8);
#line 155
    sum___0 += *(window + 10) * *(b0 + 10);
#line 156
    sum___0 += *(window + 12) * *(b0 + 12);
#line 157
    sum___0 += *(window + 14) * *(b0 + 14);
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (ntom >= 32768)) {
#line 159
        goto while_break___1;
      }
#line 161
      *samples = ((float )1. / (float )32768) * sum___0;
#line 162
      samples += step___5;
#line 163
      ntom -= 32768;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 167
  b0 -= 16;
#line 167
  window -= 32;
#line 168
  window += bo1 << 1;
#line 170
  j = 15;
  {
#line 170
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 170
    if (! j) {
#line 170
      goto while_break___2;
    }
#line 174
    ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 175
    if (ntom < 32768) {
#line 177
      window -= 16;
#line 178
      b0 += 16;
#line 179
      goto __Cont___0;
    }
#line 182
    window --;
#line 182
    tmp___32 = b0;
#line 182
    b0 ++;
#line 182
    sum___1 = - *window * *tmp___32;
#line 183
    window --;
#line 183
    tmp___33 = b0;
#line 183
    b0 ++;
#line 183
    sum___1 -= *window * *tmp___33;
#line 184
    window --;
#line 184
    tmp___34 = b0;
#line 184
    b0 ++;
#line 184
    sum___1 -= *window * *tmp___34;
#line 185
    window --;
#line 185
    tmp___35 = b0;
#line 185
    b0 ++;
#line 185
    sum___1 -= *window * *tmp___35;
#line 186
    window --;
#line 186
    tmp___36 = b0;
#line 186
    b0 ++;
#line 186
    sum___1 -= *window * *tmp___36;
#line 187
    window --;
#line 187
    tmp___37 = b0;
#line 187
    b0 ++;
#line 187
    sum___1 -= *window * *tmp___37;
#line 188
    window --;
#line 188
    tmp___38 = b0;
#line 188
    b0 ++;
#line 188
    sum___1 -= *window * *tmp___38;
#line 189
    window --;
#line 189
    tmp___39 = b0;
#line 189
    b0 ++;
#line 189
    sum___1 -= *window * *tmp___39;
#line 190
    window --;
#line 190
    tmp___40 = b0;
#line 190
    b0 ++;
#line 190
    sum___1 -= *window * *tmp___40;
#line 191
    window --;
#line 191
    tmp___41 = b0;
#line 191
    b0 ++;
#line 191
    sum___1 -= *window * *tmp___41;
#line 192
    window --;
#line 192
    tmp___42 = b0;
#line 192
    b0 ++;
#line 192
    sum___1 -= *window * *tmp___42;
#line 193
    window --;
#line 193
    tmp___43 = b0;
#line 193
    b0 ++;
#line 193
    sum___1 -= *window * *tmp___43;
#line 194
    window --;
#line 194
    tmp___44 = b0;
#line 194
    b0 ++;
#line 194
    sum___1 -= *window * *tmp___44;
#line 195
    window --;
#line 195
    tmp___45 = b0;
#line 195
    b0 ++;
#line 195
    sum___1 -= *window * *tmp___45;
#line 196
    window --;
#line 196
    tmp___46 = b0;
#line 196
    b0 ++;
#line 196
    sum___1 -= *window * *tmp___46;
#line 197
    window --;
#line 197
    tmp___47 = b0;
#line 197
    b0 ++;
#line 197
    sum___1 -= *window * *tmp___47;
    {
#line 199
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 199
      if (! (ntom >= 32768)) {
#line 199
        goto while_break___3;
      }
#line 201
      *samples = ((float )1. / (float )32768) * sum___1;
#line 202
      samples += step___5;
#line 203
      ntom -= 32768;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 170
    j --;
#line 170
    b0 -= 32;
#line 170
    window -= 16;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 208
  fr->ntom_val[channel] = (unsigned long )ntom;
#line 209
  if (final) {
#line 209
    if (channel) {
#line 209
      tmp___48 = sizeof(float );
    } else {
#line 209
      tmp___48 = 0UL;
    }
#line 209
    fr->buffer.fill = (size_t )((unsigned long )((unsigned char *)samples - fr->buffer.data) - tmp___48);
  }
#line 211
  return (clip);
}
}
#line 154 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
int synth_1to1_s32(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 155
int synth_1to1_s32_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 156
int synth_1to1_s32_sse(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 157
int synth_1to1_s32_stereo_sse(float *bandPtr_l , float *bandPtr_r , mpg123_handle *fr ) ;
#line 162
int synth_1to1_s32_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 163
int synth_1to1_s32_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 165
int synth_2to1_s32(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 166
int synth_2to1_s32_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 167
int synth_2to1_s32_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 168
int synth_2to1_s32_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 169
int synth_4to1_s32(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 170
int synth_4to1_s32_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 171
int synth_4to1_s32_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 172
int synth_4to1_s32_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 175
int synth_ntom_s32(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 176
int synth_ntom_s32_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 177
int synth_ntom_s32_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___6  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_1to1_s32(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int32_t *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float tmpsum ;
  float sum___0 ;
  float tmpsum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  float tmpsum___1 ;

  {
#line 34
  samples = (int32_t *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 16;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    tmpsum = sum * (float )65536;
#line 125
    if ((double )tmpsum > 2147483647.0) {
#line 125
      *samples = 2147483647;
#line 125
      clip ++;
    } else
#line 125
    if ((double )tmpsum < - 2147483648.0) {
#line 125
      *samples = (-0x7FFFFFFF-1);
#line 125
      clip ++;
    } else {
#line 125
      *samples = (int32_t )tmpsum;
    }
#line 85
    j --;
#line 85
    b0 += 0;
#line 85
    window += 16;
#line 85
    samples += step___6;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  tmpsum___0 = sum___0 * (float )65536;
#line 140
  if ((double )tmpsum___0 > 2147483647.0) {
#line 140
    *samples = 2147483647;
#line 140
    clip ++;
  } else
#line 140
  if ((double )tmpsum___0 < - 2147483648.0) {
#line 140
    *samples = (-0x7FFFFFFF-1);
#line 140
    clip ++;
  } else {
#line 140
    *samples = (int32_t )tmpsum___0;
  }
#line 141
  samples += step___6;
#line 142
  b0 -= 16;
#line 143
  window -= 32;
#line 145
  window += bo1 << 1;
#line 147
  j = 15;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    tmpsum___1 = sum___1 * (float )65536;
#line 186
    if ((double )tmpsum___1 > 2147483647.0) {
#line 186
      *samples = 2147483647;
#line 186
      clip ++;
    } else
#line 186
    if ((double )tmpsum___1 < - 2147483648.0) {
#line 186
      *samples = (-0x7FFFFFFF-1);
#line 186
      clip ++;
    } else {
#line 186
      *samples = (int32_t )tmpsum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 32;
#line 147
    window -= 16;
#line 147
    samples += step___6;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 64UL * sizeof(int32_t ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_1to1_s32_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  int32_t samples_tmp[64] ;
  int32_t *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[0][3]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 32)) {
#line 37
      goto while_break;
    }
#line 39
    *((int32_t *)samples) = *tmp1;
#line 40
    samples += sizeof(int32_t );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 32UL * sizeof(int32_t ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_1to1_s32_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[0][3]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 64UL * sizeof(int32_t );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 32)) {
#line 57
      goto while_break;
    }
#line 59
    *((int32_t *)samples + 1) = *((int32_t *)samples + 0);
#line 60
    samples += 2UL * sizeof(int32_t );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___7  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_1to1_s32_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int32_t *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float tmpsum ;
  float sum___0 ;
  float tmpsum___0 ;
  float sum___1 ;
  float tmpsum___1 ;

  {
#line 34
  samples = (int32_t *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 16;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    tmpsum = sum * (float )65536;
#line 125
    if ((double )tmpsum > 2147483647.0) {
#line 125
      *samples = 2147483647;
#line 125
      clip ++;
    } else
#line 125
    if ((double )tmpsum < - 2147483648.0) {
#line 125
      *samples = (-0x7FFFFFFF-1);
#line 125
      clip ++;
    } else {
#line 125
      *samples = (int32_t )tmpsum;
    }
#line 85
    j --;
#line 85
    b0 += 16;
#line 85
    window += 32;
#line 85
    samples += step___7;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  tmpsum___0 = sum___0 * (float )65536;
#line 140
  if ((double )tmpsum___0 > 2147483647.0) {
#line 140
    *samples = 2147483647;
#line 140
    clip ++;
  } else
#line 140
  if ((double )tmpsum___0 < - 2147483648.0) {
#line 140
    *samples = (-0x7FFFFFFF-1);
#line 140
    clip ++;
  } else {
#line 140
    *samples = (int32_t )tmpsum___0;
  }
#line 141
  samples += step___7;
#line 142
  b0 -= 16;
#line 143
  window -= 32;
#line 145
  window += bo1 << 1;
#line 147
  j = 15;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    tmpsum___1 = sum___1 * (float )65536;
#line 186
    if ((double )tmpsum___1 > 2147483647.0) {
#line 186
      *samples = 2147483647;
#line 186
      clip ++;
    } else
#line 186
    if ((double )tmpsum___1 < - 2147483648.0) {
#line 186
      *samples = (-0x7FFFFFFF-1);
#line 186
      clip ++;
    } else {
#line 186
      *samples = (int32_t )tmpsum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 16;
#line 147
    window -= 32;
#line 147
    samples += step___7;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 64UL * sizeof(int32_t ));
  }
#line 192
  return (clip);
}
}
#line 144 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_s32.c"
extern int synth_1to1_s32_sse_asm(float *window , float *b0 , int32_t *samples , int bo1 ) ;
#line 145
extern int synth_1to1_s32_stereo_sse_asm(float *window , float *b0l , float *b0r ,
                                         int32_t *samples , int bo1 ) ;
#line 148 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_s32.c"
int synth_1to1_s32_sse(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int32_t *samples ;
  float *b0 ;
  float **buf ;
  int bo1 ;
  int clip ;

  {
#line 150
  samples = (int32_t *)(fr->buffer.data + fr->buffer.fill);
#line 156
  if (fr->have_eq_settings) {
    {
#line 156
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 158
  if (! channel) {
#line 160
    (fr->bo) --;
#line 161
    fr->bo &= 15;
#line 162
    buf = fr->real_buffs[0];
  } else {
#line 166
    samples ++;
#line 167
    buf = fr->real_buffs[1];
  }
#line 170
  if (fr->bo & 1) {
    {
#line 172
    b0 = *(buf + 0);
#line 173
    bo1 = fr->bo;
#line 174
    dct64_real_sse(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 178
    b0 = *(buf + 1);
#line 179
    bo1 = fr->bo + 1;
#line 180
    dct64_real_sse(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
  {
#line 183
  clip = synth_1to1_s32_sse_asm(fr->decwin, b0, samples, bo1);
  }
#line 185
  if (final) {
#line 185
    fr->buffer.fill += 256U;
  }
#line 187
  return (clip);
}
}
#line 191 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_s32.c"
int synth_1to1_s32_stereo_sse(float *bandPtr_l , float *bandPtr_r , mpg123_handle *fr ) 
{ 
  int32_t *samples ;
  float *b0l ;
  float *b0r ;
  float **bufl ;
  float **bufr ;
  int bo1 ;
  int clip ;

  {
#line 193
  samples = (int32_t *)(fr->buffer.data + fr->buffer.fill);
#line 199
  if (fr->have_eq_settings) {
    {
#line 201
    do_equalizer(bandPtr_l, 0, (float (*)[32])(fr->equalizer));
#line 202
    do_equalizer(bandPtr_r, 1, (float (*)[32])(fr->equalizer));
    }
  }
#line 205
  (fr->bo) --;
#line 206
  fr->bo &= 15;
#line 207
  bufl = fr->real_buffs[0];
#line 208
  bufr = fr->real_buffs[1];
#line 210
  if (fr->bo & 1) {
    {
#line 212
    b0l = *(bufl + 0);
#line 213
    b0r = *(bufr + 0);
#line 214
    bo1 = fr->bo;
#line 215
    dct64_real_sse(*(bufl + 1) + ((fr->bo + 1) & 15), *(bufl + 0) + fr->bo, bandPtr_l);
#line 216
    dct64_real_sse(*(bufr + 1) + ((fr->bo + 1) & 15), *(bufr + 0) + fr->bo, bandPtr_r);
    }
  } else {
    {
#line 220
    b0l = *(bufl + 1);
#line 221
    b0r = *(bufr + 1);
#line 222
    bo1 = fr->bo + 1;
#line 223
    dct64_real_sse(*(bufl + 0) + fr->bo, (*(bufl + 1) + fr->bo) + 1, bandPtr_l);
#line 224
    dct64_real_sse(*(bufr + 0) + fr->bo, (*(bufr + 1) + fr->bo) + 1, bandPtr_r);
    }
  }
  {
#line 227
  clip = synth_1to1_s32_stereo_sse_asm(fr->decwin, b0l, b0r, samples, bo1);
#line 229
  fr->buffer.fill += 256U;
  }
#line 231
  return (clip);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___8  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_2to1_s32(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int32_t *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float tmpsum ;
  float sum___0 ;
  float tmpsum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  float tmpsum___1 ;

  {
#line 34
  samples = (int32_t *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    tmpsum = sum * (float )65536;
#line 125
    if ((double )tmpsum > 2147483647.0) {
#line 125
      *samples = 2147483647;
#line 125
      clip ++;
    } else
#line 125
    if ((double )tmpsum < - 2147483648.0) {
#line 125
      *samples = (-0x7FFFFFFF-1);
#line 125
      clip ++;
    } else {
#line 125
      *samples = (int32_t )tmpsum;
    }
#line 85
    j --;
#line 85
    b0 += 16;
#line 85
    window += 48;
#line 85
    samples += step___8;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  tmpsum___0 = sum___0 * (float )65536;
#line 140
  if ((double )tmpsum___0 > 2147483647.0) {
#line 140
    *samples = 2147483647;
#line 140
    clip ++;
  } else
#line 140
  if ((double )tmpsum___0 < - 2147483648.0) {
#line 140
    *samples = (-0x7FFFFFFF-1);
#line 140
    clip ++;
  } else {
#line 140
    *samples = (int32_t )tmpsum___0;
  }
#line 141
  samples += step___8;
#line 142
  b0 -= 32;
#line 143
  window -= 64;
#line 145
  window += bo1 << 1;
#line 147
  j = 7;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    tmpsum___1 = sum___1 * (float )65536;
#line 186
    if ((double )tmpsum___1 > 2147483647.0) {
#line 186
      *samples = 2147483647;
#line 186
      clip ++;
    } else
#line 186
    if ((double )tmpsum___1 < - 2147483648.0) {
#line 186
      *samples = (-0x7FFFFFFF-1);
#line 186
      clip ++;
    } else {
#line 186
      *samples = (int32_t )tmpsum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 48;
#line 147
    window -= 48;
#line 147
    samples += step___8;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 32UL * sizeof(int32_t ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_2to1_s32_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  int32_t samples_tmp[32] ;
  int32_t *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[1][3]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 16)) {
#line 37
      goto while_break;
    }
#line 39
    *((int32_t *)samples) = *tmp1;
#line 40
    samples += sizeof(int32_t );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 16UL * sizeof(int32_t ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_2to1_s32_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[1][3]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 32UL * sizeof(int32_t );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 16)) {
#line 57
      goto while_break;
    }
#line 59
    *((int32_t *)samples + 1) = *((int32_t *)samples + 0);
#line 60
    samples += 2UL * sizeof(int32_t );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___9  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_2to1_s32_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int32_t *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float tmpsum ;
  float sum___0 ;
  float tmpsum___0 ;
  float sum___1 ;
  float tmpsum___1 ;

  {
#line 34
  samples = (int32_t *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    tmpsum = sum * (float )65536;
#line 125
    if ((double )tmpsum > 2147483647.0) {
#line 125
      *samples = 2147483647;
#line 125
      clip ++;
    } else
#line 125
    if ((double )tmpsum < - 2147483648.0) {
#line 125
      *samples = (-0x7FFFFFFF-1);
#line 125
      clip ++;
    } else {
#line 125
      *samples = (int32_t )tmpsum;
    }
#line 85
    j --;
#line 85
    b0 += 32;
#line 85
    window += 64;
#line 85
    samples += step___9;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  tmpsum___0 = sum___0 * (float )65536;
#line 140
  if ((double )tmpsum___0 > 2147483647.0) {
#line 140
    *samples = 2147483647;
#line 140
    clip ++;
  } else
#line 140
  if ((double )tmpsum___0 < - 2147483648.0) {
#line 140
    *samples = (-0x7FFFFFFF-1);
#line 140
    clip ++;
  } else {
#line 140
    *samples = (int32_t )tmpsum___0;
  }
#line 141
  samples += step___9;
#line 142
  b0 -= 32;
#line 143
  window -= 64;
#line 145
  window += bo1 << 1;
#line 147
  j = 7;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    tmpsum___1 = sum___1 * (float )65536;
#line 186
    if ((double )tmpsum___1 > 2147483647.0) {
#line 186
      *samples = 2147483647;
#line 186
      clip ++;
    } else
#line 186
    if ((double )tmpsum___1 < - 2147483648.0) {
#line 186
      *samples = (-0x7FFFFFFF-1);
#line 186
      clip ++;
    } else {
#line 186
      *samples = (int32_t )tmpsum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 32;
#line 147
    window -= 64;
#line 147
    samples += step___9;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 32UL * sizeof(int32_t ));
  }
#line 192
  return (clip);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___10  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_4to1_s32(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int32_t *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float tmpsum ;
  float sum___0 ;
  float tmpsum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  float tmpsum___1 ;

  {
#line 34
  samples = (int32_t *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    tmpsum = sum * (float )65536;
#line 125
    if ((double )tmpsum > 2147483647.0) {
#line 125
      *samples = 2147483647;
#line 125
      clip ++;
    } else
#line 125
    if ((double )tmpsum < - 2147483648.0) {
#line 125
      *samples = (-0x7FFFFFFF-1);
#line 125
      clip ++;
    } else {
#line 125
      *samples = (int32_t )tmpsum;
    }
#line 85
    j --;
#line 85
    b0 += 48;
#line 85
    window += 112;
#line 85
    samples += step___10;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  tmpsum___0 = sum___0 * (float )65536;
#line 140
  if ((double )tmpsum___0 > 2147483647.0) {
#line 140
    *samples = 2147483647;
#line 140
    clip ++;
  } else
#line 140
  if ((double )tmpsum___0 < - 2147483648.0) {
#line 140
    *samples = (-0x7FFFFFFF-1);
#line 140
    clip ++;
  } else {
#line 140
    *samples = (int32_t )tmpsum___0;
  }
#line 141
  samples += step___10;
#line 142
  b0 -= 64;
#line 143
  window -= 128;
#line 145
  window += bo1 << 1;
#line 147
  j = 3;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    tmpsum___1 = sum___1 * (float )65536;
#line 186
    if ((double )tmpsum___1 > 2147483647.0) {
#line 186
      *samples = 2147483647;
#line 186
      clip ++;
    } else
#line 186
    if ((double )tmpsum___1 < - 2147483648.0) {
#line 186
      *samples = (-0x7FFFFFFF-1);
#line 186
      clip ++;
    } else {
#line 186
      *samples = (int32_t )tmpsum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 80;
#line 147
    window -= 112;
#line 147
    samples += step___10;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 16UL * sizeof(int32_t ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_4to1_s32_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  int32_t samples_tmp[16] ;
  int32_t *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[2][3]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 8)) {
#line 37
      goto while_break;
    }
#line 39
    *((int32_t *)samples) = *tmp1;
#line 40
    samples += sizeof(int32_t );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 8UL * sizeof(int32_t ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_4to1_s32_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[2][3]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 16UL * sizeof(int32_t );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 8)) {
#line 57
      goto while_break;
    }
#line 59
    *((int32_t *)samples + 1) = *((int32_t *)samples + 0);
#line 60
    samples += 2UL * sizeof(int32_t );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___11  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_4to1_s32_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int32_t *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float tmpsum ;
  float sum___0 ;
  float tmpsum___0 ;
  float sum___1 ;
  float tmpsum___1 ;

  {
#line 34
  samples = (int32_t *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    tmpsum = sum * (float )65536;
#line 125
    if ((double )tmpsum > 2147483647.0) {
#line 125
      *samples = 2147483647;
#line 125
      clip ++;
    } else
#line 125
    if ((double )tmpsum < - 2147483648.0) {
#line 125
      *samples = (-0x7FFFFFFF-1);
#line 125
      clip ++;
    } else {
#line 125
      *samples = (int32_t )tmpsum;
    }
#line 85
    j --;
#line 85
    b0 += 64;
#line 85
    window += 128;
#line 85
    samples += step___11;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  tmpsum___0 = sum___0 * (float )65536;
#line 140
  if ((double )tmpsum___0 > 2147483647.0) {
#line 140
    *samples = 2147483647;
#line 140
    clip ++;
  } else
#line 140
  if ((double )tmpsum___0 < - 2147483648.0) {
#line 140
    *samples = (-0x7FFFFFFF-1);
#line 140
    clip ++;
  } else {
#line 140
    *samples = (int32_t )tmpsum___0;
  }
#line 141
  samples += step___11;
#line 142
  b0 -= 64;
#line 143
  window -= 128;
#line 145
  window += bo1 << 1;
#line 147
  j = 3;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    tmpsum___1 = sum___1 * (float )65536;
#line 186
    if ((double )tmpsum___1 > 2147483647.0) {
#line 186
      *samples = 2147483647;
#line 186
      clip ++;
    } else
#line 186
    if ((double )tmpsum___1 < - 2147483648.0) {
#line 186
      *samples = (-0x7FFFFFFF-1);
#line 186
      clip ++;
    } else {
#line 186
      *samples = (int32_t )tmpsum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 64;
#line 147
    window -= 128;
#line 147
    samples += step___11;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 16UL * sizeof(int32_t ));
  }
#line 192
  return (clip);
}
}
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_s32_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  int32_t samples_tmp[512] ;
  int32_t *tmp1 ;
  size_t i ;
  int ret ;
  size_t pnt ;
  unsigned char *samples ;
  void *__cil_tmp9 ;

  {
  {
#line 23
  tmp1 = samples_tmp;
#line 27
  pnt = fr->buffer.fill;
#line 28
  samples = fr->buffer.data;
#line 29
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 30
  fr->buffer.fill = (size_t )0;
#line 31
  ret = synth_ntom_s32(bandPtr, 0, fr, 1);
#line 32
  fr->buffer.data = samples;
#line 34
  samples += pnt;
#line 35
  i = (size_t )0;
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((unsigned long )i < (unsigned long )fr->buffer.fill / (2UL * sizeof(int32_t )))) {
#line 35
      goto while_break;
    }
#line 37
    *((int32_t *)samples) = *tmp1;
#line 38
    samples += sizeof(int32_t );
#line 39
    tmp1 += 2;
#line 35
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  fr->buffer.fill = pnt + fr->buffer.fill / 2U;
#line 43
  return (ret);
}
}
#line 47 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_s32_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  size_t i ;
  int ret ;
  size_t pnt1 ;
  unsigned char *samples ;

  {
  {
#line 51
  pnt1 = fr->buffer.fill;
#line 52
  samples = fr->buffer.data + pnt1;
#line 54
  ret = synth_ntom_s32(bandPtr, 0, fr, 1);
#line 56
  i = (size_t )0;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )i < (unsigned long )(fr->buffer.fill - pnt1) / (2UL * sizeof(int32_t )))) {
#line 56
      goto while_break;
    }
#line 58
    *((int32_t *)samples + 1) = *((int32_t *)samples + 0);
#line 59
    samples += 2UL * sizeof(int32_t );
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (ret);
}
}
#line 68 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
static int const   step___12  =    (int const   )2;
#line 66 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_s32(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int32_t *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  int ntom ;
  unsigned long tmp ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float *tmp___31 ;
  float tmpsum ;
  float sum___0 ;
  float tmpsum___0 ;
  float sum___1 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  float *tmp___47 ;
  float tmpsum___1 ;
  unsigned long tmp___48 ;

  {
#line 69
  samples = (int32_t *)(fr->buffer.data + fr->buffer.fill);
#line 72
  clip = 0;
#line 76
  if (fr->have_eq_settings) {
    {
#line 76
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 78
  if (! channel) {
#line 80
    (fr->bo) --;
#line 81
    fr->bo &= 15;
#line 82
    buf = fr->real_buffs[0];
#line 83
    tmp = fr->ntom_val[0];
#line 83
    fr->ntom_val[1] = tmp;
#line 83
    ntom = (int )tmp;
  } else {
#line 87
    samples ++;
#line 88
    buf = fr->real_buffs[1];
#line 89
    ntom = (int )fr->ntom_val[1];
  }
#line 92
  if (fr->bo & 1) {
    {
#line 94
    b0 = *(buf + 0);
#line 95
    bo1 = fr->bo;
#line 96
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 100
    b0 = *(buf + 1);
#line 101
    bo1 = fr->bo + 1;
#line 102
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 107
  window = (fr->decwin + 16) - bo1;
#line 109
  j = 16;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! j) {
#line 109
      goto while_break;
    }
#line 113
    ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 114
    if (ntom < 32768) {
#line 116
      window += 16;
#line 117
      b0 += 16;
#line 118
      goto __Cont;
    }
#line 121
    tmp___0 = window;
#line 121
    window ++;
#line 121
    tmp___1 = b0;
#line 121
    b0 ++;
#line 121
    sum = *tmp___0 * *tmp___1;
#line 122
    tmp___2 = window;
#line 122
    window ++;
#line 122
    tmp___3 = b0;
#line 122
    b0 ++;
#line 122
    sum -= *tmp___2 * *tmp___3;
#line 123
    tmp___4 = window;
#line 123
    window ++;
#line 123
    tmp___5 = b0;
#line 123
    b0 ++;
#line 123
    sum += *tmp___4 * *tmp___5;
#line 124
    tmp___6 = window;
#line 124
    window ++;
#line 124
    tmp___7 = b0;
#line 124
    b0 ++;
#line 124
    sum -= *tmp___6 * *tmp___7;
#line 125
    tmp___8 = window;
#line 125
    window ++;
#line 125
    tmp___9 = b0;
#line 125
    b0 ++;
#line 125
    sum += *tmp___8 * *tmp___9;
#line 126
    tmp___10 = window;
#line 126
    window ++;
#line 126
    tmp___11 = b0;
#line 126
    b0 ++;
#line 126
    sum -= *tmp___10 * *tmp___11;
#line 127
    tmp___12 = window;
#line 127
    window ++;
#line 127
    tmp___13 = b0;
#line 127
    b0 ++;
#line 127
    sum += *tmp___12 * *tmp___13;
#line 128
    tmp___14 = window;
#line 128
    window ++;
#line 128
    tmp___15 = b0;
#line 128
    b0 ++;
#line 128
    sum -= *tmp___14 * *tmp___15;
#line 129
    tmp___16 = window;
#line 129
    window ++;
#line 129
    tmp___17 = b0;
#line 129
    b0 ++;
#line 129
    sum += *tmp___16 * *tmp___17;
#line 130
    tmp___18 = window;
#line 130
    window ++;
#line 130
    tmp___19 = b0;
#line 130
    b0 ++;
#line 130
    sum -= *tmp___18 * *tmp___19;
#line 131
    tmp___20 = window;
#line 131
    window ++;
#line 131
    tmp___21 = b0;
#line 131
    b0 ++;
#line 131
    sum += *tmp___20 * *tmp___21;
#line 132
    tmp___22 = window;
#line 132
    window ++;
#line 132
    tmp___23 = b0;
#line 132
    b0 ++;
#line 132
    sum -= *tmp___22 * *tmp___23;
#line 133
    tmp___24 = window;
#line 133
    window ++;
#line 133
    tmp___25 = b0;
#line 133
    b0 ++;
#line 133
    sum += *tmp___24 * *tmp___25;
#line 134
    tmp___26 = window;
#line 134
    window ++;
#line 134
    tmp___27 = b0;
#line 134
    b0 ++;
#line 134
    sum -= *tmp___26 * *tmp___27;
#line 135
    tmp___28 = window;
#line 135
    window ++;
#line 135
    tmp___29 = b0;
#line 135
    b0 ++;
#line 135
    sum += *tmp___28 * *tmp___29;
#line 136
    tmp___30 = window;
#line 136
    window ++;
#line 136
    tmp___31 = b0;
#line 136
    b0 ++;
#line 136
    sum -= *tmp___30 * *tmp___31;
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 138
      if (! (ntom >= 32768)) {
#line 138
        goto while_break___0;
      }
#line 140
      tmpsum = sum * (float )65536;
#line 140
      if ((double )tmpsum > 2147483647.0) {
#line 140
        *samples = 2147483647;
#line 140
        clip ++;
      } else
#line 140
      if ((double )tmpsum < - 2147483648.0) {
#line 140
        *samples = (-0x7FFFFFFF-1);
#line 140
        clip ++;
      } else {
#line 140
        *samples = (int32_t )tmpsum;
      }
#line 141
      samples += step___12;
#line 142
      ntom -= 32768;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 109
    j --;
#line 109
    window += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 147
  if (ntom >= 32768) {
#line 150
    sum___0 = *(window + 0) * *(b0 + 0);
#line 151
    sum___0 += *(window + 2) * *(b0 + 2);
#line 152
    sum___0 += *(window + 4) * *(b0 + 4);
#line 153
    sum___0 += *(window + 6) * *(b0 + 6);
#line 154
    sum___0 += *(window + 8) * *(b0 + 8);
#line 155
    sum___0 += *(window + 10) * *(b0 + 10);
#line 156
    sum___0 += *(window + 12) * *(b0 + 12);
#line 157
    sum___0 += *(window + 14) * *(b0 + 14);
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (ntom >= 32768)) {
#line 159
        goto while_break___1;
      }
#line 161
      tmpsum___0 = sum___0 * (float )65536;
#line 161
      if ((double )tmpsum___0 > 2147483647.0) {
#line 161
        *samples = 2147483647;
#line 161
        clip ++;
      } else
#line 161
      if ((double )tmpsum___0 < - 2147483648.0) {
#line 161
        *samples = (-0x7FFFFFFF-1);
#line 161
        clip ++;
      } else {
#line 161
        *samples = (int32_t )tmpsum___0;
      }
#line 162
      samples += step___12;
#line 163
      ntom -= 32768;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 167
  b0 -= 16;
#line 167
  window -= 32;
#line 168
  window += bo1 << 1;
#line 170
  j = 15;
  {
#line 170
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 170
    if (! j) {
#line 170
      goto while_break___2;
    }
#line 174
    ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 175
    if (ntom < 32768) {
#line 177
      window -= 16;
#line 178
      b0 += 16;
#line 179
      goto __Cont___0;
    }
#line 182
    window --;
#line 182
    tmp___32 = b0;
#line 182
    b0 ++;
#line 182
    sum___1 = - *window * *tmp___32;
#line 183
    window --;
#line 183
    tmp___33 = b0;
#line 183
    b0 ++;
#line 183
    sum___1 -= *window * *tmp___33;
#line 184
    window --;
#line 184
    tmp___34 = b0;
#line 184
    b0 ++;
#line 184
    sum___1 -= *window * *tmp___34;
#line 185
    window --;
#line 185
    tmp___35 = b0;
#line 185
    b0 ++;
#line 185
    sum___1 -= *window * *tmp___35;
#line 186
    window --;
#line 186
    tmp___36 = b0;
#line 186
    b0 ++;
#line 186
    sum___1 -= *window * *tmp___36;
#line 187
    window --;
#line 187
    tmp___37 = b0;
#line 187
    b0 ++;
#line 187
    sum___1 -= *window * *tmp___37;
#line 188
    window --;
#line 188
    tmp___38 = b0;
#line 188
    b0 ++;
#line 188
    sum___1 -= *window * *tmp___38;
#line 189
    window --;
#line 189
    tmp___39 = b0;
#line 189
    b0 ++;
#line 189
    sum___1 -= *window * *tmp___39;
#line 190
    window --;
#line 190
    tmp___40 = b0;
#line 190
    b0 ++;
#line 190
    sum___1 -= *window * *tmp___40;
#line 191
    window --;
#line 191
    tmp___41 = b0;
#line 191
    b0 ++;
#line 191
    sum___1 -= *window * *tmp___41;
#line 192
    window --;
#line 192
    tmp___42 = b0;
#line 192
    b0 ++;
#line 192
    sum___1 -= *window * *tmp___42;
#line 193
    window --;
#line 193
    tmp___43 = b0;
#line 193
    b0 ++;
#line 193
    sum___1 -= *window * *tmp___43;
#line 194
    window --;
#line 194
    tmp___44 = b0;
#line 194
    b0 ++;
#line 194
    sum___1 -= *window * *tmp___44;
#line 195
    window --;
#line 195
    tmp___45 = b0;
#line 195
    b0 ++;
#line 195
    sum___1 -= *window * *tmp___45;
#line 196
    window --;
#line 196
    tmp___46 = b0;
#line 196
    b0 ++;
#line 196
    sum___1 -= *window * *tmp___46;
#line 197
    window --;
#line 197
    tmp___47 = b0;
#line 197
    b0 ++;
#line 197
    sum___1 -= *window * *tmp___47;
    {
#line 199
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 199
      if (! (ntom >= 32768)) {
#line 199
        goto while_break___3;
      }
#line 201
      tmpsum___1 = sum___1 * (float )65536;
#line 201
      if ((double )tmpsum___1 > 2147483647.0) {
#line 201
        *samples = 2147483647;
#line 201
        clip ++;
      } else
#line 201
      if ((double )tmpsum___1 < - 2147483648.0) {
#line 201
        *samples = (-0x7FFFFFFF-1);
#line 201
        clip ++;
      } else {
#line 201
        *samples = (int32_t )tmpsum___1;
      }
#line 202
      samples += step___12;
#line 203
      ntom -= 32768;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 170
    j --;
#line 170
    b0 -= 32;
#line 170
    window -= 16;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 208
  fr->ntom_val[channel] = (unsigned long )ntom;
#line 209
  if (final) {
#line 209
    if (channel) {
#line 209
      tmp___48 = sizeof(int32_t );
    } else {
#line 209
      tmp___48 = 0UL;
    }
#line 209
    fr->buffer.fill = (size_t )((unsigned long )((unsigned char *)samples - fr->buffer.data) - tmp___48);
  }
#line 211
  return (clip);
}
}
#line 64 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 68
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 154
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 157
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 193 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
void dct36(float *inbuf , float *o1 , float *o2 , float *wintab , float *tsbuf ) ;
#line 216
void init_layer3(void) ;
#line 217
float init_layer3_gainpow2(mpg123_handle *fr , int i ) ;
#line 218
void init_layer3_stuff(mpg123_handle *fr , float (*gainpow2)(mpg123_handle *fr , int i ) ) ;
#line 238
float init_layer3_gainpow2_mmx(mpg123_handle *fr , int i ) ;
#line 255
int do_layer3(mpg123_handle *fr ) ;
#line 19 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.h"
void set_pointer(mpg123_handle *fr , long backstep ) ;
#line 22 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab0[1]  = {      (short)0};
#line 27 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab1[7]  = {      (short)-5,      (short)-3,      (short)-1,      (short)17, 
        (short)1,      (short)16,      (short)0};
#line 32 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab2[17]  = 
#line 32
  {      (short)-15,      (short)-11,      (short)-9,      (short)-5, 
        (short)-3,      (short)-1,      (short)34,      (short)2, 
        (short)18,      (short)-1,      (short)33,      (short)32, 
        (short)17,      (short)-1,      (short)1,      (short)16, 
        (short)0};
#line 38 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab3[17]  = 
#line 38
  {      (short)-13,      (short)-11,      (short)-9,      (short)-5, 
        (short)-3,      (short)-1,      (short)34,      (short)2, 
        (short)18,      (short)-1,      (short)33,      (short)32, 
        (short)16,      (short)17,      (short)-1,      (short)1, 
        (short)0};
#line 44 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab5[31]  = 
#line 44
  {      (short)-29,      (short)-25,      (short)-23,      (short)-15, 
        (short)-7,      (short)-5,      (short)-3,      (short)-1, 
        (short)51,      (short)35,      (short)50,      (short)49, 
        (short)-3,      (short)-1,      (short)19,      (short)3, 
        (short)-1,      (short)48,      (short)34,      (short)-3, 
        (short)-1,      (short)18,      (short)33,      (short)-1, 
        (short)2,      (short)32,      (short)17,      (short)-1, 
        (short)1,      (short)16,      (short)0};
#line 51 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab6[31]  = 
#line 51
  {      (short)-25,      (short)-19,      (short)-13,      (short)-9, 
        (short)-5,      (short)-3,      (short)-1,      (short)51, 
        (short)3,      (short)35,      (short)-1,      (short)50, 
        (short)48,      (short)-1,      (short)19,      (short)49, 
        (short)-3,      (short)-1,      (short)34,      (short)2, 
        (short)18,      (short)-3,      (short)-1,      (short)33, 
        (short)32,      (short)1,      (short)-1,      (short)17, 
        (short)-1,      (short)16,      (short)0};
#line 58 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab7[71]  = 
#line 58
  {      (short)-69,      (short)-65,      (short)-57,      (short)-39, 
        (short)-29,      (short)-17,      (short)-11,      (short)-7, 
        (short)-3,      (short)-1,      (short)85,      (short)69, 
        (short)-1,      (short)84,      (short)83,      (short)-1, 
        (short)53,      (short)68,      (short)-3,      (short)-1, 
        (short)37,      (short)82,      (short)21,      (short)-5, 
        (short)-1,      (short)81,      (short)-1,      (short)5, 
        (short)52,      (short)-1,      (short)80,      (short)-1, 
        (short)67,      (short)51,      (short)-5,      (short)-3, 
        (short)-1,      (short)36,      (short)66,      (short)20, 
        (short)-1,      (short)65,      (short)64,      (short)-11, 
        (short)-7,      (short)-3,      (short)-1,      (short)4, 
        (short)35,      (short)-1,      (short)50,      (short)3, 
        (short)-1,      (short)19,      (short)49,      (short)-3, 
        (short)-1,      (short)48,      (short)34,      (short)18, 
        (short)-5,      (short)-1,      (short)33,      (short)-1, 
        (short)2,      (short)32,      (short)17,      (short)-1, 
        (short)1,      (short)16,      (short)0};
#line 67 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab8[71]  = 
#line 67
  {      (short)-65,      (short)-63,      (short)-59,      (short)-45, 
        (short)-31,      (short)-19,      (short)-13,      (short)-7, 
        (short)-5,      (short)-3,      (short)-1,      (short)85, 
        (short)84,      (short)69,      (short)83,      (short)-3, 
        (short)-1,      (short)53,      (short)68,      (short)37, 
        (short)-3,      (short)-1,      (short)82,      (short)5, 
        (short)21,      (short)-5,      (short)-1,      (short)81, 
        (short)-1,      (short)52,      (short)67,      (short)-3, 
        (short)-1,      (short)80,      (short)51,      (short)36, 
        (short)-5,      (short)-3,      (short)-1,      (short)66, 
        (short)20,      (short)65,      (short)-3,      (short)-1, 
        (short)4,      (short)64,      (short)-1,      (short)35, 
        (short)50,      (short)-9,      (short)-7,      (short)-3, 
        (short)-1,      (short)19,      (short)49,      (short)-1, 
        (short)3,      (short)48,      (short)34,      (short)-1, 
        (short)2,      (short)32,      (short)-1,      (short)18, 
        (short)33,      (short)17,      (short)-3,      (short)-1, 
        (short)1,      (short)16,      (short)0};
#line 76 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab9[71]  = 
#line 76
  {      (short)-63,      (short)-53,      (short)-41,      (short)-29, 
        (short)-19,      (short)-11,      (short)-5,      (short)-3, 
        (short)-1,      (short)85,      (short)69,      (short)53, 
        (short)-1,      (short)83,      (short)-1,      (short)84, 
        (short)5,      (short)-3,      (short)-1,      (short)68, 
        (short)37,      (short)-1,      (short)82,      (short)21, 
        (short)-3,      (short)-1,      (short)81,      (short)52, 
        (short)-1,      (short)67,      (short)-1,      (short)80, 
        (short)4,      (short)-7,      (short)-3,      (short)-1, 
        (short)36,      (short)66,      (short)-1,      (short)51, 
        (short)64,      (short)-1,      (short)20,      (short)65, 
        (short)-5,      (short)-3,      (short)-1,      (short)35, 
        (short)50,      (short)19,      (short)-1,      (short)49, 
        (short)-1,      (short)3,      (short)48,      (short)-5, 
        (short)-3,      (short)-1,      (short)34,      (short)2, 
        (short)18,      (short)-1,      (short)33,      (short)32, 
        (short)-3,      (short)-1,      (short)17,      (short)1, 
        (short)-1,      (short)16,      (short)0};
#line 85 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab10[127]  = 
#line 85
  {      (short)-125,      (short)-121,      (short)-111,      (short)-83, 
        (short)-55,      (short)-35,      (short)-21,      (short)-13, 
        (short)-7,      (short)-3,      (short)-1,      (short)119, 
        (short)103,      (short)-1,      (short)118,      (short)87, 
        (short)-3,      (short)-1,      (short)117,      (short)102, 
        (short)71,      (short)-3,      (short)-1,      (short)116, 
        (short)86,      (short)-1,      (short)101,      (short)55, 
        (short)-9,      (short)-3,      (short)-1,      (short)115, 
        (short)70,      (short)-3,      (short)-1,      (short)85, 
        (short)84,      (short)99,      (short)-1,      (short)39, 
        (short)114,      (short)-11,      (short)-5,      (short)-3, 
        (short)-1,      (short)100,      (short)7,      (short)112, 
        (short)-1,      (short)98,      (short)-1,      (short)69, 
        (short)53,      (short)-5,      (short)-1,      (short)6, 
        (short)-1,      (short)83,      (short)68,      (short)23, 
        (short)-17,      (short)-5,      (short)-1,      (short)113, 
        (short)-1,      (short)54,      (short)38,      (short)-5, 
        (short)-3,      (short)-1,      (short)37,      (short)82, 
        (short)21,      (short)-1,      (short)81,      (short)-1, 
        (short)52,      (short)67,      (short)-3,      (short)-1, 
        (short)22,      (short)97,      (short)-1,      (short)96, 
        (short)-1,      (short)5,      (short)80,      (short)-19, 
        (short)-11,      (short)-7,      (short)-3,      (short)-1, 
        (short)36,      (short)66,      (short)-1,      (short)51, 
        (short)4,      (short)-1,      (short)20,      (short)65, 
        (short)-3,      (short)-1,      (short)64,      (short)35, 
        (short)-1,      (short)50,      (short)3,      (short)-3, 
        (short)-1,      (short)19,      (short)49,      (short)-1, 
        (short)48,      (short)34,      (short)-7,      (short)-3, 
        (short)-1,      (short)18,      (short)33,      (short)-1, 
        (short)2,      (short)32,      (short)17,      (short)-1, 
        (short)1,      (short)16,      (short)0};
#line 98 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab11[127]  = 
#line 98
  {      (short)-121,      (short)-113,      (short)-89,      (short)-59, 
        (short)-43,      (short)-27,      (short)-17,      (short)-7, 
        (short)-3,      (short)-1,      (short)119,      (short)103, 
        (short)-1,      (short)118,      (short)117,      (short)-3, 
        (short)-1,      (short)102,      (short)71,      (short)-1, 
        (short)116,      (short)-1,      (short)87,      (short)85, 
        (short)-5,      (short)-3,      (short)-1,      (short)86, 
        (short)101,      (short)55,      (short)-1,      (short)115, 
        (short)70,      (short)-9,      (short)-7,      (short)-3, 
        (short)-1,      (short)69,      (short)84,      (short)-1, 
        (short)53,      (short)83,      (short)39,      (short)-1, 
        (short)114,      (short)-1,      (short)100,      (short)7, 
        (short)-5,      (short)-1,      (short)113,      (short)-1, 
        (short)23,      (short)112,      (short)-3,      (short)-1, 
        (short)54,      (short)99,      (short)-1,      (short)96, 
        (short)-1,      (short)68,      (short)37,      (short)-13, 
        (short)-7,      (short)-5,      (short)-3,      (short)-1, 
        (short)82,      (short)5,      (short)21,      (short)98, 
        (short)-3,      (short)-1,      (short)38,      (short)6, 
        (short)22,      (short)-5,      (short)-1,      (short)97, 
        (short)-1,      (short)81,      (short)52,      (short)-5, 
        (short)-1,      (short)80,      (short)-1,      (short)67, 
        (short)51,      (short)-1,      (short)36,      (short)66, 
        (short)-15,      (short)-11,      (short)-7,      (short)-3, 
        (short)-1,      (short)20,      (short)65,      (short)-1, 
        (short)4,      (short)64,      (short)-1,      (short)35, 
        (short)50,      (short)-1,      (short)19,      (short)49, 
        (short)-5,      (short)-3,      (short)-1,      (short)3, 
        (short)48,      (short)34,      (short)33,      (short)-5, 
        (short)-1,      (short)18,      (short)-1,      (short)2, 
        (short)32,      (short)17,      (short)-3,      (short)-1, 
        (short)1,      (short)16,      (short)0};
#line 111 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab12[127]  = 
#line 111
  {      (short)-115,      (short)-99,      (short)-73,      (short)-45, 
        (short)-27,      (short)-17,      (short)-9,      (short)-5, 
        (short)-3,      (short)-1,      (short)119,      (short)103, 
        (short)118,      (short)-1,      (short)87,      (short)117, 
        (short)-3,      (short)-1,      (short)102,      (short)71, 
        (short)-1,      (short)116,      (short)101,      (short)-3, 
        (short)-1,      (short)86,      (short)55,      (short)-3, 
        (short)-1,      (short)115,      (short)85,      (short)39, 
        (short)-7,      (short)-3,      (short)-1,      (short)114, 
        (short)70,      (short)-1,      (short)100,      (short)23, 
        (short)-5,      (short)-1,      (short)113,      (short)-1, 
        (short)7,      (short)112,      (short)-1,      (short)54, 
        (short)99,      (short)-13,      (short)-9,      (short)-3, 
        (short)-1,      (short)69,      (short)84,      (short)-1, 
        (short)68,      (short)-1,      (short)6,      (short)5, 
        (short)-1,      (short)38,      (short)98,      (short)-5, 
        (short)-1,      (short)97,      (short)-1,      (short)22, 
        (short)96,      (short)-3,      (short)-1,      (short)53, 
        (short)83,      (short)-1,      (short)37,      (short)82, 
        (short)-17,      (short)-7,      (short)-3,      (short)-1, 
        (short)21,      (short)81,      (short)-1,      (short)52, 
        (short)67,      (short)-5,      (short)-3,      (short)-1, 
        (short)80,      (short)4,      (short)36,      (short)-1, 
        (short)66,      (short)20,      (short)-3,      (short)-1, 
        (short)51,      (short)65,      (short)-1,      (short)35, 
        (short)50,      (short)-11,      (short)-7,      (short)-5, 
        (short)-3,      (short)-1,      (short)64,      (short)3, 
        (short)48,      (short)19,      (short)-1,      (short)49, 
        (short)34,      (short)-1,      (short)18,      (short)33, 
        (short)-7,      (short)-5,      (short)-3,      (short)-1, 
        (short)2,      (short)32,      (short)0,      (short)17, 
        (short)-1,      (short)1,      (short)16};
#line 124 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab13[511]  = 
#line 124
  {      (short)-509,      (short)-503,      (short)-475,      (short)-405, 
        (short)-333,      (short)-265,      (short)-205,      (short)-153, 
        (short)-115,      (short)-83,      (short)-53,      (short)-35, 
        (short)-21,      (short)-13,      (short)-9,      (short)-7, 
        (short)-5,      (short)-3,      (short)-1,      (short)254, 
        (short)252,      (short)253,      (short)237,      (short)255, 
        (short)-1,      (short)239,      (short)223,      (short)-3, 
        (short)-1,      (short)238,      (short)207,      (short)-1, 
        (short)222,      (short)191,      (short)-9,      (short)-3, 
        (short)-1,      (short)251,      (short)206,      (short)-1, 
        (short)220,      (short)-1,      (short)175,      (short)233, 
        (short)-1,      (short)236,      (short)221,      (short)-9, 
        (short)-5,      (short)-3,      (short)-1,      (short)250, 
        (short)205,      (short)190,      (short)-1,      (short)235, 
        (short)159,      (short)-3,      (short)-1,      (short)249, 
        (short)234,      (short)-1,      (short)189,      (short)219, 
        (short)-17,      (short)-9,      (short)-3,      (short)-1, 
        (short)143,      (short)248,      (short)-1,      (short)204, 
        (short)-1,      (short)174,      (short)158,      (short)-5, 
        (short)-1,      (short)142,      (short)-1,      (short)127, 
        (short)126,      (short)247,      (short)-5,      (short)-1, 
        (short)218,      (short)-1,      (short)173,      (short)188, 
        (short)-3,      (short)-1,      (short)203,      (short)246, 
        (short)111,      (short)-15,      (short)-7,      (short)-3, 
        (short)-1,      (short)232,      (short)95,      (short)-1, 
        (short)157,      (short)217,      (short)-3,      (short)-1, 
        (short)245,      (short)231,      (short)-1,      (short)172, 
        (short)187,      (short)-9,      (short)-3,      (short)-1, 
        (short)79,      (short)244,      (short)-3,      (short)-1, 
        (short)202,      (short)230,      (short)243,      (short)-1, 
        (short)63,      (short)-1,      (short)141,      (short)216, 
        (short)-21,      (short)-9,      (short)-3,      (short)-1, 
        (short)47,      (short)242,      (short)-3,      (short)-1, 
        (short)110,      (short)156,      (short)15,      (short)-5, 
        (short)-3,      (short)-1,      (short)201,      (short)94, 
        (short)171,      (short)-3,      (short)-1,      (short)125, 
        (short)215,      (short)78,      (short)-11,      (short)-5, 
        (short)-3,      (short)-1,      (short)200,      (short)214, 
        (short)62,      (short)-1,      (short)185,      (short)-1, 
        (short)155,      (short)170,      (short)-1,      (short)31, 
        (short)241,      (short)-23,      (short)-13,      (short)-5, 
        (short)-1,      (short)240,      (short)-1,      (short)186, 
        (short)229,      (short)-3,      (short)-1,      (short)228, 
        (short)140,      (short)-1,      (short)109,      (short)227, 
        (short)-5,      (short)-1,      (short)226,      (short)-1, 
        (short)46,      (short)14,      (short)-1,      (short)30, 
        (short)225,      (short)-15,      (short)-7,      (short)-3, 
        (short)-1,      (short)224,      (short)93,      (short)-1, 
        (short)213,      (short)124,      (short)-3,      (short)-1, 
        (short)199,      (short)77,      (short)-1,      (short)139, 
        (short)184,      (short)-7,      (short)-3,      (short)-1, 
        (short)212,      (short)154,      (short)-1,      (short)169, 
        (short)108,      (short)-1,      (short)198,      (short)61, 
        (short)-37,      (short)-21,      (short)-9,      (short)-5, 
        (short)-3,      (short)-1,      (short)211,      (short)123, 
        (short)45,      (short)-1,      (short)210,      (short)29, 
        (short)-5,      (short)-1,      (short)183,      (short)-1, 
        (short)92,      (short)197,      (short)-3,      (short)-1, 
        (short)153,      (short)122,      (short)195,      (short)-7, 
        (short)-5,      (short)-3,      (short)-1,      (short)167, 
        (short)151,      (short)75,      (short)209,      (short)-3, 
        (short)-1,      (short)13,      (short)208,      (short)-1, 
        (short)138,      (short)168,      (short)-11,      (short)-7, 
        (short)-3,      (short)-1,      (short)76,      (short)196, 
        (short)-1,      (short)107,      (short)182,      (short)-1, 
        (short)60,      (short)44,      (short)-3,      (short)-1, 
        (short)194,      (short)91,      (short)-3,      (short)-1, 
        (short)181,      (short)137,      (short)28,      (short)-43, 
        (short)-23,      (short)-11,      (short)-5,      (short)-1, 
        (short)193,      (short)-1,      (short)152,      (short)12, 
        (short)-1,      (short)192,      (short)-1,      (short)180, 
        (short)106,      (short)-5,      (short)-3,      (short)-1, 
        (short)166,      (short)121,      (short)59,      (short)-1, 
        (short)179,      (short)-1,      (short)136,      (short)90, 
        (short)-11,      (short)-5,      (short)-1,      (short)43, 
        (short)-1,      (short)165,      (short)105,      (short)-1, 
        (short)164,      (short)-1,      (short)120,      (short)135, 
        (short)-5,      (short)-1,      (short)148,      (short)-1, 
        (short)119,      (short)118,      (short)178,      (short)-11, 
        (short)-3,      (short)-1,      (short)27,      (short)177, 
        (short)-3,      (short)-1,      (short)11,      (short)176, 
        (short)-1,      (short)150,      (short)74,      (short)-7, 
        (short)-3,      (short)-1,      (short)58,      (short)163, 
        (short)-1,      (short)89,      (short)149,      (short)-1, 
        (short)42,      (short)162,      (short)-47,      (short)-23, 
        (short)-9,      (short)-3,      (short)-1,      (short)26, 
        (short)161,      (short)-3,      (short)-1,      (short)10, 
        (short)104,      (short)160,      (short)-5,      (short)-3, 
        (short)-1,      (short)134,      (short)73,      (short)147, 
        (short)-3,      (short)-1,      (short)57,      (short)88, 
        (short)-1,      (short)133,      (short)103,      (short)-9, 
        (short)-3,      (short)-1,      (short)41,      (short)146, 
        (short)-3,      (short)-1,      (short)87,      (short)117, 
        (short)56,      (short)-5,      (short)-1,      (short)131, 
        (short)-1,      (short)102,      (short)71,      (short)-3, 
        (short)-1,      (short)116,      (short)86,      (short)-1, 
        (short)101,      (short)115,      (short)-11,      (short)-3, 
        (short)-1,      (short)25,      (short)145,      (short)-3, 
        (short)-1,      (short)9,      (short)144,      (short)-1, 
        (short)72,      (short)132,      (short)-7,      (short)-5, 
        (short)-1,      (short)114,      (short)-1,      (short)70, 
        (short)100,      (short)40,      (short)-1,      (short)130, 
        (short)24,      (short)-41,      (short)-27,      (short)-11, 
        (short)-5,      (short)-3,      (short)-1,      (short)55, 
        (short)39,      (short)23,      (short)-1,      (short)113, 
        (short)-1,      (short)85,      (short)7,      (short)-7, 
        (short)-3,      (short)-1,      (short)112,      (short)54, 
        (short)-1,      (short)99,      (short)69,      (short)-3, 
        (short)-1,      (short)84,      (short)38,      (short)-1, 
        (short)98,      (short)53,      (short)-5,      (short)-1, 
        (short)129,      (short)-1,      (short)8,      (short)128, 
        (short)-3,      (short)-1,      (short)22,      (short)97, 
        (short)-1,      (short)6,      (short)96,      (short)-13, 
        (short)-9,      (short)-5,      (short)-3,      (short)-1, 
        (short)83,      (short)68,      (short)37,      (short)-1, 
        (short)82,      (short)5,      (short)-1,      (short)21, 
        (short)81,      (short)-7,      (short)-3,      (short)-1, 
        (short)52,      (short)67,      (short)-1,      (short)80, 
        (short)36,      (short)-3,      (short)-1,      (short)66, 
        (short)51,      (short)20,      (short)-19,      (short)-11, 
        (short)-5,      (short)-1,      (short)65,      (short)-1, 
        (short)4,      (short)64,      (short)-3,      (short)-1, 
        (short)35,      (short)50,      (short)19,      (short)-3, 
        (short)-1,      (short)49,      (short)3,      (short)-1, 
        (short)48,      (short)34,      (short)-3,      (short)-1, 
        (short)18,      (short)33,      (short)-1,      (short)2, 
        (short)32,      (short)-3,      (short)-1,      (short)17, 
        (short)1,      (short)16,      (short)0};
#line 163 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab15[511]  = 
#line 163
  {      (short)-495,      (short)-445,      (short)-355,      (short)-263, 
        (short)-183,      (short)-115,      (short)-77,      (short)-43, 
        (short)-27,      (short)-13,      (short)-7,      (short)-3, 
        (short)-1,      (short)255,      (short)239,      (short)-1, 
        (short)254,      (short)223,      (short)-1,      (short)238, 
        (short)-1,      (short)253,      (short)207,      (short)-7, 
        (short)-3,      (short)-1,      (short)252,      (short)222, 
        (short)-1,      (short)237,      (short)191,      (short)-1, 
        (short)251,      (short)-1,      (short)206,      (short)236, 
        (short)-7,      (short)-3,      (short)-1,      (short)221, 
        (short)175,      (short)-1,      (short)250,      (short)190, 
        (short)-3,      (short)-1,      (short)235,      (short)205, 
        (short)-1,      (short)220,      (short)159,      (short)-15, 
        (short)-7,      (short)-3,      (short)-1,      (short)249, 
        (short)234,      (short)-1,      (short)189,      (short)219, 
        (short)-3,      (short)-1,      (short)143,      (short)248, 
        (short)-1,      (short)204,      (short)158,      (short)-7, 
        (short)-3,      (short)-1,      (short)233,      (short)127, 
        (short)-1,      (short)247,      (short)173,      (short)-3, 
        (short)-1,      (short)218,      (short)188,      (short)-1, 
        (short)111,      (short)-1,      (short)174,      (short)15, 
        (short)-19,      (short)-11,      (short)-3,      (short)-1, 
        (short)203,      (short)246,      (short)-3,      (short)-1, 
        (short)142,      (short)232,      (short)-1,      (short)95, 
        (short)157,      (short)-3,      (short)-1,      (short)245, 
        (short)126,      (short)-1,      (short)231,      (short)172, 
        (short)-9,      (short)-3,      (short)-1,      (short)202, 
        (short)187,      (short)-3,      (short)-1,      (short)217, 
        (short)141,      (short)79,      (short)-3,      (short)-1, 
        (short)244,      (short)63,      (short)-1,      (short)243, 
        (short)216,      (short)-33,      (short)-17,      (short)-9, 
        (short)-3,      (short)-1,      (short)230,      (short)47, 
        (short)-1,      (short)242,      (short)-1,      (short)110, 
        (short)240,      (short)-3,      (short)-1,      (short)31, 
        (short)241,      (short)-1,      (short)156,      (short)201, 
        (short)-7,      (short)-3,      (short)-1,      (short)94, 
        (short)171,      (short)-1,      (short)186,      (short)229, 
        (short)-3,      (short)-1,      (short)125,      (short)215, 
        (short)-1,      (short)78,      (short)228,      (short)-15, 
        (short)-7,      (short)-3,      (short)-1,      (short)140, 
        (short)200,      (short)-1,      (short)62,      (short)109, 
        (short)-3,      (short)-1,      (short)214,      (short)227, 
        (short)-1,      (short)155,      (short)185,      (short)-7, 
        (short)-3,      (short)-1,      (short)46,      (short)170, 
        (short)-1,      (short)226,      (short)30,      (short)-5, 
        (short)-1,      (short)225,      (short)-1,      (short)14, 
        (short)224,      (short)-1,      (short)93,      (short)213, 
        (short)-45,      (short)-25,      (short)-13,      (short)-7, 
        (short)-3,      (short)-1,      (short)124,      (short)199, 
        (short)-1,      (short)77,      (short)139,      (short)-1, 
        (short)212,      (short)-1,      (short)184,      (short)154, 
        (short)-7,      (short)-3,      (short)-1,      (short)169, 
        (short)108,      (short)-1,      (short)198,      (short)61, 
        (short)-1,      (short)211,      (short)210,      (short)-9, 
        (short)-5,      (short)-3,      (short)-1,      (short)45, 
        (short)13,      (short)29,      (short)-1,      (short)123, 
        (short)183,      (short)-5,      (short)-1,      (short)209, 
        (short)-1,      (short)92,      (short)208,      (short)-1, 
        (short)197,      (short)138,      (short)-17,      (short)-7, 
        (short)-3,      (short)-1,      (short)168,      (short)76, 
        (short)-1,      (short)196,      (short)107,      (short)-5, 
        (short)-1,      (short)182,      (short)-1,      (short)153, 
        (short)12,      (short)-1,      (short)60,      (short)195, 
        (short)-9,      (short)-3,      (short)-1,      (short)122, 
        (short)167,      (short)-1,      (short)166,      (short)-1, 
        (short)192,      (short)11,      (short)-1,      (short)194, 
        (short)-1,      (short)44,      (short)91,      (short)-55, 
        (short)-29,      (short)-15,      (short)-7,      (short)-3, 
        (short)-1,      (short)181,      (short)28,      (short)-1, 
        (short)137,      (short)152,      (short)-3,      (short)-1, 
        (short)193,      (short)75,      (short)-1,      (short)180, 
        (short)106,      (short)-5,      (short)-3,      (short)-1, 
        (short)59,      (short)121,      (short)179,      (short)-3, 
        (short)-1,      (short)151,      (short)136,      (short)-1, 
        (short)43,      (short)90,      (short)-11,      (short)-5, 
        (short)-1,      (short)178,      (short)-1,      (short)165, 
        (short)27,      (short)-1,      (short)177,      (short)-1, 
        (short)176,      (short)105,      (short)-7,      (short)-3, 
        (short)-1,      (short)150,      (short)74,      (short)-1, 
        (short)164,      (short)120,      (short)-3,      (short)-1, 
        (short)135,      (short)58,      (short)163,      (short)-17, 
        (short)-7,      (short)-3,      (short)-1,      (short)89, 
        (short)149,      (short)-1,      (short)42,      (short)162, 
        (short)-3,      (short)-1,      (short)26,      (short)161, 
        (short)-3,      (short)-1,      (short)10,      (short)160, 
        (short)104,      (short)-7,      (short)-3,      (short)-1, 
        (short)134,      (short)73,      (short)-1,      (short)148, 
        (short)57,      (short)-5,      (short)-1,      (short)147, 
        (short)-1,      (short)119,      (short)9,      (short)-1, 
        (short)88,      (short)133,      (short)-53,      (short)-29, 
        (short)-13,      (short)-7,      (short)-3,      (short)-1, 
        (short)41,      (short)103,      (short)-1,      (short)118, 
        (short)146,      (short)-1,      (short)145,      (short)-1, 
        (short)25,      (short)144,      (short)-7,      (short)-3, 
        (short)-1,      (short)72,      (short)132,      (short)-1, 
        (short)87,      (short)117,      (short)-3,      (short)-1, 
        (short)56,      (short)131,      (short)-1,      (short)102, 
        (short)71,      (short)-7,      (short)-3,      (short)-1, 
        (short)40,      (short)130,      (short)-1,      (short)24, 
        (short)129,      (short)-7,      (short)-3,      (short)-1, 
        (short)116,      (short)8,      (short)-1,      (short)128, 
        (short)86,      (short)-3,      (short)-1,      (short)101, 
        (short)55,      (short)-1,      (short)115,      (short)70, 
        (short)-17,      (short)-7,      (short)-3,      (short)-1, 
        (short)39,      (short)114,      (short)-1,      (short)100, 
        (short)23,      (short)-3,      (short)-1,      (short)85, 
        (short)113,      (short)-3,      (short)-1,      (short)7, 
        (short)112,      (short)54,      (short)-7,      (short)-3, 
        (short)-1,      (short)99,      (short)69,      (short)-1, 
        (short)84,      (short)38,      (short)-3,      (short)-1, 
        (short)98,      (short)22,      (short)-3,      (short)-1, 
        (short)6,      (short)96,      (short)53,      (short)-33, 
        (short)-19,      (short)-9,      (short)-5,      (short)-1, 
        (short)97,      (short)-1,      (short)83,      (short)68, 
        (short)-1,      (short)37,      (short)82,      (short)-3, 
        (short)-1,      (short)21,      (short)81,      (short)-3, 
        (short)-1,      (short)5,      (short)80,      (short)52, 
        (short)-7,      (short)-3,      (short)-1,      (short)67, 
        (short)36,      (short)-1,      (short)66,      (short)51, 
        (short)-1,      (short)65,      (short)-1,      (short)20, 
        (short)4,      (short)-9,      (short)-3,      (short)-1, 
        (short)35,      (short)50,      (short)-3,      (short)-1, 
        (short)64,      (short)3,      (short)19,      (short)-3, 
        (short)-1,      (short)49,      (short)48,      (short)34, 
        (short)-9,      (short)-7,      (short)-3,      (short)-1, 
        (short)18,      (short)33,      (short)-1,      (short)2, 
        (short)32,      (short)17,      (short)-3,      (short)-1, 
        (short)1,      (short)16,      (short)0};
#line 202 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab16[511]  = 
#line 202
  {      (short)-509,      (short)-503,      (short)-461,      (short)-323, 
        (short)-103,      (short)-37,      (short)-27,      (short)-15, 
        (short)-7,      (short)-3,      (short)-1,      (short)239, 
        (short)254,      (short)-1,      (short)223,      (short)253, 
        (short)-3,      (short)-1,      (short)207,      (short)252, 
        (short)-1,      (short)191,      (short)251,      (short)-5, 
        (short)-1,      (short)175,      (short)-1,      (short)250, 
        (short)159,      (short)-3,      (short)-1,      (short)249, 
        (short)248,      (short)143,      (short)-7,      (short)-3, 
        (short)-1,      (short)127,      (short)247,      (short)-1, 
        (short)111,      (short)246,      (short)255,      (short)-9, 
        (short)-5,      (short)-3,      (short)-1,      (short)95, 
        (short)245,      (short)79,      (short)-1,      (short)244, 
        (short)243,      (short)-53,      (short)-1,      (short)240, 
        (short)-1,      (short)63,      (short)-29,      (short)-19, 
        (short)-13,      (short)-7,      (short)-5,      (short)-1, 
        (short)206,      (short)-1,      (short)236,      (short)221, 
        (short)222,      (short)-1,      (short)233,      (short)-1, 
        (short)234,      (short)217,      (short)-1,      (short)238, 
        (short)-1,      (short)237,      (short)235,      (short)-3, 
        (short)-1,      (short)190,      (short)205,      (short)-3, 
        (short)-1,      (short)220,      (short)219,      (short)174, 
        (short)-11,      (short)-5,      (short)-1,      (short)204, 
        (short)-1,      (short)173,      (short)218,      (short)-3, 
        (short)-1,      (short)126,      (short)172,      (short)202, 
        (short)-5,      (short)-3,      (short)-1,      (short)201, 
        (short)125,      (short)94,      (short)189,      (short)242, 
        (short)-93,      (short)-5,      (short)-3,      (short)-1, 
        (short)47,      (short)15,      (short)31,      (short)-1, 
        (short)241,      (short)-49,      (short)-25,      (short)-13, 
        (short)-5,      (short)-1,      (short)158,      (short)-1, 
        (short)188,      (short)203,      (short)-3,      (short)-1, 
        (short)142,      (short)232,      (short)-1,      (short)157, 
        (short)231,      (short)-7,      (short)-3,      (short)-1, 
        (short)187,      (short)141,      (short)-1,      (short)216, 
        (short)110,      (short)-1,      (short)230,      (short)156, 
        (short)-13,      (short)-7,      (short)-3,      (short)-1, 
        (short)171,      (short)186,      (short)-1,      (short)229, 
        (short)215,      (short)-1,      (short)78,      (short)-1, 
        (short)228,      (short)140,      (short)-3,      (short)-1, 
        (short)200,      (short)62,      (short)-1,      (short)109, 
        (short)-1,      (short)214,      (short)155,      (short)-19, 
        (short)-11,      (short)-5,      (short)-3,      (short)-1, 
        (short)185,      (short)170,      (short)225,      (short)-1, 
        (short)212,      (short)-1,      (short)184,      (short)169, 
        (short)-5,      (short)-1,      (short)123,      (short)-1, 
        (short)183,      (short)208,      (short)227,      (short)-7, 
        (short)-3,      (short)-1,      (short)14,      (short)224, 
        (short)-1,      (short)93,      (short)213,      (short)-3, 
        (short)-1,      (short)124,      (short)199,      (short)-1, 
        (short)77,      (short)139,      (short)-75,      (short)-45, 
        (short)-27,      (short)-13,      (short)-7,      (short)-3, 
        (short)-1,      (short)154,      (short)108,      (short)-1, 
        (short)198,      (short)61,      (short)-3,      (short)-1, 
        (short)92,      (short)197,      (short)13,      (short)-7, 
        (short)-3,      (short)-1,      (short)138,      (short)168, 
        (short)-1,      (short)153,      (short)76,      (short)-3, 
        (short)-1,      (short)182,      (short)122,      (short)60, 
        (short)-11,      (short)-5,      (short)-3,      (short)-1, 
        (short)91,      (short)137,      (short)28,      (short)-1, 
        (short)192,      (short)-1,      (short)152,      (short)121, 
        (short)-1,      (short)226,      (short)-1,      (short)46, 
        (short)30,      (short)-15,      (short)-7,      (short)-3, 
        (short)-1,      (short)211,      (short)45,      (short)-1, 
        (short)210,      (short)209,      (short)-5,      (short)-1, 
        (short)59,      (short)-1,      (short)151,      (short)136, 
        (short)29,      (short)-7,      (short)-3,      (short)-1, 
        (short)196,      (short)107,      (short)-1,      (short)195, 
        (short)167,      (short)-1,      (short)44,      (short)-1, 
        (short)194,      (short)181,      (short)-23,      (short)-13, 
        (short)-7,      (short)-3,      (short)-1,      (short)193, 
        (short)12,      (short)-1,      (short)75,      (short)180, 
        (short)-3,      (short)-1,      (short)106,      (short)166, 
        (short)179,      (short)-5,      (short)-3,      (short)-1, 
        (short)90,      (short)165,      (short)43,      (short)-1, 
        (short)178,      (short)27,      (short)-13,      (short)-5, 
        (short)-1,      (short)177,      (short)-1,      (short)11, 
        (short)176,      (short)-3,      (short)-1,      (short)105, 
        (short)150,      (short)-1,      (short)74,      (short)164, 
        (short)-5,      (short)-3,      (short)-1,      (short)120, 
        (short)135,      (short)163,      (short)-3,      (short)-1, 
        (short)58,      (short)89,      (short)42,      (short)-97, 
        (short)-57,      (short)-33,      (short)-19,      (short)-11, 
        (short)-5,      (short)-3,      (short)-1,      (short)149, 
        (short)104,      (short)161,      (short)-3,      (short)-1, 
        (short)134,      (short)119,      (short)148,      (short)-5, 
        (short)-3,      (short)-1,      (short)73,      (short)87, 
        (short)103,      (short)162,      (short)-5,      (short)-1, 
        (short)26,      (short)-1,      (short)10,      (short)160, 
        (short)-3,      (short)-1,      (short)57,      (short)147, 
        (short)-1,      (short)88,      (short)133,      (short)-9, 
        (short)-3,      (short)-1,      (short)41,      (short)146, 
        (short)-3,      (short)-1,      (short)118,      (short)9, 
        (short)25,      (short)-5,      (short)-1,      (short)145, 
        (short)-1,      (short)144,      (short)72,      (short)-3, 
        (short)-1,      (short)132,      (short)117,      (short)-1, 
        (short)56,      (short)131,      (short)-21,      (short)-11, 
        (short)-5,      (short)-3,      (short)-1,      (short)102, 
        (short)40,      (short)130,      (short)-3,      (short)-1, 
        (short)71,      (short)116,      (short)24,      (short)-3, 
        (short)-1,      (short)129,      (short)128,      (short)-3, 
        (short)-1,      (short)8,      (short)86,      (short)55, 
        (short)-9,      (short)-5,      (short)-1,      (short)115, 
        (short)-1,      (short)101,      (short)70,      (short)-1, 
        (short)39,      (short)114,      (short)-5,      (short)-3, 
        (short)-1,      (short)100,      (short)85,      (short)7, 
        (short)23,      (short)-23,      (short)-13,      (short)-5, 
        (short)-1,      (short)113,      (short)-1,      (short)112, 
        (short)54,      (short)-3,      (short)-1,      (short)99, 
        (short)69,      (short)-1,      (short)84,      (short)38, 
        (short)-3,      (short)-1,      (short)98,      (short)22, 
        (short)-1,      (short)97,      (short)-1,      (short)6, 
        (short)96,      (short)-9,      (short)-5,      (short)-1, 
        (short)83,      (short)-1,      (short)53,      (short)68, 
        (short)-1,      (short)37,      (short)82,      (short)-1, 
        (short)81,      (short)-1,      (short)21,      (short)5, 
        (short)-33,      (short)-23,      (short)-13,      (short)-7, 
        (short)-3,      (short)-1,      (short)52,      (short)67, 
        (short)-1,      (short)80,      (short)36,      (short)-3, 
        (short)-1,      (short)66,      (short)51,      (short)20, 
        (short)-5,      (short)-1,      (short)65,      (short)-1, 
        (short)4,      (short)64,      (short)-1,      (short)35, 
        (short)50,      (short)-3,      (short)-1,      (short)19, 
        (short)49,      (short)-3,      (short)-1,      (short)3, 
        (short)48,      (short)34,      (short)-3,      (short)-1, 
        (short)18,      (short)33,      (short)-1,      (short)2, 
        (short)32,      (short)-3,      (short)-1,      (short)17, 
        (short)1,      (short)16,      (short)0};
#line 241 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab24[511]  = 
#line 241
  {      (short)-451,      (short)-117,      (short)-43,      (short)-25, 
        (short)-15,      (short)-7,      (short)-3,      (short)-1, 
        (short)239,      (short)254,      (short)-1,      (short)223, 
        (short)253,      (short)-3,      (short)-1,      (short)207, 
        (short)252,      (short)-1,      (short)191,      (short)251, 
        (short)-5,      (short)-1,      (short)250,      (short)-1, 
        (short)175,      (short)159,      (short)-1,      (short)249, 
        (short)248,      (short)-9,      (short)-5,      (short)-3, 
        (short)-1,      (short)143,      (short)127,      (short)247, 
        (short)-1,      (short)111,      (short)246,      (short)-3, 
        (short)-1,      (short)95,      (short)245,      (short)-1, 
        (short)79,      (short)244,      (short)-71,      (short)-7, 
        (short)-3,      (short)-1,      (short)63,      (short)243, 
        (short)-1,      (short)47,      (short)242,      (short)-5, 
        (short)-1,      (short)241,      (short)-1,      (short)31, 
        (short)240,      (short)-25,      (short)-9,      (short)-1, 
        (short)15,      (short)-3,      (short)-1,      (short)238, 
        (short)222,      (short)-1,      (short)237,      (short)206, 
        (short)-7,      (short)-3,      (short)-1,      (short)236, 
        (short)221,      (short)-1,      (short)190,      (short)235, 
        (short)-3,      (short)-1,      (short)205,      (short)220, 
        (short)-1,      (short)174,      (short)234,      (short)-15, 
        (short)-7,      (short)-3,      (short)-1,      (short)189, 
        (short)219,      (short)-1,      (short)204,      (short)158, 
        (short)-3,      (short)-1,      (short)233,      (short)173, 
        (short)-1,      (short)218,      (short)188,      (short)-7, 
        (short)-3,      (short)-1,      (short)203,      (short)142, 
        (short)-1,      (short)232,      (short)157,      (short)-3, 
        (short)-1,      (short)217,      (short)126,      (short)-1, 
        (short)231,      (short)172,      (short)255,      (short)-235, 
        (short)-143,      (short)-77,      (short)-45,      (short)-25, 
        (short)-15,      (short)-7,      (short)-3,      (short)-1, 
        (short)202,      (short)187,      (short)-1,      (short)141, 
        (short)216,      (short)-5,      (short)-3,      (short)-1, 
        (short)14,      (short)224,      (short)13,      (short)230, 
        (short)-5,      (short)-3,      (short)-1,      (short)110, 
        (short)156,      (short)201,      (short)-1,      (short)94, 
        (short)186,      (short)-9,      (short)-5,      (short)-1, 
        (short)229,      (short)-1,      (short)171,      (short)125, 
        (short)-1,      (short)215,      (short)228,      (short)-3, 
        (short)-1,      (short)140,      (short)200,      (short)-3, 
        (short)-1,      (short)78,      (short)46,      (short)62, 
        (short)-15,      (short)-7,      (short)-3,      (short)-1, 
        (short)109,      (short)214,      (short)-1,      (short)227, 
        (short)155,      (short)-3,      (short)-1,      (short)185, 
        (short)170,      (short)-1,      (short)226,      (short)30, 
        (short)-7,      (short)-3,      (short)-1,      (short)225, 
        (short)93,      (short)-1,      (short)213,      (short)124, 
        (short)-3,      (short)-1,      (short)199,      (short)77, 
        (short)-1,      (short)139,      (short)184,      (short)-31, 
        (short)-15,      (short)-7,      (short)-3,      (short)-1, 
        (short)212,      (short)154,      (short)-1,      (short)169, 
        (short)108,      (short)-3,      (short)-1,      (short)198, 
        (short)61,      (short)-1,      (short)211,      (short)45, 
        (short)-7,      (short)-3,      (short)-1,      (short)210, 
        (short)29,      (short)-1,      (short)123,      (short)183, 
        (short)-3,      (short)-1,      (short)209,      (short)92, 
        (short)-1,      (short)197,      (short)138,      (short)-17, 
        (short)-7,      (short)-3,      (short)-1,      (short)168, 
        (short)153,      (short)-1,      (short)76,      (short)196, 
        (short)-3,      (short)-1,      (short)107,      (short)182, 
        (short)-3,      (short)-1,      (short)208,      (short)12, 
        (short)60,      (short)-7,      (short)-3,      (short)-1, 
        (short)195,      (short)122,      (short)-1,      (short)167, 
        (short)44,      (short)-3,      (short)-1,      (short)194, 
        (short)91,      (short)-1,      (short)181,      (short)28, 
        (short)-57,      (short)-35,      (short)-19,      (short)-7, 
        (short)-3,      (short)-1,      (short)137,      (short)152, 
        (short)-1,      (short)193,      (short)75,      (short)-5, 
        (short)-3,      (short)-1,      (short)192,      (short)11, 
        (short)59,      (short)-3,      (short)-1,      (short)176, 
        (short)10,      (short)26,      (short)-5,      (short)-1, 
        (short)180,      (short)-1,      (short)106,      (short)166, 
        (short)-3,      (short)-1,      (short)121,      (short)151, 
        (short)-3,      (short)-1,      (short)160,      (short)9, 
        (short)144,      (short)-9,      (short)-3,      (short)-1, 
        (short)179,      (short)136,      (short)-3,      (short)-1, 
        (short)43,      (short)90,      (short)178,      (short)-7, 
        (short)-3,      (short)-1,      (short)165,      (short)27, 
        (short)-1,      (short)177,      (short)105,      (short)-1, 
        (short)150,      (short)164,      (short)-17,      (short)-9, 
        (short)-5,      (short)-3,      (short)-1,      (short)74, 
        (short)120,      (short)135,      (short)-1,      (short)58, 
        (short)163,      (short)-3,      (short)-1,      (short)89, 
        (short)149,      (short)-1,      (short)42,      (short)162, 
        (short)-7,      (short)-3,      (short)-1,      (short)161, 
        (short)104,      (short)-1,      (short)134,      (short)119, 
        (short)-3,      (short)-1,      (short)73,      (short)148, 
        (short)-1,      (short)57,      (short)147,      (short)-63, 
        (short)-31,      (short)-15,      (short)-7,      (short)-3, 
        (short)-1,      (short)88,      (short)133,      (short)-1, 
        (short)41,      (short)103,      (short)-3,      (short)-1, 
        (short)118,      (short)146,      (short)-1,      (short)25, 
        (short)145,      (short)-7,      (short)-3,      (short)-1, 
        (short)72,      (short)132,      (short)-1,      (short)87, 
        (short)117,      (short)-3,      (short)-1,      (short)56, 
        (short)131,      (short)-1,      (short)102,      (short)40, 
        (short)-17,      (short)-7,      (short)-3,      (short)-1, 
        (short)130,      (short)24,      (short)-1,      (short)71, 
        (short)116,      (short)-5,      (short)-1,      (short)129, 
        (short)-1,      (short)8,      (short)128,      (short)-1, 
        (short)86,      (short)101,      (short)-7,      (short)-5, 
        (short)-1,      (short)23,      (short)-1,      (short)7, 
        (short)112,      (short)115,      (short)-3,      (short)-1, 
        (short)55,      (short)39,      (short)114,      (short)-15, 
        (short)-7,      (short)-3,      (short)-1,      (short)70, 
        (short)100,      (short)-1,      (short)85,      (short)113, 
        (short)-3,      (short)-1,      (short)54,      (short)99, 
        (short)-1,      (short)69,      (short)84,      (short)-7, 
        (short)-3,      (short)-1,      (short)38,      (short)98, 
        (short)-1,      (short)22,      (short)97,      (short)-5, 
        (short)-3,      (short)-1,      (short)6,      (short)96, 
        (short)53,      (short)-1,      (short)83,      (short)68, 
        (short)-51,      (short)-37,      (short)-23,      (short)-15, 
        (short)-9,      (short)-3,      (short)-1,      (short)37, 
        (short)82,      (short)-1,      (short)21,      (short)-1, 
        (short)5,      (short)80,      (short)-1,      (short)81, 
        (short)-1,      (short)52,      (short)67,      (short)-3, 
        (short)-1,      (short)36,      (short)66,      (short)-1, 
        (short)51,      (short)20,      (short)-9,      (short)-5, 
        (short)-1,      (short)65,      (short)-1,      (short)4, 
        (short)64,      (short)-1,      (short)35,      (short)50, 
        (short)-1,      (short)19,      (short)49,      (short)-7, 
        (short)-5,      (short)-3,      (short)-1,      (short)3, 
        (short)48,      (short)34,      (short)18,      (short)-1, 
        (short)33,      (short)-1,      (short)2,      (short)32, 
        (short)-3,      (short)-1,      (short)17,      (short)1, 
        (short)-1,      (short)16,      (short)0};
#line 280 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab_c0[31]  = 
#line 280
  {      (short)-29,      (short)-21,      (short)-13,      (short)-7, 
        (short)-3,      (short)-1,      (short)11,      (short)15, 
        (short)-1,      (short)13,      (short)14,      (short)-3, 
        (short)-1,      (short)7,      (short)5,      (short)9, 
        (short)-3,      (short)-1,      (short)6,      (short)3, 
        (short)-1,      (short)10,      (short)12,      (short)-3, 
        (short)-1,      (short)2,      (short)1,      (short)-1, 
        (short)4,      (short)8,      (short)0};
#line 287 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static short tab_c1[31]  = 
#line 287
  {      (short)-15,      (short)-7,      (short)-3,      (short)-1, 
        (short)15,      (short)14,      (short)-1,      (short)13, 
        (short)12,      (short)-3,      (short)-1,      (short)11, 
        (short)10,      (short)-1,      (short)9,      (short)8, 
        (short)-7,      (short)-3,      (short)-1,      (short)7, 
        (short)6,      (short)-1,      (short)5,      (short)4, 
        (short)-3,      (short)-1,      (short)3,      (short)2, 
        (short)-1,      (short)1,      (short)0};
#line 296 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static struct newhuff ht[32]  = 
#line 296
  {      {0U, tab0}, 
        {0U, tab1}, 
        {0U, tab2}, 
        {0U, tab3}, 
        {0U, tab0}, 
        {0U, tab5}, 
        {0U, tab6}, 
        {0U, tab7}, 
        {0U, tab8}, 
        {0U, tab9}, 
        {0U, tab10}, 
        {0U, tab11}, 
        {0U, tab12}, 
        {0U, tab13}, 
        {0U, tab0}, 
        {0U, tab15}, 
        {1U, tab16}, 
        {2U, tab16}, 
        {3U, tab16}, 
        {4U, tab16}, 
        {6U, tab16}, 
        {8U, tab16}, 
        {10U, tab16}, 
        {13U, tab16}, 
        {4U, tab24}, 
        {5U, tab24}, 
        {6U, tab24}, 
        {7U, tab24}, 
        {8U, tab24}, 
        {9U, tab24}, 
        {11U, tab24}, 
        {13U, tab24}};
#line 333 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/huffman.h"
static struct newhuff htc[2]  = {      {0U, tab_c0}, 
        {0U, tab_c1}};
#line 40 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/getbits.h"
static unsigned int getbits(mpg123_handle *fr , int number_of_bits ) 
{ 
  unsigned long rval ;

  {
#line 56
  rval = (unsigned long )*(fr->wordpointer + 0);
#line 57
  rval <<= 8;
#line 58
  rval |= (unsigned long )*(fr->wordpointer + 1);
#line 59
  rval <<= 8;
#line 60
  rval |= (unsigned long )*(fr->wordpointer + 2);
#line 62
  rval <<= fr->bitindex;
#line 63
  rval &= 16777215UL;
#line 65
  fr->bitindex += number_of_bits;
#line 67
  rval >>= 24 - number_of_bits;
#line 69
  fr->wordpointer += fr->bitindex >> 3;
#line 70
  fr->bitindex &= 7;
#line 77
  return ((unsigned int )rval);
}
}
#line 32 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float ispow[8207]  ;
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float aa_ca[8]  ;
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float aa_cs[8]  ;
#line 34 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float win[4][36]  ;
#line 35 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float win1[4][36]  ;
#line 36 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
float COS9[9]  ;
#line 37 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float COS6_1  ;
#line 37 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float COS6_2  ;
#line 38 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
float tfcos36[9]  ;
#line 39 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float tfcos12[3]  ;
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float cos9[3]  ;
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float cos18[3]  ;
#line 43 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float tan1_1[16]  ;
#line 43 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float tan2_1[16]  ;
#line 43 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float tan1_2[16]  ;
#line 43 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float tan2_2[16]  ;
#line 44 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float pow1_1[2][16]  ;
#line 44 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float pow2_1[2][16]  ;
#line 44 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float pow1_2[2][16]  ;
#line 44 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static float pow2_2[2][16]  ;
#line 89 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
struct bandInfoStruct  const  bandInfo[9]  = 
#line 89
  {      {{0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 52, 62, 74, 90, 110, 134, 162, 196, 238,
       288, 342, 418, 576}, {4, 4, 4, 4, 4, 4, 6, 6, 8, 8, 10, 12, 16, 20, 24, 28,
                             34, 42, 50, 54, 76, 158}, {0, 12, 24, 36, 48, 66, 90,
                                                        120, 156, 198, 252, 318, 408,
                                                        576}, {4, 4, 4, 4, 6, 8, 10,
                                                               12, 14, 18, 22, 30,
                                                               56}}, 
        {{0, 4, 8, 12, 16, 20, 24, 30, 36, 42, 50, 60, 72, 88, 106, 128, 156, 190, 230,
       276, 330, 384, 576}, {4, 4, 4, 4, 4, 4, 6, 6, 6, 8, 10, 12, 16, 18, 22, 28,
                             34, 40, 46, 54, 54, 192}, {0, 12, 24, 36, 48, 66, 84,
                                                        114, 150, 192, 240, 300, 378,
                                                        576}, {4, 4, 4, 4, 6, 6, 10,
                                                               12, 14, 16, 20, 26,
                                                               66}}, 
        {{0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 54, 66, 82, 102, 126, 156, 194, 240, 296,
       364, 448, 550, 576}, {4, 4, 4, 4, 4, 4, 6, 6, 8, 10, 12, 16, 20, 24, 30, 38,
                             46, 56, 68, 84, 102, 26}, {0, 12, 24, 36, 48, 66, 90,
                                                        126, 174, 234, 312, 414, 540,
                                                        576}, {4, 4, 4, 4, 6, 8, 12,
                                                               16, 20, 26, 34, 42,
                                                               12}}, 
        {{0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284,
       336, 396, 464, 522, 576}, {6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 20, 24, 28,
                                  32, 38, 46, 52, 60, 68, 58, 54}, {0, 12, 24, 36,
                                                                    54, 72, 96, 126,
                                                                    168, 222, 300,
                                                                    396, 522, 576},
      {4, 4, 4, 6, 6, 8, 10, 14, 18, 26, 32, 42, 18}}, 
        {{0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 114, 136, 162, 194, 232, 278,
       332, 394, 464, 540, 576}, {6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 18, 22, 26,
                                  32, 38, 46, 54, 62, 70, 76, 36}, {0, 12, 24, 36,
                                                                    54, 78, 108, 144,
                                                                    186, 240, 312,
                                                                    408, 540, 576},
      {4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 32, 44, 12}}, 
        {{0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284,
       336, 396, 464, 522, 576}, {6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 20, 24, 28,
                                  32, 38, 46, 52, 60, 68, 58, 54}, {0, 12, 24, 36,
                                                                    54, 78, 108, 144,
                                                                    186, 240, 312,
                                                                    402, 522, 576},
      {4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 30, 40, 18}}, 
        {{0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284,
       336, 396, 464, 522, 576}, {6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 20, 24, 28,
                                  32, 38, 46, 52, 60, 68, 58, 54}, {0, 12, 24, 36,
                                                                    54, 78, 108, 144,
                                                                    186, 240, 312,
                                                                    402, 522, 576},
      {4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 30, 40, 18}}, 
        {{0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284,
       336, 396, 464, 522, 576}, {6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 20, 24, 28,
                                  32, 38, 46, 52, 60, 68, 58, 54}, {0, 12, 24, 36,
                                                                    54, 78, 108, 144,
                                                                    186, 240, 312,
                                                                    402, 522, 576},
      {4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 30, 40, 18}}, 
        {{0, 12, 24, 36, 48, 60, 72, 88, 108, 132, 160, 192, 232, 280, 336, 400, 476,
       566, 568, 570, 572, 574, 576}, {12, 12, 12, 12, 12, 12, 16, 20, 24, 28, 32,
                                       40, 48, 56, 64, 76, 90, 2, 2, 2, 2, 2}, {0,
                                                                                24,
                                                                                48,
                                                                                72,
                                                                                108,
                                                                                156,
                                                                                216,
                                                                                288,
                                                                                372,
                                                                                480,
                                                                                486,
                                                                                492,
                                                                                498,
                                                                                576},
      {8, 8, 8, 12, 16, 20, 24, 28, 36, 2, 2, 2, 26}}};
#line 147 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int mapbuf0[9][152]  ;
#line 148 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int mapbuf1[9][156]  ;
#line 149 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int mapbuf2[9][44]  ;
#line 150 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int *map[9][3]  ;
#line 151 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int *mapend[9][3]  ;
#line 153 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static unsigned int n_slen2[512]  ;
#line 154 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static unsigned int i_slen2[256]  ;
#line 159 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
float init_layer3_gainpow2_mmx(mpg123_handle *fr , int i ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 161
  if (! fr->p.down_sample) {
    {
#line 161
    tmp = pow(2.0, - 0.25 * (double )(i + 210));
    }
#line 161
    return ((float )(16384.0 * tmp));
  } else {
    {
#line 162
    tmp___0 = pow(2.0, - 0.25 * (double )(i + 210));
    }
#line 162
    return ((float )tmp___0);
  }
}
}
#line 166 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
float init_layer3_gainpow2(mpg123_handle *fr , int i ) 
{ 
  double tmp ;

  {
  {
#line 171
  tmp = pow(2.0, - 0.25 * (double )(i + 210));
  }
#line 171
  return ((float )tmp);
}
}
#line 177 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
void init_layer3(void) 
{ 
  int i ;
  int j ;
  int k ;
  int l___0 ;
  double tmp ;
  double Ci[8] ;
  double sq ;
  double tmp___0 ;
  float tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  float tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  float tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double t ;
  double tmp___27 ;
  double base ;
  double tmp___28 ;
  double p1 ;
  double p2 ;
  int len[4] ;
  struct bandInfoStruct  const  *bi ;
  int *mp ;
  int cb ;
  int lwin ;
  int const   *bdf ;
  int *tmp___29 ;
  int const   *tmp___30 ;
  int *tmp___31 ;
  int *tmp___32 ;
  int *tmp___33 ;
  int *tmp___34 ;
  int l___1 ;
  int const   *tmp___35 ;
  int *tmp___36 ;
  int *tmp___37 ;
  int *tmp___38 ;
  int *tmp___39 ;
  int *tmp___40 ;
  int l___2 ;
  int const   *tmp___41 ;
  int *tmp___42 ;
  int *tmp___43 ;
  int *tmp___44 ;
  int *tmp___45 ;
  int *tmp___46 ;
  int *tmp___47 ;
  int const   *tmp___48 ;
  int *tmp___49 ;
  int n ;
  int n___0 ;
  int n___1 ;
  int n___2 ;
  int n___3 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;

  {
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < 8207)) {
#line 182
      goto while_break;
    }
    {
#line 183
    tmp = pow((double )i, 4.0 / 3.0);
#line 183
    ispow[i] = (float )tmp;
#line 182
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 185
    if (! (i < 8)) {
#line 185
      goto while_break___0;
    }
    {
#line 187
    Ci[0] = - 0.6;
#line 187
    Ci[1] = - 0.535;
#line 187
    Ci[2] = - 0.33;
#line 187
    Ci[3] = - 0.185;
#line 187
    Ci[4] = - 0.095;
#line 187
    Ci[5] = - 0.041;
#line 187
    Ci[6] = - 0.0142;
#line 187
    Ci[7] = - 0.0037;
#line 188
    tmp___0 = sqrt(1.0 + Ci[i] * Ci[i]);
#line 188
    sq = tmp___0;
#line 189
    aa_cs[i] = (float )(1.0 / sq);
#line 190
    aa_ca[i] = (float )(Ci[i] / sq);
#line 185
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 193
  i = 0;
  {
#line 193
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 193
    if (! (i < 18)) {
#line 193
      goto while_break___1;
    }
    {
#line 195
    tmp___2 = sin((3.14159265358979323846 / 72.0) * (double )(2 * i + 1));
#line 195
    tmp___3 = cos((3.14159265358979323846 * (double )(2 * i + 19)) / 72.0);
#line 195
    tmp___1 = (float )((0.5 * tmp___2) / tmp___3);
#line 195
    win[1][i] = tmp___1;
#line 195
    win[0][i] = tmp___1;
#line 197
    tmp___5 = sin((3.14159265358979323846 / 72.0) * (double )(2 * (i + 18) + 1));
#line 197
    tmp___6 = cos((3.14159265358979323846 * (double )(2 * (i + 18) + 19)) / 72.0);
#line 197
    tmp___4 = (float )((0.5 * tmp___5) / tmp___6);
#line 197
    win[3][i + 18] = tmp___4;
#line 197
    win[0][i + 18] = tmp___4;
#line 193
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 200
    if (! (i < 6)) {
#line 200
      goto while_break___2;
    }
    {
#line 202
    tmp___7 = cos((3.14159265358979323846 * (double )(2 * (i + 18) + 19)) / 72.0);
#line 202
    win[1][i + 18] = (float )(0.5 / tmp___7);
#line 203
    tmp___8 = cos((3.14159265358979323846 * (double )(2 * (i + 12) + 19)) / 72.0);
#line 203
    win[3][i + 12] = (float )(0.5 / tmp___8);
#line 204
    tmp___9 = sin((3.14159265358979323846 / 24.0) * (double )(2 * i + 13));
#line 204
    tmp___10 = cos((3.14159265358979323846 * (double )(2 * (i + 24) + 19)) / 72.0);
#line 204
    win[1][i + 24] = (float )((0.5 * tmp___9) / tmp___10);
#line 205
    tmp___11 = (float )0.0;
#line 205
    win[3][i] = tmp___11;
#line 205
    win[1][i + 30] = tmp___11;
#line 206
    tmp___12 = sin((3.14159265358979323846 / 24.0) * (double )(2 * i + 1));
#line 206
    tmp___13 = cos((3.14159265358979323846 * (double )(2 * (i + 6) + 19)) / 72.0);
#line 206
    win[3][i + 6] = (float )((0.5 * tmp___12) / tmp___13);
#line 200
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 209
  i = 0;
  {
#line 209
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 209
    if (! (i < 9)) {
#line 209
      goto while_break___3;
    }
    {
#line 210
    tmp___14 = cos((3.14159265358979323846 / 18.0) * (double )i);
#line 210
    COS9[i] = (float )tmp___14;
#line 209
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 212
    if (! (i < 9)) {
#line 212
      goto while_break___4;
    }
    {
#line 213
    tmp___15 = cos((3.14159265358979323846 * (double )(i * 2 + 1)) / 36.0);
#line 213
    tfcos36[i] = (float )(0.5 / tmp___15);
#line 212
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 215
    if (! (i < 3)) {
#line 215
      goto while_break___5;
    }
    {
#line 216
    tmp___16 = cos((3.14159265358979323846 * (double )(i * 2 + 1)) / 12.0);
#line 216
    tfcos12[i] = (float )(0.5 / tmp___16);
#line 215
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 218
  tmp___17 = cos((3.14159265358979323846 / 6.0) * (double )1);
#line 218
  COS6_1 = (float )tmp___17;
#line 219
  tmp___18 = cos((3.14159265358979323846 / 6.0) * (double )2);
#line 219
  COS6_2 = (float )tmp___18;
#line 222
  tmp___19 = cos((1.0 * 3.14159265358979323846) / 9.0);
#line 222
  cos9[0] = (float )tmp___19;
#line 223
  tmp___20 = cos((5.0 * 3.14159265358979323846) / 9.0);
#line 223
  cos9[1] = (float )tmp___20;
#line 224
  tmp___21 = cos((7.0 * 3.14159265358979323846) / 9.0);
#line 224
  cos9[2] = (float )tmp___21;
#line 225
  tmp___22 = cos((1.0 * 3.14159265358979323846) / 18.0);
#line 225
  cos18[0] = (float )tmp___22;
#line 226
  tmp___23 = cos((11.0 * 3.14159265358979323846) / 18.0);
#line 226
  cos18[1] = (float )tmp___23;
#line 227
  tmp___24 = cos((13.0 * 3.14159265358979323846) / 18.0);
#line 227
  cos18[2] = (float )tmp___24;
#line 230
  i = 0;
  }
  {
#line 230
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 230
    if (! (i < 12)) {
#line 230
      goto while_break___6;
    }
    {
#line 232
    tmp___25 = sin((3.14159265358979323846 / 24.0) * (double )(2 * i + 1));
#line 232
    tmp___26 = cos((3.14159265358979323846 * (double )(2 * i + 7)) / 24.0);
#line 232
    win[2][i] = (float )((0.5 * tmp___25) / tmp___26);
#line 230
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 235
  i = 0;
  {
#line 235
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 235
    if (! (i < 16)) {
#line 235
      goto while_break___7;
    }
    {
#line 237
    tmp___27 = tan(((double )i * 3.14159265358979323846) / 12.0);
#line 237
    t = tmp___27;
#line 238
    tan1_1[i] = (float )(t / (1.0 + t));
#line 239
    tan2_1[i] = (float )(1.0 / (1.0 + t));
#line 240
    tan1_2[i] = (float )((1.41421356237309504880 * t) / (1.0 + t));
#line 241
    tan2_2[i] = (float )(1.41421356237309504880 / (1.0 + t));
#line 243
    j = 0;
    }
    {
#line 243
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 243
      if (! (j < 2)) {
#line 243
        goto while_break___8;
      }
      {
#line 245
      tmp___28 = pow(2.0, - 0.25 * ((double )j + 1.0));
#line 245
      base = tmp___28;
#line 246
      p1 = 1.0;
#line 246
      p2 = 1.0;
      }
#line 247
      if (i > 0) {
#line 249
        if (i & 1) {
          {
#line 249
          p1 = pow(base, ((double )i + 1.0) * 0.5);
          }
        } else {
          {
#line 250
          p2 = pow(base, (double )i * 0.5);
          }
        }
      }
#line 252
      pow1_1[j][i] = (float )p1;
#line 253
      pow2_1[j][i] = (float )p2;
#line 254
      pow1_2[j][i] = (float )(1.41421356237309504880 * p1);
#line 255
      pow2_2[j][i] = (float )(1.41421356237309504880 * p2);
#line 243
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 235
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 260
  j = 0;
  {
#line 260
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 260
    if (! (j < 4)) {
#line 260
      goto while_break___9;
    }
#line 262
    len[0] = 36;
#line 262
    len[1] = 36;
#line 262
    len[2] = 12;
#line 262
    len[3] = 36;
#line 263
    i = 0;
    {
#line 263
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 263
      if (! (i < len[j])) {
#line 263
        goto while_break___10;
      }
#line 263
      win1[j][i] = win[j][i];
#line 263
      i += 2;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 265
    i = 1;
    {
#line 265
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 265
      if (! (i < len[j])) {
#line 265
        goto while_break___11;
      }
#line 265
      win1[j][i] = - win[j][i];
#line 265
      i += 2;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 260
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 268
  j = 0;
  {
#line 268
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 268
    if (! (j < 9)) {
#line 268
      goto while_break___12;
    }
#line 270
    bi = & bandInfo[j];
#line 275
    tmp___29 = mapbuf0[j];
#line 275
    map[j][0] = tmp___29;
#line 275
    mp = tmp___29;
#line 276
    bdf = (int const   *)(bi->longDiff);
#line 277
    i = 0;
#line 277
    cb = 0;
    {
#line 277
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 277
      if (! (cb < 8)) {
#line 277
        goto while_break___13;
      }
#line 279
      tmp___31 = mp;
#line 279
      mp ++;
#line 279
      *tmp___31 = (int )(*bdf >> 1);
#line 280
      tmp___32 = mp;
#line 280
      mp ++;
#line 280
      *tmp___32 = i;
#line 281
      tmp___33 = mp;
#line 281
      mp ++;
#line 281
      *tmp___33 = 3;
#line 282
      tmp___34 = mp;
#line 282
      mp ++;
#line 282
      *tmp___34 = cb;
#line 277
      cb ++;
#line 277
      tmp___30 = bdf;
#line 277
      bdf ++;
#line 277
      i += (int )*tmp___30;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 284
    bdf = (int const   *)(bi->shortDiff + 3);
#line 285
    cb = 3;
    {
#line 285
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 285
      if (! (cb < 13)) {
#line 285
        goto while_break___14;
      }
#line 287
      tmp___35 = bdf;
#line 287
      bdf ++;
#line 287
      l___1 = (int )(*tmp___35 >> 1);
#line 288
      lwin = 0;
      {
#line 288
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 288
        if (! (lwin < 3)) {
#line 288
          goto while_break___15;
        }
#line 290
        tmp___36 = mp;
#line 290
        mp ++;
#line 290
        *tmp___36 = l___1;
#line 291
        tmp___37 = mp;
#line 291
        mp ++;
#line 291
        *tmp___37 = i + lwin;
#line 292
        tmp___38 = mp;
#line 292
        mp ++;
#line 292
        *tmp___38 = lwin;
#line 293
        tmp___39 = mp;
#line 293
        mp ++;
#line 293
        *tmp___39 = cb;
#line 288
        lwin ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 295
      i += 6 * l___1;
#line 285
      cb ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 297
    mapend[j][0] = mp;
#line 299
    tmp___40 = mapbuf1[j];
#line 299
    map[j][1] = tmp___40;
#line 299
    mp = tmp___40;
#line 300
    bdf = (int const   *)(bi->shortDiff + 0);
#line 301
    i = 0;
#line 301
    cb = 0;
    {
#line 301
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 301
      if (! (cb < 13)) {
#line 301
        goto while_break___16;
      }
#line 303
      tmp___41 = bdf;
#line 303
      bdf ++;
#line 303
      l___2 = (int )(*tmp___41 >> 1);
#line 304
      lwin = 0;
      {
#line 304
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 304
        if (! (lwin < 3)) {
#line 304
          goto while_break___17;
        }
#line 306
        tmp___42 = mp;
#line 306
        mp ++;
#line 306
        *tmp___42 = l___2;
#line 307
        tmp___43 = mp;
#line 307
        mp ++;
#line 307
        *tmp___43 = i + lwin;
#line 308
        tmp___44 = mp;
#line 308
        mp ++;
#line 308
        *tmp___44 = lwin;
#line 309
        tmp___45 = mp;
#line 309
        mp ++;
#line 309
        *tmp___45 = cb;
#line 304
        lwin ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 311
      i += 6 * l___2;
#line 301
      cb ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 313
    mapend[j][1] = mp;
#line 315
    tmp___46 = mapbuf2[j];
#line 315
    map[j][2] = tmp___46;
#line 315
    mp = tmp___46;
#line 316
    bdf = (int const   *)(bi->longDiff);
#line 317
    cb = 0;
    {
#line 317
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 317
      if (! (cb < 22)) {
#line 317
        goto while_break___18;
      }
#line 319
      tmp___47 = mp;
#line 319
      mp ++;
#line 319
      tmp___48 = bdf;
#line 319
      bdf ++;
#line 319
      *tmp___47 = (int )(*tmp___48 >> 1);
#line 320
      tmp___49 = mp;
#line 320
      mp ++;
#line 320
      *tmp___49 = cb;
#line 317
      cb ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 322
    mapend[j][2] = mp;
#line 268
    j ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 326
  i = 0;
  {
#line 326
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 326
    if (! (i < 5)) {
#line 326
      goto while_break___19;
    }
#line 327
    j = 0;
    {
#line 327
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 327
      if (! (j < 6)) {
#line 327
        goto while_break___20;
      }
#line 328
      k = 0;
      {
#line 328
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 328
        if (! (k < 6)) {
#line 328
          goto while_break___21;
        }
#line 330
        n = (k + j * 6) + i * 36;
#line 331
        i_slen2[n] = (unsigned int )(((i | (j << 3)) | (k << 6)) | (3 << 12));
#line 328
        k ++;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 327
      j ++;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 326
    i ++;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 333
  i = 0;
  {
#line 333
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 333
    if (! (i < 4)) {
#line 333
      goto while_break___22;
    }
#line 334
    j = 0;
    {
#line 334
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 334
      if (! (j < 4)) {
#line 334
        goto while_break___23;
      }
#line 335
      k = 0;
      {
#line 335
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 335
        if (! (k < 4)) {
#line 335
          goto while_break___24;
        }
#line 337
        n___0 = (k + j * 4) + i * 16;
#line 338
        i_slen2[n___0 + 180] = (unsigned int )(((i | (j << 3)) | (k << 6)) | (4 << 12));
#line 335
        k ++;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 334
      j ++;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 333
    i ++;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 340
  i = 0;
  {
#line 340
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 340
    if (! (i < 4)) {
#line 340
      goto while_break___25;
    }
#line 341
    j = 0;
    {
#line 341
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 341
      if (! (j < 3)) {
#line 341
        goto while_break___26;
      }
#line 343
      n___1 = j + i * 3;
#line 344
      i_slen2[n___1 + 244] = (unsigned int )((i | (j << 3)) | (5 << 12));
#line 345
      n_slen2[n___1 + 500] = (unsigned int )(((i | (j << 3)) | (2 << 12)) | (1 << 15));
#line 341
      j ++;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 340
    i ++;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 347
  i = 0;
  {
#line 347
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 347
    if (! (i < 5)) {
#line 347
      goto while_break___27;
    }
#line 348
    j = 0;
    {
#line 348
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 348
      if (! (j < 5)) {
#line 348
        goto while_break___28;
      }
#line 349
      k = 0;
      {
#line 349
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 349
        if (! (k < 4)) {
#line 349
          goto while_break___29;
        }
#line 350
        l___0 = 0;
        {
#line 350
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 350
          if (! (l___0 < 4)) {
#line 350
            goto while_break___30;
          }
#line 352
          n___2 = ((l___0 + k * 4) + j * 16) + i * 80;
#line 353
          n_slen2[n___2] = (unsigned int )(((i | (j << 3)) | (k << 6)) | (l___0 << 9));
#line 350
          l___0 ++;
        }
        while_break___30: /* CIL Label */ ;
        }
#line 349
        k ++;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 348
      j ++;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 347
    i ++;
  }
  while_break___27: /* CIL Label */ ;
  }
#line 355
  i = 0;
  {
#line 355
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 355
    if (! (i < 5)) {
#line 355
      goto while_break___31;
    }
#line 356
    j = 0;
    {
#line 356
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 356
      if (! (j < 5)) {
#line 356
        goto while_break___32;
      }
#line 357
      k = 0;
      {
#line 357
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 357
        if (! (k < 4)) {
#line 357
          goto while_break___33;
        }
#line 359
        n___3 = (k + j * 4) + i * 20;
#line 360
        n_slen2[n___3 + 400] = (unsigned int )(((i | (j << 3)) | (k << 6)) | (1 << 12));
#line 357
        k ++;
      }
      while_break___33: /* CIL Label */ ;
      }
#line 356
      j ++;
    }
    while_break___32: /* CIL Label */ ;
    }
#line 355
    i ++;
  }
  while_break___31: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 365 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
void init_layer3_stuff(mpg123_handle *fr , float (*gainpow2)(mpg123_handle *fr , int i ) ) 
{ 
  int i ;
  int j ;

  {
#line 369
  i = -256;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (i < 122)) {
#line 369
      goto while_break;
    }
    {
#line 369
    fr->gainpow2[i + 256] = (*gainpow2)(fr, i);
#line 369
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  j = 0;
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 371
    if (! (j < 9)) {
#line 371
      goto while_break___0;
    }
#line 373
    i = 0;
    {
#line 373
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 373
      if (! (i < 23)) {
#line 373
        goto while_break___1;
      }
#line 375
      fr->longLimit[j][i] = ((bandInfo[j].longIdx[i] - 1) + 8) / 18 + 1;
#line 376
      if (fr->longLimit[j][i] > fr->down_sample_sblimit) {
#line 377
        fr->longLimit[j][i] = fr->down_sample_sblimit;
      }
#line 373
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 379
    i = 0;
    {
#line 379
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 379
      if (! (i < 14)) {
#line 379
        goto while_break___2;
      }
#line 381
      fr->shortLimit[j][i] = (bandInfo[j].shortIdx[i] - 1) / 18 + 1;
#line 382
      if (fr->shortLimit[j][i] > fr->down_sample_sblimit) {
#line 383
        fr->shortLimit[j][i] = fr->down_sample_sblimit;
      }
#line 379
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 371
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 386
  return;
}
}
#line 394 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int III_get_side_info(mpg123_handle *fr , struct III_sideinfo *si , int stereo ,
                             int ms_stereo , long sfreq , int single ) 
{ 
  int ch ;
  int gr ;
  int powdiff ;
  int tmp ;
  int tabs[2][5] ;
  int const   *tab ;
  int tmp___0 ;
  int tmp___1 ;
  register struct gr_info_s *gr_info ;
  int i ;
  int r0c ;
  int r1c ;
  int i___0 ;
  int r0c___0 ;
  int r1c___0 ;
  void *__cil_tmp22 ;
  int __cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 397
  if (single == 3) {
#line 397
    tmp = 4;
  } else {
#line 397
    tmp = 0;
  }
  {
#line 397
  powdiff = tmp;
#line 399
  tabs[0][0] = 2;
#line 399
  tabs[0][1] = 9;
#line 399
  tabs[0][2] = 5;
#line 399
  tabs[0][3] = 3;
#line 399
  tabs[0][4] = 4;
#line 399
  tabs[1][0] = 1;
#line 399
  tabs[1][1] = 8;
#line 399
  tabs[1][2] = 1;
#line 399
  tabs[1][3] = 2;
#line 399
  tabs[1][4] = 9;
#line 400
  tab = (int const   *)(tabs[fr->lsf]);
#line 402
  si->main_data_begin = getbits(fr, (int )*(tab + 1));
  }
#line 404
  if (si->main_data_begin > fr->bitreservoir) {
#line 406
    if (! (fr->p.flags & 32L)) {
#line 406
      if (fr->p.verbose > 1) {
        {
#line 406
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: missing %d bytes in bit reservoir for frame %li\n",
                (int )(si->main_data_begin - fr->bitreservoir), (long )fr->num);
        }
      }
    }
#line 409
    fr->bitindex -= (int )*(tab + 1);
#line 409
    fr->wordpointer += fr->bitindex >> 3;
#line 409
    fr->bitindex &= 7;
#line 410
    if (fr->lsf == 0) {
#line 412
      *(fr->wordpointer + 0) = (unsigned char )(fr->bitreservoir >> 1);
#line 413
      *(fr->wordpointer + 1) = (unsigned char )((fr->bitreservoir & 1U) << 7);
    } else {
#line 415
      *(fr->wordpointer + 0) = (unsigned char )fr->bitreservoir;
    }
    {
#line 419
    memset((void *)(fr->wordpointer + 2), 0, (size_t )(fr->ssize - 2));
#line 422
    si->main_data_begin = getbits(fr, (int )*(tab + 1));
    }
  }
#line 427
  if (fr->error_protection) {
#line 427
    tmp___0 = 2;
  } else {
#line 427
    tmp___0 = 0;
  }
#line 427
  fr->bitreservoir = ((fr->bitreservoir + (unsigned int )fr->framesize) - (unsigned int )fr->ssize) - (unsigned int )tmp___0;
#line 429
  if (fr->lsf == 0) {
#line 429
    tmp___1 = 511;
  } else {
#line 429
    tmp___1 = 255;
  }
#line 429
  if (fr->bitreservoir > (unsigned int )tmp___1) {
#line 430
    if (fr->lsf == 0) {
#line 430
      fr->bitreservoir = 511U;
    } else {
#line 430
      fr->bitreservoir = 255U;
    }
  }
#line 434
  if (stereo == 1) {
#line 435
    fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 435
    fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 435
    fr->ultmp <<= *(tab + 2);
#line 435
    fr->ultmp >>= 8;
#line 435
    fr->bitindex += (int )*(tab + 2);
#line 435
    fr->wordpointer += fr->bitindex >> 3;
#line 435
    fr->bitindex &= 7;
#line 435
    si->private_bits = (unsigned int )fr->ultmp;
  } else {
#line 437
    fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 437
    fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 437
    fr->ultmp <<= *(tab + 3);
#line 437
    fr->ultmp >>= 8;
#line 437
    fr->bitindex += (int )*(tab + 3);
#line 437
    fr->wordpointer += fr->bitindex >> 3;
#line 437
    fr->bitindex &= 7;
#line 437
    si->private_bits = (unsigned int )fr->ultmp;
  }
#line 439
  if (! fr->lsf) {
#line 439
    ch = 0;
    {
#line 439
    while (1) {
      while_continue: /* CIL Label */ ;
#line 439
      if (! (ch < stereo)) {
#line 439
        goto while_break;
      }
#line 441
      si->ch[ch].gr[0].scfsi = -1;
#line 442
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 442
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 442
      fr->ultmp <<= 4;
#line 442
      fr->ultmp >>= 8;
#line 442
      fr->bitindex += 4;
#line 442
      fr->wordpointer += fr->bitindex >> 3;
#line 442
      fr->bitindex &= 7;
#line 442
      si->ch[ch].gr[1].scfsi = (int )fr->ultmp;
#line 439
      ch ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 445
  gr = 0;
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 445
    if (! (gr < (int )*(tab + 0))) {
#line 445
      goto while_break___0;
    }
#line 446
    ch = 0;
    {
#line 446
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 446
      if (! (ch < stereo)) {
#line 446
        goto while_break___1;
      }
      {
#line 448
      gr_info = & si->ch[ch].gr[gr];
#line 450
      gr_info->part2_3_length = getbits(fr, 12);
#line 451
      gr_info->big_values = getbits(fr, 9);
      }
#line 452
      if (gr_info->big_values > 288U) {
#line 454
        if (! (fr->p.flags & 32L)) {
          {
#line 454
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c:%i] error: big_values too large!\n",
                  454);
          }
        }
#line 455
        gr_info->big_values = 288U;
      }
#line 457
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 457
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 457
      fr->ultmp <<= 8;
#line 457
      fr->ultmp >>= 8;
#line 457
      fr->bitindex += 8;
#line 457
      fr->wordpointer += fr->bitindex >> 3;
#line 457
      fr->bitindex &= 7;
#line 457
      gr_info->pow2gain = ((fr->gainpow2 + 256) - fr->ultmp) + powdiff;
#line 458
      if (ms_stereo) {
#line 458
        gr_info->pow2gain += 2;
      }
      {
#line 460
      gr_info->scalefac_compress = getbits(fr, (int )*(tab + 4));
#line 462
      fr->uctmp = (unsigned char )((int )*(fr->wordpointer) << fr->bitindex);
#line 462
      (fr->bitindex) ++;
#line 462
      fr->wordpointer += fr->bitindex >> 3;
#line 462
      fr->bitindex &= 7;
      }
#line 462
      if ((int )fr->uctmp >> 7) {
#line 465
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 465
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 465
        fr->ultmp <<= 2;
#line 465
        fr->ultmp >>= 8;
#line 465
        fr->bitindex += 2;
#line 465
        fr->wordpointer += fr->bitindex >> 3;
#line 465
        fr->bitindex &= 7;
#line 465
        gr_info->block_type = (unsigned int )fr->ultmp;
#line 466
        fr->uctmp = (unsigned char )((int )*(fr->wordpointer) << fr->bitindex);
#line 466
        (fr->bitindex) ++;
#line 466
        fr->wordpointer += fr->bitindex >> 3;
#line 466
        fr->bitindex &= 7;
#line 466
        gr_info->mixed_block_flag = (unsigned int )((int )fr->uctmp >> 7);
#line 467
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 467
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 467
        fr->ultmp <<= 5;
#line 467
        fr->ultmp >>= 8;
#line 467
        fr->bitindex += 5;
#line 467
        fr->wordpointer += fr->bitindex >> 3;
#line 467
        fr->bitindex &= 7;
#line 467
        gr_info->table_select[0] = (unsigned int )fr->ultmp;
#line 468
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 468
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 468
        fr->ultmp <<= 5;
#line 468
        fr->ultmp >>= 8;
#line 468
        fr->bitindex += 5;
#line 468
        fr->wordpointer += fr->bitindex >> 3;
#line 468
        fr->bitindex &= 7;
#line 468
        gr_info->table_select[1] = (unsigned int )fr->ultmp;
#line 473
        gr_info->table_select[2] = 0U;
#line 474
        i = 0;
        {
#line 474
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 474
          if (! (i < 3)) {
#line 474
            goto while_break___2;
          }
#line 475
          fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 475
          fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 475
          fr->ultmp <<= 3;
#line 475
          fr->ultmp >>= 8;
#line 475
          fr->bitindex += 3;
#line 475
          fr->wordpointer += fr->bitindex >> 3;
#line 475
          fr->bitindex &= 7;
#line 475
          gr_info->full_gain[i] = gr_info->pow2gain + (fr->ultmp << 3);
#line 474
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 477
        if (gr_info->block_type == 0U) {
#line 479
          if (! (fr->p.flags & 32L)) {
            {
#line 479
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c:%i] error: Blocktype == 0 and window-switching == 1 not allowed.\n",
                    479);
            }
          }
#line 480
          return (1);
        }
#line 484
        if (! fr->lsf) {
#line 484
          goto _L___0;
        } else
#line 484
        if (gr_info->block_type == 2U) {
          _L___0: /* CIL Label */ 
#line 484
          if (! fr->mpeg25) {
#line 486
            gr_info->region1start = (unsigned int )(36 >> 1);
#line 487
            gr_info->region2start = (unsigned int )(576 >> 1);
          } else {
#line 484
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 491
        if (fr->mpeg25) {
#line 494
          if (gr_info->block_type == 2U) {
#line 494
            if (! gr_info->mixed_block_flag) {
#line 494
              r0c = 5;
            } else {
#line 495
              r0c = 7;
            }
          } else {
#line 495
            r0c = 7;
          }
#line 497
          r1c = 20 - r0c;
#line 498
          gr_info->region1start = (unsigned int )(bandInfo[sfreq].longIdx[r0c + 1] >> 1);
#line 499
          gr_info->region2start = (unsigned int )(bandInfo[sfreq].longIdx[((r0c + 1) + r1c) + 1] >> 1);
        } else {
#line 503
          gr_info->region1start = (unsigned int )(54 >> 1);
#line 504
          gr_info->region2start = (unsigned int )(576 >> 1);
        }
      } else {
#line 511
        i___0 = 0;
        {
#line 511
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 511
          if (! (i___0 < 3)) {
#line 511
            goto while_break___3;
          }
#line 512
          fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 512
          fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 512
          fr->ultmp <<= 5;
#line 512
          fr->ultmp >>= 8;
#line 512
          fr->bitindex += 5;
#line 512
          fr->wordpointer += fr->bitindex >> 3;
#line 512
          fr->bitindex &= 7;
#line 512
          gr_info->table_select[i___0] = (unsigned int )fr->ultmp;
#line 511
          i___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 514
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 514
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 514
        fr->ultmp <<= 4;
#line 514
        fr->ultmp >>= 8;
#line 514
        fr->bitindex += 4;
#line 514
        fr->wordpointer += fr->bitindex >> 3;
#line 514
        fr->bitindex &= 7;
#line 514
        r0c___0 = (int )fr->ultmp;
#line 515
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 515
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 515
        fr->ultmp <<= 3;
#line 515
        fr->ultmp >>= 8;
#line 515
        fr->bitindex += 3;
#line 515
        fr->wordpointer += fr->bitindex >> 3;
#line 515
        fr->bitindex &= 7;
#line 515
        r1c___0 = (int )fr->ultmp;
#line 516
        gr_info->region1start = (unsigned int )(bandInfo[sfreq].longIdx[r0c___0 + 1] >> 1);
#line 517
        gr_info->region2start = (unsigned int )(bandInfo[sfreq].longIdx[((r0c___0 + 1) + r1c___0) + 1] >> 1);
#line 519
        if ((r0c___0 + r1c___0) + 2 > 22) {
#line 519
          gr_info->region2start = (unsigned int )(576 >> 1);
        } else {
#line 520
          gr_info->region2start = (unsigned int )(bandInfo[sfreq].longIdx[((r0c___0 + 1) + r1c___0) + 1] >> 1);
        }
#line 522
        gr_info->block_type = 0U;
#line 523
        gr_info->mixed_block_flag = 0U;
      }
#line 525
      if (! fr->lsf) {
#line 525
        fr->uctmp = (unsigned char )((int )*(fr->wordpointer) << fr->bitindex);
#line 525
        (fr->bitindex) ++;
#line 525
        fr->wordpointer += fr->bitindex >> 3;
#line 525
        fr->bitindex &= 7;
#line 525
        gr_info->preflag = (unsigned int )((int )fr->uctmp >> 7);
      }
#line 527
      fr->uctmp = (unsigned char )((int )*(fr->wordpointer) << fr->bitindex);
#line 527
      (fr->bitindex) ++;
#line 527
      fr->wordpointer += fr->bitindex >> 3;
#line 527
      fr->bitindex &= 7;
#line 527
      gr_info->scalefac_scale = (unsigned int )((int )fr->uctmp >> 7);
#line 528
      fr->uctmp = (unsigned char )((int )*(fr->wordpointer) << fr->bitindex);
#line 528
      (fr->bitindex) ++;
#line 528
      fr->wordpointer += fr->bitindex >> 3;
#line 528
      fr->bitindex &= 7;
#line 528
      gr_info->count1table_select = (unsigned int )((int )fr->uctmp >> 7);
#line 446
      ch ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 445
    gr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 530
  return (0);
}
}
#line 535 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int III_get_scale_factors_1(mpg123_handle *fr , int *scf , struct gr_info_s *gr_info ,
                                   int ch , int gr ) 
{ 
  unsigned char slen[2][16] ;
  int numbits ;
  int num0 ;
  int num1 ;
  int i ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int i___0 ;
  int scfsi ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  void *__cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;

  {
#line 537
  slen[0][0] = (unsigned char)0;
#line 537
  slen[0][1] = (unsigned char)0;
#line 537
  slen[0][2] = (unsigned char)0;
#line 537
  slen[0][3] = (unsigned char)0;
#line 537
  slen[0][4] = (unsigned char)3;
#line 537
  slen[0][5] = (unsigned char)1;
#line 537
  slen[0][6] = (unsigned char)1;
#line 537
  slen[0][7] = (unsigned char)1;
#line 537
  slen[0][8] = (unsigned char)2;
#line 537
  slen[0][9] = (unsigned char)2;
#line 537
  slen[0][10] = (unsigned char)2;
#line 537
  slen[0][11] = (unsigned char)3;
#line 537
  slen[0][12] = (unsigned char)3;
#line 537
  slen[0][13] = (unsigned char)3;
#line 537
  slen[0][14] = (unsigned char)4;
#line 537
  slen[0][15] = (unsigned char)4;
#line 537
  slen[1][0] = (unsigned char)0;
#line 537
  slen[1][1] = (unsigned char)1;
#line 537
  slen[1][2] = (unsigned char)2;
#line 537
  slen[1][3] = (unsigned char)3;
#line 537
  slen[1][4] = (unsigned char)0;
#line 537
  slen[1][5] = (unsigned char)1;
#line 537
  slen[1][6] = (unsigned char)2;
#line 537
  slen[1][7] = (unsigned char)3;
#line 537
  slen[1][8] = (unsigned char)1;
#line 537
  slen[1][9] = (unsigned char)2;
#line 537
  slen[1][10] = (unsigned char)3;
#line 537
  slen[1][11] = (unsigned char)1;
#line 537
  slen[1][12] = (unsigned char)2;
#line 537
  slen[1][13] = (unsigned char)3;
#line 537
  slen[1][14] = (unsigned char)2;
#line 537
  slen[1][15] = (unsigned char)3;
#line 543
  num0 = (int )slen[0][gr_info->scalefac_compress];
#line 544
  num1 = (int )slen[1][gr_info->scalefac_compress];
#line 546
  if (gr_info->block_type == 2U) {
#line 548
    i = 18;
#line 549
    numbits = (num0 + num1) * 18;
#line 551
    if (gr_info->mixed_block_flag) {
#line 553
      i = 8;
      {
#line 553
      while (1) {
        while_continue: /* CIL Label */ ;
#line 553
        if (! i) {
#line 553
          goto while_break;
        }
#line 554
        tmp = scf;
#line 554
        scf ++;
#line 554
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 554
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 554
        fr->ultmp <<= num0;
#line 554
        fr->ultmp >>= 8;
#line 554
        fr->bitindex += num0;
#line 554
        fr->wordpointer += fr->bitindex >> 3;
#line 554
        fr->bitindex &= 7;
#line 554
        *tmp = (int )fr->ultmp;
#line 553
        i --;
      }
      while_break: /* CIL Label */ ;
      }
#line 556
      i = 9;
#line 557
      numbits -= num0;
    }
    {
#line 560
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 560
      if (! i) {
#line 560
        goto while_break___0;
      }
#line 560
      tmp___0 = scf;
#line 560
      scf ++;
#line 560
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 560
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 560
      fr->ultmp <<= num0;
#line 560
      fr->ultmp >>= 8;
#line 560
      fr->bitindex += num0;
#line 560
      fr->wordpointer += fr->bitindex >> 3;
#line 560
      fr->bitindex &= 7;
#line 560
      *tmp___0 = (int )fr->ultmp;
#line 560
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 562
    i = 18;
    {
#line 562
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 562
      if (! i) {
#line 562
        goto while_break___1;
      }
#line 562
      tmp___1 = scf;
#line 562
      scf ++;
#line 562
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 562
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 562
      fr->ultmp <<= num1;
#line 562
      fr->ultmp >>= 8;
#line 562
      fr->bitindex += num1;
#line 562
      fr->wordpointer += fr->bitindex >> 3;
#line 562
      fr->bitindex &= 7;
#line 562
      *tmp___1 = (int )fr->ultmp;
#line 562
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 564
    tmp___2 = scf;
#line 564
    scf ++;
#line 564
    *tmp___2 = 0;
#line 564
    tmp___3 = scf;
#line 564
    scf ++;
#line 564
    *tmp___3 = 0;
#line 564
    tmp___4 = scf;
#line 564
    scf ++;
#line 564
    *tmp___4 = 0;
  } else {
#line 569
    scfsi = gr_info->scfsi;
#line 571
    if (scfsi < 0) {
#line 573
      i___0 = 11;
      {
#line 573
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 573
        if (! i___0) {
#line 573
          goto while_break___2;
        }
#line 573
        tmp___5 = scf;
#line 573
        scf ++;
#line 573
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 573
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 573
        fr->ultmp <<= num0;
#line 573
        fr->ultmp >>= 8;
#line 573
        fr->bitindex += num0;
#line 573
        fr->wordpointer += fr->bitindex >> 3;
#line 573
        fr->bitindex &= 7;
#line 573
        *tmp___5 = (int )fr->ultmp;
#line 573
        i___0 --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 575
      i___0 = 10;
      {
#line 575
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 575
        if (! i___0) {
#line 575
          goto while_break___3;
        }
#line 575
        tmp___6 = scf;
#line 575
        scf ++;
#line 575
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 575
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 575
        fr->ultmp <<= num1;
#line 575
        fr->ultmp >>= 8;
#line 575
        fr->bitindex += num1;
#line 575
        fr->wordpointer += fr->bitindex >> 3;
#line 575
        fr->bitindex &= 7;
#line 575
        *tmp___6 = (int )fr->ultmp;
#line 575
        i___0 --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 577
      numbits = (num0 + num1) * 10 + num0;
#line 578
      tmp___7 = scf;
#line 578
      scf ++;
#line 578
      *tmp___7 = 0;
    } else {
#line 582
      numbits = 0;
#line 583
      if (! (scfsi & 8)) {
#line 585
        i___0 = 0;
        {
#line 585
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 585
          if (! (i___0 < 6)) {
#line 585
            goto while_break___4;
          }
#line 585
          tmp___8 = scf;
#line 585
          scf ++;
#line 585
          fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 585
          fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 585
          fr->ultmp <<= num0;
#line 585
          fr->ultmp >>= 8;
#line 585
          fr->bitindex += num0;
#line 585
          fr->wordpointer += fr->bitindex >> 3;
#line 585
          fr->bitindex &= 7;
#line 585
          *tmp___8 = (int )fr->ultmp;
#line 585
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 587
        numbits += num0 * 6;
      } else {
#line 589
        scf += 6;
      }
#line 591
      if (! (scfsi & 4)) {
#line 593
        i___0 = 0;
        {
#line 593
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 593
          if (! (i___0 < 5)) {
#line 593
            goto while_break___5;
          }
#line 593
          tmp___9 = scf;
#line 593
          scf ++;
#line 593
          fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 593
          fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 593
          fr->ultmp <<= num0;
#line 593
          fr->ultmp >>= 8;
#line 593
          fr->bitindex += num0;
#line 593
          fr->wordpointer += fr->bitindex >> 3;
#line 593
          fr->bitindex &= 7;
#line 593
          *tmp___9 = (int )fr->ultmp;
#line 593
          i___0 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 595
        numbits += num0 * 5;
      } else {
#line 597
        scf += 5;
      }
#line 599
      if (! (scfsi & 2)) {
#line 601
        i___0 = 0;
        {
#line 601
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 601
          if (! (i___0 < 5)) {
#line 601
            goto while_break___6;
          }
#line 601
          tmp___10 = scf;
#line 601
          scf ++;
#line 601
          fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 601
          fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 601
          fr->ultmp <<= num1;
#line 601
          fr->ultmp >>= 8;
#line 601
          fr->bitindex += num1;
#line 601
          fr->wordpointer += fr->bitindex >> 3;
#line 601
          fr->bitindex &= 7;
#line 601
          *tmp___10 = (int )fr->ultmp;
#line 601
          i___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 603
        numbits += num1 * 5;
      } else {
#line 605
        scf += 5;
      }
#line 607
      if (! (scfsi & 1)) {
#line 609
        i___0 = 0;
        {
#line 609
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 609
          if (! (i___0 < 5)) {
#line 609
            goto while_break___7;
          }
#line 609
          tmp___11 = scf;
#line 609
          scf ++;
#line 609
          fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 609
          fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 609
          fr->ultmp <<= num1;
#line 609
          fr->ultmp >>= 8;
#line 609
          fr->bitindex += num1;
#line 609
          fr->wordpointer += fr->bitindex >> 3;
#line 609
          fr->bitindex &= 7;
#line 609
          *tmp___11 = (int )fr->ultmp;
#line 609
          i___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 611
        numbits += num1 * 5;
      } else {
#line 613
        scf += 5;
      }
#line 615
      tmp___12 = scf;
#line 615
      scf ++;
#line 615
      *tmp___12 = 0;
    }
  }
#line 618
  return (numbits);
}
}
#line 622 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int III_get_scale_factors_2(mpg123_handle *fr , int *scf , struct gr_info_s *gr_info ,
                                   int i_stereo ) 
{ 
  unsigned char const   *pnt ;
  int i ;
  int j ;
  int n ;
  int numbits ;
  unsigned int slen ;
  unsigned char stab[3][6][4] ;
  int num ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;

  {
#line 625
  n = 0;
#line 625
  numbits = 0;
#line 628
  stab[0][0][0] = (unsigned char)6;
#line 628
  stab[0][0][1] = (unsigned char)5;
#line 628
  stab[0][0][2] = (unsigned char)5;
#line 628
  stab[0][0][3] = (unsigned char)5;
#line 628
  stab[0][1][0] = (unsigned char)6;
#line 628
  stab[0][1][1] = (unsigned char)5;
#line 628
  stab[0][1][2] = (unsigned char)7;
#line 628
  stab[0][1][3] = (unsigned char)3;
#line 628
  stab[0][2][0] = (unsigned char)11;
#line 628
  stab[0][2][1] = (unsigned char)10;
#line 628
  stab[0][2][2] = (unsigned char)0;
#line 628
  stab[0][2][3] = (unsigned char)0;
#line 628
  stab[0][3][0] = (unsigned char)7;
#line 628
  stab[0][3][1] = (unsigned char)7;
#line 628
  stab[0][3][2] = (unsigned char)7;
#line 628
  stab[0][3][3] = (unsigned char)0;
#line 628
  stab[0][4][0] = (unsigned char)6;
#line 628
  stab[0][4][1] = (unsigned char)6;
#line 628
  stab[0][4][2] = (unsigned char)6;
#line 628
  stab[0][4][3] = (unsigned char)3;
#line 628
  stab[0][5][0] = (unsigned char)8;
#line 628
  stab[0][5][1] = (unsigned char)8;
#line 628
  stab[0][5][2] = (unsigned char)5;
#line 628
  stab[0][5][3] = (unsigned char)0;
#line 628
  stab[1][0][0] = (unsigned char)9;
#line 628
  stab[1][0][1] = (unsigned char)9;
#line 628
  stab[1][0][2] = (unsigned char)9;
#line 628
  stab[1][0][3] = (unsigned char)9;
#line 628
  stab[1][1][0] = (unsigned char)9;
#line 628
  stab[1][1][1] = (unsigned char)9;
#line 628
  stab[1][1][2] = (unsigned char)12;
#line 628
  stab[1][1][3] = (unsigned char)6;
#line 628
  stab[1][2][0] = (unsigned char)18;
#line 628
  stab[1][2][1] = (unsigned char)18;
#line 628
  stab[1][2][2] = (unsigned char)0;
#line 628
  stab[1][2][3] = (unsigned char)0;
#line 628
  stab[1][3][0] = (unsigned char)12;
#line 628
  stab[1][3][1] = (unsigned char)12;
#line 628
  stab[1][3][2] = (unsigned char)12;
#line 628
  stab[1][3][3] = (unsigned char)0;
#line 628
  stab[1][4][0] = (unsigned char)12;
#line 628
  stab[1][4][1] = (unsigned char)9;
#line 628
  stab[1][4][2] = (unsigned char)9;
#line 628
  stab[1][4][3] = (unsigned char)6;
#line 628
  stab[1][5][0] = (unsigned char)15;
#line 628
  stab[1][5][1] = (unsigned char)12;
#line 628
  stab[1][5][2] = (unsigned char)9;
#line 628
  stab[1][5][3] = (unsigned char)0;
#line 628
  stab[2][0][0] = (unsigned char)6;
#line 628
  stab[2][0][1] = (unsigned char)9;
#line 628
  stab[2][0][2] = (unsigned char)9;
#line 628
  stab[2][0][3] = (unsigned char)9;
#line 628
  stab[2][1][0] = (unsigned char)6;
#line 628
  stab[2][1][1] = (unsigned char)9;
#line 628
  stab[2][1][2] = (unsigned char)12;
#line 628
  stab[2][1][3] = (unsigned char)6;
#line 628
  stab[2][2][0] = (unsigned char)15;
#line 628
  stab[2][2][1] = (unsigned char)18;
#line 628
  stab[2][2][2] = (unsigned char)0;
#line 628
  stab[2][2][3] = (unsigned char)0;
#line 628
  stab[2][3][0] = (unsigned char)6;
#line 628
  stab[2][3][1] = (unsigned char)15;
#line 628
  stab[2][3][2] = (unsigned char)12;
#line 628
  stab[2][3][3] = (unsigned char)0;
#line 628
  stab[2][4][0] = (unsigned char)6;
#line 628
  stab[2][4][1] = (unsigned char)12;
#line 628
  stab[2][4][2] = (unsigned char)9;
#line 628
  stab[2][4][3] = (unsigned char)6;
#line 628
  stab[2][5][0] = (unsigned char)6;
#line 628
  stab[2][5][1] = (unsigned char)18;
#line 628
  stab[2][5][2] = (unsigned char)9;
#line 628
  stab[2][5][3] = (unsigned char)0;
#line 644
  if (i_stereo) {
#line 645
    slen = i_slen2[gr_info->scalefac_compress >> 1];
  } else {
#line 647
    slen = n_slen2[gr_info->scalefac_compress];
  }
#line 649
  gr_info->preflag = (slen >> 15) & 1U;
#line 651
  n = 0;
#line 652
  if (gr_info->block_type == 2U) {
#line 654
    n ++;
#line 655
    if (gr_info->mixed_block_flag) {
#line 655
      n ++;
    }
  }
#line 658
  pnt = (unsigned char const   *)(stab[n][(slen >> 12) & 7U]);
#line 660
  i = 0;
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! (i < 4)) {
#line 660
      goto while_break;
    }
#line 662
    num = (int )(slen & 7U);
#line 663
    slen >>= 3;
#line 664
    if (num) {
#line 666
      j = 0;
      {
#line 666
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 666
        if (! (j < (int )*(pnt + i))) {
#line 666
          goto while_break___0;
        }
#line 666
        tmp = scf;
#line 666
        scf ++;
#line 666
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 666
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 666
        fr->ultmp <<= num;
#line 666
        fr->ultmp >>= 8;
#line 666
        fr->bitindex += num;
#line 666
        fr->wordpointer += fr->bitindex >> 3;
#line 666
        fr->bitindex &= 7;
#line 666
        *tmp = (int )fr->ultmp;
#line 666
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 668
      numbits += (int )((int const   )*(pnt + i) * (int const   )num);
    } else {
#line 671
      j = 0;
      {
#line 671
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 671
        if (! (j < (int )*(pnt + i))) {
#line 671
          goto while_break___1;
        }
#line 671
        tmp___0 = scf;
#line 671
        scf ++;
#line 671
        *tmp___0 = 0;
#line 671
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 660
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 674
  n = (n << 1) + 1;
#line 675
  i = 0;
  {
#line 675
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 675
    if (! (i < n)) {
#line 675
      goto while_break___2;
    }
#line 675
    tmp___1 = scf;
#line 675
    scf ++;
#line 675
    *tmp___1 = 0;
#line 675
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 677
  return (numbits);
}
}
#line 680 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int const   pretab1[22]  = 
#line 680
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )2,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )2,      (int const   )0};
#line 681 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int const   pretab2[22]  = 
#line 681
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0};
#line 696 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static int III_dequantize_sample(mpg123_handle *fr , float (*xr)[18] , int *scf ,
                                 struct gr_info_s *gr_info , int sfreq , int part2bits ) 
{ 
  int shift ;
  float *xrpnt ;
  int l___0[3] ;
  int l3 ;
  int part2remain ;
  int *me ;
  int num ;
  long mask ;
  unsigned int tmp ;
  int bv ;
  int region1 ;
  int region2 ;
  int i ;
  int max[4] ;
  int step___30 ;
  int lwin ;
  int cb ;
  register float v ;
  register int *m ;
  register int mc ;
  int lp ;
  struct newhuff *h ;
  register int x ;
  register int y ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  register short *val ;
  unsigned char *tmp___6 ;
  short *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  struct newhuff *h___0 ;
  register short *val___0 ;
  register short a ;
  unsigned char *tmp___10 ;
  short *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int rmax ;
  int tmp___21 ;
  int tmp___22 ;
  int const   *pretab ;
  int const   *tmp___23 ;
  int i___0 ;
  int max___0 ;
  int cb___0 ;
  int *m___0 ;
  register float v___0 ;
  int mc___0 ;
  int lp___0 ;
  struct newhuff *h___1 ;
  int x___0 ;
  int y___0 ;
  int *tmp___24 ;
  int *tmp___25 ;
  int *tmp___26 ;
  int const   *tmp___27 ;
  register short *val___1 ;
  unsigned char *tmp___28 ;
  short *tmp___29 ;
  unsigned char *tmp___30 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  unsigned char *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  struct newhuff *h___2 ;
  register short *val___2 ;
  register short a___0 ;
  unsigned char *tmp___42 ;
  short *tmp___43 ;
  int *tmp___44 ;
  int *tmp___45 ;
  int *tmp___46 ;
  int const   *tmp___47 ;
  float *tmp___48 ;
  float *tmp___49 ;
  float *tmp___50 ;
  float *tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  void *__cil_tmp105 ;
  void *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;

  {
  {
#line 698
  shift = (int )(1U + gr_info->scalefac_scale);
#line 699
  xrpnt = (float *)xr;
#line 701
  part2remain = (int )(gr_info->part2_3_length - (unsigned int )part2bits);
#line 708
  num = - fr->bitindex & 7;
#line 711
  tmp = getbits(fr, num);
#line 711
  mask = (long )((unsigned long )tmp << (sizeof(long ) - 1UL) * 8UL);
#line 712
  mask <<= 8 - num;
#line 713
  part2remain -= num;
#line 716
  bv = (int )gr_info->big_values;
#line 717
  region1 = (int )gr_info->region1start;
#line 718
  region2 = (int )gr_info->region2start;
  }
#line 719
  if (region1 > region2) {
#line 726
    if (! (fr->p.flags & 32L)) {
      {
#line 726
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c:%i] error: You got some really nasty file there... region1>region2!\n",
              726);
      }
    }
#line 727
    return (1);
  }
#line 729
  l3 = ((576 >> 1) - bv) >> 1;
#line 732
  if (bv <= region1) {
#line 734
    l___0[0] = bv;
#line 735
    l___0[1] = 0;
#line 736
    l___0[2] = 0;
  } else {
#line 740
    l___0[0] = region1;
#line 741
    if (bv <= region2) {
#line 743
      l___0[1] = bv - l___0[0];
#line 744
      l___0[2] = 0;
    } else {
#line 748
      l___0[1] = region2 - l___0[0];
#line 749
      l___0[2] = bv - region2;
    }
  }
#line 754
  if (gr_info->block_type == 2U) {
#line 758
    step___30 = 0;
#line 758
    lwin = 3;
#line 758
    cb = 0;
#line 759
    v = (float )0.0;
#line 762
    if (gr_info->mixed_block_flag) {
#line 764
      max[3] = -1;
#line 765
      max[2] = 2;
#line 765
      max[1] = max[2];
#line 765
      max[0] = max[1];
#line 766
      m = map[sfreq][0];
#line 767
      me = mapend[sfreq][0];
    } else {
#line 771
      max[3] = -1;
#line 771
      max[2] = max[3];
#line 771
      max[1] = max[2];
#line 771
      max[0] = max[1];
#line 773
      m = map[sfreq][1];
#line 774
      me = mapend[sfreq][1];
    }
#line 777
    mc = 0;
#line 778
    i = 0;
    {
#line 778
    while (1) {
      while_continue: /* CIL Label */ ;
#line 778
      if (! (i < 2)) {
#line 778
        goto while_break;
      }
#line 780
      lp = l___0[i];
#line 781
      h = ht + gr_info->table_select[i];
      {
#line 782
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 782
        if (! lp) {
#line 782
          goto while_break___0;
        }
#line 785
        if (! mc) {
#line 787
          tmp___0 = m;
#line 787
          m ++;
#line 787
          mc = *tmp___0;
#line 788
          tmp___1 = m;
#line 788
          m ++;
#line 788
          xrpnt = (float *)xr + *tmp___1;
#line 789
          tmp___2 = m;
#line 789
          m ++;
#line 789
          lwin = *tmp___2;
#line 790
          tmp___3 = m;
#line 790
          m ++;
#line 790
          cb = *tmp___3;
#line 791
          if (lwin == 3) {
#line 796
            tmp___4 = scf;
#line 796
            scf ++;
#line 796
            v = *(gr_info->pow2gain + (*tmp___4 << shift));
#line 797
            step___30 = 1;
          } else {
#line 804
            tmp___5 = scf;
#line 804
            scf ++;
#line 804
            v = *(gr_info->full_gain[lwin] + (*tmp___5 << shift));
#line 805
            step___30 = 3;
          }
        }
#line 809
        val = h->table;
        {
#line 810
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 810
          if (! ((unsigned long )num < (sizeof(long ) - 1UL) * 8UL)) {
#line 810
            goto while_break___1;
          }
#line 810
          tmp___6 = fr->wordpointer;
#line 810
          (fr->wordpointer) ++;
#line 810
          mask = (long )((unsigned long )mask | ((unsigned long )*tmp___6 << ((sizeof(long ) - 1UL) * 8UL - (unsigned long )num)));
#line 810
          num += 8;
#line 810
          part2remain -= 8;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 811
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 811
          tmp___7 = val;
#line 811
          val ++;
#line 811
          y = (int )*tmp___7;
#line 811
          if (! (y < 0)) {
#line 811
            goto while_break___2;
          }
#line 813
          if (mask < 0L) {
#line 813
            val -= y;
          }
#line 815
          num --;
#line 816
          mask <<= 1;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 818
        x = y >> 4;
#line 819
        y &= 15;
#line 821
        if (x == 15) {
#line 821
          if (h->linbits) {
#line 823
            max[lwin] = cb;
            {
#line 824
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 824
              if (! ((unsigned long )num < (sizeof(long ) - 1UL) * 8UL)) {
#line 824
                goto while_break___3;
              }
#line 824
              tmp___8 = fr->wordpointer;
#line 824
              (fr->wordpointer) ++;
#line 824
              mask = (long )((unsigned long )mask | ((unsigned long )*tmp___8 << ((sizeof(long ) - 1UL) * 8UL - (unsigned long )num)));
#line 824
              num += 8;
#line 824
              part2remain -= 8;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 825
            x = (int )((unsigned long )x + ((unsigned long )mask >> (((sizeof(long ) - 1UL) * 8UL + 8UL) - (unsigned long )h->linbits)));
#line 826
            num = (int )((unsigned int )num - (h->linbits + 1U));
#line 827
            mask <<= h->linbits;
#line 828
            if (mask < 0L) {
#line 828
              *xrpnt = - ispow[x] * v;
            } else {
#line 829
              *xrpnt = ispow[x] * v;
            }
#line 831
            mask <<= 1;
          } else {
#line 821
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 833
        if (x) {
#line 835
          max[lwin] = cb;
#line 836
          if (mask < 0L) {
#line 836
            *xrpnt = - ispow[x] * v;
          } else {
#line 837
            *xrpnt = ispow[x] * v;
          }
#line 839
          num --;
#line 840
          mask <<= 1;
        } else {
#line 842
          *xrpnt = (float )0.0;
        }
#line 844
        xrpnt += step___30;
#line 845
        if (y == 15) {
#line 845
          if (h->linbits) {
#line 847
            max[lwin] = cb;
            {
#line 848
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 848
              if (! ((unsigned long )num < (sizeof(long ) - 1UL) * 8UL)) {
#line 848
                goto while_break___4;
              }
#line 848
              tmp___9 = fr->wordpointer;
#line 848
              (fr->wordpointer) ++;
#line 848
              mask = (long )((unsigned long )mask | ((unsigned long )*tmp___9 << ((sizeof(long ) - 1UL) * 8UL - (unsigned long )num)));
#line 848
              num += 8;
#line 848
              part2remain -= 8;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 849
            y = (int )((unsigned long )y + ((unsigned long )mask >> (((sizeof(long ) - 1UL) * 8UL + 8UL) - (unsigned long )h->linbits)));
#line 850
            num = (int )((unsigned int )num - (h->linbits + 1U));
#line 851
            mask <<= h->linbits;
#line 852
            if (mask < 0L) {
#line 852
              *xrpnt = - ispow[y] * v;
            } else {
#line 853
              *xrpnt = ispow[y] * v;
            }
#line 855
            mask <<= 1;
          } else {
#line 845
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 857
        if (y) {
#line 859
          max[lwin] = cb;
#line 860
          if (mask < 0L) {
#line 860
            *xrpnt = - ispow[y] * v;
          } else {
#line 861
            *xrpnt = ispow[y] * v;
          }
#line 863
          num --;
#line 864
          mask <<= 1;
        } else {
#line 866
          *xrpnt = (float )0.0;
        }
#line 868
        xrpnt += step___30;
#line 782
        lp --;
#line 782
        mc --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 778
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 872
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 872
      if (l3) {
#line 872
        if (! (part2remain + num > 0)) {
#line 872
          goto while_break___5;
        }
      } else {
#line 872
        goto while_break___5;
      }
#line 888
      if (! ((unsigned long )xrpnt < (unsigned long )(& (*(xr + 32))[0] + 5))) {
#line 890
        if (! (fr->p.flags & 32L)) {
          {
#line 890
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c:%i] error: attempted xrpnt overflow (%p !< %p)\n",
                  890, (void *)xrpnt, (void *)(& (*(xr + 32))[0]));
          }
        }
#line 891
        return (2);
      }
#line 893
      h___0 = htc + gr_info->count1table_select;
#line 894
      val___0 = h___0->table;
      {
#line 896
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 896
        if (! ((unsigned long )num < (sizeof(long ) - 1UL) * 8UL)) {
#line 896
          goto while_break___6;
        }
#line 896
        tmp___10 = fr->wordpointer;
#line 896
        (fr->wordpointer) ++;
#line 896
        mask = (long )((unsigned long )mask | ((unsigned long )*tmp___10 << ((sizeof(long ) - 1UL) * 8UL - (unsigned long )num)));
#line 896
        num += 8;
#line 896
        part2remain -= 8;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 897
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 897
        tmp___11 = val___0;
#line 897
        val___0 ++;
#line 897
        a = *tmp___11;
#line 897
        if (! ((int )a < 0)) {
#line 897
          goto while_break___7;
        }
#line 899
        if (mask < 0L) {
#line 899
          val___0 -= (int )a;
        }
#line 901
        num --;
#line 902
        mask <<= 1;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 904
      if (part2remain + num <= 0) {
#line 906
        num -= part2remain + num;
#line 907
        goto while_break___5;
      }
#line 910
      i = 0;
      {
#line 910
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 910
        if (! (i < 4)) {
#line 910
          goto while_break___8;
        }
#line 912
        if (! (i & 1)) {
#line 914
          if (! mc) {
#line 916
            tmp___12 = m;
#line 916
            m ++;
#line 916
            mc = *tmp___12;
#line 917
            tmp___13 = m;
#line 917
            m ++;
#line 917
            xrpnt = (float *)xr + *tmp___13;
#line 918
            tmp___14 = m;
#line 918
            m ++;
#line 918
            lwin = *tmp___14;
#line 919
            tmp___15 = m;
#line 919
            m ++;
#line 919
            cb = *tmp___15;
#line 920
            if (lwin == 3) {
#line 925
              tmp___16 = scf;
#line 925
              scf ++;
#line 925
              v = *(gr_info->pow2gain + (*tmp___16 << shift));
#line 926
              step___30 = 1;
            } else {
#line 933
              tmp___17 = scf;
#line 933
              scf ++;
#line 933
              v = *(gr_info->full_gain[lwin] + (*tmp___17 << shift));
#line 934
              step___30 = 3;
            }
          }
#line 937
          mc --;
        }
#line 939
        if ((int )a & (8 >> i)) {
#line 941
          max[lwin] = cb;
#line 942
          if (part2remain + num <= 0) {
#line 943
            goto while_break___8;
          }
#line 945
          if (mask < 0L) {
#line 945
            *xrpnt = - v;
          } else {
#line 946
            *xrpnt = v;
          }
#line 948
          num --;
#line 949
          mask <<= 1;
        } else {
#line 951
          *xrpnt = (float )0.0;
        }
#line 953
        xrpnt += step___30;
#line 910
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 872
      l3 --;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 957
    if (lwin < 3) {
      {
#line 959
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 961
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 961
          if (! (mc > 0)) {
#line 961
            goto while_break___10;
          }
#line 963
          *xrpnt = (float )0.0;
#line 963
          xrpnt += 3;
#line 964
          *xrpnt = (float )0.0;
#line 964
          xrpnt += 3;
#line 961
          mc --;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 966
        if ((unsigned long )m >= (unsigned long )me) {
#line 967
          goto while_break___9;
        }
#line 969
        tmp___18 = m;
#line 969
        m ++;
#line 969
        mc = *tmp___18;
#line 970
        tmp___19 = m;
#line 970
        m ++;
#line 970
        xrpnt = (float *)xr + *tmp___19;
#line 971
        tmp___20 = m;
#line 971
        m ++;
#line 971
        if (*tmp___20 == 0) {
#line 972
          goto while_break___9;
        }
#line 974
        m ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 978
    gr_info->maxband[0] = (unsigned int )(max[0] + 1);
#line 979
    gr_info->maxband[1] = (unsigned int )(max[1] + 1);
#line 980
    gr_info->maxband[2] = (unsigned int )(max[2] + 1);
#line 981
    gr_info->maxbandl = (unsigned int )(max[3] + 1);
#line 984
    if (max[0] > max[1]) {
#line 984
      tmp___21 = max[0];
    } else {
#line 984
      tmp___21 = max[1];
    }
#line 984
    rmax = tmp___21;
#line 985
    if (rmax > max[2]) {
#line 985
      tmp___22 = rmax;
    } else {
#line 985
      tmp___22 = max[2];
    }
#line 985
    rmax = tmp___22 + 1;
#line 986
    if (rmax) {
#line 986
      gr_info->maxb = (unsigned int )fr->shortLimit[sfreq][rmax];
    } else {
#line 986
      gr_info->maxb = (unsigned int )fr->longLimit[sfreq][max[3] + 1];
    }
  } else {
#line 993
    if (gr_info->preflag) {
#line 993
      tmp___23 = pretab1;
    } else {
#line 993
      tmp___23 = pretab2;
    }
#line 993
    pretab = tmp___23;
#line 994
    max___0 = -1;
#line 995
    cb___0 = 0;
#line 996
    m___0 = map[sfreq][2];
#line 997
    v___0 = (float )0.0;
#line 998
    mc___0 = 0;
#line 1001
    i___0 = 0;
    {
#line 1001
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1001
      if (! (i___0 < 3)) {
#line 1001
        goto while_break___11;
      }
#line 1003
      lp___0 = l___0[i___0];
#line 1004
      h___1 = ht + gr_info->table_select[i___0];
      {
#line 1006
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1006
        if (! lp___0) {
#line 1006
          goto while_break___12;
        }
#line 1009
        if (! mc___0) {
#line 1011
          tmp___24 = m___0;
#line 1011
          m___0 ++;
#line 1011
          mc___0 = *tmp___24;
#line 1012
          tmp___25 = m___0;
#line 1012
          m___0 ++;
#line 1012
          cb___0 = *tmp___25;
#line 1022
          tmp___26 = scf;
#line 1022
          scf ++;
#line 1022
          tmp___27 = pretab;
#line 1022
          pretab ++;
#line 1022
          v___0 = *(gr_info->pow2gain + ((*tmp___26 + (int )*tmp___27) << shift));
        }
#line 1026
        val___1 = h___1->table;
        {
#line 1027
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1027
          if (! ((unsigned long )num < (sizeof(long ) - 1UL) * 8UL)) {
#line 1027
            goto while_break___13;
          }
#line 1027
          tmp___28 = fr->wordpointer;
#line 1027
          (fr->wordpointer) ++;
#line 1027
          mask = (long )((unsigned long )mask | ((unsigned long )*tmp___28 << ((sizeof(long ) - 1UL) * 8UL - (unsigned long )num)));
#line 1027
          num += 8;
#line 1027
          part2remain -= 8;
        }
        while_break___13: /* CIL Label */ ;
        }
        {
#line 1028
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 1028
          tmp___29 = val___1;
#line 1028
          val___1 ++;
#line 1028
          y___0 = (int )*tmp___29;
#line 1028
          if (! (y___0 < 0)) {
#line 1028
            goto while_break___14;
          }
#line 1030
          if (mask < 0L) {
#line 1030
            val___1 -= y___0;
          }
#line 1032
          num --;
#line 1033
          mask <<= 1;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 1035
        x___0 = y___0 >> 4;
#line 1036
        y___0 &= 15;
#line 1039
        if (x___0 == 15) {
#line 1039
          if (h___1->linbits) {
#line 1041
            max___0 = cb___0;
            {
#line 1042
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 1042
              if (! ((unsigned long )num < (sizeof(long ) - 1UL) * 8UL)) {
#line 1042
                goto while_break___15;
              }
#line 1042
              tmp___30 = fr->wordpointer;
#line 1042
              (fr->wordpointer) ++;
#line 1042
              mask = (long )((unsigned long )mask | ((unsigned long )*tmp___30 << ((sizeof(long ) - 1UL) * 8UL - (unsigned long )num)));
#line 1042
              num += 8;
#line 1042
              part2remain -= 8;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 1043
            x___0 = (int )((unsigned long )x___0 + ((unsigned long )mask >> (((sizeof(long ) - 1UL) * 8UL + 8UL) - (unsigned long )h___1->linbits)));
#line 1044
            num = (int )((unsigned int )num - (h___1->linbits + 1U));
#line 1045
            mask <<= h___1->linbits;
#line 1046
            if (mask < 0L) {
#line 1046
              tmp___31 = xrpnt;
#line 1046
              xrpnt ++;
#line 1046
              *tmp___31 = - ispow[x___0] * v___0;
            } else {
#line 1047
              tmp___32 = xrpnt;
#line 1047
              xrpnt ++;
#line 1047
              *tmp___32 = ispow[x___0] * v___0;
            }
#line 1049
            mask <<= 1;
          } else {
#line 1039
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1051
        if (x___0) {
#line 1053
          max___0 = cb___0;
#line 1054
          if (mask < 0L) {
#line 1054
            tmp___33 = xrpnt;
#line 1054
            xrpnt ++;
#line 1054
            *tmp___33 = - ispow[x___0] * v___0;
          } else {
#line 1055
            tmp___34 = xrpnt;
#line 1055
            xrpnt ++;
#line 1055
            *tmp___34 = ispow[x___0] * v___0;
          }
#line 1056
          num --;
#line 1058
          mask <<= 1;
        } else {
#line 1060
          tmp___35 = xrpnt;
#line 1060
          xrpnt ++;
#line 1060
          *tmp___35 = (float )0.0;
        }
#line 1062
        if (y___0 == 15) {
#line 1062
          if (h___1->linbits) {
#line 1064
            max___0 = cb___0;
            {
#line 1065
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 1065
              if (! ((unsigned long )num < (sizeof(long ) - 1UL) * 8UL)) {
#line 1065
                goto while_break___16;
              }
#line 1065
              tmp___36 = fr->wordpointer;
#line 1065
              (fr->wordpointer) ++;
#line 1065
              mask = (long )((unsigned long )mask | ((unsigned long )*tmp___36 << ((sizeof(long ) - 1UL) * 8UL - (unsigned long )num)));
#line 1065
              num += 8;
#line 1065
              part2remain -= 8;
            }
            while_break___16: /* CIL Label */ ;
            }
#line 1066
            y___0 = (int )((unsigned long )y___0 + ((unsigned long )mask >> (((sizeof(long ) - 1UL) * 8UL + 8UL) - (unsigned long )h___1->linbits)));
#line 1067
            num = (int )((unsigned int )num - (h___1->linbits + 1U));
#line 1068
            mask <<= h___1->linbits;
#line 1069
            if (mask < 0L) {
#line 1069
              tmp___37 = xrpnt;
#line 1069
              xrpnt ++;
#line 1069
              *tmp___37 = - ispow[y___0] * v___0;
            } else {
#line 1070
              tmp___38 = xrpnt;
#line 1070
              xrpnt ++;
#line 1070
              *tmp___38 = ispow[y___0] * v___0;
            }
#line 1072
            mask <<= 1;
          } else {
#line 1062
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1074
        if (y___0) {
#line 1076
          max___0 = cb___0;
#line 1077
          if (mask < 0L) {
#line 1077
            tmp___39 = xrpnt;
#line 1077
            xrpnt ++;
#line 1077
            *tmp___39 = - ispow[y___0] * v___0;
          } else {
#line 1078
            tmp___40 = xrpnt;
#line 1078
            xrpnt ++;
#line 1078
            *tmp___40 = ispow[y___0] * v___0;
          }
#line 1080
          num --;
#line 1081
          mask <<= 1;
        } else {
#line 1083
          tmp___41 = xrpnt;
#line 1083
          xrpnt ++;
#line 1083
          *tmp___41 = (float )0.0;
        }
#line 1006
        lp___0 --;
#line 1006
        mc___0 --;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1001
      i___0 ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 1088
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1088
      if (l3) {
#line 1088
        if (! (part2remain + num > 0)) {
#line 1088
          goto while_break___17;
        }
      } else {
#line 1088
        goto while_break___17;
      }
#line 1090
      h___2 = htc + gr_info->count1table_select;
#line 1091
      val___2 = h___2->table;
      {
#line 1093
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 1093
        if (! ((unsigned long )num < (sizeof(long ) - 1UL) * 8UL)) {
#line 1093
          goto while_break___18;
        }
#line 1093
        tmp___42 = fr->wordpointer;
#line 1093
        (fr->wordpointer) ++;
#line 1093
        mask = (long )((unsigned long )mask | ((unsigned long )*tmp___42 << ((sizeof(long ) - 1UL) * 8UL - (unsigned long )num)));
#line 1093
        num += 8;
#line 1093
        part2remain -= 8;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 1094
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 1094
        tmp___43 = val___2;
#line 1094
        val___2 ++;
#line 1094
        a___0 = *tmp___43;
#line 1094
        if (! ((int )a___0 < 0)) {
#line 1094
          goto while_break___19;
        }
#line 1096
        if (mask < 0L) {
#line 1096
          val___2 -= (int )a___0;
        }
#line 1098
        num --;
#line 1099
        mask <<= 1;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 1101
      if (part2remain + num <= 0) {
#line 1103
        num -= part2remain + num;
#line 1104
        goto while_break___17;
      }
#line 1107
      i___0 = 0;
      {
#line 1107
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 1107
        if (! (i___0 < 4)) {
#line 1107
          goto while_break___20;
        }
#line 1109
        if (! (i___0 & 1)) {
#line 1111
          if (! mc___0) {
#line 1113
            tmp___44 = m___0;
#line 1113
            m___0 ++;
#line 1113
            mc___0 = *tmp___44;
#line 1114
            tmp___45 = m___0;
#line 1114
            m___0 ++;
#line 1114
            cb___0 = *tmp___45;
#line 1124
            tmp___46 = scf;
#line 1124
            scf ++;
#line 1124
            tmp___47 = pretab;
#line 1124
            pretab ++;
#line 1124
            v___0 = *(gr_info->pow2gain + ((*tmp___46 + (int )*tmp___47) << shift));
          }
#line 1127
          mc___0 --;
        }
#line 1129
        if ((int )a___0 & (8 >> i___0)) {
#line 1131
          max___0 = cb___0;
#line 1132
          if (part2remain + num <= 0) {
#line 1133
            goto while_break___20;
          }
#line 1135
          if (mask < 0L) {
#line 1135
            tmp___48 = xrpnt;
#line 1135
            xrpnt ++;
#line 1135
            *tmp___48 = - v___0;
          } else {
#line 1136
            tmp___49 = xrpnt;
#line 1136
            xrpnt ++;
#line 1136
            *tmp___49 = v___0;
          }
#line 1138
          num --;
#line 1139
          mask <<= 1;
        } else {
#line 1141
          tmp___50 = xrpnt;
#line 1141
          xrpnt ++;
#line 1141
          *tmp___50 = (float )0.0;
        }
#line 1107
        i___0 ++;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 1088
      l3 --;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1145
    gr_info->maxbandl = (unsigned int )(max___0 + 1);
#line 1146
    gr_info->maxb = (unsigned int )fr->longLimit[sfreq][gr_info->maxbandl];
  }
#line 1149
  part2remain += num;
#line 1150
  fr->bitindex -= num;
#line 1150
  fr->wordpointer += fr->bitindex >> 3;
#line 1150
  fr->bitindex &= 7;
#line 1151
  num = 0;
  {
#line 1153
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 1153
    if (! ((unsigned long )xrpnt < (unsigned long )(& (*(xr + 32))[0]))) {
#line 1153
      goto while_break___21;
    }
#line 1154
    tmp___51 = xrpnt;
#line 1154
    xrpnt ++;
#line 1154
    *tmp___51 = (float )0.0;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 1156
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 1156
    if (! (part2remain > 16)) {
#line 1156
      goto while_break___22;
    }
#line 1158
    fr->ultmp = (unsigned long )*(fr->wordpointer + 0);
#line 1158
    fr->ultmp <<= 8;
#line 1158
    fr->ultmp |= (unsigned long )*(fr->wordpointer + 1);
#line 1158
    fr->ultmp <<= 8;
#line 1158
    fr->ultmp |= (unsigned long )*(fr->wordpointer + 2);
#line 1158
    fr->ultmp <<= fr->bitindex;
#line 1158
    fr->ultmp &= 16777215UL;
#line 1158
    fr->bitindex += 16;
#line 1158
    fr->ultmp >>= 8;
#line 1158
    fr->wordpointer += fr->bitindex >> 3;
#line 1158
    tmp___52 = fr->bitindex & 7;
#line 1158
    fr->bitindex = tmp___52;
#line 1158
    fr->ultmp = (unsigned long )tmp___52;
#line 1159
    part2remain -= 16;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 1161
  if (part2remain > 0) {
#line 1161
    fr->ultmp = (unsigned long )*(fr->wordpointer + 0);
#line 1161
    fr->ultmp <<= 8;
#line 1161
    fr->ultmp |= (unsigned long )*(fr->wordpointer + 1);
#line 1161
    fr->ultmp <<= 8;
#line 1161
    fr->ultmp |= (unsigned long )*(fr->wordpointer + 2);
#line 1161
    fr->ultmp <<= fr->bitindex;
#line 1161
    fr->ultmp &= 16777215UL;
#line 1161
    fr->bitindex += part2remain;
#line 1161
    fr->ultmp >>= 24 - part2remain;
#line 1161
    fr->wordpointer += fr->bitindex >> 3;
#line 1161
    tmp___53 = fr->bitindex & 7;
#line 1161
    fr->bitindex = tmp___53;
#line 1161
    fr->ultmp = (unsigned long )tmp___53;
  } else
#line 1162
  if (part2remain < 0) {
#line 1165
    return (1);
  }
#line 1167
  return (0);
}
}
#line 1172 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static void III_i_stereo(float (*xr_buf)[32][18] , int *scalefac , struct gr_info_s *gr_info ,
                         int sfreq , int ms_stereo , int lsf ) 
{ 
  float (*xr)[576] ;
  struct bandInfoStruct  const  *bi ;
  float const   *tab1___0 ;
  float const   *tab2___0 ;
  int tab ;
  float const   *tabs[3][2][2] ;
  int lwin ;
  int do_l ;
  int is_p ;
  int sb ;
  int idx ;
  int sfb ;
  float t1 ;
  float t2 ;
  float v ;
  float t1___0 ;
  float t2___0 ;
  float v___0 ;
  int sfb___0 ;
  int idx___0 ;
  int sb___0 ;
  int is_p___0 ;
  float t1___1 ;
  float t2___1 ;
  float v___1 ;
  int sfb___1 ;
  int is_p___1 ;
  int idx___1 ;
  int sb___1 ;
  float t1___2 ;
  float t2___2 ;
  float v___2 ;
  int sb___2 ;
  float t1___3 ;
  float t2___3 ;
  float v___3 ;
  void *__cil_tmp43 ;
  int __cil_tmp44 ;
  void *__cil_tmp45 ;
  int __cil_tmp46 ;
  void *__cil_tmp47 ;

  {
#line 1174
  xr = (float (*)[576])xr_buf;
#line 1175
  bi = & bandInfo[sfreq];
#line 1182
  tabs[0][0][0] = (float const   *)(tan1_1);
#line 1182
  tabs[0][0][1] = (float const   *)(tan2_1);
#line 1182
  tabs[0][1][0] = (float const   *)(tan1_2);
#line 1182
  tabs[0][1][1] = (float const   *)(tan2_2);
#line 1182
  tabs[1][0][0] = (float const   *)(pow1_1[0]);
#line 1182
  tabs[1][0][1] = (float const   *)(pow2_1[0]);
#line 1182
  tabs[1][1][0] = (float const   *)(pow1_2[0]);
#line 1182
  tabs[1][1][1] = (float const   *)(pow2_2[0]);
#line 1182
  tabs[2][0][0] = (float const   *)(pow1_1[1]);
#line 1182
  tabs[2][0][1] = (float const   *)(pow2_1[1]);
#line 1182
  tabs[2][1][0] = (float const   *)(pow1_2[1]);
#line 1182
  tabs[2][1][1] = (float const   *)(pow2_2[1]);
#line 1189
  tab = (int )((unsigned int )lsf + (gr_info->scalefac_compress & (unsigned int )lsf));
#line 1190
  tab1___0 = tabs[tab][ms_stereo][0];
#line 1191
  tab2___0 = tabs[tab][ms_stereo][1];
#line 1222
  if (gr_info->block_type == 2U) {
#line 1224
    do_l = 0;
#line 1225
    if (gr_info->mixed_block_flag) {
#line 1225
      do_l = 1;
    }
#line 1227
    lwin = 0;
    {
#line 1227
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1227
      if (! (lwin < 3)) {
#line 1227
        goto while_break;
      }
#line 1230
      sfb = (int )gr_info->maxband[lwin];
#line 1231
      if (sfb > 3) {
#line 1231
        do_l = 0;
      }
      {
#line 1233
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1233
        if (! (sfb < 12)) {
#line 1233
          goto while_break___0;
        }
#line 1235
        is_p = *(scalefac + ((unsigned int )(sfb * 3 + lwin) - gr_info->mixed_block_flag));
#line 1236
        if (is_p != 7) {
#line 1239
          sb = bi->shortDiff[sfb];
#line 1240
          idx = bi->shortIdx[sfb] + lwin;
#line 1241
          t1 = (float )*(tab1___0 + is_p);
#line 1241
          t2 = (float )*(tab2___0 + is_p);
          {
#line 1242
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1242
            if (! (sb > 0)) {
#line 1242
              goto while_break___1;
            }
#line 1244
            v = (*(xr + 0))[idx];
#line 1245
            (*(xr + 0))[idx] = v * t1;
#line 1246
            (*(xr + 1))[idx] = v * t2;
#line 1242
            sb --;
#line 1242
            idx += 3;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 1233
        sfb ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1254
      is_p = *(scalefac + ((unsigned int )(33 + lwin) - gr_info->mixed_block_flag));
#line 1255
      sb = bi->shortDiff[12];
#line 1256
      idx = bi->shortIdx[12] + lwin;
#line 1262
      if (is_p != 7) {
#line 1265
        t1___0 = (float )*(tab1___0 + is_p);
#line 1265
        t2___0 = (float )*(tab2___0 + is_p);
        {
#line 1266
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1266
          if (! (sb > 0)) {
#line 1266
            goto while_break___2;
          }
#line 1268
          v___0 = (*(xr + 0))[idx];
#line 1269
          (*(xr + 0))[idx] = v___0 * t1___0;
#line 1270
          (*(xr + 1))[idx] = v___0 * t2___0;
#line 1266
          sb --;
#line 1266
          idx += 3;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1227
      lwin ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1276
    if (do_l) {
#line 1278
      sfb___0 = (int )gr_info->maxbandl;
#line 1280
      if (sfb___0 > 21) {
#line 1280
        return;
      }
#line 1282
      idx___0 = bi->longIdx[sfb___0];
      {
#line 1283
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1283
        if (! (sfb___0 < 8)) {
#line 1283
          goto while_break___3;
        }
#line 1285
        sb___0 = bi->longDiff[sfb___0];
#line 1286
        is_p___0 = *(scalefac + sfb___0);
#line 1287
        if (is_p___0 != 7) {
#line 1290
          t1___1 = (float )*(tab1___0 + is_p___0);
#line 1290
          t2___1 = (float )*(tab2___0 + is_p___0);
          {
#line 1291
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1291
            if (! (sb___0 > 0)) {
#line 1291
              goto while_break___4;
            }
#line 1293
            v___1 = (*(xr + 0))[idx___0];
#line 1294
            (*(xr + 0))[idx___0] = v___1 * t1___1;
#line 1295
            (*(xr + 1))[idx___0] = v___1 * t2___1;
#line 1291
            sb___0 --;
#line 1291
            idx___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
#line 1298
          idx___0 += sb___0;
        }
#line 1283
        sfb___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  } else {
#line 1304
    sfb___1 = (int )gr_info->maxbandl;
#line 1306
    if (sfb___1 > 21) {
#line 1306
      return;
    }
#line 1308
    idx___1 = bi->longIdx[sfb___1];
    {
#line 1309
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1309
      if (! (sfb___1 < 21)) {
#line 1309
        goto while_break___5;
      }
#line 1311
      sb___1 = bi->longDiff[sfb___1];
#line 1312
      is_p___1 = *(scalefac + sfb___1);
#line 1313
      if (is_p___1 != 7) {
#line 1316
        t1___2 = (float )*(tab1___0 + is_p___1);
#line 1316
        t2___2 = (float )*(tab2___0 + is_p___1);
        {
#line 1317
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1317
          if (! (sb___1 > 0)) {
#line 1317
            goto while_break___6;
          }
#line 1319
          v___2 = (*(xr + 0))[idx___1];
#line 1320
          (*(xr + 0))[idx___1] = v___2 * t1___2;
#line 1321
          (*(xr + 1))[idx___1] = v___2 * t2___2;
#line 1317
          sb___1 --;
#line 1317
          idx___1 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
#line 1324
        idx___1 += sb___1;
      }
#line 1309
      sfb___1 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1327
    is_p___1 = *(scalefac + 20);
#line 1328
    if (is_p___1 != 7) {
#line 1331
      t1___3 = (float )*(tab1___0 + is_p___1);
#line 1331
      t2___3 = (float )*(tab2___0 + is_p___1);
#line 1333
      sb___2 = bi->longDiff[21];
      {
#line 1333
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1333
        if (! (sb___2 > 0)) {
#line 1333
          goto while_break___7;
        }
#line 1335
        v___3 = (*(xr + 0))[idx___1];
#line 1336
        (*(xr + 0))[idx___1] = v___3 * t1___3;
#line 1337
        (*(xr + 1))[idx___1] = v___3 * t2___3;
#line 1333
        sb___2 --;
#line 1333
        idx___1 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
#line 1341
  return;
}
}
#line 1344 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static void III_antialias(float (*xr)[18] , struct gr_info_s *gr_info ) 
{ 
  int sblim ;
  int sb ;
  float *xr1 ;
  int ss ;
  float *cs ;
  float *ca ;
  float *xr2 ;
  register float bu ;
  register float bd ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;

  {
#line 1348
  if (gr_info->block_type == 2U) {
#line 1350
    if (! gr_info->mixed_block_flag) {
#line 1350
      return;
    }
#line 1352
    sblim = 1;
  } else {
#line 1354
    sblim = (int )(gr_info->maxb - 1U);
  }
#line 1361
  xr1 = *(xr + 1);
#line 1363
  sb = sblim;
  {
#line 1363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1363
    if (! sb) {
#line 1363
      goto while_break;
    }
#line 1366
    cs = aa_cs;
#line 1366
    ca = aa_ca;
#line 1367
    xr2 = xr1;
#line 1369
    ss = 7;
    {
#line 1369
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1369
      if (! (ss >= 0)) {
#line 1369
        goto while_break___0;
      }
#line 1371
      xr2 --;
#line 1371
      bu = *xr2;
#line 1371
      bd = *xr1;
#line 1372
      *xr2 = bu * *cs - bd * *ca;
#line 1373
      tmp = xr1;
#line 1373
      xr1 ++;
#line 1373
      tmp___0 = cs;
#line 1373
      cs ++;
#line 1373
      tmp___1 = ca;
#line 1373
      ca ++;
#line 1373
      *tmp = bd * *tmp___0 + bu * *tmp___1;
#line 1369
      ss --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1363
    sb --;
#line 1363
    xr1 += 10;
  }
  while_break: /* CIL Label */ ;
  }
#line 1377
  return;
}
}
#line 1416 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
void dct36(float *inbuf , float *o1 , float *o2 , float *wintab , float *tsbuf ) 
{ 
  float tmp[18] ;
  register float *in ;
  float t3 ;
  float t0 ;
  float t1 ;
  float t2 ;
  float t0___0 ;
  float t1___0 ;
  float t2___0 ;
  float t1___1 ;
  float t2___1 ;
  float t3___0 ;
  float t0___1 ;
  float t0___2 ;
  float t1___2 ;
  float t2___2 ;
  float t3___1 ;
  float t4 ;
  float t5 ;
  float t6 ;
  float t7 ;
  register float *out2 ;
  register float *w ;
  register float *out1 ;
  register float *ts ;
  float tmpval ;
  float tmpval___0 ;
  float tmpval___1 ;
  float tmpval___2 ;
  float tmpval___3 ;
  float tmpval___4 ;
  float tmpval___5 ;
  float tmpval___6 ;
  float tmpval___7 ;
  void *__cil_tmp40 ;

  {
#line 1423
  in = inbuf;
#line 1425
  *(in + 17) += *(in + 16);
#line 1425
  *(in + 16) += *(in + 15);
#line 1425
  *(in + 15) += *(in + 14);
#line 1426
  *(in + 14) += *(in + 13);
#line 1426
  *(in + 13) += *(in + 12);
#line 1426
  *(in + 12) += *(in + 11);
#line 1427
  *(in + 11) += *(in + 10);
#line 1427
  *(in + 10) += *(in + 9);
#line 1427
  *(in + 9) += *(in + 8);
#line 1428
  *(in + 8) += *(in + 7);
#line 1428
  *(in + 7) += *(in + 6);
#line 1428
  *(in + 6) += *(in + 5);
#line 1429
  *(in + 5) += *(in + 4);
#line 1429
  *(in + 4) += *(in + 3);
#line 1429
  *(in + 3) += *(in + 2);
#line 1430
  *(in + 2) += *(in + 1);
#line 1430
  *(in + 1) += *(in + 0);
#line 1432
  *(in + 17) += *(in + 15);
#line 1432
  *(in + 15) += *(in + 13);
#line 1432
  *(in + 13) += *(in + 11);
#line 1432
  *(in + 11) += *(in + 9);
#line 1433
  *(in + 9) += *(in + 7);
#line 1433
  *(in + 7) += *(in + 5);
#line 1433
  *(in + 5) += *(in + 3);
#line 1433
  *(in + 3) += *(in + 1);
#line 1443
  t0 = COS6_2 * ((*(in + 8) + *(in + 16)) - *(in + 4));
#line 1444
  t1 = COS6_2 * *(in + 12);
#line 1446
  t3 = *(in + 0);
#line 1447
  t2 = (t3 - t1) - t1;
#line 1448
  tmp[7] = t2 - t0;
#line 1448
  tmp[1] = tmp[7];
#line 1449
  tmp[4] = (t2 + t0) + t0;
#line 1450
  t3 += t1;
#line 1452
  t2 = COS6_1 * ((*(in + 10) + *(in + 14)) - *(in + 2));
#line 1453
  tmp[1] -= t2;
#line 1454
  tmp[7] += t2;
#line 1459
  t0___0 = cos9[0] * (*(in + 4) + *(in + 8));
#line 1460
  t1___0 = cos9[1] * (*(in + 8) - *(in + 16));
#line 1461
  t2___0 = cos9[2] * (*(in + 4) + *(in + 16));
#line 1463
  tmp[6] = (t3 - t0___0) - t2___0;
#line 1463
  tmp[2] = tmp[6];
#line 1464
  tmp[8] = (t3 + t0___0) + t1___0;
#line 1464
  tmp[0] = tmp[8];
#line 1465
  tmp[5] = (t3 - t1___0) + t2___0;
#line 1465
  tmp[3] = tmp[5];
#line 1471
  t1___1 = cos18[0] * (*(in + 2) + *(in + 10));
#line 1472
  t2___1 = cos18[1] * (*(in + 10) - *(in + 14));
#line 1473
  t3___0 = COS6_1 * *(in + 6);
#line 1476
  t0___1 = (t1___1 + t2___1) + t3___0;
#line 1477
  tmp[0] += t0___1;
#line 1478
  tmp[8] -= t0___1;
#line 1481
  t2___1 -= t3___0;
#line 1482
  t1___1 -= t3___0;
#line 1484
  t3___0 = cos18[2] * (*(in + 2) + *(in + 14));
#line 1486
  t1___1 += t3___0;
#line 1487
  tmp[3] += t1___1;
#line 1488
  tmp[5] -= t1___1;
#line 1490
  t2___1 -= t3___0;
#line 1491
  tmp[2] += t2___1;
#line 1492
  tmp[6] -= t2___1;
#line 1542
  t1___2 = COS6_2 * *(in + 13);
#line 1543
  t2___2 = COS6_2 * ((*(in + 9) + *(in + 17)) - *(in + 5));
#line 1545
  t3___1 = *(in + 1) + t1___2;
#line 1546
  t4 = (*(in + 1) - t1___2) - t1___2;
#line 1547
  t5 = t4 - t2___2;
#line 1549
  t0___2 = cos9[0] * (*(in + 5) + *(in + 9));
#line 1550
  t1___2 = cos9[1] * (*(in + 9) - *(in + 17));
#line 1552
  tmp[13] = ((t4 + t2___2) + t2___2) * tfcos36[4];
#line 1553
  t2___2 = cos9[2] * (*(in + 5) + *(in + 17));
#line 1555
  t6 = (t3___1 - t0___2) - t2___2;
#line 1556
  t0___2 += t3___1 + t1___2;
#line 1557
  t3___1 += t2___2 - t1___2;
#line 1559
  t2___2 = cos18[0] * (*(in + 3) + *(in + 11));
#line 1560
  t4 = cos18[1] * (*(in + 11) - *(in + 15));
#line 1561
  t7 = COS6_1 * *(in + 7);
#line 1563
  t1___2 = (t2___2 + t4) + t7;
#line 1564
  tmp[17] = (t0___2 + t1___2) * tfcos36[0];
#line 1565
  tmp[9] = (t0___2 - t1___2) * tfcos36[8];
#line 1566
  t1___2 = cos18[2] * (*(in + 3) + *(in + 15));
#line 1567
  t2___2 += t1___2 - t7;
#line 1569
  tmp[14] = (t3___1 + t2___2) * tfcos36[3];
#line 1570
  t0___2 = COS6_1 * ((*(in + 11) + *(in + 15)) - *(in + 3));
#line 1571
  tmp[12] = (t3___1 - t2___2) * tfcos36[5];
#line 1573
  t4 -= t1___2 + t7;
#line 1575
  tmp[16] = (t5 - t0___2) * tfcos36[1];
#line 1576
  tmp[10] = (t5 + t0___2) * tfcos36[7];
#line 1577
  tmp[15] = (t6 + t4) * tfcos36[2];
#line 1578
  tmp[11] = (t6 - t4) * tfcos36[6];
#line 1591
  out2 = o2;
#line 1592
  w = wintab;
#line 1593
  out1 = o1;
#line 1594
  ts = tsbuf;
#line 1596
  tmpval = tmp[0] + tmp[17];
#line 1596
  *(out2 + 9) = tmpval * *(w + 27);
#line 1596
  *(out2 + 8) = tmpval * *(w + 26);
#line 1596
  tmpval = tmp[0] - tmp[17];
#line 1596
  *(ts + 256) = *(out1 + 8) + tmpval * *(w + 8);
#line 1596
  *(ts + 288) = *(out1 + 9) + tmpval * *(w + 9);
#line 1597
  tmpval___0 = tmp[1] + tmp[16];
#line 1597
  *(out2 + 10) = tmpval___0 * *(w + 28);
#line 1597
  *(out2 + 7) = tmpval___0 * *(w + 25);
#line 1597
  tmpval___0 = tmp[1] - tmp[16];
#line 1597
  *(ts + 224) = *(out1 + 7) + tmpval___0 * *(w + 7);
#line 1597
  *(ts + 320) = *(out1 + 10) + tmpval___0 * *(w + 10);
#line 1598
  tmpval___1 = tmp[2] + tmp[15];
#line 1598
  *(out2 + 11) = tmpval___1 * *(w + 29);
#line 1598
  *(out2 + 6) = tmpval___1 * *(w + 24);
#line 1598
  tmpval___1 = tmp[2] - tmp[15];
#line 1598
  *(ts + 192) = *(out1 + 6) + tmpval___1 * *(w + 6);
#line 1598
  *(ts + 352) = *(out1 + 11) + tmpval___1 * *(w + 11);
#line 1599
  tmpval___2 = tmp[3] + tmp[14];
#line 1599
  *(out2 + 12) = tmpval___2 * *(w + 30);
#line 1599
  *(out2 + 5) = tmpval___2 * *(w + 23);
#line 1599
  tmpval___2 = tmp[3] - tmp[14];
#line 1599
  *(ts + 160) = *(out1 + 5) + tmpval___2 * *(w + 5);
#line 1599
  *(ts + 384) = *(out1 + 12) + tmpval___2 * *(w + 12);
#line 1600
  tmpval___3 = tmp[4] + tmp[13];
#line 1600
  *(out2 + 13) = tmpval___3 * *(w + 31);
#line 1600
  *(out2 + 4) = tmpval___3 * *(w + 22);
#line 1600
  tmpval___3 = tmp[4] - tmp[13];
#line 1600
  *(ts + 128) = *(out1 + 4) + tmpval___3 * *(w + 4);
#line 1600
  *(ts + 416) = *(out1 + 13) + tmpval___3 * *(w + 13);
#line 1601
  tmpval___4 = tmp[5] + tmp[12];
#line 1601
  *(out2 + 14) = tmpval___4 * *(w + 32);
#line 1601
  *(out2 + 3) = tmpval___4 * *(w + 21);
#line 1601
  tmpval___4 = tmp[5] - tmp[12];
#line 1601
  *(ts + 96) = *(out1 + 3) + tmpval___4 * *(w + 3);
#line 1601
  *(ts + 448) = *(out1 + 14) + tmpval___4 * *(w + 14);
#line 1602
  tmpval___5 = tmp[6] + tmp[11];
#line 1602
  *(out2 + 15) = tmpval___5 * *(w + 33);
#line 1602
  *(out2 + 2) = tmpval___5 * *(w + 20);
#line 1602
  tmpval___5 = tmp[6] - tmp[11];
#line 1602
  *(ts + 64) = *(out1 + 2) + tmpval___5 * *(w + 2);
#line 1602
  *(ts + 480) = *(out1 + 15) + tmpval___5 * *(w + 15);
#line 1603
  tmpval___6 = tmp[7] + tmp[10];
#line 1603
  *(out2 + 16) = tmpval___6 * *(w + 34);
#line 1603
  *(out2 + 1) = tmpval___6 * *(w + 19);
#line 1603
  tmpval___6 = tmp[7] - tmp[10];
#line 1603
  *(ts + 32) = *(out1 + 1) + tmpval___6 * *(w + 1);
#line 1603
  *(ts + 512) = *(out1 + 16) + tmpval___6 * *(w + 16);
#line 1604
  tmpval___7 = tmp[8] + tmp[9];
#line 1604
  *(out2 + 17) = tmpval___7 * *(w + 35);
#line 1604
  *(out2 + 0) = tmpval___7 * *(w + 18);
#line 1604
  tmpval___7 = tmp[8] - tmp[9];
#line 1604
  *(ts + 0) = *(out1 + 0) + tmpval___7 * *(w + 0);
#line 1604
  *(ts + 544) = *(out1 + 17) + tmpval___7 * *(w + 17);
#line 1696
  return;
}
}
#line 1700 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static void dct12(float *in , float *rawout1 , float *rawout2 , float *wi , float *ts ) 
{ 
  float in0 ;
  float in1 ;
  float in2 ;
  float in3 ;
  float in4 ;
  float in5 ;
  register float *out1 ;
  float tmp0 ;
  float tmp1 ;
  float tmp2 ;
  float in0___0 ;
  float in1___0 ;
  float in2___0 ;
  float in3___0 ;
  float in4___0 ;
  float in5___0 ;
  register float *out2 ;
  float tmp0___0 ;
  float tmp1___0 ;
  float tmp2___0 ;
  float in0___1 ;
  float in1___1 ;
  float in2___1 ;
  float in3___1 ;
  float in4___1 ;
  float in5___1 ;
  register float *out2___0 ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp0___1 ;
  float tmp1___1 ;
  float tmp2___1 ;

  {
#line 1734
  out1 = rawout1;
#line 1735
  *(ts + 0) = *(out1 + 0);
#line 1735
  *(ts + 32) = *(out1 + 1);
#line 1735
  *(ts + 64) = *(out1 + 2);
#line 1736
  *(ts + 96) = *(out1 + 3);
#line 1736
  *(ts + 128) = *(out1 + 4);
#line 1736
  *(ts + 160) = *(out1 + 5);
#line 1738
  in5 = *(in + 15);
#line 1738
  in4 = *(in + 12);
#line 1738
  in5 += in4;
#line 1738
  in3 = *(in + 9);
#line 1738
  in4 += in3;
#line 1738
  in2 = *(in + 6);
#line 1738
  in3 += in2;
#line 1738
  in1 = *(in + 3);
#line 1738
  in2 += in1;
#line 1738
  in0 = *(in + 0);
#line 1738
  in1 += in0;
#line 1738
  in5 += in3;
#line 1738
  in3 += in1;
#line 1738
  in2 *= COS6_1;
#line 1738
  in3 *= COS6_1;
#line 1741
  tmp1 = in0 - in4;
#line 1743
  tmp2 = (in1 - in5) * tfcos12[1];
#line 1744
  tmp0 = tmp1 + tmp2;
#line 1745
  tmp1 -= tmp2;
#line 1747
  *(ts + 512) = *(out1 + 16) + tmp0 * *(wi + 10);
#line 1748
  *(ts + 416) = *(out1 + 13) + tmp0 * *(wi + 7);
#line 1749
  *(ts + 224) = *(out1 + 7) + tmp1 * *(wi + 1);
#line 1750
  *(ts + 320) = *(out1 + 10) + tmp1 * *(wi + 4);
#line 1753
  in0 += in4 * COS6_2;
#line 1753
  in4 = in0 + in2;
#line 1753
  in0 -= in2;
#line 1753
  in1 += in5 * COS6_2;
#line 1753
  in5 = (in1 + in3) * tfcos12[0];
#line 1753
  in1 = (in1 - in3) * tfcos12[2];
#line 1753
  in3 = in4 + in5;
#line 1753
  in4 -= in5;
#line 1753
  in2 = in0 + in1;
#line 1753
  in0 -= in1;
#line 1755
  *(ts + 544) = *(out1 + 17) + in2 * *(wi + 11);
#line 1756
  *(ts + 384) = *(out1 + 12) + in2 * *(wi + 6);
#line 1757
  *(ts + 448) = *(out1 + 14) + in3 * *(wi + 8);
#line 1758
  *(ts + 480) = *(out1 + 15) + in3 * *(wi + 9);
#line 1760
  *(ts + 192) = *(out1 + 6) + in0 * *(wi + 0);
#line 1761
  *(ts + 352) = *(out1 + 11) + in0 * *(wi + 5);
#line 1762
  *(ts + 256) = *(out1 + 8) + in4 * *(wi + 2);
#line 1763
  *(ts + 288) = *(out1 + 9) + in4 * *(wi + 3);
#line 1766
  in ++;
#line 1770
  out2 = rawout2;
#line 1772
  in5___0 = *(in + 15);
#line 1772
  in4___0 = *(in + 12);
#line 1772
  in5___0 += in4___0;
#line 1772
  in3___0 = *(in + 9);
#line 1772
  in4___0 += in3___0;
#line 1772
  in2___0 = *(in + 6);
#line 1772
  in3___0 += in2___0;
#line 1772
  in1___0 = *(in + 3);
#line 1772
  in2___0 += in1___0;
#line 1772
  in0___0 = *(in + 0);
#line 1772
  in1___0 += in0___0;
#line 1772
  in5___0 += in3___0;
#line 1772
  in3___0 += in1___0;
#line 1772
  in2___0 *= COS6_1;
#line 1772
  in3___0 *= COS6_1;
#line 1775
  tmp1___0 = in0___0 - in4___0;
#line 1777
  tmp2___0 = (in1___0 - in5___0) * tfcos12[1];
#line 1778
  tmp0___0 = tmp1___0 + tmp2___0;
#line 1779
  tmp1___0 -= tmp2___0;
#line 1781
  *(out2 + 4) = tmp0___0 * *(wi + 10);
#line 1782
  *(out2 + 1) = tmp0___0 * *(wi + 7);
#line 1783
  *(ts + 416) += tmp1___0 * *(wi + 1);
#line 1784
  *(ts + 512) += tmp1___0 * *(wi + 4);
#line 1787
  in0___0 += in4___0 * COS6_2;
#line 1787
  in4___0 = in0___0 + in2___0;
#line 1787
  in0___0 -= in2___0;
#line 1787
  in1___0 += in5___0 * COS6_2;
#line 1787
  in5___0 = (in1___0 + in3___0) * tfcos12[0];
#line 1787
  in1___0 = (in1___0 - in3___0) * tfcos12[2];
#line 1787
  in3___0 = in4___0 + in5___0;
#line 1787
  in4___0 -= in5___0;
#line 1787
  in2___0 = in0___0 + in1___0;
#line 1787
  in0___0 -= in1___0;
#line 1789
  *(out2 + 5) = in2___0 * *(wi + 11);
#line 1790
  *(out2 + 0) = in2___0 * *(wi + 6);
#line 1791
  *(out2 + 2) = in3___0 * *(wi + 8);
#line 1792
  *(out2 + 3) = in3___0 * *(wi + 9);
#line 1794
  *(ts + 384) += in0___0 * *(wi + 0);
#line 1795
  *(ts + 544) += in0___0 * *(wi + 5);
#line 1796
  *(ts + 448) += in4___0 * *(wi + 2);
#line 1797
  *(ts + 480) += in4___0 * *(wi + 3);
#line 1800
  in ++;
#line 1804
  out2___0 = rawout2;
#line 1805
  tmp___3 = (float )0.0;
#line 1805
  *(out2___0 + 17) = tmp___3;
#line 1805
  tmp___2 = tmp___3;
#line 1805
  *(out2___0 + 16) = tmp___2;
#line 1805
  tmp___1 = tmp___2;
#line 1805
  *(out2___0 + 15) = tmp___1;
#line 1805
  tmp___0 = tmp___1;
#line 1805
  *(out2___0 + 14) = tmp___0;
#line 1805
  tmp = tmp___0;
#line 1805
  *(out2___0 + 13) = tmp;
#line 1805
  *(out2___0 + 12) = tmp;
#line 1807
  in5___1 = *(in + 15);
#line 1807
  in4___1 = *(in + 12);
#line 1807
  in5___1 += in4___1;
#line 1807
  in3___1 = *(in + 9);
#line 1807
  in4___1 += in3___1;
#line 1807
  in2___1 = *(in + 6);
#line 1807
  in3___1 += in2___1;
#line 1807
  in1___1 = *(in + 3);
#line 1807
  in2___1 += in1___1;
#line 1807
  in0___1 = *(in + 0);
#line 1807
  in1___1 += in0___1;
#line 1807
  in5___1 += in3___1;
#line 1807
  in3___1 += in1___1;
#line 1807
  in2___1 *= COS6_1;
#line 1807
  in3___1 *= COS6_1;
#line 1810
  tmp1___1 = in0___1 - in4___1;
#line 1812
  tmp2___1 = (in1___1 - in5___1) * tfcos12[1];
#line 1813
  tmp0___1 = tmp1___1 + tmp2___1;
#line 1814
  tmp1___1 -= tmp2___1;
#line 1816
  *(out2___0 + 10) = tmp0___1 * *(wi + 10);
#line 1817
  *(out2___0 + 7) = tmp0___1 * *(wi + 7);
#line 1818
  *(out2___0 + 1) += tmp1___1 * *(wi + 1);
#line 1819
  *(out2___0 + 4) += tmp1___1 * *(wi + 4);
#line 1822
  in0___1 += in4___1 * COS6_2;
#line 1822
  in4___1 = in0___1 + in2___1;
#line 1822
  in0___1 -= in2___1;
#line 1822
  in1___1 += in5___1 * COS6_2;
#line 1822
  in5___1 = (in1___1 + in3___1) * tfcos12[0];
#line 1822
  in1___1 = (in1___1 - in3___1) * tfcos12[2];
#line 1822
  in3___1 = in4___1 + in5___1;
#line 1822
  in4___1 -= in5___1;
#line 1822
  in2___1 = in0___1 + in1___1;
#line 1822
  in0___1 -= in1___1;
#line 1824
  *(out2___0 + 11) = in2___1 * *(wi + 11);
#line 1825
  *(out2___0 + 6) = in2___1 * *(wi + 6);
#line 1826
  *(out2___0 + 8) = in3___1 * *(wi + 8);
#line 1827
  *(out2___0 + 9) = in3___1 * *(wi + 9);
#line 1829
  *(out2___0 + 0) += in0___1 * *(wi + 0);
#line 1830
  *(out2___0 + 5) += in0___1 * *(wi + 5);
#line 1831
  *(out2___0 + 2) += in4___1 * *(wi + 2);
#line 1832
  *(out2___0 + 3) += in4___1 * *(wi + 3);
#line 1834
  return;
}
}
#line 1837 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
static void III_hybrid(float (*fsIn)[18] , float (*tsOut)[32] , int ch , struct gr_info_s *gr_info ,
                       mpg123_handle *fr ) 
{ 
  float (*block___0)[2][576] ;
  int *blc ;
  float *tspnt ;
  float *rawout1 ;
  float *rawout2 ;
  int bt ;
  size_t sb ;
  int b ;
  int i ;
  float *tmp ;
  float *tmp___0 ;

  {
#line 1839
  block___0 = fr->hybrid_block;
#line 1840
  blc = fr->hybrid_blc;
#line 1842
  tspnt = (float *)tsOut;
#line 1844
  bt = 0;
#line 1845
  sb = (size_t )0;
#line 1848
  b = *(blc + ch);
#line 1849
  rawout1 = (*(block___0 + b))[ch];
#line 1850
  b = - b + 1;
#line 1851
  rawout2 = (*(block___0 + b))[ch];
#line 1852
  *(blc + ch) = b;
#line 1855
  if (gr_info->mixed_block_flag) {
    {
#line 1857
    sb = (size_t )2;
#line 1858
    (*(fr->cpu_opts.dct36))(*(fsIn + 0), rawout1, rawout2, win[0], tspnt);
#line 1859
    (*(fr->cpu_opts.dct36))(*(fsIn + 1), rawout1 + 18, rawout2 + 18, win1[0], tspnt + 1);
#line 1860
    rawout1 += 36;
#line 1860
    rawout2 += 36;
#line 1860
    tspnt += 2;
    }
  }
#line 1863
  bt = (int )gr_info->block_type;
#line 1864
  if (bt == 2) {
    {
#line 1866
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1866
      if (! (sb < gr_info->maxb)) {
#line 1866
        goto while_break;
      }
      {
#line 1868
      dct12(*(fsIn + sb), rawout1, rawout2, win[2], tspnt);
#line 1869
      dct12(*(fsIn + (sb + 1U)), rawout1 + 18, rawout2 + 18, win1[2], tspnt + 1);
#line 1866
      sb += 2U;
#line 1866
      tspnt += 2;
#line 1866
      rawout1 += 36;
#line 1866
      rawout2 += 36;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1874
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1874
      if (! (sb < gr_info->maxb)) {
#line 1874
        goto while_break___0;
      }
      {
#line 1876
      (*(fr->cpu_opts.dct36))(*(fsIn + sb), rawout1, rawout2, win[bt], tspnt);
#line 1877
      (*(fr->cpu_opts.dct36))(*(fsIn + (sb + 1U)), rawout1 + 18, rawout2 + 18, win1[bt],
                              tspnt + 1);
#line 1874
      sb += 2U;
#line 1874
      tspnt += 2;
#line 1874
      rawout1 += 36;
#line 1874
      rawout2 += 36;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1881
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1881
    if (! (sb < 32U)) {
#line 1881
      goto while_break___1;
    }
#line 1884
    i = 0;
    {
#line 1884
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1884
      if (! (i < 18)) {
#line 1884
        goto while_break___2;
      }
#line 1886
      tmp = rawout1;
#line 1886
      rawout1 ++;
#line 1886
      *(tspnt + i * 32) = *tmp;
#line 1887
      tmp___0 = rawout2;
#line 1887
      rawout2 ++;
#line 1887
      *tmp___0 = (float )0.0;
#line 1884
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1881
    sb ++;
#line 1881
    tspnt ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1890
  return;
}
}
#line 1894 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c"
int do_layer3(mpg123_handle *fr ) 
{ 
  int gr ;
  int ch ;
  int ss ;
  int clip ;
  int scalefacs[2][39] ;
  struct III_sideinfo sideinfo ;
  int stereo ;
  int single ;
  int ms_stereo ;
  int i_stereo ;
  int sfreq ;
  int stereo1 ;
  int granules ;
  int tmp ;
  float (*hybridIn)[32][18] ;
  float (*hybridOut)[18][32] ;
  struct gr_info_s *gr_info ;
  long part2bits ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct gr_info_s *gr_info___0 ;
  long part2bits___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int i ;
  unsigned int maxb ;
  float tmp0 ;
  float tmp1 ;
  register int i___0 ;
  register float *in0 ;
  register float *in1 ;
  float *tmp___6 ;
  register int i___1 ;
  register float *in0___0 ;
  register float *in1___0 ;
  float *tmp___7 ;
  float *tmp___8 ;
  struct gr_info_s *gr_info___1 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp44 ;
  int __cil_tmp45 ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
#line 1896
  clip = 0;
#line 1899
  stereo = fr->stereo;
#line 1900
  single = fr->single;
#line 1902
  sfreq = fr->sampling_frequency;
#line 1905
  if (stereo == 1) {
#line 1907
    stereo1 = 1;
#line 1908
    single = 0;
  } else
#line 1910
  if (single != -1) {
#line 1911
    stereo1 = 1;
  } else {
#line 1913
    stereo1 = 2;
  }
#line 1915
  if (fr->mode == 1) {
#line 1917
    ms_stereo = (fr->mode_ext & 2) >> 1;
#line 1918
    i_stereo = fr->mode_ext & 1;
  } else {
#line 1920
    i_stereo = 0;
#line 1920
    ms_stereo = i_stereo;
  }
#line 1922
  if (fr->lsf) {
#line 1922
    granules = 1;
  } else {
#line 1922
    granules = 2;
  }
  {
#line 1926
  tmp = III_get_side_info(fr, & sideinfo, stereo, ms_stereo, (long )sfreq, single);
  }
#line 1926
  if (tmp) {
#line 1928
    if (! (fr->p.flags & 32L)) {
      {
#line 1928
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c:%i] error: bad frame - unable to get valid sideinfo\n",
              1928);
      }
    }
#line 1929
    return (clip);
  }
  {
#line 1932
  set_pointer(fr, (long )sideinfo.main_data_begin);
#line 1934
  gr = 0;
  }
  {
#line 1934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1934
    if (! (gr < granules)) {
#line 1934
      goto while_break;
    }
#line 1937
    hybridIn = fr->layer3.hybrid_in;
#line 1939
    hybridOut = fr->layer3.hybrid_out;
#line 1942
    gr_info = & sideinfo.ch[0].gr[gr];
#line 1944
    if (fr->lsf) {
      {
#line 1945
      tmp___0 = III_get_scale_factors_2(fr, scalefacs[0], gr_info, 0);
#line 1945
      part2bits = (long )tmp___0;
      }
    } else {
      {
#line 1947
      tmp___1 = III_get_scale_factors_1(fr, scalefacs[0], gr_info, 0, gr);
#line 1947
      part2bits = (long )tmp___1;
      }
    }
    {
#line 1949
    tmp___2 = III_dequantize_sample(fr, (float (*)[18])(*(hybridIn + 0)), scalefacs[0],
                                    gr_info, sfreq, (int )part2bits);
    }
#line 1949
    if (tmp___2) {
#line 1951
      if (! (fr->p.flags & 32L)) {
#line 1951
        if (fr->p.verbose > 1) {
          {
#line 1951
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c:%i] error: dequantization failed!\n",
                  1951);
          }
        }
      }
#line 1952
      return (clip);
    }
#line 1956
    if (stereo == 2) {
#line 1958
      gr_info___0 = & sideinfo.ch[1].gr[gr];
#line 1960
      if (fr->lsf) {
        {
#line 1961
        tmp___3 = III_get_scale_factors_2(fr, scalefacs[1], gr_info___0, i_stereo);
#line 1961
        part2bits___0 = (long )tmp___3;
        }
      } else {
        {
#line 1963
        tmp___4 = III_get_scale_factors_1(fr, scalefacs[1], gr_info___0, 1, gr);
#line 1963
        part2bits___0 = (long )tmp___4;
        }
      }
      {
#line 1965
      tmp___5 = III_dequantize_sample(fr, (float (*)[18])(*(hybridIn + 1)), scalefacs[1],
                                      gr_info___0, sfreq, (int )part2bits___0);
      }
#line 1965
      if (tmp___5) {
#line 1967
        if (! (fr->p.flags & 32L)) {
#line 1967
          if (fr->p.verbose > 1) {
            {
#line 1967
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer3.c:%i] error: dequantization failed!\n",
                    1967);
            }
          }
        }
#line 1968
        return (clip);
      }
#line 1971
      if (ms_stereo) {
#line 1974
        maxb = sideinfo.ch[0].gr[gr].maxb;
#line 1975
        if (sideinfo.ch[1].gr[gr].maxb > maxb) {
#line 1975
          maxb = sideinfo.ch[1].gr[gr].maxb;
        }
#line 1977
        i = 0;
        {
#line 1977
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1977
          if (! (i < 18 * (int )maxb)) {
#line 1977
            goto while_break___0;
          }
#line 1979
          tmp0 = *((float *)(*(hybridIn + 0)) + i);
#line 1980
          tmp1 = *((float *)(*(hybridIn + 1)) + i);
#line 1981
          *((float *)(*(hybridIn + 0)) + i) = tmp0 + tmp1;
#line 1982
          *((float *)(*(hybridIn + 1)) + i) = tmp0 - tmp1;
#line 1977
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1986
      if (i_stereo) {
        {
#line 1986
        III_i_stereo((float (*)[32][18])hybridIn, scalefacs[1], gr_info___0, sfreq,
                     ms_stereo, fr->lsf);
        }
      }
#line 1988
      if (ms_stereo) {
#line 1988
        goto _L;
      } else
#line 1988
      if (i_stereo) {
#line 1988
        goto _L;
      } else
#line 1988
      if (single == 3) {
        _L: /* CIL Label */ 
#line 1990
        if (gr_info___0->maxb > sideinfo.ch[0].gr[gr].maxb) {
#line 1991
          sideinfo.ch[0].gr[gr].maxb = gr_info___0->maxb;
        } else {
#line 1993
          gr_info___0->maxb = sideinfo.ch[0].gr[gr].maxb;
        }
      }
      {
#line 1998
      if (single == 3) {
#line 1998
        goto case_3;
      }
#line 2006
      if (single == 1) {
#line 2006
        goto case_1;
      }
#line 1996
      goto switch_break;
      case_3: /* CIL Label */ 
#line 2001
      in0 = (float *)(*(hybridIn + 0));
#line 2001
      in1 = (float *)(*(hybridIn + 1));
#line 2002
      i___0 = 0;
      {
#line 2002
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2002
        if (! (i___0 < 18 * (int )gr_info___0->maxb)) {
#line 2002
          goto while_break___1;
        }
#line 2003
        tmp___6 = in1;
#line 2003
        in1 ++;
#line 2003
        *in0 += *tmp___6;
#line 2002
        i___0 ++;
#line 2002
        in0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2005
      goto switch_break;
      case_1: /* CIL Label */ 
#line 2009
      in0___0 = (float *)(*(hybridIn + 0));
#line 2009
      in1___0 = (float *)(*(hybridIn + 1));
#line 2010
      i___1 = 0;
      {
#line 2010
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2010
        if (! (i___1 < 18 * (int )gr_info___0->maxb)) {
#line 2010
          goto while_break___2;
        }
#line 2011
        tmp___7 = in0___0;
#line 2011
        in0___0 ++;
#line 2011
        tmp___8 = in1___0;
#line 2011
        in1___0 ++;
#line 2011
        *tmp___7 = *tmp___8;
#line 2010
        i___1 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2013
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2017
    ch = 0;
    {
#line 2017
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2017
      if (! (ch < stereo1)) {
#line 2017
        goto while_break___3;
      }
      {
#line 2019
      gr_info___1 = & sideinfo.ch[ch].gr[gr];
#line 2020
      III_antialias((float (*)[18])(*(hybridIn + ch)), gr_info___1);
#line 2021
      III_hybrid((float (*)[18])(*(hybridIn + ch)), (float (*)[32])(*(hybridOut + ch)),
                 ch, gr_info___1, fr);
#line 2017
      ch ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2028
    ss = 0;
    {
#line 2028
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2028
      if (! (ss < 18)) {
#line 2028
        goto while_break___4;
      }
#line 2030
      if (single != -1) {
        {
#line 2031
        tmp___9 = (*(fr->synth_mono))((*(hybridOut + 0))[ss], fr);
#line 2031
        clip += tmp___9;
        }
      } else {
        {
#line 2033
        tmp___10 = (*(fr->synth_stereo))((*(hybridOut + 0))[ss], (*(hybridOut + 1))[ss],
                                         fr);
#line 2033
        clip += tmp___10;
        }
      }
#line 2028
      ss ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1934
    gr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2057
  return (clip);
}
}
#line 221 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
void init_layer12(void) ;
#line 222
float *init_layer12_table(mpg123_handle *fr , float *table , int m ) ;
#line 223
void init_layer12_stuff(mpg123_handle *fr , float *(*init_table)(mpg123_handle *fr ,
                                                                 float *table , int m ) ) ;
#line 241
float *init_layer12_table_mmx(mpg123_handle *fr , float *table , int m ) ;
#line 258
int do_layer2(mpg123_handle *fr ) ;
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/l2tables.h"
struct al_table  const  alloc_0[288]  = 
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/l2tables.h"
  {      {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)3, (short)-3}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)3, (short)-3}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)3, (short)-3}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}};
#line 56 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/l2tables.h"
struct al_table  const  alloc_1[300]  = 
#line 56
  {      {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)3, (short)-3}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)3, (short)-3}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)3, (short)-3}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)16, (short)-32767}};
#line 99 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/l2tables.h"
struct al_table  const  alloc_2[80]  = 
#line 99
  {      {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}};
#line 111 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/l2tables.h"
struct al_table  const  alloc_3[112]  = 
#line 111
  {      {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)15, (short)-16383}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}};
#line 127 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/l2tables.h"
struct al_table  const  alloc_4[196]  = 
#line 127
  {      {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)4, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)3, (short)-3}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)8, (short)-127}, 
        {(short)9, (short)-255}, 
        {(short)10, (short)-511}, 
        {(short)11, (short)-1023}, 
        {(short)12, (short)-2047}, 
        {(short)13, (short)-4095}, 
        {(short)14, (short)-8191}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)3, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)4, (short)-7}, 
        {(short)5, (short)-15}, 
        {(short)6, (short)-31}, 
        {(short)7, (short)-63}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}, 
        {(short)2, (short)0}, 
        {(short)5, (short)3}, 
        {(short)7, (short)5}, 
        {(short)10, (short)9}};
#line 40 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/getbits.h"
static unsigned int getbits___0(mpg123_handle *fr , int number_of_bits ) 
{ 
  unsigned long rval ;

  {
#line 56
  rval = (unsigned long )*(fr->wordpointer + 0);
#line 57
  rval <<= 8;
#line 58
  rval |= (unsigned long )*(fr->wordpointer + 1);
#line 59
  rval <<= 8;
#line 60
  rval |= (unsigned long )*(fr->wordpointer + 2);
#line 62
  rval <<= fr->bitindex;
#line 63
  rval &= 16777215UL;
#line 65
  fr->bitindex += number_of_bits;
#line 67
  rval >>= 24 - number_of_bits;
#line 69
  fr->wordpointer += fr->bitindex >> 3;
#line 70
  fr->bitindex &= 7;
#line 77
  return ((unsigned int )rval);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
static int grp_3tab[96]  = {      0};
#line 22 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
static int grp_5tab[384]  = {      0};
#line 23 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
static int grp_9tab[3072]  = {      0};
#line 28 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
static double const   mulmul[27]  = 
#line 28
  {      (double const   )0.0,      (double const   )(- 2.0 / 3.0),      (double const   )(2.0 / 3.0),      (double const   )(2.0 / 7.0), 
        (double const   )(2.0 / 15.0),      (double const   )(2.0 / 31.0),      (double const   )(2.0 / 63.0),      (double const   )(2.0 / 127.0), 
        (double const   )(2.0 / 255.0),      (double const   )(2.0 / 511.0),      (double const   )(2.0 / 1023.0),      (double const   )(2.0 / 2047.0), 
        (double const   )(2.0 / 4095.0),      (double const   )(2.0 / 8191.0),      (double const   )(2.0 / 16383.0),      (double const   )(2.0 / 32767.0), 
        (double const   )(2.0 / 65535.0),      (double const   )(- 4.0 / 5.0),      (double const   )(- 2.0 / 5.0),      (double const   )(2.0 / 5.0), 
        (double const   )(4.0 / 5.0),      (double const   )(- 8.0 / 9.0),      (double const   )(- 4.0 / 9.0),      (double const   )(- 2.0 / 9.0), 
        (double const   )(2.0 / 9.0),      (double const   )(4.0 / 9.0),      (double const   )(8.0 / 9.0)};
#line 39 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
void init_layer12(void) 
{ 
  int base[3][9] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int i ;
  int j ;
  int k ;
  int l___0 ;
  int len ;
  int tablen[3] ;
  int *itable ;
  int *tables[3] ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
#line 41
  base[0][0] = 1;
#line 41
  base[0][1] = 0;
#line 41
  base[0][2] = 2;
#line 41
  tmp = 3U;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (tmp >= 9U) {
#line 41
      goto while_break;
    }
#line 41
    base[0][tmp] = 0;
#line 41
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  base[1][0] = 17;
#line 41
  base[1][1] = 18;
#line 41
  base[1][2] = 0;
#line 41
  base[1][3] = 19;
#line 41
  base[1][4] = 20;
#line 41
  tmp___0 = 5U;
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 41
    if (tmp___0 >= 9U) {
#line 41
      goto while_break___0;
    }
#line 41
    base[1][tmp___0] = 0;
#line 41
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 41
  base[2][0] = 21;
#line 41
  base[2][1] = 1;
#line 41
  base[2][2] = 22;
#line 41
  base[2][3] = 23;
#line 41
  base[2][4] = 0;
#line 41
  base[2][5] = 24;
#line 41
  base[2][6] = 25;
#line 41
  base[2][7] = 2;
#line 41
  base[2][8] = 26;
#line 48
  tablen[0] = 3;
#line 48
  tablen[1] = 5;
#line 48
  tablen[2] = 9;
#line 50
  tables[0] = grp_3tab;
#line 50
  tables[1] = grp_5tab;
#line 50
  tables[2] = grp_9tab;
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 52
    if (! (i < 3)) {
#line 52
      goto while_break___1;
    }
#line 54
    itable = tables[i];
#line 55
    len = tablen[i];
#line 56
    j = 0;
    {
#line 56
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 56
      if (! (j < len)) {
#line 56
        goto while_break___2;
      }
#line 57
      k = 0;
      {
#line 57
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 57
        if (! (k < len)) {
#line 57
          goto while_break___3;
        }
#line 58
        l___0 = 0;
        {
#line 58
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 58
          if (! (l___0 < len)) {
#line 58
            goto while_break___4;
          }
#line 60
          tmp___1 = itable;
#line 60
          itable ++;
#line 60
          *tmp___1 = base[i][l___0];
#line 61
          tmp___2 = itable;
#line 61
          itable ++;
#line 61
          *tmp___2 = base[i][k];
#line 62
          tmp___3 = itable;
#line 62
          itable ++;
#line 62
          *tmp___3 = base[i][j];
#line 58
          l___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 57
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 56
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 52
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
void init_layer12_stuff(mpg123_handle *fr , float *(*init_table)(mpg123_handle *fr ,
                                                                 float *table , int m ) ) 
{ 
  int k ;
  float *table ;
  float *tmp ;

  {
#line 71
  k = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (k < 27)) {
#line 71
      goto while_break;
    }
    {
#line 73
    table = (*init_table)(fr, fr->muls[k], k);
#line 74
    tmp = table;
#line 74
    table ++;
#line 74
    *tmp = (float )0.0;
#line 71
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return;
}
}
#line 78 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
float *init_layer12_table(mpg123_handle *fr , float *table , int m ) 
{ 
  int i ;
  int j ;
  float *tmp ;
  double tmp___0 ;

  {
#line 86
  j = 3;
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < 63)) {
#line 86
      goto while_break;
    }
    {
#line 87
    tmp = table;
#line 87
    table ++;
#line 87
    tmp___0 = pow(2.0, (double )j / 3.0);
#line 87
    *tmp = (float )(mulmul[m] * (double const   )tmp___0);
#line 86
    i ++;
#line 86
    j --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (table);
}
}
#line 94 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
float *init_layer12_table_mmx(mpg123_handle *fr , float *table , int m ) 
{ 
  int i ;
  int j ;
  float *tmp ;
  double tmp___0 ;
  float *tmp___1 ;
  double tmp___2 ;

  {
#line 97
  if (! fr->p.down_sample) {
#line 99
    j = 3;
#line 99
    i = 0;
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;
#line 99
      if (! (i < 63)) {
#line 99
        goto while_break;
      }
      {
#line 100
      tmp = table;
#line 100
      table ++;
#line 100
      tmp___0 = pow(2.0, (double )j / 3.0);
#line 100
      *tmp = (float )(((double const   )16384 * mulmul[m]) * (double const   )tmp___0);
#line 99
      i ++;
#line 99
      j --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 104
    j = 3;
#line 104
    i = 0;
    {
#line 104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 104
      if (! (i < 63)) {
#line 104
        goto while_break___0;
      }
      {
#line 105
      tmp___1 = table;
#line 105
      table ++;
#line 105
      tmp___2 = pow(2.0, (double )j / 3.0);
#line 105
      *tmp___1 = (float )(mulmul[m] * (double const   )tmp___2);
#line 104
      i ++;
#line 104
      j --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 107
  return (table);
}
}
#line 117 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
void II_step_one(unsigned int *bit_alloc , int *scale , mpg123_handle *fr ) 
{ 
  int stereo ;
  int sblimit ;
  int jsbound ;
  int sblimit2 ;
  struct al_table  const  *alloc1 ;
  int i ;
  unsigned int scfsi_buf[64] ;
  unsigned int *scfsi ;
  unsigned int *bita ;
  int sc ;
  int step___30 ;
  unsigned int *tmp ;
  unsigned int tmp___0 ;
  unsigned int *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int *tmp___4 ;
  unsigned int *tmp___5 ;
  unsigned int *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int *tmp___8 ;
  unsigned int *tmp___9 ;
  unsigned int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  unsigned int *tmp___23 ;
  void *__cil_tmp40 ;

  {
#line 119
  stereo = fr->stereo - 1;
#line 120
  sblimit = fr->II_sblimit;
#line 121
  jsbound = fr->jsbound;
#line 122
  sblimit2 = fr->II_sblimit << stereo;
#line 123
  alloc1 = fr->alloc;
#line 129
  bita = bit_alloc;
#line 130
  if (stereo) {
#line 132
    i = jsbound;
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (! i) {
#line 132
        goto while_break;
      }
      {
#line 134
      step___30 = (int )alloc1->bits;
#line 135
      tmp = bita;
#line 135
      bita ++;
#line 135
      tmp___0 = getbits___0(fr, step___30);
#line 135
      *tmp = (unsigned int )((char )tmp___0);
#line 136
      tmp___1 = bita;
#line 136
      bita ++;
#line 136
      tmp___2 = getbits___0(fr, step___30);
#line 136
      *tmp___1 = (unsigned int )((char )tmp___2);
#line 132
      i --;
#line 132
      alloc1 += 1 << step___30;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 138
    i = sblimit - jsbound;
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 138
      if (! i) {
#line 138
        goto while_break___0;
      }
      {
#line 140
      step___30 = (int )alloc1->bits;
#line 141
      tmp___3 = getbits___0(fr, step___30);
#line 141
      *(bita + 0) = (unsigned int )((char )tmp___3);
#line 142
      *(bita + 1) = *(bita + 0);
#line 143
      bita += 2;
#line 138
      i --;
#line 138
      alloc1 += 1 << step___30;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 145
    bita = bit_alloc;
#line 146
    scfsi = scfsi_buf;
#line 148
    i = sblimit2;
    {
#line 148
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 148
      if (! i) {
#line 148
        goto while_break___1;
      }
#line 149
      tmp___5 = bita;
#line 149
      bita ++;
#line 149
      if (*tmp___5) {
#line 149
        tmp___4 = scfsi;
#line 149
        scfsi ++;
#line 149
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 149
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 149
        fr->ultmp <<= 2;
#line 149
        fr->ultmp >>= 8;
#line 149
        fr->bitindex += 2;
#line 149
        fr->wordpointer += fr->bitindex >> 3;
#line 149
        fr->bitindex &= 7;
#line 149
        *tmp___4 = (unsigned int )((char )fr->ultmp);
      }
#line 148
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 153
    i = sblimit;
    {
#line 153
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 153
      if (! i) {
#line 153
        goto while_break___2;
      }
      {
#line 155
      step___30 = (int )alloc1->bits;
#line 156
      tmp___6 = bita;
#line 156
      bita ++;
#line 156
      tmp___7 = getbits___0(fr, step___30);
#line 156
      *tmp___6 = (unsigned int )((char )tmp___7);
#line 153
      i --;
#line 153
      alloc1 += 1 << step___30;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 158
    bita = bit_alloc;
#line 159
    scfsi = scfsi_buf;
#line 160
    i = sblimit;
    {
#line 160
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 160
      if (! i) {
#line 160
        goto while_break___3;
      }
#line 161
      tmp___9 = bita;
#line 161
      bita ++;
#line 161
      if (*tmp___9) {
#line 161
        tmp___8 = scfsi;
#line 161
        scfsi ++;
#line 161
        fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 161
        fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 161
        fr->ultmp <<= 2;
#line 161
        fr->ultmp >>= 8;
#line 161
        fr->bitindex += 2;
#line 161
        fr->wordpointer += fr->bitindex >> 3;
#line 161
        fr->bitindex &= 7;
#line 161
        *tmp___8 = (unsigned int )((char )fr->ultmp);
      }
#line 160
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 164
  bita = bit_alloc;
#line 165
  scfsi = scfsi_buf;
#line 166
  i = sblimit2;
  {
#line 166
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 166
    if (! i) {
#line 166
      goto while_break___4;
    }
#line 167
    tmp___23 = bita;
#line 167
    bita ++;
#line 167
    if (*tmp___23) {
#line 168
      tmp___10 = scfsi;
#line 168
      scfsi ++;
      {
#line 170
      if (*tmp___10 == 0U) {
#line 170
        goto case_0;
      }
#line 175
      if (*tmp___10 == 1U) {
#line 175
        goto case_1;
      }
#line 180
      if (*tmp___10 == 2U) {
#line 180
        goto case_2;
      }
#line 185
      goto switch_default;
      case_0: /* CIL Label */ 
#line 171
      tmp___11 = scale;
#line 171
      scale ++;
#line 171
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 171
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 171
      fr->ultmp <<= 6;
#line 171
      fr->ultmp >>= 8;
#line 171
      fr->bitindex += 6;
#line 171
      fr->wordpointer += fr->bitindex >> 3;
#line 171
      fr->bitindex &= 7;
#line 171
      *tmp___11 = (int )fr->ultmp;
#line 172
      tmp___12 = scale;
#line 172
      scale ++;
#line 172
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 172
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 172
      fr->ultmp <<= 6;
#line 172
      fr->ultmp >>= 8;
#line 172
      fr->bitindex += 6;
#line 172
      fr->wordpointer += fr->bitindex >> 3;
#line 172
      fr->bitindex &= 7;
#line 172
      *tmp___12 = (int )fr->ultmp;
#line 173
      tmp___13 = scale;
#line 173
      scale ++;
#line 173
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 173
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 173
      fr->ultmp <<= 6;
#line 173
      fr->ultmp >>= 8;
#line 173
      fr->bitindex += 6;
#line 173
      fr->wordpointer += fr->bitindex >> 3;
#line 173
      fr->bitindex &= 7;
#line 173
      *tmp___13 = (int )fr->ultmp;
#line 174
      goto switch_break;
      case_1: /* CIL Label */ 
#line 176
      tmp___14 = scale;
#line 176
      scale ++;
#line 176
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 176
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 176
      fr->ultmp <<= 6;
#line 176
      fr->ultmp >>= 8;
#line 176
      fr->bitindex += 6;
#line 176
      fr->wordpointer += fr->bitindex >> 3;
#line 176
      fr->bitindex &= 7;
#line 176
      sc = (int )fr->ultmp;
#line 176
      *tmp___14 = sc;
#line 177
      tmp___15 = scale;
#line 177
      scale ++;
#line 177
      *tmp___15 = sc;
#line 178
      tmp___16 = scale;
#line 178
      scale ++;
#line 178
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 178
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 178
      fr->ultmp <<= 6;
#line 178
      fr->ultmp >>= 8;
#line 178
      fr->bitindex += 6;
#line 178
      fr->wordpointer += fr->bitindex >> 3;
#line 178
      fr->bitindex &= 7;
#line 178
      *tmp___16 = (int )fr->ultmp;
#line 179
      goto switch_break;
      case_2: /* CIL Label */ 
#line 181
      tmp___17 = scale;
#line 181
      scale ++;
#line 181
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 181
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 181
      fr->ultmp <<= 6;
#line 181
      fr->ultmp >>= 8;
#line 181
      fr->bitindex += 6;
#line 181
      fr->wordpointer += fr->bitindex >> 3;
#line 181
      fr->bitindex &= 7;
#line 181
      sc = (int )fr->ultmp;
#line 181
      *tmp___17 = sc;
#line 182
      tmp___18 = scale;
#line 182
      scale ++;
#line 182
      *tmp___18 = sc;
#line 183
      tmp___19 = scale;
#line 183
      scale ++;
#line 183
      *tmp___19 = sc;
#line 184
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 186
      tmp___20 = scale;
#line 186
      scale ++;
#line 186
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 186
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 186
      fr->ultmp <<= 6;
#line 186
      fr->ultmp >>= 8;
#line 186
      fr->bitindex += 6;
#line 186
      fr->wordpointer += fr->bitindex >> 3;
#line 186
      fr->bitindex &= 7;
#line 186
      *tmp___20 = (int )fr->ultmp;
#line 187
      tmp___21 = scale;
#line 187
      scale ++;
#line 187
      fr->ultmp = (unsigned long )((unsigned char )((int )*(fr->wordpointer + 0) << fr->bitindex));
#line 187
      fr->ultmp |= ((unsigned long )*(fr->wordpointer + 1) << fr->bitindex) >> 8;
#line 187
      fr->ultmp <<= 6;
#line 187
      fr->ultmp >>= 8;
#line 187
      fr->bitindex += 6;
#line 187
      fr->wordpointer += fr->bitindex >> 3;
#line 187
      fr->bitindex &= 7;
#line 187
      sc = (int )fr->ultmp;
#line 187
      *tmp___21 = sc;
#line 188
      tmp___22 = scale;
#line 188
      scale ++;
#line 188
      *tmp___22 = sc;
#line 189
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 166
    i --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 194 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
void II_step_two(unsigned int *bit_alloc , float (*fraction)[4][32] , int *scale ,
                 mpg123_handle *fr , int x1 ) 
{ 
  int i ;
  int j ;
  int k ;
  int ba ;
  int stereo ;
  int sblimit ;
  int jsbound ;
  struct al_table  const  *alloc2 ;
  struct al_table  const  *alloc1 ;
  unsigned int *bita ;
  int d1 ;
  int step___30 ;
  float cm ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int const   *table[10] ;
  unsigned int idx ;
  unsigned int *tab ;
  unsigned int m ;
  unsigned int tmp___2 ;
  unsigned int *tmp___3 ;
  unsigned int *tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  unsigned int *tmp___7 ;
  float cm___0 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  int const   *table___0[10] ;
  unsigned int idx___0 ;
  unsigned int *tab___0 ;
  unsigned int m1 ;
  unsigned int m2 ;
  unsigned int tmp___11 ;
  unsigned int *tmp___12 ;
  unsigned int *tmp___13 ;
  float tmp___14 ;
  float tmp___15 ;
  float tmp___16 ;
  float tmp___17 ;
  float tmp___18 ;
  unsigned int *tmp___19 ;
  float tmp___20 ;
  float tmp___21 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;

  {
#line 197
  stereo = fr->stereo;
#line 198
  sblimit = fr->II_sblimit;
#line 199
  jsbound = fr->jsbound;
#line 200
  alloc1 = fr->alloc;
#line 201
  bita = bit_alloc;
#line 204
  i = 0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (i < jsbound)) {
#line 204
      goto while_break;
    }
#line 206
    step___30 = (int )alloc1->bits;
#line 207
    j = 0;
    {
#line 207
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 207
      if (! (j < stereo)) {
#line 207
        goto while_break___0;
      }
#line 209
      tmp___7 = bita;
#line 209
      bita ++;
#line 209
      ba = (int )*tmp___7;
#line 209
      if (ba) {
#line 211
        alloc2 = alloc1 + ba;
#line 211
        k = (int )alloc2->bits;
#line 212
        d1 = (int )alloc2->d;
#line 212
        if (d1 < 0) {
          {
#line 214
          cm = fr->muls[k][*(scale + x1)];
#line 215
          tmp = getbits___0(fr, k);
#line 215
          (*(fraction + j))[0][i] = (float )((int )tmp + d1) * cm;
#line 216
          tmp___0 = getbits___0(fr, k);
#line 216
          (*(fraction + j))[1][i] = (float )((int )tmp___0 + d1) * cm;
#line 217
          tmp___1 = getbits___0(fr, k);
#line 217
          (*(fraction + j))[2][i] = (float )((int )tmp___1 + d1) * cm;
          }
        } else {
          {
#line 221
          table[0] = (int const   *)0;
#line 221
          table[1] = (int const   *)0;
#line 221
          table[2] = (int const   *)0;
#line 221
          table[3] = (int const   *)(grp_3tab);
#line 221
          table[4] = (int const   *)0;
#line 221
          table[5] = (int const   *)(grp_5tab);
#line 221
          table[6] = (int const   *)0;
#line 221
          table[7] = (int const   *)0;
#line 221
          table[8] = (int const   *)0;
#line 221
          table[9] = (int const   *)(grp_9tab);
#line 222
          m = (unsigned int )*(scale + x1);
#line 223
          tmp___2 = getbits___0(fr, k);
#line 223
          idx = tmp___2;
#line 224
          tab = (unsigned int *)(((table[d1] + idx) + idx) + idx);
#line 225
          tmp___3 = tab;
#line 225
          tab ++;
#line 225
          (*(fraction + j))[0][i] = fr->muls[*tmp___3][m];
#line 226
          tmp___4 = tab;
#line 226
          tab ++;
#line 226
          (*(fraction + j))[1][i] = fr->muls[*tmp___4][m];
#line 227
          (*(fraction + j))[2][i] = fr->muls[*tab][m];
          }
        }
#line 229
        scale += 3;
      } else {
#line 232
        tmp___6 = (float )0.0;
#line 232
        (*(fraction + j))[2][i] = tmp___6;
#line 232
        tmp___5 = tmp___6;
#line 232
        (*(fraction + j))[1][i] = tmp___5;
#line 232
        (*(fraction + j))[0][i] = tmp___5;
      }
#line 207
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 204
    i ++;
#line 204
    alloc1 += 1 << step___30;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  i = jsbound;
  {
#line 236
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 236
    if (! (i < sblimit)) {
#line 236
      goto while_break___1;
    }
#line 238
    step___30 = (int )alloc1->bits;
#line 239
    bita ++;
#line 240
    tmp___19 = bita;
#line 240
    bita ++;
#line 240
    ba = (int )*tmp___19;
#line 240
    if (ba) {
#line 242
      alloc2 = alloc1 + ba;
#line 242
      k = (int )alloc2->bits;
#line 243
      d1 = (int )alloc2->d;
#line 243
      if (d1 < 0) {
        {
#line 246
        cm___0 = fr->muls[k][*(scale + (x1 + 3))];
#line 247
        tmp___8 = getbits___0(fr, k);
#line 247
        (*(fraction + 0))[0][i] = (float )((int )tmp___8 + d1);
#line 248
        tmp___9 = getbits___0(fr, k);
#line 248
        (*(fraction + 0))[1][i] = (float )((int )tmp___9 + d1);
#line 249
        tmp___10 = getbits___0(fr, k);
#line 249
        (*(fraction + 0))[2][i] = (float )((int )tmp___10 + d1);
#line 250
        (*(fraction + 1))[0][i] = (*(fraction + 0))[0][i] * cm___0;
#line 251
        (*(fraction + 1))[1][i] = (*(fraction + 0))[1][i] * cm___0;
#line 252
        (*(fraction + 1))[2][i] = (*(fraction + 0))[2][i] * cm___0;
#line 253
        cm___0 = fr->muls[k][*(scale + x1)];
#line 254
        (*(fraction + 0))[0][i] *= cm___0;
#line 255
        (*(fraction + 0))[1][i] *= cm___0;
#line 256
        (*(fraction + 0))[2][i] *= cm___0;
        }
      } else {
        {
#line 260
        table___0[0] = (int const   *)0;
#line 260
        table___0[1] = (int const   *)0;
#line 260
        table___0[2] = (int const   *)0;
#line 260
        table___0[3] = (int const   *)(grp_3tab);
#line 260
        table___0[4] = (int const   *)0;
#line 260
        table___0[5] = (int const   *)(grp_5tab);
#line 260
        table___0[6] = (int const   *)0;
#line 260
        table___0[7] = (int const   *)0;
#line 260
        table___0[8] = (int const   *)0;
#line 260
        table___0[9] = (int const   *)(grp_9tab);
#line 262
        m1 = (unsigned int )*(scale + x1);
#line 262
        m2 = (unsigned int )*(scale + (x1 + 3));
#line 263
        tmp___11 = getbits___0(fr, k);
#line 263
        idx___0 = tmp___11;
#line 264
        tab___0 = (unsigned int *)(((table___0[d1] + idx___0) + idx___0) + idx___0);
#line 265
        (*(fraction + 0))[0][i] = fr->muls[*tab___0][m1];
#line 265
        tmp___12 = tab___0;
#line 265
        tab___0 ++;
#line 265
        (*(fraction + 1))[0][i] = fr->muls[*tmp___12][m2];
#line 266
        (*(fraction + 0))[1][i] = fr->muls[*tab___0][m1];
#line 266
        tmp___13 = tab___0;
#line 266
        tab___0 ++;
#line 266
        (*(fraction + 1))[1][i] = fr->muls[*tmp___13][m2];
#line 267
        (*(fraction + 0))[2][i] = fr->muls[*tab___0][m1];
#line 267
        (*(fraction + 1))[2][i] = fr->muls[*tab___0][m2];
        }
      }
#line 269
      scale += 6;
    } else {
#line 273
      tmp___18 = (float )0.0;
#line 273
      (*(fraction + 1))[2][i] = tmp___18;
#line 273
      tmp___17 = tmp___18;
#line 273
      (*(fraction + 1))[1][i] = tmp___17;
#line 273
      tmp___16 = tmp___17;
#line 273
      (*(fraction + 1))[0][i] = tmp___16;
#line 273
      tmp___15 = tmp___16;
#line 273
      (*(fraction + 0))[2][i] = tmp___15;
#line 273
      tmp___14 = tmp___15;
#line 273
      (*(fraction + 0))[1][i] = tmp___14;
#line 273
      (*(fraction + 0))[0][i] = tmp___14;
    }
#line 236
    i ++;
#line 236
    alloc1 += 1 << step___30;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 287
  if (sblimit > fr->down_sample_sblimit) {
#line 288
    sblimit = fr->down_sample_sblimit;
  }
#line 290
  i = sblimit;
  {
#line 290
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 290
    if (! (i < 32)) {
#line 290
      goto while_break___2;
    }
#line 291
    j = 0;
    {
#line 291
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 291
      if (! (j < stereo)) {
#line 291
        goto while_break___3;
      }
#line 292
      tmp___21 = (float )0.0;
#line 292
      (*(fraction + j))[2][i] = tmp___21;
#line 292
      tmp___20 = tmp___21;
#line 292
      (*(fraction + j))[1][i] = tmp___20;
#line 292
      (*(fraction + j))[0][i] = tmp___20;
#line 291
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 290
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 293
  return;
}
}
#line 296 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
static void II_select_table(mpg123_handle *fr ) 
{ 
  int translate[3][2][16] ;
  int table ;
  int sblim ;
  struct al_table  const  *tables[5] ;
  int sblims[5] ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 298
  translate[0][0][0] = 0;
#line 298
  translate[0][0][1] = 2;
#line 298
  translate[0][0][2] = 2;
#line 298
  translate[0][0][3] = 2;
#line 298
  translate[0][0][4] = 2;
#line 298
  translate[0][0][5] = 2;
#line 298
  translate[0][0][6] = 2;
#line 298
  translate[0][0][7] = 0;
#line 298
  translate[0][0][8] = 0;
#line 298
  translate[0][0][9] = 0;
#line 298
  translate[0][0][10] = 1;
#line 298
  translate[0][0][11] = 1;
#line 298
  translate[0][0][12] = 1;
#line 298
  translate[0][0][13] = 1;
#line 298
  translate[0][0][14] = 1;
#line 298
  translate[0][0][15] = 0;
#line 298
  translate[0][1][0] = 0;
#line 298
  translate[0][1][1] = 2;
#line 298
  translate[0][1][2] = 2;
#line 298
  translate[0][1][3] = 0;
#line 298
  translate[0][1][4] = 0;
#line 298
  translate[0][1][5] = 0;
#line 298
  translate[0][1][6] = 1;
#line 298
  translate[0][1][7] = 1;
#line 298
  translate[0][1][8] = 1;
#line 298
  translate[0][1][9] = 1;
#line 298
  translate[0][1][10] = 1;
#line 298
  translate[0][1][11] = 1;
#line 298
  translate[0][1][12] = 1;
#line 298
  translate[0][1][13] = 1;
#line 298
  translate[0][1][14] = 1;
#line 298
  translate[0][1][15] = 0;
#line 298
  translate[1][0][0] = 0;
#line 298
  translate[1][0][1] = 2;
#line 298
  translate[1][0][2] = 2;
#line 298
  translate[1][0][3] = 2;
#line 298
  translate[1][0][4] = 2;
#line 298
  translate[1][0][5] = 2;
#line 298
  translate[1][0][6] = 2;
#line 298
  translate[1][0][7] = 0;
#line 298
  translate[1][0][8] = 0;
#line 298
  translate[1][0][9] = 0;
#line 298
  translate[1][0][10] = 0;
#line 298
  translate[1][0][11] = 0;
#line 298
  translate[1][0][12] = 0;
#line 298
  translate[1][0][13] = 0;
#line 298
  translate[1][0][14] = 0;
#line 298
  translate[1][0][15] = 0;
#line 298
  translate[1][1][0] = 0;
#line 298
  translate[1][1][1] = 2;
#line 298
  translate[1][1][2] = 2;
#line 298
  translate[1][1][3] = 0;
#line 298
  translate[1][1][4] = 0;
#line 298
  translate[1][1][5] = 0;
#line 298
  translate[1][1][6] = 0;
#line 298
  translate[1][1][7] = 0;
#line 298
  translate[1][1][8] = 0;
#line 298
  translate[1][1][9] = 0;
#line 298
  translate[1][1][10] = 0;
#line 298
  translate[1][1][11] = 0;
#line 298
  translate[1][1][12] = 0;
#line 298
  translate[1][1][13] = 0;
#line 298
  translate[1][1][14] = 0;
#line 298
  translate[1][1][15] = 0;
#line 298
  translate[2][0][0] = 0;
#line 298
  translate[2][0][1] = 3;
#line 298
  translate[2][0][2] = 3;
#line 298
  translate[2][0][3] = 3;
#line 298
  translate[2][0][4] = 3;
#line 298
  translate[2][0][5] = 3;
#line 298
  translate[2][0][6] = 3;
#line 298
  translate[2][0][7] = 0;
#line 298
  translate[2][0][8] = 0;
#line 298
  translate[2][0][9] = 0;
#line 298
  translate[2][0][10] = 1;
#line 298
  translate[2][0][11] = 1;
#line 298
  translate[2][0][12] = 1;
#line 298
  translate[2][0][13] = 1;
#line 298
  translate[2][0][14] = 1;
#line 298
  translate[2][0][15] = 0;
#line 298
  translate[2][1][0] = 0;
#line 298
  translate[2][1][1] = 3;
#line 298
  translate[2][1][2] = 3;
#line 298
  translate[2][1][3] = 0;
#line 298
  translate[2][1][4] = 0;
#line 298
  translate[2][1][5] = 0;
#line 298
  translate[2][1][6] = 1;
#line 298
  translate[2][1][7] = 1;
#line 298
  translate[2][1][8] = 1;
#line 298
  translate[2][1][9] = 1;
#line 298
  translate[2][1][10] = 1;
#line 298
  translate[2][1][11] = 1;
#line 298
  translate[2][1][12] = 1;
#line 298
  translate[2][1][13] = 1;
#line 298
  translate[2][1][14] = 1;
#line 298
  translate[2][1][15] = 0;
#line 315
  tables[0] = alloc_0;
#line 315
  tables[1] = alloc_1;
#line 315
  tables[2] = alloc_2;
#line 315
  tables[3] = alloc_3;
#line 315
  tables[4] = alloc_4;
#line 316
  sblims[0] = 27;
#line 316
  sblims[1] = 30;
#line 316
  sblims[2] = 8;
#line 316
  sblims[3] = 12;
#line 316
  sblims[4] = 30;
#line 318
  if (fr->sampling_frequency >= 3) {
#line 319
    table = 4;
  } else {
#line 321
    table = translate[fr->sampling_frequency][2 - fr->stereo][fr->bitrate_index];
  }
#line 323
  sblim = sblims[table];
#line 324
  fr->alloc = tables[table];
#line 325
  fr->II_sblimit = sblim;
#line 326
  return;
}
}
#line 329 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer2.c"
int do_layer2(mpg123_handle *fr ) 
{ 
  int clip ;
  int i ;
  int j ;
  int stereo ;
  float (*fraction)[4][32] ;
  unsigned int bit_alloc[64] ;
  int scale[192] ;
  int single ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 331
  clip = 0;
#line 333
  stereo = fr->stereo;
#line 336
  fraction = fr->layer2.fraction;
#line 339
  single = fr->single;
#line 341
  II_select_table(fr);
  }
#line 342
  if (fr->mode == 1) {
#line 342
    fr->jsbound = (fr->mode_ext << 2) + 4;
  } else {
#line 342
    fr->jsbound = fr->II_sblimit;
  }
#line 344
  if (fr->jsbound > fr->II_sblimit) {
    {
#line 346
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Truncating stereo boundary to sideband limit.\n");
#line 347
    fr->jsbound = fr->II_sblimit;
    }
  }
#line 351
  if (stereo == 1) {
#line 352
    single = 0;
  } else
#line 351
  if (single == 3) {
#line 352
    single = 0;
  }
  {
#line 354
  II_step_one(bit_alloc, scale, fr);
#line 356
  i = 0;
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! (i < 12)) {
#line 356
      goto while_break;
    }
    {
#line 358
    II_step_two(bit_alloc, (float (*)[4][32])fraction, scale, fr, i >> 2);
#line 359
    j = 0;
    }
    {
#line 359
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 359
      if (! (j < 3)) {
#line 359
        goto while_break___0;
      }
#line 361
      if (single != -1) {
        {
#line 362
        tmp = (*(fr->synth_mono))((*(fraction + single))[j], fr);
#line 362
        clip += tmp;
        }
      } else {
        {
#line 364
        tmp___0 = (*(fr->synth_stereo))((*(fraction + 0))[j], (*(fraction + 1))[j],
                                        fr);
#line 364
        clip += tmp___0;
        }
      }
#line 359
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 356
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return (clip);
}
}
#line 261 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
int do_layer1(mpg123_handle *fr ) ;
#line 40 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/getbits.h"
static unsigned int getbits___1(mpg123_handle *fr , int number_of_bits ) 
{ 
  unsigned long rval ;

  {
#line 56
  rval = (unsigned long )*(fr->wordpointer + 0);
#line 57
  rval <<= 8;
#line 58
  rval |= (unsigned long )*(fr->wordpointer + 1);
#line 59
  rval <<= 8;
#line 60
  rval |= (unsigned long )*(fr->wordpointer + 2);
#line 62
  rval <<= fr->bitindex;
#line 63
  rval &= 16777215UL;
#line 65
  fr->bitindex += number_of_bits;
#line 67
  rval >>= 24 - number_of_bits;
#line 69
  fr->wordpointer += fr->bitindex >> 3;
#line 70
  fr->bitindex &= 7;
#line 77
  return ((unsigned int )rval);
}
}
#line 14 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer1.c"
void I_step_one(unsigned int *balloc , unsigned int (*scale_index)[32] , mpg123_handle *fr ) 
{ 
  unsigned int *ba ;
  unsigned int *sca ;
  int i ;
  int jsbound ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int *tmp___1 ;
  unsigned int *tmp___2 ;
  unsigned int *tmp___3 ;
  unsigned int *tmp___4 ;
  unsigned int *tmp___5 ;
  unsigned int *tmp___6 ;
  unsigned int *tmp___7 ;
  unsigned int *tmp___8 ;
  int i___0 ;
  unsigned int *tmp___9 ;
  unsigned int *tmp___10 ;
  unsigned int *tmp___11 ;

  {
#line 16
  ba = balloc;
#line 17
  sca = (unsigned int *)scale_index;
#line 19
  if (fr->stereo == 2) {
#line 22
    jsbound = fr->jsbound;
#line 23
    i = 0;
    {
#line 23
    while (1) {
      while_continue: /* CIL Label */ ;
#line 23
      if (! (i < jsbound)) {
#line 23
        goto while_break;
      }
      {
#line 25
      tmp = ba;
#line 25
      ba ++;
#line 25
      *tmp = getbits___1(fr, 4);
#line 26
      tmp___0 = ba;
#line 26
      ba ++;
#line 26
      *tmp___0 = getbits___1(fr, 4);
#line 23
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 28
    i = jsbound;
    {
#line 28
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 28
      if (! (i < 32)) {
#line 28
        goto while_break___0;
      }
      {
#line 28
      tmp___1 = ba;
#line 28
      ba ++;
#line 28
      *tmp___1 = getbits___1(fr, 4);
#line 28
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 30
    ba = balloc;
#line 32
    i = 0;
    {
#line 32
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 32
      if (! (i < jsbound)) {
#line 32
        goto while_break___1;
      }
#line 34
      tmp___3 = ba;
#line 34
      ba ++;
#line 34
      if (*tmp___3) {
        {
#line 35
        tmp___2 = sca;
#line 35
        sca ++;
#line 35
        *tmp___2 = getbits___1(fr, 6);
        }
      }
#line 36
      tmp___5 = ba;
#line 36
      ba ++;
#line 36
      if (*tmp___5) {
        {
#line 37
        tmp___4 = sca;
#line 37
        sca ++;
#line 37
        *tmp___4 = getbits___1(fr, 6);
        }
      }
#line 32
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 39
    i = jsbound;
    {
#line 39
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 39
      if (! (i < 32)) {
#line 39
        goto while_break___2;
      }
#line 40
      tmp___8 = ba;
#line 40
      ba ++;
#line 40
      if (*tmp___8) {
        {
#line 42
        tmp___6 = sca;
#line 42
        sca ++;
#line 42
        *tmp___6 = getbits___1(fr, 6);
#line 43
        tmp___7 = sca;
#line 43
        sca ++;
#line 43
        *tmp___7 = getbits___1(fr, 6);
        }
      }
#line 39
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 49
    i___0 = 0;
    {
#line 49
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 49
      if (! (i___0 < 32)) {
#line 49
        goto while_break___3;
      }
      {
#line 49
      tmp___9 = ba;
#line 49
      ba ++;
#line 49
      *tmp___9 = getbits___1(fr, 4);
#line 49
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 51
    ba = balloc;
#line 52
    i___0 = 0;
    {
#line 52
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 52
      if (! (i___0 < 32)) {
#line 52
        goto while_break___4;
      }
#line 53
      tmp___11 = ba;
#line 53
      ba ++;
#line 53
      if (*tmp___11) {
        {
#line 54
        tmp___10 = sca;
#line 54
        sca ++;
#line 54
        *tmp___10 = getbits___1(fr, 6);
        }
      }
#line 52
      i___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 56
  return;
}
}
#line 58 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer1.c"
void I_step_two(float (*fraction)[32] , unsigned int *balloc , unsigned int (*scale_index)[32] ,
                mpg123_handle *fr ) 
{ 
  int i ;
  int n ;
  int smpb[64] ;
  int *sample ;
  register unsigned int *ba ;
  register unsigned int *sca ;
  int jsbound ;
  register float *f0 ;
  register float *f1 ;
  int *tmp ;
  unsigned int tmp___0 ;
  unsigned int *tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int *tmp___4 ;
  int *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int *tmp___7 ;
  float *tmp___8 ;
  int *tmp___9 ;
  unsigned int *tmp___10 ;
  float *tmp___11 ;
  unsigned int *tmp___12 ;
  float *tmp___13 ;
  int *tmp___14 ;
  unsigned int *tmp___15 ;
  float *tmp___16 ;
  unsigned int *tmp___17 ;
  float samp ;
  int *tmp___18 ;
  float *tmp___19 ;
  unsigned int *tmp___20 ;
  float *tmp___21 ;
  unsigned int *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float tmp___25 ;
  unsigned int *tmp___26 ;
  float tmp___27 ;
  register float *f0___0 ;
  int *tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int *tmp___30 ;
  float *tmp___31 ;
  int *tmp___32 ;
  unsigned int *tmp___33 ;
  float *tmp___34 ;
  unsigned int *tmp___35 ;
  void *__cil_tmp53 ;

  {
#line 64
  sca = (unsigned int *)scale_index;
#line 66
  if (fr->stereo == 2) {
#line 68
    jsbound = fr->jsbound;
#line 69
    f0 = *(fraction + 0);
#line 70
    f1 = *(fraction + 1);
#line 71
    ba = (unsigned int *)balloc;
#line 72
    sample = smpb;
#line 72
    i = 0;
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (! (i < jsbound)) {
#line 72
        goto while_break;
      }
#line 74
      tmp___1 = ba;
#line 74
      ba ++;
#line 74
      n = (int )*tmp___1;
#line 74
      if (n) {
        {
#line 74
        tmp = sample;
#line 74
        sample ++;
#line 74
        tmp___0 = getbits___1(fr, n + 1);
#line 74
        *tmp = (int )tmp___0;
        }
      }
#line 76
      tmp___4 = ba;
#line 76
      ba ++;
#line 76
      n = (int )*tmp___4;
#line 76
      if (n) {
        {
#line 76
        tmp___2 = sample;
#line 76
        sample ++;
#line 76
        tmp___3 = getbits___1(fr, n + 1);
#line 76
        *tmp___2 = (int )tmp___3;
        }
      }
#line 72
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 78
    i = jsbound;
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 78
      if (! (i < 32)) {
#line 78
        goto while_break___0;
      }
#line 79
      tmp___7 = ba;
#line 79
      ba ++;
#line 79
      n = (int )*tmp___7;
#line 79
      if (n) {
        {
#line 80
        tmp___5 = sample;
#line 80
        sample ++;
#line 80
        tmp___6 = getbits___1(fr, n + 1);
#line 80
        *tmp___5 = (int )tmp___6;
        }
      }
#line 78
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 82
    ba = (unsigned int *)balloc;
#line 83
    sample = smpb;
#line 83
    i = 0;
    {
#line 83
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 83
      if (! (i < jsbound)) {
#line 83
        goto while_break___1;
      }
#line 85
      tmp___12 = ba;
#line 85
      ba ++;
#line 85
      n = (int )*tmp___12;
#line 85
      if (n) {
#line 86
        tmp___8 = f0;
#line 86
        f0 ++;
#line 86
        tmp___9 = sample;
#line 86
        sample ++;
#line 86
        tmp___10 = sca;
#line 86
        sca ++;
#line 86
        *tmp___8 = (float )(((-1 << n) + *tmp___9) + 1) * fr->muls[n + 1][*tmp___10];
      } else {
#line 87
        tmp___11 = f0;
#line 87
        f0 ++;
#line 87
        *tmp___11 = (float )0.0;
      }
#line 89
      tmp___17 = ba;
#line 89
      ba ++;
#line 89
      n = (int )*tmp___17;
#line 89
      if (n) {
#line 90
        tmp___13 = f1;
#line 90
        f1 ++;
#line 90
        tmp___14 = sample;
#line 90
        sample ++;
#line 90
        tmp___15 = sca;
#line 90
        sca ++;
#line 90
        *tmp___13 = (float )(((-1 << n) + *tmp___14) + 1) * fr->muls[n + 1][*tmp___15];
      } else {
#line 91
        tmp___16 = f1;
#line 91
        f1 ++;
#line 91
        *tmp___16 = (float )0.0;
      }
#line 83
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 93
    i = jsbound;
    {
#line 93
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 93
      if (! (i < 32)) {
#line 93
        goto while_break___2;
      }
#line 95
      tmp___26 = ba;
#line 95
      ba ++;
#line 95
      n = (int )*tmp___26;
#line 95
      if (n) {
#line 97
        tmp___18 = sample;
#line 97
        sample ++;
#line 97
        samp = (float )(((-1 << n) + *tmp___18) + 1);
#line 98
        tmp___19 = f0;
#line 98
        f0 ++;
#line 98
        tmp___20 = sca;
#line 98
        sca ++;
#line 98
        *tmp___19 = samp * fr->muls[n + 1][*tmp___20];
#line 99
        tmp___21 = f1;
#line 99
        f1 ++;
#line 99
        tmp___22 = sca;
#line 99
        sca ++;
#line 99
        *tmp___21 = samp * fr->muls[n + 1][*tmp___22];
      } else {
#line 101
        tmp___23 = f0;
#line 101
        f0 ++;
#line 101
        tmp___24 = f1;
#line 101
        f1 ++;
#line 101
        tmp___25 = (float )0.0;
#line 101
        *tmp___24 = tmp___25;
#line 101
        *tmp___23 = tmp___25;
      }
#line 93
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 103
    i = fr->down_sample_sblimit;
    {
#line 103
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 103
      if (! (i < 32)) {
#line 103
        goto while_break___3;
      }
#line 104
      tmp___27 = (float )0.0;
#line 104
      (*(fraction + 1))[i] = tmp___27;
#line 104
      (*(fraction + 0))[i] = tmp___27;
#line 103
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
#line 108
    f0___0 = *(fraction + 0);
#line 109
    ba = (unsigned int *)balloc;
#line 110
    sample = smpb;
#line 110
    i = 0;
    {
#line 110
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 110
      if (! (i < 32)) {
#line 110
        goto while_break___4;
      }
#line 111
      tmp___30 = ba;
#line 111
      ba ++;
#line 111
      n = (int )*tmp___30;
#line 111
      if (n) {
        {
#line 112
        tmp___28 = sample;
#line 112
        sample ++;
#line 112
        tmp___29 = getbits___1(fr, n + 1);
#line 112
        *tmp___28 = (int )tmp___29;
        }
      }
#line 110
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 114
    ba = (unsigned int *)balloc;
#line 115
    sample = smpb;
#line 115
    i = 0;
    {
#line 115
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 115
      if (! (i < 32)) {
#line 115
        goto while_break___5;
      }
#line 117
      tmp___35 = ba;
#line 117
      ba ++;
#line 117
      n = (int )*tmp___35;
#line 117
      if (n) {
#line 118
        tmp___31 = f0___0;
#line 118
        f0___0 ++;
#line 118
        tmp___32 = sample;
#line 118
        sample ++;
#line 118
        tmp___33 = sca;
#line 118
        sca ++;
#line 118
        *tmp___31 = (float )(((-1 << n) + *tmp___32) + 1) * fr->muls[n + 1][*tmp___33];
      } else {
#line 119
        tmp___34 = f0___0;
#line 119
        f0___0 ++;
#line 119
        *tmp___34 = (float )0.0;
      }
#line 115
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 121
    i = fr->down_sample_sblimit;
    {
#line 121
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 121
      if (! (i < 32)) {
#line 121
        goto while_break___6;
      }
#line 122
      (*(fraction + 0))[i] = (float )0.0;
#line 121
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 124
  return;
}
}
#line 126 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/layer1.c"
int do_layer1(mpg123_handle *fr ) 
{ 
  int clip ;
  int i ;
  int stereo ;
  unsigned int balloc[64] ;
  unsigned int scale_index[2][32] ;
  float (*fraction)[32] ;
  int single ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
#line 128
  clip = 0;
#line 129
  stereo = fr->stereo;
#line 132
  fraction = fr->layer1.fraction;
#line 133
  single = fr->single;
#line 135
  if (fr->mode == 1) {
#line 135
    fr->jsbound = (fr->mode_ext << 2) + 4;
  } else {
#line 135
    fr->jsbound = 32;
  }
#line 137
  if (stereo == 1) {
#line 138
    single = 0;
  } else
#line 137
  if (single == 3) {
#line 138
    single = 0;
  }
  {
#line 140
  I_step_one(balloc, (unsigned int (*)[32])(scale_index), fr);
#line 142
  i = 0;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < 12)) {
#line 142
      goto while_break;
    }
    {
#line 144
    I_step_two((float (*)[32])fraction, (unsigned int *)(balloc), (unsigned int (*)[32])(scale_index),
               fr);
    }
#line 146
    if (single != -1) {
      {
#line 147
      tmp = (*(fr->synth_mono))(*(fraction + single), fr);
#line 147
      clip += tmp;
      }
    } else {
      {
#line 149
      tmp___0 = (*(fr->synth_stereo))(*(fraction + 0), *(fraction + 1), fr);
#line 149
      clip += tmp___0;
      }
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (clip);
}
}
#line 92 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
int synth_1to1_8bit(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 93
int synth_1to1_8bit_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 95
int synth_1to1_8bit_wrap(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 96
int synth_1to1_8bit_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 98
int synth_1to1_8bit_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 100
int synth_1to1_8bit_wrap_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 101
int synth_1to1_8bit_wrap_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 104
int synth_2to1_8bit(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 105
int synth_2to1_8bit_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 106
int synth_2to1_8bit_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 107
int synth_2to1_8bit_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 108
int synth_4to1_8bit(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 109
int synth_4to1_8bit_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 110
int synth_4to1_8bit_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 111
int synth_4to1_8bit_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 114
int synth_ntom_8bit(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 115
int synth_ntom_8bit_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 116
int synth_ntom_8bit_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___13  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_1to1_8bit(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  unsigned char *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  short write_8bit_tmp ;
  float sum___0 ;
  short write_8bit_tmp___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  short write_8bit_tmp___1 ;

  {
#line 34
  samples = fr->buffer.data + fr->buffer.fill;
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 16;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    if ((double )sum > 32767.0) {
#line 125
      write_8bit_tmp = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      write_8bit_tmp = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      write_8bit_tmp = (short )sum;
    }
#line 125
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp >> 3));
#line 85
    j --;
#line 85
    b0 += 0;
#line 85
    window += 16;
#line 85
    samples += step___13;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    write_8bit_tmp___0 = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    write_8bit_tmp___0 = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    write_8bit_tmp___0 = (short )sum___0;
  }
#line 140
  *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___0 >> 3));
#line 141
  samples += step___13;
#line 142
  b0 -= 16;
#line 143
  window -= 32;
#line 145
  window += bo1 << 1;
#line 147
  j = 15;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      write_8bit_tmp___1 = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      write_8bit_tmp___1 = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      write_8bit_tmp___1 = (short )sum___1;
    }
#line 186
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___1 >> 3));
#line 147
    j --;
#line 147
    b0 -= 32;
#line 147
    window -= 16;
#line 147
    samples += step___13;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 64UL * sizeof(unsigned char ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_1to1_8bit_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  unsigned char samples_tmp[64] ;
  unsigned char *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = samples_tmp;
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[0][1]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 32)) {
#line 37
      goto while_break;
    }
#line 39
    *samples = *tmp1;
#line 40
    samples += sizeof(unsigned char );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 32UL * sizeof(unsigned char ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_1to1_8bit_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[0][1]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 64UL * sizeof(unsigned char );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 32)) {
#line 57
      goto while_break;
    }
#line 59
    *(samples + 1) = *(samples + 0);
#line 60
    samples += 2UL * sizeof(unsigned char );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___14  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_1to1_8bit_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  unsigned char *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  short write_8bit_tmp ;
  float sum___0 ;
  short write_8bit_tmp___0 ;
  float sum___1 ;
  short write_8bit_tmp___1 ;

  {
#line 34
  samples = fr->buffer.data + fr->buffer.fill;
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 16;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    if ((double )sum > 32767.0) {
#line 125
      write_8bit_tmp = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      write_8bit_tmp = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      write_8bit_tmp = (short )sum;
    }
#line 125
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp >> 3));
#line 85
    j --;
#line 85
    b0 += 16;
#line 85
    window += 32;
#line 85
    samples += step___14;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    write_8bit_tmp___0 = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    write_8bit_tmp___0 = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    write_8bit_tmp___0 = (short )sum___0;
  }
#line 140
  *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___0 >> 3));
#line 141
  samples += step___14;
#line 142
  b0 -= 16;
#line 143
  window -= 32;
#line 145
  window += bo1 << 1;
#line 147
  j = 15;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      write_8bit_tmp___1 = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      write_8bit_tmp___1 = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      write_8bit_tmp___1 = (short )sum___1;
    }
#line 186
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___1 >> 3));
#line 147
    j --;
#line 147
    b0 -= 16;
#line 147
    window -= 32;
#line 147
    samples += step___14;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 64UL * sizeof(unsigned char ));
  }
#line 192
  return (clip);
}
}
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_8bit.h"
int synth_1to1_8bit_wrap(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short samples_tmp[64] ;
  short *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  int tmp ;
  void *__cil_tmp12 ;

  {
  {
#line 16
  tmp1 = samples_tmp + channel;
#line 19
  samples = fr->buffer.data;
#line 20
  pnt = (int )fr->buffer.fill;
#line 21
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 22
  fr->buffer.fill = (size_t )0;
#line 23
  ret = (*(fr->synths.plain[0][0]))(bandPtr, channel, fr, 0);
#line 24
  fr->buffer.data = samples;
#line 26
  samples += channel + pnt;
#line 27
  i = 0;
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! (i < 32)) {
#line 27
      goto while_break;
    }
#line 29
    *samples = *(fr->conv16to8 + ((int )*tmp1 >> 3));
#line 30
    samples += 2;
#line 31
    tmp1 += 2;
#line 27
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  if (final) {
#line 33
    tmp = 64;
  } else {
#line 33
    tmp = 0;
  }
#line 33
  fr->buffer.fill = (size_t )(pnt + tmp);
#line 35
  return (ret);
}
}
#line 38 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_8bit.h"
int synth_1to1_8bit_wrap_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  short samples_tmp[64] ;
  short *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  unsigned char *tmp ;
  void *__cil_tmp10 ;

  {
  {
#line 41
  tmp1 = samples_tmp;
#line 44
  samples = fr->buffer.data;
#line 45
  pnt = (int )fr->buffer.fill;
#line 46
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 47
  fr->buffer.fill = (size_t )0;
#line 48
  ret = (*(fr->synths.plain[0][0]))(bandPtr, 0, fr, 0);
#line 49
  fr->buffer.data = samples;
#line 51
  samples += pnt;
#line 52
  i = 0;
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < 32)) {
#line 52
      goto while_break;
    }
#line 54
    tmp = samples;
#line 54
    samples ++;
#line 54
    *tmp = *(fr->conv16to8 + ((int )*tmp1 >> 3));
#line 55
    tmp1 += 2;
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  fr->buffer.fill = (size_t )(pnt + 32);
#line 59
  return (ret);
}
}
#line 62 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_8bit.h"
int synth_1to1_8bit_wrap_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  short samples_tmp[64] ;
  short *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  void *__cil_tmp11 ;

  {
  {
#line 65
  tmp1 = samples_tmp;
#line 68
  samples = fr->buffer.data;
#line 69
  pnt = (int )fr->buffer.fill;
#line 70
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 71
  fr->buffer.fill = (size_t )0;
#line 72
  ret = (*(fr->synths.plain[0][0]))(bandPtr, 0, fr, 0);
#line 73
  fr->buffer.data = samples;
#line 75
  samples += pnt;
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < 32)) {
#line 76
      goto while_break;
    }
#line 78
    tmp = samples;
#line 78
    samples ++;
#line 78
    *tmp = *(fr->conv16to8 + ((int )*tmp1 >> 3));
#line 79
    tmp___0 = samples;
#line 79
    samples ++;
#line 79
    *tmp___0 = *(fr->conv16to8 + ((int )*tmp1 >> 3));
#line 80
    tmp1 += 2;
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  fr->buffer.fill = (size_t )(pnt + 64);
#line 84
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___15  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_2to1_8bit(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  unsigned char *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  short write_8bit_tmp ;
  float sum___0 ;
  short write_8bit_tmp___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  short write_8bit_tmp___1 ;

  {
#line 34
  samples = fr->buffer.data + fr->buffer.fill;
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    if ((double )sum > 32767.0) {
#line 125
      write_8bit_tmp = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      write_8bit_tmp = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      write_8bit_tmp = (short )sum;
    }
#line 125
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp >> 3));
#line 85
    j --;
#line 85
    b0 += 16;
#line 85
    window += 48;
#line 85
    samples += step___15;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    write_8bit_tmp___0 = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    write_8bit_tmp___0 = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    write_8bit_tmp___0 = (short )sum___0;
  }
#line 140
  *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___0 >> 3));
#line 141
  samples += step___15;
#line 142
  b0 -= 32;
#line 143
  window -= 64;
#line 145
  window += bo1 << 1;
#line 147
  j = 7;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      write_8bit_tmp___1 = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      write_8bit_tmp___1 = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      write_8bit_tmp___1 = (short )sum___1;
    }
#line 186
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___1 >> 3));
#line 147
    j --;
#line 147
    b0 -= 48;
#line 147
    window -= 48;
#line 147
    samples += step___15;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 32UL * sizeof(unsigned char ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_2to1_8bit_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  unsigned char samples_tmp[32] ;
  unsigned char *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = samples_tmp;
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[1][1]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 16)) {
#line 37
      goto while_break;
    }
#line 39
    *samples = *tmp1;
#line 40
    samples += sizeof(unsigned char );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 16UL * sizeof(unsigned char ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_2to1_8bit_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[1][1]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 32UL * sizeof(unsigned char );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 16)) {
#line 57
      goto while_break;
    }
#line 59
    *(samples + 1) = *(samples + 0);
#line 60
    samples += 2UL * sizeof(unsigned char );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___16  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_2to1_8bit_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  unsigned char *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  short write_8bit_tmp ;
  float sum___0 ;
  short write_8bit_tmp___0 ;
  float sum___1 ;
  short write_8bit_tmp___1 ;

  {
#line 34
  samples = fr->buffer.data + fr->buffer.fill;
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    if ((double )sum > 32767.0) {
#line 125
      write_8bit_tmp = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      write_8bit_tmp = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      write_8bit_tmp = (short )sum;
    }
#line 125
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp >> 3));
#line 85
    j --;
#line 85
    b0 += 32;
#line 85
    window += 64;
#line 85
    samples += step___16;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    write_8bit_tmp___0 = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    write_8bit_tmp___0 = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    write_8bit_tmp___0 = (short )sum___0;
  }
#line 140
  *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___0 >> 3));
#line 141
  samples += step___16;
#line 142
  b0 -= 32;
#line 143
  window -= 64;
#line 145
  window += bo1 << 1;
#line 147
  j = 7;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      write_8bit_tmp___1 = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      write_8bit_tmp___1 = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      write_8bit_tmp___1 = (short )sum___1;
    }
#line 186
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___1 >> 3));
#line 147
    j --;
#line 147
    b0 -= 32;
#line 147
    window -= 64;
#line 147
    samples += step___16;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 32UL * sizeof(unsigned char ));
  }
#line 192
  return (clip);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___17  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_4to1_8bit(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  unsigned char *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  short write_8bit_tmp ;
  float sum___0 ;
  short write_8bit_tmp___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  short write_8bit_tmp___1 ;

  {
#line 34
  samples = fr->buffer.data + fr->buffer.fill;
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    if ((double )sum > 32767.0) {
#line 125
      write_8bit_tmp = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      write_8bit_tmp = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      write_8bit_tmp = (short )sum;
    }
#line 125
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp >> 3));
#line 85
    j --;
#line 85
    b0 += 48;
#line 85
    window += 112;
#line 85
    samples += step___17;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    write_8bit_tmp___0 = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    write_8bit_tmp___0 = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    write_8bit_tmp___0 = (short )sum___0;
  }
#line 140
  *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___0 >> 3));
#line 141
  samples += step___17;
#line 142
  b0 -= 64;
#line 143
  window -= 128;
#line 145
  window += bo1 << 1;
#line 147
  j = 3;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      write_8bit_tmp___1 = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      write_8bit_tmp___1 = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      write_8bit_tmp___1 = (short )sum___1;
    }
#line 186
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___1 >> 3));
#line 147
    j --;
#line 147
    b0 -= 80;
#line 147
    window -= 112;
#line 147
    samples += step___17;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 16UL * sizeof(unsigned char ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_4to1_8bit_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  unsigned char samples_tmp[16] ;
  unsigned char *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = samples_tmp;
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[2][1]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 8)) {
#line 37
      goto while_break;
    }
#line 39
    *samples = *tmp1;
#line 40
    samples += sizeof(unsigned char );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 8UL * sizeof(unsigned char ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_4to1_8bit_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[2][1]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 16UL * sizeof(unsigned char );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 8)) {
#line 57
      goto while_break;
    }
#line 59
    *(samples + 1) = *(samples + 0);
#line 60
    samples += 2UL * sizeof(unsigned char );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___18  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_4to1_8bit_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  unsigned char *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  short write_8bit_tmp ;
  float sum___0 ;
  short write_8bit_tmp___0 ;
  float sum___1 ;
  short write_8bit_tmp___1 ;

  {
#line 34
  samples = fr->buffer.data + fr->buffer.fill;
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    if ((double )sum > 32767.0) {
#line 125
      write_8bit_tmp = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      write_8bit_tmp = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      write_8bit_tmp = (short )sum;
    }
#line 125
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp >> 3));
#line 85
    j --;
#line 85
    b0 += 64;
#line 85
    window += 128;
#line 85
    samples += step___18;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    write_8bit_tmp___0 = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    write_8bit_tmp___0 = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    write_8bit_tmp___0 = (short )sum___0;
  }
#line 140
  *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___0 >> 3));
#line 141
  samples += step___18;
#line 142
  b0 -= 64;
#line 143
  window -= 128;
#line 145
  window += bo1 << 1;
#line 147
  j = 3;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      write_8bit_tmp___1 = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      write_8bit_tmp___1 = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      write_8bit_tmp___1 = (short )sum___1;
    }
#line 186
    *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___1 >> 3));
#line 147
    j --;
#line 147
    b0 -= 64;
#line 147
    window -= 128;
#line 147
    samples += step___18;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 16UL * sizeof(unsigned char ));
  }
#line 192
  return (clip);
}
}
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_8bit_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  unsigned char samples_tmp[512] ;
  unsigned char *tmp1 ;
  size_t i ;
  int ret ;
  size_t pnt ;
  unsigned char *samples ;
  void *__cil_tmp9 ;

  {
  {
#line 23
  tmp1 = samples_tmp;
#line 27
  pnt = fr->buffer.fill;
#line 28
  samples = fr->buffer.data;
#line 29
  fr->buffer.data = samples_tmp;
#line 30
  fr->buffer.fill = (size_t )0;
#line 31
  ret = synth_ntom_8bit(bandPtr, 0, fr, 1);
#line 32
  fr->buffer.data = samples;
#line 34
  samples += pnt;
#line 35
  i = (size_t )0;
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((unsigned long )i < (unsigned long )fr->buffer.fill / (2UL * sizeof(unsigned char )))) {
#line 35
      goto while_break;
    }
#line 37
    *samples = *tmp1;
#line 38
    samples += sizeof(unsigned char );
#line 39
    tmp1 += 2;
#line 35
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  fr->buffer.fill = pnt + fr->buffer.fill / 2U;
#line 43
  return (ret);
}
}
#line 47 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_8bit_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  size_t i ;
  int ret ;
  size_t pnt1 ;
  unsigned char *samples ;

  {
  {
#line 51
  pnt1 = fr->buffer.fill;
#line 52
  samples = fr->buffer.data + pnt1;
#line 54
  ret = synth_ntom_8bit(bandPtr, 0, fr, 1);
#line 56
  i = (size_t )0;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )i < (unsigned long )(fr->buffer.fill - pnt1) / (2UL * sizeof(unsigned char )))) {
#line 56
      goto while_break;
    }
#line 58
    *(samples + 1) = *(samples + 0);
#line 59
    samples += 2UL * sizeof(unsigned char );
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (ret);
}
}
#line 68 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
static int const   step___19  =    (int const   )2;
#line 66 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_8bit(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  unsigned char *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  int ntom ;
  unsigned long tmp ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float *tmp___31 ;
  short write_8bit_tmp ;
  float sum___0 ;
  short write_8bit_tmp___0 ;
  float sum___1 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  float *tmp___47 ;
  short write_8bit_tmp___1 ;
  unsigned long tmp___48 ;

  {
#line 69
  samples = fr->buffer.data + fr->buffer.fill;
#line 72
  clip = 0;
#line 76
  if (fr->have_eq_settings) {
    {
#line 76
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 78
  if (! channel) {
#line 80
    (fr->bo) --;
#line 81
    fr->bo &= 15;
#line 82
    buf = fr->real_buffs[0];
#line 83
    tmp = fr->ntom_val[0];
#line 83
    fr->ntom_val[1] = tmp;
#line 83
    ntom = (int )tmp;
  } else {
#line 87
    samples ++;
#line 88
    buf = fr->real_buffs[1];
#line 89
    ntom = (int )fr->ntom_val[1];
  }
#line 92
  if (fr->bo & 1) {
    {
#line 94
    b0 = *(buf + 0);
#line 95
    bo1 = fr->bo;
#line 96
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 100
    b0 = *(buf + 1);
#line 101
    bo1 = fr->bo + 1;
#line 102
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 107
  window = (fr->decwin + 16) - bo1;
#line 109
  j = 16;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! j) {
#line 109
      goto while_break;
    }
#line 113
    ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 114
    if (ntom < 32768) {
#line 116
      window += 16;
#line 117
      b0 += 16;
#line 118
      goto __Cont;
    }
#line 121
    tmp___0 = window;
#line 121
    window ++;
#line 121
    tmp___1 = b0;
#line 121
    b0 ++;
#line 121
    sum = *tmp___0 * *tmp___1;
#line 122
    tmp___2 = window;
#line 122
    window ++;
#line 122
    tmp___3 = b0;
#line 122
    b0 ++;
#line 122
    sum -= *tmp___2 * *tmp___3;
#line 123
    tmp___4 = window;
#line 123
    window ++;
#line 123
    tmp___5 = b0;
#line 123
    b0 ++;
#line 123
    sum += *tmp___4 * *tmp___5;
#line 124
    tmp___6 = window;
#line 124
    window ++;
#line 124
    tmp___7 = b0;
#line 124
    b0 ++;
#line 124
    sum -= *tmp___6 * *tmp___7;
#line 125
    tmp___8 = window;
#line 125
    window ++;
#line 125
    tmp___9 = b0;
#line 125
    b0 ++;
#line 125
    sum += *tmp___8 * *tmp___9;
#line 126
    tmp___10 = window;
#line 126
    window ++;
#line 126
    tmp___11 = b0;
#line 126
    b0 ++;
#line 126
    sum -= *tmp___10 * *tmp___11;
#line 127
    tmp___12 = window;
#line 127
    window ++;
#line 127
    tmp___13 = b0;
#line 127
    b0 ++;
#line 127
    sum += *tmp___12 * *tmp___13;
#line 128
    tmp___14 = window;
#line 128
    window ++;
#line 128
    tmp___15 = b0;
#line 128
    b0 ++;
#line 128
    sum -= *tmp___14 * *tmp___15;
#line 129
    tmp___16 = window;
#line 129
    window ++;
#line 129
    tmp___17 = b0;
#line 129
    b0 ++;
#line 129
    sum += *tmp___16 * *tmp___17;
#line 130
    tmp___18 = window;
#line 130
    window ++;
#line 130
    tmp___19 = b0;
#line 130
    b0 ++;
#line 130
    sum -= *tmp___18 * *tmp___19;
#line 131
    tmp___20 = window;
#line 131
    window ++;
#line 131
    tmp___21 = b0;
#line 131
    b0 ++;
#line 131
    sum += *tmp___20 * *tmp___21;
#line 132
    tmp___22 = window;
#line 132
    window ++;
#line 132
    tmp___23 = b0;
#line 132
    b0 ++;
#line 132
    sum -= *tmp___22 * *tmp___23;
#line 133
    tmp___24 = window;
#line 133
    window ++;
#line 133
    tmp___25 = b0;
#line 133
    b0 ++;
#line 133
    sum += *tmp___24 * *tmp___25;
#line 134
    tmp___26 = window;
#line 134
    window ++;
#line 134
    tmp___27 = b0;
#line 134
    b0 ++;
#line 134
    sum -= *tmp___26 * *tmp___27;
#line 135
    tmp___28 = window;
#line 135
    window ++;
#line 135
    tmp___29 = b0;
#line 135
    b0 ++;
#line 135
    sum += *tmp___28 * *tmp___29;
#line 136
    tmp___30 = window;
#line 136
    window ++;
#line 136
    tmp___31 = b0;
#line 136
    b0 ++;
#line 136
    sum -= *tmp___30 * *tmp___31;
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 138
      if (! (ntom >= 32768)) {
#line 138
        goto while_break___0;
      }
#line 140
      if ((double )sum > 32767.0) {
#line 140
        write_8bit_tmp = (short)32767;
#line 140
        clip ++;
      } else
#line 140
      if ((double )sum < - 32768.0) {
#line 140
        write_8bit_tmp = (short)-32768;
#line 140
        clip ++;
      } else {
#line 140
        write_8bit_tmp = (short )sum;
      }
#line 140
      *samples = *(fr->conv16to8 + ((int )write_8bit_tmp >> 3));
#line 141
      samples += step___19;
#line 142
      ntom -= 32768;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 109
    j --;
#line 109
    window += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 147
  if (ntom >= 32768) {
#line 150
    sum___0 = *(window + 0) * *(b0 + 0);
#line 151
    sum___0 += *(window + 2) * *(b0 + 2);
#line 152
    sum___0 += *(window + 4) * *(b0 + 4);
#line 153
    sum___0 += *(window + 6) * *(b0 + 6);
#line 154
    sum___0 += *(window + 8) * *(b0 + 8);
#line 155
    sum___0 += *(window + 10) * *(b0 + 10);
#line 156
    sum___0 += *(window + 12) * *(b0 + 12);
#line 157
    sum___0 += *(window + 14) * *(b0 + 14);
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (ntom >= 32768)) {
#line 159
        goto while_break___1;
      }
#line 161
      if ((double )sum___0 > 32767.0) {
#line 161
        write_8bit_tmp___0 = (short)32767;
#line 161
        clip ++;
      } else
#line 161
      if ((double )sum___0 < - 32768.0) {
#line 161
        write_8bit_tmp___0 = (short)-32768;
#line 161
        clip ++;
      } else {
#line 161
        write_8bit_tmp___0 = (short )sum___0;
      }
#line 161
      *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___0 >> 3));
#line 162
      samples += step___19;
#line 163
      ntom -= 32768;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 167
  b0 -= 16;
#line 167
  window -= 32;
#line 168
  window += bo1 << 1;
#line 170
  j = 15;
  {
#line 170
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 170
    if (! j) {
#line 170
      goto while_break___2;
    }
#line 174
    ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 175
    if (ntom < 32768) {
#line 177
      window -= 16;
#line 178
      b0 += 16;
#line 179
      goto __Cont___0;
    }
#line 182
    window --;
#line 182
    tmp___32 = b0;
#line 182
    b0 ++;
#line 182
    sum___1 = - *window * *tmp___32;
#line 183
    window --;
#line 183
    tmp___33 = b0;
#line 183
    b0 ++;
#line 183
    sum___1 -= *window * *tmp___33;
#line 184
    window --;
#line 184
    tmp___34 = b0;
#line 184
    b0 ++;
#line 184
    sum___1 -= *window * *tmp___34;
#line 185
    window --;
#line 185
    tmp___35 = b0;
#line 185
    b0 ++;
#line 185
    sum___1 -= *window * *tmp___35;
#line 186
    window --;
#line 186
    tmp___36 = b0;
#line 186
    b0 ++;
#line 186
    sum___1 -= *window * *tmp___36;
#line 187
    window --;
#line 187
    tmp___37 = b0;
#line 187
    b0 ++;
#line 187
    sum___1 -= *window * *tmp___37;
#line 188
    window --;
#line 188
    tmp___38 = b0;
#line 188
    b0 ++;
#line 188
    sum___1 -= *window * *tmp___38;
#line 189
    window --;
#line 189
    tmp___39 = b0;
#line 189
    b0 ++;
#line 189
    sum___1 -= *window * *tmp___39;
#line 190
    window --;
#line 190
    tmp___40 = b0;
#line 190
    b0 ++;
#line 190
    sum___1 -= *window * *tmp___40;
#line 191
    window --;
#line 191
    tmp___41 = b0;
#line 191
    b0 ++;
#line 191
    sum___1 -= *window * *tmp___41;
#line 192
    window --;
#line 192
    tmp___42 = b0;
#line 192
    b0 ++;
#line 192
    sum___1 -= *window * *tmp___42;
#line 193
    window --;
#line 193
    tmp___43 = b0;
#line 193
    b0 ++;
#line 193
    sum___1 -= *window * *tmp___43;
#line 194
    window --;
#line 194
    tmp___44 = b0;
#line 194
    b0 ++;
#line 194
    sum___1 -= *window * *tmp___44;
#line 195
    window --;
#line 195
    tmp___45 = b0;
#line 195
    b0 ++;
#line 195
    sum___1 -= *window * *tmp___45;
#line 196
    window --;
#line 196
    tmp___46 = b0;
#line 196
    b0 ++;
#line 196
    sum___1 -= *window * *tmp___46;
#line 197
    window --;
#line 197
    tmp___47 = b0;
#line 197
    b0 ++;
#line 197
    sum___1 -= *window * *tmp___47;
    {
#line 199
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 199
      if (! (ntom >= 32768)) {
#line 199
        goto while_break___3;
      }
#line 201
      if ((double )sum___1 > 32767.0) {
#line 201
        write_8bit_tmp___1 = (short)32767;
#line 201
        clip ++;
      } else
#line 201
      if ((double )sum___1 < - 32768.0) {
#line 201
        write_8bit_tmp___1 = (short)-32768;
#line 201
        clip ++;
      } else {
#line 201
        write_8bit_tmp___1 = (short )sum___1;
      }
#line 201
      *samples = *(fr->conv16to8 + ((int )write_8bit_tmp___1 >> 3));
#line 202
      samples += step___19;
#line 203
      ntom -= 32768;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 170
    j --;
#line 170
    b0 -= 32;
#line 170
    window -= 16;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 208
  fr->ntom_val[channel] = (unsigned long )ntom;
#line 209
  if (final) {
#line 209
    if (channel) {
#line 209
      tmp___48 = sizeof(unsigned char );
    } else {
#line 209
      tmp___48 = 0UL;
    }
#line 209
    fr->buffer.fill = (size_t )((unsigned long )(samples - fr->buffer.data) - tmp___48);
  }
#line 211
  return (clip);
}
}
#line 41 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
int synth_stereo_wrap(float *bandPtr_l , float *bandPtr_r , mpg123_handle *fr ) ;
#line 45
int synth_1to1(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 46
int synth_1to1_dither(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 47
int synth_1to1_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 48
int synth_1to1_i586(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 49
int synth_1to1_i586_dither(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 50
int synth_1to1_mmx(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 51
int synth_1to1_3dnow(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 52
int synth_1to1_sse(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 54
int synth_1to1_3dnowext(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 65
int synth_1to1_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 66
int synth_1to1_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 70
int synth_2to1(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 71
int synth_2to1_dither(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 72
int synth_2to1_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 73
int synth_2to1_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 74
int synth_2to1_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 75
int synth_4to1(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 76
int synth_4to1_dither(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 77
int synth_4to1_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 78
int synth_4to1_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 79
int synth_4to1_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 83
int synth_ntom(float *bandPtr , int channel , mpg123_handle *fr , int final ) ;
#line 84
int synth_ntom_mono(float *bandPtr , mpg123_handle *fr ) ;
#line 85
int synth_ntom_mono2stereo(float *bandPtr , mpg123_handle *fr ) ;
#line 39 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/sample.h"
__inline static short ftoi16(float x ) 
{ 
  union __anonunion_u_fi_58 u_fi ;

  {
#line 46
  u_fi.f = x + 12582912.0f;
#line 47
  return ((short )u_fi.i);
}
}
#line 14 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.c"
int synth_stereo_wrap(float *bandPtr_l , float *bandPtr_r , mpg123_handle *fr ) 
{ 
  int clip ;
  int tmp ;

  {
  {
#line 17
  clip = (*(fr->synth))(bandPtr_l, 0, fr, 0);
#line 18
  tmp = (*(fr->synth))(bandPtr_r, 1, fr, 1);
#line 18
  clip += tmp;
  }
#line 19
  return (clip);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___20  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_1to1(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;

  {
#line 34
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 16;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    if ((double )sum > 32767.0) {
#line 125
      *samples = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      *samples = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      *samples = (short )sum;
    }
#line 85
    j --;
#line 85
    b0 += 0;
#line 85
    window += 16;
#line 85
    samples += step___20;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    *samples = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    *samples = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    *samples = (short )sum___0;
  }
#line 141
  samples += step___20;
#line 142
  b0 -= 16;
#line 143
  window -= 32;
#line 145
  window += bo1 << 1;
#line 147
  j = 15;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      *samples = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      *samples = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      *samples = (short )sum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 32;
#line 147
    window -= 16;
#line 147
    samples += step___20;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 64UL * sizeof(short ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_1to1_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  short samples_tmp[64] ;
  short *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[0][0]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 32)) {
#line 37
      goto while_break;
    }
#line 39
    *((short *)samples) = *tmp1;
#line 40
    samples += sizeof(short );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 32UL * sizeof(short ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_1to1_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[0][0]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 64UL * sizeof(short );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 32)) {
#line 57
      goto while_break;
    }
#line 59
    *((short *)samples + 1) = *((short *)samples + 0);
#line 60
    samples += 2UL * sizeof(short );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___21  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_1to1_dither(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;

  {
#line 34
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 53
    fr->ditherindex -= 32;
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 61
  if (65536 - fr->ditherindex < 32) {
#line 61
    fr->ditherindex = 0;
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 16;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 124
    sum += *(fr->dithernoise + fr->ditherindex);
#line 124
    (fr->ditherindex) ++;
#line 125
    if ((double )sum > 32767.0) {
#line 125
      *samples = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      *samples = (short)-32768;
#line 125
      clip ++;
    } else {
      {
#line 125
      *samples = ftoi16(sum);
      }
    }
#line 85
    j --;
#line 85
    b0 += 0;
#line 85
    window += 16;
#line 85
    samples += step___21;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 139
  sum___0 += *(fr->dithernoise + fr->ditherindex);
#line 139
  (fr->ditherindex) ++;
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    *samples = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    *samples = (short)-32768;
#line 140
    clip ++;
  } else {
    {
#line 140
    *samples = ftoi16(sum___0);
    }
  }
#line 141
  samples += step___21;
#line 142
  b0 -= 16;
#line 143
  window -= 32;
#line 145
  window += bo1 << 1;
#line 147
  j = 15;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 185
    sum___1 += *(fr->dithernoise + fr->ditherindex);
#line 185
    (fr->ditherindex) ++;
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      *samples = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      *samples = (short)-32768;
#line 186
      clip ++;
    } else {
      {
#line 186
      *samples = ftoi16(sum___1);
      }
    }
#line 147
    j --;
#line 147
    b0 -= 32;
#line 147
    window -= 16;
#line 147
    samples += step___21;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 64UL * sizeof(short ));
  }
#line 192
  return (clip);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___22  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_1to1_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float sum___0 ;
  float sum___1 ;

  {
#line 34
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 16;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    if ((double )sum > 32767.0) {
#line 125
      *samples = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      *samples = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      *samples = (short )sum;
    }
#line 85
    j --;
#line 85
    b0 += 16;
#line 85
    window += 32;
#line 85
    samples += step___22;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    *samples = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    *samples = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    *samples = (short )sum___0;
  }
#line 141
  samples += step___22;
#line 142
  b0 -= 16;
#line 143
  window -= 32;
#line 145
  window += bo1 << 1;
#line 147
  j = 15;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      *samples = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      *samples = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      *samples = (short )sum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 16;
#line 147
    window -= 32;
#line 147
    samples += step___22;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 64UL * sizeof(short ));
  }
#line 192
  return (clip);
}
}
#line 82 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.c"
extern int synth_1to1_i586_asm(float *bandPtr , int channel , unsigned char *out ,
                               unsigned char *buffs , int *bo , float *decwin ) ;
#line 84 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.c"
int synth_1to1_i586(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int ret ;

  {
#line 87
  if (fr->have_eq_settings) {
    {
#line 87
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
  {
#line 89
  ret = synth_1to1_i586_asm(bandPtr, channel, fr->buffer.data + fr->buffer.fill, fr->rawbuffs,
                            & fr->bo, fr->decwin);
  }
#line 90
  if (final) {
#line 90
    fr->buffer.fill += 128U;
  }
#line 91
  return (ret);
}
}
#line 97
extern int synth_1to1_i586_asm_dither(float *bandPtr , int channel , unsigned char *out ,
                                      unsigned char *buffs , int *bo , float *decwin ,
                                      float *dithernoise ) ;
#line 99 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.c"
int synth_1to1_i586_dither(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int ret ;
  int bo_dither[2] ;
  void *__cil_tmp7 ;

  {
#line 103
  if (fr->have_eq_settings) {
    {
#line 103
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
  {
#line 106
  bo_dither[0] = fr->bo;
#line 107
  bo_dither[1] = fr->ditherindex;
#line 108
  ret = synth_1to1_i586_asm_dither(bandPtr, channel, fr->buffer.data + fr->buffer.fill,
                                   fr->rawbuffs, bo_dither, fr->decwin, fr->dithernoise);
#line 109
  fr->bo = bo_dither[0];
#line 110
  fr->ditherindex = bo_dither[1];
  }
#line 112
  if (final) {
#line 112
    fr->buffer.fill += 128U;
  }
#line 113
  return (ret);
}
}
#line 119
extern void do_equalizer_3dnow(float *bandPtr , int channel , float (*equalizer)[32] ) ;
#line 120
extern int synth_1to1_3dnow_asm(float *bandPtr , int channel , unsigned char *out ,
                                unsigned char *buffs , int *bo , float *decwin ) ;
#line 122 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.c"
int synth_1to1_3dnow(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  int ret ;
  int tmp ;

  {
#line 126
  if (fr->have_eq_settings) {
    {
#line 126
    do_equalizer_3dnow(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
  {
#line 130
  tmp = synth_1to1_3dnow_asm(bandPtr, channel, fr->buffer.data + fr->buffer.fill,
                             fr->rawbuffs, & fr->bo, fr->decwin);
#line 130
  ret = tmp;
  }
#line 131
  if (final) {
#line 131
    fr->buffer.fill += 128U;
  }
#line 132
  return (ret);
}
}
#line 138
extern int synth_1to1_MMX(float *bandPtr , int channel , short *out , short *buffs ,
                          int *bo , float *decwins ) ;
#line 140 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.c"
int synth_1to1_mmx(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 


  {
#line 142
  if (fr->have_eq_settings) {
    {
#line 142
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
  {
#line 145
  synth_1to1_MMX(bandPtr, channel, (short *)(fr->buffer.data + fr->buffer.fill), (short *)fr->rawbuffs,
                 & fr->bo, fr->decwins);
  }
#line 146
  if (final) {
#line 146
    fr->buffer.fill += 128U;
  }
#line 147
  return (0);
}
}
#line 243
extern void synth_1to1_sse_asm(float *bandPtr , int channel , short *samples , short *buffs ,
                               int *bo , float *decwin ) ;
#line 245 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.c"
int synth_1to1_sse(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 


  {
#line 247
  if (fr->have_eq_settings) {
    {
#line 247
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
  {
#line 249
  synth_1to1_sse_asm(bandPtr, channel, (short *)(fr->buffer.data + fr->buffer.fill),
                     (short *)fr->rawbuffs, & fr->bo, fr->decwins);
  }
#line 250
  if (final) {
#line 250
    fr->buffer.fill += 128U;
  }
#line 251
  return (0);
}
}
#line 258
extern void synth_1to1_3dnowext_asm(float *bandPtr , int channel , short *samples ,
                                    short *buffs , int *bo , float *decwin ) ;
#line 260 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.c"
int synth_1to1_3dnowext(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 


  {
#line 262
  if (fr->have_eq_settings) {
    {
#line 262
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
  {
#line 264
  synth_1to1_3dnowext_asm(bandPtr, channel, (short *)(fr->buffer.data + fr->buffer.fill),
                          (short *)fr->rawbuffs, & fr->bo, fr->decwins);
  }
#line 265
  if (final) {
#line 265
    fr->buffer.fill += 128U;
  }
#line 266
  return (0);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___23  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_2to1(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;

  {
#line 34
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    if ((double )sum > 32767.0) {
#line 125
      *samples = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      *samples = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      *samples = (short )sum;
    }
#line 85
    j --;
#line 85
    b0 += 16;
#line 85
    window += 48;
#line 85
    samples += step___23;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    *samples = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    *samples = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    *samples = (short )sum___0;
  }
#line 141
  samples += step___23;
#line 142
  b0 -= 32;
#line 143
  window -= 64;
#line 145
  window += bo1 << 1;
#line 147
  j = 7;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      *samples = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      *samples = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      *samples = (short )sum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 48;
#line 147
    window -= 48;
#line 147
    samples += step___23;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 32UL * sizeof(short ));
  }
#line 192
  return (clip);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___24  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_2to1_dither(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;

  {
#line 34
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 53
    fr->ditherindex -= 32;
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 61
  if (65536 - fr->ditherindex < 32) {
#line 61
    fr->ditherindex = 0;
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 124
    sum += *(fr->dithernoise + fr->ditherindex);
#line 124
    fr->ditherindex += 2;
#line 125
    if ((double )sum > 32767.0) {
#line 125
      *samples = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      *samples = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      *samples = (short )sum;
    }
#line 85
    j --;
#line 85
    b0 += 16;
#line 85
    window += 48;
#line 85
    samples += step___24;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 139
  sum___0 += *(fr->dithernoise + fr->ditherindex);
#line 139
  fr->ditherindex += 2;
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    *samples = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    *samples = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    *samples = (short )sum___0;
  }
#line 141
  samples += step___24;
#line 142
  b0 -= 32;
#line 143
  window -= 64;
#line 145
  window += bo1 << 1;
#line 147
  j = 7;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 185
    sum___1 += *(fr->dithernoise + fr->ditherindex);
#line 185
    fr->ditherindex += 2;
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      *samples = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      *samples = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      *samples = (short )sum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 48;
#line 147
    window -= 48;
#line 147
    samples += step___24;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 32UL * sizeof(short ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_2to1_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  short samples_tmp[32] ;
  short *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[1][0]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 16)) {
#line 37
      goto while_break;
    }
#line 39
    *((short *)samples) = *tmp1;
#line 40
    samples += sizeof(short );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 16UL * sizeof(short ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_2to1_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[1][0]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 32UL * sizeof(short );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 16)) {
#line 57
      goto while_break;
    }
#line 59
    *((short *)samples + 1) = *((short *)samples + 0);
#line 60
    samples += 2UL * sizeof(short );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___25  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_2to1_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float sum___0 ;
  float sum___1 ;

  {
#line 34
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    if ((double )sum > 32767.0) {
#line 125
      *samples = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      *samples = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      *samples = (short )sum;
    }
#line 85
    j --;
#line 85
    b0 += 32;
#line 85
    window += 64;
#line 85
    samples += step___25;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    *samples = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    *samples = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    *samples = (short )sum___0;
  }
#line 141
  samples += step___25;
#line 142
  b0 -= 32;
#line 143
  window -= 64;
#line 145
  window += bo1 << 1;
#line 147
  j = 7;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      *samples = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      *samples = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      *samples = (short )sum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 32;
#line 147
    window -= 64;
#line 147
    samples += step___25;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 32UL * sizeof(short ));
  }
#line 192
  return (clip);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___26  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_4to1(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;

  {
#line 34
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 125
    if ((double )sum > 32767.0) {
#line 125
      *samples = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      *samples = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      *samples = (short )sum;
    }
#line 85
    j --;
#line 85
    b0 += 48;
#line 85
    window += 112;
#line 85
    samples += step___26;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    *samples = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    *samples = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    *samples = (short )sum___0;
  }
#line 141
  samples += step___26;
#line 142
  b0 -= 64;
#line 143
  window -= 128;
#line 145
  window += bo1 << 1;
#line 147
  j = 3;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      *samples = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      *samples = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      *samples = (short )sum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 80;
#line 147
    window -= 112;
#line 147
    samples += step___26;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 16UL * sizeof(short ));
  }
#line 192
  return (clip);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___27  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_4to1_dither(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;

  {
#line 34
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 53
    fr->ditherindex -= 32;
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 61
  if (65536 - fr->ditherindex < 32) {
#line 61
    fr->ditherindex = 0;
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 89
    tmp = window;
#line 89
    window ++;
#line 89
    tmp___0 = b0;
#line 89
    b0 ++;
#line 89
    sum = *tmp * *tmp___0;
#line 90
    tmp___1 = window;
#line 90
    window ++;
#line 90
    tmp___2 = b0;
#line 90
    b0 ++;
#line 90
    sum -= *tmp___1 * *tmp___2;
#line 91
    tmp___3 = window;
#line 91
    window ++;
#line 91
    tmp___4 = b0;
#line 91
    b0 ++;
#line 91
    sum += *tmp___3 * *tmp___4;
#line 92
    tmp___5 = window;
#line 92
    window ++;
#line 92
    tmp___6 = b0;
#line 92
    b0 ++;
#line 92
    sum -= *tmp___5 * *tmp___6;
#line 93
    tmp___7 = window;
#line 93
    window ++;
#line 93
    tmp___8 = b0;
#line 93
    b0 ++;
#line 93
    sum += *tmp___7 * *tmp___8;
#line 94
    tmp___9 = window;
#line 94
    window ++;
#line 94
    tmp___10 = b0;
#line 94
    b0 ++;
#line 94
    sum -= *tmp___9 * *tmp___10;
#line 95
    tmp___11 = window;
#line 95
    window ++;
#line 95
    tmp___12 = b0;
#line 95
    b0 ++;
#line 95
    sum += *tmp___11 * *tmp___12;
#line 96
    tmp___13 = window;
#line 96
    window ++;
#line 96
    tmp___14 = b0;
#line 96
    b0 ++;
#line 96
    sum -= *tmp___13 * *tmp___14;
#line 97
    tmp___15 = window;
#line 97
    window ++;
#line 97
    tmp___16 = b0;
#line 97
    b0 ++;
#line 97
    sum += *tmp___15 * *tmp___16;
#line 98
    tmp___17 = window;
#line 98
    window ++;
#line 98
    tmp___18 = b0;
#line 98
    b0 ++;
#line 98
    sum -= *tmp___17 * *tmp___18;
#line 99
    tmp___19 = window;
#line 99
    window ++;
#line 99
    tmp___20 = b0;
#line 99
    b0 ++;
#line 99
    sum += *tmp___19 * *tmp___20;
#line 100
    tmp___21 = window;
#line 100
    window ++;
#line 100
    tmp___22 = b0;
#line 100
    b0 ++;
#line 100
    sum -= *tmp___21 * *tmp___22;
#line 101
    tmp___23 = window;
#line 101
    window ++;
#line 101
    tmp___24 = b0;
#line 101
    b0 ++;
#line 101
    sum += *tmp___23 * *tmp___24;
#line 102
    tmp___25 = window;
#line 102
    window ++;
#line 102
    tmp___26 = b0;
#line 102
    b0 ++;
#line 102
    sum -= *tmp___25 * *tmp___26;
#line 103
    tmp___27 = window;
#line 103
    window ++;
#line 103
    tmp___28 = b0;
#line 103
    b0 ++;
#line 103
    sum += *tmp___27 * *tmp___28;
#line 104
    tmp___29 = window;
#line 104
    window ++;
#line 104
    tmp___30 = b0;
#line 104
    b0 ++;
#line 104
    sum -= *tmp___29 * *tmp___30;
#line 124
    sum += *(fr->dithernoise + fr->ditherindex);
#line 124
    fr->ditherindex += 4;
#line 125
    if ((double )sum > 32767.0) {
#line 125
      *samples = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      *samples = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      *samples = (short )sum;
    }
#line 85
    j --;
#line 85
    b0 += 48;
#line 85
    window += 112;
#line 85
    samples += step___27;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 139
  sum___0 += *(fr->dithernoise + fr->ditherindex);
#line 139
  fr->ditherindex += 4;
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    *samples = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    *samples = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    *samples = (short )sum___0;
  }
#line 141
  samples += step___27;
#line 142
  b0 -= 64;
#line 143
  window -= 128;
#line 145
  window += bo1 << 1;
#line 147
  j = 3;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 151
    window --;
#line 151
    tmp___31 = b0;
#line 151
    b0 ++;
#line 151
    sum___1 = - (*window * *tmp___31);
#line 152
    window --;
#line 152
    tmp___32 = b0;
#line 152
    b0 ++;
#line 152
    sum___1 -= *window * *tmp___32;
#line 153
    window --;
#line 153
    tmp___33 = b0;
#line 153
    b0 ++;
#line 153
    sum___1 -= *window * *tmp___33;
#line 154
    window --;
#line 154
    tmp___34 = b0;
#line 154
    b0 ++;
#line 154
    sum___1 -= *window * *tmp___34;
#line 155
    window --;
#line 155
    tmp___35 = b0;
#line 155
    b0 ++;
#line 155
    sum___1 -= *window * *tmp___35;
#line 156
    window --;
#line 156
    tmp___36 = b0;
#line 156
    b0 ++;
#line 156
    sum___1 -= *window * *tmp___36;
#line 157
    window --;
#line 157
    tmp___37 = b0;
#line 157
    b0 ++;
#line 157
    sum___1 -= *window * *tmp___37;
#line 158
    window --;
#line 158
    tmp___38 = b0;
#line 158
    b0 ++;
#line 158
    sum___1 -= *window * *tmp___38;
#line 159
    window --;
#line 159
    tmp___39 = b0;
#line 159
    b0 ++;
#line 159
    sum___1 -= *window * *tmp___39;
#line 160
    window --;
#line 160
    tmp___40 = b0;
#line 160
    b0 ++;
#line 160
    sum___1 -= *window * *tmp___40;
#line 161
    window --;
#line 161
    tmp___41 = b0;
#line 161
    b0 ++;
#line 161
    sum___1 -= *window * *tmp___41;
#line 162
    window --;
#line 162
    tmp___42 = b0;
#line 162
    b0 ++;
#line 162
    sum___1 -= *window * *tmp___42;
#line 163
    window --;
#line 163
    tmp___43 = b0;
#line 163
    b0 ++;
#line 163
    sum___1 -= *window * *tmp___43;
#line 164
    window --;
#line 164
    tmp___44 = b0;
#line 164
    b0 ++;
#line 164
    sum___1 -= *window * *tmp___44;
#line 165
    window --;
#line 165
    tmp___45 = b0;
#line 165
    b0 ++;
#line 165
    sum___1 -= *window * *tmp___45;
#line 166
    window --;
#line 166
    tmp___46 = b0;
#line 166
    b0 ++;
#line 166
    sum___1 -= *window * *tmp___46;
#line 185
    sum___1 += *(fr->dithernoise + fr->ditherindex);
#line 185
    fr->ditherindex += 4;
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      *samples = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      *samples = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      *samples = (short )sum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 80;
#line 147
    window -= 112;
#line 147
    samples += step___27;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 16UL * sizeof(short ));
  }
#line 192
  return (clip);
}
}
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_4to1_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  short samples_tmp[16] ;
  short *tmp1 ;
  int i ;
  int ret ;
  unsigned char *samples ;
  int pnt ;
  void *__cil_tmp9 ;

  {
  {
#line 24
  tmp1 = samples_tmp;
#line 28
  samples = fr->buffer.data;
#line 29
  pnt = (int )fr->buffer.fill;
#line 30
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 31
  fr->buffer.fill = (size_t )0;
#line 32
  ret = (*(fr->synths.plain[2][0]))(bandPtr, 0, fr, 0);
#line 33
  fr->buffer.data = samples;
#line 36
  samples += pnt;
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 8)) {
#line 37
      goto while_break;
    }
#line 39
    *((short *)samples) = *tmp1;
#line 40
    samples += sizeof(short );
#line 41
    tmp1 += 2;
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  fr->buffer.fill = (size_t )((unsigned long )pnt + 8UL * sizeof(short ));
#line 45
  return (ret);
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_mono.h"
int synth_4to1_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  int i ;
  int ret ;
  unsigned char *samples ;

  {
  {
#line 52
  samples = fr->buffer.data;
#line 54
  ret = (*(fr->synths.plain[2][0]))(bandPtr, 0, fr, 1);
#line 55
  samples += (unsigned long )fr->buffer.fill - 16UL * sizeof(short );
#line 57
  i = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 8)) {
#line 57
      goto while_break;
    }
#line 59
    *((short *)samples + 1) = *((short *)samples + 0);
#line 60
    samples += 2UL * sizeof(short );
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (ret);
}
}
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
static int const   step___28  =    (int const   )2;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth.h"
int synth_4to1_i386(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  register int j ;
  float *window ;
  float sum ;
  float sum___0 ;
  float sum___1 ;

  {
#line 34
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 37
  clip = 0;
#line 40
  if (fr->have_eq_settings) {
    {
#line 40
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 42
  if (! channel) {
#line 44
    (fr->bo) --;
#line 45
    fr->bo &= 15;
#line 46
    buf = fr->real_buffs[0];
  } else {
#line 55
    samples ++;
#line 56
    buf = fr->real_buffs[1];
  }
#line 68
  if (fr->bo & 1) {
    {
#line 70
    b0 = *(buf + 0);
#line 71
    bo1 = fr->bo;
#line 72
    dct64_i386(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 76
    b0 = *(buf + 1);
#line 77
    bo1 = fr->bo + 1;
#line 78
    dct64_i386(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 83
  window = (fr->decwin + 16) - bo1;
#line 85
  j = 4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! j) {
#line 85
      goto while_break;
    }
#line 106
    sum = *(window + 0) * *(b0 + 0);
#line 107
    sum -= *(window + 1) * *(b0 + 1);
#line 108
    sum += *(window + 2) * *(b0 + 2);
#line 109
    sum -= *(window + 3) * *(b0 + 3);
#line 110
    sum += *(window + 4) * *(b0 + 4);
#line 111
    sum -= *(window + 5) * *(b0 + 5);
#line 112
    sum += *(window + 6) * *(b0 + 6);
#line 113
    sum -= *(window + 7) * *(b0 + 7);
#line 114
    sum += *(window + 8) * *(b0 + 8);
#line 115
    sum -= *(window + 9) * *(b0 + 9);
#line 116
    sum += *(window + 10) * *(b0 + 10);
#line 117
    sum -= *(window + 11) * *(b0 + 11);
#line 118
    sum += *(window + 12) * *(b0 + 12);
#line 119
    sum -= *(window + 13) * *(b0 + 13);
#line 120
    sum += *(window + 14) * *(b0 + 14);
#line 121
    sum -= *(window + 15) * *(b0 + 15);
#line 125
    if ((double )sum > 32767.0) {
#line 125
      *samples = (short)32767;
#line 125
      clip ++;
    } else
#line 125
    if ((double )sum < - 32768.0) {
#line 125
      *samples = (short)-32768;
#line 125
      clip ++;
    } else {
#line 125
      *samples = (short )sum;
    }
#line 85
    j --;
#line 85
    b0 += 64;
#line 85
    window += 128;
#line 85
    samples += step___28;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  sum___0 = *(window + 0) * *(b0 + 0);
#line 131
  sum___0 += *(window + 2) * *(b0 + 2);
#line 132
  sum___0 += *(window + 4) * *(b0 + 4);
#line 133
  sum___0 += *(window + 6) * *(b0 + 6);
#line 134
  sum___0 += *(window + 8) * *(b0 + 8);
#line 135
  sum___0 += *(window + 10) * *(b0 + 10);
#line 136
  sum___0 += *(window + 12) * *(b0 + 12);
#line 137
  sum___0 += *(window + 14) * *(b0 + 14);
#line 140
  if ((double )sum___0 > 32767.0) {
#line 140
    *samples = (short)32767;
#line 140
    clip ++;
  } else
#line 140
  if ((double )sum___0 < - 32768.0) {
#line 140
    *samples = (short)-32768;
#line 140
    clip ++;
  } else {
#line 140
    *samples = (short )sum___0;
  }
#line 141
  samples += step___28;
#line 142
  b0 -= 64;
#line 143
  window -= 128;
#line 145
  window += bo1 << 1;
#line 147
  j = 3;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! j) {
#line 147
      goto while_break___0;
    }
#line 168
    sum___1 = - (*(window + -1) * *(b0 + 0));
#line 169
    sum___1 -= *(window + -2) * *(b0 + 1);
#line 170
    sum___1 -= *(window + -3) * *(b0 + 2);
#line 171
    sum___1 -= *(window + -4) * *(b0 + 3);
#line 172
    sum___1 -= *(window + -5) * *(b0 + 4);
#line 173
    sum___1 -= *(window + -6) * *(b0 + 5);
#line 174
    sum___1 -= *(window + -7) * *(b0 + 6);
#line 175
    sum___1 -= *(window + -8) * *(b0 + 7);
#line 176
    sum___1 -= *(window + -9) * *(b0 + 8);
#line 177
    sum___1 -= *(window + -10) * *(b0 + 9);
#line 178
    sum___1 -= *(window + -11) * *(b0 + 10);
#line 179
    sum___1 -= *(window + -12) * *(b0 + 11);
#line 180
    sum___1 -= *(window + -13) * *(b0 + 12);
#line 181
    sum___1 -= *(window + -14) * *(b0 + 13);
#line 182
    sum___1 -= *(window + -15) * *(b0 + 14);
#line 183
    sum___1 -= *(window + 0) * *(b0 + 15);
#line 186
    if ((double )sum___1 > 32767.0) {
#line 186
      *samples = (short)32767;
#line 186
      clip ++;
    } else
#line 186
    if ((double )sum___1 < - 32768.0) {
#line 186
      *samples = (short)-32768;
#line 186
      clip ++;
    } else {
#line 186
      *samples = (short )sum___1;
    }
#line 147
    j --;
#line 147
    b0 -= 64;
#line 147
    window -= 128;
#line 147
    samples += step___28;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (final) {
#line 190
    fr->buffer.fill = (size_t )((unsigned long )fr->buffer.fill + 16UL * sizeof(short ));
  }
#line 192
  return (clip);
}
}
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_mono(float *bandPtr , mpg123_handle *fr ) 
{ 
  short samples_tmp[512] ;
  short *tmp1 ;
  size_t i ;
  int ret ;
  size_t pnt ;
  unsigned char *samples ;
  void *__cil_tmp9 ;

  {
  {
#line 23
  tmp1 = samples_tmp;
#line 27
  pnt = fr->buffer.fill;
#line 28
  samples = fr->buffer.data;
#line 29
  fr->buffer.data = (unsigned char *)(samples_tmp);
#line 30
  fr->buffer.fill = (size_t )0;
#line 31
  ret = synth_ntom(bandPtr, 0, fr, 1);
#line 32
  fr->buffer.data = samples;
#line 34
  samples += pnt;
#line 35
  i = (size_t )0;
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((unsigned long )i < (unsigned long )fr->buffer.fill / (2UL * sizeof(short )))) {
#line 35
      goto while_break;
    }
#line 37
    *((short *)samples) = *tmp1;
#line 38
    samples += sizeof(short );
#line 39
    tmp1 += 2;
#line 35
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  fr->buffer.fill = pnt + fr->buffer.fill / 2U;
#line 43
  return (ret);
}
}
#line 47 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom_mono2stereo(float *bandPtr , mpg123_handle *fr ) 
{ 
  size_t i ;
  int ret ;
  size_t pnt1 ;
  unsigned char *samples ;

  {
  {
#line 51
  pnt1 = fr->buffer.fill;
#line 52
  samples = fr->buffer.data + pnt1;
#line 54
  ret = synth_ntom(bandPtr, 0, fr, 1);
#line 56
  i = (size_t )0;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )i < (unsigned long )(fr->buffer.fill - pnt1) / (2UL * sizeof(short )))) {
#line 56
      goto while_break;
    }
#line 58
    *((short *)samples + 1) = *((short *)samples + 0);
#line 59
    samples += 2UL * sizeof(short );
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (ret);
}
}
#line 68 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
static int const   step___29  =    (int const   )2;
#line 66 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/synth_ntom.h"
int synth_ntom(float *bandPtr , int channel , mpg123_handle *fr , int final ) 
{ 
  short *samples ;
  float *b0 ;
  float **buf ;
  int clip ;
  int bo1 ;
  int ntom ;
  unsigned long tmp ;
  register int j ;
  float *window ;
  float sum ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float *tmp___31 ;
  float sum___0 ;
  float sum___1 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  float *tmp___43 ;
  float *tmp___44 ;
  float *tmp___45 ;
  float *tmp___46 ;
  float *tmp___47 ;
  unsigned long tmp___48 ;

  {
#line 69
  samples = (short *)(fr->buffer.data + fr->buffer.fill);
#line 72
  clip = 0;
#line 76
  if (fr->have_eq_settings) {
    {
#line 76
    do_equalizer(bandPtr, channel, (float (*)[32])(fr->equalizer));
    }
  }
#line 78
  if (! channel) {
#line 80
    (fr->bo) --;
#line 81
    fr->bo &= 15;
#line 82
    buf = fr->real_buffs[0];
#line 83
    tmp = fr->ntom_val[0];
#line 83
    fr->ntom_val[1] = tmp;
#line 83
    ntom = (int )tmp;
  } else {
#line 87
    samples ++;
#line 88
    buf = fr->real_buffs[1];
#line 89
    ntom = (int )fr->ntom_val[1];
  }
#line 92
  if (fr->bo & 1) {
    {
#line 94
    b0 = *(buf + 0);
#line 95
    bo1 = fr->bo;
#line 96
    dct64(*(buf + 1) + ((fr->bo + 1) & 15), *(buf + 0) + fr->bo, bandPtr);
    }
  } else {
    {
#line 100
    b0 = *(buf + 1);
#line 101
    bo1 = fr->bo + 1;
#line 102
    dct64(*(buf + 0) + fr->bo, (*(buf + 1) + fr->bo) + 1, bandPtr);
    }
  }
#line 107
  window = (fr->decwin + 16) - bo1;
#line 109
  j = 16;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! j) {
#line 109
      goto while_break;
    }
#line 113
    ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 114
    if (ntom < 32768) {
#line 116
      window += 16;
#line 117
      b0 += 16;
#line 118
      goto __Cont;
    }
#line 121
    tmp___0 = window;
#line 121
    window ++;
#line 121
    tmp___1 = b0;
#line 121
    b0 ++;
#line 121
    sum = *tmp___0 * *tmp___1;
#line 122
    tmp___2 = window;
#line 122
    window ++;
#line 122
    tmp___3 = b0;
#line 122
    b0 ++;
#line 122
    sum -= *tmp___2 * *tmp___3;
#line 123
    tmp___4 = window;
#line 123
    window ++;
#line 123
    tmp___5 = b0;
#line 123
    b0 ++;
#line 123
    sum += *tmp___4 * *tmp___5;
#line 124
    tmp___6 = window;
#line 124
    window ++;
#line 124
    tmp___7 = b0;
#line 124
    b0 ++;
#line 124
    sum -= *tmp___6 * *tmp___7;
#line 125
    tmp___8 = window;
#line 125
    window ++;
#line 125
    tmp___9 = b0;
#line 125
    b0 ++;
#line 125
    sum += *tmp___8 * *tmp___9;
#line 126
    tmp___10 = window;
#line 126
    window ++;
#line 126
    tmp___11 = b0;
#line 126
    b0 ++;
#line 126
    sum -= *tmp___10 * *tmp___11;
#line 127
    tmp___12 = window;
#line 127
    window ++;
#line 127
    tmp___13 = b0;
#line 127
    b0 ++;
#line 127
    sum += *tmp___12 * *tmp___13;
#line 128
    tmp___14 = window;
#line 128
    window ++;
#line 128
    tmp___15 = b0;
#line 128
    b0 ++;
#line 128
    sum -= *tmp___14 * *tmp___15;
#line 129
    tmp___16 = window;
#line 129
    window ++;
#line 129
    tmp___17 = b0;
#line 129
    b0 ++;
#line 129
    sum += *tmp___16 * *tmp___17;
#line 130
    tmp___18 = window;
#line 130
    window ++;
#line 130
    tmp___19 = b0;
#line 130
    b0 ++;
#line 130
    sum -= *tmp___18 * *tmp___19;
#line 131
    tmp___20 = window;
#line 131
    window ++;
#line 131
    tmp___21 = b0;
#line 131
    b0 ++;
#line 131
    sum += *tmp___20 * *tmp___21;
#line 132
    tmp___22 = window;
#line 132
    window ++;
#line 132
    tmp___23 = b0;
#line 132
    b0 ++;
#line 132
    sum -= *tmp___22 * *tmp___23;
#line 133
    tmp___24 = window;
#line 133
    window ++;
#line 133
    tmp___25 = b0;
#line 133
    b0 ++;
#line 133
    sum += *tmp___24 * *tmp___25;
#line 134
    tmp___26 = window;
#line 134
    window ++;
#line 134
    tmp___27 = b0;
#line 134
    b0 ++;
#line 134
    sum -= *tmp___26 * *tmp___27;
#line 135
    tmp___28 = window;
#line 135
    window ++;
#line 135
    tmp___29 = b0;
#line 135
    b0 ++;
#line 135
    sum += *tmp___28 * *tmp___29;
#line 136
    tmp___30 = window;
#line 136
    window ++;
#line 136
    tmp___31 = b0;
#line 136
    b0 ++;
#line 136
    sum -= *tmp___30 * *tmp___31;
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 138
      if (! (ntom >= 32768)) {
#line 138
        goto while_break___0;
      }
#line 140
      if ((double )sum > 32767.0) {
#line 140
        *samples = (short)32767;
#line 140
        clip ++;
      } else
#line 140
      if ((double )sum < - 32768.0) {
#line 140
        *samples = (short)-32768;
#line 140
        clip ++;
      } else {
#line 140
        *samples = (short )sum;
      }
#line 141
      samples += step___29;
#line 142
      ntom -= 32768;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 109
    j --;
#line 109
    window += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 147
  if (ntom >= 32768) {
#line 150
    sum___0 = *(window + 0) * *(b0 + 0);
#line 151
    sum___0 += *(window + 2) * *(b0 + 2);
#line 152
    sum___0 += *(window + 4) * *(b0 + 4);
#line 153
    sum___0 += *(window + 6) * *(b0 + 6);
#line 154
    sum___0 += *(window + 8) * *(b0 + 8);
#line 155
    sum___0 += *(window + 10) * *(b0 + 10);
#line 156
    sum___0 += *(window + 12) * *(b0 + 12);
#line 157
    sum___0 += *(window + 14) * *(b0 + 14);
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (ntom >= 32768)) {
#line 159
        goto while_break___1;
      }
#line 161
      if ((double )sum___0 > 32767.0) {
#line 161
        *samples = (short)32767;
#line 161
        clip ++;
      } else
#line 161
      if ((double )sum___0 < - 32768.0) {
#line 161
        *samples = (short)-32768;
#line 161
        clip ++;
      } else {
#line 161
        *samples = (short )sum___0;
      }
#line 162
      samples += step___29;
#line 163
      ntom -= 32768;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 167
  b0 -= 16;
#line 167
  window -= 32;
#line 168
  window += bo1 << 1;
#line 170
  j = 15;
  {
#line 170
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 170
    if (! j) {
#line 170
      goto while_break___2;
    }
#line 174
    ntom = (int )((unsigned long )ntom + fr->ntom_step);
#line 175
    if (ntom < 32768) {
#line 177
      window -= 16;
#line 178
      b0 += 16;
#line 179
      goto __Cont___0;
    }
#line 182
    window --;
#line 182
    tmp___32 = b0;
#line 182
    b0 ++;
#line 182
    sum___1 = - *window * *tmp___32;
#line 183
    window --;
#line 183
    tmp___33 = b0;
#line 183
    b0 ++;
#line 183
    sum___1 -= *window * *tmp___33;
#line 184
    window --;
#line 184
    tmp___34 = b0;
#line 184
    b0 ++;
#line 184
    sum___1 -= *window * *tmp___34;
#line 185
    window --;
#line 185
    tmp___35 = b0;
#line 185
    b0 ++;
#line 185
    sum___1 -= *window * *tmp___35;
#line 186
    window --;
#line 186
    tmp___36 = b0;
#line 186
    b0 ++;
#line 186
    sum___1 -= *window * *tmp___36;
#line 187
    window --;
#line 187
    tmp___37 = b0;
#line 187
    b0 ++;
#line 187
    sum___1 -= *window * *tmp___37;
#line 188
    window --;
#line 188
    tmp___38 = b0;
#line 188
    b0 ++;
#line 188
    sum___1 -= *window * *tmp___38;
#line 189
    window --;
#line 189
    tmp___39 = b0;
#line 189
    b0 ++;
#line 189
    sum___1 -= *window * *tmp___39;
#line 190
    window --;
#line 190
    tmp___40 = b0;
#line 190
    b0 ++;
#line 190
    sum___1 -= *window * *tmp___40;
#line 191
    window --;
#line 191
    tmp___41 = b0;
#line 191
    b0 ++;
#line 191
    sum___1 -= *window * *tmp___41;
#line 192
    window --;
#line 192
    tmp___42 = b0;
#line 192
    b0 ++;
#line 192
    sum___1 -= *window * *tmp___42;
#line 193
    window --;
#line 193
    tmp___43 = b0;
#line 193
    b0 ++;
#line 193
    sum___1 -= *window * *tmp___43;
#line 194
    window --;
#line 194
    tmp___44 = b0;
#line 194
    b0 ++;
#line 194
    sum___1 -= *window * *tmp___44;
#line 195
    window --;
#line 195
    tmp___45 = b0;
#line 195
    b0 ++;
#line 195
    sum___1 -= *window * *tmp___45;
#line 196
    window --;
#line 196
    tmp___46 = b0;
#line 196
    b0 ++;
#line 196
    sum___1 -= *window * *tmp___46;
#line 197
    window --;
#line 197
    tmp___47 = b0;
#line 197
    b0 ++;
#line 197
    sum___1 -= *window * *tmp___47;
    {
#line 199
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 199
      if (! (ntom >= 32768)) {
#line 199
        goto while_break___3;
      }
#line 201
      if ((double )sum___1 > 32767.0) {
#line 201
        *samples = (short)32767;
#line 201
        clip ++;
      } else
#line 201
      if ((double )sum___1 < - 32768.0) {
#line 201
        *samples = (short)-32768;
#line 201
        clip ++;
      } else {
#line 201
        *samples = (short )sum___1;
      }
#line 202
      samples += step___29;
#line 203
      ntom -= 32768;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 170
    j --;
#line 170
    b0 -= 32;
#line 170
    window -= 16;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 208
  fr->ntom_val[channel] = (unsigned long )ntom;
#line 209
  if (final) {
#line 209
    if (channel) {
#line 209
      tmp___48 = sizeof(short );
    } else {
#line 209
      tmp___48 = 0UL;
    }
#line 209
    fr->buffer.fill = (size_t )((unsigned long )((unsigned char *)samples - fr->buffer.data) - tmp___48);
  }
#line 211
  return (clip);
}
}
#line 117 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
void ntom_set_ntom(mpg123_handle *fr , off_t num ) ;
#line 198
int synth_ntom_set_step(mpg123_handle *fr ) ;
#line 199
unsigned long ntom_val(mpg123_handle *fr , off_t frame ) ;
#line 206
off_t ntom_frame_outsamples(mpg123_handle *fr ) ;
#line 208
off_t ntom_frmouts(mpg123_handle *fr , off_t frame ) ;
#line 209
off_t ntom_ins2outs(mpg123_handle *fr , off_t ins ) ;
#line 210
off_t ntom_frameoff(mpg123_handle *fr , off_t soff ) ;
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.h"
long frame_freq(mpg123_handle *fr ) ;
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/ntom.c"
int synth_ntom_set_step(mpg123_handle *fr ) 
{ 
  long m ;
  long n ;
  unsigned long tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 16
  m = frame_freq(fr);
#line 17
  n = fr->af.rate;
  }
#line 18
  if (! (fr->p.flags & 32L)) {
#line 18
    if (fr->p.verbose > 1) {
      {
#line 19
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Init rate converter: %ld->%ld\n",
              m, n);
      }
    }
  }
#line 21
  if (n > 96000L) {
#line 21
    goto _L;
  } else
#line 21
  if (m > 96000L) {
#line 21
    goto _L;
  } else
#line 21
  if (m <= 0L) {
#line 21
    goto _L;
  } else
#line 21
  if (n <= 0L) {
    _L: /* CIL Label */ 
#line 22
    if (! (fr->p.flags & 32L)) {
      {
#line 22
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/ntom.c:%i] error: NtoM converter: illegal rates\n",
              22);
      }
    }
#line 23
    fr->err = 3;
#line 24
    return (-1);
  }
#line 27
  n *= 32768L;
#line 28
  fr->ntom_step = (unsigned long )n / (unsigned long )m;
#line 30
  if (fr->ntom_step > 262144UL) {
#line 31
    if (! (fr->p.flags & 32L)) {
      {
#line 31
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/ntom.c:%i] error: max. 1:%i conversion allowed (%lu vs %lu)!\n",
              31, 8, fr->ntom_step, 262144UL);
      }
    }
#line 32
    fr->err = 3;
#line 33
    return (-1);
  }
  {
#line 36
  tmp = ntom_val(fr, fr->num);
#line 36
  fr->ntom_val[1] = tmp;
#line 36
  fr->ntom_val[0] = tmp;
  }
#line 37
  return (0);
}
}
#line 46 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/ntom.c"
unsigned long ntom_val(mpg123_handle *fr , off_t frame ) 
{ 
  off_t ntm ;
  off_t f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 51
  ntm = (off_t )(32768 >> 1);
#line 52
  f = (off_t )0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (f < frame)) {
#line 52
      goto while_break;
    }
#line 54
    if (fr->lay == 1) {
#line 54
      tmp___1 = 384;
    } else {
#line 54
      if (fr->lay == 2) {
#line 54
        tmp___0 = 1152;
      } else {
#line 54
        if (fr->lsf) {
#line 54
          tmp = 576;
        } else
#line 54
        if (fr->mpeg25) {
#line 54
          tmp = 576;
        } else {
#line 54
          tmp = 1152;
        }
#line 54
        tmp___0 = tmp;
      }
#line 54
      tmp___1 = tmp___0;
    }
#line 54
    ntm += (off_t )((unsigned long )tmp___1 * fr->ntom_step);
#line 55
    ntm -= (ntm / 32768LL) * 32768LL;
#line 52
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return ((unsigned long )ntm);
}
}
#line 66 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/ntom.c"
void ntom_set_ntom(mpg123_handle *fr , off_t num ) 
{ 
  unsigned long tmp ;

  {
  {
#line 68
  tmp = ntom_val(fr, num);
#line 68
  fr->ntom_val[0] = tmp;
#line 68
  fr->ntom_val[1] = tmp;
  }
#line 69
  return;
}
}
#line 73 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/ntom.c"
off_t ntom_frame_outsamples(mpg123_handle *fr ) 
{ 
  int ntm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 76
  ntm = (int )fr->ntom_val[0];
#line 77
  if (fr->lay == 1) {
#line 77
    tmp___1 = 384;
  } else {
#line 77
    if (fr->lay == 2) {
#line 77
      tmp___0 = 1152;
    } else {
#line 77
      if (fr->lsf) {
#line 77
        tmp = 576;
      } else
#line 77
      if (fr->mpeg25) {
#line 77
        tmp = 576;
      } else {
#line 77
        tmp = 1152;
      }
#line 77
      tmp___0 = tmp;
    }
#line 77
    tmp___1 = tmp___0;
  }
#line 77
  ntm = (int )((unsigned long )ntm + (unsigned long )tmp___1 * fr->ntom_step);
#line 78
  return ((off_t )(ntm / 32768));
}
}
#line 82 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/ntom.c"
off_t ntom_frmouts(mpg123_handle *fr , off_t frame ) 
{ 
  off_t f ;
  off_t soff ;
  off_t ntm ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 87
  soff = (off_t )0;
#line 88
  tmp = ntom_val(fr, (off_t )0);
#line 88
  ntm = (off_t )tmp;
  }
#line 90
  if (frame <= 0LL) {
#line 90
    return ((off_t )0);
  }
#line 91
  f = (off_t )0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (f < frame)) {
#line 91
      goto while_break;
    }
#line 93
    if (fr->lay == 1) {
#line 93
      tmp___2 = 384;
    } else {
#line 93
      if (fr->lay == 2) {
#line 93
        tmp___1 = 1152;
      } else {
#line 93
        if (fr->lsf) {
#line 93
          tmp___0 = 576;
        } else
#line 93
        if (fr->mpeg25) {
#line 93
          tmp___0 = 576;
        } else {
#line 93
          tmp___0 = 1152;
        }
#line 93
        tmp___1 = tmp___0;
      }
#line 93
      tmp___2 = tmp___1;
    }
#line 93
    ntm += (off_t )((unsigned long )tmp___2 * fr->ntom_step);
#line 94
    soff += ntm / 32768LL;
#line 95
    ntm -= (ntm / 32768LL) * 32768LL;
#line 91
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (soff);
}
}
#line 104 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/ntom.c"
off_t ntom_ins2outs(mpg123_handle *fr , off_t ins ) 
{ 
  off_t soff ;
  off_t ntm ;
  unsigned long tmp ;
  off_t block___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  off_t nowblock ;
  off_t tmp___3 ;

  {
  {
#line 106
  soff = (off_t )0;
#line 107
  tmp = ntom_val(fr, (off_t )0);
#line 107
  ntm = (off_t )tmp;
  }
#line 110
  if (fr->lay == 1) {
#line 110
    tmp___2 = 384;
  } else {
#line 110
    if (fr->lay == 2) {
#line 110
      tmp___1 = 1152;
    } else {
#line 110
      if (fr->lsf) {
#line 110
        tmp___0 = 576;
      } else
#line 110
      if (fr->mpeg25) {
#line 110
        tmp___0 = 576;
      } else {
#line 110
        tmp___0 = 1152;
      }
#line 110
      tmp___1 = tmp___0;
    }
#line 110
    tmp___2 = tmp___1;
  }
#line 110
  block___0 = (off_t )tmp___2;
#line 111
  if (ins <= 0LL) {
#line 111
    return ((off_t )0);
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (ins > block___0) {
#line 114
      tmp___3 = block___0;
    } else {
#line 114
      tmp___3 = ins;
    }
#line 114
    nowblock = tmp___3;
#line 115
    ntm += nowblock * (off_t )fr->ntom_step;
#line 116
    soff += ntm / 32768LL;
#line 117
    ntm -= (ntm / 32768LL) * 32768LL;
#line 118
    ins -= nowblock;
#line 112
    if (! (ins > 0LL)) {
#line 112
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return (soff);
}
}
#line 130 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/ntom.c"
off_t ntom_frameoff(mpg123_handle *fr , off_t soff ) 
{ 
  off_t ioff ;
  off_t ntm ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 132
  ioff = (off_t )0;
#line 133
  tmp = ntom_val(fr, (off_t )0);
#line 133
  ntm = (off_t )tmp;
  }
#line 135
  if (soff <= 0LL) {
#line 135
    return ((off_t )0);
  }
#line 136
  ioff = (off_t )0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (fr->lay == 1) {
#line 138
      tmp___2 = 384;
    } else {
#line 138
      if (fr->lay == 2) {
#line 138
        tmp___1 = 1152;
      } else {
#line 138
        if (fr->lsf) {
#line 138
          tmp___0 = 576;
        } else
#line 138
        if (fr->mpeg25) {
#line 138
          tmp___0 = 576;
        } else {
#line 138
          tmp___0 = 1152;
        }
#line 138
        tmp___1 = tmp___0;
      }
#line 138
      tmp___2 = tmp___1;
    }
#line 138
    ntm += (off_t )((unsigned long )tmp___2 * fr->ntom_step);
#line 139
    if (ntm / 32768LL > soff) {
#line 139
      goto while_break;
    }
#line 140
    soff -= ntm / 32768LL;
#line 141
    ntm -= (ntm / 32768LL) * 32768LL;
#line 136
    ioff ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (ioff);
}
}
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 37 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy2utf8.c"
static unsigned char const   cp1252_utf8[406]  = 
#line 37 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy2utf8.c"
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )67, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71, 
        (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )75, 
        (unsigned char const   )76,      (unsigned char const   )77,      (unsigned char const   )78,      (unsigned char const   )79, 
        (unsigned char const   )80,      (unsigned char const   )81,      (unsigned char const   )82,      (unsigned char const   )83, 
        (unsigned char const   )84,      (unsigned char const   )85,      (unsigned char const   )86,      (unsigned char const   )87, 
        (unsigned char const   )88,      (unsigned char const   )89,      (unsigned char const   )90,      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )97,      (unsigned char const   )98,      (unsigned char const   )99, 
        (unsigned char const   )100,      (unsigned char const   )101,      (unsigned char const   )102,      (unsigned char const   )103, 
        (unsigned char const   )104,      (unsigned char const   )105,      (unsigned char const   )106,      (unsigned char const   )107, 
        (unsigned char const   )108,      (unsigned char const   )109,      (unsigned char const   )110,      (unsigned char const   )111, 
        (unsigned char const   )112,      (unsigned char const   )113,      (unsigned char const   )114,      (unsigned char const   )115, 
        (unsigned char const   )116,      (unsigned char const   )117,      (unsigned char const   )118,      (unsigned char const   )119, 
        (unsigned char const   )120,      (unsigned char const   )121,      (unsigned char const   )122,      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )226,      (unsigned char const   )130,      (unsigned char const   )172,      (unsigned char const   )239, 
        (unsigned char const   )191,      (unsigned char const   )189,      (unsigned char const   )226,      (unsigned char const   )128, 
        (unsigned char const   )154,      (unsigned char const   )198,      (unsigned char const   )146,      (unsigned char const   )226, 
        (unsigned char const   )128,      (unsigned char const   )158,      (unsigned char const   )226,      (unsigned char const   )128, 
        (unsigned char const   )166,      (unsigned char const   )226,      (unsigned char const   )128,      (unsigned char const   )160, 
        (unsigned char const   )226,      (unsigned char const   )128,      (unsigned char const   )161,      (unsigned char const   )203, 
        (unsigned char const   )134,      (unsigned char const   )226,      (unsigned char const   )128,      (unsigned char const   )176, 
        (unsigned char const   )197,      (unsigned char const   )160,      (unsigned char const   )226,      (unsigned char const   )128, 
        (unsigned char const   )185,      (unsigned char const   )197,      (unsigned char const   )146,      (unsigned char const   )239, 
        (unsigned char const   )191,      (unsigned char const   )189,      (unsigned char const   )197,      (unsigned char const   )189, 
        (unsigned char const   )239,      (unsigned char const   )191,      (unsigned char const   )189,      (unsigned char const   )239, 
        (unsigned char const   )191,      (unsigned char const   )189,      (unsigned char const   )226,      (unsigned char const   )128, 
        (unsigned char const   )152,      (unsigned char const   )226,      (unsigned char const   )128,      (unsigned char const   )153, 
        (unsigned char const   )226,      (unsigned char const   )128,      (unsigned char const   )156,      (unsigned char const   )226, 
        (unsigned char const   )128,      (unsigned char const   )157,      (unsigned char const   )226,      (unsigned char const   )128, 
        (unsigned char const   )162,      (unsigned char const   )226,      (unsigned char const   )128,      (unsigned char const   )147, 
        (unsigned char const   )226,      (unsigned char const   )128,      (unsigned char const   )148,      (unsigned char const   )203, 
        (unsigned char const   )156,      (unsigned char const   )226,      (unsigned char const   )132,      (unsigned char const   )162, 
        (unsigned char const   )197,      (unsigned char const   )161,      (unsigned char const   )226,      (unsigned char const   )128, 
        (unsigned char const   )186,      (unsigned char const   )197,      (unsigned char const   )147,      (unsigned char const   )239, 
        (unsigned char const   )191,      (unsigned char const   )189,      (unsigned char const   )197,      (unsigned char const   )190, 
        (unsigned char const   )197,      (unsigned char const   )184,      (unsigned char const   )194,      (unsigned char const   )160, 
        (unsigned char const   )194,      (unsigned char const   )161,      (unsigned char const   )194,      (unsigned char const   )162, 
        (unsigned char const   )194,      (unsigned char const   )163,      (unsigned char const   )194,      (unsigned char const   )164, 
        (unsigned char const   )194,      (unsigned char const   )165,      (unsigned char const   )194,      (unsigned char const   )166, 
        (unsigned char const   )194,      (unsigned char const   )167,      (unsigned char const   )194,      (unsigned char const   )168, 
        (unsigned char const   )194,      (unsigned char const   )169,      (unsigned char const   )194,      (unsigned char const   )170, 
        (unsigned char const   )194,      (unsigned char const   )171,      (unsigned char const   )194,      (unsigned char const   )172, 
        (unsigned char const   )194,      (unsigned char const   )173,      (unsigned char const   )194,      (unsigned char const   )174, 
        (unsigned char const   )194,      (unsigned char const   )175,      (unsigned char const   )194,      (unsigned char const   )176, 
        (unsigned char const   )194,      (unsigned char const   )177,      (unsigned char const   )194,      (unsigned char const   )178, 
        (unsigned char const   )194,      (unsigned char const   )179,      (unsigned char const   )194,      (unsigned char const   )180, 
        (unsigned char const   )194,      (unsigned char const   )181,      (unsigned char const   )194,      (unsigned char const   )182, 
        (unsigned char const   )194,      (unsigned char const   )183,      (unsigned char const   )194,      (unsigned char const   )184, 
        (unsigned char const   )194,      (unsigned char const   )185,      (unsigned char const   )194,      (unsigned char const   )186, 
        (unsigned char const   )194,      (unsigned char const   )187,      (unsigned char const   )194,      (unsigned char const   )188, 
        (unsigned char const   )194,      (unsigned char const   )189,      (unsigned char const   )194,      (unsigned char const   )190, 
        (unsigned char const   )194,      (unsigned char const   )191,      (unsigned char const   )195,      (unsigned char const   )128, 
        (unsigned char const   )195,      (unsigned char const   )129,      (unsigned char const   )195,      (unsigned char const   )130, 
        (unsigned char const   )195,      (unsigned char const   )131,      (unsigned char const   )195,      (unsigned char const   )132, 
        (unsigned char const   )195,      (unsigned char const   )133,      (unsigned char const   )195,      (unsigned char const   )134, 
        (unsigned char const   )195,      (unsigned char const   )135,      (unsigned char const   )195,      (unsigned char const   )136, 
        (unsigned char const   )195,      (unsigned char const   )137,      (unsigned char const   )195,      (unsigned char const   )138, 
        (unsigned char const   )195,      (unsigned char const   )139,      (unsigned char const   )195,      (unsigned char const   )140, 
        (unsigned char const   )195,      (unsigned char const   )141,      (unsigned char const   )195,      (unsigned char const   )142, 
        (unsigned char const   )195,      (unsigned char const   )143,      (unsigned char const   )195,      (unsigned char const   )144, 
        (unsigned char const   )195,      (unsigned char const   )145,      (unsigned char const   )195,      (unsigned char const   )146, 
        (unsigned char const   )195,      (unsigned char const   )147,      (unsigned char const   )195,      (unsigned char const   )148, 
        (unsigned char const   )195,      (unsigned char const   )149,      (unsigned char const   )195,      (unsigned char const   )150, 
        (unsigned char const   )195,      (unsigned char const   )151,      (unsigned char const   )195,      (unsigned char const   )152, 
        (unsigned char const   )195,      (unsigned char const   )153,      (unsigned char const   )195,      (unsigned char const   )154, 
        (unsigned char const   )195,      (unsigned char const   )155,      (unsigned char const   )195,      (unsigned char const   )156, 
        (unsigned char const   )195,      (unsigned char const   )157,      (unsigned char const   )195,      (unsigned char const   )158, 
        (unsigned char const   )195,      (unsigned char const   )159,      (unsigned char const   )195,      (unsigned char const   )160, 
        (unsigned char const   )195,      (unsigned char const   )161,      (unsigned char const   )195,      (unsigned char const   )162, 
        (unsigned char const   )195,      (unsigned char const   )163,      (unsigned char const   )195,      (unsigned char const   )164, 
        (unsigned char const   )195,      (unsigned char const   )165,      (unsigned char const   )195,      (unsigned char const   )166, 
        (unsigned char const   )195,      (unsigned char const   )167,      (unsigned char const   )195,      (unsigned char const   )168, 
        (unsigned char const   )195,      (unsigned char const   )169,      (unsigned char const   )195,      (unsigned char const   )170, 
        (unsigned char const   )195,      (unsigned char const   )171,      (unsigned char const   )195,      (unsigned char const   )172, 
        (unsigned char const   )195,      (unsigned char const   )173,      (unsigned char const   )195,      (unsigned char const   )174, 
        (unsigned char const   )195,      (unsigned char const   )175,      (unsigned char const   )195,      (unsigned char const   )176, 
        (unsigned char const   )195,      (unsigned char const   )177,      (unsigned char const   )195,      (unsigned char const   )178, 
        (unsigned char const   )195,      (unsigned char const   )179,      (unsigned char const   )195,      (unsigned char const   )180, 
        (unsigned char const   )195,      (unsigned char const   )181,      (unsigned char const   )195,      (unsigned char const   )182, 
        (unsigned char const   )195,      (unsigned char const   )183,      (unsigned char const   )195,      (unsigned char const   )184, 
        (unsigned char const   )195,      (unsigned char const   )185,      (unsigned char const   )195,      (unsigned char const   )186, 
        (unsigned char const   )195,      (unsigned char const   )187,      (unsigned char const   )195,      (unsigned char const   )188, 
        (unsigned char const   )195,      (unsigned char const   )189,      (unsigned char const   )195,      (unsigned char const   )190, 
        (unsigned char const   )195,      (unsigned char const   )191};
#line 296 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy2utf8.c"
static unsigned short const   tblofs[257]  = 
#line 296
  {      (unsigned short const   )0,      (unsigned short const   )1,      (unsigned short const   )2,      (unsigned short const   )3, 
        (unsigned short const   )4,      (unsigned short const   )5,      (unsigned short const   )6,      (unsigned short const   )7, 
        (unsigned short const   )8,      (unsigned short const   )9,      (unsigned short const   )10,      (unsigned short const   )11, 
        (unsigned short const   )12,      (unsigned short const   )13,      (unsigned short const   )14,      (unsigned short const   )15, 
        (unsigned short const   )16,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )19, 
        (unsigned short const   )20,      (unsigned short const   )21,      (unsigned short const   )22,      (unsigned short const   )23, 
        (unsigned short const   )24,      (unsigned short const   )25,      (unsigned short const   )26,      (unsigned short const   )27, 
        (unsigned short const   )28,      (unsigned short const   )29,      (unsigned short const   )30,      (unsigned short const   )31, 
        (unsigned short const   )32,      (unsigned short const   )33,      (unsigned short const   )34,      (unsigned short const   )35, 
        (unsigned short const   )36,      (unsigned short const   )37,      (unsigned short const   )38,      (unsigned short const   )39, 
        (unsigned short const   )40,      (unsigned short const   )41,      (unsigned short const   )42,      (unsigned short const   )43, 
        (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47, 
        (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51, 
        (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55, 
        (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )58,      (unsigned short const   )59, 
        (unsigned short const   )60,      (unsigned short const   )61,      (unsigned short const   )62,      (unsigned short const   )63, 
        (unsigned short const   )64,      (unsigned short const   )65,      (unsigned short const   )66,      (unsigned short const   )67, 
        (unsigned short const   )68,      (unsigned short const   )69,      (unsigned short const   )70,      (unsigned short const   )71, 
        (unsigned short const   )72,      (unsigned short const   )73,      (unsigned short const   )74,      (unsigned short const   )75, 
        (unsigned short const   )76,      (unsigned short const   )77,      (unsigned short const   )78,      (unsigned short const   )79, 
        (unsigned short const   )80,      (unsigned short const   )81,      (unsigned short const   )82,      (unsigned short const   )83, 
        (unsigned short const   )84,      (unsigned short const   )85,      (unsigned short const   )86,      (unsigned short const   )87, 
        (unsigned short const   )88,      (unsigned short const   )89,      (unsigned short const   )90,      (unsigned short const   )91, 
        (unsigned short const   )92,      (unsigned short const   )93,      (unsigned short const   )94,      (unsigned short const   )95, 
        (unsigned short const   )96,      (unsigned short const   )97,      (unsigned short const   )98,      (unsigned short const   )99, 
        (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107, 
        (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )110,      (unsigned short const   )111, 
        (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )115, 
        (unsigned short const   )116,      (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )119, 
        (unsigned short const   )120,      (unsigned short const   )121,      (unsigned short const   )122,      (unsigned short const   )123, 
        (unsigned short const   )124,      (unsigned short const   )125,      (unsigned short const   )126,      (unsigned short const   )127, 
        (unsigned short const   )128,      (unsigned short const   )131,      (unsigned short const   )134,      (unsigned short const   )137, 
        (unsigned short const   )139,      (unsigned short const   )142,      (unsigned short const   )145,      (unsigned short const   )148, 
        (unsigned short const   )151,      (unsigned short const   )153,      (unsigned short const   )156,      (unsigned short const   )158, 
        (unsigned short const   )161,      (unsigned short const   )163,      (unsigned short const   )166,      (unsigned short const   )168, 
        (unsigned short const   )171,      (unsigned short const   )174,      (unsigned short const   )177,      (unsigned short const   )180, 
        (unsigned short const   )183,      (unsigned short const   )186,      (unsigned short const   )189,      (unsigned short const   )192, 
        (unsigned short const   )195,      (unsigned short const   )197,      (unsigned short const   )200,      (unsigned short const   )202, 
        (unsigned short const   )205,      (unsigned short const   )207,      (unsigned short const   )210,      (unsigned short const   )212, 
        (unsigned short const   )214,      (unsigned short const   )216,      (unsigned short const   )218,      (unsigned short const   )220, 
        (unsigned short const   )222,      (unsigned short const   )224,      (unsigned short const   )226,      (unsigned short const   )228, 
        (unsigned short const   )230,      (unsigned short const   )232,      (unsigned short const   )234,      (unsigned short const   )236, 
        (unsigned short const   )238,      (unsigned short const   )240,      (unsigned short const   )242,      (unsigned short const   )244, 
        (unsigned short const   )246,      (unsigned short const   )248,      (unsigned short const   )250,      (unsigned short const   )252, 
        (unsigned short const   )254,      (unsigned short const   )256,      (unsigned short const   )258,      (unsigned short const   )260, 
        (unsigned short const   )262,      (unsigned short const   )264,      (unsigned short const   )266,      (unsigned short const   )268, 
        (unsigned short const   )270,      (unsigned short const   )272,      (unsigned short const   )274,      (unsigned short const   )276, 
        (unsigned short const   )278,      (unsigned short const   )280,      (unsigned short const   )282,      (unsigned short const   )284, 
        (unsigned short const   )286,      (unsigned short const   )288,      (unsigned short const   )290,      (unsigned short const   )292, 
        (unsigned short const   )294,      (unsigned short const   )296,      (unsigned short const   )298,      (unsigned short const   )300, 
        (unsigned short const   )302,      (unsigned short const   )304,      (unsigned short const   )306,      (unsigned short const   )308, 
        (unsigned short const   )310,      (unsigned short const   )312,      (unsigned short const   )314,      (unsigned short const   )316, 
        (unsigned short const   )318,      (unsigned short const   )320,      (unsigned short const   )322,      (unsigned short const   )324, 
        (unsigned short const   )326,      (unsigned short const   )328,      (unsigned short const   )330,      (unsigned short const   )332, 
        (unsigned short const   )334,      (unsigned short const   )336,      (unsigned short const   )338,      (unsigned short const   )340, 
        (unsigned short const   )342,      (unsigned short const   )344,      (unsigned short const   )346,      (unsigned short const   )348, 
        (unsigned short const   )350,      (unsigned short const   )352,      (unsigned short const   )354,      (unsigned short const   )356, 
        (unsigned short const   )358,      (unsigned short const   )360,      (unsigned short const   )362,      (unsigned short const   )364, 
        (unsigned short const   )366,      (unsigned short const   )368,      (unsigned short const   )370,      (unsigned short const   )372, 
        (unsigned short const   )374,      (unsigned short const   )376,      (unsigned short const   )378,      (unsigned short const   )380, 
        (unsigned short const   )382,      (unsigned short const   )384,      (unsigned short const   )386,      (unsigned short const   )388, 
        (unsigned short const   )390,      (unsigned short const   )392,      (unsigned short const   )394,      (unsigned short const   )396, 
        (unsigned short const   )398,      (unsigned short const   )400,      (unsigned short const   )402,      (unsigned short const   )404, 
        (unsigned short const   )406};
#line 333 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy2utf8.c"
static int is_utf8(char const   *src ) 
{ 
  unsigned char ch ;
  size_t i ;
  unsigned char const   *s ;
  unsigned char const   *tmp ;
  size_t tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
#line 338
  s = (unsigned char const   *)src;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    tmp___1 = s;
#line 342
    s ++;
#line 342
    ch = (unsigned char )*tmp___1;
#line 342
    if (! ch) {
#line 342
      goto while_break;
    }
#line 344
    if ((int )ch < 128) {
#line 344
      goto while_continue;
    } else
#line 347
    if ((int )ch < 194) {
#line 348
      return (0);
    } else
#line 347
    if ((int )ch > 253) {
#line 348
      return (0);
    }
#line 350
    if ((int )ch == 194) {
#line 350
      if ((int const   )*(s + 0) < 160) {
#line 353
        return (0);
      } else {
#line 350
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 350
    if ((int )ch == 239) {
#line 350
      if ((int const   )*(s + 0) == 191) {
#line 350
        if ((int const   )*(s + 1) > 189) {
#line 353
          return (0);
        }
      }
    }
#line 356
    if ((int )ch < 224) {
#line 356
      i = (size_t )1;
    } else
#line 357
    if ((int )ch < 240) {
#line 357
      i = (size_t )2;
    } else
#line 358
    if ((int )ch < 248) {
#line 358
      i = (size_t )3;
    } else
#line 359
    if ((int )ch < 252) {
#line 359
      i = (size_t )4;
    } else {
#line 361
      i = (size_t )5;
    }
    {
#line 363
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 363
      tmp___0 = i;
#line 363
      i --;
#line 363
      if (! tmp___0) {
#line 363
        goto while_break___0;
      }
#line 364
      tmp = s;
#line 364
      s ++;
#line 364
      if (((int const   )*tmp & 192) != 128) {
#line 365
        return (0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return (1);
}
}
#line 375 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy2utf8.c"
char *icy2utf8(char const   *src , int force ) 
{ 
  unsigned char const   *s ;
  size_t srclen ;
  size_t dstlen ;
  size_t i ;
  size_t k ;
  unsigned char ch ;
  unsigned char *d ;
  char *dst ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;

  {
#line 378
  s = (unsigned char const   *)src;
#line 385
  if (! force) {
    {
#line 385
    tmp___0 = is_utf8(src);
    }
#line 385
    if (tmp___0) {
      {
#line 385
      tmp = strdup(src);
      }
#line 385
      return (tmp);
    }
  }
  {
#line 387
  tmp___1 = strlen(src);
#line 387
  srclen = tmp___1 + 1U;
#line 389
  tmp___2 = malloc(srclen * 3U);
#line 389
  d = (unsigned char *)tmp___2;
  }
#line 389
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 390
    return ((char *)((void *)0));
  }
#line 392
  i = (size_t )0;
#line 393
  dstlen = (size_t )0;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i < srclen)) {
#line 394
      goto while_break;
    }
#line 395
    tmp___3 = i;
#line 395
    i ++;
#line 395
    ch = (unsigned char )*(s + tmp___3);
#line 396
    k = (size_t )tblofs[ch];
    {
#line 397
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 397
      if (! (k < (size_t )tblofs[(int )ch + 1])) {
#line 397
        goto while_break___0;
      }
#line 398
      tmp___4 = dstlen;
#line 398
      dstlen ++;
#line 398
      tmp___5 = k;
#line 398
      k ++;
#line 398
      *(d + tmp___4) = (unsigned char )cp1252_utf8[tmp___5];
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 402
  tmp___6 = realloc((void *)d, dstlen);
#line 402
  dst = (char *)tmp___6;
  }
#line 402
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
    {
#line 403
    free((void *)d);
    }
#line 404
    return ((char *)((void *)0));
  }
#line 406
  return (dst);
}
}
#line 23 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy.h"
void init_icy(struct icy_meta *icy ) ;
#line 24
void clear_icy(struct icy_meta *icy ) ;
#line 25
void reset_icy(struct icy_meta *icy ) ;
#line 11 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy.c"
void init_icy(struct icy_meta *icy ) 
{ 


  {
#line 13
  icy->data = (char *)((void *)0);
#line 14
  return;
}
}
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy.c"
void clear_icy(struct icy_meta *icy ) 
{ 


  {
#line 18
  if ((unsigned long )icy->data != (unsigned long )((void *)0)) {
    {
#line 18
    free((void *)icy->data);
    }
  }
  {
#line 19
  init_icy(icy);
  }
#line 20
  return;
}
}
#line 22 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/icy.c"
void reset_icy(struct icy_meta *icy ) 
{ 


  {
  {
#line 24
  clear_icy(icy);
#line 25
  init_icy(icy);
  }
#line 26
  return;
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 747 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
void __attribute__((__force_align_arg_pointer__))  mpg123_init_string(mpg123_string *sb ) ;
#line 750
void __attribute__((__force_align_arg_pointer__))  mpg123_free_string(mpg123_string *sb ) ;
#line 754
int __attribute__((__force_align_arg_pointer__))  mpg123_resize_string(mpg123_string *sb ,
                                                                       size_t new ) ;
#line 760
int __attribute__((__force_align_arg_pointer__))  mpg123_grow_string(mpg123_string *sb ,
                                                                     size_t new ) ;
#line 764
int __attribute__((__force_align_arg_pointer__))  mpg123_copy_string(mpg123_string *from ,
                                                                     mpg123_string *to ) ;
#line 768
int __attribute__((__force_align_arg_pointer__))  mpg123_add_string(mpg123_string *sb ,
                                                                    char const   *stuff ) ;
#line 774
int __attribute__((__force_align_arg_pointer__))  mpg123_add_substring(mpg123_string *sb ,
                                                                       char const   *stuff ,
                                                                       size_t from ,
                                                                       size_t count ) ;
#line 778
int __attribute__((__force_align_arg_pointer__))  mpg123_set_string(mpg123_string *sb ,
                                                                    char const   *stuff ) ;
#line 784
int __attribute__((__force_align_arg_pointer__))  mpg123_set_substring(mpg123_string *sb ,
                                                                       char const   *stuff ,
                                                                       size_t from ,
                                                                       size_t count ) ;
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/stringbuf.c"
void __attribute__((__force_align_arg_pointer__))  mpg123_init_string(mpg123_string *sb ) 
{ 


  {
#line 18
  sb->p = (char *)((void *)0);
#line 19
  sb->size = (size_t )0;
#line 20
  sb->fill = (size_t )0;
#line 21
  return;
}
}
#line 23 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/stringbuf.c"
void __attribute__((__force_align_arg_pointer__))  mpg123_free_string(mpg123_string *sb ) 
{ 


  {
#line 25
  if ((unsigned long )sb->p != (unsigned long )((void *)0)) {
    {
#line 25
    free((void *)sb->p);
    }
  }
  {
#line 26
  mpg123_init_string(sb);
  }
#line 27
  return;
}
}
#line 29 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/stringbuf.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_grow_string(mpg123_string *sb ,
                                                                     size_t new ) 
{ 
  int tmp ;

  {
#line 31
  if (sb->size < new) {
    {
#line 31
    tmp = (int )mpg123_resize_string(sb, new);
    }
#line 31
    return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
  } else {
#line 32
    return ((int __attribute__((__force_align_arg_pointer__))  )1);
  }
}
}
#line 35 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/stringbuf.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_resize_string(mpg123_string *sb ,
                                                                       size_t new ) 
{ 
  char *t ;
  void *tmp ;

  {
#line 38
  if (new == 0U) {
#line 40
    if (sb->size) {
#line 40
      if ((unsigned long )sb->p != (unsigned long )((void *)0)) {
        {
#line 40
        free((void *)sb->p);
        }
      }
    }
    {
#line 41
    mpg123_init_string(sb);
    }
#line 42
    return ((int __attribute__((__force_align_arg_pointer__))  )1);
  }
#line 44
  if (sb->size != new) {
    {
#line 48
    tmp = safe_realloc((void *)sb->p, (size_t )((unsigned long )new * sizeof(char )));
#line 48
    t = (char *)tmp;
    }
#line 50
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 52
      sb->p = t;
#line 53
      sb->size = new;
#line 54
      return ((int __attribute__((__force_align_arg_pointer__))  )1);
    } else {
#line 56
      return ((int __attribute__((__force_align_arg_pointer__))  )0);
    }
  } else {
#line 58
    return ((int __attribute__((__force_align_arg_pointer__))  )1);
  }
}
}
#line 61 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/stringbuf.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_copy_string(mpg123_string *from ,
                                                                     mpg123_string *to ) 
{ 
  size_t fill ;
  char *text ;
  int __attribute__((__force_align_arg_pointer__))  tmp ;

  {
#line 65
  if ((unsigned long )to == (unsigned long )((void *)0)) {
#line 65
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 68
  if ((unsigned long )from == (unsigned long )((void *)0)) {
#line 70
    fill = (size_t )0;
#line 71
    text = (char *)((void *)0);
  } else {
#line 75
    fill = from->fill;
#line 76
    text = from->p;
  }
  {
#line 79
  tmp = mpg123_resize_string(to, fill);
  }
#line 79
  if (tmp) {
    {
#line 81
    memcpy((void */* __restrict  */)to->p, (void const   */* __restrict  */)text,
           fill);
#line 82
    to->fill = fill;
    }
#line 83
    return ((int __attribute__((__force_align_arg_pointer__))  )1);
  } else {
#line 85
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  }
}
}
#line 88 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/stringbuf.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_add_string(mpg123_string *sb ,
                                                                    char const   *stuff ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 91
  tmp = strlen(stuff);
#line 91
  tmp___0 = (int )mpg123_add_substring(sb, stuff, (size_t )0, tmp);
  }
#line 91
  return ((int __attribute__((__force_align_arg_pointer__))  )tmp___0);
}
}
#line 94 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/stringbuf.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_add_substring(mpg123_string *sb ,
                                                                       char const   *stuff ,
                                                                       size_t from ,
                                                                       size_t count ) 
{ 
  int __attribute__((__force_align_arg_pointer__))  tmp ;
  int __attribute__((__force_align_arg_pointer__))  tmp___0 ;

  {
#line 97
  if (sb->fill) {
#line 99
    if (4294967295U - sb->fill >= count) {
#line 99
      if (sb->size >= sb->fill + count) {
        {
#line 102
        memcpy((void */* __restrict  */)((sb->p + sb->fill) - 1), (void const   */* __restrict  */)(stuff + from),
               count);
#line 103
        sb->fill += count;
#line 104
        *(sb->p + (sb->fill - 1U)) = (char)0;
        }
      } else {
        {
#line 99
        tmp = mpg123_grow_string(sb, sb->fill + count);
        }
#line 99
        if (tmp) {
          {
#line 102
          memcpy((void */* __restrict  */)((sb->p + sb->fill) - 1), (void const   */* __restrict  */)(stuff + from),
                 count);
#line 103
          sb->fill += count;
#line 104
          *(sb->p + (sb->fill - 1U)) = (char)0;
          }
        } else {
#line 106
          return ((int __attribute__((__force_align_arg_pointer__))  )0);
        }
      }
    } else {
#line 106
      return ((int __attribute__((__force_align_arg_pointer__))  )0);
    }
  } else
#line 110
  if (count < 4294967295U) {
    {
#line 110
    tmp___0 = mpg123_grow_string(sb, count + 1U);
    }
#line 110
    if (tmp___0) {
      {
#line 112
      memcpy((void */* __restrict  */)sb->p, (void const   */* __restrict  */)(stuff + from),
             count);
#line 113
      sb->fill = count + 1U;
#line 114
      *(sb->p + (sb->fill - 1U)) = (char)0;
      }
    } else {
#line 116
      return ((int __attribute__((__force_align_arg_pointer__))  )0);
    }
  } else {
#line 116
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  }
#line 118
  return ((int __attribute__((__force_align_arg_pointer__))  )1);
}
}
#line 121 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/stringbuf.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_set_substring(mpg123_string *sb ,
                                                                       char const   *stuff ,
                                                                       size_t from ,
                                                                       size_t count ) 
{ 
  int __attribute__((__force_align_arg_pointer__))  tmp ;

  {
  {
#line 123
  sb->fill = (size_t )0;
#line 124
  tmp = mpg123_add_substring(sb, stuff, from, count);
  }
#line 124
  return (tmp);
}
}
#line 127 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/stringbuf.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_set_string(mpg123_string *sb ,
                                                                    char const   *stuff ) 
{ 
  int __attribute__((__force_align_arg_pointer__))  tmp ;

  {
  {
#line 129
  sb->fill = (size_t )0;
#line 130
  tmp = mpg123_add_string(sb, stuff);
  }
#line 130
  return (tmp);
}
}
#line 41 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.h"
void fi_init(struct frame_index *fi ) ;
#line 43
void fi_exit(struct frame_index *fi ) ;
#line 48
int fi_resize(struct frame_index *fi , size_t newsize ) ;
#line 51
void fi_add(struct frame_index *fi , off_t pos ) ;
#line 54
int fi_set(struct frame_index *fi , off_t *offsets , off_t step___30 , size_t fill ) ;
#line 57
void fi_reset(struct frame_index *fi ) ;
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.c"
static off_t fi_next(struct frame_index *fi ) 
{ 


  {
#line 15
  return ((off_t )fi->fill * fi->step);
}
}
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.c"
static void fi_shrink(struct frame_index *fi ) 
{ 
  size_t c ;

  {
#line 22
  if (fi->fill < 2U) {
#line 22
    return;
  } else {
#line 27
    fi->step *= 2LL;
#line 28
    fi->fill /= 2U;
#line 30
    c = (size_t )0;
    {
#line 30
    while (1) {
      while_continue: /* CIL Label */ ;
#line 30
      if (! (c < fi->fill)) {
#line 30
        goto while_break;
      }
#line 31
      *(fi->data + c) = *(fi->data + 2U * c);
#line 30
      c ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 34
  fi->next = fi_next(fi);
  }
#line 35
  return;
}
}
#line 37 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.c"
void fi_init(struct frame_index *fi ) 
{ 


  {
  {
#line 39
  fi->data = (off_t *)((void *)0);
#line 40
  fi->step = (off_t )1;
#line 41
  fi->fill = (size_t )0;
#line 42
  fi->size = (size_t )0;
#line 43
  fi->grow_size = (size_t )0;
#line 44
  fi->next = fi_next(fi);
  }
#line 45
  return;
}
}
#line 47 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.c"
void fi_exit(struct frame_index *fi ) 
{ 


  {
#line 50
  if (fi->size) {
#line 50
    if ((unsigned long )fi->data != (unsigned long )((void *)0)) {
      {
#line 50
      free((void *)fi->data);
      }
    }
  }
  {
#line 52
  fi_init(fi);
  }
#line 53
  return;
}
}
#line 55 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.c"
int fi_resize(struct frame_index *fi , size_t newsize ) 
{ 
  off_t *newdata ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
#line 57
  newdata = (off_t *)((void *)0);
#line 58
  if (newsize == fi->size) {
#line 58
    return (0);
  }
#line 60
  if (newsize > 0U) {
#line 60
    if (newsize < fi->size) {
      {
#line 62
      while (1) {
        while_continue: /* CIL Label */ ;
#line 62
        if (! (fi->fill > newsize)) {
#line 62
          goto while_break;
        }
        {
#line 62
        fi_shrink(fi);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 65
  tmp = safe_realloc((void *)fi->data, (size_t )((unsigned long )newsize * sizeof(off_t )));
#line 65
  newdata = (off_t *)tmp;
  }
#line 66
  if (newsize == 0U) {
#line 66
    goto _L;
  } else
#line 66
  if ((unsigned long )newdata != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 68
    fi->data = newdata;
#line 69
    fi->size = newsize;
#line 70
    if (fi->fill > fi->size) {
#line 70
      fi->fill = fi->size;
    }
    {
#line 72
    fi->next = fi_next(fi);
    }
#line 74
    return (0);
  } else {
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.c:%i] error: failed to resize index!\n",
            78);
    }
#line 79
    return (-1);
  }
}
}
#line 83 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.c"
void fi_add(struct frame_index *fi , off_t pos ) 
{ 
  off_t framenum___0 ;
  int tmp ;

  {
#line 86
  if (fi->fill == fi->size) {
#line 89
    framenum___0 = (off_t )fi->fill * fi->step;
#line 91
    if (fi->grow_size) {
      {
#line 91
      tmp = fi_resize(fi, fi->size + fi->grow_size);
      }
#line 91
      if (! (tmp == 0)) {
        {
#line 92
        fi_shrink(fi);
        }
      }
    } else {
      {
#line 92
      fi_shrink(fi);
      }
    }
#line 95
    if (fi->next != framenum___0) {
#line 95
      return;
    }
  }
#line 98
  if (fi->fill < fi->size) {
    {
#line 101
    *(fi->data + fi->fill) = pos;
#line 102
    (fi->fill) ++;
#line 103
    fi->next = fi_next(fi);
    }
  }
#line 106
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.c"
int fi_set(struct frame_index *fi , off_t *offsets , off_t step___30 , size_t fill ) 
{ 
  int tmp ;

  {
  {
#line 110
  tmp = fi_resize(fi, fill);
  }
#line 110
  if (tmp == -1) {
#line 110
    return (-1);
  }
#line 111
  fi->step = step___30;
#line 112
  if ((unsigned long )offsets != (unsigned long )((void *)0)) {
    {
#line 114
    memcpy((void */* __restrict  */)fi->data, (void const   */* __restrict  */)offsets,
           (size_t )((unsigned long )fill * sizeof(off_t )));
#line 115
    fi->fill = fill;
    }
  } else {
#line 120
    fi->fill = (size_t )0;
  }
  {
#line 122
  fi->next = fi_next(fi);
  }
#line 125
  return (0);
}
}
#line 128 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/index.c"
void fi_reset(struct frame_index *fi ) 
{ 


  {
  {
#line 131
  fi->fill = (size_t )0;
#line 132
  fi->step = (off_t )1;
#line 133
  fi->next = fi_next(fi);
  }
#line 134
  return;
}
}
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 116 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
int __attribute__((__force_align_arg_pointer__))  mpg123_init(void) ;
#line 120
void __attribute__((__force_align_arg_pointer__))  mpg123_exit(void) ;
#line 128
mpg123_handle __attribute__((__force_align_arg_pointer__))  *mpg123_new(char const   *decoder ,
                                                                        int *error ) ;
#line 131
void __attribute__((__force_align_arg_pointer__))  mpg123_delete(mpg123_handle *mh___0 ) ;
#line 187
int __attribute__((__force_align_arg_pointer__))  mpg123_param(mpg123_handle *mh___0 ,
                                                               enum mpg123_parms key ,
                                                               long val , double fval ) ;
#line 191
int __attribute__((__force_align_arg_pointer__))  mpg123_getparam(mpg123_handle *mh___0 ,
                                                                  enum mpg123_parms key ,
                                                                  long *val , double *fval ) ;
#line 282
char const   * __attribute__((__force_align_arg_pointer__)) mpg123_plain_strerror(int errcode ) ;
#line 288
char const   * __attribute__((__force_align_arg_pointer__)) mpg123_strerror(mpg123_handle *mh___0 ) ;
#line 291
int __attribute__((__force_align_arg_pointer__))  mpg123_errcode(mpg123_handle *mh___0 ) ;
#line 311
int __attribute__((__force_align_arg_pointer__))  mpg123_decoder(mpg123_handle *mh___0 ,
                                                                 char const   *decoder ) ;
#line 409
int __attribute__((__force_align_arg_pointer__))  mpg123_getformat(mpg123_handle *mh___0 ,
                                                                   long *rate , int *channels ,
                                                                   int *encoding ) ;
#line 439
int __attribute__((__force_align_arg_pointer__))  mpg123_open_handle_64(mpg123_handle *mh___0 ,
                                                                        void *iohandle ) ;
#line 444
int __attribute__((__force_align_arg_pointer__))  mpg123_open_feed(mpg123_handle *mh___0 ) ;
#line 454
int __attribute__((__force_align_arg_pointer__))  mpg123_read(mpg123_handle *mh___0 ,
                                                              unsigned char *out ,
                                                              size_t size , size_t *done ) ;
#line 461
int __attribute__((__force_align_arg_pointer__))  mpg123_feed(mpg123_handle *mh___0 ,
                                                              unsigned char const   *in ,
                                                              size_t size ) ;
#line 477
int __attribute__((__force_align_arg_pointer__))  mpg123_decode(mpg123_handle *mh___0 ,
                                                                unsigned char const   *inmemory ,
                                                                size_t inmemsize ,
                                                                unsigned char *outmemory ,
                                                                size_t outmemsize ,
                                                                size_t *done ) ;
#line 500
int __attribute__((__force_align_arg_pointer__))  mpg123_framebyframe_next(mpg123_handle *mh___0 ) ;
#line 599
int __attribute__((__force_align_arg_pointer__))  mpg123_eq(mpg123_handle *mh___0 ,
                                                            enum mpg123_channels channel ,
                                                            int band , double val ) ;
#line 605
double __attribute__((__force_align_arg_pointer__))  mpg123_geteq(mpg123_handle *mh___0 ,
                                                                  enum mpg123_channels channel ,
                                                                  int band ) ;
#line 686
size_t __attribute__((__force_align_arg_pointer__))  mpg123_safe_buffer(void) ;
#line 694
int __attribute__((__force_align_arg_pointer__))  mpg123_scan(mpg123_handle *mh___0 ) ;
#line 706
double __attribute__((__force_align_arg_pointer__))  mpg123_tpf(mpg123_handle *fr ) ;
#line 709
long __attribute__((__force_align_arg_pointer__))  mpg123_clip(mpg123_handle *mh___0 ) ;
#line 724
int __attribute__((__force_align_arg_pointer__))  mpg123_getstate(mpg123_handle *mh___0 ,
                                                                  enum mpg123_state key ,
                                                                  long *val , double *fval ) ;
#line 817
enum mpg123_text_encoding  __attribute__((__force_align_arg_pointer__)) mpg123_enc_from_id3(unsigned char id3_enc_byte ) ;
#line 829
int mpg123_store_utf8(mpg123_string *sb , enum mpg123_text_encoding enc , unsigned char const   *source ,
                      size_t source_size ) ;
#line 889
int __attribute__((__force_align_arg_pointer__))  mpg123_meta_check(mpg123_handle *mh___0 ) ;
#line 894
int __attribute__((__force_align_arg_pointer__))  mpg123_id3(mpg123_handle *mh___0 ,
                                                             mpg123_id3v1 **v1 , mpg123_id3v2 **v2 ) ;
#line 898
int __attribute__((__force_align_arg_pointer__))  mpg123_icy(mpg123_handle *mh___0 ,
                                                             char **icy_meta ) ;
#line 904
char * __attribute__((__force_align_arg_pointer__)) mpg123_icy2utf8(char const   *icy_text ) ;
#line 932
mpg123_handle __attribute__((__force_align_arg_pointer__))  *mpg123_parnew(mpg123_pars *mp ,
                                                                           char const   *decoder ,
                                                                           int *error ) ;
#line 964
int __attribute__((__force_align_arg_pointer__))  mpg123_par(mpg123_pars *mp , enum mpg123_parms key ,
                                                             long val , double fval ) ;
#line 968
int __attribute__((__force_align_arg_pointer__))  mpg123_getpar(mpg123_pars *mp ,
                                                                enum mpg123_parms key ,
                                                                long *val , double *fval ) ;
#line 984
size_t __attribute__((__force_align_arg_pointer__))  mpg123_outblock(mpg123_handle *mh___0 ) ;
#line 993
int __attribute__((__force_align_arg_pointer__))  mpg123_replace_reader_64(mpg123_handle *mh___0 ,
                                                                           ssize_t (*r_read)(int  ,
                                                                                             void * ,
                                                                                             size_t  ) ,
                                                                           off_t (*r_lseek)(int  ,
                                                                                            off_t  ,
                                                                                            int  ) ) ;
#line 46 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.h"
int frame_cpu_opt(mpg123_handle *fr , char const   *cpu ) ;
#line 48
int set_synth_functions(mpg123_handle *fr ) ;
#line 50
enum optdec dectype(char const   *decoder ) ;
#line 188
void check_decoders(void) ;
#line 226 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
void prepare_decode_tables(void) ;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.h"
void id3_link(mpg123_handle *fr ) ;
#line 29
void id3_to_utf8(mpg123_string *sb , unsigned char encoding , unsigned char const   *source ,
                 size_t source_size , int noquiet ) ;
#line 79 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/reader.h"
int open_stream(mpg123_handle *fr , char const   *bs_filenam , int fd ) ;
#line 84
int open_feed(mpg123_handle *fr ) ;
#line 86
int feed_more(mpg123_handle *fr , unsigned char const   *in , long count ) ;
#line 88
off_t feed_set_pos(mpg123_handle *fr , off_t pos ) ;
#line 55 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
void invalidate_format(struct audioformat *af ) ;
#line 321
void frame_init_par(mpg123_handle *fr , mpg123_pars *mp ) ;
#line 323
int frame_outbuffer(mpg123_handle *fr ) ;
#line 324
int frame_output_format(mpg123_handle *fr ) ;
#line 328
int frame_buffers_reset(mpg123_handle *fr ) ;
#line 329
void frame_exit(mpg123_handle *fr ) ;
#line 335
off_t frame_index_find(mpg123_handle *fr , off_t want_frame , off_t *get_frame ) ;
#line 337
int frame_index_setup(mpg123_handle *fr ) ;
#line 340
void do_rva(mpg123_handle *fr ) ;
#line 366
void frame_gapless_realinit(mpg123_handle *fr ) ;
#line 367
void frame_gapless_update(mpg123_handle *fr , off_t total_samples ) ;
#line 375
off_t frame_expect_outsamples(mpg123_handle *fr ) ;
#line 378
void frame_skip(mpg123_handle *fr ) ;
#line 387
off_t frame_ins2outs(mpg123_handle *fr , off_t ins ) ;
#line 388
off_t frame_outs(mpg123_handle *fr , off_t num ) ;
#line 392
void frame_set_frameseek(mpg123_handle *fr , off_t fe ) ;
#line 393
void frame_set_seek(mpg123_handle *fr , off_t sp ) ;
#line 18 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.h"
int read_frame(mpg123_handle *fr ) ;
#line 21
double compute_bpf(mpg123_handle *fr ) ;
#line 316 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123lib_intern.h"
int decode_update(mpg123_handle *mh___0 ) ;
#line 318
off_t samples_to_bytes(mpg123_handle *fr , off_t s ) ;
#line 319
off_t bytes_to_samples(mpg123_handle *fr , off_t b ) ;
#line 23 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
static int initialized  =    0;
#line 32 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
static void frame_buffercheck(mpg123_handle *fr ) 
{ 
  off_t byteoff ;
  off_t tmp ;
  off_t tmp___0 ;
  off_t byteoff___0 ;
  off_t tmp___1 ;

  {
#line 35
  if (! fr->accurate) {
#line 35
    return;
  }
#line 43
  if (fr->lastframe > -1LL) {
#line 43
    if (fr->num >= fr->lastframe) {
#line 46
      if (fr->num == fr->lastframe) {
        {
#line 46
        tmp = samples_to_bytes(fr, fr->lastoff);
#line 46
        tmp___0 = tmp;
        }
      } else {
#line 46
        tmp___0 = (off_t )0;
      }
#line 46
      byteoff = tmp___0;
#line 47
      if ((off_t )fr->buffer.fill > byteoff) {
#line 49
        fr->buffer.fill = (size_t )byteoff;
      }
    }
  }
#line 55
  if (fr->firstoff) {
#line 55
    if (fr->num == fr->firstframe) {
      {
#line 57
      tmp___1 = samples_to_bytes(fr, fr->firstoff);
#line 57
      byteoff___0 = tmp___1;
      }
#line 58
      if ((off_t )fr->buffer.fill > byteoff___0) {
#line 60
        fr->buffer.fill = (size_t )((off_t )fr->buffer.fill - byteoff___0);
#line 64
        if (fr->own_buffer) {
#line 64
          fr->buffer.p = fr->buffer.data + byteoff___0;
        } else {
          {
#line 65
          memmove((void *)fr->buffer.data, (void const   *)(fr->buffer.data + byteoff___0),
                  fr->buffer.fill);
          }
        }
      } else {
#line 69
        fr->buffer.fill = (size_t )0;
      }
#line 72
      fr->firstoff = (off_t )0;
    }
  }
#line 74
  return;
}
}
#line 77 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_init(void) 
{ 


  {
#line 80
  if (sizeof(short ) != 2UL) {
#line 80
    return ((int __attribute__((__force_align_arg_pointer__))  )15);
  } else
#line 80
  if (sizeof(long ) < 4UL) {
#line 80
    return ((int __attribute__((__force_align_arg_pointer__))  )15);
  }
#line 82
  if (initialized) {
#line 82
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  }
  {
#line 85
  init_layer12();
#line 88
  init_layer3();
#line 90
  prepare_decode_tables();
#line 91
  check_decoders();
#line 92
  initialized = 1;
  }
#line 93
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 96 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
void __attribute__((__force_align_arg_pointer__))  mpg123_exit(void) 
{ 


  {
#line 99
  return;
}
}
#line 102 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
mpg123_handle __attribute__((__force_align_arg_pointer__))  *mpg123_new(char const   *decoder ,
                                                                        int *error ) 
{ 
  mpg123_handle *tmp ;

  {
  {
#line 104
  tmp = (mpg123_handle *)mpg123_parnew((mpg123_pars *)((void *)0), decoder, error);
  }
#line 104
  return ((mpg123_handle __attribute__((__force_align_arg_pointer__))  *)tmp);
}
}
#line 108 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
mpg123_handle __attribute__((__force_align_arg_pointer__))  *mpg123_parnew(mpg123_pars *mp ,
                                                                           char const   *decoder ,
                                                                           int *error ) 
{ 
  mpg123_handle *fr ;
  int err ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  int __cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  int __cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  int __cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  int __cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  int __cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  int __cil_tmp55 ;
  void *__cil_tmp56 ;
  int __cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;

  {
#line 110
  fr = (mpg123_handle *)((void *)0);
#line 111
  err = 0;
#line 123
  if (initialized) {
    {
#line 123
    tmp = malloc((size_t )sizeof(mpg123_handle ));
#line 123
    fr = (mpg123_handle *)tmp;
    }
  } else {
#line 124
    err = 8;
  }
#line 125
  if ((unsigned long )fr != (unsigned long )((void *)0)) {
    {
#line 127
    frame_init_par(fr, mp);
#line 129
    tmp___0 = frame_cpu_opt(fr, decoder);
    }
#line 129
    if (tmp___0 != 1) {
      {
#line 131
      err = 9;
#line 132
      frame_exit(fr);
#line 133
      free((void *)fr);
#line 134
      fr = (mpg123_handle *)((void *)0);
      }
    }
  }
#line 137
  if ((unsigned long )fr != (unsigned long )((void *)0)) {
    {
#line 140
    tmp___1 = frame_outbuffer(fr);
    }
#line 140
    if (tmp___1 != 0) {
      {
#line 142
      err = 11;
#line 143
      frame_exit(fr);
#line 144
      free((void *)fr);
#line 145
      fr = (mpg123_handle *)((void *)0);
      }
    } else {
#line 158
      fr->decoder_change = 1;
    }
  } else
#line 161
  if (err == 0) {
#line 161
    err = 7;
  }
#line 163
  if ((unsigned long )error != (unsigned long )((void *)0)) {
#line 163
    *error = err;
  }
#line 164
  return ((mpg123_handle __attribute__((__force_align_arg_pointer__))  *)fr);
}
}
#line 167 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_decoder(mpg123_handle *mh___0 ,
                                                                 char const   *decoder ) 
{ 
  enum optdec dt ;
  enum optdec tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 169
  tmp = dectype(decoder);
#line 169
  dt = tmp;
  }
#line 171
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 171
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 173
  if ((unsigned int )dt == 14U) {
#line 175
    mh___0->err = 9;
#line 176
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 178
  if ((unsigned int )dt == (unsigned int )mh___0->cpu_opts.type) {
#line 178
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  }
  {
#line 184
  tmp___0 = frame_cpu_opt(mh___0, decoder);
  }
#line 184
  if (tmp___0 != 1) {
    {
#line 186
    mh___0->err = 9;
#line 187
    frame_exit(mh___0);
    }
#line 188
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 191
  tmp___1 = frame_outbuffer(mh___0);
  }
#line 191
  if (tmp___1 != 0) {
    {
#line 193
    mh___0->err = 11;
#line 194
    frame_exit(mh___0);
    }
#line 195
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 198
  decode_update(mh___0);
#line 199
  mh___0->decoder_change = 1;
  }
#line 200
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 203 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_param(mpg123_handle *mh___0 ,
                                                               enum mpg123_parms key ,
                                                               long val , double fval ) 
{ 
  int r ;

  {
#line 207
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 207
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 208
  r = (int )mpg123_par(& mh___0->p, key, val, fval);
  }
#line 209
  if (r != 0) {
#line 209
    mh___0->err = r;
#line 209
    r = -1;
  } else
#line 213
  if ((unsigned int )key == 15U) {
    {
#line 215
    r = frame_index_setup(mh___0);
    }
#line 216
    if (r != 0) {
#line 216
      mh___0->err = 36;
    }
  }
#line 220
  return ((int __attribute__((__force_align_arg_pointer__))  )r);
}
}
#line 223 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_par(mpg123_pars *mp , enum mpg123_parms key ,
                                                             long val , double fval ) 
{ 
  int ret ;

  {
#line 225
  ret = 0;
#line 227
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 227
    return ((int __attribute__((__force_align_arg_pointer__))  )25);
  }
  {
#line 230
  if ((unsigned int )key == 0U) {
#line 230
    goto case_0;
  }
#line 233
  if ((unsigned int )key == 1U) {
#line 233
    goto case_1;
  }
#line 240
  if ((unsigned int )key == 2U) {
#line 240
    goto case_2;
  }
#line 249
  if ((unsigned int )key == 13U) {
#line 249
    goto case_13;
  }
#line 253
  if ((unsigned int )key == 3U) {
#line 253
    goto case_3;
  }
#line 262
  if ((unsigned int )key == 4U) {
#line 262
    goto case_4;
  }
#line 270
  if ((unsigned int )key == 5U) {
#line 270
    goto case_5;
  }
#line 274
  if ((unsigned int )key == 6U) {
#line 274
    goto case_6;
  }
#line 277
  if ((unsigned int )key == 7U) {
#line 277
    goto case_7;
  }
#line 280
  if ((unsigned int )key == 10U) {
#line 280
    goto case_10;
  }
#line 287
  if ((unsigned int )key == 11U) {
#line 287
    goto case_11;
  }
#line 292
  if ((unsigned int )key == 12U) {
#line 292
    goto case_12;
  }
#line 296
  if ((unsigned int )key == 14U) {
#line 296
    goto case_14;
  }
#line 299
  if ((unsigned int )key == 15U) {
#line 299
    goto case_15;
  }
#line 306
  if ((unsigned int )key == 16U) {
#line 306
    goto case_16;
  }
#line 310
  goto switch_default;
  case_0: /* CIL Label */ 
#line 231
  mp->verbose = (int )val;
#line 232
  goto switch_break;
  case_1: /* CIL Label */ 
#line 237
  if (ret == 0) {
#line 237
    mp->flags = val;
  }
#line 239
  goto switch_break;
  case_2: /* CIL Label */ 
#line 246
  mp->flags |= val;
#line 248
  goto switch_break;
  case_13: /* CIL Label */ 
#line 250
  mp->flags &= ~ val;
#line 252
  goto switch_break;
  case_3: /* CIL Label */ 
#line 258
  if (val > 96000L) {
#line 258
    ret = 3;
  } else
#line 259
  if (val < 0L) {
#line 259
    mp->force_rate = 0L;
  } else {
#line 259
    mp->force_rate = val;
  }
#line 261
  goto switch_break;
  case_4: /* CIL Label */ 
#line 266
  if (val < 0L) {
#line 266
    ret = 3;
  } else
#line 266
  if (val > 2L) {
#line 266
    ret = 3;
  } else {
#line 267
    mp->down_sample = (int )val;
  }
#line 269
  goto switch_break;
  case_5: /* CIL Label */ 
#line 271
  if (val < 0L) {
#line 271
    ret = 12;
  } else
#line 271
  if (val > 2L) {
#line 271
    ret = 12;
  } else {
#line 272
    mp->rva = (int )val;
  }
#line 273
  goto switch_break;
  case_6: /* CIL Label */ 
#line 275
  if (val < 0L) {
#line 275
    mp->halfspeed = 0L;
  } else {
#line 275
    mp->halfspeed = val;
  }
#line 276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 278
  if (val < 0L) {
#line 278
    mp->doublespeed = 0L;
  } else {
#line 278
    mp->doublespeed = val;
  }
#line 279
  goto switch_break;
  case_10: /* CIL Label */ 
#line 282
  if (val > 0L) {
#line 282
    mp->icy_interval = val;
  } else {
#line 282
    mp->icy_interval = 0L;
  }
#line 286
  goto switch_break;
  case_11: /* CIL Label */ 
#line 290
  if (val == 0L) {
#line 290
    mp->outscale = fval;
  } else {
#line 290
    mp->outscale = (double )val / (double )32768;
  }
#line 291
  goto switch_break;
  case_12: /* CIL Label */ 
#line 293
  if (val >= 0L) {
#line 293
    mp->timeout = val;
  } else {
#line 293
    mp->timeout = 0L;
  }
#line 295
  goto switch_break;
  case_14: /* CIL Label */ 
#line 297
  mp->resync_limit = val;
#line 298
  goto switch_break;
  case_15: /* CIL Label */ 
#line 301
  mp->index_size = val;
#line 305
  goto switch_break;
  case_16: /* CIL Label */ 
#line 307
  if (val >= 0L) {
#line 307
    mp->preframes = val;
  } else {
#line 308
    ret = 39;
  }
#line 309
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 311
  ret = 5;
  switch_break: /* CIL Label */ ;
  }
#line 313
  return ((int __attribute__((__force_align_arg_pointer__))  )ret);
}
}
#line 316 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_getparam(mpg123_handle *mh___0 ,
                                                                  enum mpg123_parms key ,
                                                                  long *val , double *fval ) 
{ 
  int r ;

  {
#line 320
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 320
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 321
  r = (int )mpg123_getpar(& mh___0->p, key, val, fval);
  }
#line 322
  if (r != 0) {
#line 322
    mh___0->err = r;
#line 322
    r = -1;
  }
#line 323
  return ((int __attribute__((__force_align_arg_pointer__))  )r);
}
}
#line 326 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_getpar(mpg123_pars *mp ,
                                                                enum mpg123_parms key ,
                                                                long *val , double *fval ) 
{ 
  int ret ;

  {
#line 328
  ret = 0;
#line 330
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 330
    return ((int __attribute__((__force_align_arg_pointer__))  )25);
  }
  {
#line 333
  if ((unsigned int )key == 0U) {
#line 333
    goto case_0;
  }
#line 337
  if ((unsigned int )key == 2U) {
#line 337
    goto case_2;
  }
#line 337
  if ((unsigned int )key == 1U) {
#line 337
    goto case_2;
  }
#line 340
  if ((unsigned int )key == 3U) {
#line 340
    goto case_3;
  }
#line 348
  if ((unsigned int )key == 4U) {
#line 348
    goto case_4;
  }
#line 351
  if ((unsigned int )key == 5U) {
#line 351
    goto case_5;
  }
#line 354
  if ((unsigned int )key == 6U) {
#line 354
    goto case_6;
  }
#line 357
  if ((unsigned int )key == 7U) {
#line 357
    goto case_7;
  }
#line 360
  if ((unsigned int )key == 10U) {
#line 360
    goto case_10;
  }
#line 367
  if ((unsigned int )key == 11U) {
#line 367
    goto case_11;
  }
#line 371
  if ((unsigned int )key == 14U) {
#line 371
    goto case_14;
  }
#line 374
  if ((unsigned int )key == 15U) {
#line 374
    goto case_15;
  }
#line 382
  if ((unsigned int )key == 16U) {
#line 382
    goto case_16;
  }
#line 385
  goto switch_default;
  case_0: /* CIL Label */ 
#line 334
  if (val) {
#line 334
    *val = (long )mp->verbose;
  }
#line 335
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 338
  if (val) {
#line 338
    *val = mp->flags;
  }
#line 339
  goto switch_break;
  case_3: /* CIL Label */ 
#line 341
  if (val) {
#line 345
    *val = mp->force_rate;
  }
#line 347
  goto switch_break;
  case_4: /* CIL Label */ 
#line 349
  if (val) {
#line 349
    *val = (long )mp->down_sample;
  }
#line 350
  goto switch_break;
  case_5: /* CIL Label */ 
#line 352
  if (val) {
#line 352
    *val = (long )mp->rva;
  }
#line 353
  goto switch_break;
  case_6: /* CIL Label */ 
#line 355
  if (val) {
#line 355
    *val = mp->halfspeed;
  }
#line 356
  goto switch_break;
  case_7: /* CIL Label */ 
#line 358
  if (val) {
#line 358
    *val = mp->doublespeed;
  }
#line 359
  goto switch_break;
  case_10: /* CIL Label */ 
#line 362
  if (val) {
#line 362
    *val = mp->icy_interval;
  }
#line 366
  goto switch_break;
  case_11: /* CIL Label */ 
#line 368
  if (fval) {
#line 368
    *fval = mp->outscale;
  }
#line 369
  if (val) {
#line 369
    *val = (long )(mp->outscale * (double )32768);
  }
#line 370
  goto switch_break;
  case_14: /* CIL Label */ 
#line 372
  if (val) {
#line 372
    *val = mp->resync_limit;
  }
#line 373
  goto switch_break;
  case_15: /* CIL Label */ 
#line 375
  if (val) {
#line 377
    *val = mp->index_size;
  }
#line 381
  goto switch_break;
  case_16: /* CIL Label */ 
#line 383
  *val = mp->preframes;
#line 384
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 386
  ret = 5;
  switch_break: /* CIL Label */ ;
  }
#line 388
  return ((int __attribute__((__force_align_arg_pointer__))  )ret);
}
}
#line 391 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_getstate(mpg123_handle *mh___0 ,
                                                                  enum mpg123_state key ,
                                                                  long *val , double *fval ) 
{ 
  int ret ;
  long theval ;
  double thefval ;

  {
#line 393
  ret = 0;
#line 394
  theval = 0L;
#line 395
  thefval = 0.;
#line 397
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 397
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 401
  if ((unsigned int )key == 1U) {
#line 401
    goto case_1;
  }
#line 404
  goto switch_default;
  case_1: /* CIL Label */ 
#line 402
  theval = (long )mh___0->accurate;
#line 403
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 405
  mh___0->err = 34;
#line 406
  ret = -1;
  switch_break: /* CIL Label */ ;
  }
#line 409
  if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 409
    *val = theval;
  }
#line 410
  if ((unsigned long )fval != (unsigned long )((void *)0)) {
#line 410
    *fval = thefval;
  }
#line 412
  return ((int __attribute__((__force_align_arg_pointer__))  )ret);
}
}
#line 415 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_eq(mpg123_handle *mh___0 ,
                                                            enum mpg123_channels channel ,
                                                            int band , double val ) 
{ 
  float tmp ;

  {
#line 418
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 418
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 419
  if (band < 0) {
#line 419
    mh___0->err = 16;
#line 419
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  } else
#line 419
  if (band > 31) {
#line 419
    mh___0->err = 16;
#line 419
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 422
  if ((unsigned int )channel == 3U) {
#line 422
    goto case_3;
  }
#line 425
  if ((unsigned int )channel == 1U) {
#line 425
    goto case_1;
  }
#line 426
  if ((unsigned int )channel == 2U) {
#line 426
    goto case_2;
  }
#line 427
  goto switch_default;
  case_3: /* CIL Label */ 
#line 423
  tmp = (float )val;
#line 423
  mh___0->equalizer[1][band] = tmp;
#line 423
  mh___0->equalizer[0][band] = tmp;
#line 424
  goto switch_break;
  case_1: /* CIL Label */ 
#line 425
  mh___0->equalizer[0][band] = (float )val;
#line 425
  goto switch_break;
  case_2: /* CIL Label */ 
#line 426
  mh___0->equalizer[1][band] = (float )val;
#line 426
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 428
  mh___0->err = 2;
#line 429
  return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  switch_break: /* CIL Label */ ;
  }
#line 431
  mh___0->have_eq_settings = 1;
#line 432
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 435 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
double __attribute__((__force_align_arg_pointer__))  mpg123_geteq(mpg123_handle *mh___0 ,
                                                                  enum mpg123_channels channel ,
                                                                  int band ) 
{ 
  double ret ;

  {
#line 437
  ret = 0.;
#line 439
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 439
    return ((double __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 442
  if (band > -1) {
#line 442
    if (band < 32) {
      {
#line 445
      if ((unsigned int )channel == 3U) {
#line 445
        goto case_3;
      }
#line 448
      if ((unsigned int )channel == 1U) {
#line 448
        goto case_1;
      }
#line 449
      if ((unsigned int )channel == 2U) {
#line 449
        goto case_2;
      }
#line 443
      goto switch_break;
      case_3: /* CIL Label */ 
#line 446
      ret = 0.5 * (double )(mh___0->equalizer[0][band] + mh___0->equalizer[1][band]);
#line 447
      goto switch_break;
      case_1: /* CIL Label */ 
#line 448
      ret = (double )mh___0->equalizer[0][band];
#line 448
      goto switch_break;
      case_2: /* CIL Label */ 
#line 449
      ret = (double )mh___0->equalizer[1][band];
#line 449
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 453
  return ((double __attribute__((__force_align_arg_pointer__))  )ret);
}
}
#line 458 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_open_64(mpg123_handle *mh___0 ,
                                                                 char const   *path ) 
{ 
  int tmp ;

  {
#line 461
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 461
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 463
  mpg123_close(mh___0);
#line 464
  frame_reset(mh___0);
#line 465
  tmp = open_stream(mh___0, path, -1);
  }
#line 465
  return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
}
}
#line 468 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_open_fd_64(mpg123_handle *mh___0 ,
                                                                    int fd ) 
{ 
  int tmp ;

  {
#line 471
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 471
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 473
  mpg123_close(mh___0);
#line 474
  frame_reset(mh___0);
#line 475
  tmp = open_stream(mh___0, (char const   *)((void *)0), fd);
  }
#line 475
  return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
}
}
#line 478 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_open_handle_64(mpg123_handle *mh___0 ,
                                                                        void *iohandle ) 
{ 
  int tmp ;

  {
#line 481
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 481
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 483
  mpg123_close(mh___0);
#line 484
  frame_reset(mh___0);
  }
#line 485
  if ((unsigned long )mh___0->rdat.r_read_handle == (unsigned long )((void *)0)) {
#line 487
    mh___0->err = 41;
#line 488
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 490
  tmp = open_stream_handle(mh___0, iohandle);
  }
#line 490
  return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
}
}
#line 493 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_open_feed(mpg123_handle *mh___0 ) 
{ 
  int tmp ;

  {
#line 496
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 496
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 498
  mpg123_close(mh___0);
#line 499
  frame_reset(mh___0);
#line 500
  tmp = open_feed(mh___0);
  }
#line 500
  return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
}
}
#line 503 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_replace_reader_64(mpg123_handle *mh___0 ,
                                                                           ssize_t (*r_read)(int  ,
                                                                                             void * ,
                                                                                             size_t  ) ,
                                                                           off_t (*r_lseek)(int  ,
                                                                                            off_t  ,
                                                                                            int  ) ) 
{ 


  {
#line 508
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 508
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 510
  mpg123_close(mh___0);
#line 511
  mh___0->rdat.r_read = r_read;
#line 512
  mh___0->rdat.r_lseek = r_lseek;
  }
#line 513
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 516 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_replace_reader_handle_64(mpg123_handle *mh___0 ,
                                                                                  ssize_t (*r_read)(void * ,
                                                                                                    void * ,
                                                                                                    size_t  ) ,
                                                                                  off_t (*r_lseek)(void * ,
                                                                                                   off_t  ,
                                                                                                   int  ) ,
                                                                                  void (*cleanup)(void * ) ) 
{ 


  {
#line 522
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 522
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 524
  mpg123_close(mh___0);
#line 525
  mh___0->rdat.r_read_handle = r_read;
#line 526
  mh___0->rdat.r_lseek_handle = r_lseek;
#line 527
  mh___0->rdat.cleanup_handle = cleanup;
  }
#line 528
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 531 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int decode_update(mpg123_handle *mh___0 ) 
{ 
  long native_rate ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  off_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;

  {
  {
#line 536
  native_rate = frame_freq(mh___0);
#line 538
  b = frame_output_format(mh___0);
  }
#line 539
  if (b < 0) {
#line 539
    return (-1);
  }
#line 541
  if (b == 1) {
#line 541
    mh___0->new_format = 1;
  }
#line 544
  if (mh___0->af.rate == native_rate) {
#line 544
    mh___0->down_sample = 0;
  } else
#line 545
  if (mh___0->af.rate == native_rate >> 1) {
#line 545
    mh___0->down_sample = 1;
  } else
#line 546
  if (mh___0->af.rate == native_rate >> 2) {
#line 546
    mh___0->down_sample = 2;
  } else {
#line 547
    mh___0->down_sample = 3;
  }
  {
#line 552
  if (mh___0->down_sample == 2) {
#line 552
    goto case_2;
  }
#line 552
  if (mh___0->down_sample == 1) {
#line 552
    goto case_2;
  }
#line 552
  if (mh___0->down_sample == 0) {
#line 552
    goto case_2;
  }
#line 558
  if (mh___0->down_sample == 3) {
#line 558
    goto case_3;
  }
#line 548
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 553
  mh___0->down_sample_sblimit = 32 >> mh___0->down_sample;
#line 555
  if (mh___0->lay == 1) {
#line 555
    tmp___1 = 384;
  } else {
#line 555
    if (mh___0->lay == 2) {
#line 555
      tmp___0 = 1152;
    } else {
#line 555
      if (mh___0->lsf) {
#line 555
        tmp = 576;
      } else
#line 555
      if (mh___0->mpeg25) {
#line 555
        tmp = 576;
      } else {
#line 555
        tmp = 1152;
      }
#line 555
      tmp___0 = tmp;
    }
#line 555
    tmp___1 = tmp___0;
  }
  {
#line 555
  tmp___2 = samples_to_bytes(mh___0, (off_t )(tmp___1 >> mh___0->down_sample));
#line 555
  mh___0->outblock = (size_t )tmp___2;
  }
#line 556
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 560
  tmp___3 = synth_ntom_set_step(mh___0);
  }
#line 560
  if (tmp___3 != 0) {
#line 560
    return (-1);
  }
  {
#line 561
  tmp___5 = frame_freq(mh___0);
  }
#line 561
  if (tmp___5 > mh___0->af.rate) {
    {
#line 563
    mh___0->down_sample_sblimit = (int )(32L * mh___0->af.rate);
#line 564
    tmp___4 = frame_freq(mh___0);
#line 564
    mh___0->down_sample_sblimit = (int )((long )mh___0->down_sample_sblimit / tmp___4);
    }
  } else {
#line 566
    mh___0->down_sample_sblimit = 32;
  }
#line 567
  if (mh___0->lay == 1) {
#line 567
    tmp___8 = 384;
  } else {
#line 567
    if (mh___0->lay == 2) {
#line 567
      tmp___7 = 1152;
    } else {
#line 567
      if (mh___0->lsf) {
#line 567
        tmp___6 = 576;
      } else
#line 567
      if (mh___0->mpeg25) {
#line 567
        tmp___6 = 576;
      } else {
#line 567
        tmp___6 = 1152;
      }
#line 567
      tmp___7 = tmp___6;
    }
#line 567
    tmp___8 = tmp___7;
  }
  {
#line 567
  tmp___9 = frame_freq(mh___0);
#line 567
  mh___0->outblock = (size_t )((long )(mh___0->af.encsize * mh___0->af.channels) * ((32767L + (long )tmp___8 * ((32768L * mh___0->af.rate) / tmp___9)) / 32768L));
  }
#line 572
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 576
  if (! (mh___0->p.flags & 7L)) {
#line 578
    if (mh___0->af.channels == 1) {
#line 578
      mh___0->single = 3;
    } else {
#line 579
      mh___0->single = -1;
    }
  } else {
#line 581
    mh___0->single = (int )((mh___0->p.flags & 7L) - 1L);
  }
  {
#line 582
  tmp___10 = set_synth_functions(mh___0);
  }
#line 582
  if (tmp___10 != 0) {
#line 582
    return (-1);
  }
  {
#line 584
  do_rva(mh___0);
  }
#line 587
  return (0);
}
}
#line 590 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
size_t __attribute__((__force_align_arg_pointer__))  mpg123_safe_buffer(void) 
{ 


  {
#line 593
  return ((size_t __attribute__((__force_align_arg_pointer__))  )(((sizeof(float ) * 2UL) * 1152UL) * 8UL));
}
}
#line 596 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
size_t __attribute__((__force_align_arg_pointer__))  mpg123_outblock(mpg123_handle *mh___0 ) 
{ 
  size_t __attribute__((__force_align_arg_pointer__))  tmp ;

  {
#line 598
  if ((unsigned long )mh___0 != (unsigned long )((void *)0)) {
#line 598
    return ((size_t __attribute__((__force_align_arg_pointer__))  )mh___0->outblock);
  } else {
    {
#line 599
    tmp = mpg123_safe_buffer();
    }
#line 599
    return (tmp);
  }
}
}
#line 602 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
static int get_next_frame(mpg123_handle *mh___0 ) 
{ 
  int change ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int b___0 ;

  {
#line 604
  change = mh___0->decoder_change;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    if (mh___0->to_ignore) {
#line 609
      if (mh___0->num < mh___0->firstframe) {
#line 609
        if (mh___0->num >= mh___0->ignoreframe) {
          {
#line 613
          (*(mh___0->do_layer))(mh___0);
#line 613
          mh___0->buffer.fill = (size_t )0;
          }
#line 616
          if (mh___0->down_sample == 3) {
            {
#line 616
            ntom_set_ntom(mh___0, mh___0->num + 1LL);
            }
          }
#line 618
          tmp = 0;
#line 618
          mh___0->to_decode = tmp;
#line 618
          mh___0->to_ignore = tmp;
        }
      }
    }
    {
#line 622
    mh___0->to_decode = 0;
#line 623
    b = read_frame(mh___0);
    }
#line 625
    if (b == -10) {
#line 625
      return (-10);
    } else
#line 626
    if (b <= 0) {
#line 629
      if (b == 0) {
#line 631
        mh___0->track_frames = mh___0->num + 1LL;
#line 633
        return (-12);
      } else
#line 629
      if (mh___0->rdat.filepos == mh___0->rdat.filelen) {
#line 631
        mh___0->track_frames = mh___0->num + 1LL;
#line 633
        return (-12);
      } else {
#line 635
        return (-1);
      }
    }
#line 638
    if (mh___0->header_change > 1) {
#line 641
      change = 1;
    }
#line 644
    (mh___0->playnum) ++;
#line 646
    if (mh___0->num < mh___0->firstframe) {
#line 646
      goto _L;
    } else
#line 646
    if (mh___0->p.doublespeed) {
#line 646
      if (mh___0->playnum % (long long )mh___0->p.doublespeed) {
        _L: /* CIL Label */ 
#line 648
        if (mh___0->to_ignore) {
#line 648
          if (mh___0->num < mh___0->firstframe) {
#line 648
            if (! (mh___0->num >= mh___0->ignoreframe)) {
              {
#line 650
              frame_skip(mh___0);
              }
            }
          } else {
            {
#line 650
            frame_skip(mh___0);
            }
          }
        } else {
          {
#line 650
          frame_skip(mh___0);
          }
        }
      } else {
#line 656
        goto while_break;
      }
    } else {
#line 656
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  if (change) {
    {
#line 661
    tmp___0 = decode_update(mh___0);
    }
#line 661
    if (tmp___0 < 0) {
#line 662
      return (-1);
    }
#line 666
    mh___0->decoder_change = 0;
#line 667
    if (mh___0->fresh) {
      {
#line 670
      b___0 = 0;
#line 673
      frame_gapless_realinit(mh___0);
#line 674
      frame_set_frameseek(mh___0, mh___0->num);
#line 676
      mh___0->fresh = 0;
      }
#line 679
      if (mh___0->num < mh___0->firstframe) {
        {
#line 679
        b___0 = get_next_frame(mh___0);
        }
      }
#line 680
      if (b___0 < 0) {
#line 680
        return (b___0);
      }
    }
  }
#line 684
  return (0);
}
}
#line 689 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
static int zero_byte(mpg123_handle *fr ) 
{ 
  int tmp ;

  {
#line 692
  if (fr->af.encoding & 15) {
#line 692
    tmp = (int )*(fr->conv16to8 + 0);
  } else {
#line 692
    tmp = 0;
  }
#line 692
  return (tmp);
}
}
#line 702 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
void decode_the_frame(mpg123_handle *fr ) 
{ 
  size_t needed_bytes ;
  off_t tmp ;
  off_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t i ;
  int32_t *ssamples ;
  uint32_t *usamples ;
  size_t i___0 ;
  short *ssamples___0 ;
  unsigned short *usamples___0 ;
  long tmp___3 ;
  char *__cil_tmp14 ;

  {
  {
#line 704
  tmp = frame_expect_outsamples(fr);
#line 704
  tmp___0 = samples_to_bytes(fr, tmp);
#line 704
  needed_bytes = (size_t )tmp___0;
#line 704
  tmp___1 = (*(fr->do_layer))(fr);
#line 704
  fr->clip += (long )tmp___1;
  }
#line 712
  if (fr->buffer.fill < needed_bytes) {
#line 714
    if (! (fr->p.flags & 32L)) {
#line 714
      if (fr->p.verbose > 1) {
        {
#line 715
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: broken frame %li, filling up with %lu zeroes, from %lu\n",
                (long )fr->num, (size_p )(needed_bytes - fr->buffer.fill), (size_p )fr->buffer.fill);
        }
      }
    }
    {
#line 723
    tmp___2 = zero_byte(fr);
#line 723
    memset((void *)(fr->buffer.data + fr->buffer.fill), tmp___2, needed_bytes - fr->buffer.fill);
#line 725
    fr->buffer.fill = needed_bytes;
#line 728
    ntom_set_ntom(fr, fr->num + 1LL);
    }
  }
#line 741
  if (fr->af.encoding == 8448) {
#line 746
    ssamples = (int32_t *)fr->buffer.data;
#line 747
    usamples = (uint32_t *)fr->buffer.data;
#line 749
    i = (size_t )0;
    {
#line 749
    while (1) {
      while_continue: /* CIL Label */ ;
#line 749
      if (! ((unsigned long )i < (unsigned long )fr->buffer.fill / sizeof(int32_t ))) {
#line 749
        goto while_break;
      }
#line 753
      if (*(ssamples + i) >= 0) {
#line 754
        *(usamples + i) = ((uint32_t )*(ssamples + i) + 2147483647U) + 1U;
      } else
#line 756
      if (*(ssamples + i) == (-0x7FFFFFFF-1)) {
#line 757
        *(usamples + i) = (uint32_t )0;
      } else {
#line 760
        *(usamples + i) = 2147483648U - (uint32_t )(- *(ssamples + i));
      }
#line 749
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 765
  if (fr->af.encoding == 96) {
#line 770
    ssamples___0 = (short *)fr->buffer.data;
#line 771
    usamples___0 = (unsigned short *)fr->buffer.data;
#line 773
    i___0 = (size_t )0;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! ((unsigned long )i___0 < (unsigned long )fr->buffer.fill / sizeof(short ))) {
#line 773
        goto while_break___0;
      }
#line 775
      tmp___3 = (long )*(ssamples___0 + i___0) + 32768L;
#line 776
      *(usamples___0 + i___0) = (unsigned short )tmp___3;
#line 773
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 780
  return;
}
}
#line 794 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_framebyframe_decode_64(mpg123_handle *mh___0 ,
                                                                                off_t *num ,
                                                                                unsigned char **audio ,
                                                                                size_t *bytes ) 
{ 
  int tmp ;

  {
#line 797
  if ((unsigned long )bytes == (unsigned long )((void *)0)) {
#line 797
    return ((int __attribute__((__force_align_arg_pointer__))  )17);
  }
#line 798
  if ((unsigned long )audio == (unsigned long )((void *)0)) {
#line 798
    return ((int __attribute__((__force_align_arg_pointer__))  )17);
  }
#line 799
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 799
    return ((int __attribute__((__force_align_arg_pointer__))  )10);
  }
#line 800
  if (mh___0->buffer.size < mh___0->outblock) {
#line 800
    return ((int __attribute__((__force_align_arg_pointer__))  )14);
  }
#line 802
  *bytes = (size_t )0;
#line 803
  mh___0->buffer.fill = (size_t )0;
#line 804
  if (! mh___0->to_decode) {
#line 804
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  }
#line 806
  if ((unsigned long )num != (unsigned long )((void *)0)) {
#line 806
    *num = mh___0->num;
  }
  {
#line 808
  decode_the_frame(mh___0);
#line 809
  tmp = 0;
#line 809
  mh___0->to_ignore = tmp;
#line 809
  mh___0->to_decode = tmp;
#line 810
  mh___0->buffer.p = mh___0->buffer.data;
#line 813
  frame_buffercheck(mh___0);
#line 815
  *audio = mh___0->buffer.p;
#line 816
  *bytes = mh___0->buffer.fill;
  }
#line 817
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 829 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_framebyframe_next(mpg123_handle *mh___0 ) 
{ 
  int b ;
  int tmp ;

  {
#line 832
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 832
    return ((int __attribute__((__force_align_arg_pointer__))  )10);
  }
  {
#line 834
  tmp = 0;
#line 834
  mh___0->to_ignore = tmp;
#line 834
  mh___0->to_decode = tmp;
#line 835
  mh___0->buffer.fill = (size_t )0;
#line 837
  b = get_next_frame(mh___0);
  }
#line 838
  if (b < 0) {
#line 838
    return ((int __attribute__((__force_align_arg_pointer__))  )b);
  }
#line 842
  if (! mh___0->to_decode) {
#line 843
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  }
#line 845
  if (mh___0->new_format) {
#line 848
    mh___0->new_format = 0;
#line 849
    return ((int __attribute__((__force_align_arg_pointer__))  )-11);
  }
#line 852
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 867 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_decode_frame_64(mpg123_handle *mh___0 ,
                                                                         off_t *num ,
                                                                         unsigned char **audio ,
                                                                         size_t *bytes ) 
{ 
  int tmp ;
  int b ;
  int tmp___0 ;

  {
#line 870
  if ((unsigned long )bytes != (unsigned long )((void *)0)) {
#line 870
    *bytes = (size_t )0;
  }
#line 871
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 871
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 872
  if (mh___0->buffer.size < mh___0->outblock) {
#line 872
    return ((int __attribute__((__force_align_arg_pointer__))  )14);
  }
#line 873
  mh___0->buffer.fill = (size_t )0;
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (mh___0->to_decode) {
#line 879
      if (mh___0->new_format) {
#line 882
        mh___0->new_format = 0;
#line 883
        return ((int __attribute__((__force_align_arg_pointer__))  )-11);
      }
#line 885
      if ((unsigned long )num != (unsigned long )((void *)0)) {
#line 885
        *num = mh___0->num;
      }
      {
#line 888
      decode_the_frame(mh___0);
#line 890
      tmp = 0;
#line 890
      mh___0->to_ignore = tmp;
#line 890
      mh___0->to_decode = tmp;
#line 891
      mh___0->buffer.p = mh___0->buffer.data;
#line 894
      frame_buffercheck(mh___0);
      }
#line 896
      if ((unsigned long )audio != (unsigned long )((void *)0)) {
#line 896
        *audio = mh___0->buffer.p;
      }
#line 897
      if ((unsigned long )bytes != (unsigned long )((void *)0)) {
#line 897
        *bytes = mh___0->buffer.fill;
      }
#line 899
      return ((int __attribute__((__force_align_arg_pointer__))  )0);
    } else {
      {
#line 903
      tmp___0 = get_next_frame(mh___0);
#line 903
      b = tmp___0;
      }
#line 904
      if (b < 0) {
#line 904
        return ((int __attribute__((__force_align_arg_pointer__))  )b);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 910 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_read(mpg123_handle *mh___0 ,
                                                              unsigned char *out ,
                                                              size_t size , size_t *done ) 
{ 
  int tmp ;

  {
  {
#line 912
  tmp = (int )mpg123_decode(mh___0, (unsigned char const   *)((void *)0), (size_t )0,
                            out, size, done);
  }
#line 912
  return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
}
}
#line 915 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_feed(mpg123_handle *mh___0 ,
                                                              unsigned char const   *in ,
                                                              size_t size ) 
{ 
  int tmp ;

  {
#line 917
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 917
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 918
  if (size > 0U) {
#line 920
    if ((unsigned long )in != (unsigned long )((void *)0)) {
      {
#line 922
      tmp = feed_more(mh___0, in, (long )size);
      }
#line 922
      if (tmp != 0) {
#line 922
        return ((int __attribute__((__force_align_arg_pointer__))  )-1);
      } else {
#line 927
        if (mh___0->err == 18) {
#line 927
          mh___0->err = 0;
        }
#line 929
        return ((int __attribute__((__force_align_arg_pointer__))  )0);
      }
    } else {
#line 934
      mh___0->err = 31;
#line 935
      return ((int __attribute__((__force_align_arg_pointer__))  )-1);
    }
  }
#line 938
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 955 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_decode(mpg123_handle *mh___0 ,
                                                                unsigned char const   *inmemory ,
                                                                size_t inmemsize ,
                                                                unsigned char *outmemory ,
                                                                size_t outmemsize ,
                                                                size_t *done ) 
{ 
  int ret ;
  size_t mdone ;
  int __attribute__((__force_align_arg_pointer__))  tmp ;
  int tmp___0 ;
  int a ;
  size_t tmp___1 ;
  int b ;
  int tmp___2 ;

  {
#line 957
  ret = 0;
#line 958
  mdone = (size_t )0;
#line 960
  if ((unsigned long )done != (unsigned long )((void *)0)) {
#line 960
    *done = (size_t )0;
  }
#line 961
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 961
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 962
  if (inmemsize > 0U) {
    {
#line 962
    tmp = mpg123_feed(mh___0, inmemory, inmemsize);
    }
#line 962
    if (tmp != (int __attribute__((__force_align_arg_pointer__))  )0) {
#line 964
      ret = -1;
#line 965
      goto decodeend;
    }
  }
#line 967
  if ((unsigned long )outmemory == (unsigned long )((void *)0)) {
#line 967
    outmemsize = (size_t )0;
  }
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 969
    if (! (ret == 0)) {
#line 969
      goto while_break;
    }
#line 974
    if (mh___0->to_decode) {
#line 976
      if (mh___0->new_format) {
#line 979
        mh___0->new_format = 0;
#line 980
        ret = -11;
#line 981
        goto decodeend;
      }
#line 983
      if (mh___0->buffer.size - mh___0->buffer.fill < mh___0->outblock) {
#line 985
        ret = 14;
#line 986
        goto decodeend;
      }
      {
#line 988
      decode_the_frame(mh___0);
#line 989
      tmp___0 = 0;
#line 989
      mh___0->to_ignore = tmp___0;
#line 989
      mh___0->to_decode = tmp___0;
#line 990
      mh___0->buffer.p = mh___0->buffer.data;
#line 993
      frame_buffercheck(mh___0);
      }
    }
#line 996
    if (mh___0->buffer.fill) {
#line 999
      if (mh___0->buffer.fill > outmemsize - mdone) {
#line 999
        tmp___1 = outmemsize - mdone;
      } else {
#line 999
        tmp___1 = mh___0->buffer.fill;
      }
      {
#line 999
      a = (int )tmp___1;
#line 1001
      memcpy((void */* __restrict  */)outmemory, (void const   */* __restrict  */)mh___0->buffer.p,
             (size_t )a);
#line 1003
      mh___0->buffer.fill -= (size_t )a;
#line 1004
      outmemory += a;
#line 1005
      mdone += (size_t )a;
#line 1006
      mh___0->buffer.p += a;
      }
#line 1007
      if (! (outmemsize > mdone)) {
#line 1007
        goto decodeend;
      }
    } else {
      {
#line 1011
      tmp___2 = get_next_frame(mh___0);
#line 1011
      b = tmp___2;
      }
#line 1012
      if (b < 0) {
#line 1012
        ret = b;
#line 1012
        goto decodeend;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  decodeend: 
#line 1016
  if ((unsigned long )done != (unsigned long )((void *)0)) {
#line 1016
    *done = mdone;
  }
#line 1017
  return ((int __attribute__((__force_align_arg_pointer__))  )ret);
}
}
#line 1020 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
long __attribute__((__force_align_arg_pointer__))  mpg123_clip(mpg123_handle *mh___0 ) 
{ 
  long ret ;

  {
#line 1022
  ret = 0L;
#line 1024
  if ((unsigned long )mh___0 != (unsigned long )((void *)0)) {
#line 1026
    ret = mh___0->clip;
#line 1027
    mh___0->clip = 0L;
  }
#line 1029
  return ((long __attribute__((__force_align_arg_pointer__))  )ret);
}
}
#line 1034 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
static int init_track(mpg123_handle *mh___0 ) 
{ 
  int b ;
  int tmp ;

  {
#line 1036
  if (! mh___0->to_decode) {
#line 1036
    if (mh___0->fresh) {
      {
#line 1039
      tmp = get_next_frame(mh___0);
#line 1039
      b = tmp;
      }
#line 1040
      if (b < 0) {
#line 1040
        return (b);
      }
    }
  }
#line 1042
  return (0);
}
}
#line 1045 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_getformat(mpg123_handle *mh___0 ,
                                                                   long *rate , int *channels ,
                                                                   int *encoding ) 
{ 
  int tmp ;

  {
#line 1048
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1048
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1049
  tmp = init_track(mh___0);
  }
#line 1049
  if (tmp == -1) {
#line 1049
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1051
  if ((unsigned long )rate != (unsigned long )((void *)0)) {
#line 1051
    *rate = mh___0->af.rate;
  }
#line 1052
  if ((unsigned long )channels != (unsigned long )((void *)0)) {
#line 1052
    *channels = mh___0->af.channels;
  }
#line 1053
  if ((unsigned long )encoding != (unsigned long )((void *)0)) {
#line 1053
    *encoding = mh___0->af.encoding;
  }
#line 1054
  mh___0->new_format = 0;
#line 1055
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 1058 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
off_t __attribute__((__force_align_arg_pointer__))  mpg123_timeframe_64(mpg123_handle *mh___0 ,
                                                                        double seconds ) 
{ 
  off_t b ;
  int tmp ;
  double tmp___0 ;

  {
#line 1062
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1062
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1063
  tmp = init_track(mh___0);
#line 1063
  b = (off_t )tmp;
  }
#line 1064
  if (b < 0LL) {
#line 1064
    return ((off_t __attribute__((__force_align_arg_pointer__))  )b);
  }
  {
#line 1065
  tmp___0 = (double )mpg123_tpf(mh___0);
  }
#line 1065
  return ((off_t __attribute__((__force_align_arg_pointer__))  )((off_t )(seconds / tmp___0)));
}
}
#line 1076 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
off_t __attribute__((__force_align_arg_pointer__))  mpg123_tell_64(mpg123_handle *mh___0 ) 
{ 
  off_t pos ;
  off_t tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  off_t tmp___2 ;
  off_t tmp___3 ;
  off_t tmp___4 ;

  {
#line 1079
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1079
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1080
  if (! mh___0->to_decode) {
#line 1080
    if (mh___0->fresh) {
#line 1080
      return ((off_t __attribute__((__force_align_arg_pointer__))  )0);
    }
  }
#line 1085
  pos = (off_t )0;
#line 1086
  if (mh___0->num < mh___0->firstframe) {
    {
#line 1088
    pos = frame_outs(mh___0, mh___0->firstframe);
#line 1090
    pos += mh___0->firstoff;
    }
  } else
#line 1086
  if (mh___0->num == mh___0->firstframe) {
#line 1086
    if (mh___0->to_decode) {
      {
#line 1088
      pos = frame_outs(mh___0, mh___0->firstframe);
#line 1090
      pos += mh___0->firstoff;
      }
    } else {
#line 1086
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1093
  if (mh___0->to_decode) {
    {
#line 1095
    tmp = frame_outs(mh___0, mh___0->num);
#line 1095
    tmp___0 = bytes_to_samples(mh___0, (off_t )mh___0->buffer.fill);
#line 1095
    pos = tmp - tmp___0;
    }
  } else {
    {
#line 1099
    tmp___1 = frame_outs(mh___0, mh___0->num + 1LL);
#line 1099
    tmp___2 = bytes_to_samples(mh___0, (off_t )mh___0->buffer.fill);
#line 1099
    pos = tmp___1 - tmp___2;
    }
  }
#line 1102
  if (mh___0->p.flags & 64L) {
#line 1102
    tmp___3 = mh___0->begin_os;
  } else {
#line 1102
    tmp___3 = (off_t )0;
  }
#line 1102
  pos -= tmp___3;
#line 1104
  if (pos > 0LL) {
#line 1104
    tmp___4 = pos;
  } else {
#line 1104
    tmp___4 = (off_t )0;
  }
#line 1104
  return ((off_t __attribute__((__force_align_arg_pointer__))  )tmp___4);
}
}
#line 1108 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
off_t __attribute__((__force_align_arg_pointer__))  mpg123_tellframe_64(mpg123_handle *mh___0 ) 
{ 
  off_t tmp ;

  {
#line 1111
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1111
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1112
  if (mh___0->num < mh___0->firstframe) {
#line 1112
    return ((off_t __attribute__((__force_align_arg_pointer__))  )mh___0->firstframe);
  }
#line 1113
  if (mh___0->to_decode) {
#line 1113
    return ((off_t __attribute__((__force_align_arg_pointer__))  )mh___0->num);
  }
#line 1115
  if (mh___0->buffer.fill) {
#line 1115
    tmp = mh___0->num;
  } else {
#line 1115
    tmp = mh___0->num + 1LL;
  }
#line 1115
  return ((off_t __attribute__((__force_align_arg_pointer__))  )tmp);
}
}
#line 1118 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
off_t __attribute__((__force_align_arg_pointer__))  mpg123_tell_stream_64(mpg123_handle *mh___0 ) 
{ 
  off_t tmp ;

  {
#line 1121
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1121
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1123
  tmp = (*((mh___0->rd)->tell))(mh___0);
  }
#line 1123
  return ((off_t __attribute__((__force_align_arg_pointer__))  )tmp);
}
}
#line 1126 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
static int do_the_seek(mpg123_handle *mh___0 ) 
{ 
  int b ;
  off_t fnum ;
  off_t tmp ;

  {
#line 1129
  if (mh___0->ignoreframe < 0LL) {
#line 1129
    tmp = (off_t )0;
  } else {
#line 1129
    tmp = mh___0->ignoreframe;
  }
#line 1129
  fnum = tmp;
#line 1130
  mh___0->buffer.fill = (size_t )0;
#line 1133
  if (mh___0->num < mh___0->firstframe) {
#line 1135
    mh___0->to_decode = 0;
#line 1136
    if (mh___0->num > fnum) {
#line 1136
      return (0);
    }
  }
#line 1140
  if (mh___0->num == fnum) {
#line 1140
    if (mh___0->to_decode) {
#line 1140
      return (0);
    } else
#line 1140
    if (fnum < mh___0->firstframe) {
#line 1140
      return (0);
    }
  }
#line 1142
  if (mh___0->num == fnum - 1LL) {
#line 1144
    mh___0->to_decode = 0;
#line 1145
    return (0);
  }
  {
#line 1149
  frame_buffers_reset(mh___0);
  }
#line 1151
  if (mh___0->down_sample == 3) {
    {
#line 1153
    ntom_set_ntom(mh___0, fnum);
    }
  }
  {
#line 1157
  b = (*((mh___0->rd)->seek_frame))(mh___0, fnum);
  }
#line 1159
  if (b < 0) {
#line 1159
    return (b);
  }
#line 1161
  if (mh___0->num < mh___0->firstframe) {
#line 1161
    mh___0->to_decode = 0;
  }
#line 1163
  mh___0->playnum = mh___0->num;
#line 1164
  return (0);
}
}
#line 1167 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
off_t __attribute__((__force_align_arg_pointer__))  mpg123_seek_64(mpg123_handle *mh___0 ,
                                                                   off_t sampleoff ,
                                                                   int whence ) 
{ 
  int b ;
  off_t pos ;
  off_t __attribute__((__force_align_arg_pointer__))  tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  int tmp___2 ;
  off_t __attribute__((__force_align_arg_pointer__))  tmp___3 ;

  {
  {
#line 1172
  tmp = mpg123_tell_64(mh___0);
#line 1172
  pos = (off_t )tmp;
  }
#line 1175
  if (pos < 0LL) {
#line 1175
    if (whence != 0) {
#line 1177
      if ((unsigned long )mh___0 != (unsigned long )((void *)0)) {
#line 1177
        mh___0->err = 32;
      }
#line 1178
      return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
    }
  }
  {
#line 1180
  b = init_track(mh___0);
  }
#line 1180
  if (b < 0) {
#line 1180
    return ((off_t __attribute__((__force_align_arg_pointer__))  )b);
  }
  {
#line 1183
  if (whence == 1) {
#line 1183
    goto case_1;
  }
#line 1184
  if (whence == 0) {
#line 1184
    goto case_0;
  }
#line 1185
  if (whence == 2) {
#line 1185
    goto case_2;
  }
#line 1200
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1183
  pos += sampleoff;
#line 1183
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1184
  pos = sampleoff;
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if (mh___0->track_frames < 1LL) {
#line 1187
    if (mh___0->rdat.flags & 4) {
      {
#line 1188
      mpg123_scan(mh___0);
      }
    }
  }
#line 1190
  if (mh___0->end_os > 0LL) {
#line 1190
    if (mh___0->p.flags & 64L) {
#line 1190
      tmp___0 = mh___0->begin_os;
    } else {
#line 1190
      tmp___0 = (off_t )0;
    }
#line 1190
    pos = (mh___0->end_os - tmp___0) - sampleoff;
  } else {
#line 1196
    mh___0->err = 19;
#line 1197
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1199
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1200
  mh___0->err = 20;
#line 1200
  return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  switch_break: /* CIL Label */ ;
  }
#line 1202
  if (pos < 0LL) {
#line 1202
    pos = (off_t )0;
  }
#line 1204
  if (mh___0->p.flags & 64L) {
#line 1204
    tmp___1 = mh___0->begin_os;
  } else {
#line 1204
    tmp___1 = (off_t )0;
  }
  {
#line 1204
  frame_set_seek(mh___0, pos + tmp___1);
#line 1205
  tmp___2 = do_the_seek(mh___0);
#line 1205
  pos = (off_t )tmp___2;
  }
#line 1206
  if (pos < 0LL) {
#line 1206
    return ((off_t __attribute__((__force_align_arg_pointer__))  )pos);
  }
  {
#line 1208
  tmp___3 = mpg123_tell_64(mh___0);
  }
#line 1208
  return (tmp___3);
}
}
#line 1217 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
off_t __attribute__((__force_align_arg_pointer__))  mpg123_feedseek_64(mpg123_handle *mh___0 ,
                                                                       off_t sampleoff ,
                                                                       int whence ,
                                                                       off_t *input_offset ) 
{ 
  int b ;
  off_t pos ;
  off_t __attribute__((__force_align_arg_pointer__))  tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  off_t tmp___2 ;
  off_t tmp___3 ;
  off_t __attribute__((__force_align_arg_pointer__))  tmp___4 ;

  {
  {
#line 1222
  tmp = mpg123_tell_64(mh___0);
#line 1222
  pos = (off_t )tmp;
  }
#line 1225
  if (pos < 0LL) {
#line 1225
    return ((off_t __attribute__((__force_align_arg_pointer__))  )pos);
  }
#line 1226
  if ((unsigned long )input_offset == (unsigned long )((void *)0)) {
#line 1228
    mh___0->err = 33;
#line 1229
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1232
  b = init_track(mh___0);
  }
#line 1232
  if (b < 0) {
#line 1232
    return ((off_t __attribute__((__force_align_arg_pointer__))  )b);
  }
  {
#line 1236
  if (whence == 1) {
#line 1236
    goto case_1;
  }
#line 1237
  if (whence == 0) {
#line 1237
    goto case_0;
  }
#line 1238
  if (whence == 2) {
#line 1238
    goto case_2;
  }
#line 1250
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1236
  pos += sampleoff;
#line 1236
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1237
  pos = sampleoff;
#line 1237
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1240
  if (mh___0->end_os >= 0LL) {
#line 1240
    if (mh___0->p.flags & 64L) {
#line 1240
      tmp___0 = mh___0->begin_os;
    } else {
#line 1240
      tmp___0 = (off_t )0;
    }
#line 1240
    pos = (mh___0->end_os - tmp___0) - sampleoff;
  } else {
#line 1246
    mh___0->err = 19;
#line 1247
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1249
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1250
  mh___0->err = 20;
#line 1250
  return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  switch_break: /* CIL Label */ ;
  }
#line 1252
  if (pos < 0LL) {
#line 1252
    pos = (off_t )0;
  }
#line 1253
  if (mh___0->p.flags & 64L) {
#line 1253
    tmp___1 = mh___0->begin_os;
  } else {
#line 1253
    tmp___1 = (off_t )0;
  }
  {
#line 1253
  frame_set_seek(mh___0, pos + tmp___1);
  }
#line 1254
  if (mh___0->ignoreframe < 0LL) {
#line 1254
    pos = (off_t )0;
  } else {
#line 1254
    pos = mh___0->ignoreframe;
  }
#line 1255
  mh___0->buffer.fill = (size_t )0;
#line 1258
  *input_offset = mh___0->rdat.buffer.fileoff + (off_t )mh___0->rdat.buffer.size;
#line 1259
  if (mh___0->num < mh___0->firstframe) {
#line 1259
    mh___0->to_decode = 0;
  }
#line 1260
  if (mh___0->num == pos) {
#line 1260
    if (mh___0->to_decode) {
#line 1260
      goto feedseekend;
    }
  }
#line 1261
  if (mh___0->num == pos - 1LL) {
#line 1261
    goto feedseekend;
  }
#line 1263
  if (mh___0->ignoreframe < 0LL) {
#line 1263
    tmp___2 = (off_t )0;
  } else {
#line 1263
    tmp___2 = mh___0->ignoreframe;
  }
  {
#line 1263
  tmp___3 = frame_index_find(mh___0, tmp___2, & pos);
#line 1263
  *input_offset = feed_set_pos(mh___0, tmp___3);
#line 1264
  mh___0->num = pos - 1LL;
  }
#line 1265
  if (*input_offset < 0LL) {
#line 1265
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
  feedseekend: 
  {
#line 1268
  tmp___4 = mpg123_tell_64(mh___0);
  }
#line 1268
  return (tmp___4);
}
}
#line 1271 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
off_t __attribute__((__force_align_arg_pointer__))  mpg123_seek_frame_64(mpg123_handle *mh___0 ,
                                                                         off_t offset___0 ,
                                                                         int whence ) 
{ 
  int b ;
  off_t pos ;
  int tmp ;
  off_t __attribute__((__force_align_arg_pointer__))  tmp___0 ;

  {
#line 1274
  pos = (off_t )0;
#line 1276
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1276
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1277
  b = init_track(mh___0);
  }
#line 1277
  if (b < 0) {
#line 1277
    return ((off_t __attribute__((__force_align_arg_pointer__))  )b);
  }
#line 1280
  pos = mh___0->num;
  {
#line 1283
  if (whence == 1) {
#line 1283
    goto case_1;
  }
#line 1284
  if (whence == 0) {
#line 1284
    goto case_0;
  }
#line 1285
  if (whence == 2) {
#line 1285
    goto case_2;
  }
#line 1293
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1283
  pos += offset___0;
#line 1283
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1284
  pos = offset___0;
#line 1284
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1286
  if (mh___0->track_frames > 0LL) {
#line 1286
    pos = mh___0->track_frames - offset___0;
  } else {
#line 1289
    mh___0->err = 19;
#line 1290
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1292
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1294
  mh___0->err = 20;
#line 1295
  return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  switch_break: /* CIL Label */ ;
  }
#line 1297
  if (pos < 0LL) {
#line 1297
    pos = (off_t )0;
  } else
#line 1299
  if (mh___0->track_frames > 0LL) {
#line 1299
    if (pos >= mh___0->track_frames) {
#line 1299
      pos = mh___0->track_frames;
    }
  }
  {
#line 1301
  frame_set_frameseek(mh___0, pos);
#line 1302
  tmp = do_the_seek(mh___0);
#line 1302
  pos = (off_t )tmp;
  }
#line 1303
  if (pos < 0LL) {
#line 1303
    return ((off_t __attribute__((__force_align_arg_pointer__))  )pos);
  }
  {
#line 1305
  tmp___0 = mpg123_tellframe_64(mh___0);
  }
#line 1305
  return (tmp___0);
}
}
#line 1308 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_set_filesize_64(mpg123_handle *mh___0 ,
                                                                         off_t size ) 
{ 


  {
#line 1311
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1311
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1313
  mh___0->rdat.filelen = size;
#line 1314
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 1317 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
off_t __attribute__((__force_align_arg_pointer__))  mpg123_length_64(mpg123_handle *mh___0 ) 
{ 
  int b ;
  off_t length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double bpf ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  off_t __attribute__((__force_align_arg_pointer__))  tmp___7 ;

  {
#line 1322
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1322
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1323
  b = init_track(mh___0);
  }
#line 1324
  if (b < 0) {
#line 1324
    return ((off_t __attribute__((__force_align_arg_pointer__))  )b);
  }
#line 1325
  if (mh___0->track_samples > -1LL) {
#line 1325
    length = mh___0->track_samples;
  } else
#line 1326
  if (mh___0->track_frames > 0LL) {
#line 1326
    if (mh___0->lay == 1) {
#line 1326
      tmp___1 = 384;
    } else {
#line 1326
      if (mh___0->lay == 2) {
#line 1326
        tmp___0 = 1152;
      } else {
#line 1326
        if (mh___0->lsf) {
#line 1326
          tmp = 576;
        } else
#line 1326
        if (mh___0->mpeg25) {
#line 1326
          tmp = 576;
        } else {
#line 1326
          tmp = 1152;
        }
#line 1326
        tmp___0 = tmp;
      }
#line 1326
      tmp___1 = tmp___0;
    }
#line 1326
    length = mh___0->track_frames * (off_t )tmp___1;
  } else
#line 1327
  if (mh___0->rdat.filelen > 0LL) {
#line 1330
    if (mh___0->mean_framesize) {
#line 1330
      tmp___3 = mh___0->mean_framesize;
    } else {
      {
#line 1330
      tmp___2 = compute_bpf(mh___0);
#line 1330
      tmp___3 = tmp___2;
      }
    }
#line 1330
    bpf = tmp___3;
#line 1331
    if (mh___0->lay == 1) {
#line 1331
      tmp___6 = 384;
    } else {
#line 1331
      if (mh___0->lay == 2) {
#line 1331
        tmp___5 = 1152;
      } else {
#line 1331
        if (mh___0->lsf) {
#line 1331
          tmp___4 = 576;
        } else
#line 1331
        if (mh___0->mpeg25) {
#line 1331
          tmp___4 = 576;
        } else {
#line 1331
          tmp___4 = 1152;
        }
#line 1331
        tmp___5 = tmp___4;
      }
#line 1331
      tmp___6 = tmp___5;
    }
#line 1331
    length = (off_t )(((double )mh___0->rdat.filelen / bpf) * (double )tmp___6);
  } else
#line 1333
  if (mh___0->rdat.filelen == 0LL) {
    {
#line 1333
    tmp___7 = mpg123_tell_64(mh___0);
    }
#line 1333
    return (tmp___7);
  } else {
#line 1334
    return ((off_t __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1338
  length = frame_ins2outs(mh___0, length);
  }
#line 1341
  if (mh___0->p.flags & 64L) {
#line 1344
    if (mh___0->end_os > 0LL) {
#line 1344
      if (length > mh___0->end_os) {
#line 1344
        length = mh___0->end_os;
      }
    }
#line 1345
    length -= mh___0->begin_os;
  }
#line 1349
  return ((off_t __attribute__((__force_align_arg_pointer__))  )length);
}
}
#line 1352 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_scan(mpg123_handle *mh___0 ) 
{ 
  int b ;
  off_t backframe ;
  int to_decode ;
  int to_ignore ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1358
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1358
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1359
  if (! (mh___0->rdat.flags & 4)) {
#line 1359
    mh___0->err = 23;
#line 1359
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1363
  b = init_track(mh___0);
  }
#line 1364
  if (b < 0) {
#line 1366
    if (b == -12) {
#line 1366
      return ((int __attribute__((__force_align_arg_pointer__))  )0);
    } else {
#line 1367
      return ((int __attribute__((__force_align_arg_pointer__))  )-1);
    }
  }
  {
#line 1369
  backframe = mh___0->num;
#line 1370
  to_decode = mh___0->to_decode;
#line 1371
  to_ignore = mh___0->to_ignore;
#line 1372
  b = (*((mh___0->rd)->seek_frame))(mh___0, (off_t )0);
  }
#line 1373
  if (b < 0) {
#line 1373
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  } else
#line 1373
  if (mh___0->num != 0LL) {
#line 1373
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1375
  mh___0->track_frames = (off_t )1;
#line 1376
  if (mh___0->lay == 1) {
#line 1376
    mh___0->track_samples = (off_t )384;
  } else {
#line 1376
    if (mh___0->lay == 2) {
#line 1376
      tmp___0 = 1152;
    } else {
#line 1376
      if (mh___0->lsf) {
#line 1376
        tmp = 576;
      } else
#line 1376
      if (mh___0->mpeg25) {
#line 1376
        tmp = 576;
      } else {
#line 1376
        tmp = 1152;
      }
#line 1376
      tmp___0 = tmp;
    }
#line 1376
    mh___0->track_samples = (off_t )tmp___0;
  }
  {
#line 1378
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1378
    tmp___4 = read_frame(mh___0);
    }
#line 1378
    if (! (tmp___4 == 1)) {
#line 1378
      goto while_break;
    }
#line 1380
    (mh___0->track_frames) ++;
#line 1381
    if (mh___0->lay == 1) {
#line 1381
      tmp___3 = 384;
    } else {
#line 1381
      if (mh___0->lay == 2) {
#line 1381
        tmp___2 = 1152;
      } else {
#line 1381
        if (mh___0->lsf) {
#line 1381
          tmp___1 = 576;
        } else
#line 1381
        if (mh___0->mpeg25) {
#line 1381
          tmp___1 = 576;
        } else {
#line 1381
          tmp___1 = 1152;
        }
#line 1381
        tmp___2 = tmp___1;
      }
#line 1381
      tmp___3 = tmp___2;
    }
#line 1381
    mh___0->track_samples += (off_t )tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1386
  frame_gapless_update(mh___0, mh___0->track_samples);
#line 1388
  b = (*((mh___0->rd)->seek_frame))(mh___0, backframe);
  }
#line 1389
  if (b < 0) {
#line 1389
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  } else
#line 1389
  if (mh___0->num != backframe) {
#line 1389
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1390
  mh___0->to_decode = to_decode;
#line 1391
  mh___0->to_ignore = to_ignore;
#line 1392
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 1395 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_meta_check(mpg123_handle *mh___0 ) 
{ 


  {
#line 1397
  if ((unsigned long )mh___0 != (unsigned long )((void *)0)) {
#line 1397
    return ((int __attribute__((__force_align_arg_pointer__))  )mh___0->metaflags);
  } else {
#line 1398
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  }
}
}
#line 1401 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_id3(mpg123_handle *mh___0 ,
                                                             mpg123_id3v1 **v1 , mpg123_id3v2 **v2 ) 
{ 


  {
#line 1404
  if ((unsigned long )v1 != (unsigned long )((void *)0)) {
#line 1404
    *v1 = (mpg123_id3v1 *)((void *)0);
  }
#line 1405
  if ((unsigned long )v2 != (unsigned long )((void *)0)) {
#line 1405
    *v2 = (mpg123_id3v2 *)((void *)0);
  }
#line 1406
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1406
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1408
  if (mh___0->metaflags & 3) {
    {
#line 1410
    id3_link(mh___0);
    }
#line 1411
    if ((unsigned long )v1 != (unsigned long )((void *)0)) {
#line 1411
      if (mh___0->rdat.flags & 2) {
#line 1411
        *v1 = (mpg123_id3v1 *)(mh___0->id3buf);
      }
    }
#line 1412
    if ((unsigned long )v2 != (unsigned long )((void *)0)) {
#line 1416
      *v2 = & mh___0->id3v2;
    }
#line 1419
    mh___0->metaflags |= 3;
#line 1420
    mh___0->metaflags &= -2;
  }
#line 1422
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 1425 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_icy(mpg123_handle *mh___0 ,
                                                             char **icy_meta ) 
{ 


  {
#line 1428
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1428
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1430
  if ((unsigned long )icy_meta == (unsigned long )((void *)0)) {
#line 1432
    mh___0->err = 33;
#line 1433
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1435
  *icy_meta = (char *)((void *)0);
#line 1437
  if (mh___0->metaflags & 12) {
#line 1439
    *icy_meta = mh___0->icy.data;
#line 1440
    mh___0->metaflags |= 12;
#line 1441
    mh___0->metaflags &= -5;
  }
#line 1443
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 1455 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
char * __attribute__((__force_align_arg_pointer__)) mpg123_icy2utf8(char const   *icy_text ) 
{ 
  char *tmp ;

  {
  {
#line 1458
  tmp = icy2utf8(icy_text, 0);
  }
#line 1458
  return ((char */* __attribute__((__force_align_arg_pointer__)) */)tmp);
}
}
#line 1465 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
enum mpg123_text_encoding  __attribute__((__force_align_arg_pointer__)) mpg123_enc_from_id3(unsigned char id3_enc_byte ) 
{ 


  {
  {
#line 1469
  if ((int )id3_enc_byte == 0) {
#line 1469
    goto case_0;
  }
#line 1470
  if ((int )id3_enc_byte == 1) {
#line 1470
    goto case_1;
  }
#line 1471
  if ((int )id3_enc_byte == 2) {
#line 1471
    goto case_2;
  }
#line 1472
  if ((int )id3_enc_byte == 3) {
#line 1472
    goto case_3;
  }
#line 1473
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1469
  return ((enum mpg123_text_encoding  __attribute__((__force_align_arg_pointer__)) )2);
  case_1: /* CIL Label */ 
#line 1470
  return ((enum mpg123_text_encoding  __attribute__((__force_align_arg_pointer__)) )6);
  case_2: /* CIL Label */ 
#line 1471
  return ((enum mpg123_text_encoding  __attribute__((__force_align_arg_pointer__)) )7);
  case_3: /* CIL Label */ 
#line 1472
  return ((enum mpg123_text_encoding  __attribute__((__force_align_arg_pointer__)) )1);
  switch_default: /* CIL Label */ 
#line 1473
  return ((enum mpg123_text_encoding  __attribute__((__force_align_arg_pointer__)) )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1478 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int mpg123_store_utf8(mpg123_string *sb , enum mpg123_text_encoding enc , unsigned char const   *source ,
                      size_t source_size ) 
{ 
  char *tmpstring ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1484
  if ((unsigned int )enc == 1U) {
#line 1484
    goto case_1;
  }
#line 1487
  if ((unsigned int )enc == 2U) {
#line 1487
    goto case_2;
  }
#line 1491
  if ((unsigned int )enc == 5U) {
#line 1491
    goto case_5;
  }
#line 1491
  if ((unsigned int )enc == 6U) {
#line 1491
    goto case_5;
  }
#line 1495
  if ((unsigned int )enc == 7U) {
#line 1495
    goto case_7;
  }
#line 1502
  if ((unsigned int )enc == 4U) {
#line 1502
    goto case_4;
  }
#line 1502
  if ((unsigned int )enc == 3U) {
#line 1502
    goto case_4;
  }
#line 1519
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1485
  id3_to_utf8(sb, (unsigned char)3, source, source_size, 0);
  }
#line 1486
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1488
  id3_to_utf8(sb, (unsigned char)0, source, source_size, 0);
  }
#line 1489
  goto switch_break;
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 1492
  id3_to_utf8(sb, (unsigned char)1, source, source_size, 0);
  }
#line 1493
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1496
  id3_to_utf8(sb, (unsigned char)2, source, source_size, 0);
  }
#line 1497
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1504
  mpg123_free_string(sb);
  }
#line 1506
  if ((int const   )*(source + (source_size - 1U)) == 0) {
#line 1509
    if ((unsigned int )enc == 4U) {
#line 1509
      tmp = 1;
    } else {
#line 1509
      tmp = 0;
    }
    {
#line 1509
    tmp___0 = icy2utf8((char const   *)source, tmp);
#line 1509
    tmpstring = tmp___0;
    }
#line 1510
    if ((unsigned long )tmpstring != (unsigned long )((void *)0)) {
      {
#line 1512
      mpg123_set_string(sb, (char const   *)tmpstring);
#line 1513
      free((void *)tmpstring);
      }
    }
  }
#line 1517
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1520
  mpg123_free_string(sb);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1523
  if (sb->fill > 0U) {
#line 1523
    tmp___1 = 1;
  } else {
#line 1523
    tmp___1 = 0;
  }
#line 1523
  return (tmp___1);
}
}
#line 1527 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_index_64(mpg123_handle *mh___0 ,
                                                                  off_t **offsets ,
                                                                  off_t *step___30 ,
                                                                  size_t *fill ) 
{ 


  {
#line 1530
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1530
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1531
  if ((unsigned long )offsets == (unsigned long )((void *)0)) {
#line 1533
    mh___0->err = 26;
#line 1534
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  } else
#line 1531
  if ((unsigned long )step___30 == (unsigned long )((void *)0)) {
#line 1533
    mh___0->err = 26;
#line 1534
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  } else
#line 1531
  if ((unsigned long )fill == (unsigned long )((void *)0)) {
#line 1533
    mh___0->err = 26;
#line 1534
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1537
  *offsets = mh___0->index.data;
#line 1538
  *step___30 = mh___0->index.step;
#line 1539
  *fill = mh___0->index.fill;
#line 1545
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 1548 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_set_index_64(mpg123_handle *mh___0 ,
                                                                      off_t *offsets ,
                                                                      off_t step___30 ,
                                                                      size_t fill ) 
{ 
  int tmp ;

  {
#line 1551
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1551
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1553
  if (step___30 == 0LL) {
#line 1555
    mh___0->err = 26;
#line 1556
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1558
  tmp = fi_set(& mh___0->index, offsets, step___30, fill);
  }
#line 1558
  if (tmp == -1) {
#line 1560
    mh___0->err = 7;
#line 1561
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1563
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 1570 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_close(mpg123_handle *mh___0 ) 
{ 


  {
#line 1573
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 1573
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1574
  if ((unsigned long )mh___0->rd != (unsigned long )((void *)0)) {
#line 1574
    if ((unsigned long )(mh___0->rd)->close != (unsigned long )((void *)0)) {
      {
#line 1574
      (*((mh___0->rd)->close))(mh___0);
      }
    }
  }
#line 1575
  mh___0->rd = (struct reader *)((void *)0);
#line 1576
  if (mh___0->new_format) {
    {
#line 1579
    invalidate_format(& mh___0->af);
#line 1580
    mh___0->new_format = 0;
    }
  }
#line 1582
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 1585 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
void __attribute__((__force_align_arg_pointer__))  mpg123_delete(mpg123_handle *mh___0 ) 
{ 


  {
#line 1587
  if ((unsigned long )mh___0 != (unsigned long )((void *)0)) {
    {
#line 1589
    mpg123_close(mh___0);
#line 1590
    frame_exit(mh___0);
#line 1591
    free((void *)mh___0);
    }
  }
#line 1593
  return;
}
}
#line 1595 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
static char const   *mpg123_error[43]  = 
#line 1595
  {      "No error... (code 0)",      "Unable to set up output format! (code 1)",      "Invalid channel number specified. (code 2)",      "Invalid sample rate specified. (code 3)", 
        "Unable to allocate memory for 16 to 8 converter table! (code 4)",      "Bad parameter id! (code 5)",      "Bad buffer given -- invalid pointer or too small size. (code 6)",      "Out of memory -- some malloc() failed. (code 7)", 
        "You didn\'t initialize the library! (code 8)",      "Invalid decoder choice. (code 9)",      "Invalid mpg123 handle. (code 10)",      "Unable to initialize frame buffers (out of memory?)! (code 11)", 
        "Invalid RVA mode. (code 12)",      "This build doesn\'t support gapless decoding. (code 13)",      "Not enough buffer space. (code 14)",      "Incompatible numeric data types. (code 15)", 
        "Bad equalizer band. (code 16)",      "Null pointer given where valid storage address needed. (code 17)",      "Error reading the stream. (code 18)",      "Cannot seek from end (end is not known). (code 19)", 
        "Invalid \'whence\' for seek function. (code 20)",      "Build does not support stream timeouts. (code 21)",      "File access error. (code 22)",      "Seek not supported by stream. (code 23)", 
        "No stream opened. (code 24)",      "Bad parameter handle. (code 25)",      "Invalid parameter addresses for index retrieval. (code 26)",      "Lost track in the bytestream and did not attempt resync. (code 27)", 
        "Failed to find valid MPEG data within limit on resync. (code 28)",      "No 8bit encoding possible. (code 29)",      "Stack alignment is not good. (code 30)",      "You gave me a NULL buffer? (code 31)", 
        "File position is screwed up, please do an absolute seek (code 32)",      "Inappropriate NULL-pointer provided.",      "Bad key value given.",      "There is no frame index (disabled in this build).", 
        "Frame index operation failed.",      "Decoder setup failed (invalid combination of settings?)",      "Feature not in this build.",      "Some bad value has been provided.", 
        "Low-level seeking has failed (call to lseek(), usually).",      "Custom I/O obviously not prepared.",      "Overflow in LFS (large file support) conversion."};
#line 1642 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
char const   * __attribute__((__force_align_arg_pointer__)) mpg123_plain_strerror(int errcode ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1644
  if (errcode >= 0) {
#line 1644
    if ((unsigned long )errcode < sizeof(mpg123_error) / sizeof(char *)) {
#line 1645
      return ((char const   */* __attribute__((__force_align_arg_pointer__)) */)mpg123_error[errcode]);
    } else {
#line 1644
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1648
    if (errcode == -1) {
#line 1648
      goto case_neg_1;
    }
#line 1650
    if (errcode == -12) {
#line 1650
      goto case_neg_12;
    }
#line 1652
    if (errcode == -10) {
#line 1652
      goto case_neg_10;
    }
#line 1654
    if (errcode == -11) {
#line 1654
      goto case_neg_11;
    }
#line 1656
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 1649
    return ((char const   */* __attribute__((__force_align_arg_pointer__)) */)"A generic mpg123 error.");
    case_neg_12: /* CIL Label */ 
#line 1651
    return ((char const   */* __attribute__((__force_align_arg_pointer__)) */)"Message: I am done with this track.");
    case_neg_10: /* CIL Label */ 
#line 1653
    return ((char const   */* __attribute__((__force_align_arg_pointer__)) */)"Message: Feed me more input data!");
    case_neg_11: /* CIL Label */ 
#line 1655
    return ((char const   */* __attribute__((__force_align_arg_pointer__)) */)"Message: Prepare for a changed audio format (query the new one)!");
    switch_default: /* CIL Label */ 
#line 1657
    return ((char const   */* __attribute__((__force_align_arg_pointer__)) */)"I have no idea - an unknown error code!");
    switch_break: /* CIL Label */ ;
    }
  }
}
}
#line 1661 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_errcode(mpg123_handle *mh___0 ) 
{ 


  {
#line 1663
  if ((unsigned long )mh___0 != (unsigned long )((void *)0)) {
#line 1663
    return ((int __attribute__((__force_align_arg_pointer__))  )mh___0->err);
  }
#line 1664
  return ((int __attribute__((__force_align_arg_pointer__))  )10);
}
}
#line 1667 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/libmpg123.c"
char const   * __attribute__((__force_align_arg_pointer__)) mpg123_strerror(mpg123_handle *mh___0 ) 
{ 
  int __attribute__((__force_align_arg_pointer__))  tmp ;
  char const   * __attribute__((__force_align_arg_pointer__)) tmp___0 ;

  {
  {
#line 1669
  tmp = mpg123_errcode(mh___0);
#line 1669
  tmp___0 = mpg123_plain_strerror((int )tmp);
  }
#line 1669
  return (tmp___0);
}
}
#line 110 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 231 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
void make_decode_tables(mpg123_handle *fr ) ;
#line 236
void make_decode_tables_mmx(mpg123_handle *fr ) ;
#line 247
int make_conv16to8_table(mpg123_handle *fr ) ;
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
static float cos64[16]  ;
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
static float cos32[8]  ;
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
static float cos16[4]  ;
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
static float cos8[2]  ;
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
static float cos4[1]  ;
#line 45 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
float *pnts[5]  = {      cos64,      cos32,      cos16,      cos8, 
        cos4};
#line 48 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
static long intwinbase[257]  = 
#line 48
  {      0L,      -1L,      -1L,      -1L, 
        -1L,      -1L,      -1L,      -2L, 
        -2L,      -2L,      -2L,      -3L, 
        -3L,      -4L,      -4L,      -5L, 
        -5L,      -6L,      -7L,      -7L, 
        -8L,      -9L,      -10L,      -11L, 
        -13L,      -14L,      -16L,      -17L, 
        -19L,      -21L,      -24L,      -26L, 
        -29L,      -31L,      -35L,      -38L, 
        -41L,      -45L,      -49L,      -53L, 
        -58L,      -63L,      -68L,      -73L, 
        -79L,      -85L,      -91L,      -97L, 
        -104L,      -111L,      -117L,      -125L, 
        -132L,      -139L,      -147L,      -154L, 
        -161L,      -169L,      -176L,      -183L, 
        -190L,      -196L,      -202L,      -208L, 
        -213L,      -218L,      -222L,      -225L, 
        -227L,      -228L,      -228L,      -227L, 
        -224L,      -221L,      -215L,      -208L, 
        -200L,      -189L,      -177L,      -163L, 
        -146L,      -127L,      -106L,      -83L, 
        -57L,      -29L,      2L,      36L, 
        72L,      111L,      153L,      197L, 
        244L,      294L,      347L,      401L, 
        459L,      519L,      581L,      645L, 
        711L,      779L,      848L,      919L, 
        991L,      1064L,      1137L,      1210L, 
        1283L,      1356L,      1428L,      1498L, 
        1567L,      1634L,      1698L,      1759L, 
        1817L,      1870L,      1919L,      1962L, 
        2001L,      2032L,      2057L,      2075L, 
        2085L,      2087L,      2080L,      2063L, 
        2037L,      2000L,      1952L,      1893L, 
        1822L,      1739L,      1644L,      1535L, 
        1414L,      1280L,      1131L,      970L, 
        794L,      605L,      402L,      185L, 
        -45L,      -288L,      -545L,      -814L, 
        -1095L,      -1388L,      -1692L,      -2006L, 
        -2330L,      -2663L,      -3004L,      -3351L, 
        -3705L,      -4063L,      -4425L,      -4788L, 
        -5153L,      -5517L,      -5879L,      -6237L, 
        -6589L,      -6935L,      -7271L,      -7597L, 
        -7910L,      -8209L,      -8491L,      -8755L, 
        -8998L,      -9219L,      -9416L,      -9585L, 
        -9727L,      -9838L,      -9916L,      -9959L, 
        -9966L,      -9935L,      -9863L,      -9750L, 
        -9592L,      -9389L,      -9139L,      -8840L, 
        -8492L,      -8092L,      -7640L,      -7134L, 
        -6574L,      -5959L,      -5288L,      -4561L, 
        -3776L,      -2935L,      -2037L,      -1082L, 
        -70L,      998L,      2122L,      3300L, 
        4533L,      5818L,      7154L,      8540L, 
        9975L,      11455L,      12980L,      14548L, 
        16155L,      17799L,      19478L,      21189L, 
        22929L,      24694L,      26482L,      28289L, 
        30112L,      31947L,      33791L,      35640L, 
        37489L,      39336L,      41176L,      43006L, 
        44821L,      46617L,      48390L,      50137L, 
        51853L,      53534L,      55178L,      56778L, 
        58333L,      59838L,      61289L,      62684L, 
        64019L,      65290L,      66494L,      67629L, 
        68692L,      69679L,      70590L,      71420L, 
        72169L,      72835L,      73415L,      73908L, 
        74313L,      74630L,      74856L,      74992L, 
        75038L};
#line 76 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
void prepare_decode_tables(void) 
{ 
  int i ;
  int k ;
  int kr ;
  int divv ;
  float *costab ;
  double tmp ;

  {
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < 5)) {
#line 82
      goto while_break;
    }
#line 84
    kr = 16 >> i;
#line 84
    divv = 64 >> i;
#line 85
    costab = pnts[i];
#line 86
    k = 0;
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 86
      if (! (k < kr)) {
#line 86
        goto while_break___0;
      }
      {
#line 87
      tmp = cos((3.14159265358979323846 * ((double )k * 2.0 + 1.0)) / (double )divv);
#line 87
      *(costab + k) = (float )(1.0 / (2.0 * tmp));
#line 86
      k ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 94
extern void make_decode_tables_mmx_asm(long scaleval , float *decwin_mmx , float *decwins ) ;
#line 95 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
void make_decode_tables_mmx(mpg123_handle *fr ) 
{ 
  double tmp ;

  {
#line 99
  if (fr->lastscale < (double )0) {
#line 99
    tmp = fr->p.outscale;
  } else {
#line 99
    tmp = fr->lastscale;
  }
  {
#line 99
  make_decode_tables_mmx_asm((long )(tmp * (double )32768), fr->decwin_mmx, fr->decwins);
  }
#line 101
  return;
}
}
#line 166 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
void make_decode_tables(mpg123_handle *fr ) 
{ 
  int i ;
  int j ;
  int idx ;
  double scaleval ;
  double tmp ;
  float tmp___0 ;
  float tmp___1 ;

  {
#line 169
  idx = 0;
#line 171
  if (fr->lastscale < (double )0) {
#line 171
    tmp = fr->p.outscale;
  } else {
#line 171
    tmp = fr->lastscale;
  }
#line 171
  scaleval = - 0.5 * tmp;
#line 176
  i = 0;
#line 176
  j = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < 256)) {
#line 176
      goto while_break;
    }
#line 178
    if (idx < 528) {
#line 182
      tmp___0 = (float )((double )intwinbase[j] * scaleval);
#line 182
      *(fr->decwin + idx) = tmp___0;
#line 182
      *(fr->decwin + (idx + 16)) = tmp___0;
    }
#line 185
    if (i % 32 == 31) {
#line 186
      idx -= 1023;
    }
#line 187
    if (i % 64 == 63) {
#line 191
      scaleval = - scaleval;
    }
#line 176
    i ++;
#line 176
    j ++;
#line 176
    idx += 32;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (i < 512)) {
#line 195
      goto while_break___0;
    }
#line 197
    if (idx < 528) {
#line 201
      tmp___1 = (float )((double )intwinbase[j] * scaleval);
#line 201
      *(fr->decwin + idx) = tmp___1;
#line 201
      *(fr->decwin + (idx + 16)) = tmp___1;
    }
#line 204
    if (i % 32 == 31) {
#line 205
      idx -= 1023;
    }
#line 206
    if (i % 64 == 63) {
#line 210
      scaleval = - scaleval;
    }
#line 195
    i ++;
#line 195
    j --;
#line 195
    idx += 32;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 214
  if ((unsigned int )fr->cpu_opts.type == 12U) {
#line 214
    goto _L;
  } else
#line 214
  if ((unsigned int )fr->cpu_opts.type == 10U) {
#line 214
    goto _L;
  } else
#line 214
  if ((unsigned int )fr->cpu_opts.type == 11U) {
#line 214
    goto _L;
  } else
#line 214
  if ((unsigned int )fr->cpu_opts.type == 13U) {
    _L: /* CIL Label */ 
#line 216
    i = 512;
    {
#line 216
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 216
      if (! (i < 544)) {
#line 216
        goto while_break___1;
      }
#line 218
      if (i & 1) {
#line 218
        *(fr->decwin + i) = *(fr->decwin + i);
      } else {
#line 218
        *(fr->decwin + i) = (float )0;
      }
#line 216
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 220
    i = 0;
    {
#line 220
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 220
      if (! (i < 512)) {
#line 220
        goto while_break___2;
      }
#line 222
      *(fr->decwin + (544 + i)) = - *(fr->decwin + (511 - i));
#line 220
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 227
  return;
}
}
#line 230 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c"
int make_conv16to8_table(mpg123_handle *fr ) 
{ 
  int i ;
  int mode___0 ;
  double mul ;
  void *tmp ;
  double m ;
  double tmp___0 ;
  int c1 ;
  double tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 233
  mode___0 = fr->af.encoding;
#line 238
  mul = 8.0;
#line 240
  if (! fr->conv16to8_buf) {
    {
#line 241
    tmp = malloc((size_t )8192);
#line 241
    fr->conv16to8_buf = (unsigned char *)tmp;
    }
#line 242
    if (! fr->conv16to8_buf) {
#line 243
      fr->err = 4;
#line 244
      if (! (fr->p.flags & 32L)) {
        {
#line 244
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c:%i] error: Can\'t allocate 16 to 8 converter table!\n",
                244);
        }
      }
#line 245
      return (-1);
    }
#line 247
    fr->conv16to8 = fr->conv16to8_buf + 4096;
  }
#line 250
  if (fr->af.encoding == 4) {
    {
#line 251
    tmp___0 = log(256.0);
#line 251
    m = 127.0 / tmp___0;
#line 254
    i = -4096;
    }
    {
#line 254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 254
      if (! (i < 4096)) {
#line 254
        goto while_break;
      }
#line 256
      if (i < 0) {
        {
#line 257
        tmp___1 = log(1.0 - ((255.0 * (double )i) * mul) / 32768.0);
#line 257
        c1 = 127 - (int )(tmp___1 * m);
        }
      } else {
        {
#line 259
        tmp___2 = log(1.0 + ((255.0 * (double )i) * mul) / 32768.0);
#line 259
        c1 = 255 - (int )(tmp___2 * m);
        }
      }
#line 260
      if (c1 < 0) {
#line 260
        goto _L;
      } else
#line 260
      if (c1 > 255) {
        _L: /* CIL Label */ 
#line 260
        if (! (fr->p.flags & 32L)) {
          {
#line 260
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/tabinit.c:%i] error: Converror %d %d\n",
                  260, i, c1);
          }
        }
      }
#line 262
      if (c1 == 0) {
#line 263
        c1 = 2;
      }
#line 264
      *(fr->conv16to8 + i) = (unsigned char )c1;
#line 254
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 267
  if (mode___0 == 130) {
#line 268
    i = -4096;
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 268
      if (! (i < 4096)) {
#line 268
        goto while_break___0;
      }
#line 269
      *(fr->conv16to8 + i) = (unsigned char )(i >> 5);
#line 268
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 272
  if (mode___0 == 1) {
#line 273
    i = -4096;
    {
#line 273
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 273
      if (! (i < 4096)) {
#line 273
        goto while_break___1;
      }
#line 274
      *(fr->conv16to8 + i) = (unsigned char )((i >> 5) + 128);
#line 273
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 278
    i = -4096;
    {
#line 278
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 278
      if (! (i < 4096)) {
#line 278
        goto while_break___2;
      }
#line 279
      *(fr->conv16to8 + i) = (unsigned char)0;
#line 278
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 282
  return (0);
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 139 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/compat.h"
int compat_close(int infd ) ;
#line 90 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/reader.h"
void open_bad(mpg123_handle *mh___0 ) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 29 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int default_init(mpg123_handle *fr ) ;
#line 30
static off_t get_fileinfo(mpg123_handle *fr ) ;
#line 31 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t posix_read(int fd , void *buf , size_t count ) 
{ 
  ssize_t tmp ;

  {
  {
#line 31
  tmp = read(fd, buf, count);
  }
#line 31
  return (tmp);
}
}
#line 32 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static off_t posix_lseek(int fd , off_t offset___0 , int whence ) 
{ 
  __off64_t tmp ;

  {
  {
#line 32
  tmp = lseek(fd, offset___0, whence);
  }
#line 32
  return (tmp);
}
}
#line 34
static ssize_t plain_fullread(mpg123_handle *fr , unsigned char *buf , ssize_t count ) ;
#line 37
static off_t io_seek(struct reader_data *rdat , off_t offset___0 , int whence ) ;
#line 38
static ssize_t io_read(struct reader_data *rdat , void *buf , size_t count ) ;
#line 42
static void bc_init(struct bufferchain *bc ) ;
#line 43
static void bc_reset(struct bufferchain *bc ) ;
#line 44
static int bc_append(struct bufferchain *bc , ssize_t size ) ;
#line 48
static int bc_add(struct bufferchain *bc , unsigned char const   *data , ssize_t size ) ;
#line 49
static ssize_t bc_give(struct bufferchain *bc , unsigned char *out , ssize_t size ) ;
#line 50
static ssize_t bc_skip(struct bufferchain *bc , ssize_t count ) ;
#line 51
static ssize_t bc_seekback(struct bufferchain *bc , ssize_t count ) ;
#line 52
static void bc_forget(struct bufferchain *bc ) ;
#line 59 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t plain_read(mpg123_handle *fr , void *buf , size_t count ) 
{ 
  ssize_t ret ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 61
  tmp = io_read(& fr->rdat, buf, count);
#line 61
  ret = tmp;
  }
#line 62
  if (! (fr->p.flags & 32L)) {
#line 62
    if (fr->p.verbose > 2) {
#line 62
      tmp___0 = 1;
    } else {
#line 62
      tmp___0 = 0;
    }
  } else {
#line 62
    tmp___0 = 0;
  }
#line 63
  return (ret);
}
}
#line 69 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t timeout_read(mpg123_handle *fr , void *buf , size_t count ) 
{ 
  struct timeval tv ;
  ssize_t ret ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  char *__cil_tmp9 ;

  {
#line 72
  ret = 0;
#line 74
  tv.tv_sec = fr->rdat.timeout_sec;
#line 75
  tv.tv_usec = (__suseconds_t )0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  fds.__fds_bits[fr->rdat.filept / (8 * (int )sizeof(__fd_mask ))] |= 1L << fr->rdat.filept % (8 * (int )sizeof(__fd_mask ));
#line 78
  ret = select(fr->rdat.filept + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 80
  if (ret > 0) {
    {
#line 80
    ret = read(fr->rdat.filept, buf, count);
    }
  } else {
#line 83
    ret = -1;
#line 84
    if (! (fr->p.flags & 32L)) {
      {
#line 84
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: stream timed out\n",
              84);
      }
    }
  }
#line 86
  return (ret);
}
}
#line 92 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t icy_fullread(mpg123_handle *fr , unsigned char *buf , ssize_t count ) 
{ 
  ssize_t ret ;
  ssize_t cnt ;
  unsigned char temp_buff ;
  size_t meta_size ;
  ssize_t cut_pos ;
  char *meta_buff ;
  void *tmp ;
  ssize_t left ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 95
  cnt = 0;
#line 96
  if (fr->rdat.flags & 4) {
#line 98
    if (! (fr->p.flags & 32L)) {
      {
#line 98
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: mpg123 programmer error: I don\'t do ICY on seekable streams.\n",
              98);
      }
    }
#line 99
    return (-1);
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (cnt < count)) {
#line 109
      goto while_break;
    }
#line 113
    if (fr->icy.next < (off_t )(count - cnt)) {
#line 120
      if (fr->icy.next > 0LL) {
        {
#line 122
        cut_pos = (ssize_t )fr->icy.next;
#line 123
        ret = (*(fr->rdat.fdread))(fr, (void *)buf, (size_t )cut_pos);
        }
#line 124
        if (ret < 1) {
#line 126
          if (ret == 0) {
#line 126
            goto while_break;
          }
#line 127
          if (! (fr->p.flags & 32L)) {
            {
#line 127
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: icy boundary read\n",
                    127);
            }
          }
#line 129
          return (-1);
        }
#line 131
        fr->rdat.filepos += (off_t )ret;
#line 132
        cnt += ret;
#line 133
        fr->icy.next -= (off_t )ret;
#line 134
        if (fr->icy.next > 0LL) {
#line 137
          goto while_continue;
        }
      }
      {
#line 144
      ret = (*(fr->rdat.fdread))(fr, (void *)(& temp_buff), (size_t )1);
      }
#line 145
      if (ret < 0) {
#line 145
        if (! (fr->p.flags & 32L)) {
          {
#line 145
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: reading icy size\n",
                  145);
          }
        }
#line 145
        return (-1);
      }
#line 146
      if (ret == 0) {
#line 146
        goto while_break;
      }
#line 149
      if (! (fr->rdat.flags & 8)) {
#line 149
        fr->rdat.filepos += (off_t )ret;
      }
#line 151
      meta_size = (size_t )temp_buff * 16U;
#line 151
      if (meta_size) {
        {
#line 155
        tmp = malloc(meta_size + 1U);
#line 155
        meta_buff = (char *)tmp;
        }
#line 156
        if ((unsigned long )meta_buff != (unsigned long )((void *)0)) {
#line 158
          left = (ssize_t )meta_size;
          {
#line 159
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 159
            if (! (left > 0)) {
#line 159
              goto while_break___0;
            }
            {
#line 161
            ret = (*(fr->rdat.fdread))(fr, (void *)((meta_buff + meta_size) - left),
                                       (size_t )left);
            }
#line 163
            if (ret < 1) {
#line 163
              if (! (fr->p.flags & 32L)) {
                {
#line 163
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: reading icy-meta\n",
                        163);
                }
              }
#line 163
              return (-1);
            }
#line 164
            left -= ret;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 166
          *(meta_buff + meta_size) = (char)0;
#line 167
          if (! (fr->rdat.flags & 8)) {
#line 167
            fr->rdat.filepos += (off_t )ret;
          }
#line 169
          if (fr->icy.data) {
            {
#line 169
            free((void *)fr->icy.data);
            }
          }
#line 170
          fr->icy.data = meta_buff;
#line 171
          fr->metaflags |= 4;
        } else {
#line 176
          if (! (fr->p.flags & 32L)) {
            {
#line 176
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: cannot allocate memory for meta_buff (%lu bytes) ... trying to skip the metadata!\n",
                    176, (unsigned long )meta_size);
            }
          }
          {
#line 177
          (*((fr->rd)->skip_bytes))(fr, (off_t )meta_size);
          }
        }
      }
#line 180
      fr->icy.next = fr->icy.interval;
    } else {
      {
#line 184
      ret = plain_fullread(fr, buf + cnt, count - cnt);
      }
#line 185
      if (ret < 0) {
#line 185
        if (! (fr->p.flags & 32L)) {
          {
#line 185
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: reading the rest of %li\n",
                  185, (long )(count - cnt));
          }
        }
#line 185
        return (-1);
      }
#line 186
      if (ret == 0) {
#line 186
        goto while_break;
      }
#line 188
      cnt += ret;
#line 189
      fr->icy.next -= (off_t )ret;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  return (cnt);
}
}
#line 200 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t plain_fullread(mpg123_handle *fr , unsigned char *buf , ssize_t count ) 
{ 
  ssize_t ret ;
  ssize_t cnt ;

  {
#line 202
  cnt = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (cnt < count)) {
#line 211
      goto while_break;
    }
    {
#line 213
    ret = (*(fr->rdat.fdread))(fr, (void *)(buf + cnt), (size_t )(count - cnt));
    }
#line 214
    if (ret < 0) {
#line 214
      return (-1);
    }
#line 215
    if (ret == 0) {
#line 215
      goto while_break;
    }
#line 216
    if (! (fr->rdat.flags & 8)) {
#line 216
      fr->rdat.filepos += (off_t )ret;
    }
#line 217
    cnt += ret;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return (cnt);
}
}
#line 222 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static off_t stream_lseek(mpg123_handle *fr , off_t pos , int whence ) 
{ 
  off_t ret ;

  {
  {
#line 225
  ret = io_seek(& fr->rdat, pos, whence);
  }
#line 226
  if (ret >= 0LL) {
#line 226
    fr->rdat.filepos = ret;
  } else {
#line 229
    fr->err = 40;
#line 230
    ret = (off_t )-1;
  }
#line 232
  return (ret);
}
}
#line 235 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static void stream_close(mpg123_handle *fr ) 
{ 


  {
#line 237
  if (fr->rdat.flags & 1) {
    {
#line 237
    compat_close(fr->rdat.filept);
    }
  }
#line 239
  fr->rdat.filept = 0;
#line 241
  if (fr->rdat.flags & 8) {
    {
#line 241
    bc_reset(& fr->rdat.buffer);
    }
  }
#line 242
  if (fr->rdat.flags & 64) {
#line 244
    if ((unsigned long )fr->rdat.cleanup_handle != (unsigned long )((void *)0)) {
      {
#line 244
      (*(fr->rdat.cleanup_handle))(fr->rdat.iohandle);
      }
    }
#line 246
    fr->rdat.iohandle = (void *)0;
  }
#line 248
  return;
}
}
#line 250 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int stream_seek_frame(mpg123_handle *fr , off_t newframe ) 
{ 
  off_t preframe ;
  off_t seek_to ;
  off_t to_skip ;
  off_t tmp ;
  off_t tmp___0 ;
  int tmp___1 ;

  {
#line 255
  if (fr->rdat.flags & 4) {
#line 255
    goto _L___0;
  } else
#line 255
  if (newframe >= fr->num) {
    _L___0: /* CIL Label */ 
    {
#line 265
    seek_to = frame_index_find(fr, newframe, & preframe);
    }
#line 269
    if (fr->num >= newframe) {
#line 269
      goto _L;
    } else
#line 269
    if (fr->num < preframe) {
      _L: /* CIL Label */ 
      {
#line 271
      tmp = (*((fr->rd)->tell))(fr);
#line 271
      to_skip = seek_to - tmp;
#line 272
      tmp___0 = (*((fr->rd)->skip_bytes))(fr, to_skip);
      }
#line 272
      if (tmp___0 != seek_to) {
#line 273
        return (-1);
      }
#line 276
      fr->num = preframe - 1LL;
    }
    {
#line 278
    while (1) {
      while_continue: /* CIL Label */ ;
#line 278
      if (! (fr->num < newframe)) {
#line 278
        goto while_break;
      }
      {
#line 281
      tmp___1 = read_frame(fr);
      }
#line 281
      if (! tmp___1) {
#line 281
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 286
    return (0);
  } else {
#line 290
    fr->err = 23;
#line 291
    return (-1);
  }
}
}
#line 296 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int generic_head_read(mpg123_handle *fr , unsigned long *newhead ) 
{ 
  unsigned char hbuf[4] ;
  int ret ;
  ssize_t tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 299
  tmp = (*((fr->rd)->fullread))(fr, hbuf, 4);
#line 299
  ret = tmp;
  }
#line 300
  if (ret == -10) {
#line 300
    return (ret);
  }
#line 301
  if (ret != 4) {
#line 301
    return (0);
  }
#line 303
  *newhead = ((((unsigned long )hbuf[0] << 24) | ((unsigned long )hbuf[1] << 16)) | ((unsigned long )hbuf[2] << 8)) | (unsigned long )hbuf[3];
#line 308
  return (1);
}
}
#line 312 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int generic_head_shift(mpg123_handle *fr , unsigned long *head ) 
{ 
  unsigned char hbuf ;
  int ret ;
  ssize_t tmp ;

  {
  {
#line 315
  tmp = (*((fr->rd)->fullread))(fr, & hbuf, 1);
#line 315
  ret = tmp;
  }
#line 316
  if (ret == -10) {
#line 316
    return (ret);
  }
#line 317
  if (ret != 1) {
#line 317
    return (0);
  }
#line 319
  *head <<= 8;
#line 320
  *head |= (unsigned long )hbuf;
#line 321
  *head &= 4294967295UL;
#line 322
  return (1);
}
}
#line 326 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static off_t stream_skip_bytes(mpg123_handle *fr , off_t len ) 
{ 
  off_t ret ;
  off_t tmp ;
  off_t tmp___0 ;
  unsigned char buf[1024] ;
  ssize_t ret___0 ;
  ssize_t num ;
  ssize_t tmp___1 ;
  off_t tmp___2 ;
  off_t tmp___3 ;
  void *__cil_tmp12 ;

  {
#line 328
  if (fr->rdat.flags & 4) {
    {
#line 330
    tmp = stream_lseek(fr, len, 1);
#line 330
    ret = tmp;
    }
#line 331
    if (ret < 0LL) {
#line 331
      tmp___0 = (off_t )-1;
    } else {
#line 331
      tmp___0 = ret;
    }
#line 331
    return (tmp___0);
  } else
#line 333
  if (len >= 0LL) {
    {
#line 337
    while (1) {
      while_continue: /* CIL Label */ ;
#line 337
      if (! (len > 0LL)) {
#line 337
        goto while_break;
      }
#line 339
      if (len < (off_t )sizeof(buf)) {
#line 339
        tmp___1 = (ssize_t )len;
      } else {
#line 339
        tmp___1 = (ssize_t )sizeof(buf);
      }
      {
#line 339
      num = tmp___1;
#line 340
      ret___0 = (*((fr->rd)->fullread))(fr, buf, num);
      }
#line 341
      if (ret___0 < 0) {
#line 341
        return ((off_t )ret___0);
      } else
#line 342
      if (ret___0 == 0) {
#line 342
        goto while_break;
      }
#line 343
      len -= (off_t )ret___0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 345
    tmp___2 = (*((fr->rd)->tell))(fr);
    }
#line 345
    return (tmp___2);
  } else
#line 347
  if (fr->rdat.flags & 8) {
#line 349
    if ((off_t )fr->rdat.buffer.pos >= - len) {
      {
#line 351
      fr->rdat.buffer.pos = (ssize_t )((off_t )fr->rdat.buffer.pos + len);
#line 352
      tmp___3 = (*((fr->rd)->tell))(fr);
      }
#line 352
      return (tmp___3);
    } else {
#line 356
      fr->err = 23;
#line 357
      return ((off_t )-1);
    }
  } else {
#line 362
    fr->err = 23;
#line 363
    return ((off_t )-1);
  }
}
}
#line 368 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int stream_back_bytes(mpg123_handle *fr , off_t bytes ) 
{ 
  off_t want ;
  off_t tmp ;
  off_t tmp___0 ;

  {
  {
#line 370
  tmp = (*((fr->rd)->tell))(fr);
#line 370
  want = tmp - bytes;
  }
#line 371
  if (want < 0LL) {
#line 371
    return (-1);
  }
  {
#line 372
  tmp___0 = stream_skip_bytes(fr, - bytes);
  }
#line 372
  if (tmp___0 != want) {
#line 372
    return (-1);
  }
#line 374
  return (0);
}
}
#line 379 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int generic_read_frame_body(mpg123_handle *fr , unsigned char *buf , int size ) 
{ 
  long l___0 ;
  long ll ;
  ssize_t tmp ;

  {
  {
#line 383
  tmp = (*((fr->rd)->fullread))(fr, buf, size);
#line 383
  l___0 = (long )tmp;
  }
#line 383
  if (l___0 != (long )size) {
#line 385
    ll = l___0;
#line 386
    if (ll <= 0L) {
#line 386
      ll = 0L;
    }
#line 387
    return (-10);
  }
#line 389
  return ((int )l___0);
}
}
#line 392 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static off_t generic_tell(mpg123_handle *fr ) 
{ 


  {
#line 394
  if (fr->rdat.flags & 8) {
#line 395
    fr->rdat.filepos = fr->rdat.buffer.fileoff + (off_t )fr->rdat.buffer.pos;
  }
#line 397
  return (fr->rdat.filepos);
}
}
#line 401 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static void stream_rewind(mpg123_handle *fr ) 
{ 
  off_t tmp ;

  {
#line 403
  if (fr->rdat.flags & 4) {
    {
#line 404
    tmp = stream_lseek(fr, (off_t )0, 0);
#line 404
    fr->rdat.filepos = tmp;
#line 404
    fr->rdat.buffer.fileoff = tmp;
    }
  }
#line 405
  if (fr->rdat.flags & 8) {
#line 407
    fr->rdat.buffer.pos = 0;
#line 408
    fr->rdat.buffer.firstpos = 0;
#line 409
    fr->rdat.filepos = fr->rdat.buffer.fileoff;
  }
#line 411
  return;
}
}
#line 418 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static off_t get_fileinfo(mpg123_handle *fr ) 
{ 
  off_t len ;
  off_t tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  off_t tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 422
  len = io_seek(& fr->rdat, (off_t )0, 2);
  }
#line 422
  if (len < 0LL) {
#line 422
    return ((off_t )-1);
  }
  {
#line 424
  tmp = io_seek(& fr->rdat, (off_t )-128, 2);
  }
#line 424
  if (tmp < 0LL) {
#line 424
    return ((off_t )-1);
  }
  {
#line 426
  tmp___0 = (*((fr->rd)->fullread))(fr, fr->id3buf, 128);
  }
#line 426
  if (tmp___0 != 128) {
#line 426
    return ((off_t )-1);
  }
  {
#line 428
  tmp___1 = strncmp((char const   *)((char *)(fr->id3buf)), "TAG", (size_t )3);
  }
#line 428
  if (! tmp___1) {
#line 428
    len -= 128LL;
  }
  {
#line 430
  tmp___2 = io_seek(& fr->rdat, (off_t )0, 0);
  }
#line 430
  if (tmp___2 < 0LL) {
#line 430
    return ((off_t )-1);
  }
#line 432
  if (len <= 0LL) {
#line 432
    return ((off_t )-1);
  }
#line 434
  return (len);
}
}
#line 440 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static void bc_init(struct bufferchain *bc ) 
{ 


  {
#line 442
  bc->first = (struct buffy *)((void *)0);
#line 443
  bc->last = bc->first;
#line 444
  bc->size = 0;
#line 445
  bc->pos = 0;
#line 446
  bc->firstpos = 0;
#line 447
  bc->fileoff = (off_t )0;
#line 448
  return;
}
}
#line 450 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static void bc_reset(struct bufferchain *bc ) 
{ 
  struct buffy *b ;
  struct buffy *n ;

  {
#line 453
  b = bc->first;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! ((unsigned long )b != (unsigned long )((void *)0))) {
#line 454
      goto while_break;
    }
    {
#line 456
    n = b->next;
#line 457
    free((void *)b->data);
#line 458
    free((void *)b);
#line 459
    b = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  bc_init(bc);
  }
#line 462
  return;
}
}
#line 465 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int bc_append(struct bufferchain *bc , ssize_t size ) 
{ 
  struct buffy *newbuf ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 468
  if (size < 1) {
#line 468
    return (-1);
  }
  {
#line 470
  tmp = malloc((size_t )sizeof(struct buffy ));
#line 470
  newbuf = (struct buffy *)tmp;
  }
#line 471
  if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
#line 471
    return (-2);
  }
  {
#line 473
  tmp___0 = malloc((size_t )size);
#line 473
  newbuf->data = (unsigned char *)tmp___0;
  }
#line 474
  if ((unsigned long )newbuf->data == (unsigned long )((void *)0)) {
    {
#line 476
    free((void *)newbuf);
    }
#line 477
    return (-3);
  }
#line 479
  newbuf->size = size;
#line 480
  newbuf->next = (struct buffy *)((void *)0);
#line 481
  if ((unsigned long )bc->last != (unsigned long )((void *)0)) {
#line 481
    (bc->last)->next = newbuf;
  } else
#line 482
  if ((unsigned long )bc->first == (unsigned long )((void *)0)) {
#line 482
    bc->first = newbuf;
  }
#line 484
  bc->last = newbuf;
#line 485
  bc->size += size;
#line 486
  return (0);
}
}
#line 517 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int bc_add(struct bufferchain *bc , unsigned char const   *data , ssize_t size ) 
{ 
  int ret ;

  {
  {
#line 519
  ret = 0;
#line 523
  ret = bc_append(bc, size);
  }
#line 523
  if (ret == 0) {
    {
#line 524
    memcpy((void */* __restrict  */)(bc->last)->data, (void const   */* __restrict  */)data,
           (size_t )size);
    }
  }
#line 526
  return (ret);
}
}
#line 530 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t bc_need_more(struct bufferchain *bc ) 
{ 


  {
#line 534
  bc->pos = bc->firstpos;
#line 535
  return (-10);
}
}
#line 539 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t bc_give(struct bufferchain *bc , unsigned char *out , ssize_t size ) 
{ 
  struct buffy *b ;
  ssize_t gotcount ;
  ssize_t offset___0 ;
  ssize_t tmp ;
  ssize_t loff ;
  ssize_t chunk ;

  {
#line 541
  b = bc->first;
#line 542
  gotcount = 0;
#line 543
  offset___0 = 0;
#line 544
  if (bc->size - bc->pos < size) {
    {
#line 544
    tmp = bc_need_more(bc);
    }
#line 544
    return (tmp);
  }
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 547
      if (! (offset___0 + b->size <= bc->pos)) {
#line 547
        goto while_break;
      }
    } else {
#line 547
      goto while_break;
    }
#line 549
    offset___0 += b->size;
#line 550
    b = b->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 553
    if (gotcount < size) {
#line 553
      if (! ((unsigned long )b != (unsigned long )((void *)0))) {
#line 553
        goto while_break___0;
      }
    } else {
#line 553
      goto while_break___0;
    }
#line 555
    loff = bc->pos - offset___0;
#line 556
    chunk = size - gotcount;
#line 557
    if (chunk > b->size - loff) {
#line 557
      chunk = b->size - loff;
    }
    {
#line 563
    memcpy((void */* __restrict  */)(out + gotcount), (void const   */* __restrict  */)(b->data + loff),
           (size_t )chunk);
#line 564
    gotcount += chunk;
#line 565
    bc->pos += chunk;
#line 566
    offset___0 += b->size;
#line 567
    b = b->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 573
  return (gotcount);
}
}
#line 578 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t bc_skip(struct bufferchain *bc , ssize_t count ) 
{ 
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 580
  if (count >= 0) {
#line 582
    if (bc->size - bc->pos < count) {
      {
#line 582
      tmp = bc_need_more(bc);
      }
#line 582
      return (tmp);
    } else {
#line 583
      tmp___0 = bc->pos + count;
#line 583
      bc->pos = tmp___0;
#line 583
      return (tmp___0);
    }
  } else {
#line 585
    return (-1);
  }
}
}
#line 588 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t bc_seekback(struct bufferchain *bc , ssize_t count ) 
{ 
  ssize_t tmp ;

  {
#line 590
  if (count >= 0) {
#line 590
    if (count <= bc->pos) {
#line 590
      tmp = bc->pos - count;
#line 590
      bc->pos = tmp;
#line 590
      return (tmp);
    } else {
#line 591
      return (-1);
    }
  } else {
#line 591
    return (-1);
  }
}
}
#line 595 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static void bc_forget(struct bufferchain *bc ) 
{ 
  struct buffy *b ;
  struct buffy *n ;

  {
#line 597
  b = bc->first;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 603
      if (! (bc->pos >= b->size)) {
#line 603
        goto while_break;
      }
    } else {
#line 603
      goto while_break;
    }
#line 605
    n = b->next;
#line 606
    if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 606
      bc->last = (struct buffy *)((void *)0);
    }
    {
#line 607
    bc->fileoff += (off_t )b->size;
#line 608
    bc->pos -= b->size;
#line 609
    bc->size -= b->size;
#line 613
    free((void *)b->data);
#line 614
    free((void *)b);
#line 615
    b = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 617
  bc->first = b;
#line 618
  bc->firstpos = bc->pos;
#line 619
  return;
}
}
#line 623 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int feed_init(mpg123_handle *fr ) 
{ 


  {
  {
#line 625
  bc_init(& fr->rdat.buffer);
#line 626
  fr->rdat.filelen = (off_t )0;
#line 627
  fr->rdat.filepos = (off_t )0;
#line 628
  fr->rdat.flags |= 8;
  }
#line 629
  return (0);
}
}
#line 633 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int feed_more(mpg123_handle *fr , unsigned char const   *in , long count ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 635
  ret = 0;
#line 636
  if (! (fr->p.flags & 32L)) {
#line 636
    if (fr->p.verbose > 2) {
#line 636
      tmp = 1;
    } else {
#line 636
      tmp = 0;
    }
  } else {
#line 636
    tmp = 0;
  }
  {
#line 637
  ret = bc_add(& fr->rdat.buffer, in, (ssize_t )count);
  }
#line 637
  if (ret != 0) {
#line 639
    ret = -1;
#line 640
    if (! (fr->p.flags & 32L)) {
      {
#line 640
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: Failed to add buffer, return: %i\n",
              640, ret);
      }
    }
  } else
#line 644
  if (! (fr->p.flags & 32L)) {
#line 644
    if (fr->p.verbose > 2) {
#line 644
      tmp___0 = 1;
    } else {
#line 644
      tmp___0 = 0;
    }
  } else {
#line 644
    tmp___0 = 0;
  }
#line 646
  return (ret);
}
}
#line 649 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t feed_read(mpg123_handle *fr , unsigned char *out , ssize_t count ) 
{ 
  ssize_t gotcount ;
  ssize_t tmp ;

  {
  {
#line 651
  tmp = bc_give(& fr->rdat.buffer, out, count);
#line 651
  gotcount = tmp;
  }
#line 652
  if (gotcount >= 0) {
#line 652
    if (gotcount != count) {
#line 652
      return (-1);
    } else {
#line 653
      return (gotcount);
    }
  } else {
#line 653
    return (gotcount);
  }
}
}
#line 657 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static off_t feed_skip_bytes(mpg123_handle *fr , off_t len ) 
{ 
  off_t res ;
  ssize_t tmp ;

  {
  {
#line 660
  tmp = bc_skip(& fr->rdat.buffer, (ssize_t )len);
#line 660
  res = (off_t )tmp;
  }
#line 661
  if (res < 0LL) {
#line 661
    return (res);
  }
#line 663
  return (fr->rdat.buffer.fileoff + res);
}
}
#line 666 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int feed_back_bytes(mpg123_handle *fr , off_t bytes ) 
{ 
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___3 ;
  off_t tmp___4 ;

  {
#line 668
  if (bytes >= 0LL) {
    {
#line 669
    tmp___1 = bc_seekback(& fr->rdat.buffer, (ssize_t )bytes);
    }
#line 669
    if (tmp___1 >= 0) {
#line 669
      tmp___0 = 0;
    } else {
#line 669
      tmp___0 = -1;
    }
#line 669
    return (tmp___0);
  } else {
    {
#line 671
    tmp___4 = feed_skip_bytes(fr, - bytes);
    }
#line 671
    if (tmp___4 >= 0LL) {
#line 671
      tmp___3 = 0;
    } else {
#line 671
      tmp___3 = -1;
    }
#line 671
    return (tmp___3);
  }
}
}
#line 674 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int feed_seek_frame(mpg123_handle *fr , off_t num ) 
{ 


  {
#line 674
  return (-1);
}
}
#line 677 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static void buffered_forget(mpg123_handle *fr ) 
{ 


  {
  {
#line 679
  bc_forget(& fr->rdat.buffer);
#line 680
  fr->rdat.filepos = fr->rdat.buffer.fileoff + (off_t )fr->rdat.buffer.pos;
  }
#line 681
  return;
}
}
#line 683 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
off_t feed_set_pos(mpg123_handle *fr , off_t pos ) 
{ 
  struct bufferchain *bc ;

  {
#line 685
  bc = & fr->rdat.buffer;
#line 686
  if (pos >= bc->fileoff) {
#line 686
    if (pos - bc->fileoff < (off_t )bc->size) {
#line 688
      bc->pos = (ssize_t )(pos - bc->fileoff);
#line 690
      return (bc->fileoff + (off_t )bc->size);
    } else {
      {
#line 694
      bc_reset(bc);
#line 695
      bc->fileoff = pos;
      }
#line 697
      return (pos);
    }
  } else {
    {
#line 694
    bc_reset(bc);
#line 695
    bc->fileoff = pos;
    }
#line 697
    return (pos);
  }
}
}
#line 705 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t buffered_fullread(mpg123_handle *fr , unsigned char *out , ssize_t count ) 
{ 
  struct bufferchain *bc ;
  ssize_t gotcount ;
  unsigned char readbuf[4096] ;
  ssize_t need ;
  int ret ;
  ssize_t got ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 707
  bc = & fr->rdat.buffer;
#line 709
  if (bc->size - bc->pos < count) {
#line 712
    need = count - (bc->size - bc->pos);
    {
#line 713
    while (1) {
      while_continue: /* CIL Label */ ;
#line 713
      if (! (need > 0)) {
#line 713
        goto while_break;
      }
      {
#line 716
      tmp = (*(fr->rdat.fullread))(fr, readbuf, 4096);
#line 716
      got = tmp;
      }
#line 717
      if (got < 0) {
#line 719
        if (! (fr->p.flags & 32L)) {
          {
#line 719
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: buffer reading\n",
                  719);
          }
        }
#line 720
        return (-1);
      }
#line 723
      if (! (fr->p.flags & 32L)) {
#line 723
        if (fr->p.verbose > 2) {
#line 723
          tmp___0 = 1;
        } else {
#line 723
          tmp___0 = 0;
        }
      } else {
#line 723
        tmp___0 = 0;
      }
#line 724
      if (got > 0) {
        {
#line 724
        ret = bc_add(bc, (unsigned char const   *)(readbuf), got);
        }
#line 724
        if (ret != 0) {
#line 726
          if (! (fr->p.flags & 32L)) {
            {
#line 726
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: unable to add to chain, return: %i\n",
                    726, ret);
            }
          }
#line 727
          return (-1);
        }
      }
#line 730
      need -= got;
#line 731
      if (got < 4096) {
#line 733
        if (! (fr->p.flags & 32L)) {
#line 733
          if (fr->p.verbose > 2) {
            {
#line 733
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Input data end.\n");
            }
          }
        }
#line 734
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 737
    if (bc->size - bc->pos < count) {
#line 738
      count = bc->size - bc->pos;
    }
  }
  {
#line 740
  gotcount = bc_give(bc, out, count);
  }
#line 742
  if (! (fr->p.flags & 32L)) {
#line 742
    if (fr->p.verbose > 2) {
#line 742
      tmp___1 = 1;
    } else {
#line 742
      tmp___1 = 0;
    }
  } else {
#line 742
    tmp___1 = 0;
  }
#line 744
  if (gotcount != count) {
#line 744
    if (! (fr->p.flags & 32L)) {
      {
#line 744
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: gotcount != count\n",
              744);
      }
    }
#line 744
    return (-1);
  } else {
#line 745
    return (gotcount);
  }
}
}
#line 765 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int bad_init(mpg123_handle *mh___0 ) 
{ 


  {
#line 765
  mh___0->err = 24;
#line 765
  return (-1);
}
}
#line 766 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
void bad_close(mpg123_handle *mh___0 ) 
{ 


  {
#line 766
  return;
}
}
#line 767 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
ssize_t bad_fullread(mpg123_handle *mh___0 , unsigned char *data , ssize_t count ) 
{ 


  {
#line 767
  mh___0->err = 24;
#line 767
  return (-1);
}
}
#line 768 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int bad_head_read(mpg123_handle *mh___0 , unsigned long *newhead ) 
{ 


  {
#line 768
  mh___0->err = 24;
#line 768
  return (-1);
}
}
#line 769 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int bad_head_shift(mpg123_handle *mh___0 , unsigned long *head ) 
{ 


  {
#line 769
  mh___0->err = 24;
#line 769
  return (-1);
}
}
#line 770 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
off_t bad_skip_bytes(mpg123_handle *mh___0 , off_t len ) 
{ 


  {
#line 770
  mh___0->err = 24;
#line 770
  return ((off_t )-1);
}
}
#line 771 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int bad_read_frame_body(mpg123_handle *mh___0 , unsigned char *data , int size ) 
{ 


  {
#line 771
  mh___0->err = 24;
#line 771
  return (-1);
}
}
#line 772 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int bad_back_bytes(mpg123_handle *mh___0 , off_t bytes ) 
{ 


  {
#line 772
  mh___0->err = 24;
#line 772
  return (-1);
}
}
#line 773 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int bad_seek_frame(mpg123_handle *mh___0 , off_t num ) 
{ 


  {
#line 773
  mh___0->err = 24;
#line 773
  return (-1);
}
}
#line 774 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
off_t bad_tell(mpg123_handle *mh___0 ) 
{ 


  {
#line 774
  mh___0->err = 24;
#line 774
  return ((off_t )-1);
}
}
#line 775 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
void bad_rewind(mpg123_handle *mh___0 ) 
{ 


  {
#line 775
  return;
}
}
#line 783 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
struct reader readers[5]  = {      {& default_init, & stream_close, & plain_fullread, & generic_head_read, & generic_head_shift,
      & stream_skip_bytes, & generic_read_frame_body, & stream_back_bytes, & stream_seek_frame,
      & generic_tell, & stream_rewind, (void (*)(mpg123_handle * ))((void *)0)}, 
        {& default_init, & stream_close, & icy_fullread, & generic_head_read, & generic_head_shift,
      & stream_skip_bytes, & generic_read_frame_body, & stream_back_bytes, & stream_seek_frame,
      & generic_tell, & stream_rewind, (void (*)(mpg123_handle * ))((void *)0)}, 
        {& feed_init, & stream_close, & feed_read, & generic_head_read, & generic_head_shift,
      & feed_skip_bytes, & generic_read_frame_body, & feed_back_bytes, & feed_seek_frame,
      & generic_tell, & stream_rewind, & buffered_forget}, 
        {& default_init, & stream_close, & buffered_fullread, & generic_head_read, & generic_head_shift,
      & stream_skip_bytes, & generic_read_frame_body, & stream_back_bytes, & stream_seek_frame,
      & generic_tell, & stream_rewind, & buffered_forget}, 
        {& default_init, & stream_close, & buffered_fullread, & generic_head_read, & generic_head_shift,
      & stream_skip_bytes, & generic_read_frame_body, & stream_back_bytes, & stream_seek_frame,
      & generic_tell, & stream_rewind, & buffered_forget}};
#line 882 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
struct reader bad_reader  = 
#line 882
     {& bad_init, & bad_close, & bad_fullread, & bad_head_read, & bad_head_shift, & bad_skip_bytes,
    & bad_read_frame_body, & bad_back_bytes, & bad_seek_frame, & bad_tell, & bad_rewind,
    (void (*)(mpg123_handle * ))((void *)0)};
#line 898 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int default_init(mpg123_handle *fr ) 
{ 
  int flags ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 901
  if (fr->p.timeout > 0L) {
#line 904
    if ((unsigned long )fr->rdat.r_read != (unsigned long )((void *)0)) {
      {
#line 906
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: Timeout reading does not work with user-provided read function. Implement it yourself!\n",
              906);
      }
#line 907
      return (-1);
    }
    {
#line 909
    flags = fcntl(fr->rdat.filept, 3);
#line 910
    flags |= 2048;
#line 911
    fcntl(fr->rdat.filept, 4, flags);
#line 912
    fr->rdat.fdread = & timeout_read;
#line 913
    fr->rdat.timeout_sec = fr->p.timeout;
#line 914
    fr->rdat.flags |= 32;
    }
  } else {
#line 918
    fr->rdat.fdread = & plain_read;
  }
#line 920
  if ((unsigned long )fr->rdat.r_read != (unsigned long )((void *)0)) {
#line 920
    fr->rdat.read = fr->rdat.r_read;
  } else {
#line 920
    fr->rdat.read = & posix_read;
  }
#line 921
  if ((unsigned long )fr->rdat.r_lseek != (unsigned long )((void *)0)) {
#line 921
    fr->rdat.lseek = fr->rdat.r_lseek;
  } else {
#line 921
    fr->rdat.lseek = & posix_lseek;
  }
  {
#line 922
  fr->rdat.filelen = get_fileinfo(fr);
#line 923
  fr->rdat.filepos = (off_t )0;
  }
#line 924
  if (fr->rdat.filelen >= 0LL) {
    {
#line 926
    fr->rdat.flags |= 4;
#line 927
    tmp = strncmp((char const   *)((char *)(fr->id3buf)), "TAG", (size_t )3);
    }
#line 927
    if (! tmp) {
#line 929
      fr->rdat.flags |= 2;
#line 930
      fr->metaflags |= 1;
    }
  } else
#line 934
  if (fr->p.flags & 256L) {
#line 941
    if ((unsigned long )fr->rd == (unsigned long )(& readers[0])) {
#line 943
      fr->rd = & readers[3];
#line 944
      fr->rdat.fullread = & plain_fullread;
    } else
#line 947
    if ((unsigned long )fr->rd == (unsigned long )(& readers[1])) {
#line 949
      fr->rd = & readers[4];
#line 950
      fr->rdat.fullread = & icy_fullread;
    } else {
#line 955
      if (! (fr->p.flags & 32L)) {
        {
#line 955
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: mpg123 Programmer\'s fault: invalid reader\n",
                955);
        }
      }
#line 956
      return (-1);
    }
    {
#line 958
    bc_init(& fr->rdat.buffer);
#line 959
    fr->rdat.filelen = (off_t )0;
#line 960
    fr->rdat.flags |= 8;
    }
  }
#line 963
  return (0);
}
}
#line 967 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
void open_bad(mpg123_handle *mh___0 ) 
{ 


  {
  {
#line 970
  clear_icy(& mh___0->icy);
#line 972
  mh___0->rd = & bad_reader;
#line 973
  mh___0->rdat.flags = 0;
#line 974
  bc_init(& mh___0->rdat.buffer);
  }
#line 975
  return;
}
}
#line 977 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int open_feed(mpg123_handle *fr ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
#line 986
  if (fr->p.icy_interval > 0L) {
#line 988
    if (! (fr->p.flags & 32L)) {
      {
#line 988
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: Feed reader cannot do ICY parsing!\n",
              988);
      }
    }
#line 990
    return (-1);
  }
  {
#line 992
  clear_icy(& fr->icy);
#line 994
  fr->rd = & readers[2];
#line 995
  fr->rdat.flags = 0;
#line 996
  tmp = (*((fr->rd)->init))(fr);
  }
#line 996
  if (tmp < 0) {
#line 996
    return (-1);
  }
#line 997
  return (0);
}
}
#line 1002 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static int open_finish(mpg123_handle *fr ) 
{ 
  int tmp ;

  {
#line 1005
  if (fr->p.icy_interval > 0L) {
#line 1008
    fr->icy.interval = (off_t )fr->p.icy_interval;
#line 1009
    fr->icy.next = fr->icy.interval;
#line 1010
    fr->rd = & readers[1];
  } else {
#line 1015
    fr->rd = & readers[0];
  }
  {
#line 1019
  tmp = (*((fr->rd)->init))(fr);
  }
#line 1019
  if (tmp < 0) {
#line 1019
    return (-1);
  }
#line 1021
  return (0);
}
}
#line 1024 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int open_stream(mpg123_handle *fr , char const   *bs_filenam , int fd ) 
{ 
  int filept_opened ;
  int filept___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 1026
  filept_opened = 1;
#line 1029
  clear_icy(& fr->icy);
  }
#line 1031
  if (! bs_filenam) {
#line 1033
    filept___0 = fd;
#line 1034
    filept_opened = 0;
  } else {
    {
#line 1039
    filept___0 = compat_open(bs_filenam, 0);
    }
#line 1039
    if (filept___0 < 0) {
#line 1041
      if (! (fr->p.flags & 32L)) {
        {
#line 1041
        tmp = __errno_location();
#line 1041
        tmp___0 = strerror(*tmp);
#line 1041
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c:%i] error: Cannot open file %s: %s\n",
                1041, bs_filenam, tmp___0);
        }
      }
#line 1042
      fr->err = 22;
#line 1043
      return (-1);
    }
  }
#line 1047
  fr->rdat.filelen = (off_t )-1;
#line 1048
  fr->rdat.filept = filept___0;
#line 1049
  fr->rdat.flags = 0;
#line 1050
  if (filept_opened) {
#line 1050
    fr->rdat.flags |= 1;
  }
  {
#line 1052
  tmp___1 = open_finish(fr);
  }
#line 1052
  return (tmp___1);
}
}
#line 1055 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
int open_stream_handle(mpg123_handle *fr , void *iohandle ) 
{ 
  int tmp ;

  {
  {
#line 1057
  clear_icy(& fr->icy);
#line 1058
  fr->rdat.filelen = (off_t )-1;
#line 1059
  fr->rdat.filept = -1;
#line 1060
  fr->rdat.iohandle = iohandle;
#line 1061
  fr->rdat.flags = 0;
#line 1062
  fr->rdat.flags |= 64;
#line 1064
  tmp = open_finish(fr);
  }
#line 1064
  return (tmp);
}
}
#line 1068 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static off_t io_seek(struct reader_data *rdat , off_t offset___0 , int whence ) 
{ 
  off_t tmp ;
  off_t tmp___0 ;

  {
#line 1070
  if (rdat->flags & 64) {
#line 1072
    if ((unsigned long )rdat->r_lseek_handle != (unsigned long )((void *)0)) {
      {
#line 1074
      tmp = (*(rdat->r_lseek_handle))(rdat->iohandle, offset___0, whence);
      }
#line 1074
      return (tmp);
    } else {
#line 1076
      return ((off_t )-1);
    }
  } else {
    {
#line 1079
    tmp___0 = (*(rdat->lseek))(rdat->filept, offset___0, whence);
    }
#line 1079
    return (tmp___0);
  }
}
}
#line 1082 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/readers.c"
static ssize_t io_read(struct reader_data *rdat , void *buf , size_t count ) 
{ 
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 1084
  if (rdat->flags & 64) {
#line 1086
    if ((unsigned long )rdat->r_read_handle != (unsigned long )((void *)0)) {
      {
#line 1088
      tmp = (*(rdat->r_read_handle))(rdat->iohandle, buf, count);
      }
#line 1088
      return (tmp);
    } else {
#line 1090
      return (-1);
    }
  } else {
    {
#line 1093
    tmp___0 = (*(rdat->read))(rdat->filept, buf, count);
    }
#line 1093
    return (tmp___0);
  }
}
}
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 305 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
char const __attribute__((__force_align_arg_pointer__))  **mpg123_decoders(void) ;
#line 308
char const __attribute__((__force_align_arg_pointer__))  **mpg123_supported_decoders(void) ;
#line 318
char const   * __attribute__((__force_align_arg_pointer__)) mpg123_current_decoder(mpg123_handle *mh___0 ) ;
#line 52 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.h"
enum optdec defdec(void) ;
#line 54
enum optcla decclass(enum optdec  const  type ) ;
#line 194 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/decode.h"
extern void dct36_3dnow(float * , float * , float * , float * , float * ) ;
#line 195
extern void dct36_3dnowext(float * , float * , float * , float * , float * ) ;
#line 26 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
int frame_dither_init(mpg123_handle *fr ) ;
#line 326
int frame_buffers(mpg123_handle *fr ) ;
#line 44 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
static char const   *decname[15]  = 
#line 44 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
  {      "auto",      "generic",      "generic_dither",      "i386", 
        "i486",      "i586",      "i586_dither",      "MMX", 
        "3DNow",      "3DNowExt",      "AltiVec",      "SSE", 
        "x86-64",      "ARM",      "nodec"};
#line 34 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/getcpuflags.h"
struct cpuflags cpu_flags  ;
#line 36
extern unsigned int getcpuflags(struct cpuflags *cf ) ;
#line 94 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
struct synth_s  const  synth_base  =    {{{& synth_1to1, & synth_1to1_8bit, & synth_1to1_real, & synth_1to1_s32}, {& synth_2to1,
                                                                              & synth_2to1_8bit,
                                                                              & synth_2to1_real,
                                                                              & synth_2to1_s32},
     {& synth_4to1, & synth_4to1_8bit, & synth_4to1_real, & synth_4to1_s32}, {& synth_ntom,
                                                                              & synth_ntom_8bit,
                                                                              & synth_ntom_real,
                                                                              & synth_ntom_s32}},
    {{& synth_stereo_wrap, & synth_stereo_wrap, & synth_stereo_wrap, & synth_stereo_wrap},
     {& synth_stereo_wrap, & synth_stereo_wrap, & synth_stereo_wrap, & synth_stereo_wrap},
     {& synth_stereo_wrap, & synth_stereo_wrap, & synth_stereo_wrap, & synth_stereo_wrap},
     {& synth_stereo_wrap, & synth_stereo_wrap, & synth_stereo_wrap, & synth_stereo_wrap}},
    {{& synth_1to1_mono2stereo, & synth_1to1_8bit_mono2stereo, & synth_1to1_real_mono2stereo,
      & synth_1to1_s32_mono2stereo}, {& synth_2to1_mono2stereo, & synth_2to1_8bit_mono2stereo,
                                      & synth_2to1_real_mono2stereo, & synth_2to1_s32_mono2stereo},
     {& synth_4to1_mono2stereo, & synth_4to1_8bit_mono2stereo, & synth_4to1_real_mono2stereo,
      & synth_4to1_s32_mono2stereo}, {& synth_ntom_mono2stereo, & synth_ntom_8bit_mono2stereo,
                                      & synth_ntom_real_mono2stereo, & synth_ntom_s32_mono2stereo}},
    {{& synth_1to1_mono, & synth_1to1_8bit_mono, & synth_1to1_real_mono, & synth_1to1_s32_mono},
     {& synth_2to1_mono, & synth_2to1_8bit_mono, & synth_2to1_real_mono, & synth_2to1_s32_mono},
     {& synth_4to1_mono, & synth_4to1_8bit_mono, & synth_4to1_real_mono, & synth_4to1_s32_mono},
     {& synth_ntom_mono, & synth_ntom_8bit_mono, & synth_ntom_real_mono, & synth_ntom_s32_mono}}};
#line 140 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
func_synth const   plain_i386[4][4]  = { {        (func_synth const   )(& synth_1to1_i386),        (func_synth const   )(& synth_1to1_8bit_i386),        (func_synth const   )(& synth_1to1_real_i386),        (func_synth const   )(& synth_1to1_s32_i386)}, 
   {        (func_synth const   )(& synth_2to1_i386),        (func_synth const   )(& synth_2to1_8bit_i386),        (func_synth const   )(& synth_2to1_real_i386),        (func_synth const   )(& synth_2to1_s32_i386)}, 
   {        (func_synth const   )(& synth_4to1_i386),        (func_synth const   )(& synth_4to1_8bit_i386),        (func_synth const   )(& synth_4to1_real_i386),        (func_synth const   )(& synth_4to1_s32_i386)}, 
   {        (func_synth const   )(& synth_ntom),        (func_synth const   )(& synth_ntom_8bit),        (func_synth const   )(& synth_ntom_real),        (func_synth const   )(& synth_ntom_s32)}};
#line 154 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
enum optdec defdec(void) 
{ 


  {
#line 154
  return ((enum optdec )14);
}
}
#line 156 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
enum optcla decclass(enum optdec  const  type ) 
{ 
  int tmp ;

  {
#line 158
  if ((unsigned int const   )type == 7U) {
#line 158
    tmp = 2;
  } else
#line 158
  if ((unsigned int const   )type == 11U) {
#line 158
    tmp = 2;
  } else
#line 158
  if ((unsigned int const   )type == 9U) {
#line 158
    tmp = 2;
  } else
#line 158
  if ((unsigned int const   )type == 12U) {
#line 158
    tmp = 2;
  } else {
#line 158
    tmp = 1;
  }
#line 158
  return ((enum optcla )tmp);
}
}
#line 162 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
static int find_synth(int (*synth)(float * , int  , mpg123_handle * , int  ) , func_synth const   (*synths)[4] ) 
{ 
  enum synth_resample ri ;
  enum synth_format fi ;

  {
#line 166
  ri = (enum synth_resample )0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((int )ri < 4)) {
#line 166
      goto while_break;
    }
#line 167
    fi = (enum synth_format )0;
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 167
      if (! ((int )fi < 4)) {
#line 167
        goto while_break___0;
      }
#line 168
      if ((unsigned long )synth == (unsigned long )(*(synths + ri))[fi]) {
#line 169
        return (1);
      }
#line 167
      fi = (enum synth_format )((int )fi + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    ri = (enum synth_resample )((int )ri + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return (0);
}
}
#line 176 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
static int find_dectype(mpg123_handle *fr ) 
{ 
  enum optdec type ;
  int (*basic_synth)(float * , int  , mpg123_handle * , int  ) ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 178
  type = (enum optdec )14;
#line 181
  basic_synth = fr->synth;
#line 184
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_8bit_wrap)) {
#line 185
    basic_synth = fr->synths.plain[0][0];
  }
#line 192
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_3dnowext)) {
#line 192
    type = (enum optdec )9;
  } else
#line 195
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_sse)) {
#line 195
    type = (enum optdec )11;
  } else
#line 198
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_3dnow)) {
#line 198
    type = (enum optdec )8;
  } else
#line 201
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_mmx)) {
#line 201
    type = (enum optdec )7;
  } else
#line 204
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_i586_dither)) {
#line 204
    type = (enum optdec )6;
  } else
#line 207
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_i586)) {
#line 207
    type = (enum optdec )5;
  } else
#line 219
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_dither)) {
#line 219
    type = (enum optdec )2;
  } else
#line 223
  if ((unsigned long )basic_synth == (unsigned long )(& synth_2to1_dither)) {
#line 227
    type = (enum optdec )2;
  } else
#line 223
  if ((unsigned long )basic_synth == (unsigned long )(& synth_4to1_dither)) {
#line 227
    type = (enum optdec )2;
  } else
#line 234
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_real_sse)) {
#line 234
    type = (enum optdec )11;
  } else
#line 247
  if ((unsigned long )basic_synth == (unsigned long )(& synth_1to1_s32_sse)) {
#line 247
    type = (enum optdec )11;
  } else {
    {
#line 258
    tmp___0 = find_synth(basic_synth, (func_synth const   (*)[4])(plain_i386));
    }
#line 258
    if (tmp___0) {
#line 259
      type = (enum optdec )3;
    } else {
      {
#line 262
      tmp = find_synth(basic_synth, (func_synth const   (*)[4])(synth_base.plain));
      }
#line 262
      if (tmp) {
#line 263
        type = (enum optdec )1;
      }
    }
  }
#line 273
  if ((unsigned int )type != 14U) {
    {
#line 275
    fr->cpu_opts.type = type;
#line 276
    fr->cpu_opts.class = decclass((enum optdec  const  )type);
    }
#line 279
    return (0);
  } else {
#line 283
    if (! (fr->p.flags & 32L)) {
      {
#line 283
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c:%i] error: Unable to determine active decoder type -- this is SERIOUS b0rkage!\n",
              283);
      }
    }
#line 285
    fr->err = 37;
#line 286
    return (-1);
  }
}
}
#line 291 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
int set_synth_functions(mpg123_handle *fr ) 
{ 
  enum synth_resample resample ;
  enum synth_format basic_format ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 293
  resample = (enum synth_resample )-1;
#line 294
  basic_format = (enum synth_format )-1;
#line 299
  if (fr->af.encoding & 64) {
#line 300
    basic_format = (enum synth_format )0;
  } else
#line 303
  if (fr->af.encoding & 15) {
#line 304
    basic_format = (enum synth_format )1;
  } else
#line 307
  if (fr->af.encoding & 3584) {
#line 308
    basic_format = (enum synth_format )2;
  } else
#line 311
  if (fr->af.encoding & 256) {
#line 312
    basic_format = (enum synth_format )3;
  }
#line 316
  if ((int )basic_format == -1) {
#line 318
    if (! (fr->p.flags & 32L)) {
      {
#line 318
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c:%i] error: set_synth_functions: This output format is disabled in this build!\n",
              318);
      }
    }
#line 320
    return (-1);
  }
  {
#line 326
  if (fr->down_sample == 0) {
#line 326
    goto case_0;
  }
#line 328
  if (fr->down_sample == 1) {
#line 328
    goto case_1;
  }
#line 329
  if (fr->down_sample == 2) {
#line 329
    goto case_2;
  }
#line 332
  if (fr->down_sample == 3) {
#line 332
    goto case_3;
  }
#line 324
  goto switch_break;
  case_0: /* CIL Label */ 
#line 326
  resample = (enum synth_resample )0;
#line 326
  goto switch_break;
  case_1: /* CIL Label */ 
#line 328
  resample = (enum synth_resample )1;
#line 328
  goto switch_break;
  case_2: /* CIL Label */ 
#line 329
  resample = (enum synth_resample )2;
#line 329
  goto switch_break;
  case_3: /* CIL Label */ 
#line 332
  resample = (enum synth_resample )3;
#line 332
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 336
  if ((int )resample == -1) {
#line 338
    if (! (fr->p.flags & 32L)) {
      {
#line 338
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c:%i] error: set_synth_functions: This resampling mode is not supported in this build!\n",
              338);
      }
    }
#line 340
    return (-1);
  }
#line 345
  fr->synth = fr->synths.plain[resample][basic_format];
#line 346
  fr->synth_stereo = fr->synths.stereo[resample][basic_format];
#line 347
  if (fr->af.channels == 2) {
#line 347
    fr->synth_mono = fr->synths.mono2stereo[resample][basic_format];
  } else {
#line 347
    fr->synth_mono = fr->synths.mono[resample][basic_format];
  }
  {
#line 351
  tmp = find_dectype(fr);
  }
#line 351
  if (tmp != 0) {
#line 353
    fr->err = 37;
#line 354
    return (-1);
  }
  {
#line 357
  tmp___0 = frame_buffers(fr);
  }
#line 357
  if (tmp___0 != 0) {
#line 359
    fr->err = 11;
#line 360
    if (! (fr->p.flags & 32L)) {
      {
#line 360
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c:%i] error: Failed to set up decoder buffers!\n",
              360);
      }
    }
#line 362
    return (-1);
  }
#line 366
  if ((int )basic_format == 1) {
    {
#line 368
    tmp___1 = make_conv16to8_table(fr);
    }
#line 368
    if (tmp___1 != 0) {
#line 370
      if (! (fr->p.flags & 32L)) {
        {
#line 370
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c:%i] error: Failed to set up conv16to8 table!\n",
                370);
        }
      }
#line 372
      return (-1);
    }
  }
#line 380
  if ((unsigned int )fr->cpu_opts.class == 2U) {
#line 380
    if ((int )basic_format != 2) {
#line 380
      if ((int )basic_format != 3) {
        {
#line 394
        init_layer3_stuff(fr, & init_layer3_gainpow2_mmx);
#line 397
        init_layer12_stuff(fr, & init_layer12_table_mmx);
#line 399
        fr->make_decode_tables = & make_decode_tables_mmx;
        }
      } else {
        {
#line 405
        init_layer3_stuff(fr, & init_layer3_gainpow2);
#line 408
        init_layer12_stuff(fr, & init_layer12_table);
#line 410
        fr->make_decode_tables = & make_decode_tables;
        }
      }
    } else {
      {
#line 405
      init_layer3_stuff(fr, & init_layer3_gainpow2);
#line 408
      init_layer12_stuff(fr, & init_layer12_table);
#line 410
      fr->make_decode_tables = & make_decode_tables;
      }
    }
  } else {
    {
#line 405
    init_layer3_stuff(fr, & init_layer3_gainpow2);
#line 408
    init_layer12_stuff(fr, & init_layer12_table);
#line 410
    fr->make_decode_tables = & make_decode_tables;
    }
  }
  {
#line 414
  (*(fr->make_decode_tables))(fr);
  }
#line 416
  return (0);
}
}
#line 419 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
int frame_cpu_opt(mpg123_handle *fr , char const   *cpu ) 
{ 
  char const   *chosen ;
  enum optdec want_dec ;
  int done ;
  int auto_choose ;
  int dithered ;
  enum synth_resample ri ;
  enum synth_format fi ;
  int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 421
  chosen = "";
#line 422
  want_dec = (enum optdec )14;
#line 423
  done = 0;
#line 424
  auto_choose = 0;
#line 426
  dithered = 0;
#line 429
  want_dec = dectype(cpu);
#line 430
  auto_choose = (unsigned int )want_dec == 0U;
#line 432
  fr->synths = (struct synth_s )synth_base;
#line 444
  fr->cpu_opts.type = (enum optdec )14;
#line 450
  fr->cpu_opts.dct36 = & dct36;
  }
#line 454
  if ((cpu_flags.id & 3840U) >> 8 == 0U) {
#line 454
    goto _L___5;
  } else
#line 454
  if ((cpu_flags.id & 3840U) >> 8 > 4U) {
    _L___5: /* CIL Label */ 
#line 460
    if (! done) {
#line 460
      if (auto_choose) {
#line 460
        goto _L___0;
      } else
#line 460
      if ((unsigned int )want_dec == 11U) {
        _L___0: /* CIL Label */ 
#line 460
        if (33554432U & cpu_flags.std2) {
#line 460
          if (8388608U & cpu_flags.std2) {
#line 460
            goto _L;
          } else
#line 460
          if (8388608U & cpu_flags.ext) {
            _L: /* CIL Label */ 
#line 463
            chosen = "SSE";
#line 464
            fr->cpu_opts.type = (enum optdec )11;
#line 466
            fr->synths.plain[0][0] = & synth_1to1_sse;
#line 472
            fr->synths.plain[0][2] = & synth_1to1_real_sse;
#line 473
            fr->synths.stereo[0][2] = & synth_1to1_real_stereo_sse;
#line 476
            fr->synths.plain[0][3] = & synth_1to1_s32_sse;
#line 477
            fr->synths.stereo[0][3] = & synth_1to1_s32_stereo_sse;
#line 479
            done = 1;
          }
        }
      }
    }
#line 483
    if (! done) {
#line 483
      if (auto_choose) {
#line 483
        goto _L___1;
      } else
#line 483
      if ((unsigned int )want_dec == 9U) {
        _L___1: /* CIL Label */ 
#line 483
        if (2147483648U & cpu_flags.ext) {
#line 483
          if (1073741824U & cpu_flags.ext) {
#line 483
            if (8388608U & cpu_flags.std2) {
#line 488
              chosen = "3DNowExt";
#line 489
              fr->cpu_opts.type = (enum optdec )9;
#line 491
              fr->cpu_opts.dct36 = & dct36_3dnowext;
#line 494
              fr->synths.plain[0][0] = & synth_1to1_3dnowext;
#line 496
              done = 1;
            } else
#line 483
            if (8388608U & cpu_flags.ext) {
#line 488
              chosen = "3DNowExt";
#line 489
              fr->cpu_opts.type = (enum optdec )9;
#line 491
              fr->cpu_opts.dct36 = & dct36_3dnowext;
#line 494
              fr->synths.plain[0][0] = & synth_1to1_3dnowext;
#line 496
              done = 1;
            }
          }
        }
      }
    }
#line 500
    if (! done) {
#line 500
      if (auto_choose) {
#line 500
        goto _L___2;
      } else
#line 500
      if ((unsigned int )want_dec == 8U) {
        _L___2: /* CIL Label */ 
#line 500
        if (2147483648U & cpu_flags.ext) {
#line 500
          if (8388608U & cpu_flags.std2) {
#line 503
            chosen = "3DNow";
#line 504
            fr->cpu_opts.type = (enum optdec )8;
#line 506
            fr->cpu_opts.dct36 = & dct36_3dnow;
#line 509
            fr->synths.plain[0][0] = & synth_1to1_3dnow;
#line 511
            done = 1;
          } else
#line 500
          if (8388608U & cpu_flags.ext) {
#line 503
            chosen = "3DNow";
#line 504
            fr->cpu_opts.type = (enum optdec )8;
#line 506
            fr->cpu_opts.dct36 = & dct36_3dnow;
#line 509
            fr->synths.plain[0][0] = & synth_1to1_3dnow;
#line 511
            done = 1;
          }
        }
      }
    }
#line 515
    if (! done) {
#line 515
      if (auto_choose) {
#line 515
        goto _L___3;
      } else
#line 515
      if ((unsigned int )want_dec == 7U) {
        _L___3: /* CIL Label */ 
#line 515
        if (8388608U & cpu_flags.std2) {
#line 518
          chosen = "MMX";
#line 519
          fr->cpu_opts.type = (enum optdec )7;
#line 521
          fr->synths.plain[0][0] = & synth_1to1_mmx;
#line 523
          done = 1;
        } else
#line 515
        if (8388608U & cpu_flags.ext) {
#line 518
          chosen = "MMX";
#line 519
          fr->cpu_opts.type = (enum optdec )7;
#line 521
          fr->synths.plain[0][0] = & synth_1to1_mmx;
#line 523
          done = 1;
        }
      }
    }
#line 527
    if (! done) {
#line 527
      if (auto_choose) {
#line 529
        chosen = "i586/pentium";
#line 530
        fr->cpu_opts.type = (enum optdec )5;
#line 532
        fr->synths.plain[0][0] = & synth_1to1_i586;
#line 534
        done = 1;
      } else
#line 527
      if ((unsigned int )want_dec == 5U) {
#line 529
        chosen = "i586/pentium";
#line 530
        fr->cpu_opts.type = (enum optdec )5;
#line 532
        fr->synths.plain[0][0] = & synth_1to1_i586;
#line 534
        done = 1;
      }
    }
#line 538
    if (! done) {
#line 538
      if (auto_choose) {
#line 538
        goto _L___4;
      } else
#line 538
      if ((unsigned int )want_dec == 6U) {
        _L___4: /* CIL Label */ 
#line 540
        chosen = "dithered i586/pentium";
#line 541
        fr->cpu_opts.type = (enum optdec )6;
#line 542
        dithered = 1;
#line 544
        fr->synths.plain[0][0] = & synth_1to1_i586_dither;
#line 546
        fr->synths.plain[1][0] = & synth_2to1_dither;
#line 547
        fr->synths.plain[2][0] = & synth_4to1_dither;
#line 550
        done = 1;
      }
    }
  }
#line 565
  if (! done) {
#line 565
    if (auto_choose) {
#line 567
      chosen = "i386";
#line 568
      fr->cpu_opts.type = (enum optdec )3;
#line 569
      done = 1;
    } else
#line 565
    if ((unsigned int )want_dec == 3U) {
#line 567
      chosen = "i386";
#line 568
      fr->cpu_opts.type = (enum optdec )3;
#line 569
      done = 1;
    }
  }
#line 573
  if (done) {
#line 584
    if ((unsigned long )fr->synths.plain[0][0] != (unsigned long )synth_base.plain[0][0]) {
#line 586
      fr->synths.plain[0][1] = & synth_1to1_8bit_wrap;
#line 587
      fr->synths.mono[0][1] = & synth_1to1_8bit_wrap_mono;
#line 588
      fr->synths.mono2stereo[0][1] = & synth_1to1_8bit_wrap_mono2stereo;
    }
#line 592
    ri = (enum synth_resample )0;
    {
#line 592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 592
      if (! ((int )ri < 4)) {
#line 592
        goto while_break;
      }
#line 593
      fi = (enum synth_format )0;
      {
#line 593
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 593
        if (! ((int )fi < 4)) {
#line 593
          goto while_break___0;
        }
#line 595
        if ((unsigned long )fr->synths.plain[ri][fi] == (unsigned long )synth_base.plain[ri][fi]) {
#line 596
          fr->synths.plain[ri][fi] = (func_synth )plain_i386[ri][fi];
        }
#line 593
        fi = (enum synth_format )((int )fi + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 592
      ri = (enum synth_resample )((int )ri + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 624
  if (! done) {
#line 624
    if (auto_choose) {
#line 624
      goto _L___6;
    } else
#line 624
    if ((unsigned int )want_dec == 2U) {
      _L___6: /* CIL Label */ 
#line 626
      chosen = "dithered generic";
#line 627
      fr->cpu_opts.type = (enum optdec )2;
#line 628
      dithered = 1;
#line 630
      fr->synths.plain[0][0] = & synth_1to1_dither;
#line 632
      fr->synths.plain[1][0] = & synth_2to1_dither;
#line 633
      fr->synths.plain[2][0] = & synth_4to1_dither;
#line 636
      done = 1;
    }
  }
#line 674
  if (! done) {
#line 674
    if (auto_choose) {
#line 676
      chosen = "generic";
#line 677
      fr->cpu_opts.type = (enum optdec )1;
#line 678
      done = 1;
    } else
#line 674
    if ((unsigned int )want_dec == 1U) {
#line 676
      chosen = "generic";
#line 677
      fr->cpu_opts.type = (enum optdec )1;
#line 678
      done = 1;
    }
  }
  {
#line 682
  fr->cpu_opts.class = decclass((enum optdec  const  )fr->cpu_opts.type);
  }
#line 687
  if ((unsigned int )fr->cpu_opts.type != 6U) {
#line 687
    if ((unsigned int )fr->cpu_opts.type != 2U) {
#line 687
      if ((unsigned long )fr->synths.plain[0][0] != (unsigned long )synth_base.plain[0][0]) {
#line 691
        fr->synths.plain[0][1] = & synth_1to1_8bit_wrap;
#line 692
        fr->synths.mono[0][1] = & synth_1to1_8bit_wrap_mono;
#line 693
        fr->synths.mono2stereo[0][1] = & synth_1to1_8bit_wrap_mono2stereo;
      }
    }
  }
#line 699
  if (done) {
#line 699
    if (dithered) {
      {
#line 702
      tmp = frame_dither_init(fr);
      }
#line 702
      if (! tmp) {
#line 704
        if (! (fr->p.flags & 32L)) {
          {
#line 704
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c:%i] error: Dither noise setup failed!\n",
                  704);
          }
        }
#line 705
        return (0);
      }
    }
  }
#line 710
  if (done) {
#line 712
    if (! (fr->p.flags & 32L)) {
#line 712
      if (fr->p.verbose) {
        {
#line 712
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Decoder: %s\n",
                chosen);
        }
      }
    }
#line 713
    return (1);
  } else {
#line 717
    if (! (fr->p.flags & 32L)) {
      {
#line 717
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c:%i] error: Could not set optimization!\n",
              717);
      }
    }
#line 718
    return (0);
  }
}
}
#line 722 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
enum optdec dectype(char const   *decoder ) 
{ 
  enum optdec dt ;
  int tmp ;

  {
#line 725
  if ((unsigned long )decoder == (unsigned long )((void *)0)) {
#line 727
    return ((enum optdec )0);
  } else
#line 725
  if ((int const   )*(decoder + 0) == 0) {
#line 727
    return ((enum optdec )0);
  }
#line 729
  dt = (enum optdec )0;
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! ((unsigned int )dt < 14U)) {
#line 729
      goto while_break;
    }
    {
#line 730
    tmp = strcasecmp(decoder, decname[dt]);
    }
#line 730
    if (! tmp) {
#line 730
      return (dt);
    }
#line 729
    dt = (enum optdec )((unsigned int )dt + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 732
  return ((enum optdec )14);
}
}
#line 738 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
static char const   *mpg123_supported_decoder_list[10]  = 
#line 738
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0), 
        (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0), 
        (char const   *)((void *)0),      (char const   *)((void *)0)};
#line 786 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
static char const   *mpg123_decoder_list[10]  = 
#line 786
  {      "SSE",      "3DNowExt",      "3DNow",      "MMX", 
        "i586",      "i586_dither",      "i386",      "generic", 
        "generic_dither",      (char const   *)((void *)0)};
#line 830 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
void check_decoders(void) 
{ 
  char const   **d ;
  char const   **tmp ;
  char const   **tmp___0 ;
  char const   **tmp___1 ;
  char const   **tmp___2 ;
  char const   **tmp___3 ;
  char const   **tmp___4 ;
  char const   **tmp___5 ;
  char const   **tmp___6 ;
  char const   **tmp___7 ;

  {
  {
#line 836
  d = mpg123_supported_decoder_list;
#line 838
  getcpuflags(& cpu_flags);
  }
#line 839
  if ((cpu_flags.id & 3840U) >> 8 == 0U) {
#line 839
    goto _L;
  } else
#line 839
  if ((cpu_flags.id & 3840U) >> 8 > 4U) {
    _L: /* CIL Label */ 
#line 844
    if (33554432U & cpu_flags.std2) {
#line 844
      tmp = d;
#line 844
      d ++;
#line 844
      *tmp = decname[11];
    }
#line 847
    if (1073741824U & cpu_flags.ext) {
#line 847
      tmp___0 = d;
#line 847
      d ++;
#line 847
      *tmp___0 = decname[9];
    }
#line 850
    if (2147483648U & cpu_flags.ext) {
#line 850
      tmp___1 = d;
#line 850
      d ++;
#line 850
      *tmp___1 = decname[8];
    }
#line 853
    if (8388608U & cpu_flags.std2) {
#line 853
      tmp___2 = d;
#line 853
      d ++;
#line 853
      *tmp___2 = decname[7];
    } else
#line 853
    if (8388608U & cpu_flags.ext) {
#line 853
      tmp___2 = d;
#line 853
      d ++;
#line 853
      *tmp___2 = decname[7];
    }
#line 856
    tmp___3 = d;
#line 856
    d ++;
#line 856
    *tmp___3 = decname[5];
#line 859
    tmp___4 = d;
#line 859
    d ++;
#line 859
    *tmp___4 = decname[6];
  }
#line 872
  tmp___5 = d;
#line 872
  d ++;
#line 872
  *tmp___5 = decname[3];
#line 881
  tmp___6 = d;
#line 881
  d ++;
#line 881
  *tmp___6 = decname[1];
#line 884
  tmp___7 = d;
#line 884
  d ++;
#line 884
  *tmp___7 = decname[2];
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
char const   * __attribute__((__force_align_arg_pointer__)) mpg123_current_decoder(mpg123_handle *mh___0 ) 
{ 


  {
#line 891
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 891
    return ((char const   */* __attribute__((__force_align_arg_pointer__)) */)((void *)0));
  }
#line 893
  return ((char const   */* __attribute__((__force_align_arg_pointer__)) */)decname[mh___0->cpu_opts.type]);
}
}
#line 896 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
char const __attribute__((__force_align_arg_pointer__))  **mpg123_decoders(void) 
{ 


  {
#line 896
  return ((char const __attribute__((__force_align_arg_pointer__))  **)(mpg123_decoder_list));
}
}
#line 897 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/optimize.c"
char const __attribute__((__force_align_arg_pointer__))  **mpg123_supported_decoders(void) 
{ 


  {
#line 900
  return ((char const __attribute__((__force_align_arg_pointer__))  **)(mpg123_supported_decoder_list));
}
}
#line 145 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.h"
void init_id3(mpg123_handle *fr ) ;
#line 22
void exit_id3(mpg123_handle *fr ) ;
#line 23
void reset_id3(mpg123_handle *fr ) ;
#line 26
int parse_new_id3(mpg123_handle *fr , unsigned long first4bytes ) ;
#line 17 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static char const   frame_type[4][5]  = { {        (char const   )'C',        (char const   )'O',        (char const   )'M',        (char const   )'M', 
            (char const   )'\000'}, 
   {        (char const   )'T',        (char const   )'X',        (char const   )'X',        (char const   )'X', 
            (char const   )'\000'}, 
   {        (char const   )'R',        (char const   )'V',        (char const   )'A',        (char const   )'2', 
            (char const   )'\000'}, 
   {        (char const   )'U',        (char const   )'S',        (char const   )'L',        (char const   )'T', 
            (char const   )'\000'}};
#line 24
static void convert_latin1(mpg123_string *sb , unsigned char const   *s , size_t l___0 ,
                           int const   noquiet ) ;
#line 25
static void convert_utf16bom(mpg123_string *sb , unsigned char const   *s , size_t l___0 ,
                             int const   noquiet ) ;
#line 26
static void convert_utf8(mpg123_string *sb , unsigned char const   *source , size_t len ,
                         int const   noquiet ) ;
#line 28 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static text_converter const   text_converters[4]  = {      (text_converter const   )(& convert_latin1),      (text_converter const   )(& convert_utf16bom),      (text_converter const   )(& convert_utf16bom),      (text_converter const   )(& convert_utf8)};
#line 38 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
unsigned int const   encoding_widths[4]  = {      (unsigned int const   )1,      (unsigned int const   )2,      (unsigned int const   )2,      (unsigned int const   )1};
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void null_id3_links(mpg123_handle *fr ) 
{ 


  {
#line 44
  fr->id3v2.title = (mpg123_string *)((void *)0);
#line 45
  fr->id3v2.artist = (mpg123_string *)((void *)0);
#line 46
  fr->id3v2.album = (mpg123_string *)((void *)0);
#line 47
  fr->id3v2.year = (mpg123_string *)((void *)0);
#line 48
  fr->id3v2.genre = (mpg123_string *)((void *)0);
#line 49
  fr->id3v2.comment = (mpg123_string *)((void *)0);
#line 50
  return;
}
}
#line 52 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
void init_id3(mpg123_handle *fr ) 
{ 


  {
  {
#line 54
  fr->id3v2.version = (unsigned char)0;
#line 55
  null_id3_links(fr);
#line 56
  fr->id3v2.comments = (size_t )0;
#line 57
  fr->id3v2.comment_list = (mpg123_text *)((void *)0);
#line 58
  fr->id3v2.texts = (size_t )0;
#line 59
  fr->id3v2.text = (mpg123_text *)((void *)0);
#line 60
  fr->id3v2.extras = (size_t )0;
#line 61
  fr->id3v2.extra = (mpg123_text *)((void *)0);
  }
#line 62
  return;
}
}
#line 67 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void init_mpg123_text(mpg123_text *txt ) 
{ 


  {
  {
#line 69
  mpg123_init_string(& txt->text);
#line 70
  mpg123_init_string(& txt->description);
#line 71
  txt->id[0] = (char)0;
#line 72
  txt->id[1] = (char)0;
#line 73
  txt->id[2] = (char)0;
#line 74
  txt->id[3] = (char)0;
#line 75
  txt->lang[0] = (char)0;
#line 76
  txt->lang[1] = (char)0;
#line 77
  txt->lang[2] = (char)0;
  }
#line 78
  return;
}
}
#line 81 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void free_mpg123_text(mpg123_text *txt ) 
{ 


  {
  {
#line 83
  mpg123_free_string(& txt->text);
#line 84
  mpg123_free_string(& txt->description);
  }
#line 85
  return;
}
}
#line 91 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void free_id3_text(mpg123_text **list , size_t *size ) 
{ 
  size_t i ;

  {
#line 94
  i = (size_t )0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < *size)) {
#line 94
      goto while_break;
    }
    {
#line 94
    free_mpg123_text(*list + i);
#line 94
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  free((void *)*list);
#line 97
  *list = (mpg123_text *)((void *)0);
#line 98
  *size = (size_t )0;
  }
#line 99
  return;
}
}
#line 105 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static mpg123_text *add_id3_text(mpg123_text **list , size_t *size ) 
{ 
  mpg123_text *x ;
  void *tmp ;

  {
  {
#line 107
  tmp = safe_realloc((void *)*list, (size_t )(sizeof(mpg123_text ) * (unsigned long )(*size + 1U)));
#line 107
  x = (mpg123_text *)tmp;
  }
#line 108
  if ((unsigned long )x == (unsigned long )((void *)0)) {
#line 108
    return ((mpg123_text *)((void *)0));
  }
  {
#line 110
  *list = x;
#line 111
  (*size) ++;
#line 112
  init_mpg123_text(*list + (*size - 1U));
  }
#line 114
  return (*list + (*size - 1U));
}
}
#line 121 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void pop_id3_text(mpg123_text **list , size_t *size ) 
{ 
  mpg123_text *x ;
  void *tmp ;

  {
#line 124
  if (*size < 1U) {
#line 124
    return;
  }
  {
#line 126
  free_mpg123_text(*list + (*size - 1U));
  }
#line 127
  if (*size > 1U) {
    {
#line 129
    tmp = safe_realloc((void *)*list, (size_t )(sizeof(mpg123_text ) * (unsigned long )(*size - 1U)));
#line 129
    x = (mpg123_text *)tmp;
    }
#line 130
    if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 130
      *list = x;
#line 130
      (*size) --;
    }
  } else {
    {
#line 134
    free((void *)*list);
#line 135
    *list = (mpg123_text *)((void *)0);
#line 136
    *size = (size_t )0;
    }
  }
#line 138
  return;
}
}
#line 142 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
void exit_id3(mpg123_handle *fr ) 
{ 


  {
  {
#line 144
  free_id3_text(& fr->id3v2.comment_list, & fr->id3v2.comments);
#line 145
  free_id3_text(& fr->id3v2.extra, & fr->id3v2.extras);
#line 146
  free_id3_text(& fr->id3v2.text, & fr->id3v2.texts);
  }
#line 147
  return;
}
}
#line 149 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
void reset_id3(mpg123_handle *fr ) 
{ 


  {
  {
#line 151
  exit_id3(fr);
#line 152
  init_id3(fr);
  }
#line 153
  return;
}
}
#line 156 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
void id3_link(mpg123_handle *fr ) 
{ 
  size_t i ;
  mpg123_id3v2 *v2 ;
  mpg123_text *entry ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  mpg123_text *entry___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 159
  v2 = & fr->id3v2;
#line 161
  null_id3_links(fr);
#line 162
  i = (size_t )0;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < v2->texts)) {
#line 162
      goto while_break;
    }
    {
#line 164
    entry = v2->text + i;
#line 165
    tmp___3 = strncmp("TIT2", (char const   *)(entry->id), (size_t )4);
    }
#line 165
    if (tmp___3) {
      {
#line 166
      tmp___2 = strncmp("TALB", (char const   *)(entry->id), (size_t )4);
      }
#line 166
      if (tmp___2) {
        {
#line 167
        tmp___1 = strncmp("TPE1", (char const   *)(entry->id), (size_t )4);
        }
#line 167
        if (tmp___1) {
          {
#line 168
          tmp___0 = strncmp("TYER", (char const   *)(entry->id), (size_t )4);
          }
#line 168
          if (tmp___0) {
            {
#line 169
            tmp = strncmp("TCON", (char const   *)(entry->id), (size_t )4);
            }
#line 169
            if (! tmp) {
#line 169
              v2->genre = & entry->text;
            }
          } else {
#line 168
            v2->year = & entry->text;
          }
        } else {
#line 167
          v2->artist = & entry->text;
        }
      } else {
#line 166
        v2->album = & entry->text;
      }
    } else {
#line 165
      v2->title = & entry->text;
    }
#line 162
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  i = (size_t )0;
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (i < v2->comments)) {
#line 171
      goto while_break___0;
    }
#line 173
    entry___0 = v2->comment_list + i;
#line 174
    if (entry___0->description.fill == 0U) {
#line 175
      v2->comment = & entry___0->text;
    } else
#line 174
    if ((int )*(entry___0->description.p + 0) == 0) {
#line 175
      v2->comment = & entry___0->text;
    }
#line 171
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 178
  if ((unsigned long )v2->comment == (unsigned long )((void *)0)) {
#line 178
    if (v2->comments > 0U) {
#line 179
      v2->comment = & (v2->comment_list + (v2->comments - 1U))->text;
    }
  }
#line 180
  return;
}
}
#line 189 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
void store_id3_text(mpg123_string *sb , char *source , size_t source_size , int const   noquiet ,
                    int const   notranslate ) 
{ 
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 191
  if (! source_size) {
#line 194
    return;
  }
#line 198
  if (notranslate) {
    {
#line 201
    tmp = (int )mpg123_resize_string(sb, source_size);
    }
#line 201
    if (! tmp) {
#line 203
      if (noquiet) {
        {
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Cannot resize target string, out of memory?\n",
                203);
        }
      }
#line 204
      return;
    }
    {
#line 206
    memcpy((void */* __restrict  */)sb->p, (void const   */* __restrict  */)source,
           source_size);
#line 207
    sb->fill = source_size;
    }
#line 209
    return;
  }
  {
#line 212
  id3_to_utf8(sb, *((unsigned char *)source + 0), (unsigned char const   *)((unsigned char *)source + 1),
              source_size - 1U, (int )noquiet);
  }
#line 214
  if (! sb->fill) {
#line 215
    if (noquiet) {
      {
#line 215
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: unable to convert string to UTF-8 (out of memory, junk input?)!\n",
              215);
      }
    }
  }
#line 216
  return;
}
}
#line 219 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
void id3_to_utf8(mpg123_string *sb , unsigned char encoding , unsigned char const   *source ,
                 size_t source_size , int noquiet ) 
{ 
  unsigned int bwidth ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 225
  if ((int )encoding > 3) {
#line 227
    if (noquiet) {
      {
#line 227
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Unknown text encoding %u, I take no chances, sorry!\n",
              227, (int )encoding);
      }
    }
    {
#line 229
    mpg123_free_string(sb);
    }
#line 230
    return;
  }
#line 232
  bwidth = (unsigned int )encoding_widths[encoding];
#line 234
  if ((int )encoding != 2) {
    {
#line 235
    while (1) {
      while_continue: /* CIL Label */ ;
#line 235
      if (source_size > bwidth) {
#line 235
        if (! ((int const   )*(source + 0) == 0)) {
#line 235
          goto while_break;
        }
      } else {
#line 235
        goto while_break;
      }
#line 237
      source_size --;
#line 238
      source ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 241
  if (source_size % bwidth) {
#line 244
    if (noquiet) {
      {
#line 244
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] warning: Weird tag size %d for encoding %u - I will probably trim too early or something but I think the MP3 is broken.\n",
              244, (int )source_size, (int )encoding);
      }
    }
#line 245
    source_size -= source_size % bwidth;
  }
  {
#line 247
  (*(text_converters[encoding]))(sb, source, source_size, (int const   )noquiet);
  }
#line 248
  return;
}
}
#line 250 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
char *next_text(char *prev , int encoding , size_t limit ) 
{ 
  char *text___0 ;
  size_t width ;
  size_t i ;

  {
#line 252
  text___0 = prev;
#line 253
  width = (size_t )encoding_widths[encoding];
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (text___0 - prev < (long )((ssize_t )limit))) {
#line 257
      goto while_break;
    }
#line 259
    if ((int )*(text___0 + 0) == 0) {
#line 261
      if ((long )width <= (long )limit - (text___0 - prev)) {
#line 263
        i = (size_t )1;
        {
#line 264
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 264
          if (! (i < width)) {
#line 264
            goto while_break___0;
          }
#line 264
          if ((int )*(text___0 + i) != 0) {
#line 264
            goto while_break___0;
          }
#line 264
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 266
        if (i == width) {
#line 268
          text___0 += width;
#line 269
          goto while_break;
        }
      } else {
#line 272
        return ((char *)((void *)0));
      }
    }
#line 275
    text___0 += width;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  if ((size_t )(text___0 - prev) >= limit) {
#line 277
    text___0 = (char *)((void *)0);
  }
#line 279
  return (text___0);
}
}
#line 282 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static char const   *enc_name(int enc ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 286
  if (enc == 0) {
#line 286
    goto case_0;
  }
#line 287
  if (enc == 1) {
#line 287
    goto case_1;
  }
#line 288
  if (enc == 2) {
#line 288
    goto case_2;
  }
#line 289
  if (enc == 3) {
#line 289
    goto case_3;
  }
#line 290
  goto switch_default;
  case_0: /* CIL Label */ 
#line 286
  return ("Latin 1");
  case_1: /* CIL Label */ 
#line 287
  return ("UTF-16 BOM");
  case_2: /* CIL Label */ 
#line 288
  return ("UTF-16 BE");
  case_3: /* CIL Label */ 
#line 289
  return ("UTF-8");
  switch_default: /* CIL Label */ 
#line 290
  return ("unknown!");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 294 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void process_text(mpg123_handle *fr , char *realdata , size_t realsize , char *id ) 
{ 
  mpg123_text *t ;
  mpg123_text *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 298
  tmp = add_id3_text(& fr->id3v2.text, & fr->id3v2.texts);
#line 298
  t = tmp;
  }
#line 299
  if (! (fr->p.flags & 32L)) {
#line 299
    if (fr->p.verbose > 3) {
      {
#line 299
      tmp___0 = enc_name((int )*(realdata + 0));
#line 299
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Storing text from %s encoding\n",
              tmp___0);
      }
    }
  }
#line 300
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 302
    if (! (fr->p.flags & 32L)) {
      {
#line 302
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Unable to attach new text!\n",
              302);
      }
    }
#line 303
    return;
  }
  {
#line 305
  memcpy((void */* __restrict  */)(t->id), (void const   */* __restrict  */)id, (size_t )4);
#line 306
  store_id3_text(& t->text, realdata, realsize, (int const   )(! (fr->p.flags & 32L)),
                 (int const   )(fr->p.flags & 2048L));
  }
#line 307
  if (! (fr->p.flags & 32L)) {
#line 307
    if (fr->p.verbose > 3) {
      {
#line 307
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: ID3v2 %c%c%c%c text frame: %s\n",
              (int )*(id + 0), (int )*(id + 1), (int )*(id + 2), (int )*(id + 3),
              t->text.p);
      }
    }
  }
#line 308
  return;
}
}
#line 312 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void process_comment(mpg123_handle *fr , enum frame_types tt , char *realdata ,
                            size_t realsize , int rva_level , char *id ) 
{ 
  char encoding ;
  char *lang ;
  char *descr ;
  char *text___0 ;
  mpg123_text *xcom ;
  mpg123_text localcom ;
  mpg123_text *tmp ;
  mpg123_text *tmp___0 ;
  char const   *tmp___1 ;
  int rva_mode ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 318
  encoding = *(realdata + 0);
#line 319
  lang = realdata + 1;
#line 320
  descr = realdata + 4;
#line 321
  text___0 = (char *)((void *)0);
#line 322
  xcom = (mpg123_text *)((void *)0);
#line 325
  if ((long )((int )realsize) < descr - realdata) {
#line 327
    if (! (fr->p.flags & 32L)) {
      {
#line 327
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Invalid frame size of %lu (too small for anything).\n",
              327, (unsigned long )realsize);
      }
    }
#line 328
    return;
  }
#line 330
  if ((int )tt == 3) {
    {
#line 330
    tmp = add_id3_text(& fr->id3v2.text, & fr->id3v2.texts);
#line 330
    xcom = tmp;
    }
  } else {
    {
#line 330
    tmp___0 = add_id3_text(& fr->id3v2.comment_list, & fr->id3v2.comments);
#line 330
    xcom = tmp___0;
    }
  }
#line 331
  if (! (fr->p.flags & 32L)) {
#line 331
    if (fr->p.verbose > 3) {
      {
#line 331
      tmp___1 = enc_name((int )*(realdata + 0));
#line 331
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Storing comment from %s encoding\n",
              tmp___1);
      }
    }
  }
#line 332
  if ((unsigned long )xcom == (unsigned long )((void *)0)) {
#line 334
    if (! (fr->p.flags & 32L)) {
      {
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Unable to attach new comment!\n",
              334);
      }
    }
#line 335
    return;
  }
  {
#line 337
  memcpy((void */* __restrict  */)(xcom->lang), (void const   */* __restrict  */)lang,
         (size_t )3);
#line 338
  memcpy((void */* __restrict  */)(xcom->id), (void const   */* __restrict  */)id,
         (size_t )4);
#line 340
  *(descr + -1) = encoding;
#line 342
  text___0 = next_text(descr, (int )encoding, (size_t )((long )realsize - (descr - realdata)));
  }
#line 343
  if ((unsigned long )text___0 == (unsigned long )((void *)0)) {
#line 345
    if (! (fr->p.flags & 32L)) {
      {
#line 345
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: No comment text / valid description?\n",
              345);
      }
    }
    {
#line 346
    pop_id3_text(& fr->id3v2.comment_list, & fr->id3v2.comments);
    }
#line 347
    return;
  }
  {
#line 350
  init_mpg123_text(& localcom);
#line 353
  store_id3_text(& xcom->description, descr - 1, (size_t )((text___0 - descr) + 1L),
                 (int const   )(! (fr->p.flags & 32L)), (int const   )(fr->p.flags & 2048L));
  }
#line 354
  if ((int )tt == 0) {
    {
#line 355
    store_id3_text(& localcom.description, descr - 1, (size_t )((text___0 - descr) + 1L),
                   (int const   )(! (fr->p.flags & 32L)), (int const   )0);
    }
  }
  {
#line 357
  *(text___0 + -1) = encoding;
#line 358
  store_id3_text(& xcom->text, text___0 - 1, (size_t )((long )(realsize + 1U) - (text___0 - realdata)),
                 (int const   )(! (fr->p.flags & 32L)), (int const   )(fr->p.flags & 2048L));
  }
#line 361
  if (! (fr->p.flags & 32L)) {
#line 361
    if (fr->p.verbose > 3) {
      {
#line 363
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: ID3 comm/uslt desc of length %lu.\n",
              (size_p )xcom->description.fill);
#line 364
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: ID3 comm/uslt text of length %lu.\n",
              (size_p )xcom->text.fill);
      }
    }
  }
#line 367
  if ((int )tt == 0) {
#line 367
    if (localcom.description.fill > 0U) {
      {
#line 369
      rva_mode = -1;
#line 370
      tmp___5 = strcasecmp((char const   *)localcom.description.p, "rva");
      }
#line 370
      if (tmp___5) {
        {
#line 370
        tmp___6 = strcasecmp((char const   *)localcom.description.p, "rva_mix");
        }
#line 370
        if (tmp___6) {
          {
#line 370
          tmp___7 = strcasecmp((char const   *)localcom.description.p, "rva_track");
          }
#line 370
          if (tmp___7) {
            {
#line 370
            tmp___8 = strcasecmp((char const   *)localcom.description.p, "rva_radio");
            }
#line 370
            if (tmp___8) {
              {
#line 375
              tmp___2 = strcasecmp((char const   *)localcom.description.p, "rva_album");
              }
#line 375
              if (tmp___2) {
                {
#line 375
                tmp___3 = strcasecmp((char const   *)localcom.description.p, "rva_audiophile");
                }
#line 375
                if (tmp___3) {
                  {
#line 375
                  tmp___4 = strcasecmp((char const   *)localcom.description.p, "rva_user");
                  }
#line 375
                  if (! tmp___4) {
#line 378
                    rva_mode = 1;
                  }
                } else {
#line 378
                  rva_mode = 1;
                }
              } else {
#line 378
                rva_mode = 1;
              }
            } else {
#line 374
              rva_mode = 0;
            }
          } else {
#line 374
            rva_mode = 0;
          }
        } else {
#line 374
          rva_mode = 0;
        }
      } else {
#line 374
        rva_mode = 0;
      }
#line 379
      if (rva_mode > -1) {
#line 379
        if (fr->rva.level[rva_mode] <= rva_level) {
          {
#line 382
          store_id3_text(& localcom.text, text___0 - 1, (size_t )((long )(realsize + 1U) - (text___0 - realdata)),
                         (int const   )(! (fr->p.flags & 32L)), (int const   )0);
          }
#line 383
          if (localcom.text.fill > 0U) {
            {
#line 385
            tmp___9 = atof((char const   *)localcom.text.p);
#line 385
            fr->rva.gain[rva_mode] = (float )tmp___9;
            }
#line 386
            if (! (fr->p.flags & 32L)) {
#line 386
              if (fr->p.verbose > 2) {
                {
#line 386
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: RVA value %fdB\n",
                        (double )fr->rva.gain[rva_mode]);
                }
              }
            }
#line 387
            fr->rva.peak[rva_mode] = (float )0;
#line 388
            fr->rva.level[rva_mode] = rva_level;
          }
        }
      }
    }
  }
  {
#line 393
  free_mpg123_text(& localcom);
  }
#line 394
  return;
}
}
#line 396 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
void process_extra(mpg123_handle *fr , char *realdata , size_t realsize , int rva_level ,
                   char *id ) 
{ 
  char encoding ;
  char *descr ;
  char *text___0 ;
  mpg123_text *xex ;
  mpg123_text localex ;
  char const   *tmp ;
  int is_peak ;
  int rva_mode ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 401
  encoding = *(realdata + 0);
#line 402
  descr = realdata + 1;
#line 407
  if ((long )((int )realsize) < descr - realdata) {
#line 409
    if (! (fr->p.flags & 32L)) {
      {
#line 409
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Invalid frame size of %lu (too small for anything).\n",
              409, (unsigned long )realsize);
      }
    }
#line 410
    return;
  }
  {
#line 412
  text___0 = next_text(descr, (int )encoding, (size_t )((long )realsize - (descr - realdata)));
  }
#line 413
  if (! (fr->p.flags & 32L)) {
#line 413
    if (fr->p.verbose > 3) {
      {
#line 413
      tmp = enc_name((int )*(realdata + 0));
#line 413
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Storing extra from %s encoding\n",
              tmp);
      }
    }
  }
#line 414
  if ((unsigned long )text___0 == (unsigned long )((void *)0)) {
#line 416
    if (! (fr->p.flags & 32L)) {
      {
#line 416
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: No extra frame text / valid description?\n",
              416);
      }
    }
#line 417
    return;
  }
  {
#line 419
  xex = add_id3_text(& fr->id3v2.extra, & fr->id3v2.extras);
  }
#line 420
  if ((unsigned long )xex == (unsigned long )((void *)0)) {
#line 422
    if (! (fr->p.flags & 32L)) {
      {
#line 422
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Unable to attach new extra text!\n",
              422);
      }
    }
#line 423
    return;
  }
  {
#line 425
  memcpy((void */* __restrict  */)(xex->id), (void const   */* __restrict  */)id,
         (size_t )4);
#line 426
  init_mpg123_text(& localex);
#line 430
  store_id3_text(& xex->description, descr - 1, (size_t )((text___0 - descr) + 1L),
                 (int const   )(! (fr->p.flags & 32L)), (int const   )(fr->p.flags & 2048L));
#line 432
  store_id3_text(& localex.description, descr - 1, (size_t )((text___0 - descr) + 1L),
                 (int const   )(! (fr->p.flags & 32L)), (int const   )0);
#line 434
  *(text___0 + -1) = encoding;
#line 435
  store_id3_text(& xex->text, text___0 - 1, (size_t )(((long )realsize - (text___0 - realdata)) + 1L),
                 (int const   )(! (fr->p.flags & 32L)), (int const   )(fr->p.flags & 2048L));
  }
#line 438
  if (localex.description.fill > 0U) {
    {
#line 440
    is_peak = 0;
#line 441
    rva_mode = -1;
#line 443
    tmp___5 = strncasecmp((char const   *)localex.description.p, "replaygain_track_",
                          (size_t )17);
    }
#line 443
    if (tmp___5) {
      {
#line 452
      tmp___4 = strncasecmp((char const   *)localex.description.p, "replaygain_album_",
                            (size_t )17);
      }
#line 452
      if (! tmp___4) {
#line 454
        if (! (fr->p.flags & 32L)) {
#line 454
          if (fr->p.verbose > 2) {
            {
#line 454
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: RVA ReplayGain album gain/peak\n");
            }
          }
        }
        {
#line 456
        rva_mode = 1;
#line 457
        tmp___3 = strcasecmp((char const   *)localex.description.p, "replaygain_album_peak");
        }
#line 457
        if (tmp___3) {
          {
#line 458
          tmp___2 = strcasecmp((char const   *)localex.description.p, "replaygain_album_gain");
          }
#line 458
          if (tmp___2) {
#line 458
            rva_mode = -1;
          }
        } else {
#line 457
          is_peak = 1;
        }
      }
    } else {
#line 445
      if (! (fr->p.flags & 32L)) {
#line 445
        if (fr->p.verbose > 2) {
          {
#line 445
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: RVA ReplayGain track gain/peak\n");
          }
        }
      }
      {
#line 447
      rva_mode = 0;
#line 448
      tmp___1 = strcasecmp((char const   *)localex.description.p, "replaygain_track_peak");
      }
#line 448
      if (tmp___1) {
        {
#line 449
        tmp___0 = strcasecmp((char const   *)localex.description.p, "replaygain_track_gain");
        }
#line 449
        if (tmp___0) {
#line 449
          rva_mode = -1;
        }
      } else {
#line 448
        is_peak = 1;
      }
    }
#line 460
    if (rva_mode > -1) {
#line 460
      if (fr->rva.level[rva_mode] <= rva_level) {
        {
#line 463
        store_id3_text(& localex.text, text___0 - 1, (size_t )(((long )realsize - (text___0 - realdata)) + 1L),
                       (int const   )(! (fr->p.flags & 32L)), (int const   )0);
        }
#line 464
        if (localex.text.fill > 0U) {
#line 466
          if (is_peak) {
            {
#line 468
            tmp___6 = atof((char const   *)localex.text.p);
#line 468
            fr->rva.peak[rva_mode] = (float )tmp___6;
            }
#line 469
            if (! (fr->p.flags & 32L)) {
#line 469
              if (fr->p.verbose > 2) {
                {
#line 469
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: RVA peak %f\n",
                        (double )fr->rva.peak[rva_mode]);
                }
              }
            }
          } else {
            {
#line 473
            tmp___7 = atof((char const   *)localex.text.p);
#line 473
            fr->rva.gain[rva_mode] = (float )tmp___7;
            }
#line 474
            if (! (fr->p.flags & 32L)) {
#line 474
              if (fr->p.verbose > 2) {
                {
#line 474
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: RVA gain %fdB\n",
                        (double )fr->rva.gain[rva_mode]);
                }
              }
            }
          }
#line 476
          fr->rva.level[rva_mode] = rva_level;
        }
      }
    }
  }
  {
#line 481
  free_mpg123_text(& localex);
  }
#line 482
  return;
}
}
#line 488 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
int promote_framename(mpg123_handle *fr , char *id ) 
{ 
  size_t i ;
  char *old[37] ;
  char *new[37] ;
  int tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
#line 491
  old[0] = (char *)"COM";
#line 491
  old[1] = (char *)"TAL";
#line 491
  old[2] = (char *)"TBP";
#line 491
  old[3] = (char *)"TCM";
#line 491
  old[4] = (char *)"TCO";
#line 491
  old[5] = (char *)"TCR";
#line 491
  old[6] = (char *)"TDA";
#line 491
  old[7] = (char *)"TDY";
#line 491
  old[8] = (char *)"TEN";
#line 491
  old[9] = (char *)"TFT";
#line 491
  old[10] = (char *)"TIM";
#line 491
  old[11] = (char *)"TKE";
#line 491
  old[12] = (char *)"TLA";
#line 491
  old[13] = (char *)"TLE";
#line 491
  old[14] = (char *)"TMT";
#line 491
  old[15] = (char *)"TOA";
#line 491
  old[16] = (char *)"TOF";
#line 491
  old[17] = (char *)"TOL";
#line 491
  old[18] = (char *)"TOR";
#line 491
  old[19] = (char *)"TOT";
#line 491
  old[20] = (char *)"TP1";
#line 491
  old[21] = (char *)"TP2";
#line 491
  old[22] = (char *)"TP3";
#line 491
  old[23] = (char *)"TP4";
#line 491
  old[24] = (char *)"TPA";
#line 491
  old[25] = (char *)"TPB";
#line 491
  old[26] = (char *)"TRC";
#line 491
  old[27] = (char *)"TDA";
#line 491
  old[28] = (char *)"TRK";
#line 491
  old[29] = (char *)"TSI";
#line 491
  old[30] = (char *)"TSS";
#line 491
  old[31] = (char *)"TT1";
#line 491
  old[32] = (char *)"TT2";
#line 491
  old[33] = (char *)"TT3";
#line 491
  old[34] = (char *)"TXT";
#line 491
  old[35] = (char *)"TXX";
#line 491
  old[36] = (char *)"TYE";
#line 498
  new[0] = (char *)"COMM";
#line 498
  new[1] = (char *)"TALB";
#line 498
  new[2] = (char *)"TBPM";
#line 498
  new[3] = (char *)"TCOM";
#line 498
  new[4] = (char *)"TCON";
#line 498
  new[5] = (char *)"TCOP";
#line 498
  new[6] = (char *)"TDAT";
#line 498
  new[7] = (char *)"TDLY";
#line 498
  new[8] = (char *)"TENC";
#line 498
  new[9] = (char *)"TFLT";
#line 498
  new[10] = (char *)"TIME";
#line 498
  new[11] = (char *)"TKEY";
#line 498
  new[12] = (char *)"TLAN";
#line 498
  new[13] = (char *)"TLEN";
#line 498
  new[14] = (char *)"TMED";
#line 498
  new[15] = (char *)"TOPE";
#line 498
  new[16] = (char *)"TOFN";
#line 498
  new[17] = (char *)"TOLY";
#line 498
  new[18] = (char *)"TORY";
#line 498
  new[19] = (char *)"TOAL";
#line 498
  new[20] = (char *)"TPE1";
#line 498
  new[21] = (char *)"TPE2";
#line 498
  new[22] = (char *)"TPE3";
#line 498
  new[23] = (char *)"TPE4";
#line 498
  new[24] = (char *)"TPOS";
#line 498
  new[25] = (char *)"TPUB";
#line 498
  new[26] = (char *)"TSRC";
#line 498
  new[27] = (char *)"TRDA";
#line 498
  new[28] = (char *)"TRCK";
#line 498
  new[29] = (char *)"TSIZ";
#line 498
  new[30] = (char *)"TSSE";
#line 498
  new[31] = (char *)"TIT1";
#line 498
  new[32] = (char *)"TIT2";
#line 498
  new[33] = (char *)"TIT3";
#line 498
  new[34] = (char *)"TEXT";
#line 498
  new[35] = (char *)"TXXX";
#line 498
  new[36] = (char *)"TYER";
#line 505
  i = (size_t )0;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! ((unsigned long )i < sizeof(old) / sizeof(char *))) {
#line 505
      goto while_break;
    }
    {
#line 507
    tmp = strncmp((char const   *)id, (char const   *)old[i], (size_t )3);
    }
#line 507
    if (! tmp) {
      {
#line 509
      memcpy((void */* __restrict  */)id, (void const   */* __restrict  */)new[i],
             (size_t )4);
      }
#line 510
      if (! (fr->p.flags & 32L)) {
#line 510
        if (fr->p.verbose > 2) {
          {
#line 510
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Translated ID3v2.2 frame %s to %s\n",
                  old[i], new[i]);
          }
        }
      }
#line 511
      return (0);
    }
#line 505
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 514
  if (! (fr->p.flags & 32L)) {
#line 514
    if (fr->p.verbose > 2) {
      {
#line 514
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring untranslated ID3v2.2 frame %c%c%c\n",
              (int )*(id + 0), (int )*(id + 1), (int )*(id + 2));
      }
    }
  }
#line 515
  return (-1);
}
}
#line 527 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
int parse_new_id3(mpg123_handle *fr , unsigned long first4bytes ) 
{ 
  unsigned char buf[6] ;
  unsigned long length ;
  unsigned char flags ;
  int ret ;
  int ret2 ;
  unsigned char *tagdata ;
  unsigned char major ;
  int tmp ;
  off_t tmp___0 ;
  unsigned long tagpos ;
  int tmp___1 ;
  int tmp___2 ;
  char id[5] ;
  unsigned long framesize ;
  unsigned long fflags ;
  int i ;
  unsigned long pos ;
  int head_part ;
  int tmp___3 ;
  enum frame_types tt ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int rva_mode ;
  unsigned long realsize ;
  unsigned char *realdata ;
  unsigned long ipos ;
  unsigned long opos ;
  void *tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  off_t tmp___14 ;
  void *tmp___15 ;
  off_t tmp___16 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 535
  length = 0UL;
#line 536
  flags = (unsigned char)0;
#line 537
  ret = 1;
#line 539
  tagdata = (unsigned char *)((void *)0);
#line 540
  major = (unsigned char )(first4bytes & 255UL);
#line 542
  if ((int )major == 255) {
#line 542
    return (0);
  }
  {
#line 543
  ret2 = (*((fr->rd)->read_frame_body))(fr, buf, 6);
  }
#line 543
  if (ret2 < 0) {
#line 544
    return (ret2);
  }
#line 546
  if ((int )buf[0] == 255) {
#line 546
    return (0);
  }
#line 549
  flags = buf[1];
#line 582
  if (((((int )*((buf + 2) + 0) | (int )*((buf + 2) + 1)) | (int )*((buf + 2) + 2)) | (int )*((buf + 2) + 3)) & 128) {
#line 582
    tmp = 0;
  } else {
#line 582
    length = ((((unsigned long )*((buf + 2) + 0) << 21) | ((unsigned long )*((buf + 2) + 1) << 14)) | ((unsigned long )*((buf + 2) + 2) << 7)) | (unsigned long )*((buf + 2) + 3);
#line 582
    tmp = 1;
  }
#line 582
  if (! tmp) {
#line 584
    if (! (fr->p.flags & 32L)) {
      {
#line 584
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Bad tag length (not synchsafe): 0x%02x%02x%02x%02x; You got a bad ID3 tag here.\n",
              584, (int )buf[2], (int )buf[3], (int )buf[4], (int )buf[5]);
      }
    }
#line 585
    return (0);
  }
#line 589
  if (! (fr->p.flags & 32L)) {
#line 589
    if (fr->p.verbose > 1) {
      {
#line 589
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: ID3v2.%i rev %i tag of %lu bytes\n",
              (int )major, (int )buf[0], length);
      }
    }
  }
#line 591
  if ((int )flags & 15) {
#line 591
    goto _L___1;
  } else
#line 591
  if ((int )major > 4) {
#line 591
    goto _L___1;
  } else
#line 591
  if ((int )major < 2) {
    _L___1: /* CIL Label */ 
#line 594
    if (! (fr->p.flags & 32L)) {
      {
#line 594
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] warning: ID3v2: Won\'t parse the ID3v2 tag with major version %u and flags 0x%xu - some extra code may be needed\n",
              594, (int )major, (int )flags);
      }
    }
    {
#line 596
    tmp___0 = (*((fr->rd)->skip_bytes))(fr, (off_t )length);
#line 596
    ret2 = (int )tmp___0;
    }
#line 596
    if (ret2 < 0) {
#line 597
      ret = ret2;
    }
  } else {
    {
#line 602
    fr->id3v2.version = major;
#line 604
    tmp___15 = malloc((size_t )(length + 1UL));
#line 604
    tagdata = (unsigned char *)tmp___15;
    }
#line 604
    if ((unsigned long )tagdata != (unsigned long )((void *)0)) {
      {
#line 607
      ret2 = (*((fr->rd)->read_frame_body))(fr, tagdata, (int )length);
      }
#line 607
      if (ret2 > 0) {
#line 609
        tagpos = 0UL;
#line 612
        *(tagdata + length) = (unsigned char)0;
#line 613
        if ((int )flags & 64) {
#line 616
          if ((int )major == 3) {
#line 616
            tagpos = ((((unsigned long )*(tagdata + 0) << 24) | ((unsigned long )*(tagdata + 1) << 16)) | ((unsigned long )*(tagdata + 2) << 8)) | (unsigned long )*(tagdata + 3);
#line 616
            tmp___2 = 1;
          } else {
#line 616
            if (((((int )*(tagdata + 0) | (int )*(tagdata + 1)) | (int )*(tagdata + 2)) | (int )*(tagdata + 3)) & 128) {
#line 616
              tmp___1 = 0;
            } else {
#line 616
              tagpos = ((((unsigned long )*(tagdata + 0) << 21) | ((unsigned long )*(tagdata + 1) << 14)) | ((unsigned long )*(tagdata + 2) << 7)) | (unsigned long )*(tagdata + 3);
#line 616
              tmp___1 = 1;
            }
#line 616
            tmp___2 = tmp___1;
          }
#line 616
          if (! tmp___2) {
#line 618
            ret = 0;
#line 619
            if (! (fr->p.flags & 32L)) {
              {
#line 619
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Bad (non-synchsafe) tag offset: 0x%02x%02x%02x%02x\n",
                      619, (int )*(tagdata + 0), (int )*(tagdata + 1), (int )*(tagdata + 2),
                      (int )*(tagdata + 3));
              }
            }
          }
        }
#line 622
        if (ret > 0) {
#line 627
          id[4] = (char)0;
          {
#line 629
          while (1) {
            while_continue: /* CIL Label */ ;
#line 629
            if (! (tagpos < length - 10UL)) {
#line 629
              goto while_break;
            }
#line 631
            i = 0;
#line 632
            pos = tagpos;
#line 633
            if ((int )fr->id3v2.version == 2) {
#line 633
              tmp___3 = 3;
            } else {
#line 633
              tmp___3 = 4;
            }
#line 633
            head_part = tmp___3;
#line 636
            tt = (enum frame_types )-2;
#line 638
            i = 0;
            {
#line 638
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 638
              if (! (i < head_part)) {
#line 638
                goto while_break___0;
              }
#line 639
              if ((int )*(tagdata + (tagpos + (unsigned long )i)) > 47) {
#line 639
                if (! ((int )*(tagdata + (tagpos + (unsigned long )i)) < 58)) {
#line 639
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 639
              if ((int )*(tagdata + (tagpos + (unsigned long )i)) > 64) {
#line 639
                if (! ((int )*(tagdata + (tagpos + (unsigned long )i)) < 91)) {
#line 644
                  goto tagparse_cleanup;
                }
              } else {
#line 644
                goto tagparse_cleanup;
              }
#line 638
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 646
            if (ret > 0) {
              {
#line 649
              strncpy((char */* __restrict  */)(id), (char const   */* __restrict  */)((char *)tagdata + pos),
                      (size_t )head_part);
#line 650
              pos += (unsigned long )head_part;
#line 651
              tagpos += (unsigned long )head_part;
              }
#line 653
              if ((int )fr->id3v2.version == 2) {
#line 653
                framesize = (((unsigned long )*((tagdata + pos) + 0) << 16) | ((unsigned long )*((tagdata + pos) + 1) << 8)) | (unsigned long )*((tagdata + pos) + 2);
              } else {
#line 655
                if ((int )major == 3) {
#line 655
                  framesize = ((((unsigned long )*((tagdata + pos) + 0) << 24) | ((unsigned long )*((tagdata + pos) + 1) << 16)) | ((unsigned long )*((tagdata + pos) + 2) << 8)) | (unsigned long )*((tagdata + pos) + 3);
#line 655
                  tmp___5 = 1;
                } else {
#line 655
                  if (((((int )*((tagdata + pos) + 0) | (int )*((tagdata + pos) + 1)) | (int )*((tagdata + pos) + 2)) | (int )*((tagdata + pos) + 3)) & 128) {
#line 655
                    tmp___4 = 0;
                  } else {
#line 655
                    framesize = ((((unsigned long )*((tagdata + pos) + 0) << 21) | ((unsigned long )*((tagdata + pos) + 1) << 14)) | ((unsigned long )*((tagdata + pos) + 2) << 7)) | (unsigned long )*((tagdata + pos) + 3);
#line 655
                    tmp___4 = 1;
                  }
#line 655
                  tmp___5 = tmp___4;
                }
#line 655
                if (! tmp___5) {
#line 658
                  if (! (fr->p.flags & 32L)) {
                    {
#line 658
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: ID3v2: non-syncsafe size of %s frame, skipping the remainder of tag\n",
                            658, id);
                    }
                  }
#line 659
                  goto while_break;
                }
              }
#line 661
              if (! (fr->p.flags & 32L)) {
#line 661
                if (fr->p.verbose > 2) {
                  {
#line 661
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: ID3v2 %s frame of size %lu\n",
                          id, framesize);
                  }
                }
              }
#line 662
              tagpos += (unsigned long )head_part + framesize;
#line 663
              if (tagpos > length) {
#line 665
                if (! (fr->p.flags & 32L)) {
                  {
#line 665
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Whoa! ID3v2 frame claims to be larger than the whole rest of the tag.\n",
                          665);
                  }
                }
#line 666
                goto while_break;
              }
#line 668
              pos += (unsigned long )head_part;
#line 669
              if ((int )fr->id3v2.version > 2) {
#line 671
                fflags = ((unsigned long )*(tagdata + pos) << 8) | (unsigned long )*(tagdata + (pos + 1UL));
#line 672
                pos += 2UL;
#line 673
                tagpos += 2UL;
              } else {
#line 675
                fflags = 0UL;
              }
#line 688
              if (head_part < 4) {
                {
#line 688
                tmp___6 = promote_framename(fr, id);
                }
#line 688
                if (tmp___6 != 0) {
#line 688
                  goto while_continue;
                }
              }
#line 691
              if (fflags & 36796UL) {
#line 693
                if (! (fr->p.flags & 32L)) {
                  {
#line 693
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] warning: ID3v2: skipping invalid/unsupported frame\n",
                          693);
                  }
                }
#line 694
                goto while_continue;
              }
#line 697
              i = 0;
              {
#line 697
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 697
                if (! (i < 4)) {
#line 697
                  goto while_break___1;
                }
                {
#line 698
                tmp___7 = strncmp(frame_type[i], (char const   *)(id), (size_t )4);
                }
#line 698
                if (! tmp___7) {
#line 698
                  tt = (enum frame_types )i;
#line 698
                  goto while_break___1;
                }
#line 697
                i ++;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 700
              if ((int )id[0] == 84) {
#line 700
                if ((int )tt != 1) {
#line 700
                  tt = (enum frame_types )-1;
                }
              }
#line 702
              if ((int )tt != -2) {
#line 704
                rva_mode = -1;
#line 705
                realsize = framesize;
#line 706
                realdata = tagdata + pos;
#line 707
                if ((int )flags & 128) {
#line 707
                  goto _L___0;
                } else
#line 707
                if (fflags & 2UL) {
                  _L___0: /* CIL Label */ 
                  {
#line 709
                  ipos = 0UL;
#line 710
                  opos = 0UL;
#line 715
                  tmp___8 = malloc((size_t )framesize);
#line 715
                  realdata = (unsigned char *)tmp___8;
                  }
#line 716
                  if ((unsigned long )realdata == (unsigned long )((void *)0)) {
#line 718
                    if (! (fr->p.flags & 32L)) {
                      {
#line 718
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: ID3v2: unable to allocate working buffer for de-unsync\n",
                              718);
                      }
                    }
#line 719
                    goto while_continue;
                  }
#line 722
                  *(realdata + 0) = *(tagdata + pos);
#line 723
                  opos = 1UL;
#line 724
                  ipos = pos + 1UL;
                  {
#line 724
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 724
                    if (! (ipos < pos + framesize)) {
#line 724
                      goto while_break___2;
                    }
#line 726
                    if ((int )*(tagdata + ipos) == 0) {
#line 726
                      if (! ((int )*(tagdata + (ipos - 1UL)) == 255)) {
#line 728
                        tmp___9 = opos;
#line 728
                        opos ++;
#line 728
                        *(realdata + tmp___9) = *(tagdata + ipos);
                      }
                    } else {
#line 728
                      tmp___9 = opos;
#line 728
                      opos ++;
#line 728
                      *(realdata + tmp___9) = *(tagdata + ipos);
                    }
#line 724
                    ipos ++;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 731
                  realsize = opos;
                }
#line 734
                pos = 0UL;
                {
#line 738
                if ((int )tt == 3) {
#line 738
                  goto case_3;
                }
#line 738
                if ((int )tt == 0) {
#line 738
                  goto case_3;
                }
#line 741
                if ((int )tt == 1) {
#line 741
                  goto case_1;
                }
#line 744
                if ((int )tt == 2) {
#line 744
                  goto case_2;
                }
#line 775
                if ((int )tt == -1) {
#line 775
                  goto case_neg_1;
                }
#line 778
                goto switch_default;
                case_3: /* CIL Label */ 
                case_0: /* CIL Label */ 
                {
#line 739
                process_comment(fr, tt, (char *)realdata, (size_t )realsize, 1, id);
                }
#line 740
                goto switch_break;
                case_1: /* CIL Label */ 
                {
#line 742
                process_extra(fr, (char *)realdata, (size_t )realsize, 2, id);
                }
#line 743
                goto switch_break;
                case_2: /* CIL Label */ 
#line 747
                if (! (fr->p.flags & 32L)) {
#line 747
                  if (fr->p.verbose > 2) {
                    {
#line 747
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: RVA2 identification \"%s\"\n",
                            realdata);
                    }
                  }
                }
                {
#line 749
                rva_mode = 0;
#line 750
                tmp___10 = strncasecmp((char const   *)((char *)realdata), "album",
                                       (size_t )5);
                }
#line 750
                if (tmp___10) {
                  {
#line 750
                  tmp___11 = strncasecmp((char const   *)((char *)realdata), "audiophile",
                                         (size_t )10);
                  }
#line 750
                  if (tmp___11) {
                    {
#line 750
                    tmp___12 = strncasecmp((char const   *)((char *)realdata), "user",
                                           (size_t )4);
                    }
#line 750
                    if (! tmp___12) {
#line 753
                      rva_mode = 1;
                    }
                  } else {
#line 753
                    rva_mode = 1;
                  }
                } else {
#line 753
                  rva_mode = 1;
                }
#line 754
                if (fr->rva.level[rva_mode] <= 3) {
                  {
#line 756
                  tmp___13 = strlen((char const   *)((char *)realdata));
#line 756
                  pos += (unsigned long )(tmp___13 + 1U);
                  }
#line 757
                  if ((int )*(realdata + pos) == 1) {
#line 759
                    pos ++;
#line 764
                    fr->rva.gain[rva_mode] = (float )(((int )((short )((signed char )*(realdata + pos))) << 8) | (int )*(realdata + (pos + 1UL))) / (float )512;
#line 765
                    pos += 2UL;
#line 766
                    if (! (fr->p.flags & 32L)) {
#line 766
                      if (fr->p.verbose > 2) {
                        {
#line 766
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: RVA value %fdB\n",
                                (double )fr->rva.gain[rva_mode]);
                        }
                      }
                    }
#line 768
                    fr->rva.peak[rva_mode] = (float )0;
#line 769
                    fr->rva.level[rva_mode] = 3;
                  }
                }
#line 773
                goto switch_break;
                case_neg_1: /* CIL Label */ 
                {
#line 776
                process_text(fr, (char *)realdata, (size_t )realsize, id);
                }
#line 777
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 778
                if (! (fr->p.flags & 32L)) {
                  {
#line 778
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: ID3v2: unknown frame type %i\n",
                          778, (int )tt);
                  }
                }
                switch_break: /* CIL Label */ ;
                }
#line 780
                if ((int )flags & 128) {
                  {
#line 780
                  free((void *)realdata);
                  }
                } else
#line 780
                if (fflags & 2UL) {
                  {
#line 780
                  free((void *)realdata);
                  }
                }
              }
            } else {
#line 792
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
      } else {
#line 800
        if (length > 0UL) {
#line 800
          if (! (fr->p.flags & 32L)) {
            {
#line 800
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: ID3v2: Duh, not able to read ID3v2 tag data.\n",
                    800);
            }
          }
        }
#line 801
        ret = ret2;
      }
      tagparse_cleanup: 
      {
#line 804
      free((void *)tagdata);
      }
    } else {
#line 808
      if (! (fr->p.flags & 32L)) {
        {
#line 808
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: ID3v2: Arrg! Unable to allocate %lu bytes for interpreting ID3v2 data - trying to skip instead.\n",
                808, length);
        }
      }
      {
#line 809
      tmp___14 = (*((fr->rd)->skip_bytes))(fr, (off_t )length);
#line 809
      ret2 = (int )tmp___14;
      }
#line 809
      if (ret2 < 0) {
#line 809
        ret = ret2;
      } else {
#line 810
        ret = 0;
      }
    }
  }
#line 815
  if (ret > 0) {
#line 815
    if ((int )flags & 16) {
      {
#line 815
      tmp___16 = (*((fr->rd)->skip_bytes))(fr, (off_t )length);
#line 815
      ret2 = (int )tmp___16;
      }
#line 815
      if (ret2 < 0) {
#line 815
        ret = ret2;
      }
    }
  }
#line 817
  return (ret);
}
}
#line 827 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void convert_latin1(mpg123_string *sb , unsigned char const   *s , size_t l___0 ,
                           int const   noquiet ) 
{ 
  size_t length ;
  size_t i ;
  unsigned char *p ;
  int tmp ;

  {
#line 829
  length = l___0;
#line 833
  i = (size_t )0;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (! (i < l___0)) {
#line 833
      goto while_break;
    }
#line 834
    if ((int const   )*(s + i) >= 128) {
#line 834
      length ++;
    }
#line 833
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 838
  tmp = (int )mpg123_resize_string(sb, length + 1U);
  }
#line 838
  if (! tmp) {
    {
#line 838
    mpg123_free_string(sb);
    }
#line 838
    return;
  }
#line 840
  p = (unsigned char *)sb->p;
#line 841
  i = (size_t )0;
  {
#line 841
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 841
    if (! (i < l___0)) {
#line 841
      goto while_break___0;
    }
#line 842
    if ((int const   )*(s + i) < 128) {
#line 842
      *p = (unsigned char )*(s + i);
#line 842
      p ++;
    } else {
#line 845
      *p = (unsigned char )(192 | (int )((int const   )*(s + i) >> 6));
#line 846
      *(p + 1) = (unsigned char )(128 | (int )((int const   )*(s + i) & 63));
#line 847
      p += 2;
    }
#line 841
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 850
  *(sb->p + length) = (char)0;
#line 851
  sb->fill = length + 1U;
#line 852
  return;
}
}
#line 865 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static int check_bom(unsigned char const   **source , size_t *len ) 
{ 
  int this_bom ;
  int further_bom ;

  {
#line 867
  this_bom = 0;
#line 868
  further_bom = 0;
#line 870
  if (*len < 2U) {
#line 870
    return (0);
  }
#line 872
  if ((int const   )*(*source + 0) == 255) {
#line 872
    if ((int const   )*(*source + 1) == 254) {
#line 873
      this_bom = -1;
    }
  }
#line 875
  if ((int const   )*(*source + 0) == 254) {
#line 875
    if ((int const   )*(*source + 1) == 255) {
#line 876
      this_bom = 1;
    }
  }
#line 879
  if (this_bom != 0) {
    {
#line 881
    *source += 2;
#line 882
    *len -= 2U;
#line 884
    further_bom = check_bom(source, len);
    }
#line 885
    if (further_bom == 0) {
#line 885
      return (this_bom);
    } else {
#line 886
      return (further_bom);
    }
  } else {
#line 888
    return (0);
  }
}
}
#line 894 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void convert_utf16bom(mpg123_string *sb , unsigned char const   *s , size_t l___0 ,
                             int const   noquiet ) 
{ 
  size_t i ;
  size_t n ;
  unsigned char *p ;
  size_t length ;
  size_t high ;
  size_t low ;
  int bom_endian ;
  unsigned long point ;
  unsigned short second ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned long codepoint ;
  unsigned short second___0 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  char *__cil_tmp34 ;

  {
  {
#line 899
  length = (size_t )0;
#line 901
  high = (size_t )0;
#line 902
  low = (size_t )1;
#line 907
  bom_endian = check_bom(& s, & l___0);
  }
#line 910
  if (bom_endian == -1) {
#line 912
    high = (size_t )1;
#line 913
    low = (size_t )0;
  }
#line 916
  n = (l___0 / 2U) * 2U;
#line 919
  i = (size_t )0;
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (i < n)) {
#line 919
      goto while_break;
    }
#line 921
    point = ((unsigned long )*(s + (i + high)) << 8) + (unsigned long )*(s + (i + low));
#line 922
    if ((point & 55296UL) == 55296UL) {
#line 924
      if (i + 3U < l___0) {
#line 924
        tmp = ((int const   )*(s + ((i + 2U) + high)) << 8) + (int const   )*(s + ((i + 2U) + low));
      } else {
#line 924
        tmp = (int const   )0;
      }
#line 924
      second = (unsigned short )tmp;
#line 925
      if (((int )second & 56320) == 56320) {
#line 927
        point = (((point & 1023UL) << 10) + (unsigned long )((int )second & 1023)) + 65536UL;
#line 928
        if (point < 128UL) {
#line 928
          tmp___2 = 1;
        } else {
#line 928
          if (point < 2048UL) {
#line 928
            tmp___1 = 2;
          } else {
#line 928
            if (point < 65536UL) {
#line 928
              tmp___0 = 3;
            } else {
#line 928
              tmp___0 = 4;
            }
#line 928
            tmp___1 = tmp___0;
          }
#line 928
          tmp___2 = tmp___1;
        }
#line 928
        length += (size_t )tmp___2;
#line 929
        i += 2U;
      } else {
#line 933
        if (noquiet) {
          {
#line 933
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c:%i] error: Invalid UTF16 surrogate pair at %li (0x%04lx).\n",
                  933, (unsigned long )i, point);
          }
        }
#line 934
        n = i;
#line 935
        goto while_break;
      }
    } else {
#line 938
      if (point < 128UL) {
#line 938
        tmp___5 = 1;
      } else {
#line 938
        if (point < 2048UL) {
#line 938
          tmp___4 = 2;
        } else {
#line 938
          if (point < 65536UL) {
#line 938
            tmp___3 = 3;
          } else {
#line 938
            tmp___3 = 4;
          }
#line 938
          tmp___4 = tmp___3;
        }
#line 938
        tmp___5 = tmp___4;
      }
#line 938
      length += (size_t )tmp___5;
    }
#line 919
    i += 2U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 941
  tmp___6 = (int )mpg123_resize_string(sb, length + 1U);
  }
#line 941
  if (! tmp___6) {
    {
#line 941
    mpg123_free_string(sb);
    }
#line 941
    return;
  }
#line 944
  p = (unsigned char *)sb->p;
#line 945
  i = (size_t )0;
  {
#line 945
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 945
    if (! (i < n)) {
#line 945
      goto while_break___0;
    }
#line 947
    codepoint = ((unsigned long )*(s + (i + high)) << 8) + (unsigned long )*(s + (i + low));
#line 948
    if ((codepoint & 55296UL) == 55296UL) {
#line 950
      second___0 = (unsigned short )(((int const   )*(s + ((i + 2U) + high)) << 8) + (int const   )*(s + ((i + 2U) + low)));
#line 951
      codepoint = (((codepoint & 1023UL) << 10) + (unsigned long )((int )second___0 & 1023)) + 65536UL;
#line 952
      i += 2U;
    }
#line 954
    if (codepoint < 128UL) {
#line 954
      tmp___7 = p;
#line 954
      p ++;
#line 954
      *tmp___7 = (unsigned char )codepoint;
    } else
#line 955
    if (codepoint < 2048UL) {
#line 957
      tmp___8 = p;
#line 957
      p ++;
#line 957
      *tmp___8 = (unsigned char )(192UL | (codepoint >> 6));
#line 958
      tmp___9 = p;
#line 958
      p ++;
#line 958
      *tmp___9 = (unsigned char )(128UL | (codepoint & 63UL));
    } else
#line 960
    if (codepoint < 65536UL) {
#line 962
      tmp___10 = p;
#line 962
      p ++;
#line 962
      *tmp___10 = (unsigned char )(224UL | (codepoint >> 12));
#line 963
      tmp___11 = p;
#line 963
      p ++;
#line 963
      *tmp___11 = (unsigned char )(128UL | ((codepoint >> 6) & 63UL));
#line 964
      tmp___12 = p;
#line 964
      p ++;
#line 964
      *tmp___12 = (unsigned char )(128UL | (codepoint & 63UL));
    } else
#line 966
    if (codepoint < 2097152UL) {
#line 968
      tmp___13 = p;
#line 968
      p ++;
#line 968
      *tmp___13 = (unsigned char )(240UL | (codepoint >> 18));
#line 969
      tmp___14 = p;
#line 969
      p ++;
#line 969
      *tmp___14 = (unsigned char )(128UL | ((codepoint >> 12) & 63UL));
#line 970
      tmp___15 = p;
#line 970
      p ++;
#line 970
      *tmp___15 = (unsigned char )(128UL | ((codepoint >> 6) & 63UL));
#line 971
      tmp___16 = p;
#line 971
      p ++;
#line 971
      *tmp___16 = (unsigned char )(128UL | (codepoint & 63UL));
    }
#line 945
    i += 2U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 974
  *(sb->p + (sb->size - 1U)) = (char)0;
#line 975
  sb->fill = sb->size;
#line 976
  return;
}
}
#line 980 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/id3.c"
static void convert_utf8(mpg123_string *sb , unsigned char const   *source , size_t len ,
                         int const   noquiet ) 
{ 
  int tmp ;

  {
  {
#line 982
  tmp = (int )mpg123_resize_string(sb, len + 1U);
  }
#line 982
  if (tmp) {
    {
#line 984
    memcpy((void */* __restrict  */)sb->p, (void const   */* __restrict  */)source,
           len);
#line 985
    *(sb->p + len) = (char)0;
#line 986
    sb->fill = len + 1U;
    }
  } else {
    {
#line 988
    mpg123_free_string(sb);
    }
  }
#line 989
  return;
}
}
#line 12 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/equalizer.c"
void do_equalizer(float *bandPtr , int channel , float (*equalizer)[32] ) 
{ 
  int i ;

  {
#line 15
  i = 0;
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! (i < 32)) {
#line 15
      goto while_break;
    }
#line 16
    *(bandPtr + i) *= (*(equalizer + channel))[i];
#line 15
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 17
  return;
}
}
#line 22 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/dct64.c"
void dct64(float *out0 , float *out1 , float *samples ) 
{ 
  float bufs[64] ;
  register int i ;
  register int j ;
  register float *b1 ;
  register float *b2 ;
  register float *bs___0 ;
  register float *costab ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;
  float *tmp___3 ;
  float *tmp___4 ;
  float *tmp___5 ;
  float *tmp___6 ;
  float *tmp___7 ;
  float *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  float *tmp___29 ;
  float *tmp___30 ;
  float *tmp___31 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float v0 ;
  float v1 ;
  float *tmp___35 ;
  float *tmp___36 ;
  float *tmp___37 ;
  float *tmp___38 ;
  float *tmp___39 ;
  float *tmp___40 ;
  float *tmp___41 ;
  float *tmp___42 ;
  register float *b1___0 ;
  register int i___0 ;
  void *__cil_tmp59 ;

  {
#line 30
  b1 = samples;
#line 31
  bs___0 = bufs;
#line 32
  costab = pnts[0] + 16;
#line 33
  b2 = b1 + 32;
#line 35
  i = 15;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i >= 0)) {
#line 35
      goto while_break;
    }
#line 36
    tmp = bs___0;
#line 36
    bs___0 ++;
#line 36
    tmp___0 = b1;
#line 36
    b1 ++;
#line 36
    b2 --;
#line 36
    *tmp = *tmp___0 + *b2;
#line 35
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  i = 15;
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 37
    if (! (i >= 0)) {
#line 37
      goto while_break___0;
    }
#line 38
    tmp___1 = bs___0;
#line 38
    bs___0 ++;
#line 38
    b2 --;
#line 38
    tmp___2 = b1;
#line 38
    b1 ++;
#line 38
    costab --;
#line 38
    *tmp___1 = (*b2 - *tmp___2) * *costab;
#line 37
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 40
  b1 = bufs;
#line 41
  costab = pnts[1] + 8;
#line 42
  b2 = b1 + 16;
#line 45
  i = 7;
  {
#line 45
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 45
    if (! (i >= 0)) {
#line 45
      goto while_break___1;
    }
#line 46
    tmp___3 = bs___0;
#line 46
    bs___0 ++;
#line 46
    tmp___4 = b1;
#line 46
    b1 ++;
#line 46
    b2 --;
#line 46
    *tmp___3 = *tmp___4 + *b2;
#line 45
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 47
  i = 7;
  {
#line 47
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 47
    if (! (i >= 0)) {
#line 47
      goto while_break___2;
    }
#line 48
    tmp___5 = bs___0;
#line 48
    bs___0 ++;
#line 48
    b2 --;
#line 48
    tmp___6 = b1;
#line 48
    b1 ++;
#line 48
    costab --;
#line 48
    *tmp___5 = (*b2 - *tmp___6) * *costab;
#line 47
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 49
  b2 += 32;
#line 50
  costab += 8;
#line 51
  i = 7;
  {
#line 51
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 51
    if (! (i >= 0)) {
#line 51
      goto while_break___3;
    }
#line 52
    tmp___7 = bs___0;
#line 52
    bs___0 ++;
#line 52
    tmp___8 = b1;
#line 52
    b1 ++;
#line 52
    b2 --;
#line 52
    *tmp___7 = *tmp___8 + *b2;
#line 51
    i --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 53
  i = 7;
  {
#line 53
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 53
    if (! (i >= 0)) {
#line 53
      goto while_break___4;
    }
#line 54
    tmp___9 = bs___0;
#line 54
    bs___0 ++;
#line 54
    tmp___10 = b1;
#line 54
    b1 ++;
#line 54
    b2 --;
#line 54
    costab --;
#line 54
    *tmp___9 = (*tmp___10 - *b2) * *costab;
#line 53
    i --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 55
  b2 += 32;
#line 58
  bs___0 = bufs;
#line 59
  costab = pnts[2];
#line 60
  b2 = b1 + 8;
#line 62
  j = 2;
  {
#line 62
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 62
    if (! j) {
#line 62
      goto while_break___5;
    }
#line 64
    i = 3;
    {
#line 64
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 64
      if (! (i >= 0)) {
#line 64
        goto while_break___6;
      }
#line 65
      tmp___11 = bs___0;
#line 65
      bs___0 ++;
#line 65
      tmp___12 = b1;
#line 65
      b1 ++;
#line 65
      b2 --;
#line 65
      *tmp___11 = *tmp___12 + *b2;
#line 64
      i --;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 66
    i = 3;
    {
#line 66
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 66
      if (! (i >= 0)) {
#line 66
        goto while_break___7;
      }
#line 67
      tmp___13 = bs___0;
#line 67
      bs___0 ++;
#line 67
      b2 --;
#line 67
      tmp___14 = b1;
#line 67
      b1 ++;
#line 67
      *tmp___13 = (*b2 - *tmp___14) * *(costab + i);
#line 66
      i --;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 68
    b2 += 16;
#line 69
    i = 3;
    {
#line 69
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 69
      if (! (i >= 0)) {
#line 69
        goto while_break___8;
      }
#line 70
      tmp___15 = bs___0;
#line 70
      bs___0 ++;
#line 70
      tmp___16 = b1;
#line 70
      b1 ++;
#line 70
      b2 --;
#line 70
      *tmp___15 = *tmp___16 + *b2;
#line 69
      i --;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 71
    i = 3;
    {
#line 71
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 71
      if (! (i >= 0)) {
#line 71
        goto while_break___9;
      }
#line 72
      tmp___17 = bs___0;
#line 72
      bs___0 ++;
#line 72
      tmp___18 = b1;
#line 72
      b1 ++;
#line 72
      b2 --;
#line 72
      *tmp___17 = (*tmp___18 - *b2) * *(costab + i);
#line 71
      i --;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 73
    b2 += 16;
#line 62
    j --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 76
  b1 = bufs;
#line 77
  costab = pnts[3];
#line 78
  b2 = b1 + 4;
#line 80
  j = 4;
  {
#line 80
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 80
    if (! j) {
#line 80
      goto while_break___10;
    }
#line 82
    tmp___19 = bs___0;
#line 82
    bs___0 ++;
#line 82
    tmp___20 = b1;
#line 82
    b1 ++;
#line 82
    b2 --;
#line 82
    *tmp___19 = *tmp___20 + *b2;
#line 83
    tmp___21 = bs___0;
#line 83
    bs___0 ++;
#line 83
    tmp___22 = b1;
#line 83
    b1 ++;
#line 83
    b2 --;
#line 83
    *tmp___21 = *tmp___22 + *b2;
#line 84
    tmp___23 = bs___0;
#line 84
    bs___0 ++;
#line 84
    b2 --;
#line 84
    tmp___24 = b1;
#line 84
    b1 ++;
#line 84
    *tmp___23 = (*b2 - *tmp___24) * *(costab + 1);
#line 85
    tmp___25 = bs___0;
#line 85
    bs___0 ++;
#line 85
    b2 --;
#line 85
    tmp___26 = b1;
#line 85
    b1 ++;
#line 85
    *tmp___25 = (*b2 - *tmp___26) * *(costab + 0);
#line 86
    b2 += 8;
#line 87
    tmp___27 = bs___0;
#line 87
    bs___0 ++;
#line 87
    tmp___28 = b1;
#line 87
    b1 ++;
#line 87
    b2 --;
#line 87
    *tmp___27 = *tmp___28 + *b2;
#line 88
    tmp___29 = bs___0;
#line 88
    bs___0 ++;
#line 88
    tmp___30 = b1;
#line 88
    b1 ++;
#line 88
    b2 --;
#line 88
    *tmp___29 = *tmp___30 + *b2;
#line 89
    tmp___31 = bs___0;
#line 89
    bs___0 ++;
#line 89
    tmp___32 = b1;
#line 89
    b1 ++;
#line 89
    b2 --;
#line 89
    *tmp___31 = (*tmp___32 - *b2) * *(costab + 1);
#line 90
    tmp___33 = bs___0;
#line 90
    bs___0 ++;
#line 90
    tmp___34 = b1;
#line 90
    b1 ++;
#line 90
    b2 --;
#line 90
    *tmp___33 = (*tmp___34 - *b2) * *(costab + 0);
#line 91
    b2 += 8;
#line 80
    j --;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 93
  bs___0 = bufs;
#line 94
  costab = pnts[4];
#line 96
  j = 8;
  {
#line 96
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 96
    if (! j) {
#line 96
      goto while_break___11;
    }
#line 99
    tmp___35 = b1;
#line 99
    b1 ++;
#line 99
    v0 = *tmp___35;
#line 99
    tmp___36 = b1;
#line 99
    b1 ++;
#line 99
    v1 = *tmp___36;
#line 100
    tmp___37 = bs___0;
#line 100
    bs___0 ++;
#line 100
    *tmp___37 = v0 + v1;
#line 101
    tmp___38 = bs___0;
#line 101
    bs___0 ++;
#line 101
    *tmp___38 = (v0 - v1) * *costab;
#line 102
    tmp___39 = b1;
#line 102
    b1 ++;
#line 102
    v0 = *tmp___39;
#line 102
    tmp___40 = b1;
#line 102
    b1 ++;
#line 102
    v1 = *tmp___40;
#line 103
    tmp___41 = bs___0;
#line 103
    bs___0 ++;
#line 103
    *tmp___41 = v0 + v1;
#line 104
    tmp___42 = bs___0;
#line 104
    bs___0 ++;
#line 104
    *tmp___42 = (v1 - v0) * *costab;
#line 96
    j --;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 114
  b1___0 = bufs;
#line 114
  i___0 = 8;
  {
#line 114
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 114
    if (! i___0) {
#line 114
      goto while_break___12;
    }
#line 115
    *(b1___0 + 2) += *(b1___0 + 3);
#line 114
    i___0 --;
#line 114
    b1___0 += 4;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 117
  b1___0 = bufs;
#line 117
  i___0 = 4;
  {
#line 117
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 117
    if (! i___0) {
#line 117
      goto while_break___13;
    }
#line 119
    *(b1___0 + 4) += *(b1___0 + 6);
#line 120
    *(b1___0 + 6) += *(b1___0 + 5);
#line 121
    *(b1___0 + 5) += *(b1___0 + 7);
#line 117
    i___0 --;
#line 117
    b1___0 += 8;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 124
  b1___0 = bufs;
#line 124
  i___0 = 2;
  {
#line 124
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 124
    if (! i___0) {
#line 124
      goto while_break___14;
    }
#line 126
    *(b1___0 + 8) += *(b1___0 + 12);
#line 127
    *(b1___0 + 12) += *(b1___0 + 10);
#line 128
    *(b1___0 + 10) += *(b1___0 + 14);
#line 129
    *(b1___0 + 14) += *(b1___0 + 9);
#line 130
    *(b1___0 + 9) += *(b1___0 + 13);
#line 131
    *(b1___0 + 13) += *(b1___0 + 11);
#line 132
    *(b1___0 + 11) += *(b1___0 + 15);
#line 124
    i___0 --;
#line 124
    b1___0 += 16;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 137
  *(out0 + 256) = bufs[0];
#line 138
  *(out0 + 240) = bufs[16] + bufs[24];
#line 139
  *(out0 + 224) = bufs[8];
#line 140
  *(out0 + 208) = bufs[24] + bufs[20];
#line 141
  *(out0 + 192) = bufs[4];
#line 142
  *(out0 + 176) = bufs[20] + bufs[28];
#line 143
  *(out0 + 160) = bufs[12];
#line 144
  *(out0 + 144) = bufs[28] + bufs[18];
#line 145
  *(out0 + 128) = bufs[2];
#line 146
  *(out0 + 112) = bufs[18] + bufs[26];
#line 147
  *(out0 + 96) = bufs[10];
#line 148
  *(out0 + 80) = bufs[26] + bufs[22];
#line 149
  *(out0 + 64) = bufs[6];
#line 150
  *(out0 + 48) = bufs[22] + bufs[30];
#line 151
  *(out0 + 32) = bufs[14];
#line 152
  *(out0 + 16) = bufs[30] + bufs[17];
#line 153
  *(out0 + 0) = bufs[1];
#line 155
  *(out1 + 0) = bufs[1];
#line 156
  *(out1 + 16) = bufs[17] + bufs[25];
#line 157
  *(out1 + 32) = bufs[9];
#line 158
  *(out1 + 48) = bufs[25] + bufs[21];
#line 159
  *(out1 + 64) = bufs[5];
#line 160
  *(out1 + 80) = bufs[21] + bufs[29];
#line 161
  *(out1 + 96) = bufs[13];
#line 162
  *(out1 + 112) = bufs[29] + bufs[19];
#line 163
  *(out1 + 128) = bufs[3];
#line 164
  *(out1 + 144) = bufs[19] + bufs[27];
#line 165
  *(out1 + 160) = bufs[11];
#line 166
  *(out1 + 176) = bufs[27] + bufs[23];
#line 167
  *(out1 + 192) = bufs[7];
#line 168
  *(out1 + 208) = bufs[23] + bufs[31];
#line 169
  *(out1 + 224) = bufs[15];
#line 170
  *(out1 + 240) = bufs[31];
#line 172
  return;
}
}
#line 378 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
void __attribute__((__force_align_arg_pointer__))  mpg123_rates(long const   **list ,
                                                                size_t *number ) ;
#line 384
void __attribute__((__force_align_arg_pointer__))  mpg123_encodings(int const   **list ,
                                                                    size_t *number ) ;
#line 388
int __attribute__((__force_align_arg_pointer__))  mpg123_format_none(mpg123_handle *mh___0 ) ;
#line 392
int __attribute__((__force_align_arg_pointer__))  mpg123_format_all(mpg123_handle *mh___0 ) ;
#line 400
int __attribute__((__force_align_arg_pointer__))  mpg123_format(mpg123_handle *mh___0 ,
                                                                long rate , int channels ,
                                                                int encodings ) ;
#line 406
int __attribute__((__force_align_arg_pointer__))  mpg123_format_support(mpg123_handle *mh___0 ,
                                                                        long rate ,
                                                                        int encoding ) ;
#line 942
int __attribute__((__force_align_arg_pointer__))  mpg123_fmt_none(mpg123_pars *mp ) ;
#line 946
int __attribute__((__force_align_arg_pointer__))  mpg123_fmt_all(mpg123_pars *mp ) ;
#line 954
int __attribute__((__force_align_arg_pointer__))  mpg123_fmt(mpg123_pars *mp , long rate ,
                                                             int channels , int encodings ) ;
#line 960
int __attribute__((__force_align_arg_pointer__))  mpg123_fmt_support(mpg123_pars *mp ,
                                                                     long rate , int encoding ) ;
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
static long const   my_rates[9]  = 
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
  {      (long const   )8000,      (long const   )11025,      (long const   )12000,      (long const   )16000, 
        (long const   )22050,      (long const   )24000,      (long const   )32000,      (long const   )44100, 
        (long const   )48000};
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
static int const   my_encodings[10]  = 
#line 20
  {      (int const   )208,      (int const   )96,      (int const   )4480,      (int const   )8448, 
        (int const   )512,      (int const   )1024,      (int const   )130,      (int const   )1, 
        (int const   )4,      (int const   )8};
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
static int const   good_encodings[9]  = 
#line 42
  {      (int const   )208,      (int const   )96,      (int const   )4480,      (int const   )8448, 
        (int const   )512,      (int const   )130,      (int const   )1,      (int const   )4, 
        (int const   )8};
#line 65 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
static int good_enc(int const   enc ) 
{ 
  size_t i ;

  {
#line 68
  i = (size_t )0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )i < sizeof(good_encodings) / sizeof(int ))) {
#line 68
      goto while_break;
    }
#line 69
    if (enc == good_encodings[i]) {
#line 69
      return (1);
    }
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (0);
}
}
#line 74 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
void __attribute__((__force_align_arg_pointer__))  mpg123_rates(long const   **list ,
                                                                size_t *number ) 
{ 


  {
#line 76
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 76
    *list = my_rates;
  }
#line 77
  if ((unsigned long )number != (unsigned long )((void *)0)) {
#line 77
    *number = (size_t )(sizeof(my_rates) / sizeof(long ));
  }
#line 78
  return;
}
}
#line 81 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
void __attribute__((__force_align_arg_pointer__))  mpg123_encodings(int const   **list ,
                                                                    size_t *number ) 
{ 


  {
#line 83
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 83
    *list = good_encodings;
  }
#line 84
  if ((unsigned long )number != (unsigned long )((void *)0)) {
#line 84
    *number = (size_t )(sizeof(good_encodings) / sizeof(int ));
  }
#line 85
  return;
}
}
#line 89 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
static int rate2num(mpg123_pars *mp , long r ) 
{ 
  int i ;

  {
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i < 9)) {
#line 92
      goto while_break;
    }
#line 92
    if (my_rates[i] == (long const   )r) {
#line 92
      return (i);
    }
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if (mp) {
#line 94
    if (mp->force_rate != 0L) {
#line 94
      if (mp->force_rate == r) {
#line 94
        return (9);
      }
    }
  }
#line 97
  return (-1);
}
}
#line 100 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
static int enc2num(int encoding ) 
{ 
  int i ;

  {
#line 103
  i = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < 10)) {
#line 103
      goto while_break;
    }
#line 104
    if (my_encodings[i] == (int const   )encoding) {
#line 104
      return (i);
    }
#line 103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (-1);
}
}
#line 109 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
static int cap_fit(mpg123_handle *fr , struct audioformat *nf , int f0 , int f2 ) 
{ 
  int i ;
  int c ;
  int rn ;
  int tmp ;

  {
  {
#line 112
  c = nf->channels - 1;
#line 113
  tmp = rate2num(& fr->p, nf->rate);
#line 113
  rn = tmp;
  }
#line 114
  if (rn >= 0) {
#line 114
    i = f0;
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (! (i < f2)) {
#line 114
        goto while_break;
      }
#line 116
      if (fr->p.audio_caps[c][rn][i]) {
#line 118
        nf->encoding = (int )my_encodings[i];
#line 119
        return (1);
      }
#line 114
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 122
  return (0);
}
}
#line 125 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
static int freq_fit(mpg123_handle *fr , struct audioformat *nf , int f0 , int f2 ) 
{ 
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int i ;
  int c ;
  int rn ;
  long tmp___3 ;
  int tmp___4 ;
  int rrn ;

  {
  {
#line 127
  tmp = frame_freq(fr);
#line 127
  nf->rate = tmp >> fr->p.down_sample;
#line 128
  tmp___0 = cap_fit(fr, nf, f0, f2);
  }
#line 128
  if (tmp___0) {
#line 128
    return (1);
  }
  {
#line 129
  nf->rate >>= 1;
#line 130
  tmp___1 = cap_fit(fr, nf, f0, f2);
  }
#line 130
  if (tmp___1) {
#line 130
    return (1);
  }
  {
#line 131
  nf->rate >>= 1;
#line 132
  tmp___2 = cap_fit(fr, nf, f0, f2);
  }
#line 132
  if (tmp___2) {
#line 132
    return (1);
  }
#line 136
  if (! fr->p.force_rate) {
#line 136
    if (fr->p.down_sample == 0) {
      {
#line 139
      c = nf->channels - 1;
#line 140
      tmp___3 = frame_freq(fr);
#line 140
      tmp___4 = rate2num(& fr->p, tmp___3);
#line 140
      rn = tmp___4;
      }
#line 142
      if (rn < 0) {
#line 142
        return (0);
      }
#line 144
      i = f0;
      {
#line 144
      while (1) {
        while_continue: /* CIL Label */ ;
#line 144
        if (! (i < f2)) {
#line 144
          goto while_break;
        }
#line 144
        rrn = rn + 1;
        {
#line 144
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 144
          if (! (rrn < 9)) {
#line 144
            goto while_break___0;
          }
#line 145
          if (fr->p.audio_caps[c][rrn][i]) {
#line 147
            nf->rate = (long )my_rates[rrn];
#line 148
            nf->encoding = (int )my_encodings[i];
#line 149
            return (1);
          }
#line 144
          rrn ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 144
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 152
      i = f0;
      {
#line 152
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 152
        if (! (i < f2)) {
#line 152
          goto while_break___1;
        }
#line 152
        rrn = rn - 1;
        {
#line 152
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 152
          if (! (rrn >= 0)) {
#line 152
            goto while_break___2;
          }
#line 153
          if (fr->p.audio_caps[c][rrn][i]) {
#line 155
            nf->rate = (long )my_rates[rrn];
#line 156
            nf->encoding = (int )my_encodings[i];
#line 157
            return (1);
          }
#line 152
          rrn --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 152
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 162
  return (0);
}
}
#line 167 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
int frame_output_format(mpg123_handle *fr ) 
{ 
  struct audioformat nf ;
  int f0 ;
  int f2 ;
  mpg123_pars *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 170
  f0 = 0;
#line 171
  f2 = 10;
#line 172
  p = & fr->p;
#line 174
  nf.channels = fr->stereo;
#line 177
  if (p->flags & 16L) {
#line 179
    f0 = 6;
#line 180
    f2 = 10;
  }
#line 182
  if (p->flags & 1024L) {
#line 184
    f0 = 4;
#line 185
    f2 = 6;
  }
#line 189
  if (p->flags & 7L) {
#line 189
    nf.channels = 1;
  }
#line 190
  if (p->flags & 8L) {
#line 190
    nf.channels = 2;
  }
#line 193
  if (p->force_rate) {
    {
#line 195
    nf.rate = p->force_rate;
#line 196
    tmp = cap_fit(fr, & nf, f0, 2);
    }
#line 196
    if (tmp) {
#line 196
      goto end;
    }
#line 197
    if (f0 <= 2) {
#line 197
      tmp___0 = 2;
    } else {
#line 197
      tmp___0 = f0;
    }
    {
#line 197
    tmp___1 = cap_fit(fr, & nf, tmp___0, f2);
    }
#line 197
    if (tmp___1) {
#line 197
      goto end;
    }
#line 200
    if (nf.channels == 2) {
#line 200
      if (! (p->flags & 8L)) {
#line 200
        nf.channels = 1;
      } else {
#line 200
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 201
    if (nf.channels == 1) {
#line 201
      if (! (p->flags & 7L)) {
#line 201
        nf.channels = 2;
      }
    }
    {
#line 203
    tmp___2 = cap_fit(fr, & nf, f0, 2);
    }
#line 203
    if (tmp___2) {
#line 203
      goto end;
    }
#line 204
    if (f0 <= 2) {
#line 204
      tmp___3 = 2;
    } else {
#line 204
      tmp___3 = f0;
    }
    {
#line 204
    tmp___4 = cap_fit(fr, & nf, tmp___3, f2);
    }
#line 204
    if (tmp___4) {
#line 204
      goto end;
    }
#line 206
    if (! (fr->p.flags & 32L)) {
#line 207
      if (p->flags & 16L) {
#line 207
        tmp___5 = "8bit, ";
      } else {
#line 207
        tmp___5 = "";
      }
#line 207
      if (p->flags & 8L) {
#line 207
        tmp___7 = "stereo, ";
      } else {
#line 207
        if (p->flags & 7L) {
#line 207
          tmp___6 = "mono, ";
        } else {
#line 207
          tmp___6 = "";
        }
#line 207
        tmp___7 = tmp___6;
      }
      {
#line 207
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c:%i] error: Unable to set up output format! Constraints: %s%s%liHz.\n",
              211, tmp___7, tmp___5, p->force_rate);
      }
    }
#line 214
    fr->err = 1;
#line 215
    return (-1);
  }
  {
#line 219
  tmp___8 = freq_fit(fr, & nf, f0, 2);
  }
#line 219
  if (tmp___8) {
#line 219
    goto end;
  }
#line 220
  if (f0 <= 2) {
#line 220
    tmp___9 = 2;
  } else {
#line 220
    tmp___9 = f0;
  }
  {
#line 220
  tmp___10 = freq_fit(fr, & nf, tmp___9, f2);
  }
#line 220
  if (tmp___10) {
#line 220
    goto end;
  }
#line 223
  if (nf.channels == 2) {
#line 223
    if (! (p->flags & 8L)) {
#line 223
      nf.channels = 1;
    } else {
#line 223
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 224
  if (nf.channels == 1) {
#line 224
    if (! (p->flags & 7L)) {
#line 224
      nf.channels = 2;
    }
  }
  {
#line 226
  tmp___11 = freq_fit(fr, & nf, f0, 2);
  }
#line 226
  if (tmp___11) {
#line 226
    goto end;
  }
#line 227
  if (f0 <= 2) {
#line 227
    tmp___12 = 2;
  } else {
#line 227
    tmp___12 = f0;
  }
  {
#line 227
  tmp___13 = freq_fit(fr, & nf, tmp___12, f2);
  }
#line 227
  if (tmp___13) {
#line 227
    goto end;
  }
#line 230
  if (! (fr->p.flags & 32L)) {
    {
#line 232
    tmp___14 = frame_freq(fr);
#line 232
    tmp___15 = frame_freq(fr);
#line 232
    tmp___16 = frame_freq(fr);
    }
#line 232
    if (p->flags & 16L) {
#line 232
      tmp___17 = "8bit, ";
    } else {
#line 232
      tmp___17 = "";
    }
#line 232
    if (p->flags & 8L) {
#line 232
      tmp___19 = "stereo, ";
    } else {
#line 232
      if (p->flags & 7L) {
#line 232
        tmp___18 = "mono, ";
      } else {
#line 232
        tmp___18 = "";
      }
#line 232
      tmp___19 = tmp___18;
    }
    {
#line 232
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c:%i] error: Unable to set up output format! Constraints: %s%s%li, %li or %liHz.\n",
            236, tmp___19, tmp___17, tmp___16, tmp___15 >> 1, tmp___14 >> 2);
    }
  }
#line 240
  fr->err = 1;
#line 241
  return (-1);
  end: 
#line 245
  if (nf.rate == fr->af.rate) {
#line 245
    if (nf.channels == fr->af.channels) {
#line 245
      if (nf.encoding == fr->af.encoding) {
#line 248
        return (0);
      } else {
#line 245
        goto _L___2;
      }
    } else {
#line 245
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 253
    fr->af.rate = nf.rate;
#line 254
    fr->af.channels = nf.channels;
#line 255
    fr->af.encoding = nf.encoding;
#line 257
    if (fr->af.encoding & 15) {
#line 258
      fr->af.encsize = 1;
    } else
#line 259
    if (fr->af.encoding & 64) {
#line 260
      fr->af.encsize = 2;
    } else
#line 261
    if (fr->af.encoding & 256) {
#line 262
      fr->af.encsize = 4;
    } else
#line 261
    if (fr->af.encoding == 512) {
#line 262
      fr->af.encsize = 4;
    } else
#line 263
    if (fr->af.encoding == 1024) {
#line 264
      fr->af.encsize = 8;
    } else {
#line 267
      if (! (fr->p.flags & 32L)) {
        {
#line 267
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c:%i] error: Some unknown encoding??? (%i)\n",
                267, fr->af.encoding);
        }
      }
#line 269
      fr->err = 1;
#line 270
      return (-1);
    }
#line 272
    return (1);
  }
}
}
#line 276 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_format_none(mpg123_handle *mh___0 ) 
{ 
  int r ;

  {
#line 279
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 279
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 281
  r = (int )mpg123_fmt_none(& mh___0->p);
  }
#line 282
  if (r != 0) {
#line 282
    mh___0->err = r;
#line 282
    r = -1;
  }
#line 284
  return ((int __attribute__((__force_align_arg_pointer__))  )r);
}
}
#line 287 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_fmt_none(mpg123_pars *mp ) 
{ 
  char *__cil_tmp2 ;

  {
#line 289
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 289
    return ((int __attribute__((__force_align_arg_pointer__))  )25);
  }
#line 291
  if (! (mp->flags & 32L)) {
#line 291
    if (mp->verbose >= 3) {
      {
#line 291
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Disabling all formats.\n");
      }
    }
  }
  {
#line 293
  memset((void *)(mp->audio_caps), 0, (size_t )sizeof(mp->audio_caps));
  }
#line 294
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 297 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_format_all(mpg123_handle *mh___0 ) 
{ 
  int r ;

  {
#line 300
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 300
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 302
  r = (int )mpg123_fmt_all(& mh___0->p);
  }
#line 303
  if (r != 0) {
#line 303
    mh___0->err = r;
#line 303
    r = -1;
  }
#line 305
  return ((int __attribute__((__force_align_arg_pointer__))  )r);
}
}
#line 308 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_fmt_all(mpg123_pars *mp ) 
{ 
  size_t rate ;
  size_t ch ;
  size_t enc ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 311
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 311
    return ((int __attribute__((__force_align_arg_pointer__))  )25);
  }
#line 313
  if (! (mp->flags & 32L)) {
#line 313
    if (mp->verbose >= 3) {
      {
#line 313
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Enabling all formats.\n");
      }
    }
  }
#line 315
  ch = (size_t )0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (ch < 2U)) {
#line 315
      goto while_break;
    }
#line 316
    rate = (size_t )0;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! (rate < 10U)) {
#line 316
        goto while_break___0;
      }
#line 317
      enc = (size_t )0;
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (! (enc < 10U)) {
#line 317
          goto while_break___1;
        }
        {
#line 318
        tmp___0 = good_enc(my_encodings[enc]);
        }
#line 318
        if (tmp___0) {
#line 318
          mp->audio_caps[ch][rate][enc] = (char)1;
        } else {
#line 318
          mp->audio_caps[ch][rate][enc] = (char)0;
        }
#line 317
        enc ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 316
      rate ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 315
    ch ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 323 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_format(mpg123_handle *mh___0 ,
                                                                long rate , int channels ,
                                                                int encodings ) 
{ 
  int r ;

  {
#line 326
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 326
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 327
  r = (int )mpg123_fmt(& mh___0->p, rate, channels, encodings);
  }
#line 328
  if (r != 0) {
#line 328
    mh___0->err = r;
#line 328
    r = -1;
  }
#line 330
  return ((int __attribute__((__force_align_arg_pointer__))  )r);
}
}
#line 333 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_fmt(mpg123_pars *mp , long rate ,
                                                             int channels , int encodings ) 
{ 
  int ie ;
  int ic ;
  int ratei ;
  int ch[2] ;
  int tmp ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 336
  ch[0] = 0;
#line 336
  ch[1] = 1;
#line 337
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 337
    return ((int __attribute__((__force_align_arg_pointer__))  )25);
  }
#line 338
  if (! (channels & 3)) {
#line 338
    return ((int __attribute__((__force_align_arg_pointer__))  )2);
  }
#line 340
  if (! (mp->flags & 32L)) {
#line 340
    if (mp->verbose >= 3) {
      {
#line 340
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Want to enable format %li/%i for encodings 0x%x.\n",
              rate, channels, encodings);
      }
    }
  }
#line 342
  if (! (channels & 2)) {
#line 342
    ch[1] = 0;
  } else
#line 343
  if (! (channels & 1)) {
#line 343
    ch[0] = 1;
  }
  {
#line 344
  ratei = rate2num(mp, rate);
  }
#line 345
  if (ratei < 0) {
#line 345
    return ((int __attribute__((__force_align_arg_pointer__))  )3);
  }
#line 348
  ic = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (ic < 2)) {
#line 348
      goto while_break;
    }
#line 350
    ie = 0;
    {
#line 350
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 350
      if (! (ie < 10)) {
#line 350
        goto while_break___0;
      }
      {
#line 351
      tmp = good_enc(my_encodings[ie]);
      }
#line 351
      if (tmp) {
#line 351
        if ((my_encodings[ie] & (int const   )encodings) == my_encodings[ie]) {
#line 352
          mp->audio_caps[ch[ic]][ratei][ie] = (char)1;
        }
      }
#line 350
      ie ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 354
    if (ch[0] == ch[1]) {
#line 354
      goto while_break;
    }
#line 348
    ic ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 360 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_format_support(mpg123_handle *mh___0 ,
                                                                        long rate ,
                                                                        int encoding ) 
{ 
  int tmp ;

  {
#line 362
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 362
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  } else {
    {
#line 363
    tmp = (int )mpg123_fmt_support(& mh___0->p, rate, encoding);
    }
#line 363
    return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
  }
}
}
#line 366 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_fmt_support(mpg123_pars *mp ,
                                                                     long rate , int encoding ) 
{ 
  int ch ;
  int ratei ;
  int enci ;

  {
  {
#line 368
  ch = 0;
#line 370
  ratei = rate2num(mp, rate);
#line 371
  enci = enc2num(encoding);
  }
#line 372
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 372
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  } else
#line 372
  if (ratei < 0) {
#line 372
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  } else
#line 372
  if (enci < 0) {
#line 372
    return ((int __attribute__((__force_align_arg_pointer__))  )0);
  }
#line 373
  if (mp->audio_caps[0][ratei][enci]) {
#line 373
    ch |= 1;
  }
#line 374
  if (mp->audio_caps[1][ratei][enci]) {
#line 374
    ch |= 2;
  }
#line 375
  return ((int __attribute__((__force_align_arg_pointer__))  )ch);
}
}
#line 379 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
void invalidate_format(struct audioformat *af ) 
{ 


  {
#line 381
  af->encoding = 0;
#line 382
  af->rate = 0L;
#line 383
  af->channels = 0;
#line 384
  return;
}
}
#line 387 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
off_t samples_to_bytes(mpg123_handle *fr , off_t s ) 
{ 


  {
#line 389
  return ((s * (off_t )fr->af.encsize) * (off_t )fr->af.channels);
}
}
#line 392 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/format.c"
off_t bytes_to_samples(mpg123_handle *fr , off_t b ) 
{ 


  {
#line 394
  return ((b / (off_t )fr->af.encsize) / (off_t )fr->af.channels);
}
}
#line 608 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/mpg123.h"
int __attribute__((__force_align_arg_pointer__))  mpg123_reset_eq(mpg123_handle *mh___0 ) ;
#line 612
int __attribute__((__force_align_arg_pointer__))  mpg123_volume(mpg123_handle *mh___0 ,
                                                                double vol ) ;
#line 615
int __attribute__((__force_align_arg_pointer__))  mpg123_volume_change(mpg123_handle *mh___0 ,
                                                                       double change ) ;
#line 621
int __attribute__((__force_align_arg_pointer__))  mpg123_getvolume(mpg123_handle *mh___0 ,
                                                                   double *base ,
                                                                   double *really ,
                                                                   double *rva_db ) ;
#line 683
int __attribute__((__force_align_arg_pointer__))  mpg123_info(mpg123_handle *mh___0 ,
                                                              struct mpg123_frameinfo *mi ) ;
#line 935
mpg123_pars __attribute__((__force_align_arg_pointer__))  *mpg123_new_pars(int *error ) ;
#line 938
void __attribute__((__force_align_arg_pointer__))  mpg123_delete_pars(mpg123_pars *mp ) ;
#line 980
int __attribute__((__force_align_arg_pointer__))  mpg123_replace_buffer(mpg123_handle *mh___0 ,
                                                                        unsigned char *data ,
                                                                        size_t size ) ;
#line 320 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.h"
void frame_init(mpg123_handle *fr ) ;
#line 365
void frame_gapless_init(mpg123_handle *fr , off_t b , off_t e ) ;
#line 391
off_t frame_offset(mpg123_handle *fr , off_t outs ) ;
#line 396
int frame_fill_toc(mpg123_handle *fr , unsigned char *in ) ;
#line 15 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.h"
int frame_bitrate(mpg123_handle *fr ) ;
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
static void frame_fixed_reset(mpg123_handle *fr ) ;
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_default_pars(mpg123_pars *mp ) 
{ 


  {
  {
#line 23
  mp->outscale = 1.0;
#line 25
  mp->flags = 64L;
#line 30
  mp->force_rate = 0L;
#line 32
  mp->down_sample = 0;
#line 33
  mp->rva = 0;
#line 34
  mp->halfspeed = 0L;
#line 35
  mp->doublespeed = 0L;
#line 36
  mp->verbose = 0;
#line 38
  mp->icy_interval = 0L;
#line 40
  mp->timeout = 0L;
#line 41
  mp->resync_limit = 1024L;
#line 43
  mp->index_size = 1000L;
#line 45
  mp->preframes = 4L;
#line 46
  mpg123_fmt_all(mp);
  }
#line 47
  return;
}
}
#line 49 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_init(mpg123_handle *fr ) 
{ 


  {
  {
#line 51
  frame_init_par(fr, (mpg123_pars *)((void *)0));
  }
#line 52
  return;
}
}
#line 54 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_init_par(mpg123_handle *fr , mpg123_pars *mp ) 
{ 


  {
  {
#line 56
  fr->own_buffer = 0;
#line 57
  fr->buffer.data = (unsigned char *)((void *)0);
#line 58
  fr->rawbuffs = (unsigned char *)((void *)0);
#line 59
  fr->rawbuffss = 0;
#line 60
  fr->rawdecwin = (unsigned char *)((void *)0);
#line 61
  fr->rawdecwins = 0;
#line 63
  fr->conv16to8_buf = (unsigned char *)((void *)0);
#line 66
  fr->dithernoise = (float *)((void *)0);
#line 68
  fr->layerscratch = (float *)((void *)0);
#line 69
  fr->xing_toc = (unsigned char *)((void *)0);
#line 70
  fr->cpu_opts.type = defdec();
#line 71
  fr->cpu_opts.class = decclass((enum optdec  const  )fr->cpu_opts.type);
#line 74
  fr->ntom_val[0] = (unsigned long )(32768 >> 1);
#line 75
  fr->ntom_val[1] = (unsigned long )(32768 >> 1);
#line 76
  fr->ntom_step = 32768UL;
#line 79
  mpg123_reset_eq(fr);
#line 80
  init_icy(& fr->icy);
#line 81
  init_id3(fr);
#line 85
  invalidate_format(& fr->af);
#line 86
  fr->rdat.r_read = (ssize_t (*)(int fd , void *buf , size_t count ))((void *)0);
#line 87
  fr->rdat.r_lseek = (off_t (*)(int fd , off_t offset , int whence ))((void *)0);
#line 88
  fr->rdat.iohandle = (void *)0;
#line 89
  fr->rdat.r_read_handle = (ssize_t (*)(void *handle , void *buf , size_t count ))((void *)0);
#line 90
  fr->rdat.r_lseek_handle = (off_t (*)(void *handle , off_t offset , int whence ))((void *)0);
#line 91
  fr->rdat.cleanup_handle = (void (*)(void *handle ))((void *)0);
#line 92
  fr->wrapperdata = (void *)0;
#line 93
  fr->wrapperclean = (void (*)(void * ))((void *)0);
#line 94
  fr->decoder_change = 1;
#line 95
  fr->err = 0;
  }
#line 96
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
    {
#line 96
    frame_default_pars(& fr->p);
    }
  } else {
    {
#line 97
    memcpy((void */* __restrict  */)(& fr->p), (void const   */* __restrict  */)mp,
           (size_t )sizeof(struct mpg123_pars_struct ));
    }
  }
  {
#line 99
  fr->down_sample = 0;
#line 100
  frame_fixed_reset(fr);
#line 101
  fr->synth = (int (*)(float * , int  , mpg123_handle * , int  ))((void *)0);
#line 102
  fr->synth_mono = (int (*)(float * , mpg123_handle * ))((void *)0);
#line 103
  fr->make_decode_tables = (void (*)(mpg123_handle *fr ))((void *)0);
#line 105
  fi_init(& fr->index);
#line 106
  frame_index_setup(fr);
  }
#line 108
  return;
}
}
#line 113 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int frame_dither_init(mpg123_handle *fr ) 
{ 
  void *tmp ;

  {
#line 116
  if ((unsigned long )fr->dithernoise == (unsigned long )((void *)0)) {
    {
#line 118
    tmp = malloc((size_t )(sizeof(float ) * 65536UL));
#line 118
    fr->dithernoise = (float *)tmp;
    }
#line 119
    if ((unsigned long )fr->dithernoise == (unsigned long )((void *)0)) {
#line 119
      return (0);
    }
    {
#line 121
    dither_table_init(fr->dithernoise);
    }
  }
#line 123
  return (1);
}
}
#line 127 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
mpg123_pars __attribute__((__force_align_arg_pointer__))  *mpg123_new_pars(int *error ) 
{ 
  mpg123_pars *mp ;
  void *tmp ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 129
  tmp = malloc((size_t )sizeof(struct mpg123_pars_struct ));
#line 129
  mp = (mpg123_pars *)tmp;
  }
#line 130
  if ((unsigned long )mp != (unsigned long )((void *)0)) {
    {
#line 130
    frame_default_pars(mp);
    }
#line 130
    if ((unsigned long )error != (unsigned long )((void *)0)) {
#line 130
      *error = 0;
    }
  } else
#line 131
  if ((unsigned long )error != (unsigned long )((void *)0)) {
#line 131
    *error = 7;
  }
#line 132
  return ((mpg123_pars __attribute__((__force_align_arg_pointer__))  *)mp);
}
}
#line 135 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void __attribute__((__force_align_arg_pointer__))  mpg123_delete_pars(mpg123_pars *mp ) 
{ 


  {
#line 137
  if ((unsigned long )mp != (unsigned long )((void *)0)) {
    {
#line 137
    free((void *)mp);
    }
  }
#line 138
  return;
}
}
#line 140 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_reset_eq(mpg123_handle *mh___0 ) 
{ 
  int i ;
  float tmp ;

  {
#line 143
  mh___0->have_eq_settings = 0;
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < 32)) {
#line 144
      goto while_break;
    }
#line 144
    tmp = (float )1.0;
#line 144
    mh___0->equalizer[1][i] = tmp;
#line 144
    mh___0->equalizer[0][i] = tmp;
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 149 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int frame_outbuffer(mpg123_handle *fr ) 
{ 
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 151
  tmp = (size_t )mpg123_safe_buffer();
#line 151
  size = tmp * 2U;
  }
#line 152
  if (! fr->own_buffer) {
#line 152
    fr->buffer.data = (unsigned char *)((void *)0);
  }
#line 153
  if ((unsigned long )fr->buffer.data != (unsigned long )((void *)0)) {
#line 153
    if (fr->buffer.size != size) {
      {
#line 155
      free((void *)fr->buffer.data);
#line 156
      fr->buffer.data = (unsigned char *)((void *)0);
      }
    }
  }
#line 158
  fr->buffer.size = size;
#line 159
  if ((unsigned long )fr->buffer.data == (unsigned long )((void *)0)) {
    {
#line 159
    tmp___0 = malloc(fr->buffer.size);
#line 159
    fr->buffer.data = (unsigned char *)tmp___0;
    }
  }
#line 160
  if ((unsigned long )fr->buffer.data == (unsigned long )((void *)0)) {
#line 162
    fr->err = 7;
#line 163
    return (-1);
  }
#line 165
  fr->own_buffer = 1;
#line 166
  fr->buffer.fill = (size_t )0;
#line 167
  return (0);
}
}
#line 170 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_replace_buffer(mpg123_handle *mh___0 ,
                                                                        unsigned char *data ,
                                                                        size_t size ) 
{ 
  size_t tmp ;

  {
#line 172
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 174
    mh___0->err = 6;
#line 175
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  } else {
    {
#line 172
    tmp = (size_t )mpg123_safe_buffer();
    }
#line 172
    if (size < tmp) {
#line 174
      mh___0->err = 6;
#line 175
      return ((int __attribute__((__force_align_arg_pointer__))  )-1);
    }
  }
#line 177
  if (mh___0->own_buffer) {
#line 177
    if ((unsigned long )mh___0->buffer.data != (unsigned long )((void *)0)) {
      {
#line 177
      free((void *)mh___0->buffer.data);
      }
    }
  }
#line 178
  mh___0->own_buffer = 0;
#line 179
  mh___0->buffer.data = data;
#line 180
  mh___0->buffer.size = size;
#line 181
  mh___0->buffer.fill = (size_t )0;
#line 182
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 186 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int frame_index_setup(mpg123_handle *fr ) 
{ 
  int ret ;

  {
#line 188
  ret = -1;
#line 189
  if (fr->p.index_size >= 0L) {
    {
#line 191
    fr->index.grow_size = (size_t )0;
#line 193
    ret = fi_resize(& fr->index, (size_t )fr->p.index_size);
    }
  } else {
#line 198
    fr->index.grow_size = (size_t )(- fr->p.index_size);
#line 199
    if (fr->index.size < fr->index.grow_size) {
      {
#line 200
      ret = fi_resize(& fr->index, fr->index.grow_size);
      }
    } else {
#line 202
      ret = 0;
    }
  }
#line 206
  return (ret);
}
}
#line 210 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
static void frame_decode_buffers_reset(mpg123_handle *fr ) 
{ 


  {
  {
#line 212
  memset((void *)fr->rawbuffs, 0, (size_t )fr->rawbuffss);
  }
#line 213
  return;
}
}
#line 215 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int frame_buffers(mpg123_handle *fr ) 
{ 
  int buffssize ;
  void *tmp ;
  int decwin_size ;
  void *tmp___0 ;
  size_t scratchsize ;
  float *scratcher ;
  void *tmp___1 ;

  {
#line 217
  buffssize = 0;
#line 234
  if ((unsigned int )fr->cpu_opts.type == 10U) {
#line 234
    buffssize = (int )(4352UL * sizeof(float ));
  } else
#line 238
  if ((unsigned int )fr->cpu_opts.type == 5U) {
#line 239
    buffssize = 4352;
  } else
#line 238
  if ((unsigned int )fr->cpu_opts.type == 6U) {
#line 239
    buffssize = 4352;
  } else
#line 238
  if ((unsigned int )fr->cpu_opts.type == 8U) {
#line 239
    buffssize = 4352;
  }
#line 241
  if (1088UL * sizeof(float ) > (unsigned long )buffssize) {
#line 242
    buffssize = (int )(1088UL * sizeof(float ));
  }
#line 243
  buffssize += 15;
#line 245
  if ((unsigned long )fr->rawbuffs != (unsigned long )((void *)0)) {
#line 245
    if (fr->rawbuffss != buffssize) {
      {
#line 247
      free((void *)fr->rawbuffs);
#line 248
      fr->rawbuffs = (unsigned char *)((void *)0);
      }
    }
  }
#line 251
  if ((unsigned long )fr->rawbuffs == (unsigned long )((void *)0)) {
    {
#line 251
    tmp = malloc((size_t )buffssize);
#line 251
    fr->rawbuffs = (unsigned char *)tmp;
    }
  }
#line 252
  if ((unsigned long )fr->rawbuffs == (unsigned long )((void *)0)) {
#line 252
    return (-1);
  }
#line 253
  fr->rawbuffss = buffssize;
#line 254
  if (((char *)fr->rawbuffs - (char *)((void *)0)) % 16L) {
#line 254
    fr->short_buffs[0][0] = (short *)(((char *)fr->rawbuffs + 16) - ((char *)fr->rawbuffs - (char *)((void *)0)) % 16L);
  } else {
#line 254
    fr->short_buffs[0][0] = (short *)fr->rawbuffs;
  }
#line 255
  fr->short_buffs[0][1] = fr->short_buffs[0][0] + 272;
#line 256
  fr->short_buffs[1][0] = fr->short_buffs[0][1] + 272;
#line 257
  fr->short_buffs[1][1] = fr->short_buffs[1][0] + 272;
#line 258
  if (((char *)fr->rawbuffs - (char *)((void *)0)) % 16L) {
#line 258
    fr->real_buffs[0][0] = (float *)(((char *)fr->rawbuffs + 16) - ((char *)fr->rawbuffs - (char *)((void *)0)) % 16L);
  } else {
#line 258
    fr->real_buffs[0][0] = (float *)fr->rawbuffs;
  }
#line 259
  fr->real_buffs[0][1] = fr->real_buffs[0][0] + 272;
#line 260
  fr->real_buffs[1][0] = fr->real_buffs[0][1] + 272;
#line 261
  fr->real_buffs[1][1] = fr->real_buffs[1][0] + 272;
#line 283
  decwin_size = (int )(544UL * sizeof(float ));
#line 286
  if ((unsigned int )fr->cpu_opts.class == 2U) {
#line 290
    if (decwin_size < 2176) {
#line 290
      decwin_size = 2176;
    }
#line 294
    decwin_size += 2239;
  }
#line 305
  if ((unsigned long )fr->rawdecwin != (unsigned long )((void *)0)) {
#line 305
    if (fr->rawdecwins != decwin_size) {
      {
#line 307
      free((void *)fr->rawdecwin);
#line 308
      fr->rawdecwin = (unsigned char *)((void *)0);
      }
    }
  }
#line 311
  if ((unsigned long )fr->rawdecwin == (unsigned long )((void *)0)) {
    {
#line 312
    tmp___0 = malloc((size_t )decwin_size);
#line 312
    fr->rawdecwin = (unsigned char *)tmp___0;
    }
  }
#line 314
  if ((unsigned long )fr->rawdecwin == (unsigned long )((void *)0)) {
#line 314
    return (-1);
  }
#line 316
  fr->rawdecwins = decwin_size;
#line 317
  fr->decwin = (float *)fr->rawdecwin;
#line 320
  if ((unsigned int )fr->cpu_opts.class == 2U) {
#line 325
    if (((char *)fr->rawdecwin - (char *)((void *)0)) % 64L) {
#line 325
      fr->decwin = (float *)(((char *)fr->rawdecwin + 64) - ((char *)fr->rawdecwin - (char *)((void *)0)) % 64L);
    } else {
#line 325
      fr->decwin = (float *)fr->rawdecwin;
    }
#line 327
    fr->decwin_mmx = fr->decwin;
#line 328
    fr->decwins = (fr->decwin_mmx + 512) + 32;
  }
#line 337
  if ((unsigned long )fr->layerscratch == (unsigned long )((void *)0)) {
    {
#line 340
    scratchsize = (size_t )0;
#line 343
    scratchsize = (size_t )((unsigned long )scratchsize + (sizeof(float ) * 2UL) * 32UL);
#line 346
    scratchsize = (size_t )((unsigned long )scratchsize + ((sizeof(float ) * 2UL) * 4UL) * 32UL);
#line 349
    scratchsize = (size_t )((unsigned long )scratchsize + ((sizeof(float ) * 2UL) * 32UL) * 18UL);
#line 350
    scratchsize = (size_t )((unsigned long )scratchsize + ((sizeof(float ) * 2UL) * 18UL) * 32UL);
#line 356
    tmp___1 = malloc(scratchsize + 63U);
#line 356
    fr->layerscratch = (float *)tmp___1;
    }
#line 357
    if ((unsigned long )fr->layerscratch == (unsigned long )((void *)0)) {
#line 357
      return (-1);
    }
#line 360
    if (((char *)fr->layerscratch - (char *)((void *)0)) % 64L) {
#line 360
      scratcher = (float *)(((char *)fr->layerscratch + 64) - ((char *)fr->layerscratch - (char *)((void *)0)) % 64L);
    } else {
#line 360
      scratcher = fr->layerscratch;
    }
#line 364
    fr->layer1.fraction = (float (*)[32])scratcher;
#line 365
    scratcher += 64;
#line 368
    fr->layer2.fraction = (float (*)[4][32])scratcher;
#line 369
    scratcher += 256;
#line 372
    fr->layer3.hybrid_in = (float (*)[32][18])scratcher;
#line 373
    scratcher += 1152;
#line 374
    fr->layer3.hybrid_out = (float (*)[18][32])scratcher;
#line 375
    scratcher += 1152;
  }
  {
#line 381
  frame_decode_buffers_reset(fr);
  }
#line 384
  return (0);
}
}
#line 387 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int frame_buffers_reset(mpg123_handle *fr ) 
{ 
  int tmp ;

  {
  {
#line 389
  fr->buffer.fill = (size_t )0;
#line 390
  fr->bsnum = 0;
#line 392
  fr->bsbuf = fr->bsspace[1];
#line 393
  fr->bsbufold = fr->bsbuf;
#line 394
  fr->bitreservoir = 0U;
#line 395
  frame_decode_buffers_reset(fr);
#line 396
  memset((void *)(fr->bsspace), 0, (size_t )7936);
#line 397
  memset((void *)(fr->ssave), 0, (size_t )34);
#line 398
  tmp = 0;
#line 398
  fr->hybrid_blc[1] = tmp;
#line 398
  fr->hybrid_blc[0] = tmp;
#line 399
  memset((void *)(fr->hybrid_block), 0, (size_t )((((sizeof(float ) * 2UL) * 2UL) * 32UL) * 18UL));
  }
#line 400
  return (0);
}
}
#line 403 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_icy_reset(mpg123_handle *fr ) 
{ 


  {
#line 406
  if ((unsigned long )fr->icy.data != (unsigned long )((void *)0)) {
    {
#line 406
    free((void *)fr->icy.data);
    }
  }
#line 407
  fr->icy.data = (char *)((void *)0);
#line 408
  fr->icy.interval = (off_t )0;
#line 409
  fr->icy.next = (off_t )0;
#line 411
  return;
}
}
#line 413 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_free_toc(mpg123_handle *fr ) 
{ 


  {
#line 415
  if ((unsigned long )fr->xing_toc != (unsigned long )((void *)0)) {
    {
#line 415
    free((void *)fr->xing_toc);
#line 415
    fr->xing_toc = (unsigned char *)((void *)0);
    }
  }
#line 416
  return;
}
}
#line 419 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int frame_fill_toc(mpg123_handle *fr , unsigned char *in ) 
{ 
  void *tmp ;

  {
#line 421
  if ((unsigned long )fr->xing_toc == (unsigned long )((void *)0)) {
    {
#line 421
    tmp = malloc((size_t )100);
#line 421
    fr->xing_toc = (unsigned char *)tmp;
    }
  }
#line 422
  if ((unsigned long )fr->xing_toc != (unsigned long )((void *)0)) {
    {
#line 424
    memcpy((void */* __restrict  */)fr->xing_toc, (void const   */* __restrict  */)in,
           (size_t )100);
    }
#line 433
    return (1);
  }
#line 435
  return (0);
}
}
#line 440 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int frame_reset(mpg123_handle *fr ) 
{ 


  {
  {
#line 442
  frame_buffers_reset(fr);
#line 443
  frame_fixed_reset(fr);
#line 444
  frame_free_toc(fr);
#line 446
  fi_reset(& fr->index);
  }
#line 449
  return (0);
}
}
#line 453 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
static void frame_fixed_reset(mpg123_handle *fr ) 
{ 


  {
  {
#line 455
  frame_icy_reset(fr);
#line 456
  open_bad(fr);
#line 457
  fr->to_decode = 0;
#line 458
  fr->to_ignore = 0;
#line 459
  fr->metaflags = 0;
#line 460
  fr->outblock = (size_t )mpg123_safe_buffer();
#line 461
  fr->num = (off_t )-1;
#line 462
  fr->playnum = (off_t )-1;
#line 463
  fr->accurate = (char)1;
#line 464
  fr->silent_resync = (char)0;
#line 465
  fr->audio_start = (off_t )0;
#line 466
  fr->clip = 0L;
#line 467
  fr->oldhead = 0UL;
#line 468
  fr->firsthead = 0UL;
#line 469
  fr->vbr = (enum mpg123_vbr )0;
#line 470
  fr->abr_rate = 0;
#line 471
  fr->track_frames = (off_t )0;
#line 472
  fr->track_samples = (off_t )-1;
#line 473
  fr->framesize = 0;
#line 474
  fr->mean_frames = (off_t )0;
#line 475
  fr->mean_framesize = (double )0;
#line 476
  fr->freesize = 0;
#line 477
  fr->lastscale = (double )-1;
#line 478
  fr->rva.level[0] = -1;
#line 479
  fr->rva.level[1] = -1;
#line 480
  fr->rva.gain[0] = (float )0;
#line 481
  fr->rva.gain[1] = (float )0;
#line 482
  fr->rva.peak[0] = (float )0;
#line 483
  fr->rva.peak[1] = (float )0;
#line 484
  fr->fsizeold = 0;
#line 485
  fr->firstframe = (off_t )0;
#line 486
  fr->ignoreframe = fr->firstframe - (off_t )fr->p.preframes;
#line 487
  fr->lastframe = (off_t )-1;
#line 488
  fr->fresh = 1;
#line 489
  fr->new_format = 0;
#line 491
  frame_gapless_init(fr, (off_t )0, (off_t )0);
#line 492
  fr->lastoff = (off_t )0;
#line 493
  fr->firstoff = (off_t )0;
#line 498
  fr->bo = 1;
#line 500
  fr->ditherindex = 0;
#line 502
  reset_id3(fr);
#line 503
  reset_icy(& fr->icy);
#line 506
  fr->icy.interval = (off_t )0;
#line 507
  fr->icy.next = (off_t )0;
#line 509
  fr->halfphase = 0;
#line 510
  fr->error_protection = 0;
#line 511
  fr->freeformat_framesize = -1L;
  }
#line 512
  return;
}
}
#line 514 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_free_buffers(mpg123_handle *fr ) 
{ 


  {
#line 516
  if ((unsigned long )fr->rawbuffs != (unsigned long )((void *)0)) {
    {
#line 516
    free((void *)fr->rawbuffs);
    }
  }
#line 517
  fr->rawbuffs = (unsigned char *)((void *)0);
#line 518
  fr->rawbuffss = 0;
#line 519
  if ((unsigned long )fr->rawdecwin != (unsigned long )((void *)0)) {
    {
#line 519
    free((void *)fr->rawdecwin);
    }
  }
#line 520
  fr->rawdecwin = (unsigned char *)((void *)0);
#line 521
  fr->rawdecwins = 0;
#line 523
  if ((unsigned long )fr->conv16to8_buf != (unsigned long )((void *)0)) {
    {
#line 523
    free((void *)fr->conv16to8_buf);
    }
  }
#line 524
  fr->conv16to8_buf = (unsigned char *)((void *)0);
#line 526
  if ((unsigned long )fr->layerscratch != (unsigned long )((void *)0)) {
    {
#line 526
    free((void *)fr->layerscratch);
    }
  }
#line 527
  return;
}
}
#line 529 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_exit(mpg123_handle *fr ) 
{ 


  {
#line 531
  if (fr->own_buffer) {
#line 531
    if ((unsigned long )fr->buffer.data != (unsigned long )((void *)0)) {
      {
#line 534
      free((void *)fr->buffer.data);
      }
    }
  }
  {
#line 536
  fr->buffer.data = (unsigned char *)((void *)0);
#line 537
  frame_free_buffers(fr);
#line 538
  frame_free_toc(fr);
#line 540
  fi_exit(& fr->index);
  }
#line 543
  if ((unsigned long )fr->dithernoise != (unsigned long )((void *)0)) {
    {
#line 545
    free((void *)fr->dithernoise);
#line 546
    fr->dithernoise = (float *)((void *)0);
    }
  }
  {
#line 549
  exit_id3(fr);
#line 550
  clear_icy(& fr->icy);
  }
#line 552
  if ((unsigned long )fr->wrapperclean != (unsigned long )((void *)0)) {
    {
#line 554
    (*(fr->wrapperclean))(fr->wrapperdata);
#line 555
    fr->wrapperdata = (void *)0;
    }
  }
#line 557
  return;
}
}
#line 559 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_info(mpg123_handle *mh___0 ,
                                                              struct mpg123_frameinfo *mi ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;

  {
#line 561
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 561
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 562
  if ((unsigned long )mi == (unsigned long )((void *)0)) {
#line 564
    mh___0->err = 17;
#line 565
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 567
  if (mh___0->mpeg25) {
#line 567
    mi->version = (enum mpg123_version )2;
  } else {
#line 567
    if (mh___0->lsf) {
#line 567
      tmp = 1;
    } else {
#line 567
      tmp = 0;
    }
#line 567
    mi->version = (enum mpg123_version )tmp;
  }
  {
#line 568
  mi->layer = mh___0->lay;
#line 569
  mi->rate = frame_freq(mh___0);
  }
  {
#line 572
  if (mh___0->mode == 0) {
#line 572
    goto case_0;
  }
#line 573
  if (mh___0->mode == 1) {
#line 573
    goto case_1;
  }
#line 574
  if (mh___0->mode == 2) {
#line 574
    goto case_2;
  }
#line 575
  if (mh___0->mode == 3) {
#line 575
    goto case_3;
  }
#line 576
  goto switch_default;
  case_0: /* CIL Label */ 
#line 572
  mi->mode = (enum mpg123_mode )0;
#line 572
  goto switch_break;
  case_1: /* CIL Label */ 
#line 573
  mi->mode = (enum mpg123_mode )1;
#line 573
  goto switch_break;
  case_2: /* CIL Label */ 
#line 574
  mi->mode = (enum mpg123_mode )2;
#line 574
  goto switch_break;
  case_3: /* CIL Label */ 
#line 575
  mi->mode = (enum mpg123_mode )3;
#line 575
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 576
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c:%i] error: That mode cannot be!\n",
          576);
  }
  switch_break: /* CIL Label */ ;
  }
#line 578
  mi->mode_ext = mh___0->mode_ext;
#line 579
  mi->framesize = mh___0->framesize + 4;
#line 580
  mi->flags = (enum mpg123_flags )0;
#line 581
  if (mh___0->error_protection) {
#line 581
    mi->flags = (enum mpg123_flags )((unsigned int )mi->flags | 1U);
  }
#line 582
  if (mh___0->copyright) {
#line 582
    mi->flags = (enum mpg123_flags )((unsigned int )mi->flags | 2U);
  }
#line 583
  if (mh___0->extension) {
#line 583
    mi->flags = (enum mpg123_flags )((unsigned int )mi->flags | 4U);
  }
#line 584
  if (mh___0->original) {
#line 584
    mi->flags = (enum mpg123_flags )((unsigned int )mi->flags | 8U);
  }
  {
#line 585
  mi->emphasis = mh___0->emphasis;
#line 586
  mi->bitrate = frame_bitrate(mh___0);
#line 587
  mi->abr_rate = mh___0->abr_rate;
#line 588
  mi->vbr = mh___0->vbr;
  }
#line 589
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 601 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
off_t frame_fuzzy_find(mpg123_handle *fr , off_t want_frame , off_t *get_frame ) 
{ 
  off_t ret ;
  int toc_entry ;

  {
#line 604
  ret = fr->audio_start;
#line 605
  *get_frame = (off_t )0;
#line 611
  if ((unsigned long )fr->xing_toc != (unsigned long )((void *)0)) {
#line 611
    if (fr->track_frames > 0LL) {
#line 611
      if (fr->rdat.filelen > 0LL) {
#line 614
        toc_entry = (int )(((double )want_frame * 100.) / (double )fr->track_frames);
#line 616
        if (toc_entry < 0) {
#line 616
          toc_entry = 0;
        }
#line 617
        if (toc_entry > 99) {
#line 617
          toc_entry = 99;
        }
#line 620
        *get_frame = (off_t )(((double )toc_entry / 100.) * (double )fr->track_frames);
#line 621
        fr->accurate = (char)0;
#line 622
        fr->silent_resync = (char)1;
#line 625
        ret = (off_t )(((double )*(fr->xing_toc + toc_entry) / 256.) * (double )fr->rdat.filelen);
      } else {
#line 611
        goto _L___0;
      }
    } else {
#line 611
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 627
  if (fr->mean_framesize > (double )0) {
#line 630
    fr->accurate = (char)0;
#line 631
    fr->silent_resync = (char)1;
#line 632
    *get_frame = want_frame;
#line 633
    ret = (off_t )((double )fr->audio_start + fr->mean_framesize * (double )want_frame);
  }
#line 637
  return (ret);
}
}
#line 649 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
off_t frame_index_find(mpg123_handle *fr , off_t want_frame , off_t *get_frame ) 
{ 
  off_t gopos ;
  size_t fi ;
  off_t tmp ;

  {
#line 652
  gopos = (off_t )0;
#line 653
  *get_frame = (off_t )0;
#line 656
  if (fr->index.fill) {
#line 661
    fi = (size_t )(want_frame / fr->index.step);
#line 662
    if (fi >= fr->index.fill) {
#line 665
      if (fr->p.flags & 512L) {
#line 665
        if (want_frame - (off_t )(fr->index.fill - 1U) * fr->index.step > 10LL) {
          {
#line 667
          gopos = frame_fuzzy_find(fr, want_frame, get_frame);
          }
#line 668
          if (gopos > fr->audio_start) {
#line 668
            return (gopos);
          }
        }
      }
#line 672
      fi = fr->index.fill - 1U;
    }
#line 675
    *get_frame = (off_t )fi * fr->index.step;
#line 676
    gopos = *(fr->index.data + fi);
#line 677
    fr->accurate = (char)1;
  } else {
#line 682
    if (fr->p.flags & 512L) {
      {
#line 683
      tmp = frame_fuzzy_find(fr, want_frame, get_frame);
      }
#line 683
      return (tmp);
    }
#line 685
    fr->firsthead = 0UL;
#line 686
    fr->oldhead = 0UL;
  }
#line 691
  return (gopos);
}
}
#line 694 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
off_t frame_ins2outs(mpg123_handle *fr , off_t ins ) 
{ 
  off_t outs ;
  char *__cil_tmp4 ;

  {
#line 696
  outs = (off_t )0;
  {
#line 702
  if (fr->down_sample == 2) {
#line 702
    goto case_2;
  }
#line 702
  if (fr->down_sample == 1) {
#line 702
    goto case_2;
  }
#line 702
  if (fr->down_sample == 0) {
#line 702
    goto case_2;
  }
#line 707
  if (fr->down_sample == 3) {
#line 707
    goto case_3;
  }
#line 709
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 704
  outs = ins >> fr->down_sample;
#line 705
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 707
  outs = ntom_ins2outs(fr, ins);
  }
#line 707
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 709
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... should not be possible!!\n",
          709, fr->down_sample);
  }
  switch_break: /* CIL Label */ ;
  }
#line 711
  return (outs);
}
}
#line 714 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
off_t frame_outs(mpg123_handle *fr , off_t num ) 
{ 
  off_t outs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 716
  outs = (off_t )0;
  {
#line 722
  if (fr->down_sample == 2) {
#line 722
    goto case_2;
  }
#line 722
  if (fr->down_sample == 1) {
#line 722
    goto case_2;
  }
#line 722
  if (fr->down_sample == 0) {
#line 722
    goto case_2;
  }
#line 727
  if (fr->down_sample == 3) {
#line 727
    goto case_3;
  }
#line 729
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 724
  if (fr->lay == 1) {
#line 724
    tmp___1 = 384;
  } else {
#line 724
    if (fr->lay == 2) {
#line 724
      tmp___0 = 1152;
    } else {
#line 724
      if (fr->lsf) {
#line 724
        tmp = 576;
      } else
#line 724
      if (fr->mpeg25) {
#line 724
        tmp = 576;
      } else {
#line 724
        tmp = 1152;
      }
#line 724
      tmp___0 = tmp;
    }
#line 724
    tmp___1 = tmp___0;
  }
#line 724
  outs = (off_t )(tmp___1 >> fr->down_sample) * num;
#line 725
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 727
  outs = ntom_frmouts(fr, num);
  }
#line 727
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 729
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... should not be possible!!\n",
          729, fr->down_sample);
  }
  switch_break: /* CIL Label */ ;
  }
#line 731
  return (outs);
}
}
#line 736 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
off_t frame_expect_outsamples(mpg123_handle *fr ) 
{ 
  off_t outs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 738
  outs = (off_t )0;
  {
#line 744
  if (fr->down_sample == 2) {
#line 744
    goto case_2;
  }
#line 744
  if (fr->down_sample == 1) {
#line 744
    goto case_2;
  }
#line 744
  if (fr->down_sample == 0) {
#line 744
    goto case_2;
  }
#line 749
  if (fr->down_sample == 3) {
#line 749
    goto case_3;
  }
#line 751
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 746
  if (fr->lay == 1) {
#line 746
    tmp___1 = 384;
  } else {
#line 746
    if (fr->lay == 2) {
#line 746
      tmp___0 = 1152;
    } else {
#line 746
      if (fr->lsf) {
#line 746
        tmp = 576;
      } else
#line 746
      if (fr->mpeg25) {
#line 746
        tmp = 576;
      } else {
#line 746
        tmp = 1152;
      }
#line 746
      tmp___0 = tmp;
    }
#line 746
    tmp___1 = tmp___0;
  }
#line 746
  outs = (off_t )(tmp___1 >> fr->down_sample);
#line 747
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 749
  outs = ntom_frame_outsamples(fr);
  }
#line 749
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 751
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c:%i] error: Bad down_sample (%i) ... should not be possible!!\n",
          751, fr->down_sample);
  }
  switch_break: /* CIL Label */ ;
  }
#line 753
  return (outs);
}
}
#line 756 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
off_t frame_offset(mpg123_handle *fr , off_t outs ) 
{ 
  off_t num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 758
  num = (off_t )0;
  {
#line 764
  if (fr->down_sample == 2) {
#line 764
    goto case_2;
  }
#line 764
  if (fr->down_sample == 1) {
#line 764
    goto case_2;
  }
#line 764
  if (fr->down_sample == 0) {
#line 764
    goto case_2;
  }
#line 769
  if (fr->down_sample == 3) {
#line 769
    goto case_3;
  }
#line 771
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 766
  if (fr->lay == 1) {
#line 766
    tmp___1 = 384;
  } else {
#line 766
    if (fr->lay == 2) {
#line 766
      tmp___0 = 1152;
    } else {
#line 766
      if (fr->lsf) {
#line 766
        tmp = 576;
      } else
#line 766
      if (fr->mpeg25) {
#line 766
        tmp = 576;
      } else {
#line 766
        tmp = 1152;
      }
#line 766
      tmp___0 = tmp;
    }
#line 766
    tmp___1 = tmp___0;
  }
#line 766
  num = outs / (off_t )(tmp___1 >> fr->down_sample);
#line 767
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 769
  num = ntom_frameoff(fr, outs);
  }
#line 769
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 771
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c:%i] error: Bad down_sample ... should not be possible!!\n",
          771);
  }
  switch_break: /* CIL Label */ ;
  }
#line 773
  return (num);
}
}
#line 778 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_gapless_init(mpg123_handle *fr , off_t b , off_t e ) 
{ 


  {
#line 780
  fr->begin_s = b;
#line 781
  fr->end_s = e;
#line 783
  fr->begin_os = (off_t )0;
#line 784
  fr->end_os = (off_t )0;
#line 786
  return;
}
}
#line 788 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_gapless_realinit(mpg123_handle *fr ) 
{ 


  {
  {
#line 790
  fr->begin_os = frame_ins2outs(fr, fr->begin_s);
#line 791
  fr->end_os = frame_ins2outs(fr, fr->end_s);
  }
#line 793
  return;
}
}
#line 796 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_gapless_update(mpg123_handle *fr , off_t total_samples ) 
{ 
  char *__cil_tmp3 ;

  {
#line 798
  if (fr->end_s < 1LL) {
    {
#line 800
    fr->end_s = total_samples;
#line 801
    frame_gapless_realinit(fr);
    }
  } else
#line 803
  if (fr->end_s > total_samples) {
#line 805
    if (! (fr->p.flags & 32L)) {
      {
#line 805
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c:%i] error: end sample count smaller than gapless end! (%lli < %lli).\n",
              805, total_samples, fr->end_s);
      }
    }
    {
#line 807
    fr->end_s = (off_t )0;
#line 808
    frame_gapless_realinit(fr);
#line 809
    fr->lastframe = (off_t )-1;
#line 810
    fr->lastoff = (off_t )0;
    }
  }
#line 812
  return;
}
}
#line 817 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
static off_t ignoreframe(mpg123_handle *fr ) 
{ 
  off_t preshift ;

  {
#line 819
  preshift = (off_t )fr->p.preframes;
#line 821
  if (fr->lay == 3) {
#line 821
    if (preshift < 1LL) {
#line 821
      preshift = (off_t )1;
    }
  }
#line 823
  if (fr->lay != 3) {
#line 823
    if (preshift > 2LL) {
#line 823
      preshift = (off_t )2;
    }
  }
#line 825
  return (fr->firstframe - preshift);
}
}
#line 832 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_set_frameseek(mpg123_handle *fr , off_t fe ) 
{ 
  off_t beg_f ;
  off_t tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  off_t tmp___2 ;

  {
#line 834
  fr->firstframe = fe;
#line 836
  if (fr->p.flags & 64L) {
    {
#line 839
    tmp = frame_offset(fr, fr->begin_os);
#line 839
    beg_f = tmp;
    }
#line 840
    if (fe <= beg_f) {
      {
#line 842
      fr->firstframe = beg_f;
#line 843
      tmp___0 = frame_outs(fr, beg_f);
#line 843
      fr->firstoff = fr->begin_os - tmp___0;
      }
    } else {
#line 845
      fr->firstoff = (off_t )0;
    }
#line 847
    if (fr->end_os > 0LL) {
      {
#line 849
      fr->lastframe = frame_offset(fr, fr->end_os);
#line 850
      tmp___1 = frame_outs(fr, fr->lastframe);
#line 850
      fr->lastoff = fr->end_os - tmp___1;
      }
    } else {
#line 851
      fr->lastoff = (off_t )0;
    }
  } else {
#line 852
    tmp___2 = (off_t )0;
#line 852
    fr->lastoff = tmp___2;
#line 852
    fr->firstoff = tmp___2;
#line 852
    fr->lastframe = (off_t )-1;
  }
  {
#line 854
  fr->ignoreframe = ignoreframe(fr);
  }
#line 863
  return;
}
}
#line 865 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_skip(mpg123_handle *fr ) 
{ 


  {
#line 868
  if (fr->lay == 3) {
    {
#line 868
    set_pointer(fr, 512L);
    }
  }
#line 870
  return;
}
}
#line 874 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void frame_set_seek(mpg123_handle *fr , off_t sp ) 
{ 
  off_t tmp ;

  {
  {
#line 876
  fr->firstframe = frame_offset(fr, sp);
  }
#line 878
  if (fr->down_sample == 3) {
    {
#line 878
    ntom_set_ntom(fr, fr->firstframe);
    }
  }
  {
#line 880
  fr->ignoreframe = ignoreframe(fr);
#line 882
  tmp = frame_outs(fr, fr->firstframe);
#line 882
  fr->firstoff = sp - tmp;
#line 891
  fr->bitreservoir = 0U;
  }
#line 892
  return;
}
}
#line 894 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_volume_change(mpg123_handle *mh___0 ,
                                                                       double change ) 
{ 
  int tmp ;

  {
#line 896
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 896
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 897
  tmp = (int )mpg123_volume(mh___0, change + mh___0->p.outscale);
  }
#line 897
  return ((int __attribute__((__force_align_arg_pointer__))  )tmp);
}
}
#line 900 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_volume(mpg123_handle *mh___0 ,
                                                                double vol ) 
{ 


  {
#line 902
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 902
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 904
  if (vol >= (double )0) {
#line 904
    mh___0->p.outscale = vol;
  } else {
#line 905
    mh___0->p.outscale = 0.;
  }
  {
#line 907
  do_rva(mh___0);
  }
#line 908
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 911 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
static int get_rva(mpg123_handle *fr , double *peak , double *gain ) 
{ 
  double p ;
  double g ;
  int ret ;
  int rt ;

  {
#line 913
  p = (double )-1;
#line 914
  g = (double )0;
#line 915
  ret = 0;
#line 916
  if (fr->p.rva) {
#line 918
    rt = 0;
#line 920
    if (fr->p.rva == 2) {
#line 920
      if (fr->rva.level[1] != -1) {
#line 920
        rt = 1;
      }
    }
#line 921
    if (fr->rva.level[rt] != -1) {
#line 923
      p = (double )fr->rva.peak[rt];
#line 924
      g = (double )fr->rva.gain[rt];
#line 925
      ret = 1;
    }
  }
#line 928
  if ((unsigned long )peak != (unsigned long )((void *)0)) {
#line 928
    *peak = p;
  }
#line 929
  if ((unsigned long )gain != (unsigned long )((void *)0)) {
#line 929
    *gain = g;
  }
#line 930
  return (ret);
}
}
#line 934 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
void do_rva(mpg123_handle *fr ) 
{ 
  double peak ;
  double gain ;
  double newscale ;
  double rvafact ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 936
  peak = (double )0;
#line 937
  gain = (double )0;
#line 939
  rvafact = (double )1;
#line 940
  tmp = get_rva(fr, & peak, & gain);
  }
#line 940
  if (tmp) {
#line 942
    if (! (fr->p.flags & 32L)) {
#line 942
      if (fr->p.verbose > 1) {
        {
#line 942
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: doing RVA with gain %f\n",
                gain);
        }
      }
    }
    {
#line 943
    rvafact = pow((double )10, gain / (double )20);
    }
  }
#line 946
  newscale = fr->p.outscale * rvafact;
#line 949
  if (peak * newscale > 1.0) {
    {
#line 951
    newscale = 1.0 / peak;
#line 952
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c:%i] warning: limiting scale value to %f to prevent clipping with indicated peak factor of %f\n",
            952, newscale, peak);
    }
  }
#line 955
  if (newscale != fr->lastscale) {
#line 955
    goto _L;
  } else
#line 955
  if (fr->decoder_change) {
    _L: /* CIL Label */ 
#line 958
    fr->lastscale = newscale;
#line 960
    if ((unsigned long )fr->make_decode_tables != (unsigned long )((void *)0)) {
      {
#line 960
      (*(fr->make_decode_tables))(fr);
      }
    }
  }
#line 962
  return;
}
}
#line 965 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/frame.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_getvolume(mpg123_handle *mh___0 ,
                                                                   double *base ,
                                                                   double *really ,
                                                                   double *rva_db ) 
{ 


  {
#line 967
  if ((unsigned long )mh___0 == (unsigned long )((void *)0)) {
#line 967
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 968
  if (base) {
#line 968
    *base = mh___0->p.outscale;
  }
#line 969
  if (really) {
#line 969
    *really = mh___0->lastscale;
  }
  {
#line 970
  get_rva(mh___0, (double *)((void *)0), rva_db);
  }
#line 971
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 14 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.h"
int read_frame_init(mpg123_handle *fr ) ;
#line 23
int get_songlen(mpg123_handle *fr , int no ) ;
#line 40 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/getbits.h"
static unsigned int getbits___2(mpg123_handle *fr , int number_of_bits ) 
{ 
  unsigned long rval ;

  {
#line 56
  rval = (unsigned long )*(fr->wordpointer + 0);
#line 57
  rval <<= 8;
#line 58
  rval |= (unsigned long )*(fr->wordpointer + 1);
#line 59
  rval <<= 8;
#line 60
  rval |= (unsigned long )*(fr->wordpointer + 2);
#line 62
  rval <<= fr->bitindex;
#line 63
  rval &= 16777215UL;
#line 65
  fr->bitindex += number_of_bits;
#line 67
  rval >>= 24 - number_of_bits;
#line 69
  fr->wordpointer += fr->bitindex >> 3;
#line 70
  fr->bitindex &= 7;
#line 77
  return ((unsigned int )rval);
}
}
#line 70 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
static int const   tabsel_123[2][3][16]  = { { {          (int const   )0,          (int const   )32,          (int const   )64,          (int const   )96, 
                (int const   )128,          (int const   )160,          (int const   )192,          (int const   )224, 
                (int const   )256,          (int const   )288,          (int const   )320,          (int const   )352, 
                (int const   )384,          (int const   )416,          (int const   )448}, 
     {          (int const   )0,          (int const   )32,          (int const   )48,          (int const   )56, 
                (int const   )64,          (int const   )80,          (int const   )96,          (int const   )112, 
                (int const   )128,          (int const   )160,          (int const   )192,          (int const   )224, 
                (int const   )256,          (int const   )320,          (int const   )384}, 
     {          (int const   )0,          (int const   )32,          (int const   )40,          (int const   )48, 
                (int const   )56,          (int const   )64,          (int const   )80,          (int const   )96, 
                (int const   )112,          (int const   )128,          (int const   )160,          (int const   )192, 
                (int const   )224,          (int const   )256,          (int const   )320}}, 
   { {          (int const   )0,          (int const   )32,          (int const   )48,          (int const   )56, 
                (int const   )64,          (int const   )80,          (int const   )96,          (int const   )112, 
                (int const   )128,          (int const   )144,          (int const   )160,          (int const   )176, 
                (int const   )192,          (int const   )224,          (int const   )256}, 
     {          (int const   )0,          (int const   )8,          (int const   )16,          (int const   )24, 
                (int const   )32,          (int const   )40,          (int const   )48,          (int const   )56, 
                (int const   )64,          (int const   )80,          (int const   )96,          (int const   )112, 
                (int const   )128,          (int const   )144,          (int const   )160}, 
     {          (int const   )0,          (int const   )8,          (int const   )16,          (int const   )24, 
                (int const   )32,          (int const   )40,          (int const   )48,          (int const   )56, 
                (int const   )64,          (int const   )80,          (int const   )96,          (int const   )112, 
                (int const   )128,          (int const   )144,          (int const   )160}}};
#line 84 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
long const   freqs[9]  = 
#line 84
  {      (long const   )44100,      (long const   )48000,      (long const   )32000,      (long const   )22050, 
        (long const   )24000,      (long const   )16000,      (long const   )11025,      (long const   )12000, 
        (long const   )8000};
#line 86
static int decode_header(mpg123_handle *fr , unsigned long newhead ) ;
#line 88 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
int read_frame_init(mpg123_handle *fr ) 
{ 
  int tmp ;

  {
  {
#line 90
  tmp = frame_reset(fr);
  }
#line 90
  if (tmp != 0) {
#line 90
    return (-1);
  }
#line 91
  return (0);
}
}
#line 96 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
int frame_bitrate(mpg123_handle *fr ) 
{ 


  {
#line 98
  return ((int )tabsel_123[fr->lsf][fr->lay - 1][fr->bitrate_index]);
}
}
#line 101 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
long frame_freq(mpg123_handle *fr ) 
{ 


  {
#line 103
  return ((long )freqs[fr->sampling_frequency]);
}
}
#line 109 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
int head_check(unsigned long head ) 
{ 


  {
#line 111
  if ((head & 4292870144UL) != 4292870144UL) {
#line 127
    return (0);
  } else
#line 111
  if (! ((head >> 17) & 3UL)) {
#line 127
    return (0);
  } else
#line 111
  if (((head >> 12) & 15UL) == 15UL) {
#line 127
    return (0);
  } else
#line 111
  if (((head >> 10) & 3UL) == 3UL) {
#line 127
    return (0);
  } else {
#line 132
    return (1);
  }
}
}
#line 136 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
static int check_lame_tag(mpg123_handle *fr ) 
{ 
  int lame_offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int i ;
  int lame_type ;
  unsigned long xing_flags ;
  off_t length ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long xing_bytes ;
  double diff ;
  unsigned long xing_quality ;
  unsigned char lame_vbr ;
  float replay_gain[2] ;
  float peak ;
  float gain_offset ;
  char nb[10] ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned char origin ;
  unsigned char gt ;
  double tmp___7 ;
  off_t length___0 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  off_t skipbegin ;
  off_t skipend ;
  off_t tmp___11 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 147
  if (fr->stereo == 2) {
#line 147
    if (fr->lsf) {
#line 147
      tmp = 17;
    } else {
#line 147
      tmp = 32;
    }
#line 147
    tmp___1 = tmp;
  } else {
#line 147
    if (fr->lsf) {
#line 147
      tmp___0 = 9;
    } else {
#line 147
      tmp___0 = 17;
    }
#line 147
    tmp___1 = tmp___0;
  }
#line 147
  lame_offset = tmp___1;
#line 150
  if (fr->p.flags & 64L) {
#line 152
    if (fr->begin_s == 0LL) {
      {
#line 152
      frame_gapless_init(fr, (off_t )529, (off_t )0);
      }
    }
  }
#line 156
  if (fr->framesize >= 120 + lame_offset) {
#line 159
    lame_type = 0;
#line 162
    i = 2;
    {
#line 162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 162
      if (! (i < lame_offset)) {
#line 162
        goto while_break;
      }
#line 162
      if ((int )*(fr->bsbuf + i) != 0) {
#line 162
        goto while_break;
      }
#line 162
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 163
    if (i == lame_offset) {
#line 166
      if ((int )*(fr->bsbuf + lame_offset) == 73) {
#line 166
        if ((int )*(fr->bsbuf + (lame_offset + 1)) == 110) {
#line 166
          if ((int )*(fr->bsbuf + (lame_offset + 2)) == 102) {
#line 166
            if ((int )*(fr->bsbuf + (lame_offset + 3)) == 111) {
#line 174
              lame_type = 1;
            } else {
#line 166
              goto _L___1;
            }
          } else {
#line 166
            goto _L___1;
          }
        } else {
#line 166
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 176
      if ((int )*(fr->bsbuf + lame_offset) == 88) {
#line 176
        if ((int )*(fr->bsbuf + (lame_offset + 1)) == 105) {
#line 176
          if ((int )*(fr->bsbuf + (lame_offset + 2)) == 110) {
#line 176
            if ((int )*(fr->bsbuf + (lame_offset + 3)) == 103) {
#line 184
              lame_type = 2;
#line 185
              fr->vbr = (enum mpg123_vbr )1;
            }
          }
        }
      }
#line 187
      if (lame_type) {
#line 192
        if (! (fr->p.flags & 32L)) {
#line 192
          if (fr->p.verbose > 1) {
            {
#line 192
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Xing/Lame/Info header detected\n");
            }
          }
        }
#line 195
        lame_offset += 4;
#line 200
        xing_flags = ((((unsigned long )*(fr->bsbuf + lame_offset) << 24) | ((unsigned long )*(fr->bsbuf + (lame_offset + 1)) << 16)) | ((unsigned long )*(fr->bsbuf + (lame_offset + 2)) << 8)) | (unsigned long )*(fr->bsbuf + (lame_offset + 3));
#line 201
        lame_offset += 4;
#line 203
        if (xing_flags & 1UL) {
#line 205
          if (fr->p.flags & 4096L) {
#line 207
            if (! (fr->p.flags & 32L)) {
#line 207
              if (fr->p.verbose > 2) {
                {
#line 208
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Ignoring Xing frames because of MPG123_IGNORE_STREAMLENGTH\n");
                }
              }
            }
          } else {
#line 218
            fr->track_frames = (off_t )(((((unsigned long )*(fr->bsbuf + lame_offset) << 24) | ((unsigned long )*(fr->bsbuf + (lame_offset + 1)) << 16)) | ((unsigned long )*(fr->bsbuf + (lame_offset + 2)) << 8)) | (unsigned long )*(fr->bsbuf + (lame_offset + 3)));
#line 219
            if (fr->track_frames > 932067LL) {
#line 219
              fr->track_frames = (off_t )0;
            }
#line 222
            if (fr->p.flags & 64L) {
#line 224
              if (fr->lay == 1) {
#line 224
                tmp___4 = 384;
              } else {
#line 224
                if (fr->lay == 2) {
#line 224
                  tmp___3 = 1152;
                } else {
#line 224
                  if (fr->lsf) {
#line 224
                    tmp___2 = 576;
                  } else
#line 224
                  if (fr->mpeg25) {
#line 224
                    tmp___2 = 576;
                  } else {
#line 224
                    tmp___2 = 1152;
                  }
#line 224
                  tmp___3 = tmp___2;
                }
#line 224
                tmp___4 = tmp___3;
              }
#line 224
              length = fr->track_frames * (off_t )tmp___4;
#line 225
              if (length > 1LL) {
                {
#line 226
                frame_gapless_init(fr, (off_t )529, length + 529LL);
                }
              }
            }
#line 229
            if (! (fr->p.flags & 32L)) {
#line 229
              if (fr->p.verbose > 2) {
                {
#line 229
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Xing: %lu frames\n",
                        (unsigned long )fr->track_frames);
                }
              }
            }
          }
#line 232
          lame_offset += 4;
        }
#line 234
        if (xing_flags & 2UL) {
#line 236
          if (fr->p.flags & 4096L) {
#line 238
            if (! (fr->p.flags & 32L)) {
#line 238
              if (fr->p.verbose > 2) {
                {
#line 239
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Ignoring Xing bytes because of MPG123_IGNORE_STREAMLENGTH\n");
                }
              }
            }
          } else {
#line 243
            xing_bytes = ((((unsigned long )*(fr->bsbuf + lame_offset) << 24) | ((unsigned long )*(fr->bsbuf + (lame_offset + 1)) << 16)) | ((unsigned long )*(fr->bsbuf + (lame_offset + 2)) << 8)) | (unsigned long )*(fr->bsbuf + (lame_offset + 3));
#line 245
            if (fr->rdat.filelen < 1LL) {
#line 246
              fr->rdat.filelen = (off_t )xing_bytes;
            } else
#line 249
            if ((off_t )xing_bytes != fr->rdat.filelen) {
#line 249
              if (! (fr->p.flags & 32L)) {
#line 251
                diff = (1.0 / (double )fr->rdat.filelen) * (double )(fr->rdat.filelen - (off_t )xing_bytes);
#line 252
                if (diff < 0.) {
#line 252
                  diff = - diff;
                }
#line 254
                if (! (fr->p.flags & 32L)) {
#line 254
                  if (fr->p.verbose > 2) {
                    {
#line 255
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Xing stream size %lu differs by %f%% from determined/given file size!\n",
                            xing_bytes, diff);
                    }
                  }
                }
#line 257
                if (diff > 1.) {
                  {
#line 258
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Xing stream size off by more than 1%%, fuzzy seeking may be even more fuzzy than by design!\n");
                  }
                }
              }
            }
#line 262
            if (! (fr->p.flags & 32L)) {
#line 262
              if (fr->p.verbose > 2) {
                {
#line 263
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Xing: %lu bytes\n",
                        xing_bytes);
                }
              }
            }
          }
#line 266
          lame_offset += 4;
        }
#line 268
        if (xing_flags & 4UL) {
          {
#line 270
          frame_fill_toc(fr, fr->bsbuf + lame_offset);
#line 271
          lame_offset += 100;
          }
        }
#line 273
        if (xing_flags & 8UL) {
#line 275
          if (! (fr->p.flags & 32L)) {
#line 275
            if (fr->p.verbose > 2) {
              {
#line 277
              xing_quality = ((((unsigned long )*(fr->bsbuf + lame_offset) << 24) | ((unsigned long )*(fr->bsbuf + (lame_offset + 1)) << 16)) | ((unsigned long )*(fr->bsbuf + (lame_offset + 2)) << 8)) | (unsigned long )*(fr->bsbuf + (lame_offset + 3));
#line 278
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Xing: quality = %lu\n",
                      xing_quality);
              }
            }
          }
#line 280
          lame_offset += 4;
        }
#line 284
        if ((int )*(fr->bsbuf + lame_offset) != 0) {
          {
#line 287
          replay_gain[0] = (float )0;
#line 287
          replay_gain[1] = (float )0;
#line 288
          peak = (float )0;
#line 289
          gain_offset = (float )0;
#line 291
          memcpy((void */* __restrict  */)(nb), (void const   */* __restrict  */)(fr->bsbuf + lame_offset),
                 (size_t )9);
#line 292
          nb[9] = (char)0;
          }
#line 293
          if (! (fr->p.flags & 32L)) {
#line 293
            if (fr->p.verbose > 2) {
              {
#line 293
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Info: Encoder: %s\n",
                      nb);
              }
            }
          }
          {
#line 294
          tmp___5 = strncmp("LAME", (char const   *)(nb), (size_t )4);
          }
#line 294
          if (! tmp___5) {
#line 296
            gain_offset = (float )6;
          }
#line 299
          lame_offset += 9;
#line 301
          lame_vbr = (unsigned char )((int )*(fr->bsbuf + lame_offset) & 15);
#line 302
          if (! (fr->p.flags & 32L)) {
#line 302
            if (fr->p.verbose > 2) {
              {
#line 304
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Info: rev %u\n",
                      (int )*(fr->bsbuf + lame_offset) >> 4);
#line 305
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Info: vbr mode %u\n",
                      (int )lame_vbr);
              }
            }
          }
#line 307
          lame_offset ++;
          {
#line 312
          if ((int )lame_vbr == 8) {
#line 312
            goto case_8;
          }
#line 312
          if ((int )lame_vbr == 1) {
#line 312
            goto case_8;
          }
#line 314
          if ((int )lame_vbr == 9) {
#line 314
            goto case_9;
          }
#line 314
          if ((int )lame_vbr == 2) {
#line 314
            goto case_9;
          }
#line 315
          goto switch_default;
          case_8: /* CIL Label */ 
          case_1: /* CIL Label */ 
#line 312
          fr->vbr = (enum mpg123_vbr )0;
#line 312
          goto switch_break;
          case_9: /* CIL Label */ 
          case_2: /* CIL Label */ 
#line 314
          fr->vbr = (enum mpg123_vbr )2;
#line 314
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 315
          fr->vbr = (enum mpg123_vbr )1;
          switch_break: /* CIL Label */ ;
          }
#line 318
          lame_offset ++;
#line 322
          if ((int )*(fr->bsbuf + lame_offset) != 0) {
#line 322
            tmp___6 = 1;
          } else
#line 322
          if ((int )*(fr->bsbuf + (lame_offset + 1)) != 0) {
#line 322
            tmp___6 = 1;
          } else
#line 322
          if ((int )*(fr->bsbuf + (lame_offset + 2)) != 0) {
#line 322
            tmp___6 = 1;
          } else
#line 322
          if ((int )*(fr->bsbuf + (lame_offset + 3)) != 0) {
#line 322
            tmp___6 = 1;
          } else {
#line 322
            tmp___6 = 0;
          }
#line 336
          if (! (fr->p.flags & 32L)) {
#line 336
            if (fr->p.verbose > 2) {
              {
#line 336
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Info: peak = %f (I won\'t use this)\n",
                      (double )peak);
              }
            }
          }
#line 337
          peak = (float )0;
#line 338
          lame_offset += 4;
#line 347
          i = 0;
          {
#line 347
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 347
            if (! (i < 2)) {
#line 347
              goto while_break___0;
            }
#line 349
            origin = (unsigned char )(((int )*(fr->bsbuf + lame_offset) >> 2) & 7);
#line 350
            if ((int )origin != 0) {
#line 352
              gt = (unsigned char )((int )*(fr->bsbuf + lame_offset) >> 5);
#line 353
              if ((int )gt == 1) {
#line 353
                gt = (unsigned char)0;
              } else
#line 354
              if ((int )gt == 2) {
#line 354
                gt = (unsigned char)1;
              } else {
#line 355
                goto __Cont;
              }
#line 357
              if ((int )*(fr->bsbuf + lame_offset) & 2) {
#line 357
                tmp___7 = - 0.1;
              } else {
#line 357
                tmp___7 = 0.1;
              }
#line 357
              replay_gain[0] = (float )tmp___7 * (float )((((int )((unsigned short )*(fr->bsbuf + lame_offset)) << 8) | (int )((unsigned short )*(fr->bsbuf + (lame_offset + 1)))) & 31);
            }
#line 359
            lame_offset += 2;
            __Cont: /* CIL Label */ 
#line 347
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 361
          if (! (fr->p.flags & 32L)) {
#line 361
            if (fr->p.verbose > 2) {
              {
#line 363
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Info: Radio Gain = %03.1fdB\n",
                      (double )replay_gain[0]);
#line 364
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Info: Audiophile Gain = %03.1fdB\n",
                      (double )replay_gain[1]);
              }
            }
          }
#line 366
          i = 0;
          {
#line 366
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 366
            if (! (i < 2)) {
#line 366
              goto while_break___1;
            }
#line 368
            if (fr->rva.level[i] <= 0) {
#line 370
              fr->rva.peak[i] = (float )0;
#line 371
              fr->rva.gain[i] = replay_gain[i];
#line 372
              fr->rva.level[i] = 0;
            }
#line 366
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 375
          lame_offset ++;
#line 376
          if ((unsigned int )fr->vbr == 2U) {
#line 378
            fr->abr_rate = (int )*(fr->bsbuf + lame_offset);
#line 379
            if (! (fr->p.flags & 32L)) {
#line 379
              if (fr->p.verbose > 2) {
                {
#line 379
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Info: ABR rate = %u\n",
                        fr->abr_rate);
                }
              }
            }
          }
#line 381
          lame_offset ++;
#line 383
          if (! (fr->p.flags & 32L)) {
#line 383
            if (fr->p.verbose > 2) {
              {
#line 384
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Encoder delay = %i; padding = %i\n",
                      ((int )*(fr->bsbuf + lame_offset) << 4) | ((int )*(fr->bsbuf + (lame_offset + 1)) >> 4),
                      (((int )*(fr->bsbuf + (lame_offset + 1)) << 8) | (int )*(fr->bsbuf + (lame_offset + 2))) & 4095);
              }
            }
          }
#line 388
          if (fr->p.flags & 64L) {
#line 390
            if (fr->lay == 1) {
#line 390
              tmp___10 = 384;
            } else {
#line 390
              if (fr->lay == 2) {
#line 390
                tmp___9 = 1152;
              } else {
#line 390
                if (fr->lsf) {
#line 390
                  tmp___8 = 576;
                } else
#line 390
                if (fr->mpeg25) {
#line 390
                  tmp___8 = 576;
                } else {
#line 390
                  tmp___8 = 1152;
                }
#line 390
                tmp___9 = tmp___8;
              }
#line 390
              tmp___10 = tmp___9;
            }
#line 390
            length___0 = fr->track_frames * (off_t )tmp___10;
#line 391
            skipbegin = (off_t )(529 + (((int )*(fr->bsbuf + lame_offset) << 4) | ((int )*(fr->bsbuf + (lame_offset + 1)) >> 4)));
#line 392
            skipend = (off_t )(-529 + ((((int )*(fr->bsbuf + (lame_offset + 1)) << 8) | (int )*(fr->bsbuf + (lame_offset + 2))) & 4095));
#line 395
            if (length___0 > 1LL) {
#line 396
              if (skipend < length___0) {
#line 396
                tmp___11 = length___0 - skipend;
              } else {
#line 396
                tmp___11 = length___0;
              }
              {
#line 396
              frame_gapless_init(fr, skipbegin, tmp___11);
              }
            }
          }
        }
#line 401
        fr->bsbuf = fr->bsspace[fr->bsnum] + 512;
#line 402
        fr->bsnum = (fr->bsnum + 1) & 1;
#line 403
        return (1);
      }
    }
  }
#line 407
  return (0);
}
}
#line 411 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
static int header_mono(unsigned long newhead ) 
{ 
  int tmp ;

  {
#line 413
  if (((newhead >> 6) & 3UL) == 3UL) {
#line 413
    tmp = 1;
  } else {
#line 413
    tmp = 0;
  }
#line 413
  return (tmp);
}
}
#line 420 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
int read_frame(mpg123_handle *fr ) 
{ 
  unsigned long newhead ;
  off_t framepos ;
  int ret ;
  int oldsize ;
  int oldphase ;
  int headcount ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int id3ret ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long nexthead ;
  int hd ;
  off_t start ;
  off_t tmp___4 ;
  off_t tmp___5 ;
  off_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int id3length ;
  off_t tmp___9 ;
  long try ;
  long limit ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  off_t tmp___13 ;
  unsigned char *newbuf ;
  int tmp___14 ;
  double tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 427
  oldsize = fr->framesize;
#line 428
  oldphase = fr->halfphase;
#line 433
  headcount = 0;
#line 435
  fr->fsizeold = fr->framesize;
#line 438
  if (fr->p.halfspeed) {
#line 440
    if (fr->halfphase) {
#line 443
      tmp = 1;
#line 443
      fr->to_ignore = tmp;
#line 443
      fr->to_decode = tmp;
#line 444
      (fr->halfphase) --;
#line 445
      fr->bitindex = 0;
#line 446
      fr->wordpointer = fr->bsbuf;
#line 447
      if (fr->lay == 3) {
        {
#line 447
        memcpy((void */* __restrict  */)fr->bsbuf, (void const   */* __restrict  */)(fr->ssave),
               (size_t )fr->ssize);
        }
      }
#line 448
      if (fr->error_protection) {
        {
#line 448
        fr->crc = getbits___2(fr, 16);
        }
      }
#line 449
      return (1);
    } else {
#line 453
      fr->halfphase = (int )(fr->p.halfspeed - 1L);
    }
  }
  read_again: 
#line 460
  if ((unsigned long )(fr->rd)->forget != (unsigned long )((void *)0)) {
    {
#line 460
    (*((fr->rd)->forget))(fr);
    }
  }
  {
#line 463
  ret = (*((fr->rd)->head_read))(fr, & newhead);
  }
#line 463
  if (ret <= 0) {
#line 463
    goto read_frame_bad;
  }
  init_resync: 
#line 467
  fr->header_change = 2;
#line 468
  if (fr->oldhead) {
#line 470
    if (fr->oldhead == newhead) {
#line 470
      fr->header_change = 0;
    } else
#line 474
    if ((fr->oldhead & 3072UL) == (newhead & 3072UL)) {
      {
#line 477
      tmp___0 = header_mono(fr->oldhead);
#line 477
      tmp___1 = header_mono(newhead);
      }
#line 477
      if (tmp___0 == tmp___1) {
#line 478
        fr->header_change = 1;
      }
    }
  }
#line 484
  if (! fr->firsthead) {
    {
#line 484
    tmp___3 = head_check(newhead);
    }
#line 484
    if (! tmp___3) {
#line 487
      if ((newhead & 4294967040UL) == 1229206272UL) {
        {
#line 489
        id3ret = 0;
#line 490
        id3ret = parse_new_id3(fr, newhead);
        }
#line 491
        if (id3ret < 0) {
#line 491
          ret = id3ret;
#line 491
          goto read_frame_bad;
        } else
#line 493
        if (id3ret > 0) {
#line 493
          fr->metaflags |= 3;
        }
#line 497
        fr->oldhead = 0UL;
#line 498
        goto read_again;
      } else
#line 500
      if (! (fr->p.flags & 32L)) {
#line 500
        if (fr->p.verbose > 1) {
#line 500
          if ((int )fr->silent_resync == 0) {
            {
#line 500
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Junk at the beginning (0x%08lx)\n",
                    newhead);
            }
          }
        }
      }
#line 503
      if (newhead == (unsigned long )((((82 << 24) + (73 << 16)) + (70 << 8)) + 70)) {
#line 504
        if (! (fr->p.flags & 32L)) {
#line 504
          if (fr->p.verbose > 1) {
#line 504
            if ((int )fr->silent_resync == 0) {
              {
#line 504
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Looks like a RIFF header.\n");
              }
            }
          }
        }
        {
#line 506
        ret = (*((fr->rd)->head_read))(fr, & newhead);
        }
#line 506
        if (ret <= 0) {
#line 506
          goto read_frame_bad;
        }
        {
#line 508
        while (1) {
          while_continue: /* CIL Label */ ;
#line 508
          if (! (newhead != (unsigned long )((((100 << 24) + (97 << 16)) + (116 << 8)) + 97))) {
#line 508
            goto while_break;
          }
          {
#line 510
          ret = (*((fr->rd)->head_shift))(fr, & newhead);
          }
#line 510
          if (ret <= 0) {
#line 510
            goto read_frame_bad;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 512
        ret = (*((fr->rd)->head_read))(fr, & newhead);
        }
#line 512
        if (ret <= 0) {
#line 512
          goto read_frame_bad;
        }
#line 514
        if (! (fr->p.flags & 32L)) {
#line 514
          if (fr->p.verbose > 1) {
#line 514
            if ((int )fr->silent_resync == 0) {
              {
#line 514
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Skipped RIFF header!\n");
              }
            }
          }
        }
#line 516
        fr->oldhead = 0UL;
#line 517
        goto read_again;
      }
#line 523
      ret = 0;
      {
#line 524
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 524
        if (! (headcount < 65536)) {
#line 524
          goto while_break___0;
        }
        {
#line 526
        ret = (*((fr->rd)->head_shift))(fr, & newhead);
        }
#line 526
        if (ret <= 0) {
#line 526
          goto read_frame_bad;
        }
        {
#line 528
        tmp___2 = head_check(newhead);
        }
#line 528
        if (tmp___2) {
          {
#line 528
          ret = decode_header(fr, newhead);
          }
#line 528
          if (ret) {
#line 529
            goto while_break___0;
          }
        }
#line 524
        headcount ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 531
      if (ret < 0) {
#line 531
        goto read_frame_bad;
      }
#line 533
      if (headcount == 65536) {
#line 535
        if (! (fr->p.flags & 32L)) {
          {
#line 535
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: Giving up searching valid MPEG header after (over) 64K of junk.\n",
                  535);
          }
        }
#line 536
        return (0);
      }
    }
  }
#line 548
  if (! fr->firsthead) {
#line 548
    if (fr->rdat.flags & 12) {
      {
#line 548
      tmp___8 = head_check(newhead);
      }
#line 548
      if (tmp___8) {
        {
#line 548
        ret = decode_header(fr, newhead);
        }
#line 548
        if (ret) {
          {
#line 550
          nexthead = 0UL;
#line 551
          hd = 0;
#line 552
          tmp___4 = (*((fr->rd)->tell))(fr);
#line 552
          start = tmp___4;
          }
#line 553
          if (ret < 0) {
#line 553
            goto read_frame_bad;
          }
          {
#line 557
          tmp___5 = (*((fr->rd)->skip_bytes))(fr, (off_t )fr->framesize);
#line 557
          ret = (int )tmp___5;
          }
#line 557
          if (ret < 0) {
#line 559
            if (ret == -1) {
#line 559
              if (! (fr->p.flags & 32L)) {
                {
#line 559
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: cannot seek!\n",
                        559);
                }
              }
            }
#line 560
            goto read_frame_bad;
          }
          {
#line 562
          hd = (*((fr->rd)->head_read))(fr, & nexthead);
          }
#line 563
          if (hd == -10) {
#line 563
            ret = hd;
#line 563
            goto read_frame_bad;
          }
          {
#line 564
          tmp___6 = (*((fr->rd)->tell))(fr);
#line 564
          ret = (*((fr->rd)->back_bytes))(fr, tmp___6 - start);
          }
#line 564
          if (ret < 0) {
#line 566
            if (ret == -1) {
#line 566
              if (! (fr->p.flags & 32L)) {
                {
#line 566
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: cannot seek!\n",
                        566);
                }
              }
            }
#line 568
            goto read_frame_bad;
          }
#line 571
          if (! hd) {
#line 573
            if (! (fr->p.flags & 32L)) {
              {
#line 573
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] warning: cannot read next header, a one-frame stream? Duh...\n",
                      573);
              }
            }
          } else {
            {
#line 579
            tmp___7 = head_check(nexthead);
            }
#line 579
            if (tmp___7) {
#line 579
              if ((nexthead & 4294839552UL) != (newhead & 4294839552UL)) {
                _L: /* CIL Label */ 
                {
#line 582
                fr->oldhead = 0UL;
#line 584
                ret = (*((fr->rd)->back_bytes))(fr, (off_t )3);
                }
#line 584
                if (ret < 0) {
#line 586
                  if (! (fr->p.flags & 32L)) {
                    {
#line 586
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: cannot seek!\n",
                            586);
                    }
                  }
#line 588
                  goto read_frame_bad;
                }
#line 590
                goto read_again;
              }
            } else {
#line 579
              goto _L;
            }
          }
        }
      }
    }
  }
  {
#line 596
  tmp___12 = head_check(newhead);
  }
#line 596
  if (! tmp___12) {
#line 599
    if ((newhead & 4294967040UL) == (unsigned long )(((84 << 24) + (65 << 16)) + (71 << 8))) {
      {
#line 601
      fr->id3buf[0] = (unsigned char )((newhead >> 24) & 255UL);
#line 602
      fr->id3buf[1] = (unsigned char )((newhead >> 16) & 255UL);
#line 603
      fr->id3buf[2] = (unsigned char )((newhead >> 8) & 255UL);
#line 604
      fr->id3buf[3] = (unsigned char )(newhead & 255UL);
#line 605
      ret = (*((fr->rd)->fullread))(fr, fr->id3buf + 4, 124);
      }
#line 605
      if (ret < 0) {
#line 605
        goto read_frame_bad;
      }
#line 606
      fr->metaflags |= 3;
#line 607
      fr->rdat.flags |= 2;
#line 608
      if (! (fr->p.flags & 32L)) {
#line 608
        if (fr->p.verbose > 2) {
          {
#line 608
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Skipped ID3v1 tag.\n");
          }
        }
      }
#line 609
      goto read_again;
    }
#line 613
    if ((newhead & 4294967040UL) == 1229206272UL) {
      {
#line 615
      id3length = 0;
#line 616
      id3length = parse_new_id3(fr, newhead);
      }
#line 617
      if (id3length < 0) {
#line 617
        ret = id3length;
#line 617
        goto read_frame_bad;
      }
#line 619
      fr->metaflags |= 3;
#line 620
      goto read_again;
    } else
#line 622
    if (! (fr->p.flags & 32L)) {
#line 622
      if ((int )fr->silent_resync == 0) {
        {
#line 624
        tmp___9 = (*((fr->rd)->tell))(fr);
#line 624
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Illegal Audio-MPEG-Header 0x%08lx at offset %lli.\n",
                newhead, tmp___9 - 4LL);
        }
      }
    }
#line 628
    if (! (fr->p.flags & 32L)) {
#line 628
      if ((newhead & 4294967040UL) == (unsigned long )(((98 << 24) + (109 << 16)) + (112 << 8))) {
        {
#line 628
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Could be a BMP album art.\n");
        }
      }
    }
#line 631
    if (! (fr->p.flags & 128L)) {
#line 633
      try = 0L;
#line 634
      limit = fr->p.resync_limit;
#line 637
      fr->bitreservoir = 0U;
#line 640
      if (! (fr->p.flags & 32L)) {
#line 640
        if ((int )fr->silent_resync == 0) {
          {
#line 640
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Trying to resync...\n");
          }
        }
      }
      {
#line 646
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 648
        try ++;
#line 649
        if (limit >= 0L) {
#line 649
          if (try >= limit) {
#line 649
            goto while_break___1;
          }
        }
        {
#line 651
        ret = (*((fr->rd)->head_shift))(fr, & newhead);
        }
#line 651
        if (ret <= 0) {
#line 654
          if (! (fr->p.flags & 32L)) {
            {
#line 654
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Hit end of (available) data during resync.\n");
            }
          }
#line 656
          goto read_frame_bad;
        }
#line 658
        if (! (fr->p.flags & 32L)) {
#line 658
          if (fr->p.verbose > 2) {
#line 658
            tmp___10 = 1;
          } else {
#line 658
            tmp___10 = 0;
          }
        } else {
#line 658
          tmp___10 = 0;
        }
#line 660
        if (! fr->oldhead) {
#line 663
          goto init_resync;
        }
        {
#line 646
        tmp___11 = head_check(newhead);
        }
#line 646
        if (tmp___11) {
#line 646
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 675
      if (! (fr->p.flags & 32L)) {
#line 675
        if ((int )fr->silent_resync == 0) {
          {
#line 675
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Skipped %li bytes in input.\n",
                  try);
          }
        }
      }
#line 677
      if (limit >= 0L) {
#line 677
        if (try >= limit) {
#line 679
          if (! (fr->p.flags & 32L)) {
            {
#line 680
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: Giving up resync after %li bytes - your stream is not nice... (maybe increasing resync limit could help).\n",
                    680, try);
            }
          }
#line 682
          fr->err = 28;
#line 683
          return (-1);
        } else {
#line 688
          fr->firsthead = 0UL;
#line 689
          goto init_resync;
        }
      } else {
#line 688
        fr->firsthead = 0UL;
#line 689
        goto init_resync;
      }
    } else {
#line 694
      if (! (fr->p.flags & 32L)) {
        {
#line 694
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: not attempting to resync...\n",
                694);
        }
      }
#line 696
      fr->err = 27;
#line 697
      return (-1);
    }
  }
#line 703
  if (! fr->firsthead) {
    {
#line 705
    ret = decode_header(fr, newhead);
    }
#line 706
    if (ret == 0) {
#line 708
      if (! (fr->p.flags & 32L)) {
        {
#line 708
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: decode header failed before first valid one, going to read again\n",
                708);
        }
      }
#line 710
      goto read_again;
    } else
#line 712
    if (ret < 0) {
#line 712
      goto read_frame_bad;
    }
  } else {
    {
#line 716
    ret = decode_header(fr, newhead);
    }
#line 717
    if (ret == 0) {
#line 719
      if (! (fr->p.flags & 32L)) {
        {
#line 719
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: decode header failed - goto resync\n",
                719);
        }
      }
#line 721
      goto init_resync;
    } else
#line 723
    if (ret < 0) {
#line 723
      goto read_frame_bad;
    }
  }
  {
#line 727
  tmp___13 = (*((fr->rd)->tell))(fr);
#line 727
  framepos = tmp___13 - 4LL;
#line 730
  newbuf = fr->bsspace[fr->bsnum] + 512;
#line 732
  ret = (*((fr->rd)->read_frame_body))(fr, newbuf, fr->framesize);
  }
#line 732
  if (ret < 0) {
#line 736
    goto read_frame_bad;
  }
#line 738
  fr->bsbufold = fr->bsbuf;
#line 739
  fr->bsbuf = newbuf;
#line 741
  fr->bsnum = (fr->bsnum + 1) & 1;
#line 743
  if (! fr->firsthead) {
#line 745
    fr->firsthead = newhead;
#line 749
    if (fr->num < 0LL) {
#line 751
      fr->audio_start = framepos;
#line 754
      if (fr->lay == 3) {
        {
#line 754
        tmp___14 = check_lame_tag(fr);
        }
#line 754
        if (tmp___14 == 1) {
#line 756
          if ((unsigned long )(fr->rd)->forget != (unsigned long )((void *)0)) {
            {
#line 756
            (*((fr->rd)->forget))(fr);
            }
          }
#line 758
          fr->oldhead = 0UL;
#line 759
          goto read_again;
        }
      }
      {
#line 762
      do_rva(fr);
      }
    }
  }
#line 768
  fr->bitindex = 0;
#line 769
  fr->wordpointer = fr->bsbuf;
#line 772
  (fr->mean_frames) ++;
#line 772
  if (fr->mean_frames != 0LL) {
    {
#line 774
    tmp___15 = compute_bpf(fr);
#line 774
    fr->mean_framesize = ((double )(fr->mean_frames - 1LL) * fr->mean_framesize + tmp___15) / (double )fr->mean_frames;
    }
  }
#line 776
  (fr->num) ++;
#line 781
  if (fr->p.halfspeed) {
#line 781
    if (fr->lay == 3) {
      {
#line 784
      memcpy((void */* __restrict  */)(fr->ssave), (void const   */* __restrict  */)fr->bsbuf,
             (size_t )fr->ssize);
      }
    }
  }
#line 791
  if (fr->accurate) {
#line 791
    if (fr->index.size) {
#line 791
      if (fr->num == fr->index.next) {
        {
#line 792
        fi_add(& fr->index, framepos);
        }
      }
    }
  }
#line 795
  if ((int )fr->silent_resync > 0) {
#line 795
    fr->silent_resync = (char )((int )fr->silent_resync - 1);
  }
#line 797
  if ((unsigned long )(fr->rd)->forget != (unsigned long )((void *)0)) {
    {
#line 797
    (*((fr->rd)->forget))(fr);
    }
  }
#line 799
  tmp___16 = 1;
#line 799
  fr->to_ignore = tmp___16;
#line 799
  fr->to_decode = tmp___16;
#line 800
  if (fr->error_protection) {
    {
#line 800
    fr->crc = getbits___2(fr, 16);
    }
  }
#line 802
  return (1);
  read_frame_bad: 
#line 806
  if ((unsigned long )(fr->rd)->forget != (unsigned long )((void *)0)) {
    {
#line 806
    (*((fr->rd)->forget))(fr);
    }
  }
#line 808
  fr->silent_resync = (char)0;
#line 809
  if (fr->err == 0) {
#line 809
    fr->err = 18;
  }
#line 810
  fr->framesize = oldsize;
#line 811
  fr->halfphase = oldphase;
#line 813
  return (ret);
}
}
#line 824 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
static int guess_freeformat_framesize(mpg123_handle *fr ) 
{ 
  long i ;
  int ret ;
  unsigned long head ;
  int sampling_frequency ;
  int mpeg25 ;
  int lsf ;
  int tmp ;
  char *__cil_tmp9 ;

  {
#line 829
  if (! (fr->rdat.flags & 12)) {
#line 831
    if (! (fr->p.flags & 32L)) {
      {
#line 831
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: Cannot look for freeformat frame size with non-seekable and non-buffered stream!\n",
              831);
      }
    }
#line 833
    return (0);
  }
  {
#line 835
  ret = (*((fr->rd)->head_read))(fr, & head);
  }
#line 835
  if (ret <= 0) {
#line 836
    return (ret);
  }
#line 840
  i = 4L;
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < 65536L)) {
#line 840
      goto while_break;
    }
    {
#line 841
    ret = (*((fr->rd)->head_shift))(fr, & head);
    }
#line 841
    if (ret <= 0) {
#line 843
      return (ret);
    }
    {
#line 845
    tmp = head_check(head);
    }
#line 845
    if (tmp) {
#line 849
      if (head & (unsigned long )(1 << 20)) {
#line 851
        if (head & (unsigned long )(1 << 19)) {
#line 851
          lsf = 0;
        } else {
#line 851
          lsf = 1;
        }
#line 852
        mpeg25 = 0;
      } else {
#line 856
        lsf = 1;
#line 857
        mpeg25 = 1;
      }
#line 860
      if (mpeg25) {
#line 861
        sampling_frequency = (int )(6UL + ((head >> 10) & 3UL));
      } else {
#line 863
        sampling_frequency = (int )(((head >> 10) & 3UL) + (unsigned long )(lsf * 3));
      }
#line 865
      if (lsf == fr->lsf) {
#line 865
        if (mpeg25 == fr->mpeg25) {
#line 865
          if (sampling_frequency == fr->sampling_frequency) {
            {
#line 867
            (*((fr->rd)->back_bytes))(fr, (off_t )(i + 1L));
#line 868
            fr->framesize = (int )(i - 3L);
            }
#line 869
            return (1);
          }
        }
      }
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  (*((fr->rd)->back_bytes))(fr, (off_t )i);
  }
#line 874
  return (0);
}
}
#line 886 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
static int decode_header(mpg123_handle *fr , unsigned long newhead ) 
{ 
  int tmp ;
  int tmp___0 ;
  int ret ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 888
  tmp = head_check(newhead);
  }
#line 888
  if (! tmp) {
#line 890
    if (! (fr->p.flags & 32L)) {
      {
#line 890
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: tried to decode obviously invalid header\n",
              890);
      }
    }
#line 892
    return (0);
  }
#line 894
  if (newhead & (unsigned long )(1 << 20)) {
#line 896
    if (newhead & (unsigned long )(1 << 19)) {
#line 896
      fr->lsf = 0;
    } else {
#line 896
      fr->lsf = 1;
    }
#line 897
    fr->mpeg25 = 0;
  } else {
#line 901
    fr->lsf = 1;
#line 902
    fr->mpeg25 = 1;
  }
#line 905
  if (fr->p.flags & 128L) {
#line 905
    goto _L;
  } else
#line 905
  if (! fr->oldhead) {
#line 905
    goto _L;
  } else
#line 905
  if (((fr->oldhead >> 19) & 3UL) ^ ((newhead >> 19) & 3UL)) {
    _L: /* CIL Label */ 
#line 912
    fr->lay = (int )(4UL - ((newhead >> 17) & 3UL));
#line 913
    if (((newhead >> 10) & 3UL) == 3UL) {
#line 915
      if (! (fr->p.flags & 32L)) {
        {
#line 915
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: Stream error\n",
                915);
        }
      }
#line 917
      return (0);
    }
#line 919
    if (fr->mpeg25) {
#line 920
      fr->sampling_frequency = (int )(6UL + ((newhead >> 10) & 3UL));
    } else {
#line 922
      fr->sampling_frequency = (int )(((newhead >> 10) & 3UL) + (unsigned long )(fr->lsf * 3));
    }
  }
#line 928
  fr->error_protection = (int )(((newhead >> 16) & 1UL) ^ 1UL);
#line 929
  fr->bitrate_index = (int )((newhead >> 12) & 15UL);
#line 930
  fr->padding = (int )((newhead >> 9) & 1UL);
#line 931
  fr->extension = (int )((newhead >> 8) & 1UL);
#line 932
  fr->mode = (int )((newhead >> 6) & 3UL);
#line 933
  fr->mode_ext = (int )((newhead >> 4) & 3UL);
#line 934
  fr->copyright = (int )((newhead >> 3) & 1UL);
#line 935
  fr->original = (int )((newhead >> 2) & 1UL);
#line 936
  fr->emphasis = (int )(newhead & 3UL);
#line 937
  if ((newhead & 4292870144UL) == 4292870144UL) {
#line 937
    if ((newhead >> 17) & 3UL) {
#line 937
      if (((newhead >> 12) & 15UL) == 0UL) {
#line 937
        if (((newhead >> 10) & 3UL) != 3UL) {
#line 937
          tmp___0 = 1;
        } else {
#line 937
          tmp___0 = 0;
        }
      } else {
#line 937
        tmp___0 = 0;
      }
    } else {
#line 937
      tmp___0 = 0;
    }
  } else {
#line 937
    tmp___0 = 0;
  }
#line 937
  fr->freeformat = tmp___0;
#line 939
  if (fr->mode == 3) {
#line 939
    fr->stereo = 1;
  } else {
#line 939
    fr->stereo = 2;
  }
#line 941
  fr->oldhead = newhead;
#line 944
  if (fr->freeformat) {
#line 947
    if (fr->freeformat_framesize < 0L) {
      {
#line 950
      ret = guess_freeformat_framesize(fr);
      }
#line 951
      if (ret > 0) {
#line 953
        fr->freeformat_framesize = (long )(fr->framesize - fr->padding);
#line 954
        if (! (fr->p.flags & 32L)) {
#line 954
          if (fr->p.verbose > 1) {
            {
#line 955
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: free format frame size %li\n",
                    fr->freeformat_framesize);
            }
          }
        }
      } else {
#line 959
        if (! (ret == -10)) {
          {
#line 962
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: Encountered free format header, but failed to guess frame size.\n",
                  962);
          }
        }
#line 963
        return (ret);
      }
    } else {
#line 969
      fr->framesize = (int )(fr->freeformat_framesize + (long )fr->padding);
    }
  }
  {
#line 976
  if (fr->lay == 1) {
#line 976
    goto case_1;
  }
#line 987
  if (fr->lay == 2) {
#line 987
    goto case_2;
  }
#line 999
  if (fr->lay == 3) {
#line 999
    goto case_3;
  }
#line 1017
  goto switch_default;
  case_1: /* CIL Label */ 
#line 977
  fr->do_layer = & do_layer1;
#line 978
  if (! fr->freeformat) {
#line 980
    fr->framesize = (int )((long )tabsel_123[fr->lsf][0][fr->bitrate_index] * 12000L);
#line 981
    fr->framesize = (int )((long const   )fr->framesize / freqs[fr->sampling_frequency]);
#line 982
    fr->framesize = ((fr->framesize + fr->padding) << 2) - 4;
  }
#line 984
  goto switch_break;
  case_2: /* CIL Label */ 
#line 988
  fr->do_layer = & do_layer2;
#line 989
  if (! fr->freeformat) {
#line 992
    fr->framesize = (int )((long )tabsel_123[fr->lsf][1][fr->bitrate_index] * 144000L);
#line 993
    fr->framesize = (int )((long const   )fr->framesize / freqs[fr->sampling_frequency]);
#line 994
    fr->framesize += fr->padding - 4;
  }
#line 996
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1000
  fr->do_layer = & do_layer3;
#line 1001
  if (fr->lsf) {
#line 1002
    if (fr->stereo == 1) {
#line 1002
      fr->ssize = 9;
    } else {
#line 1002
      fr->ssize = 17;
    }
  } else
#line 1004
  if (fr->stereo == 1) {
#line 1004
    fr->ssize = 17;
  } else {
#line 1004
    fr->ssize = 32;
  }
#line 1006
  if (fr->error_protection) {
#line 1007
    fr->ssize += 2;
  }
#line 1009
  if (! fr->freeformat) {
#line 1011
    fr->framesize = (int )((long )tabsel_123[fr->lsf][2][fr->bitrate_index] * 144000L);
#line 1012
    fr->framesize = (int )((long const   )fr->framesize / (freqs[fr->sampling_frequency] << fr->lsf));
#line 1013
    fr->framesize = (fr->framesize + fr->padding) - 4;
  }
#line 1015
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1018
  if (! (fr->p.flags & 32L)) {
    {
#line 1018
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: Layer type %i not supported in this build!\n",
            1018, fr->lay);
    }
  }
#line 1020
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 1022
  if (fr->framesize > 3456) {
#line 1024
    if (! (fr->p.flags & 32L)) {
      {
#line 1024
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c:%i] error: Frame size too big: %d\n",
              1024, (fr->framesize + 4) - fr->padding);
      }
    }
#line 1026
    return (0);
  }
#line 1028
  return (1);
}
}
#line 1031 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
void set_pointer(mpg123_handle *fr , long backstep ) 
{ 


  {
#line 1033
  fr->wordpointer = (fr->bsbuf + fr->ssize) - backstep;
#line 1034
  if (backstep) {
    {
#line 1035
    memcpy((void */* __restrict  */)fr->wordpointer, (void const   */* __restrict  */)((fr->bsbufold + fr->fsizeold) - backstep),
           (size_t )backstep);
    }
  }
#line 1037
  fr->bitindex = 0;
#line 1038
  return;
}
}
#line 1042 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
double compute_bpf(mpg123_handle *fr ) 
{ 
  double bpf ;

  {
  {
#line 1048
  if (fr->lay == 1) {
#line 1048
    goto case_1;
  }
#line 1054
  if (fr->lay == 3) {
#line 1054
    goto case_3;
  }
#line 1054
  if (fr->lay == 2) {
#line 1054
    goto case_3;
  }
#line 1059
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1049
  bpf = (double )tabsel_123[fr->lsf][0][fr->bitrate_index];
#line 1050
  bpf *= 12000.0 * 4.0;
#line 1051
  bpf /= (double )(freqs[fr->sampling_frequency] << fr->lsf);
#line 1052
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1055
  bpf = (double )tabsel_123[fr->lsf][fr->lay - 1][fr->bitrate_index];
#line 1056
  bpf *= (double )144000;
#line 1057
  bpf /= (double )(freqs[fr->sampling_frequency] << fr->lsf);
#line 1058
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1060
  bpf = 1.0;
  switch_break: /* CIL Label */ ;
  }
#line 1063
  return (bpf);
}
}
#line 1068 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
static int bs[4]  = {      0,      384,      1152,      1152};
#line 1066 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
double __attribute__((__force_align_arg_pointer__))  mpg123_tpf(mpg123_handle *fr ) 
{ 
  double tpf ;

  {
#line 1070
  if ((unsigned long )fr == (unsigned long )((void *)0)) {
#line 1070
    return ((double __attribute__((__force_align_arg_pointer__))  )-1);
  }
#line 1072
  tpf = (double )bs[fr->lay];
#line 1073
  tpf /= (double )(freqs[fr->sampling_frequency] << fr->lsf);
#line 1074
  return ((double __attribute__((__force_align_arg_pointer__))  )tpf);
}
}
#line 1077 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
int __attribute__((__force_align_arg_pointer__))  mpg123_position_64(mpg123_handle *fr ,
                                                                     off_t no , off_t buffsize ,
                                                                     off_t *current_frame ,
                                                                     off_t *frames_left___0 ,
                                                                     double *current_seconds ,
                                                                     double *seconds_left ) 
{ 
  double tpf ;
  double dt ;
  off_t cur ;
  off_t left ;
  double curs ;
  double lefts ;
  double __attribute__((__force_align_arg_pointer__))  tmp ;
  double bpf ;
  off_t t ;
  off_t tmp___0 ;
  double tmp___1 ;

  {
#line 1082
  dt = 0.0;
#line 1086
  if (! fr) {
#line 1089
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  } else
#line 1086
  if (! fr->rd) {
#line 1089
    return ((int __attribute__((__force_align_arg_pointer__))  )-1);
  }
  {
#line 1092
  no += fr->num;
#line 1093
  cur = no;
#line 1094
  tmp = mpg123_tpf(fr);
#line 1094
  tpf = (double )tmp;
  }
#line 1095
  if (buffsize > 0LL) {
#line 1095
    if (fr->af.rate > 0L) {
#line 1095
      if (fr->af.channels > 0) {
#line 1097
        dt = ((double )buffsize / (double )fr->af.rate) / (double )fr->af.channels;
#line 1098
        if (fr->af.encoding & 64) {
#line 1098
          dt *= 0.5;
        }
      }
    }
  }
#line 1101
  left = (off_t )0;
#line 1103
  if (fr->track_frames != 0LL) {
#line 1103
    if (fr->track_frames >= fr->num) {
#line 1103
      if (no < fr->track_frames) {
#line 1103
        left = fr->track_frames - no;
      } else {
#line 1103
        left = (off_t )0;
      }
    } else {
#line 1103
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1105
  if (fr->rdat.filelen >= 0LL) {
    {
#line 1108
    tmp___0 = (*((fr->rd)->tell))(fr);
#line 1108
    t = tmp___0;
    }
#line 1109
    if (fr->mean_framesize) {
#line 1109
      bpf = fr->mean_framesize;
    } else {
      {
#line 1109
      tmp___1 = compute_bpf(fr);
#line 1109
      bpf = tmp___1;
      }
    }
#line 1110
    left = (off_t )((double )(fr->rdat.filelen - t) / bpf);
#line 1112
    if (fr->num != no) {
#line 1114
      if (fr->num > no) {
#line 1114
        left += fr->num - no;
      } else
#line 1117
      if (left >= no - fr->num) {
#line 1117
        left -= no - fr->num;
      } else {
#line 1118
        left = (off_t )0;
      }
    }
  }
#line 1126
  curs = (double )no * tpf - dt;
#line 1127
  lefts = (double )left * tpf + dt;
#line 1131
  if (left < 0LL) {
#line 1133
    left = (off_t )0;
#line 1134
    lefts = 0.0;
  } else
#line 1131
  if (lefts < (double )0) {
#line 1133
    left = (off_t )0;
#line 1134
    lefts = 0.0;
  }
#line 1136
  if ((unsigned long )current_frame != (unsigned long )((void *)0)) {
#line 1136
    *current_frame = cur;
  }
#line 1137
  if ((unsigned long )frames_left___0 != (unsigned long )((void *)0)) {
#line 1137
    *frames_left___0 = left;
  }
#line 1138
  if ((unsigned long )current_seconds != (unsigned long )((void *)0)) {
#line 1138
    *current_seconds = curs;
  }
#line 1139
  if ((unsigned long )seconds_left != (unsigned long )((void *)0)) {
#line 1139
    *seconds_left = lefts;
  }
#line 1140
  return ((int __attribute__((__force_align_arg_pointer__))  )0);
}
}
#line 1143 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/parse.c"
int get_songlen(mpg123_handle *fr , int no ) 
{ 
  double tpf ;
  double tmp ;
  double __attribute__((__force_align_arg_pointer__))  tmp___0 ;

  {
#line 1147
  if (! fr) {
#line 1148
    return (0);
  }
#line 1150
  if (no < 0) {
#line 1151
    if (! fr->rd) {
#line 1152
      return (0);
    } else
#line 1151
    if (fr->rdat.filelen < 0LL) {
#line 1152
      return (0);
    }
    {
#line 1153
    tmp = compute_bpf(fr);
#line 1153
    no = (int )((double )fr->rdat.filelen / tmp);
    }
  }
  {
#line 1156
  tmp___0 = mpg123_tpf(fr);
#line 1156
  tpf = (double )tmp___0;
  }
#line 1157
  return ((int )((double )no * tpf));
}
}
#line 76 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 30 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/compat.c"
void *safe_realloc(void *ptr , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 32
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 32
    tmp = malloc(size);
    }
#line 32
    return (tmp);
  } else {
    {
#line 33
    tmp___0 = realloc(ptr, size);
    }
#line 33
    return (tmp___0);
  }
}
}
#line 58 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/compat.c"
int compat_open(char const   *filename , int mode___0 ) 
{ 
  int ret ;

  {
  {
#line 76
  ret = open(filename, mode___0);
  }
#line 84
  return (ret);
}
}
#line 87 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/libmpg123/compat.c"
int compat_close(int infd ) 
{ 
  int tmp ;

  {
  {
#line 92
  tmp = close(infd);
  }
#line 92
  return (tmp);
}
}
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 50 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int rate_best_match_oss(audio_output_t *ao___0 ) 
{ 
  int ret ;
  int dsp_rate ;

  {
#line 54
  if (! ao___0) {
#line 54
    return (-1);
  } else
#line 54
  if (ao___0->fn < 0) {
#line 54
    return (-1);
  } else
#line 54
  if (ao___0->rate < 0L) {
#line 54
    return (-1);
  }
  {
#line 55
  dsp_rate = (int )ao___0->rate;
#line 57
  ret = ioctl(ao___0->fn, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 2U) | (sizeof(int ) << 16),
              & dsp_rate);
  }
#line 58
  if (ret < 0) {
#line 58
    return (ret);
  }
#line 59
  ao___0->rate = (long )dsp_rate;
#line 60
  return (0);
}
}
#line 63 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int set_rate_oss(audio_output_t *ao___0 ) 
{ 
  int dsp_rate ;
  int ret ;

  {
#line 66
  ret = 0;
#line 68
  if (ao___0->rate >= 0L) {
    {
#line 69
    dsp_rate = (int )ao___0->rate;
#line 70
    ret = ioctl(ao___0->fn, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 2U) | (sizeof(int ) << 16),
                & dsp_rate);
    }
  }
#line 72
  return (ret);
}
}
#line 75 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int set_channels_oss(audio_output_t *ao___0 ) 
{ 
  int chan ;
  int ret ;

  {
#line 77
  chan = ao___0->channels - 1;
#line 80
  if (ao___0->channels < 0) {
#line 80
    return (0);
  }
  {
#line 82
  ret = ioctl(ao___0->fn, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 3U) | (sizeof(int ) << 16),
              & chan);
  }
#line 83
  if (chan != ao___0->channels - 1) {
#line 83
    return (-1);
  }
#line 85
  return (ret);
}
}
#line 88 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int set_format_oss(audio_output_t *ao___0 ) 
{ 
  int sample_size ;
  int fmts___0 ;
  int sf ;
  int ret ;

  {
#line 93
  if (ao___0->format == -1) {
#line 93
    return (0);
  }
  {
#line 101
  if (ao___0->format == 1) {
#line 101
    goto case_1;
  }
#line 105
  if (ao___0->format == 130) {
#line 105
    goto case_130;
  }
#line 109
  if (ao___0->format == 4) {
#line 109
    goto case_4;
  }
#line 113
  if (ao___0->format == 8) {
#line 113
    goto case_8;
  }
#line 117
  if (ao___0->format == 96) {
#line 117
    goto case_96;
  }
#line 97
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 98
  fmts___0 = 16;
#line 99
  sample_size = 16;
#line 100
  goto switch_break;
  case_1: /* CIL Label */ 
#line 102
  fmts___0 = 8;
#line 103
  sample_size = 8;
#line 104
  goto switch_break;
  case_130: /* CIL Label */ 
#line 106
  fmts___0 = 64;
#line 107
  sample_size = 8;
#line 108
  goto switch_break;
  case_4: /* CIL Label */ 
#line 110
  fmts___0 = 1;
#line 111
  sample_size = 8;
#line 112
  goto switch_break;
  case_8: /* CIL Label */ 
#line 114
  fmts___0 = 2;
#line 115
  sample_size = 8;
#line 116
  goto switch_break;
  case_96: /* CIL Label */ 
#line 118
  fmts___0 = 128;
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 127
  sf = fmts___0;
#line 128
  ret = ioctl(ao___0->fn, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
              & fmts___0);
  }
#line 129
  if (sf != fmts___0) {
#line 129
    return (-1);
  }
#line 131
  return (ret);
}
}
#line 135 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int reset_parameters_oss(audio_output_t *ao___0 ) 
{ 
  int ret ;
  char *__cil_tmp3 ;

  {
  {
#line 138
  ret = ioctl(ao___0->fn, (unsigned long )((unsigned int )(80 << 8)), (void *)0);
  }
#line 139
  if (ret < 0) {
#line 139
    if (! (ao___0->auxflags & 1)) {
      {
#line 139
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c:%i] error: Can\'t reset audio!\n",
              139);
      }
    }
  }
  {
#line 140
  ret = set_format_oss(ao___0);
  }
#line 141
  if (ret == -1) {
#line 141
    goto err;
  }
  {
#line 142
  ret = set_channels_oss(ao___0);
  }
#line 143
  if (ret == -1) {
#line 143
    goto err;
  }
  {
#line 144
  ret = set_rate_oss(ao___0);
  }
#line 145
  if (ret == -1) {

  }
  err: 
#line 159
  return (ret);
}
}
#line 163 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int open_oss(audio_output_t *ao___0 ) 
{ 
  char usingdefdev ;
  int tmp ;
  int e ;
  int mask ;
  int gain ;
  int gain___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 165
  usingdefdev = (char)0;
#line 167
  if (! ao___0) {
#line 167
    return (-1);
  }
#line 169
  if (! ao___0->device) {
#line 170
    ao___0->device = (char *)"/dev/dsp";
#line 171
    usingdefdev = (char)1;
  }
  {
#line 174
  ao___0->fn = open((char const   *)ao___0->device, 1);
  }
#line 176
  if (ao___0->fn < 0) {
#line 178
    if (usingdefdev) {
      {
#line 179
      ao___0->device = (char *)"/dev/sound/dsp";
#line 180
      ao___0->fn = open((char const   *)ao___0->device, 1);
      }
#line 181
      if (ao___0->fn < 0) {
#line 182
        if (! (ao___0->auxflags & 1)) {
          {
#line 182
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c:%i] error: Can\'t open default sound device!\n",
                  182);
          }
        }
#line 183
        return (-1);
      }
    } else {
#line 186
      if (! (ao___0->auxflags & 1)) {
        {
#line 186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c:%i] error: Can\'t open %s!\n",
                186, ao___0->device);
        }
      }
#line 187
      return (-1);
    }
  }
  {
#line 191
  tmp = reset_parameters_oss(ao___0);
  }
#line 191
  if (tmp < 0) {
    {
#line 192
    close(ao___0->fn);
    }
#line 193
    return (-1);
  }
#line 196
  if (ao___0->gain >= 0L) {
    {
#line 198
    e = ioctl(ao___0->fn, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 254U) | (sizeof(int ) << 16),
              & mask);
    }
#line 199
    if (e < 0) {
#line 200
      if (! (ao___0->auxflags & 1)) {
        {
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c:%i] error: audio/gain: Can\'t get audio device features list.\n",
                200);
        }
      }
    } else
#line 202
    if (mask & (1 << 4)) {
      {
#line 203
      gain = (int )((ao___0->gain << 8) | ao___0->gain);
#line 204
      e = ioctl(ao___0->fn, (unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 4U) | (sizeof(int ) << 16),
                & gain);
      }
    } else
#line 206
    if (! (mask & 1)) {
#line 207
      if (! (ao___0->auxflags & 1)) {
        {
#line 207
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c:%i] error: audio/gain: setable Volume/PCM-Level not supported by your audio device: %#04x\n",
                207, mask);
        }
      }
    } else {
      {
#line 210
      gain___0 = (int )((ao___0->gain << 8) | ao___0->gain);
#line 211
      e = ioctl(ao___0->fn, (unsigned long )((3U << 30) | (unsigned int )(77 << 8)) | (sizeof(int ) << 16),
                & gain___0);
      }
    }
  }
#line 215
  return (ao___0->fn);
}
}
#line 230
static int get_formats_oss(audio_output_t *ao___0 ) ;
#line 230 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int fmts[6]  = {      4,      208,      1,      130, 
        96,      8};
#line 223 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int get_formats_oss(audio_output_t *ao___0 ) 
{ 
  int fmt ;
  int r ;
  int c ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 225
  fmt = 0;
#line 226
  r = (int )ao___0->rate;
#line 227
  c = ao___0->channels;
#line 237
  ioctl(ao___0->fn, (unsigned long )((unsigned int )(80 << 8)), (void *)0);
#line 239
  i = 0;
  }
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (i < 6)) {
#line 239
      goto while_break;
    }
    {
#line 240
    ao___0->format = fmts[i];
#line 241
    tmp = set_format_oss(ao___0);
    }
#line 241
    if (tmp < 0) {
#line 242
      goto __Cont;
    }
    {
#line 244
    ao___0->channels = c;
#line 245
    tmp___0 = set_channels_oss(ao___0);
    }
#line 245
    if (tmp___0 < 0) {
#line 246
      goto __Cont;
    }
    {
#line 248
    ao___0->rate = (long )r;
#line 249
    tmp___1 = rate_best_match_oss(ao___0);
    }
#line 249
    if (tmp___1 < 0) {
#line 250
      goto __Cont;
    }
#line 252
    if (ao___0->rate * 100L > (long )(r * 97)) {
#line 252
      if (ao___0->rate * 100L < (long )(r * 103)) {
#line 253
        fmt |= fmts[i];
      }
    }
    __Cont: /* CIL Label */ 
#line 239
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  return (fmt);
}
}
#line 281 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int write_oss(audio_output_t *ao___0 , unsigned char *buf , int len ) 
{ 
  ssize_t tmp ;

  {
  {
#line 283
  tmp = write(ao___0->fn, (void const   *)buf, (size_t )len);
  }
#line 283
  return (tmp);
}
}
#line 286 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int close_oss(audio_output_t *ao___0 ) 
{ 


  {
  {
#line 288
  close(ao___0->fn);
  }
#line 289
  return (0);
}
}
#line 292 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static void flush_oss(audio_output_t *ao___0 ) 
{ 


  {
#line 294
  return;
}
}
#line 299 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
static int init_oss(audio_output_t *ao___0 ) 
{ 


  {
#line 301
  if ((unsigned long )ao___0 == (unsigned long )((void *)0)) {
#line 301
    return (-1);
  }
#line 304
  ao___0->open = & open_oss;
#line 305
  ao___0->flush = & flush_oss;
#line 306
  ao___0->write = & write_oss;
#line 307
  ao___0->get_formats = & get_formats_oss;
#line 308
  ao___0->close = & close_oss;
#line 311
  return (0);
}
}
#line 319 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/output/oss.c"
mpg123_module_t mpg123_output_module_info  =    {(int const   )1, "oss", "Output audio using OSS", "$Rev: 1445 $", (void *)0, & init_oss};
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 44 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/module.h"
mpg123_module_t *open_module(char const   *type , char const   *name ) ;
#line 45
void close_module(mpg123_module_t *module ) ;
#line 46
void list_modules(void) ;
#line 18 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/legacy_module.c"
mpg123_module_t *open_module(char const   *type , char const   *name ) 
{ 
  mpg123_module_t *mod ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 21
  mod = (mpg123_module_t *)((void *)0);
#line 24
  tmp = strcmp(type, "output");
  }
#line 24
  if (tmp == 0) {
#line 25
    mod = & mpg123_output_module_info;
  } else {
    {
#line 31
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/legacy_module.c:%i] error: Unable to open module type \'%s\'.\n",
            31, type);
    }
#line 32
    return ((mpg123_module_t *)((void *)0));
  }
  {
#line 36
  tmp___0 = strcmp(name, mod->name);
  }
#line 36
  if (tmp___0 != 0) {
    {
#line 37
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/legacy_module.c:%i] error: Unable to open requested module \'%s\'.\n",
            37, name);
#line 38
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/legacy_module.c:%i] error: The only available statically compiled module is \'%s\'.\n",
            38, mod->name);
    }
#line 39
    return ((mpg123_module_t *)((void *)0));
  }
#line 50
  return (mod);
}
}
#line 54 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/legacy_module.c"
void close_module(mpg123_module_t *module ) 
{ 


  {
#line 59
  return;
}
}
#line 62 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/legacy_module.c"
void list_modules(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 66
  printf((char const   */* __restrict  */)"\nmpg123 has been built in legacy mode - dynamic modules are not available.\n");
#line 68
  printf((char const   */* __restrict  */)"Available modules\n");
#line 69
  printf((char const   */* __restrict  */)"-----------------\n");
#line 70
  printf((char const   */* __restrict  */)"%-15s%s  %s\n", mpg123_output_module_info.name,
         "output", mpg123_output_module_info.description);
  }
#line 72
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 819 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 126 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 48 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.h"
void xfermem_init(txfermem **xf , size_t bufsize , size_t msize , size_t skipbuf ) ;
#line 49
void xfermem_init_writer(txfermem *xf ) ;
#line 50
void xfermem_init_reader(txfermem *xf ) ;
#line 52
size_t xfermem_get_freespace(txfermem *xf ) ;
#line 53
size_t xfermem_get_usedspace(txfermem *xf ) ;
#line 62
int xfermem_getcmd(int fd , int block___0 ) ;
#line 63
int xfermem_putcmd(int fd , byte cmd ) ;
#line 64
int xfermem_block(int readwrite , txfermem *xf ) ;
#line 65
int xfermem_sigblock(int readwrite , txfermem *xf , int pid , int signal___0 ) ;
#line 67
int xfermem_write(txfermem *xf , byte *buffer , size_t bytes ) ;
#line 69
void xfermem_done(txfermem *xf ) ;
#line 62 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off64_t __offset )  __asm__("mmap64")  ;
#line 77
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 111 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 34 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
void xfermem_init(txfermem **xf , size_t bufsize , size_t msize , size_t skipbuf ) 
{ 
  size_t regsize ;
  txfermem *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 36
  regsize = (size_t )((unsigned long )((bufsize + msize) + skipbuf) + sizeof(txfermem ));
#line 40
  tmp___0 = mmap((void *)0, regsize, 3, 33, -1, (__off64_t )0);
#line 40
  tmp = (txfermem *)tmp___0;
#line 40
  *xf = tmp;
  }
#line 40
  if ((unsigned long )tmp == (unsigned long )((txfermem *)-1)) {
    {
#line 42
    perror("mmap()");
#line 43
    exit(1);
    }
  }
  {
#line 76
  tmp___1 = socketpair(1, 1, 0, (int *)((*xf)->fd));
  }
#line 76
  if (tmp___1 < 0) {
    {
#line 77
    perror("socketpair()");
#line 78
    xfermem_done(*xf);
#line 79
    exit(1);
    }
  }
#line 81
  tmp___2 = (size_t )0;
#line 81
  (*xf)->readindex = tmp___2;
#line 81
  (*xf)->freeindex = tmp___2;
#line 82
  tmp___3 = 0;
#line 82
  (*xf)->wakeme[1] = tmp___3;
#line 82
  (*xf)->wakeme[0] = tmp___3;
#line 83
  (*xf)->data = ((byte *)*xf + sizeof(txfermem )) + msize;
#line 84
  (*xf)->metadata = (byte *)*xf + sizeof(txfermem );
#line 85
  (*xf)->size = bufsize;
#line 86
  (*xf)->metasize = msize + skipbuf;
#line 87
  (*xf)->justwait = 0;
#line 88
  return;
}
}
#line 90 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
void xfermem_done(txfermem *xf ) 
{ 


  {
#line 92
  if (! xf) {
#line 93
    return;
  }
  {
#line 95
  munmap((void *)((caddr_t )xf), (size_t )((unsigned long )(xf->size + xf->metasize) + sizeof(txfermem )));
  }
#line 102
  return;
}
}
#line 104 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
void xfermem_init_writer(txfermem *xf ) 
{ 


  {
#line 106
  if (xf) {
    {
#line 107
    close(xf->fd[1]);
    }
  }
#line 108
  return;
}
}
#line 110 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
void xfermem_init_reader(txfermem *xf ) 
{ 


  {
#line 112
  if (xf) {
    {
#line 113
    close(xf->fd[0]);
    }
  }
#line 114
  return;
}
}
#line 116 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
size_t xfermem_get_freespace(txfermem *xf ) 
{ 
  size_t freeindex ;
  size_t readindex ;

  {
#line 120
  if (! xf) {
#line 121
    return ((size_t )0);
  }
#line 123
  freeindex = xf->freeindex;
#line 123
  if (freeindex < 0U) {
#line 125
    return ((size_t )0);
  } else {
#line 123
    readindex = xf->readindex;
#line 123
    if (readindex < 0U) {
#line 125
      return ((size_t )0);
    }
  }
#line 126
  if (readindex > freeindex) {
#line 127
    return ((readindex - freeindex) - 1U);
  } else {
#line 129
    return ((xf->size - (freeindex - readindex)) - 1U);
  }
}
}
#line 132 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
size_t xfermem_get_usedspace(txfermem *xf ) 
{ 
  size_t freeindex ;
  size_t readindex ;

  {
#line 136
  if (! xf) {
#line 137
    return ((size_t )0);
  }
#line 139
  freeindex = xf->freeindex;
#line 139
  if (freeindex < 0U) {
#line 141
    return ((size_t )0);
  } else {
#line 139
    readindex = xf->readindex;
#line 139
    if (readindex < 0U) {
#line 141
      return ((size_t )0);
    }
  }
#line 142
  if (freeindex >= readindex) {
#line 143
    return (freeindex - readindex);
  } else {
#line 145
    return (xf->size - (readindex - freeindex));
  }
}
}
#line 148 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
int xfermem_getcmd(int fd , int block___0 ) 
{ 
  fd_set selfds ;
  byte cmd ;
  struct timeval selto ;
  int __d0 ;
  int __d1 ;
  struct timeval *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    selto.tv_sec = (__time_t )0;
#line 154
    selto.tv_usec = (__suseconds_t )0;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& selfds.__fds_bits[0]): "memory");
#line 156
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 157
    selfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 161
    if (block___0) {
#line 161
      tmp = (struct timeval *)((void *)0);
    } else {
#line 161
      tmp = & selto;
    }
    {
#line 161
    tmp___0 = select(1024, (fd_set */* __restrict  */)(& selfds), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tmp);
    }
    {
#line 163
    if (tmp___0 == 0) {
#line 163
      goto case_0;
    }
#line 167
    if (tmp___0 == -1) {
#line 167
      goto case_neg_1;
    }
#line 171
    if (tmp___0 == 1) {
#line 171
      goto case_1;
    }
#line 187
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 164
    if (! block___0) {
#line 165
      return (0);
    }
#line 166
    goto __Cont;
    case_neg_1: /* CIL Label */ 
    {
#line 168
    tmp___1 = __errno_location();
    }
#line 168
    if (*tmp___1 == 4) {
#line 169
      goto __Cont;
    }
#line 170
    return (-2);
    case_1: /* CIL Label */ 
#line 172
    if ((selfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 173
      tmp___2 = read(fd, (void *)(& cmd), (size_t )1);
      }
      {
#line 174
      if (tmp___2 == 0) {
#line 174
        goto case_0___0;
      }
#line 176
      if (tmp___2 == -1) {
#line 176
        goto case_neg_1___0;
      }
#line 180
      if (tmp___2 == 1) {
#line 180
        goto case_1___0;
      }
#line 182
      goto switch_default;
      case_0___0: /* CIL Label */ 
#line 175
      return (-1);
      case_neg_1___0: /* CIL Label */ 
      {
#line 177
      tmp___3 = __errno_location();
      }
#line 177
      if (*tmp___3 == 4) {
#line 178
        goto __Cont;
      }
#line 179
      return (-3);
      case_1___0: /* CIL Label */ 
#line 181
      return ((int )cmd);
      switch_default: /* CIL Label */ 
#line 183
      return (-4);
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 186
      return (-5);
    }
    switch_default___0: /* CIL Label */ 
#line 188
    return (-6);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 193 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
int xfermem_putcmd(int fd , byte cmd ) 
{ 
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    tmp = write(fd, (void const   *)(& cmd), (size_t )1);
    }
    {
#line 197
    if (tmp == 1) {
#line 197
      goto case_1;
    }
#line 199
    if (tmp == -1) {
#line 199
      goto case_neg_1;
    }
#line 196
    goto switch_break;
    case_1: /* CIL Label */ 
#line 198
    return (1);
    case_neg_1: /* CIL Label */ 
    {
#line 200
    tmp___0 = __errno_location();
    }
#line 200
    if (*tmp___0 != 4) {
#line 201
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 206 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
int xfermem_block(int readwrite , txfermem *xf ) 
{ 
  int myfd ;
  int result ;
  int tmp ;

  {
#line 208
  myfd = xf->fd[readwrite];
#line 211
  xf->wakeme[readwrite] = 1;
#line 212
  if (xf->wakeme[1 - readwrite]) {
    {
#line 213
    xfermem_putcmd(myfd, (byte )2);
    }
  }
  {
#line 214
  result = xfermem_getcmd(myfd, 1);
#line 215
  xf->wakeme[readwrite] = 0;
  }
#line 216
  if (result <= 0) {
#line 216
    tmp = -1;
  } else {
#line 216
    tmp = result;
  }
#line 216
  return (tmp);
}
}
#line 220 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
int xfermem_sigblock(int readwrite , txfermem *xf , int pid , int signal___0 ) 
{ 
  int myfd ;
  int result ;
  int tmp ;

  {
  {
#line 222
  myfd = xf->fd[readwrite];
#line 225
  xf->wakeme[readwrite] = 1;
#line 226
  kill(pid, signal___0);
  }
#line 229
  if (xf->wakeme[1 - readwrite]) {
    {
#line 230
    xfermem_putcmd(myfd, (byte )2);
    }
  }
  {
#line 232
  result = xfermem_getcmd(myfd, 1);
#line 233
  xf->wakeme[readwrite] = 0;
  }
#line 235
  if (result <= 0) {
#line 235
    tmp = -1;
  } else {
#line 235
    tmp = result;
  }
#line 235
  return (tmp);
}
}
#line 238 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c"
int xfermem_write(txfermem *xf , byte *buffer , size_t bytes ) 
{ 
  int cmd ;
  int tmp ;
  size_t tmp___0 ;
  size_t endblock ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 240
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 240
    return (0);
  } else
#line 240
  if (bytes < 1U) {
#line 240
    return (0);
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    tmp___0 = xfermem_get_freespace(xf);
    }
#line 243
    if (! (tmp___0 < bytes)) {
#line 243
      goto while_break;
    }
    {
#line 245
    tmp = xfermem_block(0, xf);
#line 245
    cmd = tmp;
    }
#line 246
    if (cmd == 3) {
      {
#line 248
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c:%i] error: failed to wait for free space\n",
              248);
      }
#line 249
      return (1);
    } else
#line 246
    if (cmd < 0) {
      {
#line 248
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/xfermem.c:%i] error: failed to wait for free space\n",
              248);
      }
#line 249
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (xf->size - xf->freeindex >= bytes) {
    {
#line 255
    memcpy((void */* __restrict  */)(xf->data + xf->freeindex), (void const   */* __restrict  */)buffer,
           bytes);
    }
  } else {
    {
#line 259
    endblock = xf->size - xf->freeindex;
#line 260
    memcpy((void */* __restrict  */)(xf->data + xf->freeindex), (void const   */* __restrict  */)buffer,
           endblock);
#line 261
    memcpy((void */* __restrict  */)xf->data, (void const   */* __restrict  */)(buffer + endblock),
           bytes - endblock);
    }
  }
#line 264
  xf->freeindex = (xf->freeindex + bytes) % xf->size;
#line 267
  if (xf->wakeme[1]) {
    {
#line 268
    tmp___3 = xfermem_putcmd(xf->fd[0], (byte )4);
    }
#line 268
    if (tmp___3 < 0) {
#line 268
      tmp___2 = 1;
    } else {
#line 268
      tmp___2 = 0;
    }
#line 268
    return (tmp___2);
  }
#line 270
  return (0);
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 260
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 692 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 717
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 137 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
int cdr_open(audio_output_t *ao___0 ) ;
#line 138
int au_open(audio_output_t *ao___0 ) ;
#line 139
int wav_open(audio_output_t *ao___0 ) ;
#line 140
int wav_write(unsigned char *buf , int len ) ;
#line 141
int cdr_close(void) ;
#line 142
int au_close(void) ;
#line 143
int wav_close(void) ;
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_RIFF_56 RIFF  =    {{(byte )'R', (byte )'I', (byte )'F', (byte )'F'}, {(byte )sizeof(RIFF.WAVE), (byte )0,
                                                       (byte )0, (byte )0}, {{(byte )'W',
                                                                              (byte )'A',
                                                                              (byte )'V',
                                                                              (byte )'E'},
                                                                             {(byte )'f',
                                                                              (byte )'m',
                                                                              (byte )'t',
                                                                              (byte )' '},
                                                                             {(byte )sizeof(RIFF.WAVE.fmt),
                                                                              (byte )0,
                                                                              (byte )0,
                                                                              (byte )0},
                                                                             {{(byte )1,
                                                                               (byte )0},
                                                                              {(byte )0,
                                                                               (byte )0},
                                                                              {(byte )0,
                                                                               (byte )0,
                                                                               (byte )0,
                                                                               (byte )0},
                                                                              {(byte )0,
                                                                               (byte )0,
                                                                               (byte )0,
                                                                               (byte )0},
                                                                              {(byte )0,
                                                                               (byte )0},
                                                                              {(byte )0,
                                                                               (byte )0}},
                                                                             {{(byte )'d',
                                                                               (byte )'a',
                                                                               (byte )'t',
                                                                               (byte )'a'},
                                                                              {(byte )0,
                                                                               (byte )0,
                                                                               (byte )0,
                                                                               (byte )0}}}};
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wavhead.h"
struct __anonstruct_RIFF_FLOAT_60 RIFF_FLOAT  =    {{(byte )'R', (byte )'I', (byte )'F', (byte )'F'}, {(byte )sizeof(RIFF_FLOAT.WAVE),
                                                       (byte )0, (byte )0, (byte )0},
    {{(byte )'W', (byte )'A', (byte )'V', (byte )'E'}, {(byte )'f', (byte )'m', (byte )'t',
                                                        (byte )' '}, {(byte )sizeof(RIFF_FLOAT.WAVE.fmt),
                                                                      (byte )0, (byte )0,
                                                                      (byte )0}, {{(byte )3,
                                                                                   (byte )0},
                                                                                  {(byte )0,
                                                                                   (byte )0},
                                                                                  {(byte )0,
                                                                                   (byte )0,
                                                                                   (byte )0,
                                                                                   (byte )0},
                                                                                  {(byte )0,
                                                                                   (byte )0,
                                                                                   (byte )0,
                                                                                   (byte )0},
                                                                                  {(byte )0,
                                                                                   (byte )0},
                                                                                  {(byte )0,
                                                                                   (byte )0},
                                                                                  {(byte )0,
                                                                                   (byte )0}},
     {(byte )'f', (byte )'a', (byte )'c', (byte )'t'}, {(byte )sizeof(RIFF_FLOAT.WAVE.fact),
                                                        (byte )0, (byte )0, (byte )0},
     {{(byte )0, (byte )0, (byte )0, (byte )0}}, {{(byte )'d', (byte )'a', (byte )'t',
                                                   (byte )'a'}, {(byte )0, (byte )0,
                                                                 (byte )0, (byte )0}}}};
#line 36 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
struct auhead auhead  =    {{(byte )46, (byte )115, (byte )110, (byte )100}, {(byte )0, (byte )0, (byte )0,
                                                      (byte )32}, {(byte )255, (byte )255,
                                                                   (byte )255, (byte )255},
    {(byte )0, (byte )0, (byte )0, (byte )0}, {(byte )0, (byte )0, (byte )0, (byte )0},
    {(byte )0, (byte )0, (byte )0, (byte )0}, {(byte )0, (byte )0, (byte )0, (byte )0,
                                               (byte )0, (byte )0, (byte )0, (byte )0}};
#line 50 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static FILE *wavfp  ;
#line 51 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static int header_written  =    0;
#line 52 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static long datalen  =    0L;
#line 53 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static int flipendian  =    0;
#line 54 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
int bytes_per_sample  =    -1;
#line 55 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
int floatwav  =    0;
#line 60 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static void long2littleendian(long inval , byte *outval , int b ) 
{ 
  int i ;

  {
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < b)) {
#line 63
      goto while_break;
    }
#line 64
    *(outval + i) = (byte )((inval >> i * 8) & 255L);
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return;
}
}
#line 69 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static void long2bigendian(long inval , byte *outval , int b ) 
{ 
  int i ;

  {
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < b)) {
#line 72
      goto while_break;
    }
#line 73
    *(outval + i) = (byte )((inval >> ((b - i) - 1) * 8) & 255L);
#line 72
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 77 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static long from_little(byte *inval , int b ) 
{ 
  long ret ;
  int i ;

  {
#line 79
  ret = 0L;
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < b)) {
#line 81
      goto while_break;
    }
#line 81
    ret += (long )*(inval + i) << i * 8;
#line 81
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return (ret);
}
}
#line 86 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static int testEndian(void) 
{ 
  long i ;
  long a ;
  long b ;
  long c ;
  int ret ;
  char *__cil_tmp6 ;

  {
#line 88
  a = 0L;
#line 88
  b = 0L;
#line 88
  c = 0L;
#line 89
  ret = 0;
#line 91
  i = 0L;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned long )i < sizeof(long ))) {
#line 91
      goto while_break;
    }
#line 92
    *((byte *)(& a) + i) = (byte )i;
#line 93
    b <<= 8;
#line 94
    b |= i;
#line 95
    c |= i << i * 8L;
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if (a == b) {
#line 98
    ret = 1;
  } else
#line 99
  if (a != c) {
    {
#line 100
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c:%i] error: Strange endianess?? %08lx %08lx %08lx\n\n",
            100, a, b, c);
#line 101
    ret = -1;
    }
  }
#line 103
  return (ret);
}
}
#line 106 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static int open_file(char *filename ) 
{ 
  __uid_t tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 109
  tmp = getuid();
#line 109
  setuid(tmp);
#line 111
  tmp___0 = strcmp("-", (char const   *)filename);
  }
#line 111
  if (tmp___0) {
    {
#line 115
    wavfp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
    }
#line 116
    if (! wavfp) {
#line 117
      return (-1);
    }
  } else {
#line 112
    wavfp = stdout;
  }
#line 119
  return (0);
}
}
#line 122 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static void close_file(void) 
{ 


  {
#line 124
  if ((unsigned long )wavfp != (unsigned long )((void *)0)) {
#line 124
    if ((unsigned long )wavfp != (unsigned long )stdout) {
      {
#line 125
      fclose(wavfp);
      }
    }
  }
#line 127
  wavfp = (FILE *)((void *)0);
#line 128
  return;
}
}
#line 131 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
static size_t write_header(void const   *ptr , size_t size ) 
{ 
  size_t tmp ;

  {
#line 133
  if ((unsigned long )wavfp == (unsigned long )stdout) {
#line 135
    if (header_written) {
#line 135
      return ((size_t )1);
    }
#line 137
    header_written = 1;
  }
  {
#line 139
  tmp = fwrite((void const   */* __restrict  */)ptr, size, (size_t )1, (FILE */* __restrict  */)wavfp);
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
int au_open(audio_output_t *ao___0 ) 
{ 
  int endiantest ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 144
  if (ao___0->format < 0) {
#line 144
    ao___0->format = 208;
  }
#line 146
  if (ao___0->format & 3584) {
    {
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c:%i] error: AU file support for float values not there yet\n",
            148);
    }
#line 149
    return (-1);
  }
#line 152
  flipendian = 0;
#line 154
  if (ao___0->rate < 0L) {
#line 154
    ao___0->rate = 44100L;
  }
#line 155
  if (ao___0->channels < 0) {
#line 155
    ao___0->channels = 2;
  }
  {
#line 158
  if (ao___0->format == 208) {
#line 158
    goto case_208;
  }
#line 166
  if (ao___0->format == 1) {
#line 166
    goto case_1;
  }
#line 168
  if (ao___0->format == 4) {
#line 168
    goto case_4;
  }
#line 171
  goto switch_default;
  case_208: /* CIL Label */ 
  {
#line 160
  tmp = testEndian();
#line 160
  endiantest = tmp;
  }
#line 161
  if (endiantest == -1) {
#line 161
    return (-1);
  }
  {
#line 162
  flipendian = ! endiantest;
#line 163
  long2bigendian(3L, auhead.encoding, (int )sizeof(auhead.encoding));
  }
#line 165
  goto switch_break;
  case_1: /* CIL Label */ 
#line 167
  ao___0->format = 4;
  case_4: /* CIL Label */ 
  {
#line 169
  long2bigendian(1L, auhead.encoding, (int )sizeof(auhead.encoding));
  }
#line 170
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 172
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c:%i] error: AU output is only a hack. This audio mode isn\'t supported yet.\n",
          172);
  }
#line 173
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 176
  long2bigendian(4294967295L, auhead.datalen, (int )sizeof(auhead.datalen));
#line 177
  long2bigendian(ao___0->rate, auhead.rate, (int )sizeof(auhead.rate));
#line 178
  long2bigendian((long )ao___0->channels, auhead.channels, (int )sizeof(auhead.channels));
#line 180
  tmp___0 = open_file(ao___0->device);
  }
#line 180
  if (tmp___0 < 0) {
#line 181
    return (-1);
  }
  {
#line 183
  write_header((void const   *)(& auhead), (size_t )sizeof(auhead));
#line 184
  datalen = 0L;
  }
#line 186
  return (0);
}
}
#line 189 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
int cdr_open(audio_output_t *ao___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 191
  if (ao___0->format < 0) {
#line 191
    if (ao___0->rate < 0L) {
#line 191
      if (ao___0->channels < 0) {
#line 194
        ao___0->format = 208;
#line 195
        ao___0->rate = 44100L;
#line 196
        ao___0->channels = 2;
      }
    }
  }
#line 198
  if (ao___0->format != 208) {
    {
#line 199
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Oops .. not forced to 16 bit, 44kHz?, stereo\n");
    }
#line 200
    return (-1);
  } else
#line 198
  if (ao___0->rate != 44100L) {
    {
#line 199
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Oops .. not forced to 16 bit, 44kHz?, stereo\n");
    }
#line 200
    return (-1);
  } else
#line 198
  if (ao___0->channels != 2) {
    {
#line 199
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Oops .. not forced to 16 bit, 44kHz?, stereo\n");
    }
#line 200
    return (-1);
  }
  {
#line 203
  tmp = testEndian();
  }
#line 203
  if (tmp) {
#line 203
    tmp___0 = 0;
  } else {
#line 203
    tmp___0 = 1;
  }
  {
#line 203
  flipendian = tmp___0;
#line 206
  tmp___1 = open_file(ao___0->device);
  }
#line 206
  if (tmp___1 < 0) {
#line 207
    return (-1);
  }
#line 209
  return (0);
}
}
#line 212 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
int wav_open(audio_output_t *ao___0 ) 
{ 
  int bps ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 216
  if (ao___0->format < 0) {
#line 216
    ao___0->format = 208;
  }
  {
#line 218
  flipendian = 0;
#line 221
  long2littleendian(1L, RIFF.WAVE.fmt.FormatTag, (int )sizeof(RIFF.WAVE.fmt.FormatTag));
#line 222
  floatwav = 0;
  }
#line 223
  if (ao___0->format == 512) {
    {
#line 225
    floatwav = 1;
#line 226
    long2littleendian(3L, RIFF_FLOAT.WAVE.fmt.FormatTag, (int )sizeof(RIFF_FLOAT.WAVE.fmt.FormatTag));
#line 227
    bps = 32;
#line 227
    long2littleendian((long )bps, RIFF_FLOAT.WAVE.fmt.BitsPerSample, (int )sizeof(RIFF_FLOAT.WAVE.fmt.BitsPerSample));
#line 228
    flipendian = testEndian();
    }
  } else
#line 230
  if (ao___0->format == 4480) {
    {
#line 231
    bps = 32;
#line 231
    long2littleendian((long )bps, RIFF.WAVE.fmt.BitsPerSample, (int )sizeof(RIFF.WAVE.fmt.BitsPerSample));
#line 232
    flipendian = testEndian();
    }
  } else
#line 234
  if (ao___0->format == 208) {
    {
#line 235
    bps = 16;
#line 235
    long2littleendian((long )bps, RIFF.WAVE.fmt.BitsPerSample, (int )sizeof(RIFF.WAVE.fmt.BitsPerSample));
#line 236
    flipendian = testEndian();
    }
  } else
#line 238
  if (ao___0->format == 1) {
    {
#line 239
    bps = 8;
#line 239
    long2littleendian((long )bps, RIFF.WAVE.fmt.BitsPerSample, (int )sizeof(RIFF.WAVE.fmt.BitsPerSample));
    }
  } else {
    {
#line 242
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c:%i] error: Format not supported.\n",
            242);
    }
#line 243
    return (-1);
  }
#line 246
  if (ao___0->rate < 0L) {
#line 246
    ao___0->rate = 44100L;
  }
#line 247
  if (ao___0->channels < 0) {
#line 247
    ao___0->channels = 2;
  }
#line 249
  if (floatwav) {
    {
#line 251
    long2littleendian((long )ao___0->channels, RIFF_FLOAT.WAVE.fmt.Channels, (int )sizeof(RIFF_FLOAT.WAVE.fmt.Channels));
#line 252
    long2littleendian(ao___0->rate, RIFF_FLOAT.WAVE.fmt.SamplesPerSec, (int )sizeof(RIFF_FLOAT.WAVE.fmt.SamplesPerSec));
#line 253
    long2littleendian((long )((int )(((long )ao___0->channels * ao___0->rate) * (long )bps) >> 3),
                      RIFF_FLOAT.WAVE.fmt.AvgBytesPerSec, (int )sizeof(RIFF_FLOAT.WAVE.fmt.AvgBytesPerSec));
#line 255
    long2littleendian((long )(ao___0->channels * bps >> 3), RIFF_FLOAT.WAVE.fmt.BlockAlign,
                      (int )sizeof(RIFF_FLOAT.WAVE.fmt.BlockAlign));
    }
  } else {
    {
#line 260
    long2littleendian((long )ao___0->channels, RIFF.WAVE.fmt.Channels, (int )sizeof(RIFF.WAVE.fmt.Channels));
#line 261
    long2littleendian(ao___0->rate, RIFF.WAVE.fmt.SamplesPerSec, (int )sizeof(RIFF.WAVE.fmt.SamplesPerSec));
#line 262
    long2littleendian((long )((int )(((long )ao___0->channels * ao___0->rate) * (long )bps) >> 3),
                      RIFF.WAVE.fmt.AvgBytesPerSec, (int )sizeof(RIFF.WAVE.fmt.AvgBytesPerSec));
#line 264
    long2littleendian((long )(ao___0->channels * bps >> 3), RIFF.WAVE.fmt.BlockAlign,
                      (int )sizeof(RIFF.WAVE.fmt.BlockAlign));
    }
  }
  {
#line 268
  tmp = open_file(ao___0->device);
  }
#line 268
  if (tmp < 0) {
#line 269
    return (-1);
  }
#line 271
  if (floatwav) {
    {
#line 273
    long2littleendian(datalen, RIFF_FLOAT.WAVE.data.datalen, (int )sizeof(RIFF_FLOAT.WAVE.data.datalen));
#line 274
    long2littleendian((long )((unsigned long )datalen + sizeof(RIFF_FLOAT.WAVE)),
                      RIFF_FLOAT.WAVElen, (int )sizeof(RIFF_FLOAT.WAVElen));
    }
  } else {
    {
#line 278
    long2littleendian(datalen, RIFF.WAVE.data.datalen, (int )sizeof(RIFF.WAVE.data.datalen));
#line 279
    long2littleendian((long )((unsigned long )datalen + sizeof(RIFF.WAVE)), RIFF.WAVElen,
                      (int )sizeof(RIFF.WAVElen));
    }
  }
#line 282
  if (floatwav) {
    {
#line 282
    tmp___2 = write_header((void const   *)(& RIFF_FLOAT), (size_t )sizeof(RIFF_FLOAT));
    }
#line 282
    if (! (tmp___2 == 1U)) {
#line 282
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 282
    tmp___3 = write_header((void const   *)(& RIFF), (size_t )sizeof(RIFF));
    }
#line 282
    if (! (tmp___3 == 1U)) {
      {
#line 285
      tmp___0 = __errno_location();
#line 285
      tmp___1 = strerror(*tmp___0);
#line 285
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c:%i] error: cannot write header: %s\n",
              285, tmp___1);
#line 286
      close_file();
      }
#line 287
      return (-1);
    }
  }
#line 290
  datalen = 0L;
#line 291
  bytes_per_sample = bps >> 3;
#line 293
  return (0);
}
}
#line 296 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
int wav_write(unsigned char *buf , int len ) 
{ 
  int temp ;
  int i ;
  int j ;
  unsigned char tmp[4] ;
  unsigned char tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 301
  if (! wavfp) {
#line 302
    return (0);
  }
#line 304
  if (flipendian) {
#line 306
    if (bytes_per_sample == 4) {
#line 308
      if (len & 3) {
        {
#line 310
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c:%i] error: Number of bytes no multiple of 4 (32bit)!\n",
                310);
        }
#line 311
        return (0);
      }
#line 313
      i = 0;
      {
#line 313
      while (1) {
        while_continue: /* CIL Label */ ;
#line 313
        if (! (i < len)) {
#line 313
          goto while_break;
        }
#line 317
        j = 0;
        {
#line 317
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 317
          if (! (j <= 3)) {
#line 317
            goto while_break___0;
          }
#line 317
          tmp[j] = *(buf + (i + j));
#line 317
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 318
        j = 0;
        {
#line 318
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 318
          if (! (j <= 3)) {
#line 318
            goto while_break___1;
          }
#line 318
          *(buf + (i + j)) = tmp[3 - j];
#line 318
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 313
        i += 4;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 323
      if (len & 1) {
        {
#line 325
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c:%i] error: Odd number of bytes!\n",
                325);
        }
#line 326
        return (0);
      }
#line 328
      i = 0;
      {
#line 328
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 328
        if (! (i < len)) {
#line 328
          goto while_break___2;
        }
#line 331
        tmp___0 = *(buf + i);
#line 332
        *(buf + i) = *(buf + (i + 1));
#line 333
        *(buf + (i + 1)) = tmp___0;
#line 328
        i += 2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 338
  tmp___1 = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )len,
                   (FILE */* __restrict  */)wavfp);
#line 338
  temp = (int )tmp___1;
  }
#line 339
  if (temp <= 0) {
#line 340
    return (0);
  }
#line 342
  datalen += (long )temp;
#line 344
  return (temp);
}
}
#line 347 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
int wav_close(void) 
{ 
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp4 ;

  {
#line 349
  if (! wavfp) {
#line 349
    return (0);
  }
  {
#line 351
  tmp___1 = fseek(wavfp, 0L, 0);
  }
#line 351
  if (tmp___1 >= 0) {
#line 353
    if (floatwav) {
      {
#line 355
      long2littleendian(datalen, RIFF_FLOAT.WAVE.data.datalen, (int )sizeof(RIFF_FLOAT.WAVE.data.datalen));
#line 356
      long2littleendian((long )((unsigned long )datalen + sizeof(RIFF_FLOAT.WAVE)),
                        RIFF_FLOAT.WAVElen, (int )sizeof(RIFF_FLOAT.WAVElen));
#line 357
      tmp = from_little(RIFF_FLOAT.WAVE.fmt.Channels, 2);
#line 357
      tmp___0 = from_little(RIFF_FLOAT.WAVE.fmt.BitsPerSample, 2);
#line 357
      long2littleendian(datalen / ((tmp * tmp___0) / 8L), RIFF_FLOAT.WAVE.fact.samplelen,
                        (int )sizeof(RIFF_FLOAT.WAVE.fact.samplelen));
#line 360
      fwrite((void const   */* __restrict  */)(& RIFF_FLOAT), (size_t )sizeof(RIFF_FLOAT),
             (size_t )1, (FILE */* __restrict  */)wavfp);
      }
    } else {
      {
#line 364
      long2littleendian(datalen, RIFF.WAVE.data.datalen, (int )sizeof(RIFF.WAVE.data.datalen));
#line 365
      long2littleendian((long )((unsigned long )datalen + sizeof(RIFF.WAVE)), RIFF.WAVElen,
                        (int )sizeof(RIFF.WAVElen));
#line 367
      fwrite((void const   */* __restrict  */)(& RIFF), (size_t )sizeof(RIFF), (size_t )1,
             (FILE */* __restrict  */)wavfp);
      }
    }
  } else {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c:%i] warning: Cannot rewind WAV file. File-format isn\'t fully conform now.\n",
            371);
    }
  }
  {
#line 373
  close_file();
  }
#line 374
  return (0);
}
}
#line 377 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
int au_close(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;

  {
#line 379
  if (! wavfp) {
#line 380
    return (0);
  }
  {
#line 382
  tmp = fseek(wavfp, 0L, 0);
  }
#line 382
  if (tmp >= 0) {
    {
#line 383
    long2bigendian(datalen, auhead.datalen, (int )sizeof(auhead.datalen));
#line 385
    fwrite((void const   */* __restrict  */)(& auhead), (size_t )sizeof(auhead), (size_t )1,
           (FILE */* __restrict  */)wavfp);
    }
  } else {
    {
#line 388
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c:%i] warning: Cannot rewind AU file. File-format isn\'t fully conform now.\n",
            388);
    }
  }
  {
#line 390
  close_file();
  }
#line 392
  return (0);
}
}
#line 395 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/wav.c"
int cdr_close(void) 
{ 


  {
#line 397
  if (! wavfp) {
#line 397
    return (0);
  }
  {
#line 399
  close_file();
  }
#line 400
  return (0);
}
}
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 103 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.h"
int set_pitch(mpg123_handle *fr , audio_output_t *ao___0 , double new_pitch ) ;
#line 112 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
off_t framenum ;
#line 116
txfermem *buffermem ;
#line 145
struct parameter param ;
#line 148
void next_track(void) ;
#line 149
void prev_track(void) ;
#line 152
void set_intflag(void) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.h"
void real_buffer_ignore_lowmem(void) ;
#line 22
void real_buffer_resync(void) ;
#line 25
void real_buffer_start(void) ;
#line 26
void real_buffer_stop(void) ;
#line 70 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.h"
void term_init(void) ;
#line 71
off_t term_control(mpg123_handle *fr , audio_output_t *ao___0 ) ;
#line 72
void term_restore(void) ;
#line 73
void term_hint(void) ;
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.h"
void print_header(mpg123_handle *mh___0 ) ;
#line 18
void print_stat(mpg123_handle *fr , long offset___0 , long buffsize ) ;
#line 19
void clear_stat(void) ;
#line 50 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.h"
void print_playlist(FILE *out , int showpos ) ;
#line 14 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/metaprint.h"
void print_id3_tag(mpg123_handle *mh___0 , int long_id3 , FILE *out ) ;
#line 26 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
static int term_enable  =    0;
#line 27 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
static struct termios old_tio  ;
#line 28 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
int seeking  =    0;
#line 33 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
struct keydef term_help[23]  = 
#line 33
  {      {(char const   )'s', (char const   )' ', "interrupt/restart playback (i.e. \'(un)pause\')"}, 
        {(char const   )'f',
      (char const   )0, "next track"}, 
        {(char const   )'d', (char const   )0, "previous track"}, 
        {(char const   )'b', (char const   )0, "back to beginning of track"}, 
        {(char const   )'p', (char const   )0, "loop around current position (like a damaged audio CD;-)"}, 
        {(char const   )'.',
      (char const   )0, "forward"}, 
        {(char const   )',', (char const   )0, "rewind"}, 
        {(char const   )':', (char const   )0, "fast forward"}, 
        {(char const   )';', (char const   )0, "fast rewind"}, 
        {(char const   )'>', (char const   )0, "fine forward"}, 
        {(char const   )'<', (char const   )0, "fine rewind"}, 
        {(char const   )'+', (char const   )0, "volume up"}, 
        {(char const   )'-', (char const   )0, "volume down"}, 
        {(char const   )'r', (char const   )0, "RVA switch"}, 
        {(char const   )'v', (char const   )0, "verbose switch"}, 
        {(char const   )'l', (char const   )0, "list current playlist, indicating current track there"}, 
        {(char const   )'t',
      (char const   )0, "display tag info (again)"}, 
        {(char const   )'m', (char const   )0, "print MPEG header info (again)"}, 
        {(char const   )'h', (char const   )0, "this help"}, 
        {(char const   )'q', (char const   )0, "quit"}, 
        {(char const   )'c', (char const   )'C', "pitch up (small step, big step)"}, 
        {(char const   )'x', (char const   )'X', "pitch down (small step, big step)"}, 
        {(char const   )'w',
      (char const   )0, "reset pitch to zero"}};
#line 60
void term_sigcont(int sig ) ;
#line 63 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
int term_setup(struct termios *pattern ) 
{ 
  struct termios tio ;
  int tmp ;

  {
  {
#line 65
  tio = *pattern;
#line 67
  signal(18, & term_sigcont);
#line 69
  tio.c_lflag &= 4294967285U;
#line 70
  tio.c_cc[6] = (cc_t )1;
#line 71
  tio.c_cc[5] = (cc_t )0;
#line 72
  tmp = tcsetattr(0, 0, (struct termios  const  *)(& tio));
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
void term_sigcont(int sig ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 77
  term_enable = 0;
#line 79
  tmp = term_setup(& old_tio);
  }
#line 79
  if (tmp < 0) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t set terminal attributes\n");
    }
#line 81
    return;
  }
#line 84
  term_enable = 1;
#line 85
  return;
}
}
#line 88 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
void term_init(void) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 92
  term_enable = 0;
#line 94
  tmp = tcgetattr(0, & old_tio);
  }
#line 94
  if (tmp < 0) {
    {
#line 95
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t get terminal attributes\n");
    }
#line 96
    return;
  }
  {
#line 98
  tmp___0 = term_setup(& old_tio);
  }
#line 98
  if (tmp___0 < 0) {
    {
#line 99
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t set terminal attributes\n");
    }
#line 100
    return;
  }
#line 103
  term_enable = 1;
#line 104
  return;
}
}
#line 106 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
void term_hint(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 108
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nTerminal control enabled, press \'h\' for listing of keys and functions.\n\n");
  }
#line 109
  return;
}
}
#line 111
static void term_handle_input(mpg123_handle *fr , audio_output_t *ao___0 , int do_delay ) ;
#line 113 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
static int stopped  =    0;
#line 114 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
static int paused  =    0;
#line 115 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
static int pause_cycle  ;
#line 117 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
static int print_index(mpg123_handle *mh___0 ) 
{ 
  int err ;
  size_t c ;
  size_t fill ;
  off_t *index___0 ;
  off_t step___30 ;
  char const   *tmp ;
  off_t tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 123
  err = (int )mpg123_index_64(mh___0, & index___0, & step___30, & fill);
  }
#line 124
  if (err == -1) {
    {
#line 126
    tmp = (char const   *)mpg123_strerror(mh___0);
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error accessing frame index: %s\n",
            tmp);
    }
#line 127
    return (err);
  }
#line 129
  c = (size_t )0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (c < fill)) {
#line 129
      goto while_break;
    }
#line 130
    if (c) {
#line 130
      tmp___0 = *(index___0 + c) - *(index___0 + (c - 1U));
    } else {
#line 130
      tmp___0 = (off_t )0;
    }
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%lu] %lu: %li (+%li)\n",
            (unsigned long )c, (unsigned long )((off_t )c * step___30), (long )*(index___0 + c),
            (long )tmp___0);
#line 129
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return (0);
}
}
#line 138 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
static off_t offset  =    (off_t )0;
#line 141 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
void pause_recycle(mpg123_handle *fr ) 
{ 
  double tmp ;

  {
  {
#line 145
  tmp = (double )mpg123_tpf(fr);
#line 145
  pause_cycle = (int )(0.500000 / tmp);
#line 146
  offset -= (off_t )pause_cycle;
  }
#line 147
  return;
}
}
#line 150 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
void pause_uncycle(void) 
{ 


  {
#line 152
  offset += (off_t )pause_cycle;
#line 153
  return;
}
}
#line 155 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
off_t term_control(mpg123_handle *fr , audio_output_t *ao___0 ) 
{ 
  size_t tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 157
  offset = (off_t )0;
#line 159
  if (! term_enable) {
#line 159
    return ((off_t )0);
  }
#line 161
  if (paused) {
#line 164
    pause_cycle --;
#line 164
    if (pause_cycle < 0) {
      {
#line 166
      pause_recycle(fr);
      }
#line 167
      if (param.usebuffer) {
        {
#line 169
        while (1) {
          while_continue: /* CIL Label */ ;
#line 169
          if (paused) {
            {
#line 169
            tmp = xfermem_get_usedspace(buffermem);
            }
#line 169
            if (! tmp) {
#line 169
              goto while_break;
            }
          } else {
#line 169
            goto while_break;
          }
#line 171
          if (param.usebuffer) {
            {
#line 171
            real_buffer_ignore_lowmem();
            }
          }
          {
#line 172
          term_handle_input(fr, ao___0, 1);
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 175
        if (! paused) {
          {
#line 175
          pause_uncycle();
          }
        }
      }
    }
  }
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 182
    term_handle_input(fr, ao___0, stopped | seeking);
    }
#line 183
    if (offset < 0LL) {
#line 183
      if (- offset > framenum) {
#line 183
        offset = - framenum;
      }
    }
#line 184
    if (param.verbose) {
#line 184
      if (offset != 0LL) {
        {
#line 185
        print_stat(fr, (long )offset, 0L);
        }
      }
    }
#line 180
    if (! stopped) {
#line 180
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  if (offset) {
    {
#line 192
    offset = (off_t )mpg123_seek_frame_64(fr, offset, 1);
    }
#line 192
    if (! (offset >= 0LL)) {
      {
#line 194
      tmp___0 = (char const   *)mpg123_strerror(fr);
#line 194
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c:%i] error: seek failed: %s!\n",
              194, tmp___0);
      }
    }
  }
#line 198
  return ((off_t )0);
}
}
#line 202 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
static void seekmode(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
#line 204
  if (param.usebuffer) {
#line 204
    if (! stopped) {
#line 206
      stopped = 1;
#line 207
      if (param.usebuffer) {
        {
#line 207
        real_buffer_stop();
        }
      }
      {
#line 208
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              "Stopped.\b\b\b\b\b\b\b\b");
      }
    }
  }
#line 210
  return;
}
}
#line 212 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
static void term_handle_input(mpg123_handle *fr , audio_output_t *ao___0 , int do_delay ) 
{ 
  int n ;
  fd_set r ;
  struct timeval t ;
  char val ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp ;
  int tmp___0 ;
  double tmp___1 ;
  char const   *tmp___2 ;
  off_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  double new_pitch ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int i ;
  long accurate ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *curdec ;
  char const   *tmp___11 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
#line 214
  n = 1;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (n > 0)) {
#line 217
      goto while_break;
    }
#line 222
    t.tv_sec = (__time_t )0;
#line 223
    if (do_delay) {
#line 223
      t.tv_usec = (__suseconds_t )10000;
    } else {
#line 223
      t.tv_usec = (__suseconds_t )0;
    }
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& r.__fds_bits[0]): "memory");
#line 225
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 226
    r.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 227
    n = select(1, (fd_set */* __restrict  */)(& r), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& t));
    }
#line 228
    if (n > 0) {
#line 228
      if ((r.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 229
        tmp = read(0, (void *)(& val), (size_t )1);
        }
#line 229
        if (tmp <= 0) {
#line 230
          goto while_break;
        }
        {
#line 232
        tmp___0 = tolower((int )val);
        }
        {
#line 233
        if (tmp___0 == 98) {
#line 233
          goto case_98;
        }
#line 243
        if (tmp___0 == 102) {
#line 243
          goto case_102;
        }
#line 248
        if (tmp___0 == 113) {
#line 248
          goto case_113;
        }
#line 262
        if (tmp___0 == 112) {
#line 262
          goto case_112;
        }
#line 279
        if (tmp___0 == 32) {
#line 279
          goto case_32;
        }
#line 279
        if (tmp___0 == 115) {
#line 279
          goto case_32;
        }
#line 300
        if (tmp___0 == 60) {
#line 300
          goto case_60;
        }
#line 304
        if (tmp___0 == 62) {
#line 304
          goto case_62;
        }
#line 308
        if (tmp___0 == 44) {
#line 308
          goto case_44;
        }
#line 312
        if (tmp___0 == 46) {
#line 312
          goto case_46;
        }
#line 316
        if (tmp___0 == 59) {
#line 316
          goto case_59;
        }
#line 320
        if (tmp___0 == 58) {
#line 320
          goto case_58;
        }
#line 324
        if (tmp___0 == 43) {
#line 324
          goto case_43;
        }
#line 327
        if (tmp___0 == 45) {
#line 327
          goto case_45;
        }
#line 334
        if (tmp___0 == 119) {
#line 334
          goto case_119;
        }
#line 334
        if (tmp___0 == 88) {
#line 334
          goto case_119;
        }
#line 334
        if (tmp___0 == 120) {
#line 334
          goto case_119;
        }
#line 334
        if (tmp___0 == 67) {
#line 334
          goto case_119;
        }
#line 334
        if (tmp___0 == 99) {
#line 334
          goto case_119;
        }
#line 349
        if (tmp___0 == 118) {
#line 349
          goto case_118;
        }
#line 358
        if (tmp___0 == 114) {
#line 358
          goto case_114;
        }
#line 363
        if (tmp___0 == 100) {
#line 363
          goto case_100;
        }
#line 369
        if (tmp___0 == 108) {
#line 369
          goto case_108;
        }
#line 374
        if (tmp___0 == 116) {
#line 374
          goto case_116;
        }
#line 379
        if (tmp___0 == 109) {
#line 379
          goto case_109;
        }
#line 385
        if (tmp___0 == 104) {
#line 385
          goto case_104;
        }
#line 400
        if (tmp___0 == 73) {
#line 400
          goto case_73;
        }
#line 400
        if (tmp___0 == 105) {
#line 400
          goto case_73;
        }
#line 422
        goto switch_default;
        case_98: /* CIL Label */ 
#line 234
        if (! param.usebuffer) {
          {
#line 234
          (*(ao___0->flush))(ao___0);
          }
        } else
#line 235
        if (param.usebuffer) {
          {
#line 235
          real_buffer_resync();
          }
        }
#line 236
        if (paused) {
          {
#line 236
          tmp___1 = (double )mpg123_tpf(fr);
#line 236
          pause_cycle = (int )(0.500000 / tmp___1);
          }
        }
        {
#line 238
        tmp___3 = (off_t )mpg123_seek_frame_64(fr, (off_t )0, 0);
        }
#line 238
        if (tmp___3 < 0LL) {
          {
#line 239
          tmp___2 = (char const   *)mpg123_strerror(fr);
#line 239
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c:%i] error: Seek to begin failed: %s\n",
                  239, tmp___2);
          }
        }
#line 241
        framenum = (off_t )0;
#line 242
        goto switch_break;
        case_102: /* CIL Label */ 
#line 244
        if (! param.usebuffer) {
          {
#line 244
          (*(ao___0->flush))(ao___0);
          }
        } else
#line 245
        if (param.usebuffer) {
          {
#line 245
          real_buffer_resync();
          }
        }
        {
#line 246
        next_track();
        }
#line 247
        goto switch_break;
        case_113: /* CIL Label */ ;
#line 250
        if (stopped) {
#line 252
          stopped = 0;
#line 253
          if (param.usebuffer) {
#line 255
            if (param.usebuffer) {
              {
#line 255
              real_buffer_resync();
              }
            }
#line 256
            if (param.usebuffer) {
              {
#line 256
              real_buffer_start();
              }
            }
          }
        }
        {
#line 259
        set_intflag();
#line 260
        offset = (off_t )0;
        }
#line 261
        goto switch_break;
        case_112: /* CIL Label */ 
#line 263
        paused = 1 - paused;
#line 264
        if (paused) {
#line 267
          if (param.usebuffer) {
#line 267
            if (param.usebuffer) {
              {
#line 267
              real_buffer_resync();
              }
            }
          }
          {
#line 269
          pause_recycle(fr);
          }
        }
#line 271
        if (stopped) {
#line 273
          stopped = 0;
#line 274
          if (param.usebuffer) {
#line 274
            if (param.usebuffer) {
              {
#line 274
              real_buffer_start();
              }
            }
          }
        }
#line 276
        if (paused) {
#line 276
          tmp___4 = "Paused. \b\b\b\b\b\b\b\b";
        } else {
#line 276
          tmp___4 = "        \b\b\b\b\b\b\b\b";
        }
        {
#line 276
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                tmp___4);
        }
#line 277
        goto switch_break;
        case_32: /* CIL Label */ 
        case_115: /* CIL Label */ 
#line 281
        if (! param.usebuffer) {
          {
#line 281
          (*(ao___0->flush))(ao___0);
          }
        }
#line 282
        stopped = 1 - stopped;
#line 283
        if (paused) {
#line 284
          paused = 0;
#line 285
          offset -= (off_t )pause_cycle;
        }
#line 287
        if (param.usebuffer) {
#line 289
          if (stopped) {
#line 289
            if (param.usebuffer) {
              {
#line 289
              real_buffer_stop();
              }
            }
          } else {
#line 293
            if (offset) {
#line 293
              if (param.usebuffer) {
                {
#line 293
                real_buffer_resync();
                }
              }
            }
#line 295
            if (param.usebuffer) {
              {
#line 295
              real_buffer_start();
              }
            }
          }
        }
#line 298
        if (stopped) {
#line 298
          tmp___5 = "Stopped.\b\b\b\b\b\b\b\b";
        } else {
#line 298
          tmp___5 = "        \b\b\b\b\b\b\b\b";
        }
        {
#line 298
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                tmp___5);
        }
#line 299
        goto switch_break;
        case_60: /* CIL Label */ 
#line 301
        if (param.usebuffer) {
          {
#line 301
          seekmode();
          }
        }
#line 302
        offset --;
#line 303
        goto switch_break;
        case_62: /* CIL Label */ 
        {
#line 305
        seekmode();
#line 306
        offset ++;
        }
#line 307
        goto switch_break;
        case_44: /* CIL Label */ 
        {
#line 309
        seekmode();
#line 310
        offset -= 10LL;
        }
#line 311
        goto switch_break;
        case_46: /* CIL Label */ 
        {
#line 313
        seekmode();
#line 314
        offset += 10LL;
        }
#line 315
        goto switch_break;
        case_59: /* CIL Label */ 
        {
#line 317
        seekmode();
#line 318
        offset -= 50LL;
        }
#line 319
        goto switch_break;
        case_58: /* CIL Label */ 
        {
#line 321
        seekmode();
#line 322
        offset += 50LL;
        }
#line 323
        goto switch_break;
        case_43: /* CIL Label */ 
        {
#line 325
        mpg123_volume_change(fr, 0.02);
        }
#line 326
        goto switch_break;
        case_45: /* CIL Label */ 
        {
#line 328
        mpg123_volume_change(fr, - 0.02);
        }
#line 329
        goto switch_break;
        case_119: /* CIL Label */ 
        case_88: /* CIL Label */ 
        case_120: /* CIL Label */ 
        case_67: /* CIL Label */ 
        case_99: /* CIL Label */ 
#line 336
        new_pitch = param.pitch;
        {
#line 339
        if ((int )val == 99) {
#line 339
          goto case_99___0;
        }
#line 340
        if ((int )val == 67) {
#line 340
          goto case_67___0;
        }
#line 341
        if ((int )val == 120) {
#line 341
          goto case_120___0;
        }
#line 342
        if ((int )val == 88) {
#line 342
          goto case_88___0;
        }
#line 343
        if ((int )val == 119) {
#line 343
          goto case_119___0;
        }
#line 337
        goto switch_break___0;
        case_99___0: /* CIL Label */ 
#line 339
        new_pitch += 0.001;
#line 339
        goto switch_break___0;
        case_67___0: /* CIL Label */ 
#line 340
        new_pitch += 0.01;
#line 340
        goto switch_break___0;
        case_120___0: /* CIL Label */ 
#line 341
        new_pitch -= 0.001;
#line 341
        goto switch_break___0;
        case_88___0: /* CIL Label */ 
#line 342
        new_pitch -= 0.01;
#line 342
        goto switch_break___0;
        case_119___0: /* CIL Label */ 
#line 343
        new_pitch = 0.0;
#line 343
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 345
        set_pitch(fr, ao___0, new_pitch);
#line 346
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"New pitch: %f\n",
                param.pitch);
        }
#line 348
        goto switch_break;
        case_118: /* CIL Label */ 
#line 350
        (param.verbose) ++;
#line 351
        if (param.verbose > 3) {
          {
#line 353
          param.verbose = 0;
#line 354
          clear_stat();
          }
        }
        {
#line 356
        mpg123_param(fr, (enum mpg123_parms )0, (long )param.verbose, (double )0);
        }
#line 357
        goto switch_break;
        case_114: /* CIL Label */ 
#line 359
        (param.rva) ++;
#line 359
        if (param.rva > 2L) {
#line 359
          param.rva = 0L;
        }
        {
#line 360
        mpg123_param(fr, (enum mpg123_parms )5, param.rva, (double )0);
#line 361
        mpg123_volume_change(fr, 0.);
        }
#line 362
        goto switch_break;
        case_100: /* CIL Label */ 
#line 364
        if (! param.usebuffer) {
          {
#line 364
          (*(ao___0->flush))(ao___0);
          }
        } else
#line 365
        if (param.usebuffer) {
          {
#line 365
          real_buffer_resync();
          }
        }
        {
#line 367
        prev_track();
        }
#line 368
        goto switch_break;
        case_108: /* CIL Label */ 
#line 370
        if (param.verbose) {
#line 370
          tmp___6 = "\n";
        } else {
#line 370
          tmp___6 = "";
        }
        {
#line 370
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\nPlaylist (\">\" indicates current track):\n",
                tmp___6);
#line 371
        print_playlist(stderr, 1);
#line 372
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
#line 373
        goto switch_break;
        case_116: /* CIL Label */ 
#line 375
        if (param.verbose) {
#line 375
          tmp___7 = "\n";
        } else {
#line 375
          tmp___7 = "";
        }
        {
#line 375
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                tmp___7);
#line 376
        print_id3_tag(fr, param.long_id3, stderr);
#line 377
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
#line 378
        goto switch_break;
        case_109: /* CIL Label */ 
#line 380
        if (param.verbose) {
          {
#line 380
          print_stat(fr, 0L, 0L);
          }
        }
        {
#line 381
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 382
        print_header(fr);
#line 383
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
#line 384
        goto switch_break;
        case_104: /* CIL Label */ 
        {
#line 388
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n -= terminal control keys =-\n");
#line 389
        i = 0;
        }
        {
#line 389
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 389
          if (! ((unsigned long )i < sizeof(term_help) / sizeof(struct keydef ))) {
#line 389
            goto while_break___1;
          }
#line 391
          if (term_help[i].key2) {
            {
#line 391
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%c] or [%c]",
                    (int const   )term_help[i].key, (int const   )term_help[i].key2);
            }
          } else {
            {
#line 392
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%c]",
                    (int const   )term_help[i].key);
            }
          }
          {
#line 394
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t%s\n",
                  term_help[i].desc);
#line 389
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 396
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
#line 398
        goto switch_break;
        case_73: /* CIL Label */ 
        case_105: /* CIL Label */ 
#line 401
        if (param.verbose) {
          {
#line 401
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
        {
#line 404
        if ((int )val == 105) {
#line 404
          goto case_105___0;
        }
#line 414
        if ((int )val == 73) {
#line 414
          goto case_73___0;
        }
#line 402
        goto switch_break___1;
        case_105___0: /* CIL Label */ 
        {
#line 405
        print_index(fr);
#line 408
        tmp___10 = (int )mpg123_getstate(fr, (enum mpg123_state )1, & accurate, (double *)((void *)0));
        }
#line 408
        if (tmp___10 == 0) {
#line 409
          if (accurate == 0L) {
#line 409
            tmp___8 = "no";
          } else {
#line 409
            tmp___8 = "yes";
          }
          {
#line 409
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accurate position: %s\n",
                  tmp___8);
          }
        } else {
          {
#line 411
          tmp___9 = (char const   *)mpg123_strerror(fr);
#line 411
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c:%i] error: Unable to get state: %s\n",
                  411, tmp___9);
          }
        }
#line 413
        goto switch_break___1;
        case_73___0: /* CIL Label */ 
        {
#line 416
        tmp___11 = (char const   *)mpg123_current_decoder(fr);
#line 416
        curdec = tmp___11;
        }
#line 417
        if ((unsigned long )curdec == (unsigned long )((void *)0)) {
          {
#line 417
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot get decoder info!\n");
          }
        } else {
          {
#line 418
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Active decoder: %s\n",
                  curdec);
          }
        }
        switch_break___1: /* CIL Label */ ;
        }
#line 421
        goto switch_break;
        switch_default: /* CIL Label */ ;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  return;
}
}
#line 429 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/term.c"
void term_restore(void) 
{ 


  {
#line 432
  if (! term_enable) {
#line 433
    return;
  }
  {
#line 435
  tcsetattr(0, 2, (struct termios  const  *)(& old_tio));
  }
#line 436
  return;
}
}
#line 327 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 330
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 282
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 31 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.h"
void httpdata_init(struct httpdata *e ) ;
#line 33
void httpdata_free(struct httpdata *e ) ;
#line 44
int debunk_mime(char const   *mime ) ;
#line 63
int http_open(char *url , struct httpdata *hd ) ;
#line 17 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.h"
int loptind ;
#line 41 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.h"
struct playlist_struct pl  ;
#line 44
void prepare_playlist(int argc___0 , char **argv___0 ) ;
#line 46
char *get_next_file(void) ;
#line 48
void free_playlist(void) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 43 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
int add_next_file(int argc___0 , char **argv___0 ) ;
#line 44
void shuffle_playlist(void) ;
#line 45
void init_playlist(void) ;
#line 46
int add_copy_to_playlist(char *new_entry ) ;
#line 47
int add_to_playlist(char *new_entry , char freeit ) ;
#line 50 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
void prepare_playlist(int argc___0 , char **argv___0 ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 57
  init_playlist();
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 58
    tmp = add_next_file(argc___0, argv___0);
    }
#line 58
    if (! tmp) {
#line 58
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if (param.verbose > 1) {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nplaylist in normal order:\n");
#line 62
    print_playlist(stderr, 0);
#line 63
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 65
  if (param.shuffle == 1) {
    {
#line 65
    shuffle_playlist();
    }
  }
  {
#line 67
  mpg123_free_string(& pl.linebuf);
#line 68
  mpg123_free_string(& pl.dir);
  }
#line 69
  return;
}
}
#line 72 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
static size_t rando(size_t n ) 
{ 
  long ran ;
  long limit ;

  {
#line 75
  limit = 2147483647L - 2147483647L % (long )n;
#line 76
  if (n < 2U) {
#line 76
    return ((size_t )0);
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    ran = random();
    }
#line 77
    if (! (ran >= limit)) {
#line 77
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return ((size_t )(ran % (long )n));
}
}
#line 81 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
char *get_next_file(void) 
{ 
  struct listitem *newitem ;

  {
#line 83
  newitem = (struct listitem *)((void *)0);
#line 85
  if (pl.fill == 0U) {
#line 85
    return ((char *)((void *)0));
  }
#line 87
  (pl.playcount) ++;
#line 90
  if (param.shuffle < 2) {
    {
#line 92
    while (1) {
      while_continue: /* CIL Label */ ;
#line 94
      if (pl.pos < pl.fill) {
#line 94
        newitem = pl.list + pl.pos;
      } else {
#line 95
        newitem = (struct listitem *)((void *)0);
      }
#line 97
      if (pl.loop > 0L) {
#line 97
        (pl.loop) --;
      }
#line 98
      if (pl.loop == 0L) {
#line 100
        pl.loop = param.loop;
#line 101
        (pl.pos) ++;
      }
#line 92
      if (pl.loop == 0L) {
#line 92
        if (! ((unsigned long )newitem != (unsigned long )((void *)0))) {
#line 92
          goto while_break;
        }
      } else {
#line 92
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 109
      pl.pos = rando(pl.fill);
      }
#line 107
      if ((pl.list + pl.pos)->playcount) {
#line 107
        if (! (pl.playcount - (pl.list + pl.pos)->playcount <= pl.fill / 2U)) {
#line 107
          goto while_break___0;
        }
      } else {
#line 107
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 112
    newitem = pl.list + pl.pos;
  }
#line 116
  if ((unsigned long )newitem != (unsigned long )((void *)0)) {
#line 119
    newitem->playcount = pl.playcount;
#line 120
    return (newitem->url);
  } else {
#line 122
    return ((char *)((void *)0));
  }
}
}
#line 127 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
void free_playlist(void) 
{ 


  {
#line 129
  if ((unsigned long )pl.list != (unsigned long )((void *)0)) {
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (! pl.fill) {
#line 132
        goto while_break;
      }
#line 134
      (pl.fill) --;
#line 136
      if ((pl.list + pl.fill)->freeit) {
        {
#line 136
        free((void *)(pl.list + pl.fill)->url);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 138
    free((void *)pl.list);
#line 139
    pl.list = (struct listitem *)((void *)0);
#line 140
    pl.size = (size_t )0;
    }
  }
  {
#line 143
  mpg123_free_string(& pl.linebuf);
#line 144
  mpg123_free_string(& pl.dir);
  }
#line 145
  return;
}
}
#line 148 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
void init_playlist(void) 
{ 
  time_t tmp ;

  {
  {
#line 150
  tmp = time((time_t *)((void *)0));
#line 150
  srandom((unsigned int )tmp);
#line 151
  pl.file = (FILE *)((void *)0);
#line 152
  pl.entry = (size_t )0;
#line 153
  pl.playcount = (size_t )0;
#line 154
  pl.size = (size_t )0;
#line 155
  pl.fill = (size_t )0;
#line 156
  pl.pos = (size_t )0;
#line 157
  pl.list = (struct listitem *)((void *)0);
#line 158
  pl.alloc_step = (size_t )10;
#line 159
  mpg123_init_string(& pl.dir);
#line 160
  mpg123_init_string(& pl.linebuf);
#line 161
  pl.type = (enum playlist_type )0;
#line 162
  pl.loop = param.loop;
  }
#line 166
  return;
}
}
#line 173 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
int add_next_file(int argc___0 , char **argv___0 ) 
{ 
  int firstline ;
  char *slashpos ;
  int tmp ;
  size_t line_offset ;
  int fd ;
  struct httpdata htd___0 ;
  int mimi ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  size_t have ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t i ;
  char *in_line ;
  int tmp___13 ;
  size_t need ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 175
  firstline = 0;
#line 178
  if ((unsigned int )pl.type == 3U) {
#line 178
    return (0);
  }
#line 181
  if (param.listname) {
    {
#line 185
    slashpos = strrchr((char const   *)param.listname, '/');
    }
#line 185
    if (slashpos) {
      {
#line 188
      tmp = (int )mpg123_resize_string(& pl.dir, (size_t )((slashpos + 2) - param.listname));
      }
#line 188
      if (tmp) {
        {
#line 190
        memcpy((void */* __restrict  */)pl.dir.p, (void const   */* __restrict  */)param.listname,
               pl.dir.size - 1U);
#line 191
        *(pl.dir.p + (pl.dir.size - 1U)) = (char)0;
        }
      } else {
        {
#line 195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c:%i] error: cannot allocate memory for list directory!\n",
                195);
#line 196
        pl.dir.size = (size_t )0;
        }
      }
    }
  }
#line 201
  if (param.listname) {
#line 201
    goto _L___2;
  } else
#line 201
  if (pl.file) {
    _L___2: /* CIL Label */ 
#line 203
    line_offset = (size_t )0;
#line 205
    if (! pl.file) {
#line 211
      if (! *(param.listname)) {
#line 213
        pl.file = stdin;
#line 214
        param.listname = (char *)((void *)0);
#line 215
        pl.entry = (size_t )0;
      } else {
        {
#line 211
        tmp___1 = strcmp((char const   *)param.listname, "-");
        }
#line 211
        if (tmp___1) {
          {
#line 217
          tmp___0 = strncmp((char const   *)param.listname, "http://", (size_t )7);
          }
#line 217
          if (tmp___0) {
            {
#line 283
            pl.file = fopen((char const   */* __restrict  */)param.listname, (char const   */* __restrict  */)"rb");
            }
#line 283
            if (pl.file) {
#line 291
              pl.entry = (size_t )0;
            } else {
              {
#line 285
              perror((char const   *)param.listname);
              }
#line 286
              return (0);
            }
          } else {
            {
#line 221
            httpdata_init(& htd___0);
#line 223
            fd = http_open(param.listname, & htd___0);
            }
#line 228
            if (! param.ignore_mime) {
#line 228
              if ((unsigned long )htd___0.content_type.p != (unsigned long )((void *)0)) {
                {
#line 232
                mimi = debunk_mime((char const   *)htd___0.content_type.p);
                }
#line 234
                if (mimi & 4) {
#line 234
                  pl.type = (enum playlist_type )1;
                } else
#line 235
                if (mimi & 8) {
#line 235
                  pl.type = (enum playlist_type )2;
                } else {
#line 239
                  if (fd >= 0) {
                    {
#line 239
                    close(fd);
                    }
                  }
#line 243
                  fd = -1;
#line 245
                  if (mimi & 1) {
#line 247
                    pl.type = (enum playlist_type )3;
#line 248
                    if (param.listentry < 0L) {
                      {
#line 250
                      printf((char const   */* __restrict  */)"#note you gave me a file url, no playlist, so...\n#entry 1\n%s\n",
                             param.listname);
                      }
#line 251
                      return (0);
                    } else {
                      {
#line 255
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: MIME type indicates that this is no playlist but an mpeg audio file... reopening as such.\n");
#line 256
                      add_to_playlist(param.listname, (char)0);
                      }
#line 257
                      return (1);
                    }
                  }
                  {
#line 260
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c:%i] error: Unknown playlist MIME type %s; maybe mpg123 can support it in future if you report this to the maintainer.\n",
                          260, htd___0.content_type.p);
                  }
                }
                {
#line 262
                httpdata_free(& htd___0);
                }
              }
            }
#line 264
            if (fd < 0) {
              {
#line 266
              param.listname = (char *)((void *)0);
#line 267
              pl.file = (FILE *)((void *)0);
#line 271
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c:%i] error: Invalid playlist from http_open()!\n\n",
                      271);
              }
            } else {
              {
#line 275
              pl.entry = (size_t )0;
#line 277
              pl.file = fdopen(fd, "r");
              }
            }
          }
        } else {
#line 213
          pl.file = stdin;
#line 214
          param.listname = (char *)((void *)0);
#line 215
          pl.entry = (size_t )0;
        }
      }
#line 293
      if (param.verbose) {
#line 293
        if (pl.file) {
#line 293
          if (param.listname) {
#line 293
            tmp___2 = (char const   *)param.listname;
          } else {
#line 293
            tmp___2 = "standard input";
          }
          {
#line 293
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using playlist from %s ...\n",
                  tmp___2);
          }
        }
      }
#line 294
      firstline = 1;
    }
    {
#line 298
    while (1) {
      while_continue: /* CIL Label */ ;
#line 298
      if (! pl.file) {
#line 298
        goto while_break;
      }
#line 309
      have = (size_t )0;
      {
#line 310
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 313
        if (pl.linebuf.size <= have + 1U) {
          {
#line 315
          tmp___3 = (int )mpg123_resize_string(& pl.linebuf, pl.linebuf.size + 100U);
          }
#line 315
          if (! tmp___3) {
            {
#line 317
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c:%i] error: cannot increase line buffer\n",
                    317);
            }
#line 318
            goto while_break___0;
          }
        }
        {
#line 323
        tmp___5 = fgets((char */* __restrict  */)(pl.linebuf.p + have), (int )(pl.linebuf.size - have),
                        (FILE */* __restrict  */)pl.file);
        }
#line 323
        if (tmp___5) {
          {
#line 328
          tmp___4 = strlen((char const   *)(pl.linebuf.p + have));
#line 328
          have += tmp___4;
          }
        } else {
#line 334
          goto while_break___0;
        }
#line 310
        if (have) {
#line 310
          if ((int )*(pl.linebuf.p + (have - 1U)) != 13) {
#line 310
            if (! ((int )*(pl.linebuf.p + (have - 1U)) != 10)) {
#line 310
              goto while_break___0;
            }
          } else {
#line 310
            goto while_break___0;
          }
        } else {
#line 310
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 337
      if (have) {
        {
#line 339
        tmp___6 = strcspn((char const   *)pl.linebuf.p, "\t\n\r");
#line 339
        *(pl.linebuf.p + tmp___6) = (char )'\000';
        }
#line 341
        if (firstline) {
#line 343
          if ((unsigned int )pl.type == 0U) {
            {
#line 345
            tmp___12 = strcmp("[playlist]", (char const   *)pl.linebuf.p);
            }
#line 345
            if (tmp___12) {
              {
#line 351
              tmp___7 = strncasecmp("#M3U", (char const   *)pl.linebuf.p, (size_t )4);
              }
#line 351
              if (tmp___7) {
                {
#line 351
                tmp___8 = strncasecmp("#EXTM3U", (char const   *)pl.linebuf.p, (size_t )7);
                }
#line 351
                if (tmp___8) {
#line 351
                  if ((unsigned long )param.listname != (unsigned long )((void *)0)) {
                    {
#line 351
                    tmp___9 = strrchr((char const   *)param.listname, '.');
                    }
#line 351
                    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
                      {
#line 351
                      tmp___10 = strrchr((char const   *)param.listname, '.');
#line 351
                      tmp___11 = strcasecmp(".m3u", (char const   *)tmp___10);
                      }
#line 351
                      if (tmp___11) {
#line 351
                        goto _L___1;
                      } else {
                        _L: /* CIL Label */ 
#line 360
                        if (param.verbose) {
                          {
#line 360
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: detected M3U playlist type\n");
                          }
                        }
#line 361
                        pl.type = (enum playlist_type )1;
                      }
                    } else {
#line 351
                      goto _L___1;
                    }
                  } else {
                    _L___1: /* CIL Label */ 
#line 365
                    if (param.verbose) {
                      {
#line 365
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: guessed M3U playlist type\n");
                      }
                    }
#line 366
                    pl.type = (enum playlist_type )1;
                  }
                } else {
#line 351
                  goto _L;
                }
              } else {
#line 351
                goto _L;
              }
            } else {
              {
#line 347
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: detected Shoutcast/Winamp PLS playlist\n");
#line 348
              pl.type = (enum playlist_type )2;
              }
#line 349
              goto while_continue;
            }
          } else
#line 371
          if (param.verbose) {
            {
#line 373
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Interpreting as ");
            }
            {
#line 376
            if ((unsigned int )pl.type == 1U) {
#line 376
              goto case_1;
            }
#line 377
            if ((unsigned int )pl.type == 2U) {
#line 377
              goto case_2;
            }
#line 378
            goto switch_default;
            case_1: /* CIL Label */ 
            {
#line 376
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"M3U");
            }
#line 376
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 377
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PLS (Winamp/Shoutcast)");
            }
#line 377
            goto switch_break;
            switch_default: /* CIL Label */ 
            {
#line 378
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"???");
            }
            switch_break: /* CIL Label */ ;
            }
            {
#line 380
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" playlist\n");
            }
          }
#line 383
          firstline = 0;
        }
#line 389
        i = (size_t )0;
        {
#line 389
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 389
          if (! ((int )*(pl.linebuf.p + i) != 0)) {
#line 389
            goto while_break___1;
          }
#line 391
          if ((int )*(pl.linebuf.p + i) == 92) {
#line 391
            *(pl.linebuf.p + i) = (char )'/';
          }
#line 389
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 395
        if ((int )*(pl.linebuf.p + 0) == 0) {
#line 395
          goto while_continue;
        }
#line 396
        if ((unsigned int )pl.type == 1U) {
#line 396
          if ((int )*(pl.linebuf.p + 0) == 35) {
#line 399
            if (param.listentry < 0L) {
              {
#line 399
              printf((char const   */* __restrict  */)"%s\n", pl.linebuf.p);
              }
            }
#line 400
            goto while_continue;
          }
        }
#line 404
        line_offset = (size_t )0;
#line 406
        if ((unsigned int )pl.type == 2U) {
          {
#line 408
          tmp___13 = strncasecmp("File", (char const   *)pl.linebuf.p, (size_t )4);
          }
#line 408
          if (tmp___13) {
#line 434
            if (param.listentry < 0L) {
              {
#line 434
              printf((char const   */* __restrict  */)"#metainfo %s\n", pl.linebuf.p);
              }
            }
#line 435
            goto while_continue;
          } else {
            {
#line 412
            in_line = strchr((char const   *)(pl.linebuf.p + 4), '=');
            }
#line 412
            if ((unsigned long )in_line != (unsigned long )((void *)0)) {
#line 415
              if ((int )*(in_line + 1) != 0) {
#line 417
                in_line ++;
#line 418
                line_offset = (size_t )(in_line - pl.linebuf.p);
              } else {
                {
#line 422
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Invalid PLS line (empty filename) - corrupt playlist file?\n");
                }
#line 423
                goto while_continue;
              }
            } else {
              {
#line 428
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Invalid PLS line (no \'=\' after \'File\') - corrupt playlist file?\n");
              }
#line 429
              goto while_continue;
            }
          }
        }
#line 441
        if ((unsigned long )pl.dir.p != (unsigned long )((void *)0)) {
#line 441
          if ((int )*(pl.linebuf.p + line_offset) != 47) {
#line 441
            if ((int )*(pl.linebuf.p + line_offset) != 92) {
              {
#line 441
              tmp___17 = strncmp((char const   *)(pl.linebuf.p + line_offset), "http://",
                                 (size_t )7);
              }
#line 441
              if (tmp___17) {
                {
#line 450
                tmp___14 = strlen((char const   *)(pl.linebuf.p + line_offset));
#line 450
                need = pl.dir.size + tmp___14;
                }
#line 451
                if (pl.linebuf.size < need) {
                  {
#line 453
                  tmp___15 = (int )mpg123_resize_string(& pl.linebuf, need);
                  }
#line 453
                  if (! tmp___15) {
                    {
#line 455
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c:%i] error: unable to enlarge linebuf for appending path! skipping\n",
                            455);
                    }
#line 456
                    goto while_continue;
                  }
                }
                {
#line 460
                tmp___16 = strlen((char const   *)(pl.linebuf.p + line_offset));
#line 460
                memmove((void *)((pl.linebuf.p + pl.dir.size) - 1), (void const   *)(pl.linebuf.p + line_offset),
                        tmp___16 + 1U);
#line 462
                memcpy((void */* __restrict  */)pl.linebuf.p, (void const   */* __restrict  */)pl.dir.p,
                       pl.dir.size - 1U);
#line 463
                line_offset = (size_t )0;
                }
              }
            }
          }
        }
#line 465
        (pl.entry) ++;
#line 466
        if (param.listentry < 0L) {
          {
#line 466
          printf((char const   */* __restrict  */)"#entry %lu\n%s\n", (unsigned long )pl.entry,
                 pl.linebuf.p + line_offset);
          }
        } else
#line 467
        if (param.listentry == 0L) {
          {
#line 469
          add_copy_to_playlist(pl.linebuf.p + line_offset);
          }
#line 470
          return (1);
        } else
#line 467
        if (param.listentry == (long )pl.entry) {
          {
#line 469
          add_copy_to_playlist(pl.linebuf.p + line_offset);
          }
#line 470
          return (1);
        }
      } else {
#line 475
        if (param.listname) {
#line 476
          if (pl.file) {
            {
#line 476
            fclose(pl.file);
            }
          }
        }
#line 477
        param.listname = (char *)((void *)0);
#line 478
        pl.file = (FILE *)((void *)0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 489
  if (loptind < argc___0) {
    {
#line 491
    tmp___18 = loptind;
#line 491
    loptind ++;
#line 491
    add_to_playlist(*(argv___0 + tmp___18), (char)0);
    }
#line 492
    return (1);
  }
#line 494
  return (0);
}
}
#line 497 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
void shuffle_playlist(void) 
{ 
  size_t loop ;
  size_t rannum ;
  struct listitem tmp ;
  size_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 501
  if (pl.fill >= 2U) {
#line 505
    loop = (size_t )0;
    {
#line 505
    while (1) {
      while_continue: /* CIL Label */ ;
#line 505
      if (! (loop < pl.fill)) {
#line 505
        goto while_break;
      }
      {
#line 508
      tmp___0 = rando(pl.fill - loop);
#line 508
      rannum = loop + tmp___0;
#line 521
      tmp = *(pl.list + rannum);
#line 522
      *(pl.list + rannum) = *(pl.list + loop);
#line 523
      *(pl.list + loop) = tmp;
#line 505
      loop ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 527
  if (param.verbose > 1) {
    {
#line 530
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nshuffled playlist:\n");
#line 531
    print_playlist(stderr, 0);
#line 532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 534
  return;
}
}
#line 536 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
void print_playlist(FILE *out , int showpos ) 
{ 
  size_t loop ;
  char *pre ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 539
  loop = (size_t )0;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! (loop < pl.fill)) {
#line 539
      goto while_break;
    }
#line 541
    pre = (char *)"";
#line 542
    if (showpos) {
#line 543
      if (pl.pos > 0U) {
#line 543
        if (loop == pl.pos - 1U) {
#line 543
          pre = (char *)"> ";
        } else {
#line 543
          pre = (char *)"  ";
        }
      } else {
#line 543
        pre = (char *)"  ";
      }
    }
    {
#line 545
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s%s\n",
            pre, (pl.list + loop)->url);
#line 539
    loop ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  return;
}
}
#line 550 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
int add_copy_to_playlist(char *new_entry ) 
{ 
  char *cop ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 553
  tmp___0 = strlen((char const   *)new_entry);
#line 553
  tmp___1 = malloc(tmp___0 + 1U);
#line 553
  cop = (char *)tmp___1;
  }
#line 553
  if ((unsigned long )cop != (unsigned long )((void *)0)) {
    {
#line 555
    strcpy((char */* __restrict  */)cop, (char const   */* __restrict  */)new_entry);
#line 556
    tmp = add_to_playlist(cop, (char)1);
    }
#line 556
    return (tmp);
  } else {
#line 558
    return (0);
  }
}
}
#line 562 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c"
int add_to_playlist(char *new_entry , char freeit ) 
{ 
  struct listitem *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 564
  if (pl.fill == pl.size) {
    {
#line 566
    tmp = (struct listitem *)((void *)0);
#line 568
    tmp___0 = safe_realloc((void *)pl.list, (size_t )((unsigned long )(pl.size + pl.alloc_step) * sizeof(struct listitem )));
#line 568
    tmp = (struct listitem *)tmp___0;
    }
#line 569
    if (! tmp) {
      {
#line 571
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c:%i] error: unable to allocate more memory for playlist\n",
              571);
#line 572
      perror("");
      }
#line 573
      return (0);
    } else {
#line 577
      pl.list = tmp;
#line 578
      pl.size += pl.alloc_step;
    }
  }
#line 582
  if (pl.fill < pl.size) {
#line 584
    (pl.list + pl.fill)->freeit = freeit;
#line 585
    (pl.list + pl.fill)->url = new_entry;
#line 586
    (pl.list + pl.fill)->playcount = (size_t )0;
#line 587
    (pl.fill) ++;
  } else {
    {
#line 591
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/playlist.c:%i] error: playlist memory still too small?!\n",
            591);
    }
#line 592
    return (0);
  }
#line 594
  return (1);
}
}
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 584 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 340 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/local.h"
int utf8env ;
#line 19
void check_locale(void) ;
#line 22 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/local.c"
int utf8env  =    0;
#line 25
static int is_utf8___0(char const   *lang ) ;
#line 27 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/local.c"
void check_locale(void) 
{ 
  char const   *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 29
  if (param.force_utf8) {
#line 29
    utf8env = 1;
  } else {
    {
#line 35
    tmp___0 = getenv("LC_ALL");
#line 35
    cp = (char const   *)tmp___0;
    }
#line 35
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 35
      tmp___1 = getenv("LC_CTYPE");
#line 35
      cp = (char const   *)tmp___1;
      }
#line 35
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 36
        tmp = getenv("LANG");
#line 36
        cp = (char const   *)tmp;
        }
      }
    }
    {
#line 38
    tmp___2 = is_utf8___0(cp);
    }
#line 38
    if (tmp___2) {
#line 38
      utf8env = 1;
    }
  }
#line 43
  if (! utf8env) {
    {
#line 43
    tmp___3 = setlocale(0, "");
#line 43
    tmp___4 = is_utf8___0((char const   *)tmp___3);
    }
#line 43
    if (tmp___4) {
#line 43
      utf8env = 1;
    }
  }
#line 47
  if (! utf8env) {
    {
#line 47
    tmp___5 = nl_langinfo(14);
#line 47
    tmp___6 = is_utf8___0((char const   *)tmp___5);
    }
#line 47
    if (tmp___6) {
#line 47
      utf8env = 1;
    }
  }
#line 51
  return;
}
}
#line 53 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/local.c"
static int is_utf8___0(char const   *lang ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 55
  if ((unsigned long )lang == (unsigned long )((void *)0)) {
#line 55
    return (0);
  }
  {
#line 58
  tmp = strstr(lang, "UTF-8");
  }
#line 58
  if (tmp) {
#line 60
    return (1);
  } else {
    {
#line 58
    tmp___0 = strstr(lang, "utf-8");
    }
#line 58
    if (tmp___0) {
#line 60
      return (1);
    } else {
      {
#line 58
      tmp___1 = strstr(lang, "UTF8");
      }
#line 58
      if (tmp___1) {
#line 60
        return (1);
      } else {
        {
#line 58
        tmp___2 = strstr(lang, "utf8");
        }
#line 58
        if (tmp___2) {
#line 60
          return (1);
        } else {
#line 62
          return (0);
        }
      }
    }
  }
}
}
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 12 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/genre.h"
char *genre_table[148] ;
#line 13
int const   genre_count ;
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/metaprint.c"
static void utf8_ascii(mpg123_string *dest , mpg123_string *source ) ;
#line 14 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/metaprint.c"
static void transform(mpg123_string *dest , mpg123_string *source ) 
{ 


  {
#line 17
  if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 17
    return;
  }
#line 19
  if (utf8env) {
    {
#line 19
    mpg123_copy_string(source, dest);
    }
  } else {
    {
#line 20
    utf8_ascii(dest, source);
    }
  }
#line 21
  return;
}
}
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/metaprint.c"
void print_id3_tag(mpg123_handle *mh___0 , int long_id3 , FILE *out ) 
{ 
  char genre_from_v1 ;
  enum __anonenum_ti_56 ti ;
  mpg123_string tag[6] ;
  mpg123_id3v1 *v1 ;
  mpg123_id3v2 *v2 ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  mpg123_string tmp___11 ;
  size_t num ;
  size_t nonum ;
  size_t i ;
  enum __anonenum_state_57 state ;
  int gid ;
  char *genre ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;

  {
#line 26
  genre_from_v1 = (char)0;
#line 32
  ti = (enum __anonenum_ti_56 )0;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! ((unsigned int )ti < 6U)) {
#line 32
      goto while_break;
    }
    {
#line 32
    mpg123_init_string(& tag[ti]);
#line 32
    ti = (enum __anonenum_ti_56 )((unsigned int )ti + 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 34
  mpg123_id3(mh___0, & v1, & v2);
  }
#line 36
  if ((unsigned long )v1 == (unsigned long )((void *)0)) {
#line 36
    if ((unsigned long )v2 == (unsigned long )((void *)0)) {
#line 36
      return;
    }
  }
#line 37
  if ((unsigned long )v2 != (unsigned long )((void *)0)) {
    {
#line 39
    transform(& tag[0], v2->title);
#line 40
    transform(& tag[1], v2->artist);
#line 41
    transform(& tag[2], v2->album);
#line 42
    transform(& tag[3], v2->comment);
#line 43
    transform(& tag[4], v2->year);
#line 44
    transform(& tag[5], v2->genre);
    }
  }
#line 46
  if ((unsigned long )v1 != (unsigned long )((void *)0)) {
#line 49
    if (! tag[0].fill) {
#line 51
      if (tag[0].size >= 31U) {
        {
#line 53
        strncpy((char */* __restrict  */)tag[0].p, (char const   */* __restrict  */)(v1->title),
                (size_t )30);
#line 54
        *(tag[0].p + 30) = (char)0;
#line 55
        tmp = strlen((char const   *)tag[0].p);
#line 55
        tag[0].fill = tmp + 1U;
        }
      } else {
        {
#line 51
        tmp___0 = (int )mpg123_resize_string(& tag[0], (size_t )31);
        }
#line 51
        if (tmp___0) {
          {
#line 53
          strncpy((char */* __restrict  */)tag[0].p, (char const   */* __restrict  */)(v1->title),
                  (size_t )30);
#line 54
          *(tag[0].p + 30) = (char)0;
#line 55
          tmp = strlen((char const   *)tag[0].p);
#line 55
          tag[0].fill = tmp + 1U;
          }
        }
      }
    }
#line 58
    if (! tag[1].fill) {
#line 60
      if (tag[1].size >= 31U) {
        {
#line 62
        strncpy((char */* __restrict  */)tag[1].p, (char const   */* __restrict  */)(v1->artist),
                (size_t )30);
#line 63
        *(tag[1].p + 30) = (char)0;
#line 64
        tmp___1 = strlen((char const   *)tag[1].p);
#line 64
        tag[1].fill = tmp___1 + 1U;
        }
      } else {
        {
#line 60
        tmp___2 = (int )mpg123_resize_string(& tag[1], (size_t )31);
        }
#line 60
        if (tmp___2) {
          {
#line 62
          strncpy((char */* __restrict  */)tag[1].p, (char const   */* __restrict  */)(v1->artist),
                  (size_t )30);
#line 63
          *(tag[1].p + 30) = (char)0;
#line 64
          tmp___1 = strlen((char const   *)tag[1].p);
#line 64
          tag[1].fill = tmp___1 + 1U;
          }
        }
      }
    }
#line 67
    if (! tag[2].fill) {
#line 69
      if (tag[2].size >= 31U) {
        {
#line 71
        strncpy((char */* __restrict  */)tag[2].p, (char const   */* __restrict  */)(v1->album),
                (size_t )30);
#line 72
        *(tag[2].p + 30) = (char)0;
#line 73
        tmp___3 = strlen((char const   *)tag[2].p);
#line 73
        tag[2].fill = tmp___3 + 1U;
        }
      } else {
        {
#line 69
        tmp___4 = (int )mpg123_resize_string(& tag[2], (size_t )31);
        }
#line 69
        if (tmp___4) {
          {
#line 71
          strncpy((char */* __restrict  */)tag[2].p, (char const   */* __restrict  */)(v1->album),
                  (size_t )30);
#line 72
          *(tag[2].p + 30) = (char)0;
#line 73
          tmp___3 = strlen((char const   *)tag[2].p);
#line 73
          tag[2].fill = tmp___3 + 1U;
          }
        }
      }
    }
#line 76
    if (! tag[3].fill) {
#line 78
      if (tag[3].size >= 31U) {
        {
#line 80
        strncpy((char */* __restrict  */)tag[3].p, (char const   */* __restrict  */)(v1->comment),
                (size_t )30);
#line 81
        *(tag[3].p + 30) = (char)0;
#line 82
        tmp___5 = strlen((char const   *)tag[3].p);
#line 82
        tag[3].fill = tmp___5 + 1U;
        }
      } else {
        {
#line 78
        tmp___6 = (int )mpg123_resize_string(& tag[3], (size_t )31);
        }
#line 78
        if (tmp___6) {
          {
#line 80
          strncpy((char */* __restrict  */)tag[3].p, (char const   */* __restrict  */)(v1->comment),
                  (size_t )30);
#line 81
          *(tag[3].p + 30) = (char)0;
#line 82
          tmp___5 = strlen((char const   *)tag[3].p);
#line 82
          tag[3].fill = tmp___5 + 1U;
          }
        }
      }
    }
#line 85
    if (! tag[4].fill) {
#line 87
      if (tag[4].size >= 5U) {
        {
#line 89
        strncpy((char */* __restrict  */)tag[4].p, (char const   */* __restrict  */)(v1->year),
                (size_t )4);
#line 90
        *(tag[4].p + 4) = (char)0;
#line 91
        tmp___7 = strlen((char const   *)tag[4].p);
#line 91
        tag[4].fill = tmp___7 + 1U;
        }
      } else {
        {
#line 87
        tmp___8 = (int )mpg123_resize_string(& tag[4], (size_t )5);
        }
#line 87
        if (tmp___8) {
          {
#line 89
          strncpy((char */* __restrict  */)tag[4].p, (char const   */* __restrict  */)(v1->year),
                  (size_t )4);
#line 90
          *(tag[4].p + 4) = (char)0;
#line 91
          tmp___7 = strlen((char const   *)tag[4].p);
#line 91
          tag[4].fill = tmp___7 + 1U;
          }
        }
      }
    }
#line 97
    if (! tag[5].fill) {
#line 99
      if (tag[5].size >= 31U) {
#line 99
        goto _L;
      } else {
        {
#line 99
        tmp___10 = (int )mpg123_resize_string(& tag[5], (size_t )31);
        }
#line 99
        if (tmp___10) {
          _L: /* CIL Label */ 
#line 101
          if ((int )v1->genre <= (int )genre_count) {
            {
#line 103
            strncpy((char */* __restrict  */)tag[5].p, (char const   */* __restrict  */)genre_table[v1->genre],
                    (size_t )30);
            }
          } else {
            {
#line 107
            strncpy((char */* __restrict  */)tag[5].p, (char const   */* __restrict  */)"Unknown",
                    (size_t )30);
            }
          }
          {
#line 109
          *(tag[5].p + 30) = (char)0;
#line 110
          tmp___9 = strlen((char const   *)tag[5].p);
#line 110
          tag[5].fill = tmp___9 + 1U;
#line 111
          genre_from_v1 = (char)1;
          }
        }
      }
    }
  }
#line 116
  if (tag[5].fill) {
#line 116
    if (! genre_from_v1) {
      {
#line 130
      mpg123_init_string(& tmp___11);
#line 132
      tmp___12 = (int )mpg123_copy_string(& tag[5], & tmp___11);
      }
#line 132
      if (tmp___12) {
#line 134
        num = (size_t )0;
#line 135
        nonum = (size_t )0;
#line 137
        state = (enum __anonenum_state_57 )0;
#line 138
        tag[5].fill = (size_t )0;
#line 142
        i = (size_t )0;
        {
#line 142
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 142
          if (! (i < tmp___11.fill)) {
#line 142
            goto while_break___0;
          }
          {
#line 147
          if ((unsigned int )state == 0U) {
#line 147
            goto case_0;
          }
#line 164
          if ((unsigned int )state == 1U) {
#line 164
            goto case_1;
          }
#line 210
          goto switch_default;
          case_0: /* CIL Label */ 
#line 148
          nonum = i;
#line 149
          if ((int )*(tmp___11.p + i) == 40) {
#line 151
            num = i + 1U;
#line 152
            state = (enum __anonenum_state_57 )1;
          } else
#line 156
          if ((int )*(tmp___11.p + i) >= 48) {
#line 156
            if ((int )*(tmp___11.p + i) <= 57) {
#line 158
              num = i;
#line 159
              state = (enum __anonenum_state_57 )1;
            } else {
#line 162
              state = (enum __anonenum_state_57 )2;
            }
          } else {
#line 162
            state = (enum __anonenum_state_57 )2;
          }
#line 163
          goto switch_break;
          case_1: /* CIL Label */ 
#line 166
          if ((int )*(tmp___11.p + i) == 40) {
#line 168
            nonum = i;
#line 169
            state = (enum __anonenum_state_57 )2;
          } else
#line 172
          if ((int )*(tmp___11.p + i) == 41) {
#line 172
            goto _L___0;
          } else
#line 172
          if ((int )*(tmp___11.p + i) == 10) {
#line 172
            goto _L___0;
          } else
#line 172
          if ((int )*(tmp___11.p + i) == 0) {
            _L___0: /* CIL Label */ 
#line 174
            if (i - num > 0U) {
              {
#line 178
              genre = (char *)"Unknown";
#line 179
              *(tmp___11.p + i) = (char)0;
#line 180
              gid = atoi((char const   *)(tmp___11.p + num));
              }
#line 183
              if (gid >= 0) {
#line 183
                if (gid <= (int )genre_count) {
#line 183
                  genre = genre_table[gid];
                }
              }
#line 186
              if (tag[5].fill) {
                {
#line 186
                mpg123_add_string(& tag[5], ", ");
                }
              }
              {
#line 187
              mpg123_add_string(& tag[5], (char const   *)genre);
#line 188
              nonum = i + 1U;
#line 189
              state = (enum __anonenum_state_57 )0;
              }
            } else {
#line 195
              state = (enum __anonenum_state_57 )2;
            }
          } else
#line 199
          if ((int )*(tmp___11.p + i) >= 48) {
#line 199
            if (! ((int )*(tmp___11.p + i) <= 57)) {
#line 202
              state = (enum __anonenum_state_57 )2;
            }
          } else {
#line 202
            state = (enum __anonenum_state_57 )2;
          }
#line 209
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 210
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 212
          if ((unsigned int )state == 2U) {
#line 212
            goto while_break___0;
          }
#line 142
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 214
        if (nonum < tmp___11.fill - 1U) {
#line 216
          if (tag[5].fill) {
            {
#line 216
            mpg123_add_string(& tag[5], ", ");
            }
          }
          {
#line 217
          mpg123_add_string(& tag[5], (char const   *)(tmp___11.p + nonum));
          }
        }
      }
      {
#line 220
      mpg123_free_string(& tmp___11);
      }
    }
  }
#line 223
  if (long_id3) {
    {
#line 225
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
    }
#line 228
    if (tag[0].fill) {
#line 228
      tmp___13 = (char const   *)tag[0].p;
    } else {
#line 228
      tmp___13 = "";
    }
    {
#line 228
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\tTitle:   %s\n",
            tmp___13);
    }
#line 229
    if (tag[1].fill) {
#line 229
      tmp___14 = (char const   *)tag[1].p;
    } else {
#line 229
      tmp___14 = "";
    }
    {
#line 229
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\tArtist:  %s\n",
            tmp___14);
    }
#line 230
    if (tag[2].fill) {
#line 230
      tmp___15 = (char const   *)tag[2].p;
    } else {
#line 230
      tmp___15 = "";
    }
    {
#line 230
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\tAlbum:   %s\n",
            tmp___15);
    }
#line 231
    if (tag[4].fill) {
#line 231
      tmp___16 = (char const   *)tag[4].p;
    } else {
#line 231
      tmp___16 = "";
    }
    {
#line 231
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\tYear:    %s\n",
            tmp___16);
    }
#line 232
    if (tag[5].fill) {
#line 232
      tmp___17 = (char const   *)tag[5].p;
    } else {
#line 232
      tmp___17 = "";
    }
    {
#line 232
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\tGenre:   %s\n",
            tmp___17);
    }
#line 233
    if (tag[3].fill) {
#line 233
      tmp___18 = (char const   *)tag[3].p;
    } else {
#line 233
      tmp___18 = "";
    }
    {
#line 233
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\tComment: %s\n",
            tmp___18);
#line 234
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
    }
  } else {
#line 241
    if (tag[0].fill) {
#line 241
      if (tag[1].fill) {
        {
#line 241
        tmp___19 = strlen((char const   *)tag[0].p);
        }
#line 241
        if (tmp___19 <= 30U) {
          {
#line 241
          tmp___20 = strlen((char const   *)tag[0].p);
          }
#line 241
          if (tmp___20 <= 30U) {
            {
#line 243
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Title:   %-30s  Artist: %s\n",
                    tag[0].p, tag[1].p);
            }
          } else {
#line 241
            goto _L___3;
          }
        } else {
#line 241
          goto _L___3;
        }
      } else {
#line 241
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 247
      if (tag[0].fill) {
        {
#line 247
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Title:   %s\n",
                tag[0].p);
        }
      }
#line 248
      if (tag[1].fill) {
        {
#line 248
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Artist:  %s\n",
                tag[1].p);
        }
      }
    }
#line 250
    if (tag[3].fill) {
#line 250
      if (tag[2].fill) {
        {
#line 250
        tmp___21 = strlen((char const   *)tag[3].p);
        }
#line 250
        if (tmp___21 <= 30U) {
          {
#line 250
          tmp___22 = strlen((char const   *)tag[2].p);
          }
#line 250
          if (tmp___22 <= 30U) {
            {
#line 252
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Comment: %-30s  Album:  %s\n",
                    tag[3].p, tag[2].p);
            }
          } else {
#line 250
            goto _L___6;
          }
        } else {
#line 250
          goto _L___6;
        }
      } else {
#line 250
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 256
      if (tag[3].fill) {
        {
#line 257
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Comment: %s\n",
                tag[3].p);
        }
      }
#line 258
      if (tag[2].fill) {
        {
#line 259
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Album:   %s\n",
                tag[2].p);
        }
      }
    }
#line 261
    if (tag[4].fill) {
#line 261
      if (tag[5].fill) {
        {
#line 261
        tmp___23 = strlen((char const   *)tag[4].p);
        }
#line 261
        if (tmp___23 <= 30U) {
          {
#line 261
          tmp___24 = strlen((char const   *)tag[5].p);
          }
#line 261
          if (tmp___24 <= 30U) {
            {
#line 263
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Year:    %-30s  Genre:  %s\n",
                    tag[4].p, tag[5].p);
            }
          } else {
#line 261
            goto _L___9;
          }
        } else {
#line 261
          goto _L___9;
        }
      } else {
#line 261
        goto _L___9;
      }
    } else {
      _L___9: /* CIL Label */ 
#line 267
      if (tag[4].fill) {
        {
#line 268
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Year:    %s\n",
                tag[4].p);
        }
      }
#line 269
      if (tag[5].fill) {
        {
#line 270
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Genre:   %s\n",
                tag[5].p);
        }
      }
    }
  }
#line 273
  ti = (enum __anonenum_ti_56 )0;
  {
#line 273
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 273
    if (! ((unsigned int )ti < 6U)) {
#line 273
      goto while_break___1;
    }
    {
#line 273
    mpg123_free_string(& tag[ti]);
#line 273
    ti = (enum __anonenum_ti_56 )((unsigned int )ti + 1U);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 274
  return;
}
}
#line 276 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/metaprint.c"
void print_icy(mpg123_handle *mh___0 , FILE *outstream___0 ) 
{ 
  char *icy ;
  mpg123_string in ;
  mpg123_string out ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 279
  tmp___1 = (int )mpg123_icy(mh___0, & icy);
  }
#line 279
  if (0 == tmp___1) {
    {
#line 282
    mpg123_init_string(& in);
#line 283
    tmp = strlen((char const   *)icy);
#line 283
    tmp___0 = mpg123_store_utf8(& in, (enum mpg123_text_encoding )3, (unsigned char const   *)((unsigned char *)icy),
                                tmp + 1U);
    }
#line 283
    if (tmp___0) {
      {
#line 286
      mpg123_init_string(& out);
#line 288
      transform(& out, & in);
      }
#line 289
      if (out.fill) {
        {
#line 290
        fprintf((FILE */* __restrict  */)outstream___0, (char const   */* __restrict  */)"\nICY-META: %s\n",
                out.p);
        }
      }
      {
#line 292
      mpg123_free_string(& out);
      }
    }
    {
#line 294
    mpg123_free_string(& in);
    }
  }
#line 296
  return;
}
}
#line 298 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/metaprint.c"
static void utf8_ascii(mpg123_string *dest , mpg123_string *source ) 
{ 
  size_t spos ;
  size_t dlen ;
  char *p ;
  int tmp ;

  {
#line 300
  spos = (size_t )0;
#line 301
  dlen = (size_t )0;
#line 304
  spos = (size_t )0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (spos < source->fill)) {
#line 304
      goto while_break;
    }
#line 305
    if (! (((int )*(source->p + spos) & 192) == 128)) {
#line 306
      dlen ++;
    }
#line 304
    spos ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  tmp = (int )mpg123_resize_string(dest, dlen);
  }
#line 308
  if (! tmp) {
    {
#line 308
    mpg123_free_string(dest);
    }
#line 308
    return;
  }
#line 310
  p = dest->p;
#line 311
  spos = (size_t )0;
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 311
    if (! (spos < source->fill)) {
#line 311
      goto while_break___0;
    }
#line 314
    if (((int )*(source->p + spos) & 192) == 128) {
#line 314
      goto __Cont___0;
    } else
#line 316
    if ((int )*(source->p + spos) & 128) {
#line 316
      *p = (char )'*';
    } else {
#line 318
      *p = *(source->p + spos);
    }
#line 320
    p ++;
    __Cont___0: /* CIL Label */ 
#line 311
    spos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 322
  if (dest->size) {
#line 322
    *(dest->p + (dest->size - 1U)) = (char)0;
  }
#line 323
  dest->fill = dest->size;
#line 324
  return;
}
}
#line 441 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 623
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 32 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.h"
void httpdata_reset(struct httpdata *e ) ;
#line 64
char *httpauth ;
#line 82 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.h"
void audio_capabilities(audio_output_t *ao___0 , mpg123_handle *mh___0 ) ;
#line 85
void print_capabilities(audio_output_t *ao___0 , mpg123_handle *mh___0 ) ;
#line 87
int init_output(audio_output_t **ao___0 ) ;
#line 88
void exit_output(audio_output_t *ao___0 , int rude ) ;
#line 89
int flush_output(audio_output_t *ao___0 , unsigned char *bytes , size_t count ) ;
#line 92
int reset_output(audio_output_t *ao___0 ) ;
#line 93
void output_pause(audio_output_t *ao___0 ) ;
#line 94
void output_unpause(audio_output_t *ao___0 ) ;
#line 96
void audio_enclist(char **list ) ;
#line 43 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
size_t bufferblock ;
#line 47 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
char *binpath  ;
#line 111
char *equalfile ;
#line 112 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
off_t framenum  ;
#line 113 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
struct httpdata htd  ;
#line 115 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
int buffer_fd[2]  ;
#line 117 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
int buffer_pid  ;
#line 123 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
int OutputDescriptor  ;
#line 132
int play_frame(void) ;
#line 134
int control_generic(mpg123_handle *fr ) ;
#line 150
int open_track(char *fname ) ;
#line 151
void close_track(void) ;
#line 155
int load_equalizer(mpg123_handle *mh___0 ) ;
#line 98 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 50 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param  const  *__param ) ;
#line 63
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 14 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.h"
void (*catchsignal(int signum , void (*handler)() ))() ;
#line 17
void print_header_compact(mpg123_handle *mh___0 ) ;
#line 25
int split_dir_file(char const   *path , char **dname , char **fname ) ;
#line 19 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.h"
char *loptarg ;
#line 66
int getlopt(int argc___0 , char **argv___0 , topt *opts___0 ) ;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.h"
void real_buffer_reset(void) ;
#line 46 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void usage(int err ) ;
#line 47
static void want_usage(char *arg ) ;
#line 48
static void long_usage(int err ) ;
#line 49
static void want_long_usage(char *arg ) ;
#line 50
static void print_title(FILE *o ) ;
#line 51
static void give_version(char *arg ) ;
#line 53 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
struct parameter param  = 
#line 53
     {0, 0, 0, 0, 1, 0, 0, 0L, 0, (char *)"oss", (char *)((void *)0), 0, 0, 0, 0, 0,
    0L, (char *)((void *)0), 0L, (char *)((void *)0), 0, 0, (char *)((void *)0), (char *)((void *)0),
    0L, 1L, 0, 0, 0, 0L, 0L, 0L, 0L, -1L, 0L, 0, 0L, 1, 1024L, 0, 0.0, 0, (char *)((void *)0),
    0, 0, 1000L, (char *)((void *)0), 1., -1L, -1L};
#line 115 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
mpg123_handle *mh  =    (mpg123_handle *)((void *)0);
#line 117 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
off_t frames_left  ;
#line 118 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
audio_output_t *ao  =    (audio_output_t *)((void *)0);
#line 119 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
txfermem *buffermem  =    (txfermem *)((void *)0);
#line 120 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
char *prgName  =    (char *)((void *)0);
#line 122 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
char *equalfile  =    (char *)((void *)0);
#line 124 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
int fresh  =    1;
#line 125 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
int have_output  =    0;
#line 129 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
size_t bufferblock  =    (size_t )0;
#line 131 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static int intflag  =    0;
#line 132 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static int skip_tracks  =    0;
#line 135 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static int filept  =    -1;
#line 137 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static int network_sockets_used  =    0;
#line 143 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static char **argv  =    (char **)((void *)0);
#line 144 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static int argc  =    0;
#line 147 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static int cleanup_mpg123  =    0;
#line 149 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
void set_intflag(void) 
{ 


  {
#line 152
  intflag = 1;
#line 153
  skip_tracks = 0;
#line 154
  return;
}
}
#line 157 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void catch_interrupt(void) 
{ 


  {
#line 159
  intflag = 1;
#line 160
  return;
}
}
#line 164 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
void next_track(void) 
{ 


  {
#line 166
  intflag = 1;
#line 167
  skip_tracks ++;
#line 168
  return;
}
}
#line 170 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
void prev_track(void) 
{ 


  {
#line 172
  if (pl.pos > 2U) {
#line 172
    pl.pos -= 2U;
  } else {
#line 173
    pl.pos = (size_t )0;
  }
  {
#line 175
  next_track();
  }
#line 176
  return;
}
}
#line 178 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
void safe_exit(int code ) 
{ 
  char *dummy ;
  char *dammy ;
  char *__cil_tmp4 ;

  {
#line 182
  if (param.term_ctrl) {
    {
#line 183
    term_restore();
    }
  }
#line 185
  if (have_output) {
    {
#line 185
    exit_output(ao, intflag);
    }
  }
#line 187
  if ((unsigned long )mh != (unsigned long )((void *)0)) {
    {
#line 187
    mpg123_delete(mh);
    }
  }
#line 189
  if (cleanup_mpg123) {
    {
#line 189
    mpg123_exit();
    }
  }
  {
#line 191
  httpdata_free(& htd);
#line 200
  split_dir_file("", & dummy, & dammy);
#line 201
  exit(code);
  }
}
}
#line 205 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_output_module(char *arg ) 
{ 
  unsigned int i ;
  size_t tmp ;

  {
#line 210
  i = 0U;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 210
    tmp = strlen((char const   *)arg);
    }
#line 210
    if (! (i < tmp)) {
#line 210
      goto while_break;
    }
#line 211
    if ((int )*(arg + i) == 58) {
#line 212
      *(arg + i) = (char)0;
#line 213
      param.output_device = arg + (i + 1U);
#line 215
      goto while_break;
    }
#line 210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  param.output_module = arg;
#line 221
  return;
}
}
#line 223 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_output_flag(int flag ) 
{ 


  {
#line 225
  if (param.output_flags <= 0) {
#line 225
    param.output_flags = flag;
  } else {
#line 226
    param.output_flags |= flag;
  }
#line 227
  return;
}
}
#line 229 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_output_h(char *a ) 
{ 


  {
  {
#line 231
  set_output_flag(1);
  }
#line 232
  return;
}
}
#line 234 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_output_s(char *a ) 
{ 


  {
  {
#line 236
  set_output_flag(2);
  }
#line 237
  return;
}
}
#line 239 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_output_l(char *a ) 
{ 


  {
  {
#line 241
  set_output_flag(4);
  }
#line 242
  return;
}
}
#line 244 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_output(char *arg ) 
{ 
  size_t tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 248
  tmp = strlen((char const   *)arg);
  }
#line 248
  if (tmp <= 1U) {
    {
#line 250
    if ((int )*(arg + 0) == 104) {
#line 250
      goto case_104;
    }
#line 251
    if ((int )*(arg + 0) == 115) {
#line 251
      goto case_115;
    }
#line 252
    if ((int )*(arg + 0) == 108) {
#line 252
      goto case_108;
    }
#line 253
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 250
    set_output_h(arg);
    }
#line 250
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 251
    set_output_s(arg);
    }
#line 251
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 252
    set_output_l(arg);
    }
#line 252
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: \"%s\" is no valid output\n",
            254, arg);
#line 255
    safe_exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 257
    set_output_module(arg);
    }
  }
#line 258
  return;
}
}
#line 260 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_verbose(char *arg ) 
{ 


  {
#line 262
  (param.verbose) ++;
#line 263
  return;
}
}
#line 265 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_quiet(char *arg ) 
{ 


  {
#line 267
  param.verbose = 0;
#line 268
  param.quiet = 1;
#line 269
  return;
}
}
#line 271 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_out_wav(char *arg ) 
{ 


  {
#line 273
  param.outmode = 4;
#line 274
  param.filename = arg;
#line 275
  return;
}
}
#line 277 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
void set_out_cdr(char *arg ) 
{ 


  {
#line 279
  param.outmode = 6;
#line 280
  param.filename = arg;
#line 281
  return;
}
}
#line 283 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
void set_out_au(char *arg ) 
{ 


  {
#line 285
  param.outmode = 5;
#line 286
  param.filename = arg;
#line 287
  return;
}
}
#line 289 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_out_file(char *arg ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 291
  param.outmode = 2;
#line 295
  OutputDescriptor = open((char const   *)arg, 577, 438);
  }
#line 297
  if (OutputDescriptor == -1) {
    {
#line 299
    tmp = __errno_location();
#line 299
    tmp___0 = strerror(*tmp);
#line 299
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Can\'t open %s for writing (%s).\n\n",
            299, arg, tmp___0);
#line 300
    safe_exit(1);
    }
  }
#line 302
  return;
}
}
#line 304 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_out_stdout(char *arg ) 
{ 


  {
#line 306
  param.outmode = 2;
#line 307
  param.remote_err = 1;
#line 308
  OutputDescriptor = 1;
#line 312
  return;
}
}
#line 314 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_out_stdout1(char *arg ) 
{ 


  {
#line 316
  param.outmode = 7;
#line 317
  param.remote_err = 1;
#line 318
  OutputDescriptor = 1;
#line 322
  return;
}
}
#line 331 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static int frameflag  ;
#line 332 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void set_frameflag(char *arg ) 
{ 


  {
#line 335
  if (frameflag & 7) {
#line 335
    param.flags &= -8;
  }
#line 336
  param.flags |= frameflag;
#line 337
  return;
}
}
#line 338 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void unset_frameflag(char *arg ) 
{ 


  {
#line 340
  param.flags &= ~ frameflag;
#line 341
  return;
}
}
#line 351 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static int dnow  =    0;
#line 353 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
topt opts[87]  = 
#line 353
  {      {(char )'k', (char *)"skip", 9, (void (*)(char * ))0, (void *)(& param.start_frame),
      0L}, 
        {(char )'2', (char *)"2to1", 4, (void (*)(char * ))0, (void *)(& param.down_sample),
      1L}, 
        {(char )'4', (char *)"4to1", 4, (void (*)(char * ))0, (void *)(& param.down_sample),
      2L}, 
        {(char )'t', (char *)"test", 4, (void (*)(char * ))0, (void *)(& param.outmode),
      0L}, 
        {(char )'s', (char *)"stdout", 4, & set_out_stdout, (void *)(& param.outmode),
      2L}, 
        {(char )'S', (char *)"STDOUT", 4, & set_out_stdout1, (void *)(& param.outmode),
      7L}, 
        {(char )'O', (char *)"outfile", 3, & set_out_file, (void *)0, 0L}, 
        {(char )'c', (char *)"check", 4, (void (*)(char * ))0, (void *)(& param.checkrange),
      1L}, 
        {(char )'v', (char *)"verbose", 0, & set_verbose, (void *)0, 0L}, 
        {(char )'q', (char *)"quiet", 0, & set_quiet, (void *)0, 0L}, 
        {(char )'y', (char *)"no-resync", 4, & set_frameflag, (void *)(& frameflag),
      128L}, 
        {(char)0, (char *)"resync", 4, & set_frameflag, (void *)(& frameflag), 128L}, 
        {(char )'0',
      (char *)"single0", 4, & set_frameflag, (void *)(& frameflag), 1L}, 
        {(char)0, (char *)"left", 4, & set_frameflag, (void *)(& frameflag), 1L}, 
        {(char )'1', (char *)"single1", 4, & set_frameflag, (void *)(& frameflag), 2L}, 
        {(char)0,
      (char *)"right", 4, & set_frameflag, (void *)(& frameflag), 2L}, 
        {(char )'m', (char *)"singlemix", 4, & set_frameflag, (void *)(& frameflag),
      4L}, 
        {(char)0, (char *)"mix", 4, & set_frameflag, (void *)(& frameflag), 4L}, 
        {(char)0, (char *)"mono", 4, & set_frameflag, (void *)(& frameflag), 4L}, 
        {(char)0, (char *)"stereo", 4, & set_frameflag, (void *)(& frameflag), 8L}, 
        {(char)0, (char *)"reopen", 4, (void (*)(char * ))0, (void *)(& param.force_reopen),
      1L}, 
        {(char )'g', (char *)"gain", 9, (void (*)(char * ))0, (void *)(& param.gain),
      0L}, 
        {(char )'r', (char *)"rate", 9, (void (*)(char * ))0, (void *)(& param.force_rate),
      0L}, 
        {(char)0, (char *)"8bit", 4, & set_frameflag, (void *)(& frameflag), 16L}, 
        {(char)0, (char *)"float", 4, & set_frameflag, (void *)(& frameflag), 1024L}, 
        {(char)0,
      (char *)"headphones", 0, & set_output_h, (void *)0, 0L}, 
        {(char)0, (char *)"speaker", 0, & set_output_s, (void *)0, 0L}, 
        {(char)0, (char *)"lineout", 0, & set_output_l, (void *)0, 0L}, 
        {(char )'o', (char *)"output", 3, & set_output, (void *)0, 0L}, 
        {(char)0, (char *)"list-modules", 0, (void (*)(char * ))(& list_modules), (void *)0,
      0L}, 
        {(char )'a', (char *)"audiodevice", 3, (void (*)(char * ))0, (void *)(& param.output_device),
      0L}, 
        {(char )'f', (char *)"scale", 9, (void (*)(char * ))0, (void *)(& param.outscale),
      0L}, 
        {(char )'n', (char *)"frames", 9, (void (*)(char * ))0, (void *)(& param.frame_number),
      0L}, 
        {(char )'C', (char *)"control", 4, (void (*)(char * ))0, (void *)(& param.term_ctrl),
      1L}, 
        {(char )'b', (char *)"buffer", 9, (void (*)(char * ))0, (void *)(& param.usebuffer),
      0L}, 
        {(char)0, (char *)"smooth", 4, (void (*)(char * ))0, (void *)(& param.smooth),
      1L}, 
        {(char )'R', (char *)"remote", 4, (void (*)(char * ))0, (void *)(& param.remote),
      1L}, 
        {(char)0, (char *)"remote-err", 4, (void (*)(char * ))0, (void *)(& param.remote_err),
      1L}, 
        {(char )'d', (char *)"doublespeed", 9, (void (*)(char * ))0, (void *)(& param.doublespeed),
      0L}, 
        {(char )'h', (char *)"halfspeed", 9, (void (*)(char * ))0, (void *)(& param.halfspeed),
      0L}, 
        {(char )'p', (char *)"proxy", 3, (void (*)(char * ))0, (void *)(& param.proxyurl),
      0L}, 
        {(char )'@', (char *)"list", 3, (void (*)(char * ))0, (void *)(& param.listname),
      0L}, 
        {(char )'z', (char *)"shuffle", 4, (void (*)(char * ))0, (void *)(& param.shuffle),
      1L}, 
        {(char )'Z', (char *)"random", 4, (void (*)(char * ))0, (void *)(& param.shuffle),
      2L}, 
        {(char )'E', (char *)"equalizer", 3, (void (*)(char * ))0, (void *)(& equalfile),
      1L}, 
        {(char)0, (char *)"aggressive", 4, (void (*)(char * ))0, (void *)(& param.aggressive),
      2L}, 
        {(char)0, (char *)"force-3dnow", 2, (void (*)(char * ))0, (void *)(& dnow), 1L}, 
        {(char)0,
      (char *)"no-3dnow", 2, (void (*)(char * ))0, (void *)(& dnow), 2L}, 
        {(char)0, (char *)"test-3dnow", 4, (void (*)(char * ))0, (void *)(& param.test_cpu),
      1L}, 
        {(char)0, (char *)"cpu", 3, (void (*)(char * ))0, (void *)(& param.cpu), 0L}, 
        {(char)0,
      (char *)"test-cpu", 4, (void (*)(char * ))0, (void *)(& param.test_cpu), 1L}, 
        {(char)0,
      (char *)"list-cpu", 4, (void (*)(char * ))0, (void *)(& param.list_cpu), 1L}, 
        {(char )'u',
      (char *)"auth", 3, (void (*)(char * ))0, (void *)(& httpauth), 0L}, 
        {(char )'T', (char *)"realtime", 8, (void (*)(char * ))0, (void *)(& param.realtime),
      1L}, 
        {(char)0, (char *)"title", 4, (void (*)(char * ))0, (void *)(& param.xterm_title),
      1L}, 
        {(char )'w', (char *)"wav", 3, & set_out_wav, (void *)0, 0L}, 
        {(char)0, (char *)"cdr", 3, & set_out_cdr, (void *)0, 0L}, 
        {(char)0, (char *)"au", 3, & set_out_au, (void *)0, 0L}, 
        {(char)0, (char *)"gapless", 4, & set_frameflag, (void *)(& frameflag), 64L}, 
        {(char)0,
      (char *)"no-gapless", 4, & unset_frameflag, (void *)(& frameflag), 64L}, 
        {(char )'?', (char *)"help", 0, & want_usage, (void *)0, 0L}, 
        {(char)0, (char *)"longhelp", 0, & want_long_usage, (void *)0, 0L}, 
        {(char)0, (char *)"version", 0, & give_version, (void *)0, 0L}, 
        {(char )'l', (char *)"listentry", 9, (void (*)(char * ))0, (void *)(& param.listentry),
      0L}, 
        {(char)0, (char *)"rva-mix", 4, (void (*)(char * ))0, (void *)(& param.rva),
      1L}, 
        {(char)0, (char *)"rva-radio", 4, (void (*)(char * ))0, (void *)(& param.rva),
      1L}, 
        {(char)0, (char *)"rva-album", 4, (void (*)(char * ))0, (void *)(& param.rva),
      2L}, 
        {(char)0, (char *)"rva-audiophile", 4, (void (*)(char * ))0, (void *)(& param.rva),
      2L}, 
        {(char)0, (char *)"no-icy-meta", 4, (void (*)(char * ))0, (void *)(& param.talk_icy),
      0L}, 
        {(char)0, (char *)"long-tag", 4, (void (*)(char * ))0, (void *)(& param.long_id3),
      1L}, 
        {(char)0, (char *)"fifo", 3, (void (*)(char * ))0, (void *)(& param.fifo), 0L}, 
        {(char)0,
      (char *)"timeout", 9, (void (*)(char * ))0, (void *)(& param.timeout), 0L}, 
        {(char)0, (char *)"loop", 9, (void (*)(char * ))0, (void *)(& param.loop), 0L}, 
        {(char )'i',
      (char *)"index", 4, (void (*)(char * ))0, (void *)(& param.index), 1L}, 
        {(char )'D', (char *)"delay", 5, (void (*)(char * ))0, (void *)(& param.delay),
      0L}, 
        {(char)0, (char *)"resync-limit", 9, (void (*)(char * ))0, (void *)(& param.resync_limit),
      0L}, 
        {(char)0, (char *)"pitch", 17, (void (*)(char * ))0, (void *)(& param.pitch),
      0L}, 
        {(char)0, (char *)"ignore-mime", 4, (void (*)(char * ))0, (void *)(& param.ignore_mime),
      1L}, 
        {(char)0, (char *)"keep-open", 4, (void (*)(char * ))0, (void *)(& param.keep_open),
      1L}, 
        {(char)0, (char *)"utf8", 4, (void (*)(char * ))0, (void *)(& param.force_utf8),
      1L}, 
        {(char)0, (char *)"fuzzy", 4, & set_frameflag, (void *)(& frameflag), 512L}, 
        {(char)0, (char *)"index-size", 9, (void (*)(char * ))0, (void *)(& param.index_size),
      0L}, 
        {(char)0, (char *)"no-seekbuffer", 4, & unset_frameflag, (void *)(& frameflag),
      256L}, 
        {(char )'e', (char *)"encoding", 3, (void (*)(char * ))0, (void *)(& param.force_encoding),
      0L}, 
        {(char)0, (char *)"preload", 17, (void (*)(char * ))0, (void *)(& param.preload),
      0L}, 
        {(char)0, (char *)"preframes", 9, (void (*)(char * ))0, (void *)(& param.preframes),
      0L}, 
        {(char)0, (char *)0, 0, (void (*)(char * ))0, (void *)0, 0L}};
#line 471 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void reset_audio(long rate , int channels , int format ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 474
  if (param.usebuffer) {
    {
#line 479
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 479
      tmp___0 = xfermem_get_usedspace(buffermem);
      }
#line 479
      if (! (tmp___0 > 0U)) {
#line 479
        goto while_break;
      }
      {
#line 480
      tmp = xfermem_block(0, buffermem);
      }
#line 480
      if (tmp == 3) {
#line 481
        intflag = 1;
#line 482
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 484
    buffermem->freeindex = (size_t )-1;
#line 485
    buffermem->readindex = (size_t )0;
#line 486
    buffermem->freeindex = (size_t )0;
#line 487
    if (intflag) {
#line 488
      return;
    }
#line 489
    if (param.pitch == (double )0) {
#line 489
      buffermem->rate = rate;
    } else {
#line 489
      buffermem->rate = (long )((param.pitch + 1.0) * (double )rate);
    }
#line 490
    buffermem->channels = channels;
#line 491
    buffermem->format = format;
#line 492
    if (param.usebuffer) {
      {
#line 492
      real_buffer_reset();
      }
    }
  } else {
#line 497
    if ((unsigned long )ao == (unsigned long )((void *)0)) {
      {
#line 499
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Audio handle should not be NULL here!\n",
              499);
#line 500
      safe_exit(98);
      }
    }
#line 502
    if (param.pitch == (double )0) {
#line 502
      ao->rate = rate;
    } else {
#line 502
      ao->rate = (long )((param.pitch + 1.0) * (double )rate);
    }
    {
#line 503
    ao->channels = channels;
#line 504
    ao->format = format;
#line 505
    tmp___3 = reset_output(ao);
    }
#line 505
    if (tmp___3 < 0) {
      {
#line 507
      tmp___1 = __errno_location();
#line 507
      tmp___2 = strerror(*tmp___1);
#line 507
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: failed to reset audio device: %s\n",
              507, tmp___2);
#line 508
      safe_exit(1);
      }
    }
  }
#line 513
  return;
}
}
#line 515 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static int open_track_fd(void) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp3 ;

  {
  {
#line 518
  tmp___0 = (int )mpg123_open_fd_64(mh, filept);
  }
#line 518
  if (tmp___0 != 0) {
    {
#line 520
    tmp = (char const   *)mpg123_strerror(mh);
#line 520
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot open fd %i: %s\n",
            520, filept, tmp);
    }
#line 521
    return (0);
  }
#line 524
  fresh = 1;
#line 525
  return (1);
}
}
#line 530 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
int open_track(char *fname ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 532
  filept = -1;
#line 533
  httpdata_reset(& htd);
#line 534
  tmp___0 = (int )mpg123_param(mh, (enum mpg123_parms )10, 0L, (double )0);
  }
#line 534
  if (0 != tmp___0) {
    {
#line 535
    tmp = (char const   *)mpg123_strerror(mh);
#line 535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot (re)set ICY interval: %s\n",
            535, tmp);
    }
  }
  {
#line 536
  tmp___7 = strcmp((char const   *)fname, "-");
  }
#line 536
  if (tmp___7) {
    {
#line 544
    tmp___6 = strncmp((char const   *)fname, "http://", (size_t )7);
    }
#line 544
    if (! tmp___6) {
      {
#line 551
      filept = http_open(fname, & htd);
#line 553
      network_sockets_used = 1;
      }
#line 557
      if (filept >= 0) {
#line 557
        if ((unsigned long )htd.content_type.p != (unsigned long )((void *)0)) {
#line 557
          if (! param.ignore_mime) {
            {
#line 557
            tmp___3 = debunk_mime((char const   *)htd.content_type.p);
            }
#line 557
            if (! (tmp___3 & 1)) {
#line 560
              if ((unsigned long )htd.content_type.p == (unsigned long )((void *)0)) {
#line 560
                tmp___2 = "<nil>";
              } else {
#line 560
                tmp___2 = (char const   *)htd.content_type.p;
              }
              {
#line 560
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Unknown mpeg MIME type %s - is it perhaps a playlist (use -@)?\n",
                      560, tmp___2);
#line 561
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: If you know the stream is mpeg1/2 audio, then please report this as mpg123 bug\n",
                      561);
              }
#line 562
              return (0);
            }
          }
        }
      }
#line 564
      if (filept < 0) {
        {
#line 566
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Access to http resource %s failed.\n",
                566, fname);
        }
#line 567
        return (0);
      }
      {
#line 569
      tmp___5 = (int )mpg123_param(mh, (enum mpg123_parms )10, (long )htd.icy_interval,
                                   (double )0);
      }
#line 569
      if (0 != tmp___5) {
        {
#line 570
        tmp___4 = (char const   *)mpg123_strerror(mh);
#line 570
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set ICY interval: %s\n",
                570, tmp___4);
        }
      }
#line 571
      if (param.verbose > 1) {
        {
#line 571
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Info: ICY interval %li\n",
                (long )htd.icy_interval);
        }
      }
    }
  } else {
    {
#line 538
    filept = 0;
#line 542
    tmp___1 = open_track_fd();
    }
#line 542
    return (tmp___1);
  }
#line 575
  if (network_sockets_used) {
    {
#line 577
    tmp___8 = open_track_fd();
    }
#line 577
    return (tmp___8);
  } else {
    {
#line 579
    tmp___10 = (int )mpg123_open_64(mh, (char const   *)fname);
    }
#line 579
    if (tmp___10 != 0) {
      {
#line 581
      tmp___9 = (char const   *)mpg123_strerror(mh);
#line 581
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot open %s: %s\n",
              581, fname, tmp___9);
      }
#line 582
      return (0);
    }
  }
#line 585
  fresh = 1;
#line 586
  return (1);
}
}
#line 590 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
void close_track(void) 
{ 


  {
  {
#line 592
  mpg123_close(mh);
#line 599
  network_sockets_used = 0;
  }
#line 600
  if (filept > -1) {
    {
#line 600
    close(filept);
    }
  }
#line 601
  filept = -1;
#line 602
  return;
}
}
#line 605 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
int play_frame(void) 
{ 
  unsigned char *audio ;
  int mc ;
  size_t bytes ;
  int tmp ;
  long clip ;
  long tmp___0 ;
  char const   *tmp___1 ;
  long rate ;
  int channels ;
  int format ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 612
  mc = (int )mpg123_decode_frame_64(mh, & framenum, & audio, & bytes);
  }
#line 614
  if (bytes) {
#line 616
    if (param.frame_number > -1L) {
#line 616
      frames_left --;
    }
#line 617
    if (fresh) {
#line 617
      if (framenum >= (off_t )param.start_frame) {
#line 619
        fresh = 0;
#line 620
        if (! param.quiet) {
#line 622
          if (param.verbose) {
            {
#line 622
            print_header(mh);
            }
          } else {
            {
#line 623
            print_header_compact(mh);
            }
          }
        }
      }
    }
    {
#line 627
    tmp = flush_output(ao, audio, bytes);
    }
#line 627
    if (tmp < (int )bytes) {
#line 627
      if (! intflag) {
        {
#line 629
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Deep trouble! Cannot flush to my output anymore!\n",
                629);
#line 630
        safe_exit(133);
        }
      }
    }
#line 632
    if (param.checkrange) {
      {
#line 634
      tmp___0 = (long )mpg123_clip(mh);
#line 634
      clip = tmp___0;
      }
#line 635
      if (clip > 0L) {
        {
#line 635
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%ld samples clipped\n",
                clip);
        }
      }
    }
  }
#line 639
  if (mc != 0) {
#line 641
    if (mc == -1) {
#line 641
      goto _L;
    } else
#line 641
    if (mc == -12) {
      _L: /* CIL Label */ 
#line 643
      if (mc == -1) {
        {
#line 643
        tmp___1 = (char const   *)mpg123_strerror(mh);
#line 643
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: ...in decoding next frame: %s\n",
                643, tmp___1);
        }
      }
#line 644
      return (0);
    }
#line 646
    if (mc == 14) {
      {
#line 648
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: I have not enough output space? I didn\'t plan for this.\n",
              648);
      }
#line 649
      return (0);
    }
#line 651
    if (mc == -11) {
      {
#line 655
      mpg123_getformat(mh, & rate, & channels, & format);
      }
#line 656
      if (param.verbose > 2) {
        {
#line 656
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: New output format %liHz %ich, format %i\n",
                rate, channels, format);
        }
      }
      {
#line 658
      reset_audio(rate, channels, format);
      }
    }
  }
#line 661
  return (1);
}
}
#line 664 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
void buffer_drain(void) 
{ 
  int s ;
  struct timeval wait170 ;
  size_t tmp ;

  {
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 668
    tmp = xfermem_get_usedspace(buffermem);
#line 668
    s = (int )tmp;
    }
#line 668
    if (! s) {
#line 668
      goto while_break;
    }
#line 670
    wait170.tv_sec = (__time_t )0;
#line 670
    wait170.tv_usec = (__suseconds_t )170000;
#line 671
    if (intflag) {
#line 671
      goto while_break;
    }
#line 672
    if (param.usebuffer) {
      {
#line 672
      real_buffer_ignore_lowmem();
      }
    }
#line 673
    if (param.verbose) {
      {
#line 673
      print_stat(mh, 0L, (long )s);
      }
    }
#line 675
    if (param.term_ctrl) {
      {
#line 675
      term_control(mh, ao);
      }
    }
    {
#line 677
    select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& wait170));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  return;
}
}
#line 684 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
int skip_or_die(struct timeval *start_time ) 
{ 
  struct timeval now ;
  unsigned long secdiff ;

  {
#line 694
  if (! param.term_ctrl) {
    {
#line 699
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 700
    secdiff = (unsigned long )((now.tv_sec - start_time->tv_sec) * 1000L);
    }
#line 701
    if (now.tv_usec >= start_time->tv_usec) {
#line 702
      secdiff += (unsigned long )((now.tv_usec - start_time->tv_usec) / 1000L);
    } else {
#line 704
      secdiff -= (unsigned long )((start_time->tv_usec - now.tv_usec) / 1000L);
    }
#line 705
    if (secdiff < 1000UL) {
#line 708
      return (0);
    } else {
#line 713
      skip_tracks ++;
    }
  } else
#line 717
  if (skip_tracks == 0) {
#line 720
    return (0);
  }
#line 723
  return (1);
}
}
#line 730 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
int main(int sys_argc , char **sys_argv ) 
{ 
  int result ;
  long parr ;
  char *fname ;
  int libpar ;
  mpg123_pars *mp ;
  struct timeval start_time ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   **all_dec ;
  char const   **tmp___1 ;
  char const   **all_dec___0 ;
  char const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  long default_index ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int mypid ;
  __pid_t tmp___9 ;
  struct sched_param sp ;
  int tmp___10 ;
  int ret ;
  char *dirname ;
  char *filename ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *term_type ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int meta ;
  int tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  double secs ;
  int tmp___22 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;

  {
  {
#line 735
  libpar = 0;
#line 748
  argv = sys_argv;
#line 749
  argc = sys_argc;
#line 756
  prgName = strrchr((char const   *)*(argv + 0), '/');
  }
#line 756
  if (prgName) {
#line 759
    *(prgName + 0) = (char)0;
#line 760
    prgName ++;
#line 761
    binpath = *(argv + 0);
  } else {
    {
#line 756
    prgName = strrchr((char const   *)*(argv + 0), '\\');
    }
#line 756
    if (prgName) {
#line 759
      *(prgName + 0) = (char)0;
#line 760
      prgName ++;
#line 761
      binpath = *(argv + 0);
    } else {
#line 765
      prgName = *(argv + 0);
#line 766
      binpath = (char *)((void *)0);
    }
  }
  {
#line 771
  result = (int )mpg123_init();
  }
#line 772
  if (result != 0) {
    {
#line 774
    tmp = (char const   *)mpg123_plain_strerror(result);
#line 774
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot initialize mpg123 library: %s\n",
            774, tmp);
#line 775
    safe_exit(77);
    }
  }
  {
#line 777
  cleanup_mpg123 = 1;
#line 779
  mp = (mpg123_pars *)mpg123_new_pars(& result);
  }
#line 780
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
    {
#line 782
    tmp___0 = (char const   *)mpg123_plain_strerror(result);
#line 782
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Crap! Cannot get mpg123 parameters: %s\n",
            782, tmp___0);
#line 783
    safe_exit(78);
    }
  }
  {
#line 787
  mpg123_getpar(mp, (enum mpg123_parms )4, & parr, (double *)((void *)0));
#line 788
  param.down_sample = (int )parr;
#line 789
  mpg123_getpar(mp, (enum mpg123_parms )5, & param.rva, (double *)((void *)0));
#line 790
  mpg123_getpar(mp, (enum mpg123_parms )6, & param.halfspeed, (double *)((void *)0));
#line 791
  mpg123_getpar(mp, (enum mpg123_parms )7, & param.doublespeed, (double *)((void *)0));
#line 792
  mpg123_getpar(mp, (enum mpg123_parms )11, & param.outscale, (double *)((void *)0));
#line 793
  mpg123_getpar(mp, (enum mpg123_parms )1, & parr, (double *)((void *)0));
#line 794
  mpg123_getpar(mp, (enum mpg123_parms )15, & param.index_size, (double *)((void *)0));
#line 795
  param.flags = (int )parr;
#line 796
  param.flags |= 256;
#line 797
  mpg123_getpar(mp, (enum mpg123_parms )14, & param.resync_limit, (double *)((void *)0));
#line 798
  mpg123_getpar(mp, (enum mpg123_parms )16, & param.preframes, (double *)((void *)0));
  }
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 804
    result = getlopt(argc, argv, opts);
    }
#line 804
    if (! result) {
#line 804
      goto while_break;
    }
    {
#line 806
    if (result == -1) {
#line 806
      goto case_neg_1;
    }
#line 810
    if (result == -2) {
#line 810
      goto case_neg_2;
    }
#line 805
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown option \"%s\".\n",
            prgName, loptarg);
#line 809
    usage(1);
    }
    case_neg_2: /* CIL Label */ 
    {
#line 811
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Missing argument for option \"%s\".\n",
            prgName, loptarg);
#line 813
    usage(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 816
  check_locale();
  }
#line 818
  if (param.list_cpu) {
    {
#line 820
    tmp___1 = (char const   **)mpg123_decoders();
#line 820
    all_dec = tmp___1;
#line 821
    printf((char const   */* __restrict  */)"Builtin decoders:");
    }
    {
#line 822
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 822
      if (! ((unsigned long )*all_dec != (unsigned long )((void *)0))) {
#line 822
        goto while_break___0;
      }
      {
#line 822
      printf((char const   */* __restrict  */)" %s", *all_dec);
#line 822
      all_dec ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 823
    printf((char const   */* __restrict  */)"\n");
#line 824
    mpg123_delete_pars(mp);
    }
#line 825
    return (0);
  }
#line 827
  if (param.test_cpu) {
    {
#line 829
    tmp___2 = (char const   **)mpg123_supported_decoders();
#line 829
    all_dec___0 = tmp___2;
#line 830
    printf((char const   */* __restrict  */)"Supported decoders:");
    }
    {
#line 831
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 831
      if (! ((unsigned long )*all_dec___0 != (unsigned long )((void *)0))) {
#line 831
        goto while_break___1;
      }
      {
#line 831
      printf((char const   */* __restrict  */)" %s", *all_dec___0);
#line 831
      all_dec___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 832
    printf((char const   */* __restrict  */)"\n");
#line 833
    mpg123_delete_pars(mp);
    }
#line 834
    return (0);
  }
#line 836
  if (param.gain != -1L) {
    {
#line 838
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] warning: The parameter -g is deprecated and may be removed in the future.\n",
            838);
    }
  }
#line 841
  if (loptind >= argc) {
#line 841
    if (! param.listname) {
#line 841
      if (! param.remote) {
        {
#line 841
        usage(1);
        }
      }
    }
  }
  {
#line 844
  bufferblock = (size_t )mpg123_safe_buffer();
#line 845
  tmp___3 = init_output(& ao);
  }
#line 845
  if (tmp___3 < 0) {
    {
#line 847
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Failed to initialize output, goodbye.\n",
            847);
#line 848
    mpg123_delete_pars(mp);
    }
#line 849
    return (99);
  }
  {
#line 851
  have_output = 1;
#line 858
  httpdata_init(& htd);
  }
#line 861
  if (param.remote) {
#line 863
    param.verbose = 0;
#line 864
    param.quiet = 1;
#line 865
    param.flags |= 32;
  }
#line 870
  if (param.quiet) {
#line 870
    param.flags |= 32;
  }
#line 873
  if (dnow != 0) {
#line 873
    if (dnow == 1) {
#line 873
      param.cpu = (char *)"3dnow";
    } else {
#line 873
      param.cpu = (char *)"i586";
    }
  }
#line 875
  if ((unsigned long )param.cpu != (unsigned long )((void *)0)) {
    {
#line 875
    tmp___4 = strcmp((char const   *)param.cpu, "auto");
    }
#line 875
    if (tmp___4) {
      {
#line 875
      tmp___5 = strcmp((char const   *)param.cpu, "");
      }
#line 875
      if (! tmp___5) {
#line 875
        param.cpu = (char *)((void *)0);
      }
    } else {
#line 875
      param.cpu = (char *)((void *)0);
    }
  }
  {
#line 876
  result = (int )mpg123_par(mp, (enum mpg123_parms )0, (long )param.verbose, (double )0);
  }
#line 876
  if (0 == result) {
#line 876
    libpar ++;
#line 876
    if (libpar) {
      {
#line 876
      result = (int )mpg123_par(mp, (enum mpg123_parms )1, (long )param.flags, (double )0);
      }
#line 876
      if (0 == result) {
#line 876
        libpar ++;
#line 876
        if (libpar) {
          {
#line 876
          result = (int )mpg123_par(mp, (enum mpg123_parms )4, (long )param.down_sample,
                                    (double )0);
          }
#line 876
          if (0 == result) {
#line 876
            libpar ++;
#line 876
            if (libpar) {
              {
#line 876
              result = (int )mpg123_par(mp, (enum mpg123_parms )5, param.rva, (double )0);
              }
#line 876
              if (0 == result) {
#line 876
                libpar ++;
#line 876
                if (libpar) {
                  {
#line 876
                  result = (int )mpg123_par(mp, (enum mpg123_parms )3, param.force_rate,
                                            (double )0);
                  }
#line 876
                  if (0 == result) {
#line 876
                    libpar ++;
#line 876
                    if (libpar) {
                      {
#line 876
                      result = (int )mpg123_par(mp, (enum mpg123_parms )6, param.halfspeed,
                                                (double )0);
                      }
#line 876
                      if (0 == result) {
#line 876
                        libpar ++;
#line 876
                        if (libpar) {
                          {
#line 876
                          result = (int )mpg123_par(mp, (enum mpg123_parms )7, param.doublespeed,
                                                    (double )0);
                          }
#line 876
                          if (0 == result) {
#line 876
                            libpar ++;
#line 876
                            if (libpar) {
                              {
#line 876
                              result = (int )mpg123_par(mp, (enum mpg123_parms )10,
                                                        0L, (double )0);
                              }
#line 876
                              if (0 == result) {
#line 876
                                libpar ++;
#line 876
                                if (libpar) {
                                  {
#line 876
                                  result = (int )mpg123_par(mp, (enum mpg123_parms )14,
                                                            param.resync_limit, (double )0);
                                  }
#line 876
                                  if (0 == result) {
#line 876
                                    libpar ++;
#line 876
                                    if (libpar) {
                                      {
#line 876
                                      result = (int )mpg123_par(mp, (enum mpg123_parms )12,
                                                                param.timeout, (double )0);
                                      }
#line 876
                                      if (0 == result) {
#line 876
                                        libpar ++;
#line 876
                                        if (libpar) {
                                          {
#line 876
                                          result = (int )mpg123_par(mp, (enum mpg123_parms )11,
                                                                    param.outscale,
                                                                    (double )0);
                                          }
#line 876
                                          if (0 == result) {
#line 876
                                            libpar ++;
#line 876
                                            if (libpar) {
                                              {
#line 876
                                              result = (int )mpg123_par(mp, (enum mpg123_parms )16,
                                                                        param.preframes,
                                                                        (double )0);
                                              }
#line 876
                                              if (! (0 == result)) {
                                                {
#line 901
                                                tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                                        901, libpar, tmp___6);
#line 902
                                                safe_exit(45);
                                                }
                                              }
                                            } else {
                                              {
#line 901
                                              tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                                      901, libpar, tmp___6);
#line 902
                                              safe_exit(45);
                                              }
                                            }
                                          } else {
                                            {
#line 901
                                            tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                                            fprintf((FILE */* __restrict  */)stderr,
                                                    (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                                    901, libpar, tmp___6);
#line 902
                                            safe_exit(45);
                                            }
                                          }
                                        } else {
                                          {
#line 901
                                          tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                                          fprintf((FILE */* __restrict  */)stderr,
                                                  (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                                  901, libpar, tmp___6);
#line 902
                                          safe_exit(45);
                                          }
                                        }
                                      } else {
                                        {
#line 901
                                        tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                                901, libpar, tmp___6);
#line 902
                                        safe_exit(45);
                                        }
                                      }
                                    } else {
                                      {
#line 901
                                      tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                              901, libpar, tmp___6);
#line 902
                                      safe_exit(45);
                                      }
                                    }
                                  } else {
                                    {
#line 901
                                    tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                            901, libpar, tmp___6);
#line 902
                                    safe_exit(45);
                                    }
                                  }
                                } else {
                                  {
#line 901
                                  tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                          901, libpar, tmp___6);
#line 902
                                  safe_exit(45);
                                  }
                                }
                              } else {
                                {
#line 901
                                tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                        901, libpar, tmp___6);
#line 902
                                safe_exit(45);
                                }
                              }
                            } else {
                              {
#line 901
                              tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                      901, libpar, tmp___6);
#line 902
                              safe_exit(45);
                              }
                            }
                          } else {
                            {
#line 901
                            tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                    901, libpar, tmp___6);
#line 902
                            safe_exit(45);
                            }
                          }
                        } else {
                          {
#line 901
                          tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                  901, libpar, tmp___6);
#line 902
                          safe_exit(45);
                          }
                        }
                      } else {
                        {
#line 901
                        tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                                901, libpar, tmp___6);
#line 902
                        safe_exit(45);
                        }
                      }
                    } else {
                      {
#line 901
                      tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                              901, libpar, tmp___6);
#line 902
                      safe_exit(45);
                      }
                    }
                  } else {
                    {
#line 901
                    tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                            901, libpar, tmp___6);
#line 902
                    safe_exit(45);
                    }
                  }
                } else {
                  {
#line 901
                  tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                          901, libpar, tmp___6);
#line 902
                  safe_exit(45);
                  }
                }
              } else {
                {
#line 901
                tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                        901, libpar, tmp___6);
#line 902
                safe_exit(45);
                }
              }
            } else {
              {
#line 901
              tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                      901, libpar, tmp___6);
#line 902
              safe_exit(45);
              }
            }
          } else {
            {
#line 901
            tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                    901, libpar, tmp___6);
#line 902
            safe_exit(45);
            }
          }
        } else {
          {
#line 901
          tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                  901, libpar, tmp___6);
#line 902
          safe_exit(45);
          }
        }
      } else {
        {
#line 901
        tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
                901, libpar, tmp___6);
#line 902
        safe_exit(45);
        }
      }
    } else {
      {
#line 901
      tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
              901, libpar, tmp___6);
#line 902
      safe_exit(45);
      }
    }
  } else {
    {
#line 901
    tmp___6 = (char const   *)mpg123_plain_strerror(result);
#line 901
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Cannot set library parameter %i: %s\n",
            901, libpar, tmp___6);
#line 902
    safe_exit(45);
    }
  }
#line 904
  if (! (param.listentry < 0L)) {
#line 904
    if (! param.quiet) {
      {
#line 904
      print_title(stderr);
      }
    }
  }
  {
#line 908
  mpg123_getpar(mp, (enum mpg123_parms )15, & default_index, (double *)((void *)0));
  }
#line 909
  if (param.index_size != default_index) {
    {
#line 909
    result = (int )mpg123_par(mp, (enum mpg123_parms )15, param.index_size, 0.);
    }
#line 909
    if (result != 0) {
      {
#line 910
      tmp___7 = (char const   *)mpg123_plain_strerror(result);
#line 910
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Setting of frame index size failed: %s\n",
              910, tmp___7);
      }
    }
  }
#line 913
  if (param.force_rate) {
#line 913
    if (param.down_sample) {
      {
#line 915
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Down sampling and fixed rate options not allowed together!\n",
              915);
#line 916
      safe_exit(1);
      }
    }
  }
  {
#line 920
  mh = (mpg123_handle *)mpg123_parnew(mp, (char const   *)param.cpu, & result);
  }
#line 921
  if ((unsigned long )mh == (unsigned long )((void *)0)) {
    {
#line 923
    tmp___8 = (char const   *)mpg123_plain_strerror(result);
#line 923
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Crap! Cannot get a mpg123 handle: %s\n",
            923, tmp___8);
#line 924
    safe_exit(77);
    }
  }
  {
#line 926
  mpg123_delete_pars(mp);
#line 929
  audio_capabilities(ao, mh);
#line 931
  load_equalizer(mh);
  }
#line 934
  if (param.aggressive) {
    {
#line 935
    tmp___9 = getpid();
#line 935
    mypid = tmp___9;
#line 936
    setpriority(0, (id_t )mypid, -20);
    }
  }
#line 942
  if (param.realtime) {
    {
#line 944
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getting real-time priority\n");
#line 945
    memset((void *)(& sp), 0, (size_t )sizeof(struct sched_param ));
#line 946
    sp.__sched_priority = sched_get_priority_min(1);
#line 947
    tmp___10 = sched_setscheduler(0, 2, (struct sched_param  const  *)(& sp));
    }
#line 947
    if (tmp___10 == -1) {
      {
#line 948
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t get real-time priority\n");
      }
    }
  }
#line 957
  if (! param.remote) {
    {
#line 957
    prepare_playlist(argc, argv);
    }
  }
#line 963
  if (! param.remote) {
    {
#line 963
    catchsignal(2, & catch_interrupt);
    }
  }
#line 966
  if (param.remote) {
    {
#line 968
    ret = control_generic(mh);
#line 969
    safe_exit(ret);
    }
  }
#line 973
  if (param.term_ctrl) {
    {
#line 974
    term_init();
    }
  }
  {
#line 976
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 976
    fname = get_next_file();
    }
#line 976
    if (! fname) {
#line 976
      goto while_break___2;
    }
#line 980
    if (skip_tracks) {
#line 980
      skip_tracks --;
    }
#line 981
    if (skip_tracks) {
#line 984
      goto while_continue___2;
    }
#line 986
    if (param.delay > 0) {
#line 989
      if (param.verbose > 2) {
        {
#line 989
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: pausing %i seconds before next track.\n",
                param.delay);
        }
      }
      {
#line 990
      output_pause(ao);
#line 994
      sleep((unsigned int )param.delay);
#line 996
      output_unpause(ao);
      }
    }
#line 998
    frames_left = (off_t )param.frame_number;
#line 1001
    if (intflag) {
#line 1001
      goto _L;
    } else {
      {
#line 1001
      tmp___11 = open_track(fname);
      }
#line 1001
      if (! tmp___11) {
        _L: /* CIL Label */ 
#line 1005
        if (param.term_ctrl) {
          {
#line 1005
          term_control(mh, ao);
          }
        }
#line 1008
        if (intflag) {
#line 1008
          goto while_break___2;
        }
#line 1010
        goto while_continue___2;
      }
    }
#line 1013
    if (! param.quiet) {
      {
#line 1013
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1014
    if (param.index) {
#line 1016
      if (param.verbose) {
        {
#line 1016
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"indexing...\r");
        }
      }
      {
#line 1017
      mpg123_scan(mh);
      }
    }
#line 1024
    framenum = (off_t )0;
#line 1025
    if (param.start_frame > 0L) {
      {
#line 1026
      framenum = (off_t )mpg123_seek_frame_64(mh, (off_t )param.start_frame, 0);
      }
    }
#line 1028
    if (framenum < 0LL) {
      {
#line 1030
      tmp___12 = (char const   *)mpg123_strerror(mh);
#line 1030
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c:%i] error: Initial seek failed: %s\n",
              1030, tmp___12);
#line 1031
      tmp___13 = (int )mpg123_errcode(mh);
      }
#line 1031
      if (tmp___13 == 1) {
        {
#line 1033
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                "So, you have trouble getting an output format... this is the matrix of currently possible formats:\n");
#line 1034
        print_capabilities(ao, mh);
#line 1035
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                "Somehow the input data and your choices don\'t allow one of these.\n");
        }
      }
      {
#line 1037
      mpg123_close(mh);
      }
#line 1038
      goto while_continue___2;
    }
#line 1041
    if (! param.quiet) {
#line 1043
      if (fname) {
#line 1043
        tmp___14 = (char const   *)fname;
      } else {
#line 1043
        tmp___14 = "standard input";
      }
      {
#line 1043
      tmp___15 = split_dir_file(tmp___14, & dirname, & filename);
      }
#line 1043
      if (tmp___15) {
        {
#line 1045
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Directory: %s\n",
                dirname);
        }
      }
#line 1049
      if (param.term_ctrl) {
        {
#line 1049
        term_hint();
        }
      }
      {
#line 1053
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Playing MPEG stream %lu of %lu: %s ...\n",
              (unsigned long )pl.pos, (unsigned long )pl.fill, filename);
      }
#line 1054
      if (htd.icy_name.fill) {
        {
#line 1054
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ICY-NAME: %s\n",
                htd.icy_name.p);
        }
      }
#line 1055
      if (htd.icy_url.fill) {
        {
#line 1055
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ICY-URL: %s\n",
                htd.icy_url.p);
        }
      }
      {
#line 1060
      tmp___16 = getenv("TERM");
#line 1060
      term_type = (char const   *)tmp___16;
      }
#line 1061
      if (term_type) {
#line 1061
        if (param.xterm_title) {
          {
#line 1061
          tmp___17 = strncmp(term_type, "xterm", (size_t )5);
          }
#line 1061
          if (tmp___17) {
            {
#line 1061
            tmp___18 = strncmp(term_type, "rxvt", (size_t )4);
            }
#line 1061
            if (! tmp___18) {
              {
#line 1064
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033]0;%s\a",
                      filename);
              }
            }
          } else {
            {
#line 1064
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033]0;%s\a",
                    filename);
            }
          }
        }
      }
    }
#line 1073
    if (! param.term_ctrl) {
      {
#line 1075
      gettimeofday((struct timeval */* __restrict  */)(& start_time), (__timezone_ptr_t )((void *)0));
      }
    }
    {
#line 1078
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1078
      if (! (! intflag)) {
#line 1078
        goto while_break___3;
      }
#line 1081
      if (param.frame_number > -1L) {
#line 1084
        if (! frames_left) {
#line 1084
          goto while_break___3;
        }
      }
      {
#line 1086
      tmp___19 = play_frame();
      }
#line 1086
      if (! tmp___19) {
#line 1086
        goto while_break___3;
      }
#line 1087
      if (! param.quiet) {
        {
#line 1089
        meta = (int )mpg123_meta_check(mh);
        }
#line 1090
        if (meta & 5) {
#line 1092
          if (meta & 1) {
            {
#line 1092
            print_id3_tag(mh, param.long_id3, stderr);
            }
          }
#line 1093
          if (meta & 4) {
            {
#line 1093
            print_icy(mh, stderr);
            }
          }
        }
      }
#line 1096
      if (! fresh) {
#line 1096
        if (param.verbose) {
#line 1099
          if (param.verbose > 1) {
            {
#line 1100
            tmp___20 = xfermem_get_usedspace(buffermem);
#line 1100
            print_stat(mh, 0L, (long )tmp___20);
            }
          } else
#line 1099
          if (! (framenum & 7LL)) {
            {
#line 1100
            tmp___20 = xfermem_get_usedspace(buffermem);
#line 1100
            print_stat(mh, 0L, (long )tmp___20);
            }
          }
        }
      }
#line 1106
      if (! param.term_ctrl) {
#line 1106
        goto while_continue___3;
      } else {
        {
#line 1107
        term_control(mh, ao);
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1111
    if (! param.smooth) {
#line 1111
      if (param.usebuffer) {
        {
#line 1111
        buffer_drain();
        }
      }
    }
#line 1112
    if (param.verbose) {
      {
#line 1112
      tmp___21 = xfermem_get_usedspace(buffermem);
#line 1112
      print_stat(mh, 0L, (long )tmp___21);
      }
    }
#line 1114
    if (! param.quiet) {
      {
#line 1117
      mpg123_position_64(mh, (off_t )0, (off_t )0, (off_t *)((void *)0), (off_t *)((void *)0),
                         & secs, (double *)((void *)0));
#line 1118
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n[%d:%02d] Decoding of %s finished.\n",
              (int )(secs / (double )60), (int )secs % 60, filename);
      }
    } else
#line 1120
    if (param.verbose) {
      {
#line 1120
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 1122
    mpg123_close(mh);
    }
#line 1124
    if (intflag) {
      {
#line 1126
      tmp___22 = skip_or_die(& start_time);
      }
#line 1126
      if (! tmp___22) {
#line 1126
        goto while_break___2;
      }
#line 1128
      intflag = 0;
#line 1131
      if (! param.smooth) {
#line 1131
        if (param.usebuffer) {
#line 1131
          if (param.usebuffer) {
            {
#line 1131
            real_buffer_resync();
            }
          }
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1136
  if (param.smooth) {
#line 1136
    if (param.usebuffer) {
      {
#line 1138
      buffer_drain();
      }
#line 1139
      if (param.usebuffer) {
        {
#line 1139
        real_buffer_resync();
        }
      }
    }
  }
#line 1142
  if (! param.remote) {
    {
#line 1142
    free_playlist();
    }
  }
  {
#line 1144
  safe_exit(0);
  }
#line 1145
  return (0);
}
}
#line 1148 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void print_title(FILE *o ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1150
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"High Performance MPEG 1.0/2.0/2.5 Audio Player for Layers 1, 2 and 3\n");
#line 1151
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"\tversion %s; written and copyright by Michael Hipp and others\n",
          "1.12.1");
#line 1152
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"\tfree software (LGPL/GPL) without any warranty but with best wishes\n");
  }
#line 1153
  return;
}
}
#line 1155 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void usage(int err ) 
{ 
  FILE *o ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 1157
  o = stdout;
#line 1158
  if (err) {
    {
#line 1160
    o = stderr;
#line 1161
    fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"You made some mistake in program usage... let me briefly remind you:\n\n");
    }
  }
  {
#line 1163
  print_title(o);
#line 1164
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"\nusage: %s [option(s)] [file(s) | URL(s) | -]\n",
          prgName);
#line 1165
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"supported options [defaults in brackets]:\n");
#line 1166
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -v    increase verbosity level       -q    quiet (don\'t print title)\n");
#line 1167
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -t    testmode (no output)           -s    write to stdout\n");
#line 1168
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -w <filename> write Output as WAV file\n");
#line 1169
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -k n  skip first n frames [0]        -n n  decode only n frames [all]\n");
#line 1170
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -c    check range violations         -y    DISABLE resync on errors\n");
#line 1171
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -b n  output buffer: n Kbytes [0]    -f n  change scalefactor [%li]\n",
          param.outscale);
#line 1172
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -r n  set/force samplerate [auto]\n");
#line 1173
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -os,-ol,-oh  output to built-in speaker,line-out connector,headphones\n");
#line 1179
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"                                        -a d  set audio device\n");
#line 1181
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -2    downsample 1:2 (22 kHz)        -4    downsample 1:4 (11 kHz)\n");
#line 1182
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -d n  play every n\'th frame only     -h n  play every frame n times\n");
#line 1183
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -0    decode channel 0 (left) only   -1    decode channel 1 (right) only\n");
#line 1184
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -m    mix both channels (mono)       -p p  use HTTP proxy p [$HTTP_PROXY]\n");
#line 1186
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -@ f  read filenames/URLs from f     -T get realtime priority\n");
#line 1190
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -z    shuffle play (with wildcards)  -Z    random play\n");
#line 1191
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -u a  HTTP authentication string     -E f  Equalizer, data from file\n");
#line 1192
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -C    enable control keys            --no-gapless  not skip junk/padding in mp3s\n");
#line 1193
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"   -?    this help                      --version  print name + version\n");
#line 1194
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"See the manpage %s(1) or call %s with --longhelp for more parameters and information.\n",
          prgName, prgName);
#line 1195
  safe_exit(err);
  }
#line 1196
  return;
}
}
#line 1198 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void want_usage(char *arg ) 
{ 


  {
  {
#line 1200
  usage(0);
  }
#line 1201
  return;
}
}
#line 1203 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void long_usage(int err ) 
{ 
  char *enclist ;
  FILE *o ;
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;

  {
#line 1206
  o = stdout;
#line 1207
  if (err) {
    {
#line 1209
    o = stderr;
#line 1210
    fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"You made some mistake in program usage... let me remind you:\n\n");
    }
  }
  {
#line 1212
  print_title(o);
#line 1213
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"\nusage: %s [option(s)] [file(s) | URL(s) | -]\n",
          prgName);
#line 1215
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"\ninput options\n\n");
#line 1216
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -k <n> --skip <n>         skip n frames at beginning\n");
#line 1217
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -n     --frames <n>       play only <n> frames of every stream\n");
#line 1218
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --fuzzy            Enable fuzzy seeks (guessing byte offsets or using approximate seek points from Xing TOC)\n");
#line 1219
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -y     --no-resync        DISABLES resync on error (--resync is deprecated)\n");
#line 1220
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -p <f> --proxy <f>        set WWW proxy\n");
#line 1221
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -u     --auth             set auth values for HTTP access\n");
#line 1222
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --ignore-mime      ignore HTTP MIME types (content-type)\n");
#line 1223
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -@ <f> --list <f>         play songs in playlist <f> (plain list, m3u, pls (shoutcast))\n");
#line 1224
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -l <n> --listentry <n>    play nth title in playlist; show whole playlist for n < 0\n");
#line 1225
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --loop <n>         loop track(s) <n> times, < 0 means infinite loop (not with --random!)\n");
#line 1226
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --keep-open        (--remote mode only) keep loaded file open after reaching end\n");
#line 1227
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --timeout <n>      Timeout in seconds before declaring a stream dead (if <= 0, wait forever)\n");
#line 1228
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -z     --shuffle          shuffle song-list before playing\n");
#line 1229
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -Z     --random           full random play\n");
#line 1230
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --no-icy-meta      Do not accept ICY meta data\n");
#line 1231
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -i     --index            index / scan through the track before playback\n");
#line 1232
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --index-size <n>   change size of frame index\n");
#line 1233
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --preframes  <n>   number of frames to decode in advance after seeking (to keep layer 3 bit reservoir happy)\n");
#line 1234
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --resync-limit <n> Set number of bytes to search for valid MPEG data; <0 means search whole stream.\n");
#line 1235
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"\noutput/processing options\n\n");
#line 1236
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -o <o> --output <o>       select audio output module\n");
#line 1237
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --list-modules     list the available modules\n");
#line 1238
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -a <d> --audiodevice <d>  select audio device\n");
#line 1239
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -s     --stdout           write raw audio to stdout (host native format)\n");
#line 1240
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -S     --STDOUT           play AND output stream (not implemented yet)\n");
#line 1241
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -w <f> --wav <f>          write samples as WAV file in <f> (- is stdout)\n");
#line 1242
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --au <f>           write samples as Sun AU file in <f> (- is stdout)\n");
#line 1243
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --cdr <f>          write samples as raw CD audio file in <f> (- is stdout)\n");
#line 1244
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --reopen           force close/open on audiodevice\n");
#line 1246
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --cpu <string>     set cpu optimization\n");
#line 1247
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --test-cpu         list optmizations possible with cpu and exit\n");
#line 1248
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --list-cpu         list builtin optimizations and exit\n");
#line 1251
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --test-3dnow       display result of 3DNow! autodetect and exit (obsoleted by --cpu)\n");
#line 1252
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --force-3dnow      force use of 3DNow! optimized routine (obsoleted by --test-cpu)\n");
#line 1253
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --no-3dnow         force use of floating-pointer routine (obsoleted by --cpu)\n");
#line 1255
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -g     --gain             [DEPRECATED] set audio hardware output gain\n");
#line 1256
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -f <n> --scale <n>        scale output samples (soft gain - based on 32768), default=%li)\n",
          param.outscale);
#line 1257
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --rva-mix,\n");
#line 1258
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --rva-radio        use RVA2/ReplayGain values for mix/radio mode\n");
#line 1259
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --rva-album,\n");
#line 1260
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --rva-audiophile   use RVA2/ReplayGain values for album/audiophile mode\n");
#line 1261
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -0     --left --single0   play only left channel\n");
#line 1262
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -1     --right --single1  play only right channel\n");
#line 1263
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -m     --mono --mix       mix stereo to mono\n");
#line 1264
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --stereo           duplicate mono channel\n");
#line 1265
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -r     --rate             force a specific audio output rate\n");
#line 1266
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -2     --2to1             2:1 downsampling\n");
#line 1267
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -4     --4to1             4:1 downsampling\n");
#line 1268
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --pitch <value>    set hardware pitch (speedup/down, 0 is neutral; 0.05 is 5%%)\n");
#line 1269
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --8bit             force 8 bit output\n");
#line 1270
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --float            force floating point output (internal precision)\n");
#line 1271
  audio_enclist(& enclist);
  }
#line 1272
  if ((unsigned long )enclist != (unsigned long )((void *)0)) {
#line 1272
    tmp = (char const   *)enclist;
  } else {
#line 1272
    tmp = "OOM!";
  }
  {
#line 1272
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -e <c> --encoding <c>     force a specific encoding c (%s)\n",
          tmp);
#line 1273
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -d n   --doublespeed n    play only every nth frame\n");
#line 1274
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -h n   --halfspeed   n    play every frame n times\n");
#line 1275
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --equalizer        exp.: scales freq. bands acrd. to \'equalizer.dat\'\n");
#line 1276
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --gapless          remove padding/junk on mp3s (best with Lame tag)\n");
#line 1277
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"                           This is on by default when libmpg123 supports it.\n");
#line 1278
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --no-gapless       disable gapless mode, not remove padding/junk\n");
#line 1279
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -D n   --delay n          insert a delay of n seconds before each track\n");
#line 1280
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -o h   --headphones       (aix/hp/sun) output on headphones\n");
#line 1281
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -o s   --speaker          (aix/hp/sun) output on speaker\n");
#line 1282
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -o l   --lineout          (aix/hp/sun) output to lineout\n");
#line 1284
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -b <n> --buffer <n>       set play buffer (\"output cache\")\n");
#line 1285
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --preload <value>  fraction of buffer to fill before playback\n");
#line 1286
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --smooth           keep buffer over track boundaries\n");
#line 1289
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"\nmisc options\n\n");
#line 1290
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -t     --test             only decode, no output (benchmark)\n");
#line 1291
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -c     --check            count and display clipped samples\n");
#line 1292
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -v[*]  --verbose          increase verboselevel\n");
#line 1293
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -q     --quiet            quiet mode\n");
#line 1295
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -C     --control          enable terminal control keys\n");
#line 1298
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --title            set xterm/rxvt title to filename\n");
#line 1300
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --long-tag         spacy id3 display with every item on a separate line\n");
#line 1301
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --utf8             Regardless of environment, print metadata in UTF-8.\n");
#line 1302
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -R     --remote           generic remote interface\n");
#line 1303
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --remote-err       force use of stderr for generic remote interface\n");
#line 1305
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --fifo <path>      open a FIFO at <path> for commands instead of stdin\n");
#line 1308
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --aggressive       tries to get higher priority (nice)\n");
#line 1311
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -T     --realtime         tries to get realtime priority\n");
#line 1318
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)" -?     --help             give compact help\n");
#line 1319
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --longhelp         give this long help listing\n");
#line 1320
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"        --version          give name / version string\n");
#line 1322
  fprintf((FILE */* __restrict  */)o, (char const   */* __restrict  */)"\nSee the manpage %s(1) for more information.\n",
          prgName);
#line 1323
  safe_exit(err);
  }
#line 1324
  return;
}
}
#line 1326 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void want_long_usage(char *arg ) 
{ 


  {
  {
#line 1328
  long_usage(0);
  }
#line 1329
  return;
}
}
#line 1331 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123.c"
static void give_version(char *arg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1333
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"mpg123 1.12.1\n");
#line 1334
  safe_exit(0);
  }
#line 1335
  return;
}
}
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/genre.c"
char *genre_table[148]  = 
#line 9 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/genre.c"
  {      (char *)"Blues",      (char *)"Classic Rock",      (char *)"Country",      (char *)"Dance", 
        (char *)"Disco",      (char *)"Funk",      (char *)"Grunge",      (char *)"Hip-Hop", 
        (char *)"Jazz",      (char *)"Metal",      (char *)"New Age",      (char *)"Oldies", 
        (char *)"Other",      (char *)"Pop",      (char *)"R&B",      (char *)"Rap", 
        (char *)"Reggae",      (char *)"Rock",      (char *)"Techno",      (char *)"Industrial", 
        (char *)"Alternative",      (char *)"Ska",      (char *)"Death Metal",      (char *)"Pranks", 
        (char *)"Soundtrack",      (char *)"Euro-Techno",      (char *)"Ambient",      (char *)"Trip-Hop", 
        (char *)"Vocal",      (char *)"Jazz+Funk",      (char *)"Fusion",      (char *)"Trance", 
        (char *)"Classical",      (char *)"Instrumental",      (char *)"Acid",      (char *)"House", 
        (char *)"Game",      (char *)"Sound Clip",      (char *)"Gospel",      (char *)"Noise", 
        (char *)"AlternRock",      (char *)"Bass",      (char *)"Soul",      (char *)"Punk", 
        (char *)"Space",      (char *)"Meditative",      (char *)"Instrumental Pop",      (char *)"Instrumental Rock", 
        (char *)"Ethnic",      (char *)"Gothic",      (char *)"Darkwave",      (char *)"Techno-Industrial", 
        (char *)"Electronic",      (char *)"Pop-Folk",      (char *)"Eurodance",      (char *)"Dream", 
        (char *)"Southern Rock",      (char *)"Comedy",      (char *)"Cult",      (char *)"Gangsta", 
        (char *)"Top 40",      (char *)"Christian Rap",      (char *)"Pop/Funk",      (char *)"Jungle", 
        (char *)"Native American",      (char *)"Cabaret",      (char *)"New Wave",      (char *)"Psychadelic", 
        (char *)"Rave",      (char *)"Showtunes",      (char *)"Trailer",      (char *)"Lo-Fi", 
        (char *)"Tribal",      (char *)"Acid Punk",      (char *)"Acid Jazz",      (char *)"Polka", 
        (char *)"Retro",      (char *)"Musical",      (char *)"Rock & Roll",      (char *)"Hard Rock", 
        (char *)"Folk",      (char *)"Folk/Rock",      (char *)"National folk",      (char *)"Swing", 
        (char *)"Fast-fusion",      (char *)"Bebob",      (char *)"Latin",      (char *)"Revival", 
        (char *)"Celtic",      (char *)"Bluegrass",      (char *)"Avantgarde",      (char *)"Gothic Rock", 
        (char *)"Progressive Rock",      (char *)"Psychedelic Rock",      (char *)"Symphonic Rock",      (char *)"Slow Rock", 
        (char *)"Big Band",      (char *)"Chorus",      (char *)"Easy Listening",      (char *)"Acoustic", 
        (char *)"Humour",      (char *)"Speech",      (char *)"Chanson",      (char *)"Opera", 
        (char *)"Chamber Music",      (char *)"Sonata",      (char *)"Symphony",      (char *)"Booty Bass", 
        (char *)"Primus",      (char *)"Porn Groove",      (char *)"Satire",      (char *)"Slow Jam", 
        (char *)"Club",      (char *)"Tango",      (char *)"Samba",      (char *)"Folklore", 
        (char *)"Ballad",      (char *)"Powder Ballad",      (char *)"Rhythmic Soul",      (char *)"Freestyle", 
        (char *)"Duet",      (char *)"Punk Rock",      (char *)"Drum Solo",      (char *)"A Capella", 
        (char *)"Euro-House",      (char *)"Dance Hall",      (char *)"Goa",      (char *)"Drum & Bass", 
        (char *)"Club House",      (char *)"Hardcore",      (char *)"Terror",      (char *)"Indie", 
        (char *)"BritPop",      (char *)"NegerPunk",      (char *)"Polsk Punk",      (char *)"Beat", 
        (char *)"Christian Gangsta",      (char *)"Heavy Metal",      (char *)"Black Metal",      (char *)"Crossover", 
        (char *)"Contemporary C",      (char *)"Christian Rock",      (char *)"Merengue",      (char *)"Salsa", 
        (char *)"Thrash Metal",      (char *)"Anime",      (char *)"JPop",      (char *)"SynthPop"};
#line 271 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/genre.c"
int const   genre_count  =    (int const   )((int )(sizeof(genre_table) / sizeof(char *)) - 1);
#line 18 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.h"
int split_url(mpg123_string *url , mpg123_string *auth , mpg123_string *host , mpg123_string *port ,
              mpg123_string *path ) ;
#line 23
int open_connection(mpg123_string *host , mpg123_string *port ) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 190
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 638 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 644
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 647
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 39 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c"
int split_url(mpg123_string *url , mpg123_string *auth , mpg123_string *host , mpg123_string *port ,
              mpg123_string *path ) 
{ 
  size_t pos ;
  size_t pos2 ;
  char *part ;
  int ret ;
  int tmp ;
  size_t i ;
  size_t partlen ;
  int have_auth ;
  int tmp___0 ;
  char a ;
  int tmp___1 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 41
  pos = (size_t )0;
#line 42
  pos2 = (size_t )0;
#line 43
  part = (char *)((void *)0);
#line 44
  ret = 1;
#line 46
  if (auth) {
#line 46
    auth->fill = (size_t )0;
  }
#line 47
  if (host) {
#line 47
    host->fill = (size_t )0;
  }
#line 48
  if (port) {
#line 48
    port->fill = (size_t )0;
  }
#line 49
  if (path) {
#line 49
    path->fill = (size_t )0;
  }
#line 51
  if (! url) {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: URL string is not good! (Programmer\'s fault!?)\n",
            53);
    }
#line 54
    return (0);
  } else
#line 51
  if (! url->fill) {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: URL string is not good! (Programmer\'s fault!?)\n",
            53);
    }
#line 54
    return (0);
  } else
#line 51
  if ((int )*(url->p + (url->fill - 1U)) != 0) {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: URL string is not good! (Programmer\'s fault!?)\n",
            53);
    }
#line 54
    return (0);
  }
  {
#line 56
  tmp = strncmp((char const   *)(url->p + pos), "http://", (size_t )7);
  }
#line 56
  if (! tmp) {
#line 57
    pos += 7U;
  }
  {
#line 60
  part = strchr((char const   *)(url->p + pos), '@');
  }
#line 60
  if (part) {
#line 63
    partlen = (size_t )((part - url->p) - (long )pos);
#line 64
    have_auth = 1;
#line 66
    i = (size_t )0;
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
#line 66
      if (! (i < partlen)) {
#line 66
        goto while_break;
      }
#line 68
      if ((int )*(url->p + (pos + i)) == 47) {
#line 70
        have_auth = 0;
#line 71
        goto while_break;
      }
#line 66
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 74
    if (have_auth) {
#line 76
      if ((unsigned long )auth != (unsigned long )((void *)0)) {
        {
#line 76
        tmp___0 = (int )mpg123_set_substring(auth, (char const   *)url->p, pos, partlen);
        }
#line 76
        if (! tmp___0) {
          {
#line 78
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: Cannot set auth string (out of mem?).\n",
                  78);
          }
#line 79
          return (0);
        }
      }
#line 81
      pos += partlen + 1U;
    }
  }
#line 87
  if ((int )*(url->p + pos) == 91) {
    {
#line 89
    pos ++;
#line 90
    part = strchr((char const   *)(url->p + pos), ']');
    }
#line 90
    if ((unsigned long )part != (unsigned long )((void *)0)) {
#line 92
      pos2 = (size_t )(part - url->p);
    } else {
      {
#line 94
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: Malformed IPv6 URL!\n",
              94);
      }
#line 94
      return (0);
    }
  } else {
#line 98
    pos2 = pos;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! (pos2 < url->fill - 1U)) {
#line 98
        goto while_break___0;
      }
#line 100
      a = *(url->p + pos2);
#line 101
      if ((int )a == 58) {
#line 101
        goto while_break___0;
      } else
#line 101
      if ((int )a == 47) {
#line 101
        goto while_break___0;
      }
#line 98
      pos2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 105
  if ((unsigned long )host != (unsigned long )((void *)0)) {
    {
#line 105
    tmp___1 = (int )mpg123_set_substring(host, (char const   *)url->p, pos, pos2 - pos);
    }
#line 105
    if (! tmp___1) {
      {
#line 107
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: Cannot set host string (out of mem?).\n",
              107);
      }
#line 108
      return (0);
    }
  }
#line 110
  pos = pos2;
#line 113
  if ((int )*(url->p + pos) == 58) {
#line 115
    pos ++;
#line 116
    pos2 = pos;
    {
#line 116
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 116
      if (! (pos2 < url->fill - 1U)) {
#line 116
        goto while_break___1;
      }
#line 117
      if ((int )*(url->p + pos2) == 47) {
#line 117
        goto while_break___1;
      }
#line 116
      pos2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 120
    if (port) {
      {
#line 120
      ret = (int )mpg123_set_substring(port, (char const   *)url->p, pos, pos2 - pos);
      }
    }
#line 121
    pos = pos2;
  } else
#line 123
  if (port) {
    {
#line 123
    ret = (int )mpg123_set_string(port, "80");
    }
  }
#line 125
  if (! ret) {
    {
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: Cannot set port string (out of mem?).\n",
            127);
    }
#line 128
    return (0);
  }
#line 132
  if (path) {
    {
#line 132
    ret = (int )mpg123_set_substring(path, (char const   *)url->p, pos, (url->fill - 1U) - pos);
    }
  }
#line 134
  if (! ret) {
    {
#line 134
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: Cannot set path string (out of mem?)\n",
            134);
    }
  }
#line 136
  return (ret);
}
}
#line 141 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c"
static void nonblock(int sock ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 143
  tmp = fcntl(sock, 3);
#line 143
  flags = tmp;
#line 144
  flags |= 2048;
#line 145
  fcntl(sock, 4, flags);
  }
#line 146
  return;
}
}
#line 148 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c"
static void block(int sock ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 150
  tmp = fcntl(sock, 3);
#line 150
  flags = tmp;
#line 151
  flags &= -2049;
#line 152
  fcntl(sock, 4, flags);
  }
#line 153
  return;
}
}
#line 156 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c"
static int timeout_connect(int sockfd , struct sockaddr  const  *serv_addr , socklen_t addrlen ) 
{ 
  int err ;
  struct timeval tv ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  socklen_t len ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 158
  if (param.timeout > 0L) {
    {
#line 161
    nonblock(sockfd);
#line 162
    err = connect(sockfd, serv_addr, addrlen);
    }
#line 163
    if (err == 0) {
      {
#line 166
      block(sockfd);
      }
#line 167
      return (0);
    } else {
      {
#line 169
      tmp___5 = __errno_location();
      }
#line 169
      if (*tmp___5 == 115) {
#line 173
        tv.tv_sec = param.timeout;
#line 174
        tv.tv_usec = (__suseconds_t )0;
        {
#line 178
        while (1) {
          while_continue: /* CIL Label */ ;
#line 178
          __asm__  volatile   ("cld; rep; "
                               "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                               "1" (& fds.__fds_bits[0]): "memory");
#line 178
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 179
        fds.__fds_bits[sockfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sockfd % (8 * (int )sizeof(__fd_mask ));
#line 180
        err = select(sockfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
        }
#line 181
        if (err > 0) {
          {
#line 183
          len = (socklen_t )sizeof(err);
#line 184
          tmp___0 = getsockopt(sockfd, 1, 4, (void */* __restrict  */)(& err), (socklen_t */* __restrict  */)(& len));
          }
#line 184
          if (tmp___0 == 0) {
#line 184
            if (err == 0) {
              {
#line 188
              block(sockfd);
              }
#line 189
              return (0);
            } else {
              {
#line 193
              tmp = strerror(err);
#line 193
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: connection error: %s\n",
                      193, tmp);
              }
#line 194
              return (-1);
            }
          } else {
            {
#line 193
            tmp = strerror(err);
#line 193
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: connection error: %s\n",
                    193, tmp);
            }
#line 194
            return (-1);
          }
        } else
#line 197
        if (err == 0) {
          {
#line 199
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: connection timed out\n",
                  199);
          }
#line 200
          return (-1);
        } else {
          {
#line 204
          tmp___1 = __errno_location();
#line 204
          tmp___2 = strerror(*tmp___1);
#line 204
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: error from select(): %s\n",
                  204, tmp___2);
          }
#line 205
          return (-1);
        }
      } else {
        {
#line 210
        tmp___3 = __errno_location();
#line 210
        tmp___4 = strerror(*tmp___3);
#line 210
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: connection failed: %s\n",
                210, tmp___4);
        }
#line 211
        return (err);
      }
    }
  } else {
    {
#line 216
    tmp___8 = connect(sockfd, serv_addr, addrlen);
    }
#line 216
    if (tmp___8) {
      {
#line 218
      tmp___6 = __errno_location();
#line 218
      tmp___7 = strerror(*tmp___6);
#line 218
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: connecton failed: %s\n",
              218, tmp___7);
      }
#line 219
      return (-1);
    } else {
#line 221
      return (0);
    }
  }
}
}
#line 227 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c"
int open_connection(mpg123_string *host , mpg123_string *port ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *addr ;
  struct addrinfo *addrlist ;
  int addrcount ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 274
  sock = -1;
#line 276
  if (param.verbose > 1) {
    {
#line 276
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Attempting new-style connection to %s\n",
            host->p);
    }
  }
  {
#line 277
  memset((void *)(& hints), 0, (size_t )sizeof(struct addrinfo ));
#line 278
  hints.ai_family = 0;
#line 279
  hints.ai_socktype = 1;
#line 280
  hints.ai_flags = 0;
#line 282
  hints.ai_flags |= 32;
#line 284
  addrcount = getaddrinfo((char const   */* __restrict  */)host->p, (char const   */* __restrict  */)port->p,
                          (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& addrlist));
  }
#line 286
  if (addrcount < 0) {
    {
#line 288
    tmp = gai_strerror(addrcount);
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: Resolving %s:%s: %s\n",
            288, host->p, port->p, tmp);
    }
#line 289
    return (-1);
  }
#line 292
  addr = addrlist;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! ((unsigned long )addr != (unsigned long )((void *)0))) {
#line 293
      goto while_break;
    }
    {
#line 295
    sock = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
    }
#line 296
    if (sock >= 0) {
      {
#line 298
      tmp___0 = timeout_connect(sock, (struct sockaddr  const  *)addr->ai_addr, addr->ai_addrlen);
      }
#line 298
      if (tmp___0 == 0) {
#line 299
        goto while_break;
      }
      {
#line 301
      close(sock);
#line 302
      sock = -1;
      }
    }
#line 304
    addr = addr->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (sock < 0) {
    {
#line 306
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/resolver.c:%i] error: Cannot resolve/connect to %s:%s!\n",
            306, host->p, port->p);
    }
  }
  {
#line 308
  freeaddrinfo(addrlist);
  }
#line 310
  return (sock);
}
}
#line 151 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 831 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 47 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.h"
int proxy_init(struct httpdata *hd ) ;
#line 48
int translate_url(char const   *url , mpg123_string *purl ) ;
#line 49
size_t accept_length(void) ;
#line 50
int fill_request(mpg123_string *request , mpg123_string *host , mpg123_string *port ,
                 mpg123_string *httpauth1 , int *try_without_port ) ;
#line 51
void get_header_string(mpg123_string *response , char const   *fieldname , mpg123_string *store ) ;
#line 52
char *get_header_val(char const   *hname , mpg123_string *response ) ;
#line 41 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
void httpdata_init(struct httpdata *e ) 
{ 


  {
  {
#line 43
  mpg123_init_string(& e->content_type);
#line 44
  mpg123_init_string(& e->icy_url);
#line 45
  mpg123_init_string(& e->icy_name);
#line 46
  e->icy_interval = (off_t )0;
#line 47
  e->proxystate = (enum __anonenum_proxystate_54 )0;
#line 48
  mpg123_init_string(& e->proxyhost);
#line 49
  mpg123_init_string(& e->proxyport);
  }
#line 50
  return;
}
}
#line 52 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
void httpdata_reset(struct httpdata *e ) 
{ 


  {
  {
#line 54
  mpg123_free_string(& e->content_type);
#line 55
  mpg123_free_string(& e->icy_url);
#line 56
  mpg123_free_string(& e->icy_name);
#line 57
  e->icy_interval = (off_t )0;
  }
#line 59
  return;
}
}
#line 61 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
void httpdata_free(struct httpdata *e ) 
{ 


  {
  {
#line 63
  httpdata_reset(e);
#line 64
  mpg123_free_string(& e->proxyhost);
#line 65
  mpg123_free_string(& e->proxyport);
  }
#line 66
  return;
}
}
#line 72 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static char const   *mime_file[10]  = 
#line 72
  {      "audio/mpeg",      "audio/x-mpeg",      "audio/mp3",      "audio/x-mp3", 
        "audio/mpeg3",      "audio/x-mpeg3",      "audio/mpg",      "audio/x-mpg", 
        "audio/x-mpegaudio",      (char const   *)((void *)0)};
#line 80 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static char const   *mime_m3u[4]  = {      "audio/mpegurl",      "audio/mpeg-url",      "audio/x-mpegurl",      (char const   *)((void *)0)};
#line 81 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static char const   *mime_pls[4]  = {      "audio/x-scpls",      "audio/scpls",      "application/pls",      (char const   *)((void *)0)};
#line 82 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static char const   **mimes[4]  = {      mime_file,      mime_m3u,      mime_pls,      (char const   **)((void *)0)};
#line 84 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
int debunk_mime(char const   *mime ) 
{ 
  int i ;
  int j ;
  size_t len ;
  int r ;
  char *aux ;
  size_t tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 88
  r = 0;
#line 91
  aux = strchr(mime, ';');
  }
#line 92
  if ((unsigned long )aux != (unsigned long )((void *)0)) {
    {
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: additional info in content-type ignored (%s)\n",
            aux + 1);
#line 96
    len = (size_t )(aux - (char *)mime);
    }
  } else {
    {
#line 99
    tmp = strlen(mime);
#line 99
    len = tmp + 1U;
    }
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! ((unsigned long )mimes[i] != (unsigned long )((void *)0))) {
#line 101
      goto while_break;
    }
#line 102
    j = 0;
    {
#line 102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 102
      if (! ((unsigned long )*(mimes[i] + j) != (unsigned long )((void *)0))) {
#line 102
        goto while_break___0;
      }
      {
#line 103
      tmp___0 = strncasecmp(*(mimes[i] + j), mime, len);
      }
#line 103
      if (! tmp___0) {
#line 103
        goto debunk_result;
      }
#line 102
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  debunk_result: 
#line 106
  if ((unsigned long )mimes[i] != (unsigned long )((void *)0)) {
    {
#line 110
    if (i == 0) {
#line 110
      goto case_0;
    }
#line 111
    if (i == 1) {
#line 111
      goto case_1;
    }
#line 112
    if (i == 2) {
#line 112
      goto case_2;
    }
#line 113
    goto switch_default;
    case_0: /* CIL Label */ 
#line 110
    r = 1;
#line 110
    goto switch_break;
    case_1: /* CIL Label */ 
#line 111
    r = 6;
#line 111
    goto switch_break;
    case_2: /* CIL Label */ 
#line 112
    r = 10;
#line 112
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: unexpected MIME debunk result -- coding error?!\n",
            113);
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 116
  return (r);
}
}
#line 122 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static int writestring(int fd , mpg123_string *string ) 
{ 
  size_t result ;
  size_t bytes ;
  char *ptr ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 125
  ptr = string->p;
#line 126
  if (string->fill) {
#line 126
    bytes = string->fill - 1U;
  } else {
#line 126
    bytes = (size_t )0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! bytes) {
#line 128
      goto while_break;
    }
    {
#line 130
    tmp = write(fd, (void const   *)ptr, bytes);
#line 130
    result = (size_t )tmp;
    }
#line 131
    if (result < 0U) {
      {
#line 131
      tmp___0 = __errno_location();
      }
#line 131
      if (*tmp___0 != 4) {
        {
#line 133
        perror("writing http string");
        }
#line 134
        return (0);
      } else {
#line 131
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 136
    if (result == 0U) {
      {
#line 138
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: write: socket closed unexpectedly\n",
              138);
      }
#line 139
      return (0);
    }
#line 141
    ptr += result;
#line 142
    bytes -= result;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (1);
}
}
#line 147 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static size_t readstring(mpg123_string *string , size_t maxlen , FILE *f ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 151
  string->fill = (size_t )0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (maxlen == 0U)) {
#line 152
      if (! (string->fill < maxlen)) {
#line 152
        goto while_break;
      }
    }
#line 154
    if (string->size - string->fill < 1U) {
      {
#line 155
      tmp = (int )mpg123_grow_string(string, string->fill + 4096U);
      }
#line 155
      if (! tmp) {
        {
#line 157
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: Cannot allocate memory for reading.\n",
                157);
#line 158
        string->fill = (size_t )0;
        }
#line 159
        return ((size_t )0);
      }
    }
    {
#line 161
    tmp___0 = fileno(f);
#line 161
    err = read(tmp___0, (void *)(string->p + string->fill), (size_t )1);
    }
#line 163
    if (err == 1) {
#line 165
      (string->fill) ++;
#line 166
      if ((int )*(string->p + (string->fill - 1U)) == 10) {
#line 166
        goto while_break;
      }
    } else {
      {
#line 168
      tmp___1 = __errno_location();
      }
#line 168
      if (*tmp___1 != 4) {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: Error reading from socket or unexpected EOF.\n",
                170);
#line 171
        string->fill = (size_t )0;
        }
#line 173
        return ((size_t )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  tmp___2 = (int )mpg123_grow_string(string, string->fill + 1U);
  }
#line 177
  if (tmp___2) {
#line 183
    *(string->p + string->fill) = (char)0;
#line 184
    (string->fill) ++;
  } else {
#line 179
    string->fill = (size_t )0;
  }
#line 186
  return (string->fill);
}
}
#line 192
void encode64(char *source , char *destination ) ;
#line 192 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static char *Base64Digits  =    (char *)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
#line 190 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
void encode64(char *source , char *destination ) 
{ 
  int n ;
  int ssiz ;
  size_t tmp ;
  int i ;
  unsigned int buf ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 194
  n = 0;
#line 195
  tmp = strlen((char const   *)source);
#line 195
  ssiz = (int )tmp;
#line 198
  i = 0;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i < ssiz)) {
#line 198
      goto while_break;
    }
#line 200
    buf = (unsigned int )((int )*((unsigned char *)source + i) << 16);
#line 201
    if (i + 1 < ssiz) {
#line 202
      buf |= (unsigned int )((int )*((unsigned char *)source + (i + 1)) << 8);
    }
#line 203
    if (i + 2 < ssiz) {
#line 204
      buf |= (unsigned int )*((unsigned char *)source + (i + 2));
    }
#line 206
    tmp___0 = n;
#line 206
    n ++;
#line 206
    *(destination + tmp___0) = *(Base64Digits + (buf >> 18) % 64U);
#line 207
    tmp___1 = n;
#line 207
    n ++;
#line 207
    *(destination + tmp___1) = *(Base64Digits + (buf >> 12) % 64U);
#line 208
    if (i + 1 < ssiz) {
#line 209
      tmp___2 = n;
#line 209
      n ++;
#line 209
      *(destination + tmp___2) = *(Base64Digits + (buf >> 6) % 64U);
    } else {
#line 211
      tmp___3 = n;
#line 211
      n ++;
#line 211
      *(destination + tmp___3) = (char )'=';
    }
#line 212
    if (i + 2 < ssiz) {
#line 213
      tmp___4 = n;
#line 213
      n ++;
#line 213
      *(destination + tmp___4) = *(Base64Digits + buf % 64U);
    } else {
#line 215
      tmp___5 = n;
#line 215
      n ++;
#line 215
      *(destination + tmp___5) = (char )'=';
    }
#line 198
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  tmp___6 = n;
#line 217
  n ++;
#line 217
  *(destination + tmp___6) = (char)0;
#line 218
  return;
}
}
#line 222 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
char *get_header_val(char const   *hname , mpg123_string *response ) 
{ 
  char *tmp ;
  size_t prelen ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 224
  tmp = (char *)((void *)0);
#line 225
  tmp___0 = strlen(hname);
#line 225
  prelen = tmp___0;
#line 227
  tmp___1 = strncasecmp(hname, (char const   *)response->p, prelen);
  }
#line 227
  if (! tmp___1) {
#line 227
    if ((int )*(response->p + prelen) == 58) {
      {
#line 229
      prelen ++;
#line 230
      tmp = strchr((char const   *)response->p, '\r');
      }
#line 230
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 230
        *(tmp + 0) = (char)0;
      }
      {
#line 231
      tmp = strchr((char const   *)response->p, '\n');
      }
#line 231
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 231
        *(tmp + 0) = (char)0;
      }
#line 232
      tmp = response->p + prelen;
      {
#line 234
      while (1) {
        while_continue: /* CIL Label */ ;
#line 234
        if (! ((int )*(tmp + 0) == 32)) {
#line 234
          if (! ((int )*(tmp + 0) == 9)) {
#line 234
            goto while_break;
          }
        }
#line 236
        tmp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 239
  return (tmp);
}
}
#line 243 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
void get_header_string(mpg123_string *response , char const   *fieldname , mpg123_string *store ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 246
  tmp = get_header_val(fieldname, response);
  }
#line 246
  if (tmp) {
    {
#line 248
    tmp___0 = (int )mpg123_set_string(store, (char const   *)tmp);
    }
#line 248
    if (tmp___0) {
#line 248
      return;
    } else {
      {
#line 249
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: unable to set %s to %s!\n",
              249, fieldname, tmp);
      }
    }
  }
#line 251
  return;
}
}
#line 255 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
char *httpauth  =    (char *)((void *)0);
#line 260 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static size_t l  =    (size_t )0;
#line 257 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
size_t accept_length(void) 
{ 
  int i ;
  int j ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 261
  if (l) {
#line 261
    return (l);
  }
  {
#line 262
  tmp = strlen("Accept: ");
#line 262
  l += tmp;
#line 263
  i = 0;
  }
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! ((unsigned long )mimes[i] != (unsigned long )((void *)0))) {
#line 263
      goto while_break;
    }
#line 264
    j = 0;
    {
#line 264
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 264
      if (! ((unsigned long )*(mimes[i] + j) != (unsigned long )((void *)0))) {
#line 264
        goto while_break___0;
      }
      {
#line 264
      tmp___0 = strlen(*(mimes[i] + j));
#line 264
      tmp___1 = strlen(", ");
#line 264
      l += tmp___0 + tmp___1;
#line 264
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 263
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  tmp___2 = strlen("*/*\r\n");
#line 265
  l += tmp___2;
  }
#line 267
  return (l);
}
}
#line 271 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
int proxy_init(struct httpdata *hd ) 
{ 
  int ret ;
  mpg123_string proxyurl___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 273
  ret = 1;
#line 275
  if (! param.proxyurl) {
    {
#line 276
    param.proxyurl = getenv("MP3_HTTP_PROXY");
    }
#line 276
    if (! param.proxyurl) {
      {
#line 277
      param.proxyurl = getenv("http_proxy");
      }
#line 277
      if (! param.proxyurl) {
        {
#line 278
        param.proxyurl = getenv("HTTP_PROXY");
        }
      }
    }
  }
#line 280
  if (param.proxyurl) {
#line 280
    if (*(param.proxyurl + 0)) {
      {
#line 280
      tmp___1 = strcmp((char const   *)param.proxyurl, "none");
      }
#line 280
      if (tmp___1) {
        {
#line 283
        mpg123_init_string(& proxyurl___0);
#line 284
        tmp = (int )mpg123_set_string(& proxyurl___0, (char const   *)param.proxyurl);
        }
#line 284
        if (tmp) {
          {
#line 284
          tmp___0 = split_url(& proxyurl___0, (mpg123_string *)((void *)0), & hd->proxyhost,
                              & hd->proxyport, (mpg123_string *)((void *)0));
          }
#line 284
          if (tmp___0) {
#line 290
            if (param.verbose > 1) {
              {
#line 290
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: Using proxy %s\n",
                      hd->proxyhost.p);
              }
            }
          } else {
            {
#line 287
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: splitting proxy URL\n",
                    287);
#line 288
            ret = 0;
            }
          }
        } else {
          {
#line 287
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: splitting proxy URL\n",
                  287);
#line 288
          ret = 0;
          }
        }
        {
#line 298
        mpg123_free_string(& proxyurl___0);
        }
#line 299
        if (ret) {
#line 299
          hd->proxystate = (enum __anonenum_proxystate_54 )2;
        } else {
#line 300
          hd->proxystate = (enum __anonenum_proxystate_54 )1;
        }
      } else {
#line 302
        hd->proxystate = (enum __anonenum_proxystate_54 )1;
      }
    } else {
#line 302
      hd->proxystate = (enum __anonenum_proxystate_54 )1;
    }
  } else {
#line 302
    hd->proxystate = (enum __anonenum_proxystate_54 )1;
  }
#line 304
  return (ret);
}
}
#line 307 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static int append_accept(mpg123_string *s ) 
{ 
  size_t i ;
  size_t j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 310
  tmp = (int )mpg123_add_string(s, "Accept: ");
  }
#line 310
  if (! tmp) {
#line 310
    return (0);
  }
#line 313
  i = (size_t )0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! ((unsigned long )mimes[i] != (unsigned long )((void *)0))) {
#line 313
      goto while_break;
    }
#line 314
    j = (size_t )0;
    {
#line 314
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 314
      if (! ((unsigned long )*(mimes[i] + j) != (unsigned long )((void *)0))) {
#line 314
        goto while_break___0;
      }
      {
#line 316
      tmp___0 = (int )mpg123_add_string(s, *(mimes[i] + j));
      }
#line 316
      if (tmp___0) {
        {
#line 316
        tmp___1 = (int )mpg123_add_string(s, ", ");
        }
#line 316
        if (! tmp___1) {
#line 318
          return (0);
        }
      } else {
#line 318
        return (0);
      }
#line 314
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 313
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  tmp___2 = (int )mpg123_add_string(s, "*/*\r\n");
  }
#line 321
  if (! tmp___2) {
#line 321
    return (0);
  }
#line 323
  return (1);
}
}
#line 332 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
int translate_url(char const   *url , mpg123_string *purl ) 
{ 
  char const   *sptr ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char const   *urlptr ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 337
  tmp = strlen(url);
  }
#line 337
  if (tmp >= 1431655765U) {
    {
#line 339
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: URL too long. Skipping...\n",
            339);
    }
#line 340
    return (0);
  }
  {
#line 343
  tmp___0 = strlen(url);
#line 343
  tmp___1 = (int )mpg123_resize_string(purl, tmp___0 + 31U);
  }
#line 343
  if (! tmp___1) {
#line 343
    return (0);
  }
  {
#line 351
  tmp___6 = strchr(url, ' ');
#line 351
  sptr = (char const   *)tmp___6;
  }
#line 351
  if ((unsigned long )sptr == (unsigned long )((void *)0)) {
    {
#line 352
    mpg123_set_string(purl, url);
    }
  } else {
    {
#line 355
    urlptr = url;
#line 356
    mpg123_set_string(purl, "");
    }
    {
#line 357
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 358
      tmp___2 = (int )mpg123_add_substring(purl, urlptr, (size_t )0, (size_t )(sptr - urlptr));
      }
#line 358
      if (tmp___2) {
        {
#line 358
        tmp___3 = (int )mpg123_add_string(purl, "%20");
        }
#line 358
        if (! tmp___3) {
#line 360
          return (0);
        }
      } else {
#line 360
        return (0);
      }
      {
#line 361
      urlptr = sptr + 1;
#line 357
      tmp___4 = strchr(urlptr, ' ');
#line 357
      sptr = (char const   *)tmp___4;
      }
#line 357
      if (! ((unsigned long )sptr != (unsigned long )((void *)0))) {
#line 357
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 363
    tmp___5 = (int )mpg123_add_string(purl, urlptr);
    }
#line 363
    if (! tmp___5) {
#line 363
      return (0);
    }
  }
  {
#line 366
  tmp___9 = strncmp("http://", (char const   *)purl->p, (size_t )7);
  }
#line 366
  if (tmp___9) {
#line 366
    tmp___8 = 0;
  } else {
#line 366
    tmp___8 = 7;
  }
  {
#line 366
  tmp___10 = strchr((char const   *)(purl->p + tmp___8), '/');
  }
#line 366
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
    {
#line 366
    tmp___11 = (int )mpg123_add_string(purl, "/");
    }
#line 366
    if (! tmp___11) {
#line 368
      return (0);
    }
  }
#line 370
  return (1);
}
}
#line 373 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
int fill_request(mpg123_string *request , mpg123_string *host , mpg123_string *port ,
                 mpg123_string *httpauth1 , int *try_without_port ) 
{ 
  char *ttemp ;
  int ret ;
  char const   *icy ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *buf ;
  int tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
#line 376
  ret = 1;
#line 377
  if (param.talk_icy) {
#line 377
    tmp = "Icy-MetaData: 1\r\n";
  } else {
#line 377
    tmp = "Icy-MetaData: 0\r\n";
  }
  {
#line 377
  icy = tmp;
#line 380
  ttemp = strchr((char const   *)request->p, '\r');
  }
#line 380
  if ((unsigned long )ttemp != (unsigned long )((void *)0)) {
#line 380
    *ttemp = (char)0;
#line 380
    request->fill = (size_t )((ttemp - request->p) + 1L);
  }
  {
#line 382
  ttemp = strchr((char const   *)request->p, '\n');
  }
#line 382
  if ((unsigned long )ttemp != (unsigned long )((void *)0)) {
#line 382
    *ttemp = (char)0;
#line 382
    request->fill = (size_t )((ttemp - request->p) + 1L);
  }
  {
#line 385
  tmp___0 = (int )mpg123_add_string(request, " HTTP/1.0\r\nUser-Agent: ");
  }
#line 385
  if (tmp___0) {
    {
#line 385
    tmp___1 = (int )mpg123_add_string(request, "mpg123");
    }
#line 385
    if (tmp___1) {
      {
#line 385
      tmp___2 = (int )mpg123_add_string(request, "/");
      }
#line 385
      if (tmp___2) {
        {
#line 385
        tmp___3 = (int )mpg123_add_string(request, "1.12.1");
        }
#line 385
        if (tmp___3) {
          {
#line 385
          tmp___4 = (int )mpg123_add_string(request, "\r\n");
          }
#line 385
          if (! tmp___4) {
#line 390
            return (0);
          }
        } else {
#line 390
          return (0);
        }
      } else {
#line 390
        return (0);
      }
    } else {
#line 390
      return (0);
    }
  } else {
#line 390
    return (0);
  }
#line 392
  if (host->fill) {
    {
#line 395
    tmp___5 = (int )mpg123_add_string(request, "Host: ");
    }
#line 395
    if (tmp___5) {
      {
#line 395
      tmp___6 = (int )mpg123_add_string(request, (char const   *)host->p);
      }
#line 395
      if (tmp___6) {
#line 395
        if (*try_without_port) {
#line 395
          goto _L;
        } else {
          {
#line 395
          tmp___7 = (int )mpg123_add_string(request, ":");
          }
#line 395
          if (tmp___7) {
            {
#line 395
            tmp___8 = (int )mpg123_add_string(request, (char const   *)port->p);
            }
#line 395
            if (tmp___8) {
              _L: /* CIL Label */ 
              {
#line 395
              tmp___9 = (int )mpg123_add_string(request, "\r\n");
              }
#line 395
              if (tmp___9) {
#line 402
                if (*try_without_port) {
#line 402
                  *try_without_port = 0;
                }
              } else {
#line 404
                return (0);
              }
            } else {
#line 404
              return (0);
            }
          } else {
#line 404
            return (0);
          }
        }
      } else {
#line 404
        return (0);
      }
    } else {
#line 404
      return (0);
    }
  }
  {
#line 408
  tmp___10 = append_accept(request);
  }
#line 408
  if (tmp___10) {
    {
#line 408
    tmp___11 = (int )mpg123_add_string(request, "");
    }
#line 408
    if (tmp___11) {
      {
#line 408
      tmp___12 = (int )mpg123_add_string(request, icy);
      }
#line 408
      if (! tmp___12) {
#line 411
        return (0);
      }
    } else {
#line 411
      return (0);
    }
  } else {
#line 411
    return (0);
  }
#line 414
  if (httpauth1->fill) {
#line 414
    goto _L___0;
  } else
#line 414
  if (httpauth) {
    _L___0: /* CIL Label */ 
    {
#line 416
    tmp___13 = (int )mpg123_add_string(request, "Authorization: Basic ");
    }
#line 416
    if (! tmp___13) {
#line 416
      return (0);
    }
#line 417
    if (httpauth1->fill) {
#line 418
      if (httpauth1->fill > 1073741823U) {
#line 418
        return (0);
      }
      {
#line 420
      tmp___14 = malloc(httpauth1->fill * 4U);
#line 420
      buf = (char *)tmp___14;
      }
#line 421
      if (! buf) {
        {
#line 423
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: malloc() failed for http auth, out of memory.\n",
                423);
        }
#line 424
        return (0);
      }
      {
#line 426
      encode64(httpauth1->p, buf);
      }
    } else {
      {
#line 428
      tmp___15 = strlen((char const   *)httpauth);
      }
#line 428
      if (tmp___15 > 1073741819U) {
#line 428
        return (0);
      }
      {
#line 430
      tmp___16 = strlen((char const   *)httpauth);
#line 430
      tmp___17 = malloc((tmp___16 + 1U) * 4U);
#line 430
      buf = (char *)tmp___17;
      }
#line 431
      if (! buf) {
        {
#line 433
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: malloc() for http auth failed, out of memory.\n",
                433);
        }
#line 434
        return (0);
      }
      {
#line 436
      encode64(httpauth, buf);
      }
    }
    {
#line 439
    tmp___18 = (int )mpg123_add_string(request, (char const   *)buf);
    }
#line 439
    if (tmp___18) {
      {
#line 439
      tmp___19 = (int )mpg123_add_string(request, "\r\n");
      }
#line 439
      if (! tmp___19) {
#line 440
        ret = 0;
      }
    } else {
#line 440
      ret = 0;
    }
    {
#line 442
    free((void *)buf);
    }
  }
#line 444
  if (ret) {
    {
#line 444
    ret = (int )mpg123_add_string(request, "\r\n");
    }
  }
#line 446
  return (ret);
}
}
#line 449 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
static int resolve_redirect(mpg123_string *response , mpg123_string *request_url ,
                            mpg123_string *purl ) 
{ 
  int tmp ;
  char *ptmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 453
  tmp = (int )mpg123_copy_string(request_url, purl);
  }
#line 453
  if (! tmp) {
#line 453
    return (0);
  }
  {
#line 456
  tmp___0 = strncasecmp((char const   *)response->p, "Location: http://", (size_t )17);
  }
#line 456
  if (tmp___0) {
    {
#line 458
    ptmp = (char *)((void *)0);
#line 460
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NOTE: no complete URL in redirect, constructing one\n");
    }
#line 463
    if ((int )*(response->p + 10) == 47) {
      {
#line 467
      ptmp = strchr((char const   *)(purl->p + 7), '/');
      }
#line 468
      if ((unsigned long )ptmp != (unsigned long )((void *)0)) {
#line 468
        purl->fill = (size_t )((ptmp - purl->p) + 1L);
#line 468
        *(purl->p + (purl->fill - 1U)) = (char)0;
      }
    } else {
      {
#line 474
      ptmp = strrchr((char const   *)(purl->p + 7), '/');
      }
#line 475
      if ((unsigned long )ptmp != (unsigned long )((void *)0)) {
#line 475
        purl->fill = (size_t )((ptmp - purl->p) + 2L);
#line 475
        *(purl->p + (purl->fill - 1U)) = (char)0;
      }
    }
  } else {
#line 478
    purl->fill = (size_t )0;
  }
  {
#line 481
  tmp___1 = (int )mpg123_add_string(purl, (char const   *)(response->p + 10));
  }
#line 481
  if (! tmp___1) {
#line 481
    return (0);
  }
#line 486
  return (1);
}
}
#line 489 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c"
int http_open(char *url , struct httpdata *hd ) 
{ 
  mpg123_string purl ;
  mpg123_string host ;
  mpg123_string port ;
  mpg123_string path ;
  mpg123_string request ;
  mpg123_string response ;
  mpg123_string request_url ;
  mpg123_string httpauth1 ;
  int sock ;
  int oom ;
  int relocate ;
  int numrelocs ;
  int got_location ;
  FILE *myfile ;
  int try_without_port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t length_estimate ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *sptr ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  long tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;

  {
  {
#line 494
  sock = -1;
#line 495
  oom = 0;
#line 496
  numrelocs = 0;
#line 497
  got_location = 0;
#line 498
  myfile = (FILE *)((void *)0);
#line 504
  try_without_port = 0;
#line 505
  mpg123_init_string(& purl);
#line 506
  mpg123_init_string(& host);
#line 507
  mpg123_init_string(& port);
#line 508
  mpg123_init_string(& path);
#line 509
  mpg123_init_string(& request);
#line 510
  mpg123_init_string(& response);
#line 511
  mpg123_init_string(& request_url);
#line 512
  mpg123_init_string(& httpauth1);
  }
#line 515
  if ((unsigned int )hd->proxystate == 0U) {
    {
#line 515
    tmp = proxy_init(hd);
    }
#line 515
    if (! tmp) {
#line 515
      goto exit;
    }
  }
  {
#line 517
  tmp___0 = translate_url((char const   *)url, & purl);
  }
#line 517
  if (! tmp___0) {
#line 517
    oom = 1;
#line 517
    goto exit;
  }
  {
#line 520
  tmp___1 = split_url(& purl, & httpauth1, (mpg123_string *)((void *)0), (mpg123_string *)((void *)0),
                      (mpg123_string *)((void *)0));
  }
#line 520
  if (! tmp___1) {
#line 520
    oom = 1;
#line 520
    goto exit;
  }
  {
#line 532
  tmp___2 = strlen("mpg123");
#line 532
  tmp___3 = strlen("1.12.1");
#line 532
  tmp___4 = accept_length();
#line 532
  tmp___5 = strlen("");
#line 532
  tmp___6 = strlen("Icy-MetaData: 1\r\n");
#line 532
  length_estimate = (((((62U + tmp___2) + tmp___3) + tmp___4) + tmp___5) + tmp___6) + purl.fill;
#line 534
  tmp___7 = (int )mpg123_grow_string(& request, length_estimate);
  }
#line 534
  if (tmp___7) {
    {
#line 534
    tmp___8 = (int )mpg123_grow_string(& response, (size_t )4096);
    }
#line 534
    if (! tmp___8) {
#line 537
      oom = 1;
#line 537
      goto exit;
    }
  } else {
#line 537
    oom = 1;
#line 537
    goto exit;
  }
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 545
    tmp___9 = strncasecmp((char const   *)purl.p, "http://", (size_t )7);
    }
#line 545
    if (tmp___9 != 0) {
      {
#line 545
      mpg123_set_string(& request_url, "http://");
      }
    } else {
      {
#line 546
      mpg123_set_string(& request_url, "");
      }
    }
    {
#line 548
    mpg123_add_string(& request_url, (char const   *)purl.p);
    }
#line 550
    if ((unsigned int )hd->proxystate >= 2U) {
      {
#line 553
      tmp___10 = (int )mpg123_copy_string(& hd->proxyhost, & host);
      }
#line 553
      if (tmp___10) {
        {
#line 553
        tmp___11 = (int )mpg123_copy_string(& hd->proxyport, & port);
        }
#line 553
        if (tmp___11) {
          {
#line 553
          tmp___12 = (int )mpg123_set_string(& request, "GET ");
          }
#line 553
          if (tmp___12) {
            {
#line 553
            tmp___13 = (int )mpg123_add_string(& request, (char const   *)request_url.p);
            }
#line 553
            if (! tmp___13) {
#line 558
              oom = 1;
#line 558
              goto exit;
            }
          } else {
#line 558
            oom = 1;
#line 558
            goto exit;
          }
        } else {
#line 558
          oom = 1;
#line 558
          goto exit;
        }
      } else {
#line 558
        oom = 1;
#line 558
        goto exit;
      }
    } else {
      {
#line 564
      tmp___14 = split_url(& purl, (mpg123_string *)((void *)0), & host, & port, & path);
      }
#line 564
      if (! tmp___14) {
#line 564
        oom = 1;
#line 564
        goto exit;
      }
      {
#line 565
      tmp___15 = (int )mpg123_set_string(& request, "GET ");
      }
#line 565
      if (tmp___15) {
        {
#line 565
        tmp___16 = (int )mpg123_add_string(& request, (char const   *)path.p);
        }
#line 565
        if (! tmp___16) {
#line 568
          oom = 1;
#line 568
          goto exit;
        }
      } else {
#line 568
        oom = 1;
#line 568
        goto exit;
      }
    }
    {
#line 572
    tmp___17 = fill_request(& request, & host, & port, & httpauth1, & try_without_port);
    }
#line 572
    if (! tmp___17) {
#line 572
      oom = 1;
#line 572
      goto exit;
    }
    {
#line 574
    httpauth1.fill = (size_t )0;
#line 576
    sock = open_connection(& host, & port);
    }
#line 577
    if (sock < 0) {
#line 579
      if (host.fill) {
#line 579
        tmp___18 = (char const   *)host.p;
      } else {
#line 579
        tmp___18 = "";
      }
      {
#line 579
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: Unable to establish connection to %s\n",
              579, tmp___18);
      }
#line 580
      goto exit;
    }
#line 584
    if (param.verbose > 2) {
      {
#line 584
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HTTP request:\n%s\n",
              request.p);
      }
    }
    {
#line 585
    tmp___19 = writestring(sock, & request);
    }
#line 585
    if (! tmp___19) {
      {
#line 585
      close(sock);
#line 585
      sock = -1;
      }
#line 585
      goto exit;
    }
    {
#line 586
    myfile = fdopen(sock, "rb");
    }
#line 586
    if (! myfile) {
      {
#line 588
      tmp___20 = __errno_location();
#line 588
      tmp___21 = strerror(*tmp___20);
#line 588
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: fdopen: %s\n",
              588, tmp___21);
#line 589
      close(sock);
#line 589
      sock = -1;
      }
#line 589
      goto exit;
    }
    {
#line 591
    relocate = 0;
#line 606
    readstring(& response, 268435455U, myfile);
    }
#line 606
    if (response.fill > 268435455U) {
      {
#line 606
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: HTTP response line exceeds max. length\n",
              606);
#line 606
      close(sock);
#line 606
      sock = -1;
      }
#line 606
      goto exit;
    } else
#line 606
    if (response.fill == 0U) {
      {
#line 606
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: readstring failed\n",
              606);
#line 606
      close(sock);
#line 606
      sock = -1;
      }
#line 606
      goto exit;
    }
#line 606
    if (param.verbose > 2) {
      {
#line 606
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HTTP in: %s",
              response.p);
      }
    }
    {
#line 610
    sptr = strchr((char const   *)response.p, ' ');
    }
#line 610
    if (sptr) {
#line 612
      if ((long )response.fill > (sptr - response.p) + 2L) {
        {
#line 615
        if ((int )*(sptr + 1) == 51) {
#line 615
          goto case_51;
        }
#line 617
        if ((int )*(sptr + 1) == 50) {
#line 617
          goto case_50;
        }
#line 619
        goto switch_default;
        case_51: /* CIL Label */ 
#line 616
        relocate = 1;
        case_50: /* CIL Label */ 
#line 618
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 620
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HTTP request failed: %s",
                sptr + 1);
#line 621
        close(sock);
#line 621
        sock = -1;
        }
#line 621
        goto exit;
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 623
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: Too short response,\n",
                623);
#line 623
        close(sock);
#line 623
        sock = -1;
        }
#line 623
        goto exit;
      }
    }
#line 628
    got_location = 0;
    {
#line 630
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 632
      readstring(& response, 268435455U, myfile);
      }
#line 632
      if (response.fill > 268435455U) {
        {
#line 632
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: HTTP response line exceeds max. length\n",
                632);
#line 632
        close(sock);
#line 632
        sock = -1;
        }
#line 632
        goto exit;
      } else
#line 632
      if (response.fill == 0U) {
        {
#line 632
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: readstring failed\n",
                632);
#line 632
        close(sock);
#line 632
        sock = -1;
        }
#line 632
        goto exit;
      }
#line 632
      if (param.verbose > 2) {
        {
#line 632
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HTTP in: %s",
                response.p);
        }
      }
      {
#line 633
      tmp___26 = strncasecmp((char const   *)response.p, "Location: ", (size_t )10);
      }
#line 633
      if (tmp___26) {
        {
#line 650
        get_header_string(& response, "content-type", & hd->content_type);
#line 651
        get_header_string(& response, "icy-name", & hd->icy_name);
#line 652
        get_header_string(& response, "icy-url", & hd->icy_url);
#line 655
        tmp___24 = get_header_val("icy-metaint", & response);
        }
#line 655
        if (tmp___24) {
          {
#line 657
          tmp___25 = atol((char const   *)tmp___24);
#line 657
          hd->icy_interval = (off_t )tmp___25;
          }
        }
      } else {
        {
#line 635
        tmp___22 = resolve_redirect(& response, & request_url, & purl);
        }
#line 635
        if (! tmp___22) {
          {
#line 635
          oom = 1;
#line 635
          close(sock);
#line 635
          sock = -1;
          }
#line 635
          goto exit;
        }
        {
#line 637
        tmp___23 = strcmp((char const   *)purl.p, (char const   *)request_url.p);
        }
#line 637
        if (! tmp___23) {
          {
#line 639
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] warning: relocated to very same place! trying request again without host port\n",
                  639);
#line 640
          try_without_port = 1;
          }
        }
#line 642
        got_location = 1;
      }
#line 630
      if ((int )*(response.p + 0) != 13) {
#line 630
        if (! ((int )*(response.p + 0) != 10)) {
#line 630
          goto while_break___0;
        }
      } else {
#line 630
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 541
    if (relocate) {
#line 541
      if (got_location) {
#line 541
        if (purl.fill) {
#line 541
          tmp___27 = numrelocs;
#line 541
          numrelocs ++;
#line 541
          if (! (tmp___27 < 20)) {
#line 541
            goto while_break;
          }
        } else {
#line 541
          goto while_break;
        }
      } else {
#line 541
        goto while_break;
      }
    } else {
#line 541
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 663
  if (relocate) {
#line 665
    if (! got_location) {
      {
#line 666
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: Server meant to redirect but failed to provide a location!\n",
              666);
      }
    } else {
      {
#line 668
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: Too many HTTP relocations (%i).\n",
              668, numrelocs);
      }
    }
    {
#line 670
    close(sock);
#line 670
    sock = -1;
    }
#line 670
    goto exit;
  }
  exit: 
#line 674
  if (oom) {
    {
#line 674
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/httpget.c:%i] error: Apparently, I ran out of memory or had some bad input data...\n",
            674);
    }
  }
  {
#line 676
  mpg123_free_string(& purl);
#line 677
  mpg123_free_string(& host);
#line 678
  mpg123_free_string(& port);
#line 679
  mpg123_free_string(& path);
#line 680
  mpg123_free_string(& request);
#line 681
  mpg123_free_string(& response);
#line 682
  mpg123_free_string(& request_url);
#line 683
  mpg123_free_string(& httpauth1);
  }
#line 684
  return (sock);
}
}
#line 18 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.h"
int loptchr ;
#line 19 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.h"
char *loptarg  ;
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.c"
int loptind  =    1;
#line 17 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.c"
int loptchr  =    0;
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.c"
topt *findopt(int islong , char *opt , topt *opts___0 ) 
{ 
  int tmp ;

  {
#line 22
  if (! opts___0) {
#line 23
    return ((topt *)0);
  }
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! opts___0->lname) {
#line 24
      goto while_break;
    }
#line 25
    if (islong) {
      {
#line 26
      tmp = strcmp((char const   *)opts___0->lname, (char const   *)opt);
      }
#line 26
      if (! tmp) {
#line 27
        return (opts___0);
      }
    } else
#line 30
    if ((int )opts___0->sname == (int )*opt) {
#line 31
      return (opts___0);
    }
#line 32
    opts___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  return ((topt *)0);
}
}
#line 37 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.c"
int performoption(int argc___0 , char **argv___0 , topt *opt ) 
{ 
  int result ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 39
  result = -3;
#line 47
  if (! (opt->flags & 1)) {
#line 48
    if (opt->var) {
#line 49
      if (opt->flags & 2) {
#line 52
        *((char *)opt->var) = (char )opt->value;
      } else
#line 54
      if (opt->flags & 8) {
#line 57
        *((long *)opt->var) = opt->value;
      } else
#line 59
      if (opt->flags & 4) {
#line 62
        *((int *)opt->var) = (int )opt->value;
      } else {
        {
#line 65
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.c:%i Option without type flag! This is a programming error! Developer: fix this ASAP to regain your honor.\n",
                65);
#line 65
        exit(1);
        }
      }
    } else
#line 70
    if (opt->value) {
#line 70
      result = (int )opt->value;
    } else {
#line 70
      result = (int )opt->sname;
    }
  } else {
#line 73
    if (loptind >= argc___0) {
#line 74
      return (-2);
    }
#line 75
    tmp = loptind;
#line 75
    loptind ++;
#line 75
    loptarg = *(argv___0 + tmp) + loptchr;
#line 76
    loptchr = 0;
#line 77
    if (opt->var) {
#line 78
      if (opt->flags & 2) {
        {
#line 79
        *((char **)opt->var) = strdup((char const   *)loptarg);
        }
      } else
#line 80
      if (opt->flags & 8) {
        {
#line 81
        *((long *)opt->var) = atol((char const   *)loptarg);
        }
      } else
#line 82
      if (opt->flags & 4) {
        {
#line 83
        *((int *)opt->var) = atoi((char const   *)loptarg);
        }
      } else
#line 84
      if (opt->flags & 16) {
        {
#line 85
        *((double *)opt->var) = atof((char const   *)loptarg);
        }
      } else {
        {
#line 86
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.c:%i Option without type flag! This is a programming error! Developer: fix this ASAP to regain your honor.\n",
                86);
#line 86
        exit(1);
        }
      }
    } else
#line 89
    if (opt->value) {
#line 89
      result = (int )opt->value;
    } else {
#line 89
      result = (int )opt->sname;
    }
  }
#line 91
  if (opt->func) {
    {
#line 92
    (*(opt->func))(loptarg);
    }
  }
#line 93
  return (result);
}
}
#line 100
int getsingleopt(int argc___0 , char **argv___0 , topt *opts___0 ) ;
#line 100 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.c"
static char shortopt[2]  = {      (char)0,      (char)0};
#line 96 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.c"
int getsingleopt(int argc___0 , char **argv___0 , topt *opts___0 ) 
{ 
  char *thisopt ;
  topt *opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 102
  if (loptind >= argc___0) {
#line 103
    return (0);
  }
#line 104
  thisopt = *(argv___0 + loptind);
#line 106
  if (! loptchr) {
#line 107
    if ((int )*(thisopt + 0) != 45) {
#line 108
      return (0);
    } else
#line 107
    if (! *(thisopt + 1)) {
#line 108
      return (0);
    }
#line 109
    if ((int )*(thisopt + 1) == 45) {
#line 110
      if (*(thisopt + 2)) {
        {
#line 111
        loptarg = thisopt + 2;
#line 112
        loptind ++;
#line 113
        opt = findopt(1, thisopt + 2, opts___0);
        }
#line 113
        if (opt) {
          {
#line 116
          tmp = performoption(argc___0, argv___0, opt);
          }
#line 116
          return (tmp);
        } else {
#line 114
          return (-1);
        }
      } else {
#line 119
        loptind ++;
#line 120
        return (0);
      }
    } else {
#line 124
      loptchr = 1;
    }
  }
  {
#line 126
  shortopt[0] = *(thisopt + loptchr);
#line 127
  loptarg = shortopt;
#line 128
  tmp___0 = loptchr;
#line 128
  loptchr ++;
#line 128
  opt = findopt(0, thisopt + tmp___0, opts___0);
  }
#line 129
  if (! *(thisopt + loptchr)) {
#line 130
    loptind ++;
#line 131
    loptchr = 0;
  }
#line 133
  if (! opt) {
#line 134
    return (-1);
  } else {
    {
#line 136
    tmp___1 = performoption(argc___0, argv___0, opt);
    }
#line 136
    return (tmp___1);
  }
}
}
#line 139 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/getlopt.c"
int getlopt(int argc___0 , char **argv___0 , topt *opts___0 ) 
{ 
  int result ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    result = getsingleopt(argc___0, argv___0, opts___0);
    }
#line 144
    if (! (result == -3)) {
#line 144
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (result);
}
}
#line 415 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 13 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/equalizer.c"
int load_equalizer(mpg123_handle *mh___0 ) 
{ 
  FILE *fe ;
  int i ;
  char line[256] ;
  float e0 ;
  float e1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 15
  if ((unsigned long )equalfile != (unsigned long )((void *)0)) {
    {
#line 19
    fe = fopen((char const   */* __restrict  */)equalfile, (char const   */* __restrict  */)"r");
    }
#line 20
    if (fe) {
#line 22
      i = 0;
      {
#line 22
      while (1) {
        while_continue: /* CIL Label */ ;
#line 22
        if (! (i < 32)) {
#line 22
          goto while_break;
        }
#line 23
        e0 = (float )1.0;
#line 24
        e1 = (float )1.0;
        {
#line 25
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 27
          line[0] = (char)0;
#line 28
          fgets((char */* __restrict  */)(line), 255, (FILE */* __restrict  */)fe);
          }
#line 25
          if (! ((int )line[0] == 35)) {
#line 25
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 32
        sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%f %f",
               & e0, & e1);
#line 34
        mpg123_eq(mh___0, (enum mpg123_channels )1, i, (double )e0);
#line 35
        mpg123_eq(mh___0, (enum mpg123_channels )2, i, (double )e1);
#line 22
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 37
      fclose(fe);
      }
    } else {
      {
#line 41
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open equalizer file \'%s\'\n",
              equalfile);
      }
#line 42
      return (-1);
    }
  } else {
    {
#line 45
    mpg123_reset_eq(mh___0);
    }
  }
#line 47
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 158 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 324 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 348
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 842 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 346 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.h"
char const   *remote_header_help ;
#line 22
void print_remote_header(mpg123_handle *mh___0 ) ;
#line 23
void generic_sendmsg(char const   *fmt  , ...) ;
#line 27
char const   *rva_name[3] ;
#line 350 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkfifo)(char const   *__path ,
                                                                                   __mode_t __mode ) ;
#line 32 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
int control_file  =    0;
#line 36 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
FILE *outstream  ;
#line 37 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
static int mode  =    0;
#line 38 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
static int init  =    0;
#line 42 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
void generic_sendmsg(char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 45
  fprintf((FILE */* __restrict  */)outstream, (char const   */* __restrict  */)"@");
#line 46
  __builtin_va_start(ap, fmt);
#line 47
  vfprintf((FILE */* __restrict  */)outstream, (char const   */* __restrict  */)fmt,
           ap);
#line 48
  __builtin_va_end(ap);
#line 49
  fprintf((FILE */* __restrict  */)outstream, (char const   */* __restrict  */)"\n");
  }
#line 50
  return;
}
}
#line 54 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
static void generic_send_lines(char const   *fmt , mpg123_string *inlines ) 
{ 
  size_t i ;
  int hadcr ;
  int hadlf ;
  char *lines ;
  char *line ;
  size_t len ;
  char save ;
  char *__cil_tmp10 ;

  {
#line 57
  hadcr = 0;
#line 57
  hadlf = 0;
#line 58
  lines = (char *)((void *)0);
#line 59
  line = (char *)((void *)0);
#line 60
  len = (size_t )0;
#line 62
  if ((unsigned long )inlines != (unsigned long )((void *)0)) {
#line 62
    if (inlines->fill) {
#line 64
      lines = inlines->p;
#line 65
      len = inlines->fill;
    } else {
#line 67
      return;
    }
  } else {
#line 67
    return;
  }
#line 69
  line = lines;
#line 70
  i = (size_t )0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < len)) {
#line 70
      goto while_break;
    }
#line 72
    if ((int )*(lines + i) == 10) {
#line 72
      goto _L___0;
    } else
#line 72
    if ((int )*(lines + i) == 13) {
#line 72
      goto _L___0;
    } else
#line 72
    if ((int )*(lines + i) == 0) {
      _L___0: /* CIL Label */ 
#line 74
      save = *(lines + i);
#line 75
      if ((int )save == 10) {
#line 75
        hadlf ++;
      }
#line 76
      if ((int )save == 13) {
#line 76
        hadcr ++;
      }
#line 77
      if (hadcr) {
#line 77
        goto _L;
      } else
#line 77
      if (hadlf) {
        _L: /* CIL Label */ 
#line 77
        if (hadlf % 2 == 0) {
#line 77
          if (hadcr % 2 == 0) {
#line 77
            line = (char *)"";
          }
        }
      }
#line 79
      if (line) {
        {
#line 81
        *(lines + i) = (char)0;
#line 82
        generic_sendmsg(fmt, line);
#line 83
        line = (char *)((void *)0);
#line 84
        *(lines + i) = save;
        }
      }
    } else {
#line 89
      hadcr = 0;
#line 89
      hadlf = hadcr;
#line 90
      if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 90
        line = lines + i;
      }
    }
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 95 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
void generic_sendstat(mpg123_handle *fr ) 
{ 
  off_t current_frame ;
  off_t frames_left___0 ;
  double current_seconds ;
  double seconds_left ;
  size_t tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 99
  tmp = xfermem_get_usedspace(buffermem);
#line 99
  tmp___0 = (int )mpg123_position_64(fr, (off_t )0, (off_t )tmp, & current_frame,
                                     & frames_left___0, & current_seconds, & seconds_left);
  }
#line 99
  if (! tmp___0) {
    {
#line 100
    generic_sendmsg("F %lli %lli %3.2f %3.2f", current_frame, frames_left___0, current_seconds,
                    seconds_left);
    }
  }
#line 101
  return;
}
}
#line 103 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
static void generic_sendv1(mpg123_id3v1 *v1 , char const   *prefix ) 
{ 
  int i ;
  char info[125] ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 106
  info[0] = (char )'\000';
#line 106
  tmp = 1U;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (tmp >= 125U) {
#line 106
      goto while_break;
    }
#line 106
    info[tmp] = (char)0;
#line 106
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  memcpy((void */* __restrict  */)(info), (void const   */* __restrict  */)(v1->title),
         (size_t )30);
#line 108
  memcpy((void */* __restrict  */)(info + 30), (void const   */* __restrict  */)(v1->artist),
         (size_t )30);
#line 109
  memcpy((void */* __restrict  */)(info + 60), (void const   */* __restrict  */)(v1->album),
         (size_t )30);
#line 110
  memcpy((void */* __restrict  */)(info + 90), (void const   */* __restrict  */)(v1->year),
         (size_t )4);
#line 111
  memcpy((void */* __restrict  */)(info + 94), (void const   */* __restrict  */)(v1->comment),
         (size_t )30);
#line 113
  i = 0;
  }
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (i < 124)) {
#line 113
      goto while_break___0;
    }
#line 113
    if ((int )info[i] == 0) {
#line 113
      info[i] = (char )' ';
    }
#line 113
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 114
  info[i] = (char)0;
#line 115
  if ((int )v1->genre <= (int )genre_count) {
#line 115
    tmp___0 = (char const   *)genre_table[v1->genre];
  } else {
#line 115
    tmp___0 = "Unknown";
  }
  {
#line 115
  generic_sendmsg("%s ID3:%s%s", prefix, info, tmp___0);
#line 116
  generic_sendmsg("%s ID3.genre:%i", prefix, (int )v1->genre);
  }
#line 117
  if ((int )v1->comment[28] == 0) {
#line 117
    if ((int )v1->comment[29] != 0) {
      {
#line 118
      generic_sendmsg("%s ID3.track:%i", prefix, (int )((unsigned char )v1->comment[29]));
      }
    }
  }
#line 119
  return;
}
}
#line 121 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
static void generic_sendinfoid3(mpg123_handle *mh___0 ) 
{ 
  mpg123_id3v1 *v1 ;
  mpg123_id3v2 *v2 ;
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 125
  tmp___0 = (int )mpg123_id3(mh___0, & v1, & v2);
  }
#line 125
  if (0 != tmp___0) {
    {
#line 127
    tmp = (char const   *)mpg123_strerror(mh___0);
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c:%i] error: Cannot get ID3 data: %s\n",
            127, tmp);
    }
#line 128
    return;
  }
#line 130
  if ((unsigned long )v1 != (unsigned long )((void *)0)) {
    {
#line 132
    generic_sendv1(v1, "I");
    }
  }
#line 134
  if ((unsigned long )v2 != (unsigned long )((void *)0)) {
    {
#line 136
    generic_send_lines("I ID3v2.title:%s", v2->title);
#line 137
    generic_send_lines("I ID3v2.artist:%s", v2->artist);
#line 138
    generic_send_lines("I ID3v2.album:%s", v2->album);
#line 139
    generic_send_lines("I ID3v2.year:%s", v2->year);
#line 140
    generic_send_lines("I ID3v2.comment:%s", v2->comment);
#line 141
    generic_send_lines("I ID3v2.genre:%s", v2->genre);
    }
  }
#line 143
  return;
}
}
#line 145 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
void generic_sendalltag(mpg123_handle *mh___0 ) 
{ 
  mpg123_id3v1 *v1 ;
  mpg123_id3v2 *v2 ;
  char const   *tmp ;
  int tmp___0 ;
  size_t i ;
  char id[5] ;
  char id___0[5] ;
  char const   *tmp___1 ;
  char id___1[5] ;
  char lang[4] ;
  char const   *tmp___2 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 149
  generic_sendmsg("T {");
#line 150
  tmp___0 = (int )mpg123_id3(mh___0, & v1, & v2);
  }
#line 150
  if (0 != tmp___0) {
    {
#line 152
    tmp = (char const   *)mpg123_strerror(mh___0);
#line 152
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c:%i] error: Cannot get ID3 data: %s\n",
            152, tmp);
#line 153
    v2 = (mpg123_id3v2 *)((void *)0);
#line 154
    v1 = (mpg123_id3v1 *)((void *)0);
    }
  }
#line 156
  if ((unsigned long )v1 != (unsigned long )((void *)0)) {
    {
#line 156
    generic_sendv1(v1, "T");
    }
  }
#line 158
  if ((unsigned long )v2 != (unsigned long )((void *)0)) {
#line 161
    i = (size_t )0;
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if (! (i < v2->texts)) {
#line 161
        goto while_break;
      }
      {
#line 164
      memcpy((void */* __restrict  */)(id), (void const   */* __restrict  */)((v2->text + i)->id),
             (size_t )4);
#line 165
      id[4] = (char)0;
#line 166
      generic_sendmsg("T ID3v2.%s:", id);
#line 167
      generic_send_lines("T =%s", & (v2->text + i)->text);
#line 161
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 169
    i = (size_t )0;
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      if (! (i < v2->extras)) {
#line 169
        goto while_break___0;
      }
      {
#line 172
      memcpy((void */* __restrict  */)(id___0), (void const   */* __restrict  */)((v2->extra + i)->id),
             (size_t )4);
#line 173
      id___0[4] = (char)0;
      }
#line 174
      if ((v2->extra + i)->description.fill) {
#line 174
        tmp___1 = (char const   *)(v2->extra + i)->description.p;
      } else {
#line 174
        tmp___1 = "";
      }
      {
#line 174
      generic_sendmsg("T ID3v2.%s desc(%s):", id___0, tmp___1);
#line 177
      generic_send_lines("T =%s", & (v2->extra + i)->text);
#line 169
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 179
    i = (size_t )0;
    {
#line 179
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 179
      if (! (i < v2->comments)) {
#line 179
        goto while_break___1;
      }
      {
#line 183
      memcpy((void */* __restrict  */)(id___1), (void const   */* __restrict  */)((v2->comment_list + i)->id),
             (size_t )4);
#line 184
      id___1[4] = (char)0;
#line 185
      memcpy((void */* __restrict  */)(lang), (void const   */* __restrict  */)((v2->comment_list + i)->lang),
             (size_t )3);
#line 186
      lang[3] = (char)0;
      }
#line 187
      if ((v2->comment_list + i)->description.fill) {
#line 187
        tmp___2 = (char const   *)(v2->comment_list + i)->description.p;
      } else {
#line 187
        tmp___2 = "";
      }
      {
#line 187
      generic_sendmsg("T ID3v2.%s lang(%s) desc(%s):", id___1, lang, tmp___2);
#line 190
      generic_send_lines("T =%s", & (v2->comment_list + i)->text);
#line 179
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 193
  generic_sendmsg("T }");
  }
#line 194
  return;
}
}
#line 196 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
void generic_sendinfo(char *filename ) 
{ 
  char *s ;
  char *t ;
  char *__cil_tmp4 ;

  {
  {
#line 199
  s = strrchr((char const   *)filename, '/');
  }
#line 200
  if (! s) {
#line 201
    s = filename;
  } else {
#line 203
    s ++;
  }
  {
#line 204
  t = strrchr((char const   *)s, '.');
  }
#line 205
  if (t) {
#line 206
    *t = (char)0;
  }
  {
#line 207
  generic_sendmsg("I %s", s);
  }
#line 208
  return;
}
}
#line 210 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
static void generic_load(mpg123_handle *fr , char *arg , int state ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 212
  if (param.usebuffer) {
#line 214
    if (param.usebuffer) {
      {
#line 214
      real_buffer_resync();
      }
    }
#line 215
    if (mode == 2) {
#line 215
      if (state != 2) {
#line 215
        if (param.usebuffer) {
          {
#line 215
          real_buffer_start();
          }
        }
      }
    }
  }
#line 217
  if (mode != 0) {
    {
#line 219
    close_track();
#line 220
    mode = 0;
    }
  }
  {
#line 222
  tmp = open_track(arg);
  }
#line 222
  if (! tmp) {
    {
#line 224
    generic_sendmsg("E Error opening stream: %s", arg);
#line 225
    generic_sendmsg("P 0");
    }
#line 226
    return;
  }
  {
#line 228
  mpg123_seek_64(fr, (off_t )0, 0);
#line 229
  tmp___0 = (int )mpg123_meta_check(fr);
  }
#line 229
  if (tmp___0 & 1) {
    {
#line 229
    generic_sendinfoid3(fr);
    }
  } else {
    {
#line 230
    generic_sendinfo(arg);
    }
  }
#line 232
  if (htd.icy_name.fill) {
    {
#line 232
    generic_sendmsg("I ICY-NAME: %s", htd.icy_name.p);
    }
  }
#line 233
  if (htd.icy_url.fill) {
    {
#line 233
    generic_sendmsg("I ICY-URL: %s", htd.icy_url.p);
    }
  }
#line 235
  mode = state;
#line 236
  init = 1;
#line 237
  if (mode == 2) {
#line 237
    tmp___1 = "P 1";
  } else {
#line 237
    tmp___1 = "P 2";
  }
  {
#line 237
  generic_sendmsg(tmp___1);
  }
#line 238
  return;
}
}
#line 240 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c"
int control_generic(mpg123_handle *fr ) 
{ 
  struct timeval tv ;
  fd_set fds ;
  int n ;
  char alive ;
  char silent ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int __d0 ;
  int __d1 ;
  int tmp___2 ;
  char *meta ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  short len ;
  char *cmd ;
  char *arg ;
  char *comstr ;
  char buf[2048] ;
  short counter ;
  char *next_comstr ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  ssize_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  off_t pos ;
  off_t tmp___24 ;
  off_t len___0 ;
  off_t tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  int i ;
  double tmp___28 ;
  double tmp___29 ;
  int tmp___30 ;
  long val ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  double b ;
  double m ;
  double t ;
  int cn ;
  int tmp___37 ;
  int tmp___38 ;
  double e ;
  int c ;
  int v ;
  char const   *tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  off_t soff ;
  char *spos ;
  int whence ;
  long long tmp___46 ;
  char const   *tmp___47 ;
  off_t tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *spos___0 ;
  off_t offset___0 ;
  double secs ;
  long tmp___51 ;
  size_t tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  double v___0 ;
  double tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  double p ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t tmp___71 ;
  size_t tmp___72 ;
  char lasti ;
  void *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;

  {
#line 247
  alive = (char)1;
#line 248
  silent = (char)0;
#line 251
  if (param.remote_err) {
#line 252
    outstream = stderr;
  } else {
#line 254
    outstream = stdout;
  }
  {
#line 257
  setlinebuf(outstream);
#line 265
  fprintf((FILE */* __restrict  */)outstream, (char const   */* __restrict  */)"@R MPG123 (ThOr) v6\n");
  }
#line 267
  if (param.fifo) {
#line 269
    if ((int )*(param.fifo + 0) == 0) {
      {
#line 271
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c:%i] error: You wanted an empty FIFO name??\n",
              271);
      }
#line 272
      return (1);
    }
    {
#line 274
    unlink((char const   *)param.fifo);
#line 275
    tmp___1 = mkfifo((char const   *)param.fifo, (__mode_t )438);
    }
#line 275
    if (tmp___1 == -1) {
      {
#line 277
      tmp = __errno_location();
#line 277
      tmp___0 = strerror(*tmp);
#line 277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c:%i] error: Failed to create FIFO at %s (%s)\n",
              277, param.fifo, tmp___0);
      }
#line 278
      return (1);
    }
    {
#line 281
    control_file = open((char const   *)param.fifo, 0);
    }
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! alive) {
#line 286
      goto while_break;
    }
#line 288
    tv.tv_sec = (__time_t )0;
#line 289
    tv.tv_usec = (__suseconds_t )0;
    {
#line 290
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 290
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 290
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 291
    fds.__fds_bits[control_file / (8 * (int )sizeof(__fd_mask ))] |= 1L << control_file % (8 * (int )sizeof(__fd_mask ));
#line 293
    if (mode == 1) {
      {
#line 294
      n = select(32, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 295
      if (n == 0) {
        {
#line 296
        tmp___2 = play_frame();
        }
#line 296
        if (! tmp___2) {
#line 300
          if (param.keep_open) {
#line 302
            mode = 2;
#line 304
            if (param.usebuffer) {
#line 304
              if (param.usebuffer) {
                {
#line 304
                real_buffer_stop();
                }
              }
            }
            {
#line 305
            generic_sendmsg("P 1");
            }
          } else {
            {
#line 309
            mode = 0;
#line 310
            close_track();
#line 311
            generic_sendmsg("P 0");
            }
          }
#line 313
          goto while_continue;
        }
#line 315
        if (init) {
          {
#line 316
          print_remote_header(fr);
#line 317
          init = 0;
          }
        }
#line 319
        if ((int )silent == 0) {
          {
#line 321
          generic_sendstat(fr);
#line 322
          tmp___5 = (int )mpg123_meta_check(fr);
          }
#line 322
          if (tmp___5 & 4) {
            {
#line 325
            tmp___4 = (int )mpg123_icy(fr, & meta);
            }
#line 325
            if (tmp___4 == 0) {
#line 326
              if ((unsigned long )meta != (unsigned long )((void *)0)) {
#line 326
                tmp___3 = (char const   *)meta;
              } else {
#line 326
                tmp___3 = "<nil>";
              }
              {
#line 326
              generic_sendmsg("I ICY-META: %s", tmp___3);
              }
            }
          }
        }
      }
    } else {
      {
#line 333
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 334
        n = select(32, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
        }
#line 335
        if (n > 0) {
#line 336
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 341
    if (n < 0) {
      {
#line 342
      tmp___6 = __errno_location();
#line 342
      tmp___7 = strerror(*tmp___6);
#line 342
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error waiting for command: %s\n",
              tmp___7);
      }
#line 343
      return (1);
    }
#line 347
    if (n > 0) {
      {
#line 349
      len = (short)1;
#line 351
      comstr = (char *)((void *)0);
#line 354
      next_comstr = buf;
#line 358
      tmp___12 = read(control_file, (void *)(buf), (size_t )2048);
#line 358
      len = (short )tmp___12;
      }
#line 358
      if ((int )len < 1) {
#line 361
        if ((int )len == 0) {
#line 361
          if (param.fifo) {
            {
#line 364
            close(control_file);
#line 365
            control_file = open((char const   *)param.fifo, 2048);
            }
#line 366
            if (control_file < 0) {
              {
#line 366
              tmp___8 = __errno_location();
#line 366
              tmp___9 = strerror(*tmp___8);
#line 366
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c:%i] error: open of fifo failed... %s\n",
                      366, tmp___9);
              }
#line 366
              goto while_break;
            }
#line 367
            goto while_continue;
          }
        }
#line 370
        if ((int )len < 0) {
          {
#line 370
          tmp___10 = __errno_location();
#line 370
          tmp___11 = strerror(*tmp___10);
#line 370
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/control_generic.c:%i] error: command read error: %s\n",
                  370, tmp___11);
          }
        }
#line 371
        goto while_break;
      }
#line 376
      counter = (short)0;
      {
#line 376
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 376
        if (! ((int )counter < (int )len)) {
#line 376
          goto while_break___2;
        }
#line 379
        if ((int )buf[counter] == 10) {
#line 379
          goto _L___5;
        } else
#line 379
        if ((int )buf[counter] == 13) {
          _L___5: /* CIL Label */ 
#line 382
          buf[counter] = (char)0;
#line 383
          comstr = next_comstr;
#line 386
          if ((int )counter < (int )len - 1) {
#line 386
            if ((int )buf[(int )counter + 1] == 10) {
#line 386
              counter = (short )((int )counter + 1);
#line 386
              buf[counter] = (char)0;
            } else
#line 386
            if ((int )buf[(int )counter + 1] == 13) {
#line 386
              counter = (short )((int )counter + 1);
#line 386
              buf[counter] = (char)0;
            }
          }
          {
#line 389
          next_comstr = (buf + (int )counter) + 1;
#line 393
          tmp___13 = strlen((char const   *)comstr);
          }
#line 393
          if (tmp___13 == 0U) {
#line 393
            goto __Cont;
          }
          {
#line 396
          tmp___14 = strcasecmp((char const   *)comstr, "P");
          }
#line 396
          if (tmp___14) {
            {
#line 396
            tmp___15 = strcasecmp((char const   *)comstr, "PAUSE");
            }
#line 396
            if (! tmp___15) {
              _L: /* CIL Label */ 
#line 397
              if (mode != 0) {
#line 399
                if (mode == 1) {
#line 400
                  mode = 2;
#line 401
                  if (param.usebuffer) {
#line 401
                    if (param.usebuffer) {
                      {
#line 401
                      real_buffer_stop();
                      }
                    }
                  }
                  {
#line 402
                  generic_sendmsg("P 1");
                  }
                } else {
#line 404
                  mode = 1;
#line 405
                  if (param.usebuffer) {
#line 405
                    if (param.usebuffer) {
                      {
#line 405
                      real_buffer_start();
                      }
                    }
                  }
                  {
#line 406
                  generic_sendmsg("P 2");
                  }
                }
              } else {
                {
#line 408
                generic_sendmsg("P 0");
                }
              }
#line 409
              goto __Cont;
            }
          } else {
#line 396
            goto _L;
          }
          {
#line 413
          tmp___16 = strcasecmp((char const   *)comstr, "S");
          }
#line 413
          if (tmp___16) {
            {
#line 413
            tmp___17 = strcasecmp((char const   *)comstr, "STOP");
            }
#line 413
            if (! tmp___17) {
              _L___0: /* CIL Label */ 
#line 414
              if (mode != 0) {
#line 415
                if (param.usebuffer) {
#line 417
                  if (param.usebuffer) {
                    {
#line 417
                    real_buffer_stop();
                    }
                  }
#line 418
                  if (param.usebuffer) {
                    {
#line 418
                    real_buffer_resync();
                    }
                  }
                }
                {
#line 420
                close_track();
#line 421
                mode = 0;
#line 422
                generic_sendmsg("P 0");
                }
              } else {
                {
#line 423
                generic_sendmsg("P 0");
                }
              }
#line 424
              goto __Cont;
            }
          } else {
#line 413
            goto _L___0;
          }
          {
#line 428
          tmp___18 = strcasecmp((char const   *)comstr, "SILENCE");
          }
#line 428
          if (! tmp___18) {
            {
#line 429
            silent = (char)1;
#line 430
            generic_sendmsg("silence");
            }
#line 431
            goto __Cont;
          }
          {
#line 434
          tmp___19 = strcasecmp((char const   *)comstr, "T");
          }
#line 434
          if (tmp___19) {
            {
#line 434
            tmp___20 = strcasecmp((char const   *)comstr, "TAG");
            }
#line 434
            if (! tmp___20) {
              {
#line 435
              generic_sendalltag(fr);
              }
#line 436
              goto __Cont;
            }
          } else {
            {
#line 435
            generic_sendalltag(fr);
            }
#line 436
            goto __Cont;
          }
          {
#line 439
          tmp___23 = strcasecmp((char const   *)comstr, "SCAN");
          }
#line 439
          if (! tmp___23) {
#line 441
            if (mode != 0) {
              {
#line 443
              tmp___22 = (int )mpg123_scan(fr);
              }
#line 443
              if (tmp___22 == 0) {
                {
#line 444
                generic_sendmsg("SCAN done");
                }
              } else {
                {
#line 446
                tmp___21 = (char const   *)mpg123_strerror(fr);
#line 446
                generic_sendmsg("E %s", tmp___21);
                }
              }
            } else {
              {
#line 448
              generic_sendmsg("E No track loaded!");
              }
            }
#line 450
            goto __Cont;
          }
          {
#line 453
          tmp___27 = strcasecmp((char const   *)comstr, "SAMPLE");
          }
#line 453
          if (! tmp___27) {
            {
#line 455
            tmp___24 = (off_t )mpg123_tell_64(fr);
#line 455
            pos = tmp___24;
#line 456
            tmp___25 = (off_t )mpg123_length_64(fr);
#line 456
            len___0 = tmp___25;
            }
#line 458
            if (len___0 < 0LL) {
              {
#line 458
              tmp___26 = (char const   *)mpg123_strerror(fr);
#line 458
              generic_sendmsg("E %s", tmp___26);
              }
            } else {
              {
#line 459
              generic_sendmsg("SAMPLE %li %li", (long )pos, (long )len___0);
              }
            }
#line 460
            goto __Cont;
          }
          {
#line 463
          tmp___30 = strcasecmp((char const   *)comstr, "SHOWEQ");
          }
#line 463
          if (! tmp___30) {
            {
#line 466
            generic_sendmsg("SHOWEQ {");
#line 467
            i = 0;
            }
            {
#line 467
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 467
              if (! (i < 32)) {
#line 467
                goto while_break___3;
              }
              {
#line 469
              tmp___28 = (double )mpg123_geteq(fr, (enum mpg123_channels )1, i);
#line 469
              generic_sendmsg("SHOWEQ %i : %i : %f", 1, i, tmp___28);
#line 470
              tmp___29 = (double )mpg123_geteq(fr, (enum mpg123_channels )2, i);
#line 470
              generic_sendmsg("SHOWEQ %i : %i : %f", 2, i, tmp___29);
#line 467
              i ++;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 472
            generic_sendmsg("SHOWEQ }");
            }
#line 473
            goto __Cont;
          }
          {
#line 476
          tmp___32 = strcasecmp((char const   *)comstr, "STATE");
          }
#line 476
          if (! tmp___32) {
            {
#line 479
            generic_sendmsg("STATE {");
#line 481
            tmp___31 = (int )mpg123_getstate(fr, (enum mpg123_state )1, & val, (double *)((void *)0));
            }
#line 481
            if (tmp___31 == 0) {
              {
#line 482
              generic_sendmsg("STATE accurate %li", val);
              }
            }
            {
#line 484
            generic_sendmsg("STATE }");
            }
#line 485
            goto __Cont;
          }
          {
#line 489
          tmp___33 = strcasecmp((char const   *)comstr, "Q");
          }
#line 489
          if (tmp___33) {
            {
#line 489
            tmp___34 = strcasecmp((char const   *)comstr, "QUIT");
            }
#line 489
            if (! tmp___34) {
#line 490
              alive = (char)0;
#line 490
              goto __Cont;
            }
          } else {
#line 490
            alive = (char)0;
#line 490
            goto __Cont;
          }
          {
#line 494
          tmp___35 = strcasecmp((char const   *)comstr, "H");
          }
#line 494
          if (tmp___35) {
            {
#line 494
            tmp___36 = strcasecmp((char const   *)comstr, "HELP");
            }
#line 494
            if (! tmp___36) {
              _L___1: /* CIL Label */ 
              {
#line 495
              generic_sendmsg("H {");
#line 496
              generic_sendmsg("H HELP/H: command listing (LONG/SHORT forms), command case insensitve");
#line 497
              generic_sendmsg("H LOAD/L <trackname>: load and start playing resource <trackname>");
#line 498
              generic_sendmsg("H LOADPAUSED/LP <trackname>: load but do not start playing resource <trackname>");
#line 499
              generic_sendmsg("H PAUSE/P: pause playback");
#line 500
              generic_sendmsg("H STOP/S: stop playback (closes file)");
#line 501
              generic_sendmsg("H JUMP/J <frame>|<+offset>|<-offset>|<[+|-]seconds>s: jump to mpeg frame <frame> or change position by offset, same in seconds if number followed by \"s\"");
#line 502
              generic_sendmsg("H VOLUME/V <percent>: set volume in % (0..100...); float value");
#line 503
              generic_sendmsg("H RVA off|(mix|radio)|(album|audiophile): set rva mode");
#line 504
              generic_sendmsg("H EQ/E <channel> <band> <value>: set equalizer value for frequency band 0 to 31 on channel %i (left) or %i (right) or %i (both)",
                              1, 2, 3);
#line 505
              generic_sendmsg("H EQFILE <filename>: load EQ settings from a file");
#line 506
              generic_sendmsg("H SHOWEQ: show all equalizer settings (as <channel> <band> <value> lines in a SHOWEQ block (like TAG))");
#line 507
              generic_sendmsg("H SEEK/K <sample>|<+offset>|<-offset>: jump to output sample position <samples> or change position by offset");
#line 508
              generic_sendmsg("H SCAN: scan through the file, building seek index");
#line 509
              generic_sendmsg("H SAMPLE: print out the sample position and total number of samples");
#line 510
              generic_sendmsg("H SEQ <bass> <mid> <treble>: simple eq setting...");
#line 511
              generic_sendmsg("H PITCH <[+|-]value>: adjust playback speed (+0.01 is 1 %% faster)");
#line 512
              generic_sendmsg("H SILENCE: be silent during playback (meaning silence in text form)");
#line 513
              generic_sendmsg("H STATE: Print auxilliary state info in several lines (just try it to see what info is there).");
#line 514
              generic_sendmsg("H TAG/T: Print all available (ID3) tag info, for ID3v2 that gives output of all collected text fields, using the ID3v2.3/4 4-character names.");
#line 515
              generic_sendmsg("H    The output is multiple lines, begin marked by \"@T {\", end by \"@T }\".");
#line 516
              generic_sendmsg("H    ID3v1 data is like in the @I info lines (see below), just with \"@T\" in front.");
#line 517
              generic_sendmsg("H    An ID3v2 data field is introduced via ([ ... ] means optional):");
#line 518
              generic_sendmsg("H     @T ID3v2.<NAME>[ [lang(<LANG>)] desc(<description>)]:");
#line 519
              generic_sendmsg("H    The lines of data follow with \"=\" prefixed:");
#line 520
              generic_sendmsg("H     @T =<one line of content in UTF-8 encoding>");
#line 521
              generic_sendmsg("H meaning of the @S stream info:");
#line 522
              generic_sendmsg("H %s", remote_header_help);
#line 523
              generic_sendmsg("H The @I lines after loading a track give some ID3 info, the format:");
#line 524
              generic_sendmsg("H      @I ID3:artist  album  year  comment genretext");
#line 525
              generic_sendmsg("H     where artist,album and comment are exactly 30 characters each, year is 4 characters, genre text unspecified.");
#line 526
              generic_sendmsg("H     You will encounter \"@I ID3.genre:<number>\" and \"@I ID3.track:<number>\".");
#line 527
              generic_sendmsg("H     Then, there is an excerpt of ID3v2 info in the structure");
#line 528
              generic_sendmsg("H      @I ID3v2.title:Blabla bla Bla");
#line 529
              generic_sendmsg("H     for every line of the \"title\" data field. Likewise for other fields (author, album, etc).");
#line 530
              generic_sendmsg("H }");
              }
#line 531
              goto __Cont;
            }
          } else {
#line 494
            goto _L___1;
          }
          {
#line 535
          cmd = (char *)((void *)0);
#line 536
          arg = (char *)((void *)0);
#line 537
          cmd = strtok((char */* __restrict  */)comstr, (char const   */* __restrict  */)" \t");
#line 538
          arg = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"");
          }
#line 540
          if (cmd) {
            {
#line 540
            tmp___71 = strlen((char const   *)cmd);
            }
#line 540
            if (tmp___71) {
#line 540
              if (arg) {
                {
#line 540
                tmp___72 = strlen((char const   *)arg);
                }
#line 540
                if (tmp___72) {
                  {
#line 543
                  tmp___38 = strcasecmp((char const   *)cmd, "SEQ");
                  }
#line 543
                  if (! tmp___38) {
                    {
#line 546
                    tmp___37 = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%lf %lf %lf",
                                      & b, & m, & t);
                    }
#line 546
                    if (tmp___37 == 3) {
#line 549
                      if (t >= (double )0) {
#line 549
                        if (t <= (double )3) {
#line 550
                          cn = 0;
                          {
#line 550
                          while (1) {
                            while_continue___4: /* CIL Label */ ;
#line 550
                            if (! (cn < 1)) {
#line 550
                              goto while_break___4;
                            }
                            {
#line 550
                            mpg123_eq(fr, (enum mpg123_channels )3, cn, b);
#line 550
                            cn ++;
                            }
                          }
                          while_break___4: /* CIL Label */ ;
                          }
                        }
                      }
#line 552
                      if (m >= (double )0) {
#line 552
                        if (m <= (double )3) {
#line 553
                          cn = 1;
                          {
#line 553
                          while (1) {
                            while_continue___5: /* CIL Label */ ;
#line 553
                            if (! (cn < 2)) {
#line 553
                              goto while_break___5;
                            }
                            {
#line 553
                            mpg123_eq(fr, (enum mpg123_channels )3, cn, m);
#line 553
                            cn ++;
                            }
                          }
                          while_break___5: /* CIL Label */ ;
                          }
                        }
                      }
#line 555
                      if (b >= (double )0) {
#line 555
                        if (b <= (double )3) {
#line 556
                          cn = 2;
                          {
#line 556
                          while (1) {
                            while_continue___6: /* CIL Label */ ;
#line 556
                            if (! (cn < 32)) {
#line 556
                              goto while_break___6;
                            }
                            {
#line 556
                            mpg123_eq(fr, (enum mpg123_channels )3, cn, t);
#line 556
                            cn ++;
                            }
                          }
                          while_break___6: /* CIL Label */ ;
                          }
                        }
                      }
                      {
#line 558
                      generic_sendmsg("bass: %f mid: %f treble: %f", b, m, t);
                      }
                    } else {
                      {
#line 560
                      generic_sendmsg("E invalid arguments for SEQ: %s", arg);
                      }
                    }
#line 561
                    goto __Cont;
                  }
                  {
#line 565
                  tmp___42 = strcasecmp((char const   *)cmd, "E");
                  }
#line 565
                  if (tmp___42) {
                    {
#line 565
                    tmp___43 = strcasecmp((char const   *)cmd, "EQ");
                    }
#line 565
                    if (! tmp___43) {
                      _L___2: /* CIL Label */ 
                      {
#line 569
                      tmp___41 = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%i %i %lf",
                                        & c, & v, & e);
                      }
#line 569
                      if (tmp___41 == 3) {
                        {
#line 571
                        tmp___40 = (int )mpg123_eq(fr, (enum mpg123_channels )c, v,
                                                   e);
                        }
#line 571
                        if (tmp___40 == 0) {
                          {
#line 572
                          generic_sendmsg("%i : %i : %f", c, v, e);
                          }
                        } else {
                          {
#line 574
                          tmp___39 = (char const   *)mpg123_strerror(fr);
#line 574
                          generic_sendmsg("E failed to set eq: %s", tmp___39);
                          }
                        }
                      } else {
                        {
#line 576
                        generic_sendmsg("E invalid arguments for EQ: %s", arg);
                        }
                      }
#line 577
                      goto __Cont;
                    }
                  } else {
#line 565
                    goto _L___2;
                  }
                  {
#line 580
                  tmp___45 = strcasecmp((char const   *)cmd, "EQFILE");
                  }
#line 580
                  if (! tmp___45) {
                    {
#line 582
                    equalfile = arg;
#line 583
                    tmp___44 = load_equalizer(fr);
                    }
#line 583
                    if (tmp___44 == 0) {
                      {
#line 584
                      generic_sendmsg("EQFILE done");
                      }
                    } else {
                      {
#line 586
                      generic_sendmsg("E failed to parse given eq file");
                      }
                    }
#line 588
                    goto __Cont;
                  }
                  {
#line 592
                  tmp___49 = strcasecmp((char const   *)cmd, "K");
                  }
#line 592
                  if (tmp___49) {
                    {
#line 592
                    tmp___50 = strcasecmp((char const   *)cmd, "SEEK");
                    }
#line 592
                    if (! tmp___50) {
                      _L___3: /* CIL Label */ 
#line 595
                      spos = arg;
#line 596
                      whence = 0;
#line 597
                      if (mode == 0) {
                        {
#line 599
                        generic_sendmsg("E No track loaded!");
                        }
#line 600
                        goto __Cont;
                      }
                      {
#line 603
                      tmp___46 = atoll((char const   *)spos);
#line 603
                      soff = tmp___46;
                      }
#line 604
                      if ((int )*(spos + 0) == 45) {
#line 604
                        whence = 1;
                      } else
#line 604
                      if ((int )*(spos + 0) == 43) {
#line 604
                        whence = 1;
                      }
                      {
#line 605
                      soff = (off_t )mpg123_seek_64(fr, soff, whence);
                      }
#line 605
                      if (0LL > soff) {
                        {
#line 607
                        tmp___47 = (char const   *)mpg123_strerror(fr);
#line 607
                        generic_sendmsg("E Error while seeking: %s", tmp___47);
#line 608
                        mpg123_seek_64(fr, (off_t )0, 0);
                        }
                      }
#line 610
                      if (param.usebuffer) {
#line 610
                        if (param.usebuffer) {
                          {
#line 610
                          real_buffer_resync();
                          }
                        }
                      }
                      {
#line 612
                      tmp___48 = (off_t )mpg123_tell_64(fr);
#line 612
                      generic_sendmsg("K %li", (long )tmp___48);
                      }
#line 613
                      goto __Cont;
                    }
                  } else {
#line 592
                    goto _L___3;
                  }
                  {
#line 616
                  tmp___54 = strcasecmp((char const   *)cmd, "J");
                  }
#line 616
                  if (tmp___54) {
                    {
#line 616
                    tmp___55 = strcasecmp((char const   *)cmd, "JUMP");
                    }
#line 616
                    if (! tmp___55) {
                      _L___4: /* CIL Label */ 
#line 621
                      spos___0 = arg;
#line 622
                      if (mode == 0) {
                        {
#line 624
                        generic_sendmsg("E No track loaded!");
                        }
#line 625
                        goto __Cont;
                      }
                      {
#line 628
                      tmp___52 = strlen((char const   *)spos___0);
                      }
#line 628
                      if ((int )*(spos___0 + (tmp___52 - 1U)) == 115) {
                        {
#line 628
                        tmp___53 = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%lf",
                                          & secs);
                        }
#line 628
                        if (tmp___53 == 1) {
                          {
#line 628
                          offset___0 = (off_t )mpg123_timeframe_64(fr, secs);
                          }
                        } else {
                          {
#line 629
                          tmp___51 = atol((char const   *)spos___0);
#line 629
                          offset___0 = (off_t )tmp___51;
                          }
                        }
                      } else {
                        {
#line 629
                        tmp___51 = atol((char const   *)spos___0);
#line 629
                        offset___0 = (off_t )tmp___51;
                        }
                      }
#line 632
                      if ((int )*(spos___0 + 0) == 45) {
#line 632
                        offset___0 += framenum;
                      } else
#line 632
                      if ((int )*(spos___0 + 0) == 43) {
#line 632
                        offset___0 += framenum;
                      }
                      {
#line 634
                      framenum = (off_t )mpg123_seek_frame_64(fr, offset___0, 0);
                      }
#line 634
                      if (0LL > framenum) {
                        {
#line 636
                        generic_sendmsg("E Error while seeking");
#line 637
                        mpg123_seek_frame_64(fr, (off_t )0, 0);
                        }
                      }
#line 639
                      if (param.usebuffer) {
#line 639
                        if (param.usebuffer) {
                          {
#line 639
                          real_buffer_resync();
                          }
                        }
                      }
                      {
#line 641
                      generic_sendmsg("J %d", framenum);
                      }
#line 642
                      goto __Cont;
                    }
                  } else {
#line 616
                    goto _L___4;
                  }
                  {
#line 646
                  tmp___57 = strcasecmp((char const   *)cmd, "V");
                  }
#line 646
                  if (tmp___57) {
                    {
#line 646
                    tmp___58 = strcasecmp((char const   *)cmd, "VOLUME");
                    }
#line 646
                    if (! tmp___58) {
                      {
#line 649
                      tmp___56 = atof((char const   *)arg);
#line 649
                      mpg123_volume(fr, tmp___56 / (double )100);
#line 650
                      mpg123_getvolume(fr, & v___0, (double *)((void *)0), (double *)((void *)0));
#line 651
                      generic_sendmsg("V %f%%", v___0 * (double )100);
                      }
#line 652
                      goto __Cont;
                    }
                  } else {
                    {
#line 649
                    tmp___56 = atof((char const   *)arg);
#line 649
                    mpg123_volume(fr, tmp___56 / (double )100);
#line 650
                    mpg123_getvolume(fr, & v___0, (double *)((void *)0), (double *)((void *)0));
#line 651
                    generic_sendmsg("V %f%%", v___0 * (double )100);
                    }
#line 652
                    goto __Cont;
                  }
                  {
#line 656
                  tmp___60 = strcasecmp((char const   *)cmd, "PITCH");
                  }
#line 656
                  if (! tmp___60) {
                    {
#line 659
                    tmp___59 = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%lf",
                                      & p);
                    }
#line 659
                    if (tmp___59 == 1) {
                      {
#line 661
                      set_pitch(fr, ao, p);
#line 662
                      generic_sendmsg("PITCH %f", param.pitch);
                      }
                    } else {
                      {
#line 664
                      generic_sendmsg("E invalid arguments for PITCH: %s", arg);
                      }
                    }
#line 665
                    goto __Cont;
                  }
                  {
#line 669
                  tmp___66 = strcasecmp((char const   *)cmd, "RVA");
                  }
#line 669
                  if (! tmp___66) {
                    {
#line 671
                    tmp___65 = strcasecmp((char const   *)arg, "off");
                    }
#line 671
                    if (tmp___65) {
                      {
#line 672
                      tmp___63 = strcasecmp((char const   *)arg, "mix");
                      }
#line 672
                      if (tmp___63) {
                        {
#line 672
                        tmp___64 = strcasecmp((char const   *)arg, "radio");
                        }
#line 672
                        if (tmp___64) {
                          {
#line 673
                          tmp___61 = strcasecmp((char const   *)arg, "album");
                          }
#line 673
                          if (tmp___61) {
                            {
#line 673
                            tmp___62 = strcasecmp((char const   *)arg, "audiophile");
                            }
#line 673
                            if (! tmp___62) {
#line 673
                              param.rva = 2L;
                            }
                          } else {
#line 673
                            param.rva = 2L;
                          }
                        } else {
#line 672
                          param.rva = 1L;
                        }
                      } else {
#line 672
                        param.rva = 1L;
                      }
                    } else {
#line 671
                      param.rva = 0L;
                    }
                    {
#line 674
                    mpg123_volume_change(fr, 0.);
#line 675
                    generic_sendmsg("RVA %s", rva_name[param.rva]);
                    }
#line 676
                    goto __Cont;
                  }
                  {
#line 680
                  tmp___67 = strcasecmp((char const   *)cmd, "L");
                  }
#line 680
                  if (tmp___67) {
                    {
#line 680
                    tmp___68 = strcasecmp((char const   *)cmd, "LOAD");
                    }
#line 680
                    if (! tmp___68) {
                      {
#line 680
                      generic_load(fr, arg, 1);
                      }
#line 680
                      goto __Cont;
                    }
                  } else {
                    {
#line 680
                    generic_load(fr, arg, 1);
                    }
#line 680
                    goto __Cont;
                  }
                  {
#line 683
                  tmp___69 = strcasecmp((char const   *)cmd, "LP");
                  }
#line 683
                  if (tmp___69) {
                    {
#line 683
                    tmp___70 = strcasecmp((char const   *)cmd, "LOADPAUSED");
                    }
#line 683
                    if (! tmp___70) {
                      {
#line 683
                      generic_load(fr, arg, 2);
                      }
#line 683
                      goto __Cont;
                    }
                  } else {
                    {
#line 683
                    generic_load(fr, arg, 2);
                    }
#line 683
                    goto __Cont;
                  }
                  {
#line 686
                  generic_sendmsg("E Unknown command: %s", cmd);
                  }
                } else {
                  {
#line 688
                  generic_sendmsg("E Unknown command or no arguments: %s", comstr);
                  }
                }
              } else {
                {
#line 688
                generic_sendmsg("E Unknown command or no arguments: %s", comstr);
                }
              }
            } else {
              {
#line 688
              generic_sendmsg("E Unknown command or no arguments: %s", comstr);
              }
            }
          } else {
            {
#line 688
            generic_sendmsg("E Unknown command or no arguments: %s", comstr);
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 376
        counter = (short )((int )counter + 1);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 702
      if ((int )buf[(int )len - 1] != 0) {
        {
#line 704
        lasti = buf[(int )len - 1];
#line 705
        buf[(int )len - 1] = (char)0;
#line 706
        generic_sendmsg("E Unfinished command: %s%c", comstr, (int )lasti);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  if (param.usebuffer) {
    {
#line 714
    kill(buffer_pid, 2);
#line 715
    xfermem_init_reader(buffermem);
#line 716
    waitpid(buffer_pid, (int *)((void *)0), 0);
#line 717
    xfermem_done(buffermem);
    }
  }
  {
#line 722
  close(control_file);
  }
#line 723
  if (param.fifo) {
    {
#line 723
    unlink((char const   *)param.fifo);
    }
  }
#line 726
  return (0);
}
}
#line 185 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 266
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 16 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
char const   *rva_name[3]  = {      "off",      "mix",      "album"};
#line 17 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
static char const   *modes[5]  = {      "Stereo",      "Joint-Stereo",      "Dual-Channel",      "Single-Channel", 
        "Invalid"};
#line 18 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
static char const   *smodes[5]  = {      "stereo",      "joint-stereo",      "dual-channel",      "mono", 
        "invalid"};
#line 19 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
static char const   *layers[4]  = {      "Unknown",      "I",      "II",      "III"};
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
static char const   *versions[4]  = {      "1.0",      "2.0",      "2.5",      "x.x"};
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
static int const   samples_pre_frame[4][4]  = { {        (int const   )-1,        (int const   )384,        (int const   )1152,        (int const   )1152}, 
   {        (int const   )-1,        (int const   )384,        (int const   )1152,        (int const   )576}, 
   {        (int const   )-1,        (int const   )384,        (int const   )1152,        (int const   )576}, 
   {        (int const   )-1,        (int const   )-1,        (int const   )-1,        (int const   )-1}};
#line 31 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
void (*catchsignal(int signum , void (*handler)() ))() 
{ 
  struct sigaction new_sa ;
  struct sigaction old_sa ;
  int tmp ;

  {
  {
#line 41
  new_sa.__sigaction_handler.sa_handler = (void (*)(int  ))handler;
#line 42
  sigemptyset(& new_sa.sa_mask);
#line 43
  new_sa.sa_flags = 0;
#line 44
  tmp = sigaction(signum, (struct sigaction  const  */* __restrict  */)(& new_sa),
                  (struct sigaction */* __restrict  */)(& old_sa));
  }
#line 44
  if (tmp == -1) {
#line 45
    return ((void (*)())-1);
  }
#line 46
  return ((void (*)())old_sa.__sigaction_handler.sa_handler);
}
}
#line 51 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
char const   *remote_header_help  =    "S <mpeg-version> <layer> <sampling freq> <mode(stereo/mono/...)> <mode_ext> <framesize> <stereo> <copyright> <error_protected> <emphasis> <bitrate> <extension> <vbr(0/1=yes/no)>";
#line 52 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
void print_remote_header(mpg123_handle *mh___0 ) 
{ 
  struct mpg123_frameinfo i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 55
  mpg123_info(mh___0, & i);
  }
#line 56
  if ((unsigned int )i.mode >= 4U) {
#line 56
    i.mode = (enum mpg123_mode )4;
  } else
#line 56
  if ((unsigned int )i.mode < 0U) {
#line 56
    i.mode = (enum mpg123_mode )4;
  }
#line 57
  if ((unsigned int )i.version >= 3U) {
#line 57
    i.version = (enum mpg123_version )3;
  } else
#line 57
  if ((unsigned int )i.version < 0U) {
#line 57
    i.version = (enum mpg123_version )3;
  }
#line 58
  if ((unsigned int )i.flags & 4U) {
#line 58
    tmp = 1;
  } else {
#line 58
    tmp = 0;
  }
#line 58
  if ((unsigned int )i.flags & 1U) {
#line 58
    tmp___0 = 1;
  } else {
#line 58
    tmp___0 = 0;
  }
#line 58
  if ((unsigned int )i.flags & 2U) {
#line 58
    tmp___1 = 1;
  } else {
#line 58
    tmp___1 = 0;
  }
#line 58
  if ((unsigned int )i.mode == 3U) {
#line 58
    tmp___2 = 1;
  } else {
#line 58
    tmp___2 = 2;
  }
  {
#line 58
  generic_sendmsg("S %s %d %ld %s %d %d %d %d %d %d %d %d %d", versions[i.version],
                  i.layer, i.rate, modes[i.mode], i.mode_ext, i.framesize, tmp___2,
                  tmp___1, tmp___0, i.emphasis, i.bitrate, tmp, (unsigned int )i.vbr);
  }
#line 72
  return;
}
}
#line 74 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
void print_header(mpg123_handle *mh___0 ) 
{ 
  struct mpg123_frameinfo i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 77
  mpg123_info(mh___0, & i);
  }
#line 78
  if ((unsigned int )i.mode > 4U) {
#line 78
    i.mode = (enum mpg123_mode )4;
  } else
#line 78
  if ((unsigned int )i.mode < 0U) {
#line 78
    i.mode = (enum mpg123_mode )4;
  }
#line 79
  if ((unsigned int )i.version > 3U) {
#line 79
    i.version = (enum mpg123_version )3;
  } else
#line 79
  if ((unsigned int )i.version < 0U) {
#line 79
    i.version = (enum mpg123_version )3;
  }
#line 80
  if (i.layer > 3) {
#line 80
    i.layer = 0;
  } else
#line 80
  if (i.layer < 0) {
#line 80
    i.layer = 0;
  }
  {
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPEG %s, Layer: %s, Freq: %ld, mode: %s, modext: %d, BPF : %d\n",
          versions[i.version], layers[i.layer], i.rate, modes[i.mode], i.mode_ext,
          i.framesize);
  }
#line 85
  if ((unsigned int )i.flags & 1U) {
#line 85
    tmp = "Yes";
  } else {
#line 85
    tmp = "No";
  }
#line 85
  if ((unsigned int )i.flags & 8U) {
#line 85
    tmp___0 = "Yes";
  } else {
#line 85
    tmp___0 = "No";
  }
#line 85
  if ((unsigned int )i.flags & 2U) {
#line 85
    tmp___1 = "Yes";
  } else {
#line 85
    tmp___1 = "No";
  }
#line 85
  if ((unsigned int )i.mode == 3U) {
#line 85
    tmp___2 = 1;
  } else {
#line 85
    tmp___2 = 2;
  }
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Channels: %d, copyright: %s, original: %s, CRC: %s, emphasis: %d.\n",
          tmp___2, tmp___1, tmp___0, tmp, i.emphasis);
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bitrate: ");
  }
  {
#line 92
  if ((unsigned int )i.vbr == 0U) {
#line 92
    goto case_0;
  }
#line 96
  if ((unsigned int )i.vbr == 1U) {
#line 96
    goto case_1;
  }
#line 97
  if ((unsigned int )i.vbr == 2U) {
#line 97
    goto case_2;
  }
#line 98
  goto switch_default;
  case_0: /* CIL Label */ 
#line 93
  if (i.bitrate) {
    {
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d kbit/s",
            i.bitrate);
    }
  } else {
    {
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d kbit/s (free format)",
            (int )(((((double )i.framesize * (double )8) * (double )i.rate) * 0.001) / (double )samples_pre_frame[i.version][i.layer] + 0.5));
    }
  }
#line 95
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"VBR");
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d kbit/s ABR",
          i.abr_rate);
  }
#line 97
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 98
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"???");
  }
  switch_break: /* CIL Label */ ;
  }
#line 100
  if ((unsigned int )i.flags & 4U) {
#line 100
    tmp___3 = 1;
  } else {
#line 100
    tmp___3 = 0;
  }
  {
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Extension value: %d\n",
          tmp___3);
  }
#line 101
  return;
}
}
#line 103 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
void print_header_compact(mpg123_handle *mh___0 ) 
{ 
  struct mpg123_frameinfo i ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 106
  mpg123_info(mh___0, & i);
  }
#line 107
  if ((unsigned int )i.mode > 4U) {
#line 107
    i.mode = (enum mpg123_mode )4;
  } else
#line 107
  if ((unsigned int )i.mode < 0U) {
#line 107
    i.mode = (enum mpg123_mode )4;
  }
#line 108
  if ((unsigned int )i.version > 3U) {
#line 108
    i.version = (enum mpg123_version )3;
  } else
#line 108
  if ((unsigned int )i.version < 0U) {
#line 108
    i.version = (enum mpg123_version )3;
  }
#line 109
  if (i.layer > 3) {
#line 109
    i.layer = 0;
  } else
#line 109
  if (i.layer < 0) {
#line 109
    i.layer = 0;
  }
  {
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MPEG %s layer %s, ",
          versions[i.version], layers[i.layer]);
  }
  {
#line 114
  if ((unsigned int )i.vbr == 0U) {
#line 114
    goto case_0;
  }
#line 118
  if ((unsigned int )i.vbr == 1U) {
#line 118
    goto case_1;
  }
#line 119
  if ((unsigned int )i.vbr == 2U) {
#line 119
    goto case_2;
  }
#line 120
  goto switch_default;
  case_0: /* CIL Label */ 
#line 115
  if (i.bitrate) {
    {
#line 115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d kbit/s",
            i.bitrate);
    }
  } else {
    {
#line 116
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d kbit/s (free format)",
            (int )(((((double )i.framesize * (double )8) * (double )i.rate) * 0.001) / (double )samples_pre_frame[i.version][i.layer] + 0.5));
    }
  }
#line 117
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 118
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"VBR");
  }
#line 118
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 119
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d kbit/s ABR",
          i.abr_rate);
  }
#line 119
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"???");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 122
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", %ld Hz %s\n",
          i.rate, smodes[i.mode]);
  }
#line 123
  return;
}
}
#line 156 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
static char *lastdir  =    (char *)((void *)0);
#line 154 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
int split_dir_file(char const   *path , char **dname , char **fname ) 
{ 
  char *slashpos ;
  int tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 159
  slashpos = strrchr(path, '/');
  }
#line 159
  if (slashpos) {
    {
#line 160
    *fname = slashpos + 1;
#line 161
    *dname = strdup(path);
    }
#line 162
    if (! *dname) {
      {
#line 163
      perror("failed to allocate memory for dir name");
      }
#line 164
      return (0);
    }
#line 166
    *(*dname + ((slashpos + 1) - (char *)path)) = (char)0;
#line 167
    if (lastdir) {
      {
#line 167
      tmp = strcmp((char const   *)lastdir, (char const   *)*dname);
      }
#line 167
      if (tmp) {
#line 167
        goto _L;
      } else {
        {
#line 169
        free((void *)*dname);
#line 170
        *dname = lastdir;
        }
#line 171
        return (0);
      }
    } else {
      _L: /* CIL Label */ 
#line 175
      if (lastdir) {
        {
#line 176
        free((void *)lastdir);
        }
      }
#line 177
      lastdir = *dname;
#line 178
      return (1);
    }
  } else {
#line 183
    if (lastdir) {
      {
#line 184
      free((void *)lastdir);
#line 185
      lastdir = (char *)((void *)0);
      }
    }
#line 187
    *dname = (char *)((void *)0);
#line 188
    *fname = (char *)path;
#line 189
    return (0);
  }
}
}
#line 193 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
unsigned int roundui(double val ) 
{ 
  double base ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 195
  tmp = floor(val);
#line 195
  base = tmp;
  }
#line 196
  if (val - base < 0.5) {
#line 196
    tmp___0 = base;
  } else {
#line 196
    tmp___0 = base + (double )1;
  }
#line 196
  return ((unsigned int )tmp___0);
}
}
#line 199 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
void print_stat(mpg123_handle *fr , long offset___0 , long buffsize ) 
{ 
  double tim1 ;
  double tim2 ;
  off_t rno ;
  off_t no ;
  double basevol ;
  double realvol ;
  char *icy ;
  struct timeval t ;
  fd_set serr ;
  int n ;
  int errfd ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 211
  tmp = fileno(stderr);
#line 211
  errfd = tmp;
#line 213
  t.tv_usec = (__suseconds_t )0;
#line 213
  t.tv_sec = t.tv_usec;
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& serr.__fds_bits[0]): "memory");
#line 215
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 216
  serr.__fds_bits[errfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << errfd % (8 * (int )sizeof(__fd_mask ));
#line 217
  n = select(errfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& serr),
             (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& t));
  }
#line 218
  if (n <= 0) {
#line 218
    return;
  }
  {
#line 222
  tmp___2 = (int )mpg123_position_64(fr, (off_t )offset___0, (off_t )buffsize, & no,
                                     & rno, & tim1, & tim2);
  }
#line 222
  if (0 == tmp___2) {
    {
#line 222
    tmp___3 = (int )mpg123_getvolume(fr, & basevol, & realvol, (double *)((void *)0));
    }
#line 222
    if (0 == tmp___3) {
      {
#line 225
      tmp___0 = roundui(realvol * (double )100);
#line 225
      tmp___1 = roundui(basevol * (double )100);
#line 225
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rFrame# %5lli [%5lli], Time: %02lu:%02u.%02u [%02u:%02u.%02u], RVA:%6s, Vol: %3u(%3u)",
              no, rno, (unsigned long )tim1 / 60UL, (unsigned int )tim1 % 60U, (unsigned int )(tim1 * (double )100) % 100U,
              (unsigned int )tim2 / 60U, (unsigned int )tim2 % 60U, (unsigned int )(tim2 * (double )100) % 100U,
              rva_name[param.rva], tmp___1, tmp___0);
      }
#line 230
      if (param.usebuffer) {
        {
#line 230
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", [%8ld] ",
                buffsize);
        }
      }
    }
  }
  {
#line 233
  tmp___4 = (int )mpg123_meta_check(fr);
  }
#line 233
  if (tmp___4 & 4) {
    {
#line 233
    tmp___5 = (int )mpg123_icy(fr, & icy);
    }
#line 233
    if (0 == tmp___5) {
      {
#line 234
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nICY-META: %s\n",
              icy);
      }
    }
  }
#line 235
  return;
}
}
#line 237 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/common.c"
void clear_stat(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 239
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                                                                                       \r");
  }
#line 240
  return;
}
}
#line 255 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 120 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/mpg123app.h"
void buffer_loop(audio_output_t *ao___0 , sigset_t *oldsigset ) ;
#line 21 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
int outburst  =    32768;
#line 23 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
static int intflag___0  =    0;
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
static int usr1flag  =    0;
#line 26 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
static void catch_interrupt___0(void) 
{ 


  {
#line 28
  intflag___0 = 1;
#line 29
  return;
}
}
#line 31 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
static void catch_usr1(void) 
{ 


  {
#line 33
  usr1flag = 1;
#line 34
  return;
}
}
#line 38
void buffer_sig(int signal___0 , int block___0 ) ;
#line 40 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
void real_buffer_ignore_lowmem(void) 
{ 


  {
#line 42
  if (! buffermem) {
#line 43
    return;
  }
#line 44
  if (buffermem->wakeme[1]) {
    {
#line 45
    xfermem_putcmd(buffermem->fd[0], (byte )2);
    }
  }
#line 46
  return;
}
}
#line 48 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
void real_buffer_end(int rude ) 
{ 
  int tmp ;

  {
#line 50
  if (! buffermem) {
#line 51
    return;
  }
#line 52
  if (rude) {
#line 52
    tmp = 7;
  } else {
#line 52
    tmp = 3;
  }
  {
#line 52
  xfermem_putcmd(buffermem->fd[0], (byte )tmp);
  }
#line 53
  return;
}
}
#line 55 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
void real_buffer_resync(void) 
{ 


  {
#line 57
  if (buffermem->justwait) {
    {
#line 59
    buffermem->wakeme[0] = 1;
#line 60
    xfermem_putcmd(buffermem->fd[0], (byte )6);
#line 61
    xfermem_getcmd(buffermem->fd[0], 1);
    }
  } else {
    {
#line 63
    buffer_sig(2, 1);
    }
  }
#line 64
  return;
}
}
#line 66 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
void real_plain_buffer_resync(void) 
{ 


  {
  {
#line 68
  buffer_sig(2, 0);
  }
#line 69
  return;
}
}
#line 71 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
void real_buffer_reset(void) 
{ 


  {
  {
#line 73
  buffer_sig(10, 1);
  }
#line 74
  return;
}
}
#line 76 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
void real_buffer_start(void) 
{ 


  {
#line 78
  if (buffermem->justwait) {
    {
#line 81
    buffermem->justwait = 0;
#line 82
    xfermem_putcmd(buffermem->fd[0], (byte )2);
    }
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
void real_buffer_stop(void) 
{ 


  {
  {
#line 88
  buffermem->justwait = 1;
#line 89
  buffer_sig(2, 1);
  }
#line 90
  return;
}
}
#line 94 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
void buffer_sig(int signal___0 , int block___0 ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;

  {
#line 96
  if (! buffermem) {
#line 96
    return;
  }
#line 98
  if (! block___0) {
    {
#line 100
    kill(buffer_pid, signal___0);
    }
#line 101
    return;
  }
  {
#line 106
  tmp = xfermem_sigblock(0, buffermem, buffer_pid, signal___0);
  }
#line 106
  if (tmp != 2) {
    {
#line 107
    perror("Could not resync/reset buffers");
    }
  }
#line 108
  return;
}
}
#line 111 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c"
void buffer_loop(audio_output_t *ao___0 , sigset_t *oldsigset ) 
{ 
  int bytes ;
  int outbytes ;
  int my_fd ;
  txfermem *xf ;
  int done ;
  int preload ;
  int cmd ;
  int cmd___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int cmd___1 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 114
  my_fd = buffermem->fd[1];
#line 115
  xf = buffermem;
#line 116
  done = 0;
#line 119
  catchsignal(2, & catch_interrupt___0);
#line 120
  catchsignal(10, & catch_usr1);
#line 121
  sigprocmask(2, (sigset_t const   */* __restrict  */)oldsigset, (sigset_t */* __restrict  */)((void *)0));
#line 123
  xfermem_putcmd(my_fd, (byte )2);
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    cmd = xfermem_block(1, xf);
    }
#line 131
    if (cmd == 5) {
      {
#line 133
      ao___0->rate = xf->rate;
#line 134
      ao___0->channels = xf->channels;
#line 135
      ao___0->format = (*(ao___0->get_formats))(ao___0);
#line 137
      xf->format = ao___0->format;
#line 138
      xfermem_putcmd(my_fd, (byte )5);
      }
    } else
#line 140
    if (cmd == 2) {
      {
#line 143
      xfermem_putcmd(buffermem->fd[1], (byte )2);
      }
#line 144
      goto while_break;
    } else {
      {
#line 148
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c:%i] error: unexpected command %i\n",
              148, cmd);
      }
#line 149
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  preload = (int )(param.preload * (double )xf->size);
#line 157
  if ((size_t )preload > xf->size) {
#line 157
    preload = (int )xf->size;
  }
#line 158
  if (preload < 0) {
#line 158
    preload = 0;
  }
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (intflag___0) {
      {
#line 163
      intflag___0 = 0;
#line 164
      (*(ao___0->flush))(ao___0);
      }
#line 166
      if (! xf->justwait) {
#line 166
        xf->readindex = xf->freeindex;
      } else {
        {
#line 171
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 173
          cmd___0 = xfermem_getcmd(my_fd, 0);
          }
#line 171
          if (! (cmd___0 > 0)) {
#line 171
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 177
      if (xf->wakeme[0]) {
        {
#line 177
        xfermem_putcmd(my_fd, (byte )2);
        }
      }
    }
#line 179
    if (usr1flag) {
#line 181
      usr1flag = 0;
#line 190
      xf->readindex = xf->freeindex;
#line 194
      if (xf->wakeme[0]) {
        {
#line 195
        xfermem_putcmd(my_fd, (byte )2);
        }
      }
      {
#line 196
      ao___0->rate = xf->rate;
#line 197
      ao___0->channels = xf->channels;
#line 198
      ao___0->format = xf->format;
#line 199
      tmp___1 = reset_output(ao___0);
      }
#line 199
      if (tmp___1 < 0) {
        {
#line 200
        tmp = __errno_location();
#line 200
        tmp___0 = strerror(*tmp);
#line 200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c:%i] error: failed to reset audio: %s\n",
                200, tmp___0);
#line 201
        exit(1);
        }
      }
    }
    {
#line 204
    tmp___2 = xfermem_get_usedspace(xf);
#line 204
    bytes = (int )tmp___2;
    }
#line 204
    if (bytes < outburst) {
#line 208
      if ((size_t )preload < xf->size >> 3) {
#line 209
        preload = (int )(xf->size >> 3);
      }
#line 210
      if (preload < outburst) {
#line 211
        preload = outburst;
      }
    }
#line 214
    if (xf->justwait) {
#line 214
      goto _L___0;
    } else
#line 214
    if (bytes < preload) {
      _L___0: /* CIL Label */ 
#line 216
      if (done) {
#line 216
        if (! bytes) {
#line 217
          goto while_break___0;
        }
      }
#line 220
      if (xf->justwait) {
#line 220
        goto _L;
      } else
#line 220
      if (! done) {
        _L: /* CIL Label */ 
        {
#line 223
        tmp___3 = __errno_location();
#line 223
        *tmp___3 = 0;
#line 224
        cmd___1 = xfermem_block(1, xf);
        }
        {
#line 229
        if (cmd___1 == 4) {
#line 229
          goto case_4;
        }
#line 234
        if (cmd___1 == 2) {
#line 234
          goto case_2;
        }
#line 236
        if (cmd___1 == 7) {
#line 236
          goto case_7;
        }
#line 238
        if (cmd___1 == 3) {
#line 238
          goto case_3;
        }
#line 242
        if (cmd___1 == 6) {
#line 242
          goto case_6;
        }
#line 250
        if (cmd___1 == -1) {
#line 250
          goto case_neg_1;
        }
#line 262
        goto switch_default;
        case_4: /* CIL Label */ 
#line 230
        goto __Cont;
        case_2: /* CIL Label */ 
#line 235
        goto switch_break;
        case_7: /* CIL Label */ 
#line 237
        return;
        case_3: /* CIL Label */ 
#line 240
        done = 1;
#line 241
        goto switch_break;
        case_6: /* CIL Label */ ;
#line 244
        if (param.outmode == 1) {
          {
#line 244
          (*(ao___0->flush))(ao___0);
          }
        }
#line 246
        xf->readindex = xf->freeindex;
#line 247
        if (xf->wakeme[0]) {
          {
#line 247
          xfermem_putcmd(my_fd, (byte )2);
          }
        }
#line 248
        goto __Cont;
#line 249
        goto switch_break;
        case_neg_1: /* CIL Label */ 
#line 251
        if (intflag___0) {
#line 254
          goto __Cont;
        } else
#line 251
        if (usr1flag) {
#line 254
          goto __Cont;
        }
        {
#line 256
        tmp___6 = __errno_location();
        }
#line 256
        if (*tmp___6) {
          {
#line 257
          tmp___4 = __errno_location();
#line 257
          tmp___5 = strerror(*tmp___4);
#line 257
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c:%i] error: Yuck! Error in buffer handling... or somewhere unexpected: %s\n",
                  257, tmp___5);
          }
        }
        {
#line 258
        done = 1;
#line 259
        xf->readindex = xf->freeindex;
#line 260
        xfermem_putcmd(xf->fd[1], (byte )3);
        }
#line 261
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 263
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nEh!? Received unknown command 0x%x in buffer process.\n",
                cmd___1);
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 271
    if (xf->justwait) {
#line 272
      goto __Cont;
    } else
#line 271
    if (! bytes) {
#line 272
      goto __Cont;
    }
#line 273
    preload = outburst;
#line 274
    if ((size_t )bytes > xf->size - xf->readindex) {
#line 275
      bytes = (int )(xf->size - xf->readindex);
    }
#line 276
    if (bytes > outburst) {
#line 277
      bytes = outburst;
    }
    {
#line 280
    outbytes = flush_output(ao___0, xf->data + xf->readindex, (size_t )bytes);
    }
#line 282
    if (outbytes < bytes) {
#line 284
      if (outbytes < 0) {
#line 284
        outbytes = 0;
      }
#line 285
      if (! intflag___0) {
#line 285
        if (! usr1flag) {
          {
#line 286
          tmp___7 = __errno_location();
#line 286
          tmp___8 = strerror(*tmp___7);
#line 286
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/buffer.c:%i] error: Ouch ... error while writing audio data: %s\n",
                  286, tmp___8);
#line 296
          done = 1;
#line 297
          xf->readindex = xf->freeindex;
#line 298
          xfermem_putcmd(xf->fd[1], (byte )3);
          }
        }
      }
    }
#line 302
    bytes = outbytes;
#line 304
    xf->readindex = (xf->readindex + (size_t )bytes) % xf->size;
#line 305
    if (xf->wakeme[0]) {
      {
#line 306
      xfermem_putcmd(my_fd, (byte )2);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 308
  return;
}
}
#line 228 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 773 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 79 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.h"
audio_output_t *open_output_module(char const   *names ) ;
#line 80
void close_output_module(audio_output_t *ao___0 ) ;
#line 81
audio_output_t *alloc_audio_output(void) ;
#line 84
char const   *audio_encoding_name(int const   encoding , int const   longer ) ;
#line 90
int open_output(audio_output_t *ao___0 ) ;
#line 91
void close_output(audio_output_t *ao___0 ) ;
#line 20 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static int file_write(struct audio_output_struct *ao___0 , unsigned char *bytes ,
                      int count ) 
{ 
  ssize_t tmp ;

  {
  {
#line 22
  tmp = write(ao___0->fn, (void const   *)bytes, (size_t )count);
  }
#line 22
  return (tmp);
}
}
#line 24 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static int wave_write(struct audio_output_struct *ao___0 , unsigned char *bytes ,
                      int count ) 
{ 
  int tmp ;

  {
  {
#line 26
  tmp = wav_write(bytes, count);
  }
#line 26
  return (tmp);
}
}
#line 28 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static int builtin_get_formats(struct audio_output_struct *ao___0 ) 
{ 


  {
#line 30
  if (param.outmode == 6) {
#line 32
    if (ao___0->rate == 44100L) {
#line 32
      if (ao___0->channels == 2) {
#line 33
        return (208);
      } else {
#line 35
        return (0);
      }
    } else {
#line 35
      return (0);
    }
  } else
#line 37
  if (param.outmode == 5) {
#line 37
    return (213);
  } else
#line 38
  if (param.outmode == 4) {
#line 38
    return (5073);
  } else {
#line 39
    return (14335);
  }
}
}
#line 41 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static int builtin_close(struct audio_output_struct *ao___0 ) 
{ 


  {
  {
#line 45
  if (param.outmode == 4) {
#line 45
    goto case_4;
  }
#line 48
  if (param.outmode == 5) {
#line 48
    goto case_5;
  }
#line 51
  if (param.outmode == 6) {
#line 51
    goto case_6;
  }
#line 43
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 46
  wav_close();
  }
#line 47
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 49
  au_close();
  }
#line 50
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 52
  cdr_close();
  }
#line 53
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 55
  return (0);
}
}
#line 57 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static int builtin_nothingint(struct audio_output_struct *ao___0 ) 
{ 


  {
#line 57
  return (0);
}
}
#line 58 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static void builtin_nothing(struct audio_output_struct *ao___0 ) 
{ 


  {
#line 58
  return;
}
}
#line 60 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
audio_output_t *open_fake_module(void) 
{ 
  audio_output_t *ao___0 ;
  char *__cil_tmp2 ;

  {
  {
#line 62
  ao___0 = (audio_output_t *)((void *)0);
#line 63
  ao___0 = alloc_audio_output();
  }
#line 64
  if ((unsigned long )ao___0 == (unsigned long )((void *)0)) {
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Cannot allocate memory for audio output data.\n",
            66);
    }
#line 67
    return ((audio_output_t *)((void *)0));
  }
#line 69
  ao___0->module = (mpg123_module_t *)((void *)0);
#line 70
  ao___0->open = & builtin_nothingint;
#line 71
  ao___0->flush = & builtin_nothing;
#line 72
  ao___0->get_formats = & builtin_get_formats;
#line 73
  ao___0->write = & wave_write;
#line 74
  ao___0->close = & builtin_close;
#line 75
  ao___0->device = param.filename;
#line 76
  ao___0->is_open = 0;
  {
#line 79
  if (param.outmode == 2) {
#line 79
    goto case_2;
  }
#line 83
  if (param.outmode == 4) {
#line 83
    goto case_4;
  }
#line 86
  if (param.outmode == 6) {
#line 86
    goto case_6;
  }
#line 89
  if (param.outmode == 5) {
#line 89
    goto case_5;
  }
#line 92
  if (param.outmode == 0) {
#line 92
    goto case_0;
  }
#line 77
  goto switch_break;
  case_2: /* CIL Label */ 
#line 80
  ao___0->fn = OutputDescriptor;
#line 81
  ao___0->write = & file_write;
#line 82
  goto switch_break;
  case_4: /* CIL Label */ 
#line 84
  ao___0->open = & wav_open;
#line 85
  goto switch_break;
  case_6: /* CIL Label */ 
#line 87
  ao___0->open = & cdr_open;
#line 88
  goto switch_break;
  case_5: /* CIL Label */ 
#line 90
  ao___0->open = & au_open;
#line 91
  goto switch_break;
  case_0: /* CIL Label */ 
#line 93
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 96
  return (ao___0);
}
}
#line 100 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
audio_output_t *open_output_module(char const   *names ) 
{ 
  mpg123_module_t *module ;
  audio_output_t *ao___0 ;
  int result ;
  char *curname ;
  char *modnames ;
  audio_output_t *tmp ;
  char *name ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 102
  module = (mpg123_module_t *)((void *)0);
#line 103
  ao___0 = (audio_output_t *)((void *)0);
#line 104
  result = 0;
#line 107
  if (param.usebuffer) {
#line 107
    return ((audio_output_t *)((void *)0));
  } else
#line 107
  if ((unsigned long )names == (unsigned long )((void *)0)) {
#line 107
    return ((audio_output_t *)((void *)0));
  }
#line 110
  if (param.outmode != 1) {
    {
#line 110
    tmp = open_fake_module();
    }
#line 110
    return (tmp);
  }
  {
#line 112
  modnames = strdup(names);
  }
#line 113
  if ((unsigned long )modnames == (unsigned long )((void *)0)) {
    {
#line 115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Error allocating memory for module names.\n",
            115);
    }
#line 116
    return ((audio_output_t *)((void *)0));
  }
  {
#line 119
  curname = strtok((char */* __restrict  */)modnames, (char const   */* __restrict  */)",");
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! ((unsigned long )curname != (unsigned long )((void *)0))) {
#line 120
      goto while_break;
    }
    {
#line 122
    name = curname;
#line 123
    curname = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
#line 124
    if (param.verbose > 1) {
      {
#line 124
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trying output module %s.\n",
              name);
      }
    }
    {
#line 126
    module = open_module("output", (char const   *)name);
    }
#line 127
    if ((unsigned long )module == (unsigned long )((void *)0)) {
#line 127
      goto while_continue;
    }
#line 129
    if ((unsigned long )module->init_output == (unsigned long )((void *)0)) {
      {
#line 131
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Module \'%s\' does not support audio output.\n",
              131, name);
#line 132
      close_module(module);
      }
#line 133
      goto while_continue;
    }
    {
#line 136
    ao___0 = alloc_audio_output();
    }
#line 137
    if ((unsigned long )ao___0 == (unsigned long )((void *)0)) {
      {
#line 139
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Failed to allocate audio output structure.\n",
              139);
#line 140
      close_module(module);
      }
#line 141
      goto while_break;
    }
#line 145
    ao___0->device = param.output_device;
#line 146
    ao___0->flags = param.output_flags;
#line 148
    if ((unsigned long )curname == (unsigned long )((void *)0)) {
#line 150
      if (param.verbose > 1) {
        {
#line 151
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: %s is the last output option... showing you any error messages now.\n",
                name);
        }
      }
    } else {
#line 153
      ao___0->auxflags |= 1;
    }
    {
#line 154
    ao___0->is_open = 0;
#line 155
    ao___0->module = module;
#line 156
    result = (*(module->init_output))(ao___0);
    }
#line 157
    if (result == 0) {
      {
#line 159
      result = open_output(ao___0);
#line 160
      close_output(ao___0);
      }
    } else {
      {
#line 162
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Module \'%s\' init failed: %i\n",
              162, name, result);
      }
    }
#line 164
    if (result != 0) {
      {
#line 166
      close_module(module);
#line 167
      free((void *)ao___0);
#line 168
      ao___0 = (audio_output_t *)((void *)0);
      }
    } else {
#line 172
      if (param.verbose > 1) {
        {
#line 172
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Output module \'%s\' chosen.\n",
                name);
        }
      }
#line 174
      ao___0->auxflags &= -2;
#line 175
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  free((void *)modnames);
  }
#line 180
  if ((unsigned long )ao___0 == (unsigned long )((void *)0)) {
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Unable to find a working output module in this list: %s\n",
            180, names);
    }
  }
#line 182
  return (ao___0);
}
}
#line 188 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
void close_output_module(audio_output_t *ao___0 ) 
{ 


  {
#line 190
  if (! ao___0) {
#line 190
    return;
  }
#line 194
  if (ao___0->is_open) {
#line 194
    if ((unsigned long )ao___0->close != (unsigned long )((void *)0)) {
      {
#line 194
      (*(ao___0->close))(ao___0);
      }
    }
  }
#line 197
  if (ao___0->deinit) {
    {
#line 197
    (*(ao___0->deinit))(ao___0);
    }
  }
#line 200
  if (ao___0->module) {
    {
#line 200
    close_module(ao___0->module);
    }
  }
  {
#line 203
  free((void *)ao___0);
  }
#line 204
  return;
}
}
#line 209 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
audio_output_t *alloc_audio_output(void) 
{ 
  audio_output_t *ao___0 ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 211
  tmp = malloc((size_t )sizeof(audio_output_t ));
#line 211
  ao___0 = (audio_output_t *)tmp;
  }
#line 212
  if ((unsigned long )ao___0 == (unsigned long )((void *)0)) {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Failed to allocate memory for audio_output_t.\n",
            212);
    }
  }
#line 215
  ao___0->fn = -1;
#line 216
  ao___0->rate = -1L;
#line 217
  ao___0->gain = param.gain;
#line 218
  ao___0->userptr = (void *)0;
#line 219
  ao___0->device = (char *)((void *)0);
#line 220
  ao___0->channels = -1;
#line 221
  ao___0->format = -1;
#line 222
  ao___0->flags = 0;
#line 223
  ao___0->auxflags = 0;
#line 228
  ao___0->open = (int (*)(struct audio_output_struct * ))((void *)0);
#line 229
  ao___0->get_formats = (int (*)(struct audio_output_struct * ))((void *)0);
#line 230
  ao___0->write = (int (*)(struct audio_output_struct * , unsigned char * , int  ))((void *)0);
#line 231
  ao___0->flush = (void (*)(struct audio_output_struct * ))((void *)0);
#line 232
  ao___0->close = (int (*)(struct audio_output_struct * ))((void *)0);
#line 233
  ao___0->deinit = (int (*)(struct audio_output_struct * ))((void *)0);
#line 235
  return (ao___0);
}
}
#line 259 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static struct enc_desc  const  encdesc[9]  = 
#line 259
  {      {208, "signed 16 bit", "s16 ", (unsigned char const   )3}, 
        {96, "unsigned 16 bit", "u16 ", (unsigned char const   )3}, 
        {1, "unsigned 8 bit", "u8  ", (unsigned char const   )2}, 
        {130, "signed 8 bit", "s8  ", (unsigned char const   )2}, 
        {4, "mu-law (8 bit)", "ulaw ", (unsigned char const   )4}, 
        {8, "a-law (8 bit)", "alaw ", (unsigned char const   )4}, 
        {512, "float (32 bit)", "f32 ", (unsigned char const   )3}, 
        {4480, "signed 32 bit", "s32 ", (unsigned char const   )3}, 
        {8448, "unsigned 32 bit", "u32 ", (unsigned char const   )3}};
#line 273 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
void audio_enclist(char **list ) 
{ 
  size_t length ;
  int i ;
  void *tmp ;
  size_t off ;
  size_t tmp___0 ;

  {
#line 275
  length = (size_t )0;
#line 277
  *list = (char *)((void *)0);
#line 278
  i = 0;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! ((unsigned long )i < sizeof(encdesc) / sizeof(struct enc_desc ))) {
#line 278
      goto while_break;
    }
#line 278
    length += (size_t )encdesc[i].nlen;
#line 278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  length = (size_t )((unsigned long )length + (sizeof(encdesc) / sizeof(struct enc_desc ) - 1UL));
#line 281
  tmp = malloc(length + 1U);
#line 281
  *list = (char *)tmp;
  }
#line 282
  if ((unsigned long )*list != (unsigned long )((void *)0)) {
#line 284
    off = (size_t )0;
#line 285
    *(*list + length) = (char)0;
#line 286
    i = 0;
    {
#line 286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 286
      if (! ((unsigned long )i < sizeof(encdesc) / sizeof(struct enc_desc ))) {
#line 286
        goto while_break___0;
      }
#line 288
      if (i > 0) {
#line 288
        tmp___0 = off;
#line 288
        off ++;
#line 288
        *(*list + tmp___0) = (char )' ';
      }
      {
#line 289
      memcpy((void */* __restrict  */)(*list + off), (void const   */* __restrict  */)encdesc[i].name,
             (size_t )encdesc[i].nlen);
#line 290
      off += (size_t )encdesc[i].nlen;
#line 286
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 293
  return;
}
}
#line 296 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
char const   *audio_encoding_name(int const   encoding , int const   longer ) 
{ 
  char const   *name ;
  char const   *tmp ;
  int i ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 298
  if (longer) {
#line 298
    tmp = "unknown";
  } else {
#line 298
    tmp = "???";
  }
#line 298
  name = tmp;
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! ((unsigned long )i < sizeof(encdesc) / sizeof(struct enc_desc ))) {
#line 300
      goto while_break;
    }
#line 301
    if (encdesc[i].code == encoding) {
#line 302
      if (longer) {
#line 302
        name = (char const   *)encdesc[i].longname;
      } else {
#line 302
        name = (char const   *)encdesc[i].name;
      }
    }
#line 300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return (name);
}
}
#line 307 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static void capline(mpg123_handle *mh___0 , long rate ) 
{ 
  int enci ;
  int const   *encs ;
  size_t num_encs ;
  long tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 312
  mpg123_encodings(& encs, & num_encs);
  }
#line 313
  if (param.pitch == (double )0) {
#line 313
    tmp = rate;
  } else {
#line 313
    tmp = (long )((param.pitch + 1.0) * (double )rate);
  }
  {
#line 313
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %5ld |",
          tmp);
#line 314
  enci = 0;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! ((size_t )enci < num_encs)) {
#line 314
      goto while_break;
    }
    {
#line 316
    tmp___0 = (int )mpg123_format_support(mh___0, rate, (int )*(encs + enci));
    }
    {
#line 318
    if (tmp___0 == 1) {
#line 318
      goto case_1;
    }
#line 319
    if (tmp___0 == 2) {
#line 319
      goto case_2;
    }
#line 320
    if (tmp___0 == 3) {
#line 320
      goto case_3;
    }
#line 321
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 318
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   M   |");
    }
#line 318
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   S   |");
    }
#line 319
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  M/S  |");
    }
#line 320
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       |");
    }
    switch_break: /* CIL Label */ ;
    }
#line 314
    enci ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 325
  return;
}
}
#line 327 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
void print_capabilities(audio_output_t *ao___0 , mpg123_handle *mh___0 ) 
{ 
  int r ;
  int e ;
  long const   *rates ;
  size_t num_rates ;
  int const   *encs ;
  size_t num_encs ;
  char const   *name ;
  char const   *dev ;
  char const   *tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 334
  name = "<buffer>";
#line 335
  dev = "<none>";
#line 336
  if (! param.usebuffer) {
#line 338
    if (ao___0->module) {
#line 338
      name = (ao___0->module)->name;
    } else {
#line 338
      name = "file/raw/test";
    }
#line 339
    if ((unsigned long )ao___0->device != (unsigned long )((void *)0)) {
#line 339
      dev = (char const   *)ao___0->device;
    }
  }
  {
#line 341
  mpg123_rates(& rates, & num_rates);
#line 342
  mpg123_encodings(& encs, & num_encs);
#line 343
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAudio driver: %s\nAudio device: %s\nAudio capabilities:\n(matrix of [S]tereo or [M]ono support for sample format and rate in Hz)\n       |",
          name, dev);
#line 344
  e = 0;
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((size_t )e < num_encs)) {
#line 344
      goto while_break;
    }
    {
#line 344
    tmp = audio_encoding_name(*(encs + e), (int const   )0);
#line 344
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %5s |",
            tmp);
#line 344
    e ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 346
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n ------|");
#line 347
  e = 0;
  }
  {
#line 347
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 347
    if (! ((size_t )e < num_encs)) {
#line 347
      goto while_break___0;
    }
    {
#line 347
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-------|");
#line 347
    e ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 349
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 350
  r = 0;
  }
  {
#line 350
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 350
    if (! ((size_t )r < num_rates)) {
#line 350
      goto while_break___1;
    }
    {
#line 350
    capline(mh___0, (long )*(rates + r));
#line 350
    r ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 352
  if (param.force_rate) {
    {
#line 352
    capline(mh___0, param.force_rate);
    }
  }
  {
#line 354
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 355
  return;
}
}
#line 359 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
void audio_capabilities(audio_output_t *ao___0 , mpg123_handle *mh___0 ) 
{ 
  int force_fmt ;
  int fmts___0 ;
  size_t ri ;
  long rate ;
  long decode_rate ;
  int channels ;
  long const   *rates ;
  size_t num_rates ;
  size_t rlimit ;
  int i ;
  int tmp ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 361
  force_fmt = 0;
#line 370
  mpg123_rates(& rates, & num_rates);
#line 371
  mpg123_format_none(mh___0);
  }
#line 372
  if ((unsigned long )param.force_encoding != (unsigned long )((void *)0)) {
#line 375
    if (! param.quiet) {
      {
#line 375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: forcing output encoding %s\n",
              param.force_encoding);
      }
    }
#line 377
    i = 0;
    {
#line 377
    while (1) {
      while_continue: /* CIL Label */ ;
#line 377
      if (! ((unsigned long )i < sizeof(encdesc) / sizeof(struct enc_desc ))) {
#line 377
        goto while_break;
      }
      {
#line 378
      tmp = strncasecmp((char const   *)encdesc[i].name, (char const   *)param.force_encoding,
                        (size_t )encdesc[i].nlen);
      }
#line 378
      if (! tmp) {
#line 380
        force_fmt = (int )encdesc[i].code;
#line 381
        goto while_break;
      }
#line 377
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 384
    if ((unsigned long )i == sizeof(encdesc) / sizeof(struct enc_desc )) {
      {
#line 386
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Failed to find an encoding to match requested \"%s\"!\n\n",
              386, param.force_encoding);
      }
#line 387
      return;
    } else
#line 389
    if (param.verbose > 2) {
      {
#line 389
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: forcing encoding code 0x%x\n",
              force_fmt);
      }
    }
  }
#line 391
  if (param.force_rate > 0L) {
#line 391
    rlimit = num_rates + 1U;
  } else {
#line 391
    rlimit = num_rates;
  }
#line 392
  channels = 1;
  {
#line 392
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 392
    if (! (channels <= 2)) {
#line 392
      goto while_break___0;
    }
#line 393
    ri = (size_t )0;
    {
#line 393
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 393
      if (! (ri < rlimit)) {
#line 393
        goto while_break___1;
      }
#line 395
      if (ri < num_rates) {
#line 395
        decode_rate = (long )*(rates + ri);
      } else {
#line 395
        decode_rate = param.force_rate;
      }
#line 396
      if (param.pitch == (double )0) {
#line 396
        rate = decode_rate;
      } else {
#line 396
        rate = (long )((param.pitch + 1.0) * (double )decode_rate);
      }
#line 397
      if (param.verbose > 2) {
        {
#line 397
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: checking support for %liHz/%ich.\n",
                rate, channels);
        }
      }
#line 399
      if (param.usebuffer) {
        {
#line 401
        buffermem->rate = rate;
#line 402
        buffermem->channels = channels;
#line 403
        buffermem->format = 0;
#line 405
        xfermem_putcmd(buffermem->fd[0], (byte )5);
#line 406
        xfermem_getcmd(buffermem->fd[0], 1);
#line 407
        fmts___0 = buffermem->format;
        }
      } else {
        {
#line 412
        ao___0->rate = rate;
#line 413
        ao___0->channels = channels;
#line 414
        fmts___0 = (*(ao___0->get_formats))(ao___0);
        }
      }
#line 416
      if (param.verbose > 2) {
        {
#line 416
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: result 0x%x\n",
                fmts___0);
        }
      }
#line 417
      if (force_fmt) {
#line 419
        if ((fmts___0 & force_fmt) == force_fmt) {
#line 419
          fmts___0 = force_fmt;
        } else {
#line 420
          fmts___0 = 0;
        }
#line 422
        if (param.verbose > 2) {
          {
#line 422
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: after forcing 0x%x\n",
                  fmts___0);
          }
        }
      }
#line 425
      if (! (fmts___0 < 0)) {
        {
#line 426
        mpg123_format(mh___0, decode_rate, channels, fmts___0);
        }
      }
#line 393
      ri ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 392
    channels ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 431
  if (param.usebuffer) {
    {
#line 433
    xfermem_putcmd(buffermem->fd[0], (byte )2);
#line 434
    xfermem_getcmd(buffermem->fd[0], 1);
    }
  }
#line 438
  if (param.verbose > 1) {
    {
#line 438
    print_capabilities(ao___0, mh___0);
    }
  }
#line 439
  return;
}
}
#line 443 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static void catch_child(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 445
    tmp = waitpid(-1, (int *)((void *)0), 1);
    }
#line 445
    if (! (tmp > 0)) {
#line 445
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return;
}
}
#line 455 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
static int init_done  =    0;
#line 453 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
int init_output(audio_output_t **ao___0 ) 
{ 
  unsigned int bufferbytes ;
  sigset_t newsigset ;
  sigset_t oldsigset ;
  audio_output_t *bao ;
  int tmp ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 457
  if (init_done) {
#line 457
    return (1);
  }
#line 458
  init_done = 1;
#line 461
  if (param.usebuffer) {
#line 465
    bufferbytes = (unsigned int )(param.usebuffer * 1024L);
#line 466
    if (bufferbytes < bufferblock) {
#line 468
      bufferbytes = 2U * bufferblock;
#line 469
      if (! param.quiet) {
        {
#line 469
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Note: raising buffer to minimal size %liKiB\n",
                (unsigned long )bufferbytes >> 10);
        }
      }
    }
    {
#line 471
    bufferbytes -= bufferbytes % bufferblock;
#line 473
    xfermem_init(& buffermem, bufferbytes, (size_t )0, (size_t )0);
#line 474
    sigemptyset(& newsigset);
#line 475
    sigaddset(& newsigset, 10);
#line 476
    sigprocmask(0, (sigset_t const   */* __restrict  */)(& newsigset), (sigset_t */* __restrict  */)(& oldsigset));
#line 478
    catchsignal(17, & catch_child);
#line 480
    buffer_pid = fork();
    }
    {
#line 482
    if (buffer_pid == -1) {
#line 482
      goto case_neg_1;
    }
#line 485
    if (buffer_pid == 0) {
#line 485
      goto case_0;
    }
#line 511
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 483
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: cannot fork!\n",
            483);
    }
#line 484
    return (-1);
    case_0: /* CIL Label */ 
    {
#line 488
    bao = (audio_output_t *)((void *)0);
#line 489
    param.usebuffer = 0L;
#line 491
    bao = open_output_module((char const   *)param.output_module);
    }
#line 492
    if (! bao) {
      {
#line 494
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Failed to open audio output module.\n",
              494);
#line 495
      exit(1);
      }
    }
    {
#line 497
    tmp = open_output(bao);
    }
#line 497
    if (tmp < 0) {
      {
#line 499
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Unable to open audio output.\n",
              499);
#line 500
      close_output_module(bao);
#line 501
      exit(2);
      }
    }
    {
#line 503
    xfermem_init_reader(buffermem);
#line 504
    buffer_loop(bao, & oldsigset);
#line 505
    xfermem_init_writer(buffermem);
#line 506
    xfermem_done(buffermem);
#line 507
    close_output(bao);
#line 508
    close_output_module(bao);
#line 509
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 512
    xfermem_init_writer(buffermem);
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 522
  if (! param.usebuffer) {
    {
#line 524
    *ao___0 = open_output_module((char const   *)param.output_module);
    }
#line 525
    if (! *ao___0) {
      {
#line 527
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Failed to open audio output module\n",
              527);
      }
#line 528
      return (-1);
    }
  } else {
#line 531
    *ao___0 = (audio_output_t *)((void *)0);
  }
#line 533
  if (param.usebuffer) {
    {
#line 535
    tmp___0 = xfermem_getcmd(buffermem->fd[0], 1);
#line 535
    res = tmp___0;
    }
#line 536
    if (res < 0) {
      {
#line 538
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Buffer process didn\'t initialize!\n",
              538);
      }
#line 539
      return (-1);
    }
  }
  {
#line 544
  tmp___1 = open_output(*ao___0);
  }
#line 544
  if (tmp___1 < 0) {
#line 544
    return (-1);
  }
#line 546
  return (0);
}
}
#line 549 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
void exit_output(audio_output_t *ao___0 , int rude ) 
{ 


  {
#line 553
  if (param.usebuffer) {
#line 556
    if (param.usebuffer) {
      {
#line 556
      real_buffer_stop();
      }
    }
#line 557
    if (param.usebuffer) {
      {
#line 557
      real_buffer_end(rude);
      }
    }
    {
#line 558
    xfermem_init_reader(buffermem);
#line 559
    waitpid(buffer_pid, (int *)((void *)0), 0);
#line 560
    xfermem_done(buffermem);
    }
  }
  {
#line 564
  close_output(ao___0);
#line 565
  close_output_module(ao___0);
  }
#line 566
  return;
}
}
#line 568 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
void output_pause(audio_output_t *ao___0 ) 
{ 


  {
#line 570
  if (param.usebuffer) {
#line 570
    if (param.usebuffer) {
      {
#line 570
      real_buffer_stop();
      }
    }
  } else {
    {
#line 571
    (*(ao___0->flush))(ao___0);
    }
  }
#line 572
  return;
}
}
#line 574 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
void output_unpause(audio_output_t *ao___0 ) 
{ 


  {
#line 576
  if (param.usebuffer) {
#line 576
    if (param.usebuffer) {
      {
#line 576
      real_buffer_start();
      }
    }
  }
#line 577
  return;
}
}
#line 579 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
int flush_output(audio_output_t *ao___0 , unsigned char *bytes , size_t count ) 
{ 
  int tmp ;
  int sum ;
  int written ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 581
  if (count) {
#line 585
    if (param.usebuffer) {
      {
#line 585
      tmp = xfermem_write(buffermem, bytes, count);
      }
#line 585
      if (tmp) {
#line 585
        return (-1);
      }
    } else
#line 588
    if (param.outmode != 0) {
#line 590
      sum = 0;
      {
#line 592
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 594
        written = (*(ao___0->write))(ao___0, bytes, (int )count);
        }
#line 595
        if (written >= 0) {
#line 595
          sum += written;
#line 595
          count -= (size_t )written;
        } else {
          {
#line 596
          tmp___0 = __errno_location();
#line 596
          tmp___1 = strerror(*tmp___0);
#line 596
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Error in writing audio (%s?)!\n",
                  596, tmp___1);
          }
        }
#line 592
        if (count > 0U) {
#line 592
          if (! (written >= 0)) {
#line 592
            goto while_break;
          }
        } else {
#line 592
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 598
      return (sum);
    }
  }
#line 601
  return ((int )count);
}
}
#line 604 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
int open_output(audio_output_t *ao___0 ) 
{ 
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 606
  if (param.usebuffer) {
#line 606
    return (0);
  }
#line 608
  if ((unsigned long )ao___0 == (unsigned long )((void *)0)) {
    {
#line 610
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: ao should not be NULL here!\n",
            610);
#line 611
    exit(110);
    }
  }
  {
#line 620
  if (param.outmode == 2) {
#line 620
    goto case_2;
  }
#line 620
  if (param.outmode == 6) {
#line 620
    goto case_2;
  }
#line 620
  if (param.outmode == 5) {
#line 620
    goto case_2;
  }
#line 620
  if (param.outmode == 4) {
#line 620
    goto case_2;
  }
#line 620
  if (param.outmode == 1) {
#line 620
    goto case_2;
  }
#line 630
  if (param.outmode == 0) {
#line 630
    goto case_0;
  }
#line 614
  goto switch_break;
  case_2: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 622
  tmp___0 = (*(ao___0->open))(ao___0);
  }
#line 622
  if (tmp___0 < 0) {
#line 622
    ao___0->is_open = 0;
  } else {
#line 622
    ao___0->is_open = 1;
  }
#line 623
  if (! ao___0->is_open) {
#line 625
    if (! (ao___0->auxflags & 1)) {
      {
#line 625
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: failed to open audio device\n",
              625);
      }
    }
#line 626
    return (-1);
  } else {
#line 628
    return (0);
  }
#line 629
  goto switch_break;
  case_0: /* CIL Label */ ;
#line 632
  return (0);
#line 633
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 636
  return (-1);
}
}
#line 640 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
void close_output(audio_output_t *ao___0 ) 
{ 


  {
#line 642
  if (param.usebuffer) {
#line 642
    return;
  }
  {
#line 650
  if (param.outmode == 6) {
#line 650
    goto case_6;
  }
#line 650
  if (param.outmode == 5) {
#line 650
    goto case_6;
  }
#line 650
  if (param.outmode == 4) {
#line 650
    goto case_6;
  }
#line 650
  if (param.outmode == 1) {
#line 650
    goto case_6;
  }
#line 645
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 652
  if (ao___0->is_open) {
#line 654
    ao___0->is_open = 0;
#line 655
    if ((unsigned long )ao___0->close != (unsigned long )((void *)0)) {
      {
#line 655
      (*(ao___0->close))(ao___0);
      }
    }
  }
#line 657
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 659
  return;
}
}
#line 662 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
int reset_output(audio_output_t *ao___0 ) 
{ 
  int tmp ;

  {
#line 664
  if (! param.usebuffer) {
    {
#line 666
    close_output(ao___0);
#line 667
    tmp = open_output(ao___0);
    }
#line 667
    return (tmp);
  } else {
#line 669
    return (0);
  }
}
}
#line 672 "/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c"
int set_pitch(mpg123_handle *fr , audio_output_t *ao___0 , double new_pitch ) 
{ 
  int ret ;
  double old_pitch ;
  long rate ;
  int channels ;
  int format ;
  int smode ;
  int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 674
  ret = 1;
#line 675
  old_pitch = param.pitch;
#line 678
  smode = 0;
#line 680
  if (param.usebuffer) {
    {
#line 682
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: No runtime pitch change with output buffer, sorry.\n",
            682);
    }
#line 683
    return (0);
  }
#line 686
  param.pitch = new_pitch;
#line 687
  if (param.pitch < - 0.99) {
#line 687
    param.pitch = - 0.99;
  }
  {
#line 690
  mpg123_getformat(fr, & rate, & channels, & format);
  }
#line 691
  if (channels == 1) {
#line 691
    smode = 1;
  }
#line 692
  if (channels == 2) {
#line 692
    smode = 2;
  }
  {
#line 694
  output_pause(ao___0);
#line 696
  audio_capabilities(ao___0, fr);
#line 697
  tmp = (int )mpg123_format_support(fr, rate, format);
  }
#line 697
  if (! (tmp & smode)) {
    {
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[/home/wslee/benchmarks/sound/mpg123-1.12.1/src/audio.c:%i] error: Reached a hardware limit there with pitch!\n",
            702);
#line 703
    param.pitch = old_pitch;
#line 704
    audio_capabilities(ao___0, fr);
#line 705
    ret = 0;
    }
  }
#line 707
  ao___0->format = format;
#line 708
  ao___0->channels = channels;
#line 709
  if (param.pitch == (double )0) {
#line 709
    ao___0->rate = rate;
  } else {
#line 709
    ao___0->rate = (long )((param.pitch + 1.0) * (double )rate);
  }
  {
#line 710
  reset_output(ao___0);
#line 711
  output_unpause(ao___0);
  }
#line 712
  return (ret);
}
}
