/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 48 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef unsigned char GifPixelType;
#line 50 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef unsigned char GifByteType;
#line 56 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef int GifWord;
#line 68 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
struct GifColorType {
   GifByteType Red ;
   GifByteType Green ;
   GifByteType Blue ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef struct GifColorType GifColorType;
#line 72 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
struct ColorMapObject {
   int ColorCount ;
   int BitsPerPixel ;
   GifColorType *Colors ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef struct ColorMapObject ColorMapObject;
#line 78 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
struct GifImageDesc {
   GifWord Left ;
   GifWord Top ;
   GifWord Width ;
   GifWord Height ;
   GifWord Interlace ;
   ColorMapObject *ColorMap ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef struct GifImageDesc GifImageDesc;
#line 84
struct SavedImage;
#line 84 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
struct GifFileType {
   GifWord SWidth ;
   GifWord SHeight ;
   GifWord SColorResolution ;
   GifWord SBackGroundColor ;
   ColorMapObject *SColorMap ;
   int ImageCount ;
   GifImageDesc Image ;
   struct SavedImage *SavedImages ;
   void *UserData ;
   void *Private ;
};
#line 84 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef struct GifFileType GifFileType;
#line 280 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
struct __anonstruct_ExtensionBlock_27 {
   int ByteCount ;
   char *Bytes ;
   int Function ;
};
#line 280 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef struct __anonstruct_ExtensionBlock_27 ExtensionBlock;
#line 287 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
struct SavedImage {
   GifImageDesc ImageDesc ;
   unsigned char *RasterBits ;
   int Function ;
   int ExtensionBlockCount ;
   ExtensionBlock *ExtensionBlocks ;
};
#line 287 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef struct SavedImage SavedImage;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef unsigned int GifPrefixType;
#line 50 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.h"
struct GifHashTableType {
   u_int32_t HTable[8192] ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.h"
typedef struct GifHashTableType GifHashTableType;
#line 33 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib_private.h"
struct GifFilePrivateType {
   GifWord FileState ;
   GifWord FileHandle ;
   GifWord BitsPerPixel ;
   GifWord ClearCode ;
   GifWord EOFCode ;
   GifWord RunningCode ;
   GifWord RunningBits ;
   GifWord MaxCode1 ;
   GifWord LastCode ;
   GifWord CrntCode ;
   GifWord StackPtr ;
   GifWord CrntShiftState ;
   unsigned long CrntShiftDWord ;
   unsigned long PixelCount ;
   FILE *File ;
   int (*Read)(GifFileType * , GifByteType * , int  ) ;
   int (*Write)(GifFileType * , GifByteType const   * , int  ) ;
   GifByteType Buf[256] ;
   GifByteType Stack[4095] ;
   GifByteType Suffix[4096] ;
   GifPrefixType Prefix[4096] ;
   GifHashTableType *HashTable ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib_private.h"
typedef struct GifFilePrivateType GifFilePrivateType;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 47 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
struct QuantizedColorType {
   GifByteType RGB[3] ;
   GifByteType NewColorIndex ;
   long Count ;
   struct QuantizedColorType *Pnext ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
typedef struct QuantizedColorType QuantizedColorType;
#line 54 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
struct NewColorMapType {
   GifByteType RGBMin[3] ;
   GifByteType RGBWidth[3] ;
   unsigned int NumEntries ;
   unsigned long Count ;
   QuantizedColorType *QuantizedColors ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
typedef struct NewColorMapType NewColorMapType;
#line 96 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
enum __anonenum_GifRecordType_28 {
    UNDEFINED_RECORD_TYPE = 0,
    SCREEN_DESC_RECORD_TYPE = 1,
    IMAGE_DESC_RECORD_TYPE = 2,
    EXTENSION_RECORD_TYPE = 3,
    TERMINATE_RECORD_TYPE = 4
} ;
#line 96 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
typedef enum __anonenum_GifRecordType_28 GifRecordType;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_17 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_17 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_18 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_18 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_19 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_19 Screen;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_22 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_22 XWindowAttributes;
#line 372 "/usr/include/X11/Xlib.h"
struct funcs {
   struct _XImage *(*create_image)(struct _XDisplay * , Visual * , unsigned int  ,
                                   int  , int  , char * , unsigned int  , unsigned int  ,
                                   int  , int  ) ;
   int (*destroy_image)(struct _XImage * ) ;
   unsigned long (*get_pixel)(struct _XImage * , int  , int  ) ;
   int (*put_pixel)(struct _XImage * , int  , int  , unsigned long  ) ;
   struct _XImage *(*sub_image)(struct _XImage * , int  , int  , unsigned int  , unsigned int  ) ;
   int (*add_pixel)(struct _XImage * , long  ) ;
};
#line 372 "/usr/include/X11/Xlib.h"
struct _XImage {
   int width ;
   int height ;
   int xoffset ;
   int format ;
   char *data ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_bit_order ;
   int bitmap_pad ;
   int depth ;
   int bytes_per_line ;
   int bits_per_pixel ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   XPointer obdata ;
   struct funcs f ;
};
#line 372 "/usr/include/X11/Xlib.h"
typedef struct _XImage XImage;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_26 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_26 XColor;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 422 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
union TmpArray {
   int *IntArray[100] ;
   long *LngArray[100] ;
   float *FltArray[100] ;
   double *DblArray[100] ;
   char *ChrArray[100] ;
};
#line 49 "../lib/gif_lib.h"
typedef unsigned char *GifRowType;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 47 "../lib/gif_lib.h"
typedef int GifBooleanType;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_20 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_20 ScreenFormat;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_21 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_21 XSetWindowAttributes;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_35 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_35 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_36 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_36 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_37 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_37 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_38 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_38 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_39 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_39 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_40 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_40 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_41 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_41 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_42 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_42 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_43 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_43 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_44 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_44 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_45 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_45 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_46 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_46 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_47 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_47 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_48 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_48 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_49 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_49 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_50 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_50 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_51 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_51 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_52 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_53 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_54 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_55 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_56 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_57 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_58 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_59 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_60 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_61 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_62 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_64 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_64 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_63 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_65 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_66 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_66 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_67 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_67 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_68 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_68 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_69 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_69 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_95 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_94 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_95 min_aspect ;
   struct __anonstruct_min_aspect_95 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_94 XSizeHints;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 267 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
ColorMapObject *MakeMapObject(int ColorCount , GifColorType const   *ColorMap___3 ) ;
#line 269
void FreeMapObject(ColorMapObject *Object ) ;
#line 270
ColorMapObject *UnionColorMap(ColorMapObject const   *ColorIn1 , ColorMapObject const   *ColorIn2 ,
                              GifPixelType *ColorTransIn2 ) ;
#line 273
int BitSize(int n ) ;
#line 295
void ApplyTranslation(SavedImage *Image , GifPixelType *Translation___0 ) ;
#line 296
void MakeExtension(SavedImage *New , int Function ) ;
#line 297
int AddExtensionBlock(SavedImage *New , int Len , unsigned char *ExtData ) ;
#line 299
void FreeExtension(SavedImage *Image ) ;
#line 300
SavedImage *MakeSavedImage(GifFileType *GifFile , SavedImage const   *CopyFrom ) ;
#line 302
void FreeSavedImages(GifFileType *GifFile ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
int BitSize(int n ) 
{ 
  register int i ;

  {
#line 34
  i = 1;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i <= 8)) {
#line 34
      goto while_break;
    }
#line 35
    if (1 << i >= n) {
#line 36
      goto while_break;
    }
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return (i);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
ColorMapObject *MakeMapObject(int ColorCount , GifColorType const   *ColorMap___3 ) 
{ 
  ColorMapObject *Object ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 56
  tmp = BitSize(ColorCount);
  }
#line 56
  if (ColorCount != 1 << tmp) {
#line 57
    return ((ColorMapObject *)((void *)0));
  }
  {
#line 60
  tmp___0 = malloc(sizeof(ColorMapObject ));
#line 60
  Object = (ColorMapObject *)tmp___0;
  }
#line 61
  if ((unsigned long )Object == (unsigned long )((ColorMapObject *)((void *)0))) {
#line 62
    return ((ColorMapObject *)((void *)0));
  }
  {
#line 65
  tmp___1 = calloc((size_t )ColorCount, sizeof(GifColorType ));
#line 65
  Object->Colors = (GifColorType *)tmp___1;
  }
#line 66
  if ((unsigned long )Object->Colors == (unsigned long )((GifColorType *)((void *)0))) {
#line 67
    return ((ColorMapObject *)((void *)0));
  }
  {
#line 70
  Object->ColorCount = ColorCount;
#line 71
  Object->BitsPerPixel = BitSize(ColorCount);
  }
#line 73
  if (ColorMap___3) {
    {
#line 74
    memcpy((void */* __restrict  */)((char *)Object->Colors), (void const   */* __restrict  */)((char *)ColorMap___3),
           (unsigned long )ColorCount * sizeof(GifColorType ));
    }
  }
#line 78
  return (Object);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
void FreeMapObject(ColorMapObject *Object ) 
{ 


  {
#line 87
  if ((unsigned long )Object != (unsigned long )((void *)0)) {
    {
#line 88
    free((void *)Object->Colors);
#line 89
    free((void *)Object);
    }
  }
#line 97
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
ColorMapObject *UnionColorMap(ColorMapObject const   *ColorIn1 , ColorMapObject const   *ColorIn2 ,
                              GifPixelType *ColorTransIn2 ) 
{ 
  int i ;
  int j ;
  int CrntSlot ;
  int RoundUpTo ;
  int NewBitSize ;
  ColorMapObject *ColorUnion ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  register GifColorType *Map ;
  GifByteType tmp___2 ;
  GifByteType tmp___3 ;
  void *tmp___4 ;

  {
#line 138
  if (ColorIn1->ColorCount > ColorIn2->ColorCount) {
#line 138
    tmp = ColorIn1->ColorCount;
  } else {
#line 138
    tmp = ColorIn2->ColorCount;
  }
  {
#line 138
  ColorUnion = MakeMapObject((int )(tmp * 2), (GifColorType const   *)((void *)0));
  }
#line 141
  if ((unsigned long )ColorUnion == (unsigned long )((void *)0)) {
#line 142
    return ((ColorMapObject *)((void *)0));
  }
#line 147
  i = 0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (i < (int )ColorIn1->ColorCount)) {
#line 147
      goto while_break;
    }
#line 148
    *(ColorUnion->Colors + i) = *(ColorIn1->Colors + i);
#line 147
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  CrntSlot = (int )ColorIn1->ColorCount;
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 158
    if ((int )(ColorIn1->Colors + (CrntSlot - 1))->Red == 0) {
#line 158
      if ((int )(ColorIn1->Colors + (CrntSlot - 1))->Green == 0) {
#line 158
        if (! ((int )(ColorIn1->Colors + (CrntSlot - 1))->Blue == 0)) {
#line 158
          goto while_break___0;
        }
      } else {
#line 158
        goto while_break___0;
      }
    } else {
#line 158
      goto while_break___0;
    }
#line 161
    CrntSlot --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 164
    if (i < (int )ColorIn2->ColorCount) {
#line 164
      if (! (CrntSlot <= 256)) {
#line 164
        goto while_break___1;
      }
    } else {
#line 164
      goto while_break___1;
    }
#line 170
    j = 0;
    {
#line 170
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 170
      if (! (j < (int )ColorIn1->ColorCount)) {
#line 170
        goto while_break___2;
      }
      {
#line 171
      tmp___0 = memcmp((void const   *)(ColorIn1->Colors + j), (void const   *)(ColorIn2->Colors + i),
                       sizeof(GifColorType ));
      }
#line 171
      if (tmp___0 == 0) {
#line 173
        goto while_break___2;
      }
#line 170
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 175
    if (j < (int )ColorIn1->ColorCount) {
#line 176
      *(ColorTransIn2 + i) = (GifPixelType )j;
    } else {
#line 179
      *(ColorUnion->Colors + CrntSlot) = *(ColorIn2->Colors + i);
#line 180
      tmp___1 = CrntSlot;
#line 180
      CrntSlot ++;
#line 180
      *(ColorTransIn2 + i) = (GifPixelType )tmp___1;
    }
#line 164
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 184
  if (CrntSlot > 256) {
    {
#line 185
    FreeMapObject(ColorUnion);
    }
#line 186
    return ((ColorMapObject *)((void *)0));
  }
  {
#line 189
  NewBitSize = BitSize(CrntSlot);
#line 190
  RoundUpTo = 1 << NewBitSize;
  }
#line 192
  if (RoundUpTo != ColorUnion->ColorCount) {
#line 193
    Map = ColorUnion->Colors;
#line 200
    j = CrntSlot;
    {
#line 200
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 200
      if (! (j < RoundUpTo)) {
#line 200
        goto while_break___3;
      }
#line 201
      tmp___3 = (GifByteType )0;
#line 201
      (Map + j)->Blue = tmp___3;
#line 201
      tmp___2 = tmp___3;
#line 201
      (Map + j)->Green = tmp___2;
#line 201
      (Map + j)->Red = tmp___2;
#line 200
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 204
    if (RoundUpTo < ColorUnion->ColorCount) {
      {
#line 205
      tmp___4 = realloc((void *)Map, sizeof(GifColorType ) * (unsigned long )RoundUpTo);
#line 205
      ColorUnion->Colors = (GifColorType *)tmp___4;
      }
    }
  }
#line 209
  ColorUnion->ColorCount = RoundUpTo;
#line 210
  ColorUnion->BitsPerPixel = NewBitSize;
#line 212
  return (ColorUnion);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
void ApplyTranslation(SavedImage *Image , GifPixelType *Translation___0 ) 
{ 
  register int i ;
  register int RasterSize ;

  {
#line 223
  RasterSize = Image->ImageDesc.Height * Image->ImageDesc.Width;
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < RasterSize)) {
#line 225
      goto while_break;
    }
#line 226
    *(Image->RasterBits + i) = *(Translation___0 + *(Image->RasterBits + i));
#line 225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
void MakeExtension(SavedImage *New , int Function ) 
{ 


  {
#line 237
  New->Function = Function;
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
int AddExtensionBlock(SavedImage *New , int Len , unsigned char *ExtData ) 
{ 
  ExtensionBlock *ep ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 257
  if ((unsigned long )New->ExtensionBlocks == (unsigned long )((void *)0)) {
    {
#line 258
    tmp = malloc(sizeof(ExtensionBlock ));
#line 258
    New->ExtensionBlocks = (ExtensionBlock *)tmp;
    }
  } else {
    {
#line 260
    tmp___0 = realloc((void *)New->ExtensionBlocks, sizeof(ExtensionBlock ) * (unsigned long )(New->ExtensionBlockCount + 1));
#line 260
    New->ExtensionBlocks = (ExtensionBlock *)tmp___0;
    }
  }
#line 264
  if ((unsigned long )New->ExtensionBlocks == (unsigned long )((void *)0)) {
#line 265
    return (0);
  }
  {
#line 267
  tmp___1 = New->ExtensionBlockCount;
#line 267
  (New->ExtensionBlockCount) ++;
#line 267
  ep = New->ExtensionBlocks + tmp___1;
#line 269
  ep->ByteCount = Len;
#line 270
  tmp___2 = malloc((size_t )ep->ByteCount);
#line 270
  ep->Bytes = (char *)tmp___2;
  }
#line 271
  if ((unsigned long )ep->Bytes == (unsigned long )((void *)0)) {
#line 272
    return (0);
  }
#line 274
  if (ExtData) {
    {
#line 275
    memcpy((void */* __restrict  */)ep->Bytes, (void const   */* __restrict  */)ExtData,
           (size_t )Len);
#line 276
    ep->Function = New->Function;
    }
  }
#line 279
  return (1);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
void FreeExtension(SavedImage *Image ) 
{ 
  ExtensionBlock *ep ;

  {
#line 287
  if ((unsigned long )Image == (unsigned long )((void *)0)) {
#line 288
    return;
  } else
#line 287
  if ((unsigned long )Image->ExtensionBlocks == (unsigned long )((void *)0)) {
#line 288
    return;
  }
#line 290
  ep = Image->ExtensionBlocks;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! ((unsigned long )ep < (unsigned long )(Image->ExtensionBlocks + Image->ExtensionBlockCount))) {
#line 290
      goto while_break;
    }
    {
#line 292
    free((void *)ep->Bytes);
#line 290
    ep ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 293
  free((void *)((char *)Image->ExtensionBlocks));
#line 294
  Image->ExtensionBlocks = (ExtensionBlock *)((void *)0);
  }
#line 295
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
void FreeLastSavedImage(GifFileType *GifFile ) 
{ 
  SavedImage *sp ;

  {
#line 309
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
#line 310
    return;
  } else
#line 309
  if ((unsigned long )GifFile->SavedImages == (unsigned long )((void *)0)) {
#line 310
    return;
  }
#line 313
  (GifFile->ImageCount) --;
#line 314
  sp = GifFile->SavedImages + GifFile->ImageCount;
#line 317
  if (sp->ImageDesc.ColorMap) {
    {
#line 318
    FreeMapObject(sp->ImageDesc.ColorMap);
#line 319
    sp->ImageDesc.ColorMap = (ColorMapObject *)((void *)0);
    }
  }
#line 323
  if (sp->RasterBits) {
    {
#line 324
    free((void *)((char *)sp->RasterBits));
    }
  }
#line 327
  if (sp->ExtensionBlocks) {
    {
#line 328
    FreeExtension(sp);
    }
  }
#line 336
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
SavedImage *MakeSavedImage(GifFileType *GifFile , SavedImage const   *CopyFrom ) 
{ 
  SavedImage *sp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 347
  if ((unsigned long )GifFile->SavedImages == (unsigned long )((void *)0)) {
    {
#line 348
    tmp = malloc(sizeof(SavedImage ));
#line 348
    GifFile->SavedImages = (SavedImage *)tmp;
    }
  } else {
    {
#line 350
    tmp___0 = realloc((void *)GifFile->SavedImages, sizeof(SavedImage ) * (unsigned long )(GifFile->ImageCount + 1));
#line 350
    GifFile->SavedImages = (SavedImage *)tmp___0;
    }
  }
#line 353
  if ((unsigned long )GifFile->SavedImages == (unsigned long )((void *)0)) {
#line 354
    return ((SavedImage *)((void *)0));
  } else {
    {
#line 356
    tmp___1 = GifFile->ImageCount;
#line 356
    (GifFile->ImageCount) ++;
#line 356
    sp = GifFile->SavedImages + tmp___1;
#line 357
    memset((void *)((char *)sp), '\000', sizeof(SavedImage ));
    }
#line 359
    if (CopyFrom) {
      {
#line 360
      memcpy((void */* __restrict  */)((char *)sp), (void const   */* __restrict  */)CopyFrom,
             sizeof(SavedImage ));
      }
#line 369
      if (sp->ImageDesc.ColorMap) {
        {
#line 370
        sp->ImageDesc.ColorMap = MakeMapObject((CopyFrom->ImageDesc.ColorMap)->ColorCount,
                                               (GifColorType const   *)(CopyFrom->ImageDesc.ColorMap)->Colors);
        }
#line 373
        if ((unsigned long )sp->ImageDesc.ColorMap == (unsigned long )((void *)0)) {
          {
#line 374
          FreeLastSavedImage(GifFile);
          }
#line 375
          return ((SavedImage *)((void *)0));
        }
      }
      {
#line 380
      tmp___2 = malloc((sizeof(GifPixelType ) * (unsigned long )CopyFrom->ImageDesc.Height) * (unsigned long )CopyFrom->ImageDesc.Width);
#line 380
      sp->RasterBits = (unsigned char *)tmp___2;
      }
#line 383
      if ((unsigned long )sp->RasterBits == (unsigned long )((void *)0)) {
        {
#line 384
        FreeLastSavedImage(GifFile);
        }
#line 385
        return ((SavedImage *)((void *)0));
      }
      {
#line 387
      memcpy((void */* __restrict  */)sp->RasterBits, (void const   */* __restrict  */)CopyFrom->RasterBits,
             (sizeof(GifPixelType ) * (unsigned long )CopyFrom->ImageDesc.Height) * (unsigned long )CopyFrom->ImageDesc.Width);
      }
#line 392
      if (sp->ExtensionBlocks) {
        {
#line 393
        tmp___3 = malloc(sizeof(ExtensionBlock ) * (unsigned long )CopyFrom->ExtensionBlockCount);
#line 393
        sp->ExtensionBlocks = (ExtensionBlock *)tmp___3;
        }
#line 396
        if ((unsigned long )sp->ExtensionBlocks == (unsigned long )((void *)0)) {
          {
#line 397
          FreeLastSavedImage(GifFile);
          }
#line 398
          return ((SavedImage *)((void *)0));
        }
        {
#line 400
        memcpy((void */* __restrict  */)sp->ExtensionBlocks, (void const   */* __restrict  */)CopyFrom->ExtensionBlocks,
               sizeof(ExtensionBlock ) * (unsigned long )CopyFrom->ExtensionBlockCount);
        }
      }
    }
#line 416
    return (sp);
  }
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gifalloc.c"
void FreeSavedImages(GifFileType *GifFile ) 
{ 
  SavedImage *sp ;

  {
#line 425
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
#line 426
    return;
  } else
#line 425
  if ((unsigned long )GifFile->SavedImages == (unsigned long )((void *)0)) {
#line 426
    return;
  }
#line 428
  sp = GifFile->SavedImages;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! ((unsigned long )sp < (unsigned long )(GifFile->SavedImages + GifFile->ImageCount))) {
#line 428
      goto while_break;
    }
#line 430
    if (sp->ImageDesc.ColorMap) {
      {
#line 431
      FreeMapObject(sp->ImageDesc.ColorMap);
#line 432
      sp->ImageDesc.ColorMap = (ColorMapObject *)((void *)0);
      }
    }
#line 435
    if (sp->RasterBits) {
      {
#line 436
      free((void *)((char *)sp->RasterBits));
      }
    }
#line 438
    if (sp->ExtensionBlocks) {
      {
#line 439
      FreeExtension(sp);
      }
    }
#line 428
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 441
  free((void *)((char *)GifFile->SavedImages));
#line 442
  GifFile->SavedImages = (struct SavedImage *)((void *)0);
  }
#line 443
  return;
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
GifFileType *EGifOpenFileName(char const   *FileName , int TestExistance ) ;
#line 138
GifFileType *EGifOpenFileHandle(int FileHandle ) ;
#line 139
GifFileType *EGifOpen(void *userData , int (*writeFunc)(GifFileType * , GifByteType const   * ,
                                                        int  ) ) ;
#line 141
int EGifSpew(GifFileType *GifFileOut ) ;
#line 142
void EGifSetGifVersion(char const   *Version ) ;
#line 143
int EGifPutScreenDesc(GifFileType *GifFile , int Width , int Height , int ColorRes ,
                      int BackGround___4 , ColorMapObject const   *ColorMap___3 ) ;
#line 147
int EGifPutImageDesc(GifFileType *GifFile , int Left , int Top , int Width , int Height ,
                     int Interlace , ColorMapObject const   *ColorMap___3 ) ;
#line 150
int EGifPutLine(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 152
int EGifPutPixel(GifFileType *GifFile , GifPixelType Pixel ) ;
#line 153
int EGifPutComment(GifFileType *GifFile , char const   *Comment ) ;
#line 154
int EGifPutExtensionFirst(GifFileType *GifFile , int ExtCode , int ExtLen , void const   *Extension ) ;
#line 156
int EGifPutExtensionNext(GifFileType *GifFile , int ExtCode , int ExtLen , void const   *Extension ) ;
#line 158
int EGifPutExtensionLast(GifFileType *GifFile , int ExtCode , int ExtLen , void const   *Extension ) ;
#line 160
int EGifPutExtension(GifFileType *GifFile , int ExtCode , int ExtLen , void const   *Extension ) ;
#line 162
int EGifPutCode(GifFileType *GifFile , int CodeSize , GifByteType const   *CodeBlock ) ;
#line 164
int EGifPutCodeNext(GifFileType *GifFile , GifByteType const   *CodeBlock ) ;
#line 166
int EGifCloseFile(GifFileType *GifFile ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.h"
GifHashTableType *_InitHashTable(void) ;
#line 55
void _ClearHashTable(GifHashTableType *HashTable ) ;
#line 56
void _InsertHashTable(GifHashTableType *HashTable , u_int32_t Key , int Code ) ;
#line 57
int _ExistsHashTable(GifHashTableType *HashTable , u_int32_t Key ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib_private.h"
int _GifError ;
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
GifFileType *EGifOpenFileName(char const   *FileName , int TestExistance ) 
{ 
  int FileHandle ;
  GifFileType *GifFile ;

  {
#line 99
  if (TestExistance) {
    {
#line 100
    FileHandle = open(FileName, 193, 384);
    }
  } else {
    {
#line 106
    FileHandle = open(FileName, 577, 384);
    }
  }
#line 112
  if (FileHandle == -1) {
#line 113
    _GifError = 1;
#line 114
    return ((GifFileType *)((void *)0));
  }
  {
#line 116
  GifFile = EGifOpenFileHandle(FileHandle);
  }
#line 117
  if ((unsigned long )GifFile == (unsigned long )((GifFileType *)((void *)0))) {
    {
#line 118
    close(FileHandle);
    }
  }
#line 119
  return (GifFile);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
GifFileType *EGifOpenFileHandle(int FileHandle ) 
{ 
  GifFileType *GifFile ;
  GifFilePrivateType *Private ;
  FILE *f ;
  void *tmp ;
  void *tmp___0 ;
  GifHashTableType *tmp___1 ;

  {
  {
#line 135
  tmp = malloc(sizeof(GifFileType ));
#line 135
  GifFile = (GifFileType *)tmp;
  }
#line 136
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
#line 137
    _GifError = 7;
#line 138
    return ((GifFileType *)((void *)0));
  }
  {
#line 141
  memset((void *)GifFile, '\000', sizeof(GifFileType ));
#line 143
  tmp___0 = malloc(sizeof(GifFilePrivateType ));
#line 143
  Private = (GifFilePrivateType *)tmp___0;
  }
#line 144
  if ((unsigned long )Private == (unsigned long )((void *)0)) {
    {
#line 145
    free((void *)GifFile);
#line 146
    _GifError = 7;
    }
#line 147
    return ((GifFileType *)((void *)0));
  }
  {
#line 149
  tmp___1 = _InitHashTable();
#line 149
  Private->HashTable = tmp___1;
  }
#line 149
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 150
    free((void *)GifFile);
#line 151
    free((void *)Private);
#line 152
    _GifError = 7;
    }
#line 153
    return ((GifFileType *)((void *)0));
  }
  {
#line 160
  f = fdopen(FileHandle, "wb");
#line 167
  GifFile->Private = (void *)Private;
#line 168
  Private->FileHandle = FileHandle;
#line 169
  Private->File = f;
#line 170
  Private->FileState = 1;
#line 172
  Private->Write = (int (*)(GifFileType * , GifByteType const   * , int  ))0;
#line 173
  GifFile->UserData = (void *)0;
#line 175
  _GifError = 0;
  }
#line 177
  return (GifFile);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
GifFileType *EGifOpen(void *userData , int (*writeFunc)(GifFileType * , GifByteType const   * ,
                                                        int  ) ) 
{ 
  GifFileType *GifFile ;
  GifFilePrivateType *Private ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 191
  tmp = malloc(sizeof(GifFileType ));
#line 191
  GifFile = (GifFileType *)tmp;
  }
#line 192
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
#line 193
    _GifError = 7;
#line 194
    return ((GifFileType *)((void *)0));
  }
  {
#line 197
  memset((void *)GifFile, '\000', sizeof(GifFileType ));
#line 199
  tmp___0 = malloc(sizeof(GifFilePrivateType ));
#line 199
  Private = (GifFilePrivateType *)tmp___0;
  }
#line 200
  if ((unsigned long )Private == (unsigned long )((void *)0)) {
    {
#line 201
    free((void *)GifFile);
#line 202
    _GifError = 7;
    }
#line 203
    return ((GifFileType *)((void *)0));
  }
  {
#line 206
  Private->HashTable = _InitHashTable();
  }
#line 207
  if ((unsigned long )Private->HashTable == (unsigned long )((void *)0)) {
    {
#line 208
    free((void *)GifFile);
#line 209
    free((void *)Private);
#line 210
    _GifError = 7;
    }
#line 211
    return ((GifFileType *)((void *)0));
  }
#line 214
  GifFile->Private = (void *)Private;
#line 215
  Private->FileHandle = 0;
#line 216
  Private->File = (FILE *)0;
#line 217
  Private->FileState = 1;
#line 219
  Private->Write = writeFunc;
#line 220
  GifFile->UserData = userData;
#line 222
  _GifError = 0;
#line 224
  return (GifFile);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
void EGifSetGifVersion(char const   *Version ) 
{ 


  {
  {
#line 234
  strncpy((char */* __restrict  */)(GifVersionPrefix + 3), (char const   */* __restrict  */)Version,
          (size_t )3);
  }
#line 235
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutScreenDesc(GifFileType *GifFile , int Width , int Height , int ColorRes ,
                      int BackGround___4 , ColorMapObject const   *ColorMap___3 ) 
{ 
  int i ;
  GifByteType Buf[3] ;
  GifFilePrivateType *Private ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
#line 251
  Private = (GifFilePrivateType *)GifFile->Private;
#line 253
  if (Private->FileState & 2) {
#line 255
    _GifError = 3;
#line 256
    return (0);
  }
#line 258
  if (! (Private->FileState & 1)) {
#line 260
    _GifError = 10;
#line 261
    return (0);
  }
#line 266
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 266
    tmp = strlen((char const   *)(GifVersionPrefix));
#line 266
    tmp___0 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)((unsigned char *)(GifVersionPrefix)),
                                                                   (int )tmp);
#line 266
    tmp___3 = (size_t )tmp___0;
    }
  } else {
    {
#line 266
    tmp___1 = strlen((char const   *)(GifVersionPrefix));
#line 266
    tmp___2 = fwrite((void const   */* __restrict  */)((unsigned char *)(GifVersionPrefix)),
                     (size_t )1, tmp___1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 266
    tmp___3 = tmp___2;
    }
  }
  {
#line 266
  tmp___4 = strlen((char const   *)(GifVersionPrefix));
  }
#line 266
  if (tmp___3 != tmp___4) {
#line 268
    _GifError = 2;
#line 269
    return (0);
  }
#line 273
  GifFile->SWidth = Width;
#line 274
  GifFile->SHeight = Height;
#line 275
  GifFile->SColorResolution = ColorRes;
#line 276
  GifFile->SBackGroundColor = BackGround___4;
#line 277
  if (ColorMap___3) {
    {
#line 278
    GifFile->SColorMap = MakeMapObject((int )ColorMap___3->ColorCount, (GifColorType const   *)ColorMap___3->Colors);
    }
#line 280
    if ((unsigned long )GifFile->SColorMap == (unsigned long )((void *)0)) {
#line 281
      _GifError = 7;
#line 282
      return (0);
    }
  } else {
#line 285
    GifFile->SColorMap = (ColorMapObject *)((void *)0);
  }
  {
#line 291
  EGifPutWord(Width, GifFile);
#line 292
  EGifPutWord(Height, GifFile);
  }
#line 299
  if (ColorMap___3) {
#line 299
    tmp___5 = 128;
  } else {
#line 299
    tmp___5 = 0;
  }
#line 299
  if (ColorMap___3) {
#line 299
    tmp___6 = ColorMap___3->BitsPerPixel - 1;
  } else {
#line 299
    tmp___6 = (int const   )7;
  }
#line 299
  Buf[0] = (GifByteType )((tmp___5 | ((ColorRes - 1) << 4)) | (int )tmp___6);
#line 303
  Buf[1] = (GifByteType )BackGround___4;
#line 304
  Buf[2] = (GifByteType )0;
#line 306
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 306
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(Buf),
                                                         3);
    }
  } else {
    {
#line 306
    fwrite((void const   */* __restrict  */)(Buf), (size_t )1, (size_t )3, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 311
  if ((unsigned long )ColorMap___3 != (unsigned long )((void *)0)) {
#line 312
    i = 0;
    {
#line 312
    while (1) {
      while_continue: /* CIL Label */ ;
#line 312
      if (! (i < (int )ColorMap___3->ColorCount)) {
#line 312
        goto while_break;
      }
#line 314
      Buf[0] = (ColorMap___3->Colors + i)->Red;
#line 315
      Buf[1] = (ColorMap___3->Colors + i)->Green;
#line 316
      Buf[2] = (ColorMap___3->Colors + i)->Blue;
#line 317
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 317
        tmp___7 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(Buf),
                                                                       3);
#line 317
        tmp___9 = (size_t )tmp___7;
        }
      } else {
        {
#line 317
        tmp___8 = fwrite((void const   */* __restrict  */)(Buf), (size_t )1, (size_t )3,
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 317
        tmp___9 = tmp___8;
        }
      }
#line 317
      if (tmp___9 != 3UL) {
#line 318
        _GifError = 2;
#line 319
        return (0);
      }
#line 312
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 325
  Private->FileState |= 2;
#line 327
  return (1);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutImageDesc(GifFileType *GifFile , int Left , int Top , int Width , int Height ,
                     int Interlace , ColorMapObject const   *ColorMap___3 ) 
{ 
  int i ;
  GifByteType Buf[3] ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 345
  Private = (GifFilePrivateType *)GifFile->Private;
#line 347
  if (Private->FileState & 4) {
#line 347
    if (Private->PixelCount > 4294901760UL) {
#line 354
      _GifError = 4;
#line 355
      return (0);
    }
  }
#line 357
  if (! (Private->FileState & 1)) {
#line 359
    _GifError = 10;
#line 360
    return (0);
  }
#line 362
  GifFile->Image.Left = Left;
#line 363
  GifFile->Image.Top = Top;
#line 364
  GifFile->Image.Width = Width;
#line 365
  GifFile->Image.Height = Height;
#line 366
  GifFile->Image.Interlace = Interlace;
#line 367
  if (ColorMap___3) {
    {
#line 368
    GifFile->Image.ColorMap = MakeMapObject((int )ColorMap___3->ColorCount, (GifColorType const   *)ColorMap___3->Colors);
    }
#line 370
    if ((unsigned long )GifFile->Image.ColorMap == (unsigned long )((void *)0)) {
#line 371
      _GifError = 7;
#line 372
      return (0);
    }
  } else {
#line 375
    GifFile->Image.ColorMap = (ColorMapObject *)((void *)0);
  }
#line 379
  Buf[0] = (GifByteType )',';
#line 381
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 381
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(Buf),
                                                         1);
    }
  } else {
    {
#line 381
    fwrite((void const   */* __restrict  */)(Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 383
  EGifPutWord(Left, GifFile);
#line 384
  EGifPutWord(Top, GifFile);
#line 385
  EGifPutWord(Width, GifFile);
#line 386
  EGifPutWord(Height, GifFile);
  }
#line 387
  if (ColorMap___3) {
#line 387
    tmp = 128;
  } else {
#line 387
    tmp = 0;
  }
#line 387
  if (Interlace) {
#line 387
    tmp___0 = 64;
  } else {
#line 387
    tmp___0 = 0;
  }
#line 387
  if (ColorMap___3) {
#line 387
    tmp___1 = ColorMap___3->BitsPerPixel - 1;
  } else {
#line 387
    tmp___1 = (int const   )0;
  }
#line 387
  Buf[0] = (GifByteType )((tmp | tmp___0) | (int )tmp___1);
#line 391
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 391
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(Buf),
                                                         1);
    }
  } else {
    {
#line 391
    fwrite((void const   */* __restrict  */)(Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 396
  if ((unsigned long )ColorMap___3 != (unsigned long )((void *)0)) {
#line 397
    i = 0;
    {
#line 397
    while (1) {
      while_continue: /* CIL Label */ ;
#line 397
      if (! (i < (int )ColorMap___3->ColorCount)) {
#line 397
        goto while_break;
      }
#line 399
      Buf[0] = (ColorMap___3->Colors + i)->Red;
#line 400
      Buf[1] = (ColorMap___3->Colors + i)->Green;
#line 401
      Buf[2] = (ColorMap___3->Colors + i)->Blue;
#line 402
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 402
        tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(Buf),
                                                                       3);
#line 402
        tmp___4 = (size_t )tmp___2;
        }
      } else {
        {
#line 402
        tmp___3 = fwrite((void const   */* __restrict  */)(Buf), (size_t )1, (size_t )3,
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 402
        tmp___4 = tmp___3;
        }
      }
#line 402
      if (tmp___4 != 3UL) {
#line 403
        _GifError = 2;
#line 404
        return (0);
      }
#line 397
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 408
  if ((unsigned long )GifFile->SColorMap == (unsigned long )((void *)0)) {
#line 408
    if ((unsigned long )GifFile->Image.ColorMap == (unsigned long )((void *)0)) {
#line 409
      _GifError = 5;
#line 410
      return (0);
    }
  }
  {
#line 414
  Private->FileState |= 4;
#line 415
  Private->PixelCount = (unsigned long )((long )Width * (long )Height);
#line 417
  EGifSetupCompress(GifFile);
  }
#line 419
  return (1);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutLine(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  GifPixelType Mask ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 432
  Private = (GifFilePrivateType *)GifFile->Private;
#line 434
  if (! (Private->FileState & 1)) {
#line 436
    _GifError = 10;
#line 437
    return (0);
  }
#line 440
  if (! LineLen) {
#line 441
    LineLen = GifFile->Image.Width;
  }
#line 442
  if (Private->PixelCount < (unsigned long )((unsigned int )LineLen)) {
#line 443
    _GifError = 6;
#line 444
    return (0);
  }
#line 446
  Private->PixelCount -= (unsigned long )LineLen;
#line 450
  Mask = CodeMask[Private->BitsPerPixel];
#line 451
  i = 0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! (i < LineLen)) {
#line 451
      goto while_break;
    }
#line 452
    *(Line + i) = (GifPixelType )((int )*(Line + i) & (int )Mask);
#line 451
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 454
  tmp = EGifCompressLine(GifFile, Line, LineLen);
  }
#line 454
  return (tmp);
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutPixel(GifFileType *GifFile , GifPixelType Pixel ) 
{ 
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 464
  Private = (GifFilePrivateType *)GifFile->Private;
#line 466
  if (! (Private->FileState & 1)) {
#line 468
    _GifError = 10;
#line 469
    return (0);
  }
#line 472
  if (Private->PixelCount == 0UL) {
#line 473
    _GifError = 6;
#line 474
    return (0);
  }
  {
#line 476
  (Private->PixelCount) --;
#line 480
  Pixel = (GifPixelType )((int )Pixel & (int )CodeMask[Private->BitsPerPixel]);
#line 482
  tmp = EGifCompressLine(GifFile, & Pixel, 1);
  }
#line 482
  return (tmp);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutComment(GifFileType *GifFile , char const   *Comment ) 
{ 
  unsigned int length ;
  size_t tmp ;
  char *buf ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 492
  tmp = strlen(Comment);
#line 492
  length = (unsigned int )tmp;
#line 495
  tmp___0 = strlen(Comment);
#line 495
  length = (unsigned int )tmp___0;
  }
#line 496
  if (length <= 255U) {
    {
#line 497
    tmp___1 = EGifPutExtension(GifFile, 254, (int )length, (void const   *)Comment);
    }
#line 497
    return (tmp___1);
  } else {
    {
#line 500
    buf = (char *)Comment;
#line 501
    tmp___2 = EGifPutExtensionFirst(GifFile, 254, 255, (void const   *)buf);
    }
#line 501
    if (tmp___2 == 0) {
#line 503
      return (0);
    }
#line 505
    length -= 255U;
#line 506
    buf += 255;
    {
#line 509
    while (1) {
      while_continue: /* CIL Label */ ;
#line 509
      if (! (length > 255U)) {
#line 509
        goto while_break;
      }
      {
#line 510
      tmp___3 = EGifPutExtensionNext(GifFile, 0, 255, (void const   *)buf);
      }
#line 510
      if (tmp___3 == 0) {
#line 511
        return (0);
      }
#line 513
      buf += 255;
#line 514
      length -= 255U;
    }
    while_break: /* CIL Label */ ;
    }
#line 517
    if (length > 0U) {
      {
#line 518
      tmp___4 = EGifPutExtensionLast(GifFile, 0, (int )length, (void const   *)buf);
      }
#line 518
      if (tmp___4 == 0) {
#line 519
        return (0);
      }
    } else {
      {
#line 522
      tmp___5 = EGifPutExtensionLast(GifFile, 0, 0, (void const   *)((void *)0));
      }
#line 522
      if (tmp___5 == 0) {
#line 523
        return (0);
      }
    }
  }
#line 527
  return (1);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutExtensionFirst(GifFileType *GifFile , int ExtCode , int ExtLen , void const   *Extension ) 
{ 
  GifByteType Buf[3] ;
  GifFilePrivateType *Private ;

  {
#line 542
  Private = (GifFilePrivateType *)GifFile->Private;
#line 544
  if (! (Private->FileState & 1)) {
#line 546
    _GifError = 10;
#line 547
    return (0);
  }
#line 550
  if (ExtCode == 0) {
#line 551
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 551
      (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)((GifByteType *)(& ExtLen)),
                                                           1);
      }
    } else {
      {
#line 551
      fwrite((void const   */* __restrict  */)((GifByteType *)(& ExtLen)), (size_t )1,
             (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
      }
    }
  } else {
#line 553
    Buf[0] = (GifByteType )'!';
#line 554
    Buf[1] = (GifByteType )ExtCode;
#line 555
    Buf[2] = (GifByteType )ExtLen;
#line 556
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 556
      (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(Buf),
                                                           3);
      }
    } else {
      {
#line 556
      fwrite((void const   */* __restrict  */)(Buf), (size_t )1, (size_t )3, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
      }
    }
  }
#line 559
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 559
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Extension,
                                                         ExtLen);
    }
  } else {
    {
#line 559
    fwrite((void const   */* __restrict  */)Extension, (size_t )1, (size_t )ExtLen,
           (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 561
  return (1);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutExtensionNext(GifFileType *GifFile , int ExtCode , int ExtLen , void const   *Extension ) 
{ 
  GifByteType Buf ;
  GifFilePrivateType *Private ;

  {
#line 574
  Private = (GifFilePrivateType *)GifFile->Private;
#line 576
  if (! (Private->FileState & 1)) {
#line 578
    _GifError = 10;
#line 579
    return (0);
  }
#line 582
  Buf = (GifByteType )ExtLen;
#line 583
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 583
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 583
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 584
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 584
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Extension,
                                                         ExtLen);
    }
  } else {
    {
#line 584
    fwrite((void const   */* __restrict  */)Extension, (size_t )1, (size_t )ExtLen,
           (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 586
  return (1);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutExtensionLast(GifFileType *GifFile , int ExtCode , int ExtLen , void const   *Extension ) 
{ 
  GifByteType Buf ;
  GifFilePrivateType *Private ;

  {
#line 599
  Private = (GifFilePrivateType *)GifFile->Private;
#line 601
  if (! (Private->FileState & 1)) {
#line 603
    _GifError = 10;
#line 604
    return (0);
  }
#line 608
  if (ExtLen > 0) {
#line 609
    Buf = (GifByteType )ExtLen;
#line 610
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 610
      (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                           1);
      }
    } else {
      {
#line 610
      fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
      }
    }
#line 611
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 611
      (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Extension,
                                                           ExtLen);
      }
    } else {
      {
#line 611
      fwrite((void const   */* __restrict  */)Extension, (size_t )1, (size_t )ExtLen,
             (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
      }
    }
  }
#line 615
  Buf = (GifByteType )0;
#line 616
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 616
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 616
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 618
  return (1);
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutExtension(GifFileType *GifFile , int ExtCode , int ExtLen , void const   *Extension ) 
{ 
  GifByteType Buf[3] ;
  GifFilePrivateType *Private ;

  {
#line 634
  Private = (GifFilePrivateType *)GifFile->Private;
#line 636
  if (! (Private->FileState & 1)) {
#line 638
    _GifError = 10;
#line 639
    return (0);
  }
#line 642
  if (ExtCode == 0) {
#line 643
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 643
      (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)((GifByteType *)(& ExtLen)),
                                                           1);
      }
    } else {
      {
#line 643
      fwrite((void const   */* __restrict  */)((GifByteType *)(& ExtLen)), (size_t )1,
             (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
      }
    }
  } else {
#line 645
    Buf[0] = (GifByteType )'!';
#line 646
    Buf[1] = (GifByteType )ExtCode;
#line 647
    Buf[2] = (GifByteType )ExtLen;
#line 648
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 648
      (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(Buf),
                                                           3);
      }
    } else {
      {
#line 648
      fwrite((void const   */* __restrict  */)(Buf), (size_t )1, (size_t )3, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
      }
    }
  }
#line 650
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 650
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Extension,
                                                         ExtLen);
    }
  } else {
    {
#line 650
    fwrite((void const   */* __restrict  */)Extension, (size_t )1, (size_t )ExtLen,
           (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 651
  Buf[0] = (GifByteType )0;
#line 652
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 652
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(Buf),
                                                         1);
    }
  } else {
    {
#line 652
    fwrite((void const   */* __restrict  */)(Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 654
  return (1);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutCode(GifFileType *GifFile , int CodeSize , GifByteType const   *CodeBlock ) 
{ 
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 669
  Private = (GifFilePrivateType *)GifFile->Private;
#line 671
  if (! (Private->FileState & 1)) {
#line 673
    _GifError = 10;
#line 674
    return (0);
  }
  {
#line 686
  tmp = EGifPutCodeNext(GifFile, CodeBlock);
  }
#line 686
  return (tmp);
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifPutCodeNext(GifFileType *GifFile , GifByteType const   *CodeBlock ) 
{ 
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 699
  Private = (GifFilePrivateType *)GifFile->Private;
#line 701
  if ((unsigned long )CodeBlock != (unsigned long )((void *)0)) {
#line 702
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 702
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, CodeBlock,
                                                                 (int )((int const   )*(CodeBlock + 0) + 1));
#line 702
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 702
      tmp___0 = fwrite((void const   */* __restrict  */)CodeBlock, (size_t )1, (size_t )((int const   )*(CodeBlock + 0) + 1),
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 702
      tmp___1 = tmp___0;
      }
    }
#line 702
    if (tmp___1 != (size_t )((unsigned int )((int const   )*(CodeBlock + 0) + 1))) {
#line 704
      _GifError = 2;
#line 705
      return (0);
    }
  } else {
#line 708
    Buf = (GifByteType )0;
#line 709
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 709
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                                     1);
#line 709
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 709
      tmp___3 = fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 709
      tmp___4 = tmp___3;
      }
    }
#line 709
    if (tmp___4 != 1UL) {
#line 710
      _GifError = 2;
#line 711
      return (0);
    }
#line 713
    Private->PixelCount = 0UL;
  }
#line 716
  return (1);
}
}
#line 722 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifCloseFile(GifFileType *GifFile ) 
{ 
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  FILE *File ;
  int tmp ;

  {
#line 729
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
#line 730
    return (0);
  }
#line 732
  Private = (GifFilePrivateType *)GifFile->Private;
#line 733
  if (! (Private->FileState & 1)) {
#line 735
    _GifError = 10;
#line 736
    return (0);
  }
#line 739
  File = Private->File;
#line 741
  Buf = (GifByteType )';';
#line 742
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 742
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 742
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 744
  if (GifFile->Image.ColorMap) {
    {
#line 745
    FreeMapObject(GifFile->Image.ColorMap);
#line 746
    GifFile->Image.ColorMap = (ColorMapObject *)((void *)0);
    }
  }
#line 748
  if (GifFile->SColorMap) {
    {
#line 749
    FreeMapObject(GifFile->SColorMap);
#line 750
    GifFile->SColorMap = (ColorMapObject *)((void *)0);
    }
  }
#line 752
  if (Private) {
#line 753
    if (Private->HashTable) {
      {
#line 754
      free((void *)((char *)Private->HashTable));
      }
    }
    {
#line 756
    free((void *)((char *)Private));
    }
  }
  {
#line 758
  free((void *)GifFile);
  }
#line 760
  if (File) {
    {
#line 760
    tmp = fclose(File);
    }
#line 760
    if (tmp != 0) {
#line 761
      _GifError = 9;
#line 762
      return (0);
    }
  }
#line 764
  return (1);
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 1012 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
int EGifSpew(GifFileType *GifFileOut ) 
{ 
  int i ;
  int j ;
  int gif89 ;
  int bOff ;
  char SavedStamp[(sizeof("GIFVER") - 1UL) + 1UL] ;
  int function ;
  int tmp ;
  SavedImage *sp ;
  int SavedHeight ;
  int SavedWidth ;
  ExtensionBlock *ep ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1015
  gif89 = 0;
#line 1019
  i = 0;
  {
#line 1019
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1019
    if (! (i < GifFileOut->ImageCount)) {
#line 1019
      goto while_break;
    }
#line 1020
    j = 0;
    {
#line 1020
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1020
      if (! (j < (GifFileOut->SavedImages + i)->ExtensionBlockCount)) {
#line 1020
        goto while_break___0;
      }
#line 1021
      function = ((GifFileOut->SavedImages + i)->ExtensionBlocks + j)->Function;
#line 1024
      if (function == 254) {
#line 1028
        gif89 = 1;
      } else
#line 1024
      if (function == 249) {
#line 1028
        gif89 = 1;
      } else
#line 1024
      if (function == 1) {
#line 1028
        gif89 = 1;
      } else
#line 1024
      if (function == 255) {
#line 1028
        gif89 = 1;
      }
#line 1020
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1019
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1032
  strncpy((char */* __restrict  */)(SavedStamp), (char const   */* __restrict  */)(GifVersionPrefix),
          sizeof("GIFVER") - 1UL);
  }
#line 1033
  if (gif89) {
    {
#line 1034
    strncpy((char */* __restrict  */)(GifVersionPrefix), (char const   */* __restrict  */)"GIF89a",
            sizeof("GIFVER") - 1UL);
    }
  } else {
    {
#line 1036
    strncpy((char */* __restrict  */)(GifVersionPrefix), (char const   */* __restrict  */)"GIF87a",
            sizeof("GIFVER") - 1UL);
    }
  }
  {
#line 1038
  tmp = EGifPutScreenDesc(GifFileOut, GifFileOut->SWidth, GifFileOut->SHeight, GifFileOut->SColorResolution,
                          GifFileOut->SBackGroundColor, (ColorMapObject const   *)GifFileOut->SColorMap);
  }
#line 1038
  if (tmp == 0) {
    {
#line 1044
    strncpy((char */* __restrict  */)(GifVersionPrefix), (char const   */* __restrict  */)(SavedStamp),
            sizeof("GIFVER") - 1UL);
    }
#line 1045
    return (0);
  }
  {
#line 1047
  strncpy((char */* __restrict  */)(GifVersionPrefix), (char const   */* __restrict  */)(SavedStamp),
          sizeof("GIFVER") - 1UL);
#line 1049
  i = 0;
  }
  {
#line 1049
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1049
    if (! (i < GifFileOut->ImageCount)) {
#line 1049
      goto while_break___1;
    }
#line 1050
    sp = GifFileOut->SavedImages + i;
#line 1051
    SavedHeight = sp->ImageDesc.Height;
#line 1052
    SavedWidth = sp->ImageDesc.Width;
#line 1056
    if ((unsigned long )sp->RasterBits == (unsigned long )((void *)0)) {
#line 1057
      goto __Cont;
    }
#line 1059
    if (sp->ExtensionBlocks) {
#line 1060
      j = 0;
      {
#line 1060
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1060
        if (! (j < sp->ExtensionBlockCount)) {
#line 1060
          goto while_break___2;
        }
#line 1061
        ep = sp->ExtensionBlocks + j;
#line 1062
        if (j == sp->ExtensionBlockCount - 1) {
#line 1062
          goto _L;
        } else
#line 1062
        if ((ep + 1)->Function != 0) {
          _L: /* CIL Label */ 
#line 1068
          if (ep->Function != 0) {
#line 1068
            tmp___0 = ep->Function;
          } else {
#line 1068
            tmp___0 = '\000';
          }
          {
#line 1068
          tmp___1 = EGifPutExtension(GifFileOut, tmp___0, ep->ByteCount, (void const   *)ep->Bytes);
          }
#line 1068
          if (tmp___1 == 0) {
#line 1072
            return (0);
          }
        } else {
          {
#line 1075
          EGifPutExtensionFirst(GifFileOut, ep->Function, ep->ByteCount, (void const   *)ep->Bytes);
#line 1076
          bOff = j + 1;
          }
          {
#line 1076
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1076
            if (! (bOff < sp->ExtensionBlockCount)) {
#line 1076
              goto while_break___3;
            }
#line 1077
            ep = sp->ExtensionBlocks + bOff;
#line 1078
            if (ep->Function != 0) {
#line 1079
              goto while_break___3;
            }
            {
#line 1081
            EGifPutExtensionNext(GifFileOut, 0, ep->ByteCount, (void const   *)ep->Bytes);
#line 1076
            bOff ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 1084
          EGifPutExtensionLast(GifFileOut, 0, 0, (void const   *)((void *)0));
#line 1085
          j = bOff - 1;
          }
        }
#line 1060
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 1090
    tmp___2 = EGifPutImageDesc(GifFileOut, sp->ImageDesc.Left, sp->ImageDesc.Top,
                               SavedWidth, SavedHeight, sp->ImageDesc.Interlace, (ColorMapObject const   *)sp->ImageDesc.ColorMap);
    }
#line 1090
    if (tmp___2 == 0) {
#line 1097
      return (0);
    }
#line 1099
    j = 0;
    {
#line 1099
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1099
      if (! (j < SavedHeight)) {
#line 1099
        goto while_break___4;
      }
      {
#line 1100
      tmp___3 = EGifPutLine(GifFileOut, sp->RasterBits + j * SavedWidth, SavedWidth);
      }
#line 1100
      if (tmp___3 == 0) {
#line 1103
        return (0);
      }
#line 1099
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1049
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1107
  tmp___4 = EGifCloseFile(GifFileOut);
  }
#line 1107
  if (tmp___4 == 0) {
#line 1108
    return (0);
  }
#line 1110
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 231 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
int GifQuietPrint ;
#line 234
void GifQprintf(char *Format  , ...) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/qprintf.c"
int GifQuietPrint  =    1;
#line 37 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/qprintf.c"
void GifQprintf(char *Format  , ...) 
{ 
  char Line[128] ;
  va_list ArgPtr ;

  {
  {
#line 42
  __builtin_va_start(ArgPtr, Format);
  }
#line 56
  if (GifQuietPrint) {
#line 57
    return;
  }
  {
#line 59
  vsprintf((char */* __restrict  */)(Line), (char const   */* __restrict  */)Format,
           ArgPtr);
#line 60
  __builtin_va_end(ArgPtr);
#line 62
  fputs((char const   */* __restrict  */)(Line), (FILE */* __restrict  */)stderr);
  }
#line 63
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem(u_int32_t Item ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
GifHashTableType *_InitHashTable(void) 
{ 
  GifHashTableType *HashTable ;
  int tmp ;

  {
  {
#line 71
  tmp = (int )malloc(sizeof(GifHashTableType ));
#line 71
  HashTable = (GifHashTableType *)tmp;
  }
#line 71
  if ((unsigned long )HashTable == (unsigned long )((void *)0)) {
#line 73
    return ((GifHashTableType *)((void *)0));
  }
  {
#line 75
  _ClearHashTable(HashTable);
  }
#line 77
  return (HashTable);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
void _ClearHashTable(GifHashTableType *HashTable ) 
{ 


  {
  {
#line 86
  memset((void *)(HashTable->HTable), 255, 8192UL * sizeof(u_int32_t ));
  }
#line 87
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
void _InsertHashTable(GifHashTableType *HashTable , u_int32_t Key , int Code ) 
{ 
  int HKey ;
  int tmp ;
  u_int32_t *HTable ;

  {
  {
#line 95
  tmp = KeyItem(Key);
#line 95
  HKey = tmp;
#line 96
  HTable = HashTable->HTable;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((long )(*(HTable + HKey) >> 12) != 1048575L)) {
#line 103
      goto while_break;
    }
#line 107
    HKey = (HKey + 1) & 8191;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  *(HTable + HKey) = (Key << 12) | (unsigned int )(Code & 4095);
#line 110
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
int _ExistsHashTable(GifHashTableType *HashTable , u_int32_t Key ) 
{ 
  int HKey ;
  int tmp ;
  u_int32_t *HTable ;
  u_int32_t HTKey ;

  {
  {
#line 118
  tmp = KeyItem(Key);
#line 118
  HKey = tmp;
#line 119
  HTable = HashTable->HTable;
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    HTKey = *(HTable + HKey) >> 12;
#line 126
    if (! ((long )HTKey != 1048575L)) {
#line 126
      goto while_break;
    }
#line 130
    if (Key == HTKey) {
#line 130
      return ((int )(*(HTable + HKey) & 4095U));
    }
#line 131
    HKey = (HKey + 1) & 8191;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (-1);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 222 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
int QuantizeBuffer(unsigned int Width , unsigned int Height , int *ColorMapSize___1 ,
                   GifByteType *RedInput , GifByteType *GreenInput , GifByteType *BlueInput ,
                   GifByteType *OutputBuffer , GifColorType *OutputColorMap ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis  ;
#line 61
static int SubdivColorMap(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                          unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn(void const   *Entry1 , void const   *Entry2 ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
int QuantizeBuffer(unsigned int Width , unsigned int Height , int *ColorMapSize___1 ,
                   GifByteType *RedInput , GifByteType *GreenInput , GifByteType *BlueInput ,
                   GifByteType *OutputBuffer , GifColorType *OutputColorMap ) 
{ 
  unsigned int Index ;
  unsigned int NumOfEntries ;
  int i ;
  int j ;
  int MaxRGBError[3] ;
  unsigned int NewColorMapSize ;
  long Red ;
  long Green ;
  long Blue ;
  NewColorMapType NewColorSubdiv[256] ;
  QuantizedColorType *ColorArrayEntries ;
  QuantizedColorType *QuantizedColor ;
  void *tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  GifByteType tmp___2 ;
  GifByteType tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 95
  tmp = malloc(sizeof(QuantizedColorType ) * 32768UL);
#line 95
  ColorArrayEntries = (QuantizedColorType *)tmp;
  }
#line 97
  if ((unsigned long )ColorArrayEntries == (unsigned long )((void *)0)) {
#line 98
    _GifError = 7;
#line 99
    return (0);
  }
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < 32768)) {
#line 102
      goto while_break;
    }
#line 103
    (ColorArrayEntries + i)->RGB[0] = (GifByteType )(i >> 10);
#line 104
    (ColorArrayEntries + i)->RGB[1] = (GifByteType )((i >> 5) & 31);
#line 106
    (ColorArrayEntries + i)->RGB[2] = (GifByteType )(i & 31);
#line 107
    (ColorArrayEntries + i)->Count = 0L;
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (i < (int )(Width * Height))) {
#line 111
      goto while_break___0;
    }
#line 112
    Index = (unsigned int )(((((int )*(RedInput + i) >> 3) << 10) + (((int )*(GreenInput + i) >> 3) << 5)) + ((int )*(BlueInput + i) >> 3));
#line 117
    ((ColorArrayEntries + Index)->Count) ++;
#line 111
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if (! (i < 256)) {
#line 122
      goto while_break___1;
    }
#line 123
    NewColorSubdiv[i].QuantizedColors = (QuantizedColorType *)((void *)0);
#line 124
    tmp___0 = 0U;
#line 124
    NewColorSubdiv[i].NumEntries = tmp___0;
#line 124
    NewColorSubdiv[i].Count = (unsigned long )tmp___0;
#line 125
    j = 0;
    {
#line 125
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 125
      if (! (j < 3)) {
#line 125
        goto while_break___2;
      }
#line 126
      NewColorSubdiv[i].RGBMin[j] = (GifByteType )0;
#line 127
      NewColorSubdiv[i].RGBWidth[j] = (GifByteType )255;
#line 125
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 122
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 132
  i = 0;
  {
#line 132
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 132
    if (! (i < 32768)) {
#line 132
      goto while_break___3;
    }
#line 133
    if ((ColorArrayEntries + i)->Count > 0L) {
#line 134
      goto while_break___3;
    }
#line 132
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 135
  NewColorSubdiv[0].QuantizedColors = ColorArrayEntries + i;
#line 135
  QuantizedColor = NewColorSubdiv[0].QuantizedColors;
#line 136
  NumOfEntries = 1U;
  {
#line 137
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 137
    i ++;
#line 137
    if (! (i < 32768)) {
#line 137
      goto while_break___4;
    }
#line 138
    if ((ColorArrayEntries + i)->Count > 0L) {
#line 139
      QuantizedColor->Pnext = ColorArrayEntries + i;
#line 140
      QuantizedColor = ColorArrayEntries + i;
#line 141
      NumOfEntries ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 143
  QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 145
  NewColorSubdiv[0].NumEntries = NumOfEntries;
#line 146
  NewColorSubdiv[0].Count = (unsigned long )((long )Width * (long )Height);
#line 147
  NewColorMapSize = 1U;
#line 148
  tmp___1 = SubdivColorMap(NewColorSubdiv, (unsigned int )*ColorMapSize___1, & NewColorMapSize);
  }
#line 148
  if (tmp___1 != 1) {
    {
#line 150
    free((void *)((char *)ColorArrayEntries));
    }
#line 151
    return (0);
  }
#line 153
  if (NewColorMapSize < (unsigned int )*ColorMapSize___1) {
#line 155
    i = (int )NewColorMapSize;
    {
#line 155
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 155
      if (! (i < *ColorMapSize___1)) {
#line 155
        goto while_break___5;
      }
#line 156
      tmp___3 = (GifByteType )0;
#line 156
      (OutputColorMap + i)->Blue = tmp___3;
#line 156
      tmp___2 = tmp___3;
#line 156
      (OutputColorMap + i)->Green = tmp___2;
#line 156
      (OutputColorMap + i)->Red = tmp___2;
#line 155
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 162
    if (! ((unsigned int )i < NewColorMapSize)) {
#line 162
      goto while_break___6;
    }
#line 163
    j = (int )NewColorSubdiv[i].NumEntries;
#line 163
    if (j > 0) {
#line 164
      QuantizedColor = NewColorSubdiv[i].QuantizedColors;
#line 165
      Blue = 0L;
#line 165
      Green = Blue;
#line 165
      Red = Green;
      {
#line 166
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 166
        if (! QuantizedColor) {
#line 166
          goto while_break___7;
        }
#line 167
        QuantizedColor->NewColorIndex = (GifByteType )i;
#line 168
        Red += (long )QuantizedColor->RGB[0];
#line 169
        Green += (long )QuantizedColor->RGB[1];
#line 170
        Blue += (long )QuantizedColor->RGB[2];
#line 171
        QuantizedColor = QuantizedColor->Pnext;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 173
      (OutputColorMap + i)->Red = (GifByteType )((Red << 3) / (long )j);
#line 174
      (OutputColorMap + i)->Green = (GifByteType )((Green << 3) / (long )j);
#line 175
      (OutputColorMap + i)->Blue = (GifByteType )((Blue << 3) / (long )j);
    } else {
      {
#line 177
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Null entry in quantized color map - that\'s weird.\n",
              "GIFLIB");
      }
    }
#line 162
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 184
  MaxRGBError[2] = 0;
#line 184
  MaxRGBError[1] = MaxRGBError[2];
#line 184
  MaxRGBError[0] = MaxRGBError[1];
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 185
    if (! (i < (int )(Width * Height))) {
#line 185
      goto while_break___8;
    }
#line 186
    Index = (unsigned int )(((((int )*(RedInput + i) >> 3) << 10) + (((int )*(GreenInput + i) >> 3) << 5)) + ((int )*(BlueInput + i) >> 3));
#line 191
    Index = (unsigned int )(ColorArrayEntries + Index)->NewColorIndex;
#line 192
    *(OutputBuffer + i) = (GifByteType )Index;
#line 193
    if ((int )(OutputColorMap + Index)->Red - (int )*(RedInput + i) > 0) {
#line 193
      tmp___4 = (int )(OutputColorMap + Index)->Red - (int )*(RedInput + i);
    } else {
#line 193
      tmp___4 = - ((int )(OutputColorMap + Index)->Red - (int )*(RedInput + i));
    }
#line 193
    if (MaxRGBError[0] < tmp___4) {
#line 194
      if ((int )(OutputColorMap + Index)->Red - (int )*(RedInput + i) > 0) {
#line 194
        MaxRGBError[0] = (int )(OutputColorMap + Index)->Red - (int )*(RedInput + i);
      } else {
#line 194
        MaxRGBError[0] = - ((int )(OutputColorMap + Index)->Red - (int )*(RedInput + i));
      }
    }
#line 195
    if ((int )(OutputColorMap + Index)->Green - (int )*(GreenInput + i) > 0) {
#line 195
      tmp___5 = (int )(OutputColorMap + Index)->Green - (int )*(GreenInput + i);
    } else {
#line 195
      tmp___5 = - ((int )(OutputColorMap + Index)->Green - (int )*(GreenInput + i));
    }
#line 195
    if (MaxRGBError[1] < tmp___5) {
#line 196
      if ((int )(OutputColorMap + Index)->Green - (int )*(GreenInput + i) > 0) {
#line 196
        MaxRGBError[1] = (int )(OutputColorMap + Index)->Green - (int )*(GreenInput + i);
      } else {
#line 196
        MaxRGBError[1] = - ((int )(OutputColorMap + Index)->Green - (int )*(GreenInput + i));
      }
    }
#line 197
    if ((int )(OutputColorMap + Index)->Blue - (int )*(BlueInput + i) > 0) {
#line 197
      tmp___6 = (int )(OutputColorMap + Index)->Blue - (int )*(BlueInput + i);
    } else {
#line 197
      tmp___6 = - ((int )(OutputColorMap + Index)->Blue - (int )*(BlueInput + i));
    }
#line 197
    if (MaxRGBError[2] < tmp___6) {
#line 198
      if ((int )(OutputColorMap + Index)->Blue - (int )*(BlueInput + i) > 0) {
#line 198
        MaxRGBError[2] = (int )(OutputColorMap + Index)->Blue - (int )*(BlueInput + i);
      } else {
#line 198
        MaxRGBError[2] = - ((int )(OutputColorMap + Index)->Blue - (int )*(BlueInput + i));
      }
    }
#line 185
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 207
  free((void *)((char *)ColorArrayEntries));
#line 209
  *ColorMapSize___1 = (int )NewColorMapSize;
  }
#line 211
  return (1);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                          unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis]);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 184 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
GifFileType *DGifOpenFileName(char const   *FileName ) ;
#line 185
GifFileType *DGifOpenFileHandle(int FileHandle ) ;
#line 186
int DGifSlurp(GifFileType *GifFile ) ;
#line 188
GifFileType *DGifOpen(void *userData , int (*readFunc)(GifFileType * , GifByteType * ,
                                                       int  ) ) ;
#line 190
int DGifGetScreenDesc(GifFileType *GifFile ) ;
#line 191
int DGifGetRecordType(GifFileType *GifFile , GifRecordType *Type ) ;
#line 192
int DGifGetImageDesc(GifFileType *GifFile ) ;
#line 193
int DGifGetLine(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 194
int DGifGetPixel(GifFileType *GifFile , GifPixelType Pixel ) ;
#line 196
int DGifGetExtension(GifFileType *GifFile , int *ExtCode , GifByteType **Extension ) ;
#line 198
int DGifGetExtensionNext(GifFileType *GifFile , GifByteType **Extension ) ;
#line 199
int DGifGetCode(GifFileType *GifFile , int *CodeSize , GifByteType **CodeBlock ) ;
#line 201
int DGifGetCodeNext(GifFileType *GifFile , GifByteType **CodeBlock ) ;
#line 202
int DGifGetLZCodes(GifFileType *GifFile , int *Code ) ;
#line 203
int DGifCloseFile(GifFileType *GifFile ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
GifFileType *DGifOpenFileName(char const   *FileName ) 
{ 
  int FileHandle ;
  GifFileType *GifFile ;

  {
  {
#line 71
  FileHandle = open(FileName, 0);
  }
#line 71
  if (FileHandle == -1) {
#line 76
    _GifError = 101;
#line 77
    return ((GifFileType *)((void *)0));
  }
  {
#line 80
  GifFile = DGifOpenFileHandle(FileHandle);
  }
#line 81
  return (GifFile);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
GifFileType *DGifOpenFileHandle(int FileHandle ) 
{ 
  unsigned char Buf[(sizeof("GIFVER") - 1UL) + 1UL] ;
  GifFileType *GifFile ;
  GifFilePrivateType *Private ;
  FILE *f ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 97
  tmp = malloc(sizeof(GifFileType ));
#line 97
  GifFile = (GifFileType *)tmp;
  }
#line 98
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
    {
#line 99
    _GifError = 109;
#line 100
    close(FileHandle);
    }
#line 101
    return ((GifFileType *)((void *)0));
  }
  {
#line 104
  memset((void *)GifFile, '\000', sizeof(GifFileType ));
#line 106
  tmp___0 = malloc(sizeof(GifFilePrivateType ));
#line 106
  Private = (GifFilePrivateType *)tmp___0;
  }
#line 107
  if ((unsigned long )Private == (unsigned long )((void *)0)) {
    {
#line 108
    _GifError = 109;
#line 109
    close(FileHandle);
#line 110
    free((void *)((char *)GifFile));
    }
#line 111
    return ((GifFileType *)((void *)0));
  }
  {
#line 117
  f = fdopen(FileHandle, "rb");
#line 124
  GifFile->Private = (void *)Private;
#line 125
  Private->FileHandle = FileHandle;
#line 126
  Private->File = f;
#line 127
  Private->FileState = 8;
#line 128
  Private->Read = (int (*)(GifFileType * , GifByteType * , int  ))0;
#line 129
  GifFile->UserData = (void *)0;
  }
#line 132
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 132
    tmp___1 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, (int )(sizeof("GIFVER") - 1UL));
#line 132
    tmp___3 = (size_t )tmp___1;
    }
  } else {
    {
#line 132
    tmp___2 = fread((void */* __restrict  */)(Buf), (size_t )1, sizeof("GIFVER") - 1UL,
                    (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 132
    tmp___3 = tmp___2;
    }
  }
#line 132
  if (tmp___3 != sizeof("GIFVER") - 1UL) {
    {
#line 133
    _GifError = 102;
#line 134
    fclose(f);
#line 135
    free((void *)((char *)Private));
#line 136
    free((void *)((char *)GifFile));
    }
#line 137
    return ((GifFileType *)((void *)0));
  }
  {
#line 142
  Buf[sizeof("GIFVER") - 1UL] = (unsigned char)0;
#line 143
  tmp___4 = strncmp("GIFVER", (char const   *)(Buf), (size_t )3);
  }
#line 143
  if (tmp___4 != 0) {
    {
#line 144
    _GifError = 103;
#line 145
    fclose(f);
#line 146
    free((void *)((char *)Private));
#line 147
    free((void *)((char *)GifFile));
    }
#line 148
    return ((GifFileType *)((void *)0));
  }
  {
#line 151
  tmp___5 = DGifGetScreenDesc(GifFile);
  }
#line 151
  if (tmp___5 == 0) {
    {
#line 152
    fclose(f);
#line 153
    free((void *)((char *)Private));
#line 154
    free((void *)((char *)GifFile));
    }
#line 155
    return ((GifFileType *)((void *)0));
  }
#line 158
  _GifError = 0;
#line 160
  return (GifFile);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
GifFileType *DGifOpen(void *userData , int (*readFunc)(GifFileType * , GifByteType * ,
                                                       int  ) ) 
{ 
  unsigned char Buf[(sizeof("GIFVER") - 1UL) + 1UL] ;
  GifFileType *GifFile ;
  GifFilePrivateType *Private ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 176
  tmp = malloc(sizeof(GifFileType ));
#line 176
  GifFile = (GifFileType *)tmp;
  }
#line 177
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
#line 178
    _GifError = 109;
#line 179
    return ((GifFileType *)((void *)0));
  }
  {
#line 182
  memset((void *)GifFile, '\000', sizeof(GifFileType ));
#line 184
  tmp___0 = malloc(sizeof(GifFilePrivateType ));
#line 184
  Private = (GifFilePrivateType *)tmp___0;
  }
#line 185
  if (! Private) {
    {
#line 186
    _GifError = 109;
#line 187
    free((void *)((char *)GifFile));
    }
#line 188
    return ((GifFileType *)((void *)0));
  }
#line 191
  GifFile->Private = (void *)Private;
#line 192
  Private->FileHandle = 0;
#line 193
  Private->File = (FILE *)0;
#line 194
  Private->FileState = 8;
#line 196
  Private->Read = readFunc;
#line 197
  GifFile->UserData = userData;
#line 200
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 200
    tmp___1 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, (int )(sizeof("GIFVER") - 1UL));
#line 200
    tmp___3 = (size_t )tmp___1;
    }
  } else {
    {
#line 200
    tmp___2 = fread((void */* __restrict  */)(Buf), (size_t )1, sizeof("GIFVER") - 1UL,
                    (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 200
    tmp___3 = tmp___2;
    }
  }
#line 200
  if (tmp___3 != sizeof("GIFVER") - 1UL) {
    {
#line 201
    _GifError = 102;
#line 202
    free((void *)((char *)Private));
#line 203
    free((void *)((char *)GifFile));
    }
#line 204
    return ((GifFileType *)((void *)0));
  }
  {
#line 209
  Buf[sizeof("GIFVER") - 1UL] = (unsigned char)0;
#line 210
  tmp___4 = strncmp("GIFVER", (char const   *)(Buf), (size_t )3);
  }
#line 210
  if (tmp___4 != 0) {
    {
#line 211
    _GifError = 103;
#line 212
    free((void *)((char *)Private));
#line 213
    free((void *)((char *)GifFile));
    }
#line 214
    return ((GifFileType *)((void *)0));
  }
  {
#line 217
  tmp___5 = DGifGetScreenDesc(GifFile);
  }
#line 217
  if (tmp___5 == 0) {
    {
#line 218
    free((void *)((char *)Private));
#line 219
    free((void *)((char *)GifFile));
    }
#line 220
    return ((GifFileType *)((void *)0));
  }
#line 223
  _GifError = 0;
#line 225
  return (GifFile);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetScreenDesc(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType Buf[3] ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
#line 237
  Private = (GifFilePrivateType *)GifFile->Private;
#line 239
  if (! (Private->FileState & 8)) {
#line 241
    _GifError = 111;
#line 242
    return (0);
  }
  {
#line 246
  tmp = DGifGetWord(GifFile, & GifFile->SWidth);
  }
#line 246
  if (tmp == 0) {
#line 248
    return (0);
  } else {
    {
#line 246
    tmp___0 = DGifGetWord(GifFile, & GifFile->SHeight);
    }
#line 246
    if (tmp___0 == 0) {
#line 248
      return (0);
    }
  }
#line 250
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 250
    tmp___1 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 3);
#line 250
    tmp___3 = (size_t )tmp___1;
    }
  } else {
    {
#line 250
    tmp___2 = fread((void */* __restrict  */)(Buf), (size_t )1, (size_t )3, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 250
    tmp___3 = tmp___2;
    }
  }
#line 250
  if (tmp___3 != 3UL) {
    {
#line 251
    _GifError = 102;
#line 252
    FreeMapObject(GifFile->SColorMap);
#line 253
    GifFile->SColorMap = (ColorMapObject *)((void *)0);
    }
#line 254
    return (0);
  }
#line 256
  GifFile->SColorResolution = ((((int )Buf[0] & 112) + 1) >> 4) + 1;
#line 257
  BitsPerPixel = ((int )Buf[0] & 7) + 1;
#line 258
  GifFile->SBackGroundColor = (GifWord )Buf[1];
#line 259
  if ((int )Buf[0] & 128) {
    {
#line 261
    GifFile->SColorMap = MakeMapObject(1 << BitsPerPixel, (GifColorType const   *)((void *)0));
    }
#line 262
    if ((unsigned long )GifFile->SColorMap == (unsigned long )((void *)0)) {
#line 263
      _GifError = 109;
#line 264
      return (0);
    }
#line 268
    i = 0;
    {
#line 268
    while (1) {
      while_continue: /* CIL Label */ ;
#line 268
      if (! (i < (GifFile->SColorMap)->ColorCount)) {
#line 268
        goto while_break;
      }
#line 269
      if (((GifFilePrivateType *)GifFile->Private)->Read) {
        {
#line 269
        tmp___4 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf,
                                                                      3);
#line 269
        tmp___6 = (size_t )tmp___4;
        }
      } else {
        {
#line 269
        tmp___5 = fread((void */* __restrict  */)(Buf), (size_t )1, (size_t )3, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 269
        tmp___6 = tmp___5;
        }
      }
#line 269
      if (tmp___6 != 3UL) {
        {
#line 270
        FreeMapObject(GifFile->SColorMap);
#line 271
        GifFile->SColorMap = (ColorMapObject *)((void *)0);
#line 272
        _GifError = 102;
        }
#line 273
        return (0);
      }
#line 275
      ((GifFile->SColorMap)->Colors + i)->Red = Buf[0];
#line 276
      ((GifFile->SColorMap)->Colors + i)->Green = Buf[1];
#line 277
      ((GifFile->SColorMap)->Colors + i)->Blue = Buf[2];
#line 268
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 280
    GifFile->SColorMap = (ColorMapObject *)((void *)0);
  }
#line 283
  return (1);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetRecordType(GifFileType *GifFile , GifRecordType *Type ) 
{ 
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 294
  Private = (GifFilePrivateType *)GifFile->Private;
#line 296
  if (! (Private->FileState & 8)) {
#line 298
    _GifError = 111;
#line 299
    return (0);
  }
#line 302
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 302
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & Buf, 1);
#line 302
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 302
    tmp___0 = fread((void */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 302
    tmp___1 = tmp___0;
    }
  }
#line 302
  if (tmp___1 != 1UL) {
#line 303
    _GifError = 102;
#line 304
    return (0);
  }
  {
#line 308
  if ((int )Buf == 44) {
#line 308
    goto case_44;
  }
#line 311
  if ((int )Buf == 33) {
#line 311
    goto case_33;
  }
#line 314
  if ((int )Buf == 59) {
#line 314
    goto case_59;
  }
#line 317
  goto switch_default;
  case_44: /* CIL Label */ 
#line 309
  *Type = (GifRecordType )2;
#line 310
  goto switch_break;
  case_33: /* CIL Label */ 
#line 312
  *Type = (GifRecordType )3;
#line 313
  goto switch_break;
  case_59: /* CIL Label */ 
#line 315
  *Type = (GifRecordType )4;
#line 316
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 318
  *Type = (GifRecordType )0;
#line 319
  _GifError = 107;
#line 320
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 323
  return (1);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetImageDesc(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType Buf[3] ;
  GifFilePrivateType *Private ;
  SavedImage *sp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  struct SavedImage *tmp___9 ;
  void *tmp___10 ;
  struct SavedImage *tmp___11 ;
  void *tmp___12 ;

  {
#line 335
  Private = (GifFilePrivateType *)GifFile->Private;
#line 338
  if (! (Private->FileState & 8)) {
#line 340
    _GifError = 111;
#line 341
    return (0);
  }
  {
#line 344
  tmp = DGifGetWord(GifFile, & GifFile->Image.Left);
  }
#line 344
  if (tmp == 0) {
#line 348
    return (0);
  } else {
    {
#line 344
    tmp___0 = DGifGetWord(GifFile, & GifFile->Image.Top);
    }
#line 344
    if (tmp___0 == 0) {
#line 348
      return (0);
    } else {
      {
#line 344
      tmp___1 = DGifGetWord(GifFile, & GifFile->Image.Width);
      }
#line 344
      if (tmp___1 == 0) {
#line 348
        return (0);
      } else {
        {
#line 344
        tmp___2 = DGifGetWord(GifFile, & GifFile->Image.Height);
        }
#line 344
        if (tmp___2 == 0) {
#line 348
          return (0);
        }
      }
    }
  }
#line 349
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 349
    tmp___3 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 349
    tmp___5 = (size_t )tmp___3;
    }
  } else {
    {
#line 349
    tmp___4 = fread((void */* __restrict  */)(Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 349
    tmp___5 = tmp___4;
    }
  }
#line 349
  if (tmp___5 != 1UL) {
    {
#line 350
    _GifError = 102;
#line 351
    FreeMapObject(GifFile->Image.ColorMap);
#line 352
    GifFile->Image.ColorMap = (ColorMapObject *)((void *)0);
    }
#line 353
    return (0);
  }
#line 355
  BitsPerPixel = ((int )Buf[0] & 7) + 1;
#line 356
  GifFile->Image.Interlace = (int )Buf[0] & 64;
#line 357
  if ((int )Buf[0] & 128) {
#line 361
    if (GifFile->Image.ColorMap) {
#line 361
      if ((unsigned long )GifFile->SavedImages == (unsigned long )((void *)0)) {
        {
#line 362
        FreeMapObject(GifFile->Image.ColorMap);
        }
      }
    }
    {
#line 364
    GifFile->Image.ColorMap = MakeMapObject(1 << BitsPerPixel, (GifColorType const   *)((void *)0));
    }
#line 365
    if ((unsigned long )GifFile->Image.ColorMap == (unsigned long )((void *)0)) {
#line 366
      _GifError = 109;
#line 367
      return (0);
    }
#line 371
    i = 0;
    {
#line 371
    while (1) {
      while_continue: /* CIL Label */ ;
#line 371
      if (! (i < (GifFile->Image.ColorMap)->ColorCount)) {
#line 371
        goto while_break;
      }
#line 372
      if (((GifFilePrivateType *)GifFile->Private)->Read) {
        {
#line 372
        tmp___6 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf,
                                                                      3);
#line 372
        tmp___8 = (size_t )tmp___6;
        }
      } else {
        {
#line 372
        tmp___7 = fread((void */* __restrict  */)(Buf), (size_t )1, (size_t )3, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 372
        tmp___8 = tmp___7;
        }
      }
#line 372
      if (tmp___8 != 3UL) {
        {
#line 373
        FreeMapObject(GifFile->Image.ColorMap);
#line 374
        _GifError = 102;
#line 375
        GifFile->Image.ColorMap = (ColorMapObject *)((void *)0);
        }
#line 376
        return (0);
      }
#line 378
      ((GifFile->Image.ColorMap)->Colors + i)->Red = Buf[0];
#line 379
      ((GifFile->Image.ColorMap)->Colors + i)->Green = Buf[1];
#line 380
      ((GifFile->Image.ColorMap)->Colors + i)->Blue = Buf[2];
#line 371
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 382
  if (GifFile->Image.ColorMap) {
    {
#line 383
    FreeMapObject(GifFile->Image.ColorMap);
#line 384
    GifFile->Image.ColorMap = (ColorMapObject *)((void *)0);
    }
  }
#line 387
  if (GifFile->SavedImages) {
    {
#line 388
    tmp___10 = realloc((void *)GifFile->SavedImages, sizeof(SavedImage ) * (unsigned long )(GifFile->ImageCount + 1));
#line 388
    tmp___9 = (SavedImage *)tmp___10;
#line 388
    GifFile->SavedImages = tmp___9;
    }
#line 388
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
#line 391
      _GifError = 109;
#line 392
      return (0);
    }
  } else {
    {
#line 395
    tmp___12 = malloc(sizeof(SavedImage ));
#line 395
    tmp___11 = (SavedImage *)tmp___12;
#line 395
    GifFile->SavedImages = tmp___11;
    }
#line 395
    if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 397
      _GifError = 109;
#line 398
      return (0);
    }
  }
  {
#line 402
  sp = GifFile->SavedImages + GifFile->ImageCount;
#line 403
  memcpy((void */* __restrict  */)(& sp->ImageDesc), (void const   */* __restrict  */)(& GifFile->Image),
         sizeof(GifImageDesc ));
  }
#line 404
  if ((unsigned long )GifFile->Image.ColorMap != (unsigned long )((void *)0)) {
    {
#line 405
    sp->ImageDesc.ColorMap = MakeMapObject((GifFile->Image.ColorMap)->ColorCount,
                                           (GifColorType const   *)(GifFile->Image.ColorMap)->Colors);
    }
#line 408
    if ((unsigned long )sp->ImageDesc.ColorMap == (unsigned long )((void *)0)) {
#line 409
      _GifError = 109;
#line 410
      return (0);
    }
  }
  {
#line 413
  sp->RasterBits = (unsigned char *)((void *)0);
#line 414
  sp->ExtensionBlockCount = 0;
#line 415
  sp->ExtensionBlocks = (ExtensionBlock *)((void *)0);
#line 417
  (GifFile->ImageCount) ++;
#line 419
  Private->PixelCount = (unsigned long )((long )GifFile->Image.Width * (long )GifFile->Image.Height);
#line 422
  DGifSetupDecompress(GifFile);
  }
#line 424
  return (1);
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetLine(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  GifByteType *Dummy ;
  GifFilePrivateType *Private ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 436
  Private = (GifFilePrivateType *)GifFile->Private;
#line 438
  if (! (Private->FileState & 8)) {
#line 440
    _GifError = 111;
#line 441
    return (0);
  }
#line 444
  if (! LineLen) {
#line 445
    LineLen = GifFile->Image.Width;
  }
#line 448
  tmp = Private->PixelCount - (unsigned long )LineLen;
#line 448
  Private->PixelCount = tmp;
#line 448
  if (tmp > 4294901760UL) {
#line 452
    _GifError = 108;
#line 453
    return (0);
  }
  {
#line 456
  tmp___1 = DGifDecompressLine(GifFile, Line, LineLen);
  }
#line 456
  if (tmp___1 == 1) {
#line 457
    if (Private->PixelCount == 0UL) {
      {
#line 461
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 462
        tmp___0 = DGifGetCodeNext(GifFile, & Dummy);
        }
#line 462
        if (tmp___0 == 0) {
#line 463
          return (0);
        }
#line 461
        if (! ((unsigned long )Dummy != (unsigned long )((void *)0))) {
#line 461
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 466
    return (1);
  } else {
#line 468
    return (0);
  }
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetPixel(GifFileType *GifFile , GifPixelType Pixel ) 
{ 
  GifByteType *Dummy ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;

  {
#line 479
  Private = (GifFilePrivateType *)GifFile->Private;
#line 481
  if (! (Private->FileState & 8)) {
#line 483
    _GifError = 111;
#line 484
    return (0);
  }
#line 487
  (Private->PixelCount) --;
#line 487
  if (Private->PixelCount > 4294901760UL) {
#line 492
    _GifError = 108;
#line 493
    return (0);
  }
  {
#line 496
  tmp___0 = DGifDecompressLine(GifFile, & Pixel, 1);
  }
#line 496
  if (tmp___0 == 1) {
#line 497
    if (Private->PixelCount == 0UL) {
      {
#line 501
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 502
        tmp = DGifGetCodeNext(GifFile, & Dummy);
        }
#line 502
        if (tmp == 0) {
#line 503
          return (0);
        }
#line 501
        if (! ((unsigned long )Dummy != (unsigned long )((void *)0))) {
#line 501
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 506
    return (1);
  } else {
#line 508
    return (0);
  }
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetExtension(GifFileType *GifFile , int *ExtCode , GifByteType **Extension ) 
{ 
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 524
  Private = (GifFilePrivateType *)GifFile->Private;
#line 526
  if (! (Private->FileState & 8)) {
#line 528
    _GifError = 111;
#line 529
    return (0);
  }
#line 532
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 532
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & Buf, 1);
#line 532
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 532
    tmp___0 = fread((void */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 532
    tmp___1 = tmp___0;
    }
  }
#line 532
  if (tmp___1 != 1UL) {
#line 533
    _GifError = 102;
#line 534
    return (0);
  }
  {
#line 536
  *ExtCode = (int )Buf;
#line 538
  tmp___2 = DGifGetExtensionNext(GifFile, Extension);
  }
#line 538
  return (tmp___2);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetExtensionNext(GifFileType *GifFile , GifByteType **Extension ) 
{ 
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 551
  Private = (GifFilePrivateType *)GifFile->Private;
#line 553
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 553
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & Buf, 1);
#line 553
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 553
    tmp___0 = fread((void */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 553
    tmp___1 = tmp___0;
    }
  }
#line 553
  if (tmp___1 != 1UL) {
#line 554
    _GifError = 102;
#line 555
    return (0);
  }
#line 557
  if ((int )Buf > 0) {
#line 558
    *Extension = Private->Buf;
#line 559
    *(*Extension + 0) = Buf;
#line 560
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 560
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, *Extension + 1,
                                                                    (int )Buf);
#line 560
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 560
      tmp___3 = fread((void */* __restrict  */)(*Extension + 1), (size_t )1, (size_t )Buf,
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 560
      tmp___4 = tmp___3;
      }
    }
#line 560
    if (tmp___4 != (size_t )Buf) {
#line 561
      _GifError = 102;
#line 562
      return (0);
    }
  } else {
#line 565
    *Extension = (GifByteType *)((void *)0);
  }
#line 567
  return (1);
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifCloseFile(GifFileType *GifFile ) 
{ 
  GifFilePrivateType *Private ;
  FILE *File ;
  int tmp ;

  {
#line 579
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
#line 580
    return (0);
  }
#line 582
  Private = (GifFilePrivateType *)GifFile->Private;
#line 584
  if (! (Private->FileState & 8)) {
#line 586
    _GifError = 111;
#line 587
    return (0);
  }
#line 590
  File = Private->File;
#line 592
  if (GifFile->Image.ColorMap) {
    {
#line 593
    FreeMapObject(GifFile->Image.ColorMap);
#line 594
    GifFile->Image.ColorMap = (ColorMapObject *)((void *)0);
    }
  }
#line 597
  if (GifFile->SColorMap) {
    {
#line 598
    FreeMapObject(GifFile->SColorMap);
#line 599
    GifFile->SColorMap = (ColorMapObject *)((void *)0);
    }
  }
#line 602
  if (Private) {
    {
#line 603
    free((void *)((char *)Private));
#line 604
    Private = (GifFilePrivateType *)((void *)0);
    }
  }
#line 607
  if (GifFile->SavedImages) {
    {
#line 608
    FreeSavedImages(GifFile);
#line 609
    GifFile->SavedImages = (struct SavedImage *)((void *)0);
    }
  }
  {
#line 612
  free((void *)GifFile);
  }
#line 614
  if (File) {
    {
#line 614
    tmp = fclose(File);
    }
#line 614
    if (tmp != 0) {
#line 615
      _GifError = 110;
#line 616
      return (0);
    }
  }
#line 618
  return (1);
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetCode(GifFileType *GifFile , int *CodeSize , GifByteType **CodeBlock ) 
{ 
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 651
  Private = (GifFilePrivateType *)GifFile->Private;
#line 653
  if (! (Private->FileState & 8)) {
#line 655
    _GifError = 111;
#line 656
    return (0);
  }
  {
#line 659
  *CodeSize = Private->BitsPerPixel;
#line 661
  tmp = DGifGetCodeNext(GifFile, CodeBlock);
  }
#line 661
  return (tmp);
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetCodeNext(GifFileType *GifFile , GifByteType **CodeBlock ) 
{ 
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 674
  Private = (GifFilePrivateType *)GifFile->Private;
#line 676
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 676
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & Buf, 1);
#line 676
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 676
    tmp___0 = fread((void */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 676
    tmp___1 = tmp___0;
    }
  }
#line 676
  if (tmp___1 != 1UL) {
#line 677
    _GifError = 102;
#line 678
    return (0);
  }
#line 681
  if ((int )Buf > 0) {
#line 682
    *CodeBlock = Private->Buf;
#line 683
    *(*CodeBlock + 0) = Buf;
#line 684
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 684
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, *CodeBlock + 1,
                                                                    (int )Buf);
#line 684
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 684
      tmp___3 = fread((void */* __restrict  */)(*CodeBlock + 1), (size_t )1, (size_t )Buf,
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 684
      tmp___4 = tmp___3;
      }
    }
#line 684
    if (tmp___4 != (size_t )Buf) {
#line 685
      _GifError = 102;
#line 686
      return (0);
    }
  } else {
#line 689
    *CodeBlock = (GifByteType *)((void *)0);
#line 690
    Private->Buf[0] = (GifByteType )0;
#line 691
    Private->PixelCount = 0UL;
  }
#line 694
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 889 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifGetLZCodes(GifFileType *GifFile , int *Code ) 
{ 
  GifByteType *CodeBlock ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;

  {
#line 894
  Private = (GifFilePrivateType *)GifFile->Private;
#line 896
  if (! (Private->FileState & 8)) {
#line 898
    _GifError = 111;
#line 899
    return (0);
  }
  {
#line 902
  tmp = DGifDecompressInput(GifFile, Code);
  }
#line 902
  if (tmp == 0) {
#line 903
    return (0);
  }
#line 905
  if (*Code == Private->EOFCode) {
    {
#line 907
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 908
      tmp___0 = DGifGetCodeNext(GifFile, & CodeBlock);
      }
#line 908
      if (tmp___0 == 0) {
#line 909
        return (0);
      }
#line 907
      if (! ((unsigned long )CodeBlock != (unsigned long )((void *)0))) {
#line 907
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 912
    *Code = -1;
  } else
#line 913
  if (*Code == Private->ClearCode) {
#line 915
    Private->RunningCode = Private->EOFCode + 1;
#line 916
    Private->RunningBits = Private->BitsPerPixel + 1;
#line 917
    Private->MaxCode1 = 1 << Private->RunningBits;
  }
#line 920
  return (1);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
int DGifSlurp(GifFileType *GifFile ) 
{ 
  int ImageSize ;
  GifRecordType RecordType ;
  SavedImage *sp ;
  GifByteType *ExtData ;
  SavedImage temp_save ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1039
  temp_save.ExtensionBlocks = (ExtensionBlock *)((void *)0);
#line 1040
  temp_save.ExtensionBlockCount = 0;
  {
#line 1042
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1043
    tmp = DGifGetRecordType(GifFile, & RecordType);
    }
#line 1043
    if (tmp == 0) {
#line 1044
      return (0);
    }
    {
#line 1047
    if ((unsigned int )RecordType == 2U) {
#line 1047
      goto case_2;
    }
#line 1076
    if ((unsigned int )RecordType == 3U) {
#line 1076
      goto case_3;
    }
#line 1093
    if ((unsigned int )RecordType == 4U) {
#line 1093
      goto case_4;
    }
#line 1096
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 1048
    tmp___0 = DGifGetImageDesc(GifFile);
    }
#line 1048
    if (tmp___0 == 0) {
#line 1049
      return (0);
    }
    {
#line 1051
    sp = GifFile->SavedImages + (GifFile->ImageCount - 1);
#line 1052
    ImageSize = sp->ImageDesc.Width * sp->ImageDesc.Height;
#line 1054
    tmp___1 = malloc((unsigned long )ImageSize * sizeof(GifPixelType ));
#line 1054
    sp->RasterBits = (unsigned char *)tmp___1;
    }
#line 1056
    if ((unsigned long )sp->RasterBits == (unsigned long )((void *)0)) {
#line 1057
      return (0);
    }
    {
#line 1059
    tmp___2 = DGifGetLine(GifFile, sp->RasterBits, ImageSize);
    }
#line 1059
    if (tmp___2 == 0) {
#line 1061
      return (0);
    }
#line 1062
    if (temp_save.ExtensionBlocks) {
#line 1063
      sp->ExtensionBlocks = temp_save.ExtensionBlocks;
#line 1064
      sp->ExtensionBlockCount = temp_save.ExtensionBlockCount;
#line 1066
      temp_save.ExtensionBlocks = (ExtensionBlock *)((void *)0);
#line 1067
      temp_save.ExtensionBlockCount = 0;
#line 1072
      sp->Function = (sp->ExtensionBlocks + 0)->Function;
    }
#line 1074
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1077
    tmp___3 = DGifGetExtension(GifFile, & temp_save.Function, & ExtData);
    }
#line 1077
    if (tmp___3 == 0) {
#line 1079
      return (0);
    }
    {
#line 1080
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1080
      if (! ((unsigned long )ExtData != (unsigned long )((void *)0))) {
#line 1080
        goto while_break___0;
      }
      {
#line 1083
      tmp___4 = AddExtensionBlock(& temp_save, (int )*(ExtData + 0), ExtData + 1);
      }
#line 1083
      if (tmp___4 == 0) {
#line 1085
        return (0);
      }
      {
#line 1087
      tmp___5 = DGifGetExtensionNext(GifFile, & ExtData);
      }
#line 1087
      if (tmp___5 == 0) {
#line 1088
        return (0);
      }
#line 1089
      temp_save.Function = 0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1091
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1094
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1097
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1042
    if (! ((unsigned int )RecordType != 4U)) {
#line 1042
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1105
  if (temp_save.ExtensionBlocks) {
    {
#line 1106
    FreeExtension(& temp_save);
    }
  }
#line 1108
  return (1);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
void PrintGifError(void) ;
#line 245
int GifLastError(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_err.c"
int _GifError  =    0;
#line 24 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_err.c"
int GifLastError(void) 
{ 
  int i ;

  {
#line 26
  i = _GifError;
#line 28
  _GifError = 0;
#line 30
  return (i);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_err.c"
void PrintGifError(void) 
{ 
  char *Err ;

  {
  {
#line 42
  if (_GifError == 1) {
#line 42
    goto case_1;
  }
#line 45
  if (_GifError == 2) {
#line 45
    goto case_2;
  }
#line 48
  if (_GifError == 3) {
#line 48
    goto case_3;
  }
#line 51
  if (_GifError == 4) {
#line 51
    goto case_4;
  }
#line 54
  if (_GifError == 5) {
#line 54
    goto case_5;
  }
#line 57
  if (_GifError == 6) {
#line 57
    goto case_6;
  }
#line 60
  if (_GifError == 7) {
#line 60
    goto case_7;
  }
#line 63
  if (_GifError == 8) {
#line 63
    goto case_8;
  }
#line 66
  if (_GifError == 9) {
#line 66
    goto case_9;
  }
#line 69
  if (_GifError == 10) {
#line 69
    goto case_10;
  }
#line 72
  if (_GifError == 101) {
#line 72
    goto case_101;
  }
#line 75
  if (_GifError == 102) {
#line 75
    goto case_102;
  }
#line 78
  if (_GifError == 103) {
#line 78
    goto case_103;
  }
#line 81
  if (_GifError == 104) {
#line 81
    goto case_104;
  }
#line 84
  if (_GifError == 105) {
#line 84
    goto case_105;
  }
#line 87
  if (_GifError == 106) {
#line 87
    goto case_106;
  }
#line 90
  if (_GifError == 107) {
#line 90
    goto case_107;
  }
#line 93
  if (_GifError == 108) {
#line 93
    goto case_108;
  }
#line 96
  if (_GifError == 109) {
#line 96
    goto case_109;
  }
#line 99
  if (_GifError == 110) {
#line 99
    goto case_110;
  }
#line 102
  if (_GifError == 111) {
#line 102
    goto case_111;
  }
#line 105
  if (_GifError == 112) {
#line 105
    goto case_112;
  }
#line 108
  if (_GifError == 113) {
#line 108
    goto case_113;
  }
#line 111
  goto switch_default;
  case_1: /* CIL Label */ 
#line 43
  Err = (char *)"Failed to open given file";
#line 44
  goto switch_break;
  case_2: /* CIL Label */ 
#line 46
  Err = (char *)"Failed to Write to given file";
#line 47
  goto switch_break;
  case_3: /* CIL Label */ 
#line 49
  Err = (char *)"Screen Descriptor already been set";
#line 50
  goto switch_break;
  case_4: /* CIL Label */ 
#line 52
  Err = (char *)"Image Descriptor is still active";
#line 53
  goto switch_break;
  case_5: /* CIL Label */ 
#line 55
  Err = (char *)"Neither Global Nor Local color map";
#line 56
  goto switch_break;
  case_6: /* CIL Label */ 
#line 58
  Err = (char *)"#Pixels bigger than Width * Height";
#line 59
  goto switch_break;
  case_7: /* CIL Label */ 
#line 61
  Err = (char *)"Fail to allocate required memory";
#line 62
  goto switch_break;
  case_8: /* CIL Label */ 
#line 64
  Err = (char *)"Write failed (disk full?)";
#line 65
  goto switch_break;
  case_9: /* CIL Label */ 
#line 67
  Err = (char *)"Failed to close given file";
#line 68
  goto switch_break;
  case_10: /* CIL Label */ 
#line 70
  Err = (char *)"Given file was not opened for write";
#line 71
  goto switch_break;
  case_101: /* CIL Label */ 
#line 73
  Err = (char *)"Failed to open given file";
#line 74
  goto switch_break;
  case_102: /* CIL Label */ 
#line 76
  Err = (char *)"Failed to Read from given file";
#line 77
  goto switch_break;
  case_103: /* CIL Label */ 
#line 79
  Err = (char *)"Given file is NOT GIF file";
#line 80
  goto switch_break;
  case_104: /* CIL Label */ 
#line 82
  Err = (char *)"No Screen Descriptor detected";
#line 83
  goto switch_break;
  case_105: /* CIL Label */ 
#line 85
  Err = (char *)"No Image Descriptor detected";
#line 86
  goto switch_break;
  case_106: /* CIL Label */ 
#line 88
  Err = (char *)"Neither Global Nor Local color map";
#line 89
  goto switch_break;
  case_107: /* CIL Label */ 
#line 91
  Err = (char *)"Wrong record type detected";
#line 92
  goto switch_break;
  case_108: /* CIL Label */ 
#line 94
  Err = (char *)"#Pixels bigger than Width * Height";
#line 95
  goto switch_break;
  case_109: /* CIL Label */ 
#line 97
  Err = (char *)"Fail to allocate required memory";
#line 98
  goto switch_break;
  case_110: /* CIL Label */ 
#line 100
  Err = (char *)"Failed to close given file";
#line 101
  goto switch_break;
  case_111: /* CIL Label */ 
#line 103
  Err = (char *)"Given file was not opened for read";
#line 104
  goto switch_break;
  case_112: /* CIL Label */ 
#line 106
  Err = (char *)"Image is defective, decoding aborted";
#line 107
  goto switch_break;
  case_113: /* CIL Label */ 
#line 109
  Err = (char *)"Image EOF detected, before image complete";
#line 110
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 112
  Err = (char *)((void *)0);
#line 113
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 115
  if ((unsigned long )Err != (unsigned long )((void *)0)) {
    {
#line 116
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGIF-LIB error: %s.\n",
            Err);
    }
  } else {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGIF-LIB undefined error %d.\n",
            _GifError);
    }
  }
#line 119
  return;
}
}
#line 1468 "/usr/include/X11/Xlib.h"
extern XImage *XGetImage(Display * , Drawable  , int  , int  , unsigned int  , unsigned int  ,
                         unsigned long  , int  ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2975
extern int XQueryColors(Display * , Colormap  , XColor * , int  ) ;
#line 250 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
int DumpScreen2Gif(char const   *FileName , int ReqGraphDriver , long ReqGraphMode1 ,
                   long ReqGraphMode2 , long ReqGraphMode3 ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax  =    100L;
#line 53 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
GifByteType *GlblGifBuffer  =    (GifByteType *)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
GifByteType *GlblGifBufferPtr  =    (GifByteType *)((void *)0);
#line 62
static void GetScanLine(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError(GifFileType *GifFile ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
int DumpScreen2Gif(char const   *FileName , int ReqGraphDriver , long ReqGraphMode1 ,
                   long ReqGraphMode2 , long ReqGraphMode3 ) 
{ 
  int i ;
  int j ;
  int k ;
  GifPixelType *ScanLine___0 ;
  GifFileType *GifFile ;
  ColorMapObject *ColorMap___3 ;
  XImage *XImg ;
  unsigned long XPixel ;
  GifColorType ColorMap256[256] ;
  XColor XColorTable___0[256] ;
  XWindowAttributes WinAttr ;
  void *tmp ;
  GifByteType tmp___0 ;
  GifByteType tmp___1 ;
  int tmp___2 ;
  GifByteType *tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 97
  ColorMap___3 = (ColorMapObject *)((void *)0);
  {
#line 252
  if (ReqGraphDriver == 1001) {
#line 252
    goto case_1001;
  }
#line 317
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 253
  XGetWindowAttributes((Display *)ReqGraphMode2, (Window )ReqGraphMode1, & WinAttr);
#line 255
  ScreenXMax = (long )WinAttr.width;
#line 256
  ScreenYMax = (long )WinAttr.height;
#line 258
  XImg = XGetImage((Display *)ReqGraphMode2, (Window )ReqGraphMode1, 0, 0, (unsigned int )(ScreenXMax - 1L),
                   (unsigned int )(ScreenYMax - 1L), (unsigned long )(~ 0L), 1);
#line 263
  tmp = malloc((sizeof(GifByteType ) * (unsigned long )ScreenXMax) * (unsigned long )ScreenYMax);
#line 263
  GlblGifBuffer = (GifByteType *)tmp;
#line 267
  i = 0;
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (i < 256)) {
#line 267
      goto while_break;
    }
#line 268
    XColorTable___0[i].pixel = 0UL;
#line 267
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  k = 0;
#line 270
  i = 0;
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 270
    if (! ((long )i < ScreenXMax)) {
#line 270
      goto while_break___0;
    }
#line 271
    j = 0;
    {
#line 271
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 271
      if (! ((long )j < ScreenYMax)) {
#line 271
        goto while_break___1;
      }
      {
#line 272
      XPixel = (*(XImg->f.get_pixel))(XImg, i, j);
      }
#line 273
      if (XPixel > 255UL) {
#line 274
        if (! k) {
          {
#line 276
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"X Color table - truncated.\n");
#line 277
          k = 1;
          }
        }
#line 279
        XPixel = 255UL;
      }
#line 281
      XColorTable___0[XPixel].pixel = XPixel;
#line 271
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 270
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 284
  XQueryColors((Display *)ReqGraphMode2, (Colormap )ReqGraphMode3, XColorTable___0,
               256);
#line 288
  ColorMap___3 = MakeMapObject(256, (GifColorType const   *)(ColorMap256));
#line 289
  tmp___1 = (GifByteType )0;
#line 289
  (ColorMap___3->Colors + 0)->Blue = tmp___1;
#line 289
  tmp___0 = tmp___1;
#line 289
  (ColorMap___3->Colors + 0)->Green = tmp___0;
#line 289
  (ColorMap___3->Colors + 0)->Red = tmp___0;
#line 291
  j = 1;
#line 291
  i = j;
  }
  {
#line 291
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 291
    if (! (i < 256)) {
#line 291
      goto while_break___2;
    }
#line 292
    if (XColorTable___0[i].pixel) {
#line 293
      (ColorMap___3->Colors + j)->Red = (GifByteType )((int )XColorTable___0[i].red / 256);
#line 294
      (ColorMap___3->Colors + j)->Green = (GifByteType )((int )XColorTable___0[i].green / 256);
#line 295
      (ColorMap___3->Colors + j)->Blue = (GifByteType )((int )XColorTable___0[i].blue / 256);
#line 297
      tmp___2 = j;
#line 297
      j ++;
#line 297
      XColorTable___0[i].pixel = (unsigned long )tmp___2;
    }
#line 291
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 300
  ScreenColorBits = 1;
  {
#line 300
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 300
    if (1 << ScreenColorBits < j) {
#line 300
      if (! (ScreenColorBits < 8)) {
#line 300
        goto while_break___3;
      }
    } else {
#line 300
      goto while_break___3;
    }
#line 300
    ScreenColorBits ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 306
  GlblGifBufferPtr = GlblGifBuffer;
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 307
    if (! ((long )i < ScreenXMax)) {
#line 307
      goto while_break___4;
    }
#line 308
    j = 0;
    {
#line 308
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 308
      if (! ((long )j < ScreenYMax)) {
#line 308
        goto while_break___5;
      }
      {
#line 309
      tmp___3 = GlblGifBufferPtr;
#line 309
      GlblGifBufferPtr ++;
#line 309
      tmp___4 = (*(XImg->f.get_pixel))(XImg, j, i);
#line 309
      *tmp___3 = (GifByteType )XColorTable___0[tmp___4 & 255UL].pixel;
#line 308
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 311
  (*(XImg->f.destroy_image))(XImg);
#line 313
  GlblGifBufferPtr = GlblGifBuffer;
#line 314
  ColorMap___3 = MakeMapObject(256, (GifColorType const   *)(ColorMap256));
  }
#line 315
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 318
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 321
  tmp___5 = malloc(sizeof(GifPixelType ) * (unsigned long )ScreenXMax);
#line 321
  ScanLine___0 = (GifPixelType *)tmp___5;
#line 323
  GraphDriver = ReqGraphDriver;
#line 324
  GraphMode = (int )ReqGraphMode1;
#line 326
  GifFile = EGifOpenFileName(FileName, 0);
  }
#line 326
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
    {
#line 331
    free((void *)((char *)ScanLine___0));
#line 333
    free((void *)((char *)GlblGifBuffer));
#line 335
    tmp___6 = HandleGifError(GifFile);
    }
#line 335
    return (tmp___6);
  } else {
    {
#line 326
    tmp___7 = EGifPutScreenDesc(GifFile, (int )ScreenXMax, (int )ScreenYMax, ScreenColorBits,
                                0, (ColorMapObject const   *)ColorMap___3);
    }
#line 326
    if (tmp___7 == 0) {
      {
#line 331
      free((void *)((char *)ScanLine___0));
#line 333
      free((void *)((char *)GlblGifBuffer));
#line 335
      tmp___6 = HandleGifError(GifFile);
      }
#line 335
      return (tmp___6);
    } else {
      {
#line 326
      tmp___8 = EGifPutImageDesc(GifFile, 0, 0, (int )ScreenXMax, (int )ScreenYMax,
                                 0, (ColorMapObject const   *)((void *)0));
      }
#line 326
      if (tmp___8 == 0) {
        {
#line 331
        free((void *)((char *)ScanLine___0));
#line 333
        free((void *)((char *)GlblGifBuffer));
#line 335
        tmp___6 = HandleGifError(GifFile);
        }
#line 335
        return (tmp___6);
      }
    }
  }
#line 338
  i = 0;
  {
#line 338
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 338
    if (! ((long )i < ScreenYMax)) {
#line 338
      goto while_break___6;
    }
    {
#line 339
    GetScanLine(ScanLine___0, i);
#line 340
    tmp___10 = EGifPutLine(GifFile, ScanLine___0, (int )ScreenXMax);
    }
#line 340
    if (tmp___10 == 0) {
      {
#line 341
      free((void *)((char *)ScanLine___0));
#line 343
      free((void *)((char *)GlblGifBuffer));
#line 345
      tmp___9 = HandleGifError(GifFile);
      }
#line 345
      return (tmp___9);
    }
#line 338
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 349
  tmp___12 = EGifCloseFile(GifFile);
  }
#line 349
  if (tmp___12 == 0) {
    {
#line 350
    free((void *)((char *)ScanLine___0));
#line 352
    free((void *)((char *)GlblGifBuffer));
#line 354
    tmp___11 = HandleGifError(GifFile);
    }
#line 354
    return (tmp___11);
  }
  {
#line 357
  free((void *)((char *)ScanLine___0));
#line 359
  free((void *)((char *)GlblGifBuffer));
  }
#line 361
  return (0);
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 310 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_lib.h"
unsigned char AsciiTable[128][8] ;
#line 315
void DrawText(SavedImage *Image , int const   x , int const   y , char const   *legend ,
              int const   color ) ;
#line 320
void DrawBox(SavedImage *Image , int const   x , int const   y , int const   w , int const   d ,
             int const   color ) ;
#line 324
void DrawRectangle(SavedImage *Image , int const   x , int const   y , int const   w ,
                   int const   d , int const   color ) ;
#line 328
void DrawBoxedText(SavedImage *Image , int const   x , int const   y , char const   *legend ,
                   int const   border , int const   bg , int const   fg ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_font.c"
unsigned char AsciiTable[128][8]  = 
#line 29 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_font.c"
  { {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)60,        (unsigned char)66,        (unsigned char)165,        (unsigned char)129, 
            (unsigned char)189,        (unsigned char)66,        (unsigned char)60,        (unsigned char)0}, 
   {        (unsigned char)60,        (unsigned char)126,        (unsigned char)219,        (unsigned char)255, 
            (unsigned char)195,        (unsigned char)126,        (unsigned char)60,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)238,        (unsigned char)254,        (unsigned char)254, 
            (unsigned char)124,        (unsigned char)56,        (unsigned char)16,        (unsigned char)0}, 
   {        (unsigned char)16,        (unsigned char)56,        (unsigned char)124,        (unsigned char)254, 
            (unsigned char)124,        (unsigned char)56,        (unsigned char)16,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)60,        (unsigned char)24,        (unsigned char)255, 
            (unsigned char)255,        (unsigned char)8,        (unsigned char)24,        (unsigned char)0}, 
   {        (unsigned char)16,        (unsigned char)56,        (unsigned char)124,        (unsigned char)254, 
            (unsigned char)254,        (unsigned char)16,        (unsigned char)56,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)24,        (unsigned char)60, 
            (unsigned char)24,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)255,        (unsigned char)255,        (unsigned char)231,        (unsigned char)195, 
            (unsigned char)231,        (unsigned char)255,        (unsigned char)255,        (unsigned char)255}, 
   {        (unsigned char)0,        (unsigned char)60,        (unsigned char)66,        (unsigned char)129, 
            (unsigned char)129,        (unsigned char)66,        (unsigned char)60,        (unsigned char)0}, 
   {        (unsigned char)255,        (unsigned char)195,        (unsigned char)189,        (unsigned char)126, 
            (unsigned char)126,        (unsigned char)189,        (unsigned char)195,        (unsigned char)255}, 
   {        (unsigned char)31,        (unsigned char)7,        (unsigned char)13,        (unsigned char)124, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)126,        (unsigned char)195,        (unsigned char)195, 
            (unsigned char)126,        (unsigned char)24,        (unsigned char)126,        (unsigned char)24}, 
   {        (unsigned char)4,        (unsigned char)6,        (unsigned char)7,        (unsigned char)4, 
            (unsigned char)4,        (unsigned char)252,        (unsigned char)248,        (unsigned char)0}, 
   {        (unsigned char)12,        (unsigned char)10,        (unsigned char)13,        (unsigned char)11, 
            (unsigned char)249,        (unsigned char)249,        (unsigned char)31,        (unsigned char)31}, 
   {        (unsigned char)0,        (unsigned char)146,        (unsigned char)124,        (unsigned char)68, 
            (unsigned char)198,        (unsigned char)124,        (unsigned char)146,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)96,        (unsigned char)120, 
            (unsigned char)126,        (unsigned char)120,        (unsigned char)96,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)6,        (unsigned char)30, 
            (unsigned char)126,        (unsigned char)30,        (unsigned char)6,        (unsigned char)0}, 
   {        (unsigned char)24,        (unsigned char)126,        (unsigned char)24,        (unsigned char)24, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)126,        (unsigned char)24}, 
   {        (unsigned char)102,        (unsigned char)102,        (unsigned char)102,        (unsigned char)102, 
            (unsigned char)102,        (unsigned char)0,        (unsigned char)102,        (unsigned char)0}, 
   {        (unsigned char)255,        (unsigned char)182,        (unsigned char)118,        (unsigned char)54, 
            (unsigned char)54,        (unsigned char)54,        (unsigned char)54,        (unsigned char)0}, 
   {        (unsigned char)126,        (unsigned char)193,        (unsigned char)220,        (unsigned char)34, 
            (unsigned char)34,        (unsigned char)31,        (unsigned char)131,        (unsigned char)126}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)126, 
            (unsigned char)126,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)24,        (unsigned char)126,        (unsigned char)24,        (unsigned char)24, 
            (unsigned char)126,        (unsigned char)24,        (unsigned char)0,        (unsigned char)255}, 
   {        (unsigned char)24,        (unsigned char)126,        (unsigned char)24,        (unsigned char)24, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)24,        (unsigned char)0}, 
   {        (unsigned char)24,        (unsigned char)24,        (unsigned char)24,        (unsigned char)24, 
            (unsigned char)24,        (unsigned char)126,        (unsigned char)24,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)4,        (unsigned char)6,        (unsigned char)255, 
            (unsigned char)6,        (unsigned char)4,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)32,        (unsigned char)96,        (unsigned char)255, 
            (unsigned char)96,        (unsigned char)32,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)192, 
            (unsigned char)192,        (unsigned char)192,        (unsigned char)255,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)36,        (unsigned char)102,        (unsigned char)255, 
            (unsigned char)102,        (unsigned char)36,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)16,        (unsigned char)56, 
            (unsigned char)124,        (unsigned char)254,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)254, 
            (unsigned char)124,        (unsigned char)56,        (unsigned char)16,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)48,        (unsigned char)48,        (unsigned char)48,        (unsigned char)48, 
            (unsigned char)48,        (unsigned char)0,        (unsigned char)48,        (unsigned char)0}, 
   {        (unsigned char)102,        (unsigned char)102,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)108,        (unsigned char)108,        (unsigned char)254,        (unsigned char)108, 
            (unsigned char)254,        (unsigned char)108,        (unsigned char)108,        (unsigned char)0}, 
   {        (unsigned char)16,        (unsigned char)124,        (unsigned char)210,        (unsigned char)124, 
            (unsigned char)134,        (unsigned char)124,        (unsigned char)16,        (unsigned char)0}, 
   {        (unsigned char)240,        (unsigned char)150,        (unsigned char)252,        (unsigned char)24, 
            (unsigned char)62,        (unsigned char)114,        (unsigned char)222,        (unsigned char)0}, 
   {        (unsigned char)48,        (unsigned char)72,        (unsigned char)48,        (unsigned char)120, 
            (unsigned char)206,        (unsigned char)204,        (unsigned char)120,        (unsigned char)0}, 
   {        (unsigned char)12,        (unsigned char)12,        (unsigned char)24,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)16,        (unsigned char)96,        (unsigned char)192,        (unsigned char)192, 
            (unsigned char)192,        (unsigned char)96,        (unsigned char)16,        (unsigned char)0}, 
   {        (unsigned char)16,        (unsigned char)12,        (unsigned char)6,        (unsigned char)6, 
            (unsigned char)6,        (unsigned char)12,        (unsigned char)16,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)84,        (unsigned char)56,        (unsigned char)254, 
            (unsigned char)56,        (unsigned char)84,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)24,        (unsigned char)24,        (unsigned char)126, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)24,        (unsigned char)112}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)126, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)24,        (unsigned char)0}, 
   {        (unsigned char)2,        (unsigned char)6,        (unsigned char)12,        (unsigned char)24, 
            (unsigned char)48,        (unsigned char)96,        (unsigned char)192,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)24,        (unsigned char)56,        (unsigned char)120,        (unsigned char)24, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)60,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)6,        (unsigned char)12, 
            (unsigned char)48,        (unsigned char)96,        (unsigned char)254,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)6,        (unsigned char)60, 
            (unsigned char)6,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)14,        (unsigned char)30,        (unsigned char)54,        (unsigned char)102, 
            (unsigned char)254,        (unsigned char)6,        (unsigned char)6,        (unsigned char)0}, 
   {        (unsigned char)254,        (unsigned char)192,        (unsigned char)192,        (unsigned char)252, 
            (unsigned char)6,        (unsigned char)6,        (unsigned char)252,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)192,        (unsigned char)252, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)254,        (unsigned char)6,        (unsigned char)12,        (unsigned char)24, 
            (unsigned char)48,        (unsigned char)96,        (unsigned char)96,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)198,        (unsigned char)124, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)198,        (unsigned char)126, 
            (unsigned char)6,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)48,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)48,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)48,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)48,        (unsigned char)32,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)28,        (unsigned char)48,        (unsigned char)96, 
            (unsigned char)48,        (unsigned char)28,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)126,        (unsigned char)0, 
            (unsigned char)126,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)112,        (unsigned char)24,        (unsigned char)12, 
            (unsigned char)24,        (unsigned char)112,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)12,        (unsigned char)24, 
            (unsigned char)48,        (unsigned char)0,        (unsigned char)48,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)130,        (unsigned char)154,        (unsigned char)170, 
            (unsigned char)170,        (unsigned char)158,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)56,        (unsigned char)108,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)254,        (unsigned char)198,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)252,        (unsigned char)198,        (unsigned char)198,        (unsigned char)252, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)252,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)198,        (unsigned char)192, 
            (unsigned char)192,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)248,        (unsigned char)204,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)204,        (unsigned char)248,        (unsigned char)0}, 
   {        (unsigned char)254,        (unsigned char)192,        (unsigned char)192,        (unsigned char)252, 
            (unsigned char)192,        (unsigned char)192,        (unsigned char)254,        (unsigned char)0}, 
   {        (unsigned char)254,        (unsigned char)192,        (unsigned char)192,        (unsigned char)252, 
            (unsigned char)192,        (unsigned char)192,        (unsigned char)192,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)192,        (unsigned char)206, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)126,        (unsigned char)0}, 
   {        (unsigned char)198,        (unsigned char)198,        (unsigned char)198,        (unsigned char)254, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)120,        (unsigned char)48,        (unsigned char)48,        (unsigned char)48, 
            (unsigned char)48,        (unsigned char)48,        (unsigned char)120,        (unsigned char)0}, 
   {        (unsigned char)30,        (unsigned char)6,        (unsigned char)6,        (unsigned char)6, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)198,        (unsigned char)204,        (unsigned char)216,        (unsigned char)240, 
            (unsigned char)216,        (unsigned char)204,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)192,        (unsigned char)192,        (unsigned char)192,        (unsigned char)192, 
            (unsigned char)192,        (unsigned char)192,        (unsigned char)254,        (unsigned char)0}, 
   {        (unsigned char)198,        (unsigned char)238,        (unsigned char)254,        (unsigned char)214, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)198,        (unsigned char)230,        (unsigned char)246,        (unsigned char)222, 
            (unsigned char)206,        (unsigned char)198,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)252,        (unsigned char)198,        (unsigned char)198,        (unsigned char)252, 
            (unsigned char)192,        (unsigned char)192,        (unsigned char)192,        (unsigned char)0}, 
   {        (unsigned char)124,        (unsigned char)198,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)124,        (unsigned char)6}, 
   {        (unsigned char)252,        (unsigned char)198,        (unsigned char)198,        (unsigned char)252, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)120,        (unsigned char)204,        (unsigned char)96,        (unsigned char)48, 
            (unsigned char)24,        (unsigned char)204,        (unsigned char)120,        (unsigned char)0}, 
   {        (unsigned char)252,        (unsigned char)48,        (unsigned char)48,        (unsigned char)48, 
            (unsigned char)48,        (unsigned char)48,        (unsigned char)48,        (unsigned char)0}, 
   {        (unsigned char)198,        (unsigned char)198,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)198,        (unsigned char)198,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)108,        (unsigned char)56,        (unsigned char)0}, 
   {        (unsigned char)198,        (unsigned char)198,        (unsigned char)198,        (unsigned char)214, 
            (unsigned char)254,        (unsigned char)238,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)198,        (unsigned char)198,        (unsigned char)108,        (unsigned char)56, 
            (unsigned char)108,        (unsigned char)198,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)195,        (unsigned char)195,        (unsigned char)102,        (unsigned char)60, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)24,        (unsigned char)0}, 
   {        (unsigned char)254,        (unsigned char)12,        (unsigned char)24,        (unsigned char)48, 
            (unsigned char)96,        (unsigned char)192,        (unsigned char)254,        (unsigned char)0}, 
   {        (unsigned char)60,        (unsigned char)48,        (unsigned char)48,        (unsigned char)48, 
            (unsigned char)48,        (unsigned char)48,        (unsigned char)60,        (unsigned char)0}, 
   {        (unsigned char)192,        (unsigned char)96,        (unsigned char)48,        (unsigned char)24, 
            (unsigned char)12,        (unsigned char)6,        (unsigned char)3,        (unsigned char)0}, 
   {        (unsigned char)60,        (unsigned char)12,        (unsigned char)12,        (unsigned char)12, 
            (unsigned char)12,        (unsigned char)12,        (unsigned char)60,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)56,        (unsigned char)108,        (unsigned char)198, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)255}, 
   {        (unsigned char)48,        (unsigned char)48,        (unsigned char)24,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)124,        (unsigned char)6, 
            (unsigned char)126,        (unsigned char)198,        (unsigned char)126,        (unsigned char)0}, 
   {        (unsigned char)192,        (unsigned char)192,        (unsigned char)252,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)230,        (unsigned char)220,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)124,        (unsigned char)198, 
            (unsigned char)192,        (unsigned char)192,        (unsigned char)126,        (unsigned char)0}, 
   {        (unsigned char)6,        (unsigned char)6,        (unsigned char)126,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)206,        (unsigned char)118,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)124,        (unsigned char)198, 
            (unsigned char)254,        (unsigned char)192,        (unsigned char)126,        (unsigned char)0}, 
   {        (unsigned char)30,        (unsigned char)48,        (unsigned char)124,        (unsigned char)48, 
            (unsigned char)48,        (unsigned char)48,        (unsigned char)48,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)126,        (unsigned char)198, 
            (unsigned char)206,        (unsigned char)118,        (unsigned char)6,        (unsigned char)124}, 
   {        (unsigned char)192,        (unsigned char)192,        (unsigned char)252,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)24,        (unsigned char)0,        (unsigned char)56,        (unsigned char)24, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)60,        (unsigned char)0}, 
   {        (unsigned char)24,        (unsigned char)0,        (unsigned char)56,        (unsigned char)24, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)24,        (unsigned char)240}, 
   {        (unsigned char)192,        (unsigned char)192,        (unsigned char)204,        (unsigned char)216, 
            (unsigned char)240,        (unsigned char)216,        (unsigned char)204,        (unsigned char)0}, 
   {        (unsigned char)56,        (unsigned char)24,        (unsigned char)24,        (unsigned char)24, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)60,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)204,        (unsigned char)254, 
            (unsigned char)214,        (unsigned char)198,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)252,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)124,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)124,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)252,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)230,        (unsigned char)220,        (unsigned char)192}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)126,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)206,        (unsigned char)118,        (unsigned char)6}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)110,        (unsigned char)112, 
            (unsigned char)96,        (unsigned char)96,        (unsigned char)96,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)124,        (unsigned char)192, 
            (unsigned char)124,        (unsigned char)6,        (unsigned char)252,        (unsigned char)0}, 
   {        (unsigned char)48,        (unsigned char)48,        (unsigned char)124,        (unsigned char)48, 
            (unsigned char)48,        (unsigned char)48,        (unsigned char)28,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)198,        (unsigned char)126,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)198,        (unsigned char)108,        (unsigned char)56,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)214,        (unsigned char)254,        (unsigned char)108,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)198,        (unsigned char)108, 
            (unsigned char)56,        (unsigned char)108,        (unsigned char)198,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)198,        (unsigned char)198, 
            (unsigned char)206,        (unsigned char)118,        (unsigned char)6,        (unsigned char)124}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)252,        (unsigned char)24, 
            (unsigned char)48,        (unsigned char)96,        (unsigned char)252,        (unsigned char)0}, 
   {        (unsigned char)14,        (unsigned char)24,        (unsigned char)24,        (unsigned char)112, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)14,        (unsigned char)0}, 
   {        (unsigned char)24,        (unsigned char)24,        (unsigned char)24,        (unsigned char)0, 
            (unsigned char)24,        (unsigned char)24,        (unsigned char)24,        (unsigned char)0}, 
   {        (unsigned char)224,        (unsigned char)48,        (unsigned char)48,        (unsigned char)28, 
            (unsigned char)48,        (unsigned char)48,        (unsigned char)224,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)112,        (unsigned char)154, 
            (unsigned char)14,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)0,        (unsigned char)0,        (unsigned char)24,        (unsigned char)60, 
            (unsigned char)102,        (unsigned char)255,        (unsigned char)0,        (unsigned char)0}};
#line 160 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_font.c"
void DrawText(SavedImage *Image , int const   x , int const   y , char const   *legend ,
              int const   color ) 
{ 
  int i ;
  int j ;
  int base ;
  char const   *cp ;

  {
#line 171
  i = 0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i < 8)) {
#line 171
      goto while_break;
    }
#line 172
    base = Image->ImageDesc.Width * (GifWord )(y + (int const   )i) + (GifWord )x;
#line 174
    cp = legend;
    {
#line 174
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 174
      if (! *cp) {
#line 174
        goto while_break___0;
      }
#line 175
      j = 0;
      {
#line 175
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 175
        if (! (j < 8)) {
#line 175
          goto while_break___1;
        }
#line 176
        if ((int )AsciiTable[(short )*cp][i] & (1 << (8 - j))) {
#line 177
          *(Image->RasterBits + base) = (unsigned char )color;
        }
#line 178
        base ++;
#line 175
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 174
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_font.c"
void DrawBox(SavedImage *Image , int const   x , int const   y , int const   w , int const   d ,
             int const   color ) 
{ 
  int j ;
  int base ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
#line 191
  base = Image->ImageDesc.Width * (GifWord )y + (GifWord )x;
#line 193
  j = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (j < (int )w)) {
#line 193
      goto while_break;
    }
#line 194
    tmp = (unsigned char )color;
#line 194
    *(Image->RasterBits + ((base + (int )(d * (int const   )Image->ImageDesc.Width)) + j)) = tmp;
#line 194
    *(Image->RasterBits + (base + j)) = tmp;
#line 193
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  j = 0;
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 197
    if (! (j < (int )d)) {
#line 197
      goto while_break___0;
    }
#line 198
    tmp___0 = (unsigned char )color;
#line 198
    *(Image->RasterBits + ((base + j * Image->ImageDesc.Width) + (int )w)) = tmp___0;
#line 198
    *(Image->RasterBits + (base + j * Image->ImageDesc.Width)) = tmp___0;
#line 197
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 200
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_font.c"
void DrawRectangle(SavedImage *Image , int const   x , int const   y , int const   w ,
                   int const   d , int const   color ) 
{ 
  unsigned char *bp ;
  int i ;

  {
#line 210
  bp = (Image->RasterBits + Image->ImageDesc.Width * (GifWord )y) + x;
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < (int )d)) {
#line 213
      goto while_break;
    }
    {
#line 214
    memset((void *)(bp + i * Image->ImageDesc.Width), (int )color, (size_t )w);
#line 213
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_font.c"
void DrawBoxedText(SavedImage *Image , int const   x , int const   y , char const   *legend ,
                   int const   border , int const   bg , int const   fg ) 
{ 
  int i ;
  int j ;
  int LineCount ;
  int TextWidth ;
  char const   *cp ;
  char *tmp ;
  int leadspace ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 226
  j = 0;
#line 226
  LineCount = 0;
#line 226
  TextWidth = 0;
#line 230
  cp = legend;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! *cp) {
#line 230
      goto while_break;
    }
#line 231
    if ((int const   )*cp == 13) {
#line 232
      if (j > TextWidth) {
#line 233
        TextWidth = j;
      }
#line 234
      j = 0;
#line 235
      LineCount ++;
    } else
#line 236
    if ((int const   )*cp != 9) {
#line 237
      j ++;
    }
#line 230
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  LineCount ++;
#line 239
  if (j > TextWidth) {
#line 240
    TextWidth = j;
  }
  {
#line 243
  DrawRectangle(Image, x + 1, y + 1, ((border + (int const   )(TextWidth * 8)) + border) - 1,
                ((border + (int const   )(LineCount * 8)) + border) - 1, bg);
#line 248
  i = 0;
#line 249
  tmp = strtok((char */* __restrict  */)((char *)legend), (char const   */* __restrict  */)"\r\n");
#line 249
  cp = (char const   *)tmp;
  }
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    leadspace = 0;
#line 253
    if ((int const   )*(cp + 0) == 9) {
      {
#line 254
      cp ++;
#line 254
      tmp___0 = strlen(cp);
#line 254
      leadspace = (int )(((size_t )TextWidth - tmp___0) / 2UL);
      }
    }
    {
#line 256
    tmp___1 = i;
#line 256
    i ++;
#line 256
    DrawText(Image, (x + border) + (int const   )(leadspace * 8), (y + border) + (int const   )(8 * tmp___1),
             cp, fg);
#line 258
    tmp___2 = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)"\r\n");
#line 258
    cp = (char const   *)tmp___2;
    }
#line 250
    if (! cp) {
#line 250
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 262
  DrawBox(Image, x, y, (border + (int const   )(TextWidth * 8)) + border, (border + (int const   )(LineCount * 8)) + border,
          fg);
  }
#line 264
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___0  ;
#line 61
static int SubdivColorMap___0(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___0(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___0(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___0 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___0);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___0];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___0];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___0] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___0] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___0]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___0] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___0] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___0]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___0(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___0] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___0]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___0[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___0[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___0(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___0(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___0(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___0(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___0(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___0(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___0(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___0(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___0(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___0(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___0(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___0(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___0(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___0(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___0(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___0(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___0(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___0(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___0(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.h"
int GAGetArgs(int argc , char **argv , char *CtrlStr___25  , ...) ;
#line 25
void GAPrintErrMsg(int Error ) ;
#line 26
void GAPrintHowTo(char *CtrlStr___25 ) ;
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken  ;
#line 141
static int GATestAllSatis(char *CtrlStrCopy , char *CtrlStr___25 , int *argc , char ***argv ,
                          int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters(int **Parameters , int *ParamCount , char *Option ,
                              char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv ) ;
#line 147
static int GAGetParmeters(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                          char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               int *argc , char ***argv ) ;
#line 152
static void GASetParamCount(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists(int argc , char **argv ) ;
#line 156
static char *MyMalloc(unsigned int size ) ;
#line 164 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
int GAGetArgs(int argc , char **argv , char *CtrlStr___25  , ...) 
{ 
  int i ;
  int Error ;
  int ParamCount ;
  int *Parameters[100] ;
  char *Option ;
  char CtrlStrCopy[1024] ;
  va_list ap ;
  int *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  int tmp___2 ;

  {
  {
#line 169
  Error = 0;
#line 169
  ParamCount = 0;
#line 174
  strcpy((char */* __restrict  */)(CtrlStrCopy), (char const   */* __restrict  */)CtrlStr___25);
#line 175
  __builtin_va_start(ap, CtrlStr___25);
#line 176
  i = 1;
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i <= 100)) {
#line 176
      goto while_break;
    }
    {
#line 177
    tmp = __builtin_va_arg(ap, int *);
#line 177
    Parameters[i - 1] = tmp;
#line 176
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  __builtin_va_end(ap);
#line 206
  argc --;
#line 207
  argv ++;
  }
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 208
    if (! (argc >= 0)) {
#line 208
      goto while_break___0;
    }
    {
#line 209
    tmp___0 = GAOptionExists(argc, argv);
    }
#line 209
    if (! tmp___0) {
#line 210
      goto while_break___0;
    }
    {
#line 211
    argc --;
#line 212
    tmp___1 = argv;
#line 212
    argv ++;
#line 212
    Option = *tmp___1;
#line 213
    Error = GAUpdateParameters(Parameters, & ParamCount, Option, CtrlStrCopy, CtrlStr___25,
                               & argc, & argv);
    }
#line 213
    if (Error != 0) {
#line 216
      return (Error);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 219
  tmp___2 = GATestAllSatis(CtrlStrCopy, CtrlStr___25, & argc, & argv, (int **)(Parameters),
                           & ParamCount);
  }
#line 219
  return (tmp___2);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis(char *CtrlStrCopy , char *CtrlStr___25 , int *argc , char ***argv ,
                          int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken = LocalToken;
#line 264
        *(LocalToken + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters(int **Parameters , int *ParamCount , char *Option ,
                              char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                           argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                          char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters(Parameters, ParamCount, CtrlStrCopy + i, argc, argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
void GAPrintErrMsg(int Error ) 
{ 


  {
  {
#line 579
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in command line parsing - ");
  }
  {
#line 581
  if (Error == 0) {
#line 581
    goto case_0;
  }
#line 584
  if (Error == 1) {
#line 584
    goto case_1;
  }
#line 587
  if (Error == 2) {
#line 587
    goto case_2;
  }
#line 590
  if (Error == 3) {
#line 590
    goto case_3;
  }
#line 593
  if (Error == 4) {
#line 593
    goto case_4;
  }
#line 596
  if (Error == 5) {
#line 596
    goto case_5;
  }
#line 580
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 582
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Undefined error");
  }
#line 583
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 585
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"None option Found");
  }
#line 586
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 588
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Undefined option Found");
  }
#line 589
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 591
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Empty input for \'!*?\' seq.");
  }
#line 592
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 594
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed on reading number");
  }
#line 595
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 597
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fail to satisfy");
  }
#line 598
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 600
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" - \'%s\'.\n",
          GAErrorToken);
  }
#line 601
  return;
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
void GAPrintHowTo(char *CtrlStr___25 ) 
{ 
  int i ;
  int SpaceFlag ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 609
  i = 0;
#line 611
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: ");
  }
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (! ((int )*(CtrlStr___25 + i) <= 32)) {
#line 613
      if ((int )*(CtrlStr___25 + (i + 1)) == 37) {
#line 613
        goto while_break;
      } else
#line 613
      if ((int )*(CtrlStr___25 + (i + 1)) == 33) {
#line 613
        goto while_break;
      }
    } else {
#line 613
      goto while_break;
    }
    {
#line 614
    tmp = i;
#line 614
    i ++;
#line 614
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
            (int )*(CtrlStr___25 + tmp));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 616
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 616
    tmp___13 = strlen((char const   *)CtrlStr___25);
    }
#line 616
    if (! (i < (int )tmp___13)) {
#line 616
      goto while_break___0;
    }
    {
#line 617
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 617
      if ((int )*(CtrlStr___25 + i) <= 32) {
        {
#line 617
        tmp___0 = strlen((char const   *)CtrlStr___25);
        }
#line 617
        if (! (i < (int )tmp___0)) {
#line 617
          goto while_break___1;
        }
      } else {
#line 617
        goto while_break___1;
      }
#line 618
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 620
    if ((int )*(CtrlStr___25 + (i + 1)) == 37) {
#line 620
      goto case_37;
    }
#line 643
    if ((int )*(CtrlStr___25 + (i + 1)) == 33) {
#line 643
      goto case_33;
    }
#line 665
    goto switch_default;
    case_37: /* CIL Label */ 
    {
#line 621
    tmp___1 = i;
#line 621
    i ++;
#line 621
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [-%c",
            (int )*(CtrlStr___25 + tmp___1));
#line 622
    i += 2;
#line 623
    SpaceFlag = 1;
    }
    {
#line 624
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 624
      if ((int )*(CtrlStr___25 + i) == 37) {
#line 624
        goto while_break___2;
      } else
#line 624
      if ((int )*(CtrlStr___25 + i) == 33) {
#line 624
        goto while_break___2;
      } else {
        {
#line 624
        tmp___4 = strlen((char const   *)CtrlStr___25);
        }
#line 624
        if (i < (int )tmp___4) {
#line 624
          if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 624
            goto while_break___2;
          }
        } else {
#line 624
          goto while_break___2;
        }
      }
#line 626
      if (SpaceFlag) {
#line 627
        tmp___2 = i;
#line 627
        i ++;
#line 627
        if ((int )*(CtrlStr___25 + tmp___2) == 124) {
          {
#line 628
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
          }
        } else {
          {
#line 630
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %c",
                  (int )*(CtrlStr___25 + (i - 1)));
          }
        }
#line 631
        SpaceFlag = 0;
      } else {
#line 632
        tmp___3 = i;
#line 632
        i ++;
#line 632
        if ((int )*(CtrlStr___25 + tmp___3) == 124) {
          {
#line 633
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
          }
        } else {
          {
#line 635
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
                  (int )*(CtrlStr___25 + (i - 1)));
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 636
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 636
      if (! ((int )*(CtrlStr___25 + i) <= 32)) {
        {
#line 636
        tmp___5 = strlen((char const   *)CtrlStr___25);
        }
#line 636
        if (! (i < (int )tmp___5)) {
#line 636
          goto while_break___3;
        }
      } else {
#line 636
        goto while_break___3;
      }
#line 637
      if ((int )*(CtrlStr___25 + i) == 42) {
        {
#line 638
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"...");
        }
      }
#line 639
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"]");
    }
#line 642
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 644
    tmp___6 = i;
#line 644
    i ++;
#line 644
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -%c",
            (int )*(CtrlStr___25 + tmp___6));
#line 645
    i += 2;
#line 646
    SpaceFlag = 1;
    }
    {
#line 647
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 647
      if ((int )*(CtrlStr___25 + i) == 37) {
#line 647
        goto while_break___4;
      } else
#line 647
      if ((int )*(CtrlStr___25 + i) == 33) {
#line 647
        goto while_break___4;
      } else {
        {
#line 647
        tmp___9 = strlen((char const   *)CtrlStr___25);
        }
#line 647
        if (i < (int )tmp___9) {
#line 647
          if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 647
            goto while_break___4;
          }
        } else {
#line 647
          goto while_break___4;
        }
      }
#line 649
      if (SpaceFlag) {
#line 650
        tmp___7 = i;
#line 650
        i ++;
#line 650
        if ((int )*(CtrlStr___25 + tmp___7) == 124) {
          {
#line 651
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
          }
        } else {
          {
#line 653
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %c",
                  (int )*(CtrlStr___25 + (i - 1)));
          }
        }
#line 654
        SpaceFlag = 0;
      } else {
#line 655
        tmp___8 = i;
#line 655
        i ++;
#line 655
        if ((int )*(CtrlStr___25 + tmp___8) == 124) {
          {
#line 656
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
          }
        } else {
          {
#line 658
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
                  (int )*(CtrlStr___25 + (i - 1)));
          }
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 659
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 659
      if (! ((int )*(CtrlStr___25 + i) <= 32)) {
        {
#line 659
        tmp___10 = strlen((char const   *)CtrlStr___25);
        }
#line 659
        if (! (i < (int )tmp___10)) {
#line 659
          goto while_break___5;
        }
      } else {
#line 659
        goto while_break___5;
      }
#line 660
      if ((int )*(CtrlStr___25 + i) == 42) {
        {
#line 661
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"...");
        }
      }
#line 662
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 664
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 666
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
    }
    {
#line 667
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 667
      if (! ((int )*(CtrlStr___25 + i) <= 32)) {
        {
#line 667
        tmp___12 = strlen((char const   *)CtrlStr___25);
        }
#line 667
        if (i < (int )tmp___12) {
#line 667
          if ((int )*(CtrlStr___25 + i) == 37) {
#line 667
            goto while_break___6;
          } else
#line 667
          if ((int )*(CtrlStr___25 + i) == 33) {
#line 667
            goto while_break___6;
          }
        } else {
#line 667
          goto while_break___6;
        }
      } else {
#line 667
        goto while_break___6;
      }
      {
#line 669
      tmp___11 = i;
#line 669
      i ++;
#line 669
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
              (int )*(CtrlStr___25 + tmp___11));
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 670
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 671
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 674
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 675
  return;
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___0(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___0(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___0(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___0(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___0(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___0(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___0(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___0(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___0(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___0(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___0(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___0(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___0(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___0(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___0[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___0(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___0(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___0[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___0(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___0  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___0  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___0  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___0  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___0  =    100L;
#line 62
static void GetScanLine___0(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___0(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___0(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___0 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___0 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___0;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___0(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static char *VersionStr  =    (char *)"GifBG Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:55\n(C) Copyright 1989 Gershon Elber.\n";
#line 85 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static char *CtrlStr  =    (char *)"GifBG q%- d%-Dir!s l%-#Lvls!d c%-R|G|B!d!d!d m%-MinI!d M%-MaxI!d s%-W|H!d!d h%-";
#line 91 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static int MaximumIntensity  =    100;
#line 91 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static int MinimumIntensity  =    10;
#line 91 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static int NumLevels  =    16;
#line 91 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static int ImageWidth  =    640;
#line 91 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static int ImageHeight  =    350;
#line 91 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static int Direction  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static unsigned int RedColor  =    0U;
#line 98 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static unsigned int GreenColor  =    0U;
#line 98 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static unsigned int BlueColor  =    255U;
#line 103
static void QuitGifError(GifFileType *GifFile ) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
int main(int argc , char **argv ) 
{ 
  unsigned int Ratio ;
  int i ;
  int j ;
  int l ;
  int LevelHeight ;
  int LevelWidth ;
  int Error ;
  int LogNumLevels ;
  int FlipDir ;
  int Accumulator ;
  int StartX ;
  int StepX ;
  int Count ;
  int DoAllMaximum ;
  int DirectionFlag ;
  int LevelsFlag ;
  int ColorFlag___0 ;
  int MinFlag ;
  int MaxFlag ;
  int SizeFlag___0 ;
  int HelpFlag___6 ;
  GifPixelType Color ;
  char *DirectionStr ;
  GifRowType Line ;
  ColorMapObject *ColorMap___3 ;
  GifFileType *GifFile ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 111
  Count = 0;
#line 111
  DoAllMaximum = 0;
#line 111
  DirectionFlag = 0;
#line 111
  LevelsFlag = 0;
#line 111
  ColorFlag___0 = 0;
#line 111
  MinFlag = 0;
#line 111
  MaxFlag = 0;
#line 111
  SizeFlag___0 = 0;
#line 111
  HelpFlag___6 = 0;
#line 116
  DirectionStr = (char *)"T";
#line 121
  Error = GAGetArgs(argc, argv, CtrlStr, & GifQuietPrint, & DirectionFlag, & DirectionStr,
                    & LevelsFlag, & NumLevels, & ColorFlag___0, & RedColor, & GreenColor,
                    & BlueColor, & MinFlag, & MinimumIntensity, & MaxFlag, & MaximumIntensity,
                    & SizeFlag___0, & ImageWidth, & ImageHeight, & HelpFlag___6);
  }
#line 121
  if (Error != 0) {
    {
#line 127
    GAPrintErrMsg(Error);
#line 128
    GAPrintHowTo(CtrlStr);
#line 129
    exit(1);
    }
  }
#line 132
  if (HelpFlag___6) {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            VersionStr);
#line 134
    GAPrintHowTo(CtrlStr);
#line 135
    exit(0);
    }
  }
#line 139
  if (MinimumIntensity < 0) {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Intensities (-m or -M options) are not in [0..100] range (percent).");
#line 141
    exit(-3);
    }
  } else
#line 139
  if (MinimumIntensity > 100) {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Intensities (-m or -M options) are not in [0..100] range (percent).");
#line 141
    exit(-3);
    }
  } else
#line 139
  if (MaximumIntensity < 0) {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Intensities (-m or -M options) are not in [0..100] range (percent).");
#line 141
    exit(-3);
    }
  } else
#line 139
  if (MaximumIntensity > 100) {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Intensities (-m or -M options) are not in [0..100] range (percent).");
#line 141
    exit(-3);
    }
  }
#line 144
  Direction = 0;
#line 145
  FlipDir = 0;
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 146
    tmp___1 = strlen((char const   *)DirectionStr);
    }
#line 146
    if (! (i < (int )tmp___1)) {
#line 146
      goto while_break;
    }
    {
#line 147
    tmp___0 = __ctype_b_loc();
    }
#line 147
    if ((int const   )*(*tmp___0 + (int )*(DirectionStr + i)) & 512) {
      {
#line 148
      tmp = toupper((int )*(DirectionStr + i));
#line 148
      *(DirectionStr + i) = (char )tmp;
      }
    }
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  if ((int )*(DirectionStr + 0) == 78) {
#line 152
    goto case_78;
  }
#line 152
  if ((int )*(DirectionStr + 0) == 84) {
#line 152
    goto case_78;
  }
#line 169
  if ((int )*(DirectionStr + 0) == 69) {
#line 169
    goto case_69___0;
  }
#line 169
  if ((int )*(DirectionStr + 0) == 82) {
#line 169
    goto case_69___0;
  }
#line 173
  if ((int )*(DirectionStr + 0) == 83) {
#line 173
    goto case_83;
  }
#line 173
  if ((int )*(DirectionStr + 0) == 66) {
#line 173
    goto case_83;
  }
#line 192
  if ((int )*(DirectionStr + 0) == 87) {
#line 192
    goto case_87___1;
  }
#line 192
  if ((int )*(DirectionStr + 0) == 76) {
#line 192
    goto case_87___1;
  }
#line 150
  goto switch_break;
  case_78: /* CIL Label */ 
  case_84: /* CIL Label */ 
  {
#line 153
  tmp___2 = strlen((char const   *)DirectionStr);
  }
#line 153
  if (tmp___2 < 2UL) {
#line 154
    Direction = 1;
  } else {
    {
#line 158
    if ((int )*(DirectionStr + 1) == 69) {
#line 158
      goto case_69;
    }
#line 158
    if ((int )*(DirectionStr + 1) == 82) {
#line 158
      goto case_69;
    }
#line 162
    if ((int )*(DirectionStr + 1) == 87) {
#line 162
      goto case_87;
    }
#line 162
    if ((int )*(DirectionStr + 1) == 76) {
#line 162
      goto case_87;
    }
#line 156
    goto switch_break___0;
    case_69: /* CIL Label */ 
    case_82: /* CIL Label */ 
#line 159
    Direction = 2;
#line 160
    goto switch_break___0;
    case_87: /* CIL Label */ 
    case_76: /* CIL Label */ 
#line 163
    Direction = 8;
#line 164
    FlipDir = 1;
#line 165
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 167
  goto switch_break;
  case_69___0: /* CIL Label */ 
  case_82___0: /* CIL Label */ 
#line 170
  Direction = 3;
#line 171
  goto switch_break;
  case_83: /* CIL Label */ 
  case_66: /* CIL Label */ 
  {
#line 174
  tmp___3 = strlen((char const   *)DirectionStr);
  }
#line 174
  if (tmp___3 < 2UL) {
#line 175
    Direction = 5;
#line 176
    FlipDir = 1;
  } else {
    {
#line 181
    if ((int )*(DirectionStr + 1) == 69) {
#line 181
      goto case_69___1;
    }
#line 181
    if ((int )*(DirectionStr + 1) == 82) {
#line 181
      goto case_69___1;
    }
#line 185
    if ((int )*(DirectionStr + 1) == 87) {
#line 185
      goto case_87___0;
    }
#line 185
    if ((int )*(DirectionStr + 1) == 76) {
#line 185
      goto case_87___0;
    }
#line 179
    goto switch_break___1;
    case_69___1: /* CIL Label */ 
    case_82___1: /* CIL Label */ 
#line 182
    Direction = 4;
#line 183
    goto switch_break___1;
    case_87___0: /* CIL Label */ 
    case_76___0: /* CIL Label */ 
#line 186
    Direction = 6;
#line 187
    FlipDir = 1;
#line 188
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 190
  goto switch_break;
  case_87___1: /* CIL Label */ 
  case_76___1: /* CIL Label */ 
#line 193
  Direction = 7;
#line 194
  FlipDir = 1;
#line 195
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 197
  if (Direction == 0) {
    {
#line 198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Direction requested (-d option) is weird!");
#line 198
    exit(-3);
    }
  }
#line 203
  if (FlipDir) {
    {
#line 205
    if (Direction == 5) {
#line 205
      goto case_5;
    }
#line 208
    if (Direction == 6) {
#line 208
      goto case_6;
    }
#line 211
    if (Direction == 7) {
#line 211
      goto case_7;
    }
#line 214
    if (Direction == 8) {
#line 214
      goto case_8;
    }
#line 204
    goto switch_break___2;
    case_5: /* CIL Label */ 
#line 206
    Direction = 1;
#line 207
    goto switch_break___2;
    case_6: /* CIL Label */ 
#line 209
    Direction = 2;
#line 210
    goto switch_break___2;
    case_7: /* CIL Label */ 
#line 212
    Direction = 3;
#line 213
    goto switch_break___2;
    case_8: /* CIL Label */ 
#line 215
    Direction = 4;
#line 216
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  }
#line 221
  if (MinimumIntensity == 100) {
#line 221
    if (MaximumIntensity == 100) {
#line 221
      if (NumLevels == 2) {
#line 222
        MinimumIntensity = 0;
#line 223
        DoAllMaximum = 1;
#line 224
        Direction = 3;
      }
    }
  }
#line 228
  if (RedColor > 255U) {
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Colors are not in the ragne [0..255].");
#line 229
    exit(-3);
    }
  } else
#line 228
  if (GreenColor > 255U) {
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Colors are not in the ragne [0..255].");
#line 229
    exit(-3);
    }
  } else
#line 228
  if (BlueColor > 255U) {
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Colors are not in the ragne [0..255].");
#line 229
    exit(-3);
    }
  }
#line 232
  i = 1;
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 232
    if (! (i < 8)) {
#line 232
      goto while_break___0;
    }
#line 232
    if (NumLevels == 1 << i) {
#line 232
      goto while_break___0;
    }
#line 232
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 233
  if (i == 8) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "#Lvls (-l option) is not power of 2.");
#line 233
    exit(-3);
    }
  }
  {
#line 234
  LogNumLevels = i;
#line 237
  GifFile = EGifOpenFileHandle(1);
  }
#line 237
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
    {
#line 238
    QuitGifError(GifFile);
    }
  }
  {
#line 241
  ColorMap___3 = MakeMapObject(NumLevels, (GifColorType const   *)((void *)0));
  }
#line 241
  if ((unsigned long )ColorMap___3 == (unsigned long )((void *)0)) {
    {
#line 242
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Failed to allocate memory required, aborted.");
#line 242
    exit(-3);
    }
  }
#line 244
  i = 1;
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! (i <= NumLevels)) {
#line 244
      goto while_break___1;
    }
#line 246
    Ratio = (unsigned int )((MaximumIntensity * (i * (256 / NumLevels)) + MinimumIntensity * ((NumLevels - i) * (256 / NumLevels))) / 256);
#line 249
    (ColorMap___3->Colors + (i - 1))->Red = (GifByteType )((RedColor * Ratio) / 100U);
#line 250
    (ColorMap___3->Colors + (i - 1))->Green = (GifByteType )((GreenColor * Ratio) / 100U);
#line 251
    (ColorMap___3->Colors + (i - 1))->Blue = (GifByteType )((BlueColor * Ratio) / 100U);
#line 244
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 253
  tmp___4 = EGifPutScreenDesc(GifFile, ImageWidth, ImageHeight, LogNumLevels, 0, (ColorMapObject const   *)ColorMap___3);
  }
#line 253
  if (tmp___4 == 0) {
    {
#line 256
    QuitGifError(GifFile);
    }
  }
  {
#line 259
  tmp___5 = EGifPutImageDesc(GifFile, 0, 0, ImageWidth, ImageHeight, 0, (ColorMapObject const   *)((void *)0));
  }
#line 259
  if (tmp___5 == 0) {
    {
#line 261
    QuitGifError(GifFile);
    }
  }
  {
#line 263
  GifQprintf((char *)"\n%s: Image 1 at (%d, %d) [%dx%d]:     ", "GifBG", GifFile->Image.Left,
             GifFile->Image.Top, GifFile->Image.Width, GifFile->Image.Height);
#line 269
  tmp___6 = malloc((sizeof(GifPixelType ) * (unsigned long )ImageWidth) * 2UL);
#line 269
  Line = (GifRowType )tmp___6;
  }
#line 269
  if ((unsigned long )Line == (unsigned long )((void *)0)) {
    {
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifBG", "Failed to allocate memory required, aborted.");
#line 270
    exit(-3);
    }
  }
#line 272
  if (Direction == 1) {
#line 274
    LevelHeight = ImageHeight / NumLevels;
#line 275
    Color = (GifPixelType )NumLevels;
#line 275
    l = 0;
#line 275
    i = l;
    {
#line 275
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 275
      if (! (i < ImageHeight)) {
#line 275
        goto while_break___2;
      }
#line 276
      if (i == l) {
#line 278
        if ((int )Color != 0) {
#line 278
          Color = (GifPixelType )((int )Color - 1);
        }
#line 279
        j = 0;
        {
#line 279
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 279
          if (! (j < ImageWidth)) {
#line 279
            goto while_break___3;
          }
#line 280
          if (FlipDir) {
#line 280
            *(Line + j) = (unsigned char )((NumLevels - (int )Color) - 1);
          } else {
#line 280
            *(Line + j) = Color;
          }
#line 279
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 281
        l += LevelHeight;
      }
      {
#line 283
      tmp___7 = EGifPutLine(GifFile, Line, ImageWidth);
      }
#line 283
      if (tmp___7 == 0) {
        {
#line 284
        QuitGifError(GifFile);
        }
      }
      {
#line 285
      tmp___8 = Count;
#line 285
      Count ++;
#line 285
      GifQprintf((char *)"\b\b\b\b%-4d", tmp___8);
#line 275
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 288
  if (Direction == 3) {
#line 292
    LevelWidth = ImageWidth / NumLevels;
#line 293
    if (DoAllMaximum) {
#line 295
      i = 0;
      {
#line 295
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 295
        if (! (i < ImageWidth)) {
#line 295
          goto while_break___4;
        }
#line 295
        *(Line + i) = (unsigned char)1;
#line 295
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 298
      i = 0;
#line 298
      Color = (GifPixelType )i;
#line 298
      l = LevelWidth;
      {
#line 298
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 298
        if (! (i < ImageWidth)) {
#line 298
          goto while_break___5;
        }
#line 299
        if (l == 0) {
#line 300
          l = LevelWidth;
#line 301
          if ((int )Color < NumLevels - 1) {
#line 301
            Color = (GifPixelType )((int )Color + 1);
          }
        }
#line 303
        if (FlipDir) {
#line 303
          *(Line + i) = (unsigned char )((NumLevels - (int )Color) - 1);
        } else {
#line 303
          *(Line + i) = Color;
        }
#line 298
        i ++;
#line 298
        l --;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 307
    i = 0;
    {
#line 307
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 307
      if (! (i < ImageHeight)) {
#line 307
        goto while_break___6;
      }
      {
#line 308
      tmp___9 = EGifPutLine(GifFile, Line, ImageWidth);
      }
#line 308
      if (tmp___9 == 0) {
        {
#line 309
        QuitGifError(GifFile);
        }
      }
      {
#line 310
      tmp___10 = Count;
#line 310
      Count ++;
#line 310
      GifQprintf((char *)"\b\b\b\b%-4d", tmp___10);
#line 307
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
#line 318
    LevelWidth = (ImageWidth * 2) / NumLevels;
#line 319
    i = 0;
#line 319
    Color = (GifPixelType )i;
#line 319
    l = LevelWidth;
    {
#line 319
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 319
      if (! (i < ImageWidth * 2)) {
#line 319
        goto while_break___7;
      }
#line 320
      if (l == 0) {
#line 321
        l = LevelWidth;
#line 322
        if ((int )Color < NumLevels - 1) {
#line 322
          Color = (GifPixelType )((int )Color + 1);
        }
      }
#line 324
      if (FlipDir) {
#line 324
        *(Line + i) = (unsigned char )((NumLevels - (int )Color) - 1);
      } else {
#line 324
        *(Line + i) = Color;
      }
#line 319
      i ++;
#line 319
      l --;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 328
    Accumulator = 0;
    {
#line 330
    if (Direction == 2) {
#line 330
      goto case_2;
    }
#line 335
    goto switch_default;
    case_2: /* CIL Label */ 
#line 331
    StartX = ImageWidth;
#line 332
    StepX = -1;
#line 333
    goto switch_break___3;
    switch_default: /* CIL Label */ 
#line 336
    StartX = 0;
#line 337
    StepX = 1;
#line 338
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 342
    i = 0;
    {
#line 342
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 342
      if (! (i < ImageHeight)) {
#line 342
        goto while_break___8;
      }
      {
#line 343
      tmp___11 = EGifPutLine(GifFile, Line + StartX, ImageWidth);
      }
#line 343
      if (tmp___11 == 0) {
        {
#line 344
        QuitGifError(GifFile);
        }
      }
      {
#line 345
      tmp___12 = Count;
#line 345
      Count ++;
#line 345
      GifQprintf((char *)"\b\b\b\b%-4d", tmp___12);
#line 346
      Accumulator += ImageWidth;
      }
#line 346
      if (Accumulator > ImageHeight) {
        {
#line 347
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 347
          if (! (Accumulator > ImageHeight)) {
#line 347
            goto while_break___9;
          }
#line 348
          Accumulator -= ImageHeight;
#line 349
          StartX += StepX;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 351
        if (Direction < 0) {
#line 351
          Direction = 0;
        }
#line 352
        if (Direction > ImageWidth) {
#line 352
          Direction = ImageWidth;
        }
      }
#line 342
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  {
#line 357
  tmp___13 = EGifCloseFile(GifFile);
  }
#line 357
  if (tmp___13 == 0) {
    {
#line 358
    QuitGifError(GifFile);
    }
  }
#line 360
  return (0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifbg.c"
static void QuitGifError(GifFileType *GifFile ) 
{ 


  {
  {
#line 368
  PrintGifError();
  }
#line 369
  if ((unsigned long )GifFile != (unsigned long )((void *)0)) {
    {
#line 369
    EGifCloseFile(GifFile);
    }
  }
  {
#line 370
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___0(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___0(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___1  ;
#line 61
static int SubdivColorMap___1(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___1(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___1(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___1 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___1);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___1];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___1];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___1] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___1] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___1]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___1] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___1] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___1]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___1(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___1] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___1]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___1[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___1[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___1(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___1(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___1(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___1(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___1(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___1(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___1(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___1(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___1(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___1(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___1(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___1(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___1(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___1(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___1(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___1(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___1(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___1(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___1(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___0  ;
#line 141
static int GATestAllSatis___0(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___0(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___0(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___0(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___0(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___0(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___0(int argc , char **argv ) ;
#line 156
static char *MyMalloc___0(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___0  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___0(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___0 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___0 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___0, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___0(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___0((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___0 = LocalToken___0;
#line 264
        *(LocalToken___0 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___0(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___0 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___0 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___0(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___0(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___0(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___0((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___0(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___0 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___0 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___0(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___0((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___0((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___0((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___0((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___0((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___0((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___0((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___0((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___0((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___0((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___0((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___0((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___0(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___0(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___0(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___0(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static char *VersionStr___0  =    (char *)"GifText Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:00\n(C) Copyright 1989 Gershon Elber.\n";
#line 66 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static char *CtrlStr___0  =    (char *)"GifText q%- c%- e%- z%- p%- r%- h%- GifFile!*s";
#line 72
static void PrintCodeBlock(GifFileType *GifFile , GifByteType *CodeBlock , int Reset ) ;
#line 73
static void PrintPixelBlock(GifByteType *PixelBlock , int Len , int Reset ) ;
#line 74
static void PrintExtBlock(GifByteType *Extension , int Reset ) ;
#line 75
static void PrintLZCodes(GifFileType *GifFile ) ;
#line 325 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static int CrntPlace  =    0;
#line 325 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static int Print  =    1;
#line 326 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static long CodeCount  =    0L;
#line 323 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static void PrintCodeBlock(GifFileType *GifFile , GifByteType *CodeBlock , int Reset ) 
{ 
  int i ;
  int Percent ;
  int Len ;
  long NumBytes ;

  {
#line 330
  if (Reset) {
#line 330
    goto _L;
  } else
#line 330
  if ((unsigned long )CodeBlock == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 331
    if ((unsigned long )CodeBlock == (unsigned long )((void *)0)) {
#line 332
      if (CrntPlace > 0) {
#line 333
        if (Print) {
          {
#line 333
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 334
        CodeCount += (long )(CrntPlace - 16);
      }
#line 336
      if (GifFile->Image.ColorMap) {
#line 337
        NumBytes = (((long )GifFile->Image.Width * (long )GifFile->Image.Height) * (long )(GifFile->Image.ColorMap)->BitsPerPixel) / 8L;
      } else {
#line 340
        NumBytes = (((long )GifFile->Image.Width * (long )GifFile->Image.Height) * (long )(GifFile->SColorMap)->BitsPerPixel) / 8L;
      }
      {
#line 342
      Percent = (int )((100L * CodeCount) / NumBytes);
#line 343
      printf((char const   */* __restrict  */)"\nCompression ratio: %ld/%ld (%d%%).\n",
             CodeCount, NumBytes, Percent);
      }
#line 345
      return;
    }
#line 347
    CrntPlace = 0;
#line 348
    CodeCount = 0L;
#line 349
    Print = 1;
  }
#line 352
  Len = (int )*(CodeBlock + 0);
#line 353
  i = 1;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (i <= Len)) {
#line 353
      goto while_break;
    }
#line 354
    if (CrntPlace == 0) {
#line 355
      if (Print) {
        {
#line 355
        printf((char const   */* __restrict  */)"\n%05lxh:  ", CodeCount);
        }
      }
#line 356
      CodeCount += 16L;
    }
#line 361
    if (Print) {
      {
#line 361
      printf((char const   */* __restrict  */)" %02xh", (int )*(CodeBlock + i));
      }
    }
#line 362
    CrntPlace ++;
#line 362
    if (CrntPlace >= 16) {
#line 362
      CrntPlace = 0;
    }
#line 353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static int CrntPlace___0  =    0;
#line 373 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static int Print___0  =    1;
#line 374 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static long ExtCount  =    0L;
#line 375 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static char HexForm[49]  ;
#line 375 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static char AsciiForm[17]  ;
#line 371 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static void PrintExtBlock(GifByteType *Extension , int Reset ) 
{ 
  int i ;
  int Len ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 378
  if (Reset) {
#line 378
    goto _L;
  } else
#line 378
  if ((unsigned long )Extension == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 379
    if ((unsigned long )Extension == (unsigned long )((void *)0)) {
#line 380
      if (CrntPlace___0 > 0) {
#line 381
        HexForm[CrntPlace___0 * 3] = (char)0;
#line 382
        AsciiForm[CrntPlace___0] = (char)0;
#line 383
        if (Print___0) {
          {
#line 383
          printf((char const   */* __restrict  */)"\n%05lx: %-49s  %-17s\n", ExtCount,
                 HexForm, AsciiForm);
          }
        }
#line 385
        return;
      } else
#line 387
      if (Print___0) {
        {
#line 388
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
#line 390
    CrntPlace___0 = 0;
#line 391
    ExtCount = 0L;
#line 392
    Print___0 = 1;
  }
#line 395
  if (! Print___0) {
#line 395
    return;
  }
#line 397
  Len = (int )*(Extension + 0);
#line 398
  i = 1;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (i <= Len)) {
#line 398
      goto while_break;
    }
    {
#line 399
    sprintf((char */* __restrict  */)(& HexForm[CrntPlace___0 * 3]), (char const   */* __restrict  */)" %02x",
            (int )*(Extension + i));
#line 400
    tmp___1 = __ctype_b_loc();
    }
#line 400
    if ((int const   )*(*tmp___1 + (int )*(Extension + i)) & 16384) {
#line 400
      tmp___0 = (int )*(Extension + i);
    } else {
#line 400
      tmp___0 = ' ';
    }
    {
#line 400
    sprintf((char */* __restrict  */)(& AsciiForm[CrntPlace___0]), (char const   */* __restrict  */)"%c",
            tmp___0);
#line 404
    CrntPlace___0 ++;
    }
#line 404
    if (CrntPlace___0 == 16) {
#line 405
      HexForm[CrntPlace___0 * 3] = (char)0;
#line 406
      AsciiForm[CrntPlace___0] = (char)0;
#line 407
      if (Print___0) {
        {
#line 407
        printf((char const   */* __restrict  */)"\n%05lx: %-49s  %-17s", ExtCount,
               HexForm, AsciiForm);
        }
      }
#line 409
      ExtCount += 16L;
#line 410
      CrntPlace___0 = 0;
    }
#line 398
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static int CrntPlace___1  =    0;
#line 422 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static int Print___1  =    1;
#line 423 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static long ExtCount___0  =    0L;
#line 424 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static char HexForm___0[49]  ;
#line 424 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static char AsciiForm___0[17]  ;
#line 420 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static void PrintPixelBlock(GifByteType *PixelBlock , int Len , int Reset ) 
{ 
  int i ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 427
  if (Reset) {
#line 427
    goto _L;
  } else
#line 427
  if ((unsigned long )PixelBlock == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 428
    if ((unsigned long )PixelBlock == (unsigned long )((void *)0)) {
#line 429
      if (CrntPlace___1 > 0) {
#line 430
        HexForm___0[CrntPlace___1 * 3] = (char)0;
#line 431
        AsciiForm___0[CrntPlace___1] = (char)0;
#line 432
        if (Print___1) {
          {
#line 432
          printf((char const   */* __restrict  */)"\n%05lx: %-49s  %-17s\n", ExtCount___0,
                 HexForm___0, AsciiForm___0);
          }
        }
      } else
#line 435
      if (Print___1) {
        {
#line 436
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
#line 438
    CrntPlace___1 = 0;
#line 439
    ExtCount___0 = 0L;
#line 440
    Print___1 = 1;
#line 441
    if ((unsigned long )PixelBlock == (unsigned long )((void *)0)) {
#line 441
      return;
    }
  }
#line 444
  if (! Print___1) {
#line 444
    return;
  }
#line 446
  i = 0;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! (i < Len)) {
#line 446
      goto while_break;
    }
    {
#line 447
    sprintf((char */* __restrict  */)(& HexForm___0[CrntPlace___1 * 3]), (char const   */* __restrict  */)" %02x",
            (int )*(PixelBlock + i));
#line 448
    tmp___1 = __ctype_b_loc();
    }
#line 448
    if ((int const   )*(*tmp___1 + (int )*(PixelBlock + i)) & 16384) {
#line 448
      tmp___0 = (int )*(PixelBlock + i);
    } else {
#line 448
      tmp___0 = ' ';
    }
    {
#line 448
    sprintf((char */* __restrict  */)(& AsciiForm___0[CrntPlace___1]), (char const   */* __restrict  */)"%c",
            tmp___0);
#line 452
    CrntPlace___1 ++;
    }
#line 452
    if (CrntPlace___1 == 16) {
#line 453
      HexForm___0[CrntPlace___1 * 3] = (char)0;
#line 454
      AsciiForm___0[CrntPlace___1] = (char)0;
#line 455
      if (Print___1) {
        {
#line 455
        printf((char const   */* __restrict  */)"\n%05lx: %-49s  %-17s", ExtCount___0,
               HexForm___0, AsciiForm___0);
        }
      }
#line 457
      ExtCount___0 += 16L;
#line 458
      CrntPlace___1 = 0;
    }
#line 446
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  return;
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giftext.c"
static void PrintLZCodes(GifFileType *GifFile ) 
{ 
  int Code ;
  int Print___2 ;
  int CrntPlace___2 ;
  long CodeCount___0 ;
  int tmp ;

  {
#line 468
  Print___2 = 1;
#line 468
  CrntPlace___2 = 0;
#line 469
  CodeCount___0 = 0L;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (Print___2) {
#line 472
      if (CrntPlace___2 == 0) {
        {
#line 472
        printf((char const   */* __restrict  */)"\n%05lx:", CodeCount___0);
        }
      }
    }
    {
#line 473
    tmp = DGifGetLZCodes(GifFile, & Code);
    }
#line 473
    if (tmp == 0) {
      {
#line 474
      PrintGifError();
#line 475
      exit(1);
      }
    }
#line 477
    if (Print___2) {
#line 477
      if (Code >= 0) {
        {
#line 478
        printf((char const   */* __restrict  */)" %03x", Code);
        }
      }
    }
#line 479
    CodeCount___0 ++;
#line 480
    CrntPlace___2 ++;
#line 480
    if (CrntPlace___2 >= 16) {
#line 480
      CrntPlace___2 = 0;
    }
#line 471
    if (! (Code >= 0)) {
#line 471
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___1(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___1(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___1(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___1(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___1(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___1(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___1(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___1(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___1(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___1(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___1(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___1(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___1(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___1(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___1[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___1(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___1(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___1[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___1(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___1  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___1  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___1  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___1  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___1  =    100L;
#line 62
static void GetScanLine___1(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___1(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___1(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___1 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___1 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___1;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___1(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___1(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___1(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___2  ;
#line 61
static int SubdivColorMap___2(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___2(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___2(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___2 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___2);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___2];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___2];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___2] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___2] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___2]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___2] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___2] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___2]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___2(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___2] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___2]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___2[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___2[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___2(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___2(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___2(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___2(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___2(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___2(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___2(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___2(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___2(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___2(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___2(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___2(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___2(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___2(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___2(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___2(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___2(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___2(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___2(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifcomb.c"
static char *VersionStr___1  =    (char *)"GifComb Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:56\n(C) Copyright 1989 Gershon Elber.\n";
#line 58 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifcomb.c"
static char *CtrlStr___1  =    (char *)"GifComb q%- m%-MaskGIFFile!s h%- GifFile!*s";
#line 64
static int ReadUntilImage(GifFileType *GifFile ) ;
#line 65
static void QuitGifError___0(GifFileType *GifFileIn1 , GifFileType *GifFileIn2 , GifFileType *GifMaskFile ,
                             GifFileType *GifFileOut ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifcomb.c"
static int ReadUntilImage(GifFileType *GifFile ) 
{ 
  int ExtCode ;
  GifRecordType RecordType ;
  GifByteType *Extension ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 228
    tmp = DGifGetRecordType(GifFile, & RecordType);
    }
#line 228
    if (tmp == 0) {
#line 229
      return (0);
    }
    {
#line 232
    if ((unsigned int )RecordType == 2U) {
#line 232
      goto case_2;
    }
#line 234
    if ((unsigned int )RecordType == 3U) {
#line 234
      goto case_3;
    }
#line 243
    if ((unsigned int )RecordType == 4U) {
#line 243
      goto case_4;
    }
#line 245
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 233
    tmp___0 = DGifGetImageDesc(GifFile);
    }
#line 233
    return (tmp___0);
    case_3: /* CIL Label */ 
    {
#line 236
    tmp___1 = DGifGetExtension(GifFile, & ExtCode, & Extension);
    }
#line 236
    if (tmp___1 == 0) {
#line 237
      return (0);
    }
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 239
      if (! ((unsigned long )Extension != (unsigned long )((void *)0))) {
#line 239
        goto while_break___0;
      }
      {
#line 240
      tmp___2 = DGifGetExtensionNext(GifFile, & Extension);
      }
#line 240
      if (tmp___2 == 0) {
#line 241
        return (0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 242
    goto switch_break;
    case_4: /* CIL Label */ 
#line 244
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 246
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 227
    if (! ((unsigned int )RecordType != 4U)) {
#line 227
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  return (0);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifcomb.c"
static void QuitGifError___0(GifFileType *GifFileIn1 , GifFileType *GifFileIn2 , GifFileType *GifMaskFile ,
                             GifFileType *GifFileOut ) 
{ 


  {
  {
#line 260
  PrintGifError();
  }
#line 261
  if ((unsigned long )GifFileIn1 != (unsigned long )((void *)0)) {
    {
#line 261
    DGifCloseFile(GifFileIn1);
    }
  }
#line 262
  if ((unsigned long )GifFileIn2 != (unsigned long )((void *)0)) {
    {
#line 262
    DGifCloseFile(GifFileIn2);
    }
  }
#line 263
  if ((unsigned long )GifMaskFile != (unsigned long )((void *)0)) {
    {
#line 263
    DGifCloseFile(GifMaskFile);
    }
  }
#line 264
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 264
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 265
  exit(1);
  }
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___1  ;
#line 141
static int GATestAllSatis___1(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___1(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___1(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___1(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___1(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___1(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___1(int argc , char **argv ) ;
#line 156
static char *MyMalloc___1(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___1  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___1(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___1 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___1 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___1, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___1(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___1((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___1 = LocalToken___1;
#line 264
        *(LocalToken___1 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___1(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___1 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___1 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___1(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___1(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___1(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___1((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___1(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___1 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___1 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___1(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___1((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___1((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___1((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___1((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___1((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___1((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___1((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___1((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___1((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___1((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___1((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___1((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___1(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___1(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___1(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___1(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___2(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___2(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___2(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___2(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___2(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___2(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___2(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___2(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___2(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___2(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___2(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___2(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___2(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___2(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___2[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___2(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___2(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___2[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___2(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___2  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___2  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___2  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___2  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___2  =    100L;
#line 62
static void GetScanLine___2(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___2(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___2(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___2 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___2 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___2;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___2(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___2(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___2(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___3  ;
#line 61
static int SubdivColorMap___3(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___3(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___3(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___3 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___3);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___3];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___3];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___3] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___3] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___3]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___3] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___3] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___3]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___3(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___3] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___3]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___3[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___3[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___3(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___3(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___3(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___3(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___3(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___3(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___3(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___3(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___3(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___3(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___3(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___3(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___3(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___3(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___3(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___3(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___3(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___3(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___3(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___2  ;
#line 141
static int GATestAllSatis___2(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___2(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___2(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___2(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___2(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___2(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___2(int argc , char **argv ) ;
#line 156
static char *MyMalloc___2(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___2  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___2(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___2 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___2 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___2, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___2(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___2((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___2 = LocalToken___2;
#line 264
        *(LocalToken___2 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___2(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___2 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___2 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___2(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___2(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___2(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___2((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___2(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___2 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___2 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___2(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___2((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___2((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___2((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___2((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___2((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___2((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___2((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___2((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___2((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___2((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___2((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___2((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___2(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___2(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___2(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___2(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___3(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___3(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___3(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___3(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___3(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___3(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___3(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___3(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___3(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___3(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___3(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___3(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___3(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___3(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___3[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___3(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___3(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___3[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___3(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static char *VersionStr___2  =    (char *)"GifClrMp Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:05\n(C) Copyright 1989 Gershon Elber.\n";
#line 65 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static char *CtrlStr___2  =    (char *)"GifClrMp q%- s%- t%-TranslationFile!s l%-ColorMapFile!s g%-Gamma!F i%-Image#!d h%- GifFile!*s";
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static int SaveFlag  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static int TranslateFlag  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static int LoadFlag  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static int GammaFlag  =    0;
#line 76 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static double Gamma  =    1.0;
#line 78 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static FILE *ColorFile  =    (FILE *)((void *)0);
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
FILE *TranslateFile  =    (FILE *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static GifPixelType Translation[256]  ;
#line 84
static ColorMapObject *ModifyColorMap(ColorMapObject *ColorMap___3 ) ;
#line 85
static void QuitGifError___1(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 281 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static ColorMapObject *ModifyColorMap(ColorMapObject *ColorMap___3 ) 
{ 
  int i ;
  int Dummy ;
  int Red ;
  int Green ;
  int Blue ;
  int Max ;
  double Gamma1 ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  ColorMapObject *NewMap ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 283
  Max = 0;
#line 286
  if (SaveFlag) {
#line 288
    i = 0;
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 288
      if (! (i < ColorMap___3->ColorCount)) {
#line 288
        goto while_break;
      }
      {
#line 289
      fprintf((FILE */* __restrict  */)ColorFile, (char const   */* __restrict  */)"%3d %3d %3d %3d\n",
              i, (int )(ColorMap___3->Colors + i)->Red, (int )(ColorMap___3->Colors + i)->Green,
              (int )(ColorMap___3->Colors + i)->Blue);
#line 288
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 293
    return (ColorMap___3);
  } else
#line 295
  if (LoadFlag) {
#line 297
    i = 0;
    {
#line 297
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 297
      if (! (i < ColorMap___3->ColorCount)) {
#line 297
        goto while_break___0;
      }
      {
#line 298
      tmp = feof(ColorFile);
      }
#line 298
      if (tmp) {
        {
#line 299
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "GifClrMp", "Color file to load color map from, too small.");
#line 299
        exit(-3);
        }
      }
      {
#line 300
      fscanf((FILE */* __restrict  */)ColorFile, (char const   */* __restrict  */)"%3d %3d %3d %3d\n",
             & Dummy, & Red, & Green, & Blue);
#line 301
      (ColorMap___3->Colors + i)->Red = (GifByteType )Red;
#line 302
      (ColorMap___3->Colors + i)->Green = (GifByteType )Green;
#line 303
      (ColorMap___3->Colors + i)->Blue = (GifByteType )Blue;
#line 297
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 305
    return (ColorMap___3);
  } else
#line 307
  if (GammaFlag) {
#line 309
    Gamma1 = 1.0 / Gamma;
#line 310
    i = 0;
    {
#line 310
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 310
      if (! (i < ColorMap___3->ColorCount)) {
#line 310
        goto while_break___1;
      }
      {
#line 311
      tmp___0 = pow((double )(ColorMap___3->Colors + i)->Red / 255.0, Gamma1);
#line 311
      (ColorMap___3->Colors + i)->Red = (GifByteType )((int )((double )255 * tmp___0));
#line 313
      tmp___1 = pow((double )(ColorMap___3->Colors + i)->Green / 255.0, Gamma1);
#line 313
      (ColorMap___3->Colors + i)->Green = (GifByteType )((int )((double )255 * tmp___1));
#line 315
      tmp___2 = pow((double )(ColorMap___3->Colors + i)->Blue / 255.0, Gamma1);
#line 315
      (ColorMap___3->Colors + i)->Blue = (GifByteType )((int )((double )255 * tmp___2));
#line 310
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 318
    return (ColorMap___3);
  } else
#line 320
  if (TranslateFlag) {
#line 324
    i = 0;
    {
#line 324
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 324
      if (! (i < ColorMap___3->ColorCount)) {
#line 324
        goto while_break___2;
      }
      {
#line 326
      tmp___4 = feof(TranslateFile);
      }
#line 326
      if (tmp___4) {
        {
#line 327
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "GifClrMp", "Color file to load color map from, too small.");
#line 327
        exit(-3);
        }
      }
      {
#line 328
      fscanf((FILE */* __restrict  */)TranslateFile, (char const   */* __restrict  */)"%3d %3d\n",
             & Dummy, & tmp___3);
#line 329
      Translation[i] = (GifPixelType )tmp___3;
      }
#line 330
      if ((int )Translation[i] > Max) {
#line 331
        Max = (int )Translation[i];
      }
#line 324
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 334
    tmp___5 = BitSize(Max + 1);
#line 334
    NewMap = MakeMapObject(1 << tmp___5, (GifColorType const   *)((void *)0));
    }
#line 334
    if ((unsigned long )NewMap == (unsigned long )((void *)0)) {
      {
#line 335
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "GifClrMp", "Out of memory while allocating color map!");
#line 335
      exit(-3);
      }
    }
#line 338
    i = 0;
    {
#line 338
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 338
      if (! (i < ColorMap___3->ColorCount)) {
#line 338
        goto while_break___3;
      }
#line 339
      *(NewMap->Colors + i) = *(ColorMap___3->Colors + Translation[i]);
#line 338
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 342
    return (NewMap);
  } else {
    {
#line 346
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifClrMp", "Nothing to do!");
#line 346
    exit(-3);
    }
#line 347
    return (ColorMap___3);
  }
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclrmp.c"
static void QuitGifError___1(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 356
  PrintGifError();
  }
#line 357
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 357
    DGifCloseFile(GifFileIn);
    }
  }
#line 358
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 358
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 359
  exit(1);
  }
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___3  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___3  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___3  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___3  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___3  =    100L;
#line 62
static void GetScanLine___3(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___3(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___3(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___3 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___3 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___3;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___3(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___3(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___3(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___4  ;
#line 61
static int SubdivColorMap___4(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___4(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___4(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___4 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___4);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___4];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___4];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___4] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___4] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___4]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___4] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___4] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___4]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___4(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___4] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___4]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___4[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___4[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___4(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___4(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___4(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___4(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___4(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___4(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___4(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___4(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___4(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___4(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___4(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___4(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___4(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___4(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___4(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___4(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___4(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___4(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___4(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___3  ;
#line 141
static int GATestAllSatis___3(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___3(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___3(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___3(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___3(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___3(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___3(int argc , char **argv ) ;
#line 156
static char *MyMalloc___3(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___3  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___3(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___3 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___3 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___3, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___3(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___3((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___3 = LocalToken___3;
#line 264
        *(LocalToken___3 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___3(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___3 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___3 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___3(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___3(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___3(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___3((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___3(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___3 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___3 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___3(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___3((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___3((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___3((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___3((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___3((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___3((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___3((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___3((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___3((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___3((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___3((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___3((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___3(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___3(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___3(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___3(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___4(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___4(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___4(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___4(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___4(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___4(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___4(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___4(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___4(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___4(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___4(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___4(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___4(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___4(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___4[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___4(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___4(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___4[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___4(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___4  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___4  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___4  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___4  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___4  =    100L;
#line 62
static void GetScanLine___4(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___4(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___4(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___4 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___4 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___4;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___4(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifpos.c"
static char *VersionStr___3  =    (char *)"GifPos Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:59\n(C) Copyright 1989 Gershon Elber.\n";
#line 55 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifpos.c"
static char *CtrlStr___3  =    (char *)"GifPos q%- s%-Width|Height!d!d i%-Left|Top!d!d n%-n|Left|Top!d!d!d h%- GifFile!*s";
#line 61
static void QuitGifError___2(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifpos.c"
static void QuitGifError___2(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 204
  PrintGifError();
  }
#line 205
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 205
    DGifCloseFile(GifFileIn);
    }
  }
#line 206
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 206
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 207
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___4(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___4(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___5  ;
#line 61
static int SubdivColorMap___5(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___5(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___5(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___5 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___5);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___5];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___5];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___5] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___5] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___5]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___5] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___5] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___5]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___5(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___5] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___5]);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static char *VersionStr___4  =    (char *)"Gif2PS Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:53\n(C) Copyright 1989 Gershon Elber.\n";
#line 76 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static char *CtrlStr___4  =    (char *)"Gif2PS q%- x%- y%- s%-SizeX|SizeY!F!F p%-PosX|PosY!F!F i%- n%-#Copies!d h%- GifFile!*s";
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int ImageNum  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int BackGround  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int ForceXFlag  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int ForceYFlag  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int SizeFlag  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int PosFlag  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int InvertFlag  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int NumCopiesFlag  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int HelpFlag  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int NumOfCopies  =    1;
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int InterlacedOffset[4]  = {      0,      4,      2,      1};
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int InterlacedJumps[4]  = {      8,      8,      4,      2};
#line 83 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int PSOrientation  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static double PSSizeX  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static double PSSizeY  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static double PSPosX  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static double PSPosY  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static GifColorType *ColorMap  ;
#line 101
static void DumpScreen2PS(GifRowType *ScreenBuffer , int ScreenWidth , int ScreenHeight ) ;
#line 103
static void PutString(unsigned char *Line , int Len ) ;
#line 275 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static void DumpScreen2PS(GifRowType *ScreenBuffer , int ScreenWidth , int ScreenHeight ) 
{ 
  int i ;
  int j ;
  double Aspect ;
  GifByteType *OutLine ;
  GifByteType Data ;
  GifPixelType *Line ;
  GifColorType *ColorMapEntry___0 ;
  void *tmp ;

  {
#line 285
  if (PSOrientation == 0) {
#line 286
    if (ScreenWidth > ScreenHeight) {
#line 287
      PSOrientation = 2;
    } else {
#line 289
      PSOrientation = 1;
    }
  }
#line 292
  Aspect = (double )ScreenHeight / (double )ScreenWidth;
#line 294
  if (! SizeFlag) {
    {
#line 296
    if (PSOrientation == 1) {
#line 296
      goto case_1;
    }
#line 306
    if (PSOrientation == 2) {
#line 306
      goto case_2;
    }
#line 295
    goto switch_break;
    case_1: /* CIL Label */ 
#line 297
    if (Aspect > 9.0 / 7.5) {
#line 298
      PSSizeX = 9.0 / Aspect;
#line 299
      PSSizeY = 9.0;
    } else {
#line 302
      PSSizeX = 7.5;
#line 303
      PSSizeY = 7.5 * Aspect;
    }
#line 305
    goto switch_break;
    case_2: /* CIL Label */ 
#line 307
    if ((double )1 / Aspect > 9.0 / 7.5) {
#line 308
      PSSizeX = 9.0 * Aspect;
#line 309
      PSSizeY = 9.0;
    } else {
#line 312
      PSSizeX = 7.5;
#line 313
      PSSizeY = 7.5 / Aspect;
    }
#line 315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 318
    if (7.5 < PSSizeX) {
      {
#line 319
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "Gif2PS", "X Size specified is too big, page size selected.");
#line 320
      PSSizeX = 7.5;
      }
    }
#line 322
    if (9.0 < PSSizeY) {
      {
#line 323
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "Gif2PS", "Y Size specified is too big, page size selected.");
#line 324
      PSSizeX = 9.0;
      }
    }
  }
#line 328
  if (! PosFlag) {
#line 329
    PSPosX = (8.5 - PSSizeX) / (double )2;
#line 330
    PSPosY = (11.0 - PSSizeY) / (double )2;
  } else
#line 333
  if (PSPosX + PSSizeX > 7.5) {
    {
#line 334
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2PS", "Requested position will put image out of page, aborted.");
#line 334
    exit(-3);
    }
  } else
#line 333
  if (PSPosY + PSSizeY > 9.0) {
    {
#line 334
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2PS", "Requested position will put image out of page, aborted.");
#line 334
    exit(-3);
    }
  }
  {
#line 338
  printf((char const   */* __restrict  */)"%%!\n");
#line 339
  printf((char const   */* __restrict  */)"%%%%Creator: %s\n", "Gif2PS");
#line 340
  printf((char const   */* __restrict  */)"/#copies %d def\n", NumOfCopies);
#line 341
  printf((char const   */* __restrict  */)"gsave\n");
#line 342
  printf((char const   */* __restrict  */)"72 72 scale\t\t\t\t%% Lets talk inches.\n");
#line 343
  printf((char const   */* __restrict  */)"/oneline %d string def\t\t\t%% Allocate one scan line.\n",
         ScreenWidth);
#line 345
  printf((char const   */* __restrict  */)"/drawimage {\n");
#line 346
  printf((char const   */* __restrict  */)"\t%d %d 8 [%d 0 0 %d 0 %d]\n", ScreenWidth,
         ScreenHeight, ScreenWidth, - ScreenHeight, ScreenHeight);
#line 348
  printf((char const   */* __restrict  */)"\t{ currentfile oneline readhexstring pop } image\n");
#line 349
  printf((char const   */* __restrict  */)"} def\n");
  }
  {
#line 351
  if (PSOrientation == 1) {
#line 351
    goto case_1___0;
  }
#line 355
  if (PSOrientation == 2) {
#line 355
    goto case_2___0;
  }
#line 350
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 352
  printf((char const   */* __restrict  */)"%f %f translate\n", PSPosX, PSPosY);
#line 353
  printf((char const   */* __restrict  */)"%f %f scale\n", PSSizeX, PSSizeY);
  }
#line 354
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 356
  printf((char const   */* __restrict  */)"%f %f translate\n", PSPosX + PSSizeX, PSPosY);
#line 357
  printf((char const   */* __restrict  */)"90 rotate\n");
#line 358
  printf((char const   */* __restrict  */)"%f %f scale\n", PSSizeY, PSSizeX);
  }
#line 359
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 361
  printf((char const   */* __restrict  */)"drawimage\n");
#line 363
  tmp = malloc(sizeof(GifByteType ) * (unsigned long )ScreenWidth);
#line 363
  OutLine = (GifByteType *)tmp;
  }
#line 363
  if ((unsigned long )OutLine == (unsigned long )((void *)0)) {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2PS", "Failed to allocate memory required, aborted.");
#line 365
    exit(-3);
    }
  }
#line 367
  i = 0;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! (i < ScreenHeight)) {
#line 367
      goto while_break;
    }
    {
#line 368
    GifQprintf((char *)"\b\b\b\b%-4d", ScreenHeight - i);
#line 370
    Line = *(ScreenBuffer + i);
#line 371
    j = 0;
    }
    {
#line 371
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 371
      if (! (j < ScreenWidth)) {
#line 371
        goto while_break___0;
      }
#line 372
      ColorMapEntry___0 = ColorMap + *(Line + j);
#line 373
      Data = (GifByteType )(((30U * (unsigned int )ColorMapEntry___0->Red + 59U * (unsigned int )ColorMapEntry___0->Green) + 11U * (unsigned int )ColorMapEntry___0->Blue) / 100U);
#line 376
      if (InvertFlag) {
#line 376
        *(OutLine + j) = (GifByteType )(255 - (int )Data);
      } else {
#line 376
        *(OutLine + j) = Data;
      }
#line 371
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 379
    PutString(OutLine, ScreenWidth);
#line 367
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 381
  free((void *)OutLine);
#line 383
  printf((char const   */* __restrict  */)"\nshowpage\n");
#line 384
  printf((char const   */* __restrict  */)"grestore\n");
  }
#line 385
  return;
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static int Counter  =    0;
#line 394 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static char *Hex  =    (char *)"0123456789ABCDEF";
#line 390 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2ps.c"
static void PutString(unsigned char *Line , int Len ) 
{ 
  int i ;

  {
#line 396
  i = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (i < Len)) {
#line 396
      goto while_break;
    }
#line 397
    Counter ++;
#line 397
    if (Counter % 40 == 0) {
      {
#line 398
      putchar('\n');
#line 399
      Counter = 1;
      }
    }
    {
#line 401
    putchar((int )*(Hex + ((int )*(Line + i) >> 4)));
#line 402
    putchar((int )*(Hex + ((int )*(Line + i) & 15)));
#line 396
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___5[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___5[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___5(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___5(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___5(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___5(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___5(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___5(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___5(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___5(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___5(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___5(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___5(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___5(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___5(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___5(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___5(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___5(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___5(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___5(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___5(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___4  ;
#line 141
static int GATestAllSatis___4(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___4(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___4(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___4(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___4(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___4(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___4(int argc , char **argv ) ;
#line 156
static char *MyMalloc___4(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___4  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___4(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___4 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___4 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___4, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___4(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___4((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___4 = LocalToken___4;
#line 264
        *(LocalToken___4 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___4(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___4 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___4 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___4(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___4(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___4(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___4((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___4(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___4 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___4 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___4(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___4((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___4((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___4((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___4((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___4((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___4((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___4((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___4((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___4((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___4((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___4((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___4((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___4(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___4(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___4(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___4(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___5(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___5(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___5(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___5(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___5(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___5(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___5(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___5(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___5(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___5(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___5(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___5(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___5(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___5(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___5[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___5(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___5(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___5[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___5(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___5  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___5  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___5  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___5  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___5  =    100L;
#line 62
static void GetScanLine___5(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___5(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___5(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___5 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___5 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___5;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___5(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___5(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___5(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___6  ;
#line 61
static int SubdivColorMap___6(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___6(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___6(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___6 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___6);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___6];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___6];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___6] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___6] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___6]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___6] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___6] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___6]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___6(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___6] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___6]);
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static char *VersionStr___5  =    (char *)"Gif2Epsn Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:53\n(C) Copyright 1989 Gershon Elber.\n";
#line 88 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static char *CtrlStr___5  =    (char *)"Gif2Epsn q%- d%-DitherSize!d t%-BWThreshold!d m%-Mapping!d i%- n%- p%-PrinterName!s h%- GifFile!*s";
#line 94 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static char *PrinterName  =    (char *)((void *)0);
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int ImageNum___0  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int BackGround___0  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int DitherSize  =    2;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int DitherFlag  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int BWThresholdFlag  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int Threshold  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int BWThreshold  =    5000;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int Mapping  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int MappingFlag  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int InvertFlag___0  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int NiceFlag  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int PrinterFlag  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int HelpFlag___0  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int ColorToBWMapping  =    0;
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int InterlacedOffset___0[4]  = {      0,      4,      2,      1};
#line 97 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static int InterlacedJumps___0[4]  = {      8,      8,      4,      2};
#line 111 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static GifColorType *ColorMap___0  ;
#line 114
static void EvalDitheredScanline(GifRowType *ScreenBuffer , int Row , int RowSize ,
                                 GifRowType *DitherBuffer ) ;
#line 116
static void DumpScreen2Epsn(GifRowType *ScreenBuffer , int ScreenWidth , int ScreenHeight ) ;
#line 118
static void PutString___0(FILE *Prt , int DirectPrint , char *Str , int Len ) ;
#line 119
static void PutString2(FILE *Prt , int DirectPrint , char *Str , int Len ) ;
#line 308 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static char Dither2[2][2]  = { {        (char)1,        (char)3}, 
   {        (char)4,        (char)2}};
#line 312 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static char Dither3[3][3]  = { {        (char)7,        (char)9,        (char)5}, 
   {        (char)2,        (char)1,        (char)4}, 
   {        (char)6,        (char)3,        (char)8}};
#line 317 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static char Dither4[4][4]  = { {        (char)1,        (char)9,        (char)3,        (char)11}, 
   {        (char)13,        (char)5,        (char)15,        (char)7}, 
   {        (char)4,        (char)12,        (char)2,        (char)10}, 
   {        (char)16,        (char)8,        (char)14,        (char)6}};
#line 305 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static void EvalDitheredScanline(GifRowType *ScreenBuffer , int Row , int RowSize ,
                                 GifRowType *DitherBuffer ) 
{ 
  int i ;
  int j ;
  int k ;
  int Level ;
  long Intensity ;
  GifColorType *ColorMapEntry___0 ;

  {
#line 329
  i = 0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! (i <= RowSize - DitherSize)) {
#line 329
      goto while_break;
    }
#line 330
    Intensity = 0L;
#line 331
    j = Row;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! (j < Row + DitherSize)) {
#line 331
        goto while_break___0;
      }
#line 332
      k = 0;
      {
#line 332
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 332
        if (! (k < DitherSize)) {
#line 332
          goto while_break___1;
        }
#line 333
        ColorMapEntry___0 = ColorMap___0 + *(*(ScreenBuffer + j) + (i + k));
#line 334
        Intensity += (long )((30 * (int )ColorMapEntry___0->Red + 59 * (int )ColorMapEntry___0->Green) + 11 * (int )ColorMapEntry___0->Blue);
#line 332
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 331
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 342
    Level = (int )(((Intensity / 2550L) * 5000L) / ((long )BWThreshold * 10L));
    {
#line 345
    if (DitherSize == 2) {
#line 345
      goto case_2;
    }
#line 350
    if (DitherSize == 3) {
#line 350
      goto case_3;
    }
#line 355
    if (DitherSize == 4) {
#line 355
      goto case_4;
    }
#line 344
    goto switch_break;
    case_2: /* CIL Label */ 
#line 346
    j = 0;
    {
#line 346
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 346
      if (! (j < DitherSize)) {
#line 346
        goto while_break___2;
      }
#line 347
      k = 0;
      {
#line 347
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 347
        if (! (k < DitherSize)) {
#line 347
          goto while_break___3;
        }
#line 348
        *(*(DitherBuffer + j) + (i + k)) = (unsigned char )((int )Dither2[j][k] <= Level);
#line 347
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 346
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 349
    goto switch_break;
    case_3: /* CIL Label */ 
#line 351
    j = 0;
    {
#line 351
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 351
      if (! (j < DitherSize)) {
#line 351
        goto while_break___4;
      }
#line 352
      k = 0;
      {
#line 352
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 352
        if (! (k < DitherSize)) {
#line 352
          goto while_break___5;
        }
#line 353
        *(*(DitherBuffer + j) + (i + k)) = (unsigned char )((int )Dither3[j][k] <= Level);
#line 352
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 351
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 354
    goto switch_break;
    case_4: /* CIL Label */ 
#line 356
    j = 0;
    {
#line 356
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 356
      if (! (j < DitherSize)) {
#line 356
        goto while_break___6;
      }
#line 357
      k = 0;
      {
#line 357
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 357
        if (! (k < DitherSize)) {
#line 357
          goto while_break___7;
        }
#line 358
        *(*(DitherBuffer + j) + (i + k)) = (unsigned char )((int )Dither4[j][k] <= Level);
#line 357
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 356
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 359
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 329
    i += DitherSize;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static void DumpScreen2Epsn(GifRowType *ScreenBuffer , int ScreenWidth , int ScreenHeight ) 
{ 
  int i ;
  int j ;
  int p ;
  int Size ;
  int LeftCWidth ;
  int Len ;
  int DirectPrint ;
  int DitheredLinesLeft ;
  int DitheredLinesCount ;
  int MapInvert[2] ;
  char LinePrefixLen[2] ;
  GifByteType *EpsonBuffer ;
  GifPixelType *Line ;
  GifRowType *DitherBuffer ;
  GifColorType *ColorMapEntry___0 ;
  FILE *Prt ;
  size_t tmp ;
  void *tmp___0 ;
  GifRowType tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 379
  DirectPrint = 0;
#line 379
  DitheredLinesLeft = 0;
#line 379
  DitheredLinesCount = 0;
#line 386
  Prt = (FILE *)((void *)0);
#line 402
  if (! DirectPrint) {
    {
#line 403
    tmp = strlen((char const   *)PrinterName);
    }
#line 403
    if (tmp == 0UL) {
#line 407
      Prt = stdout;
    } else {
      {
#line 411
      Prt = fopen((char const   */* __restrict  */)PrinterName, (char const   */* __restrict  */)"wb");
      }
#line 412
      if ((unsigned long )Prt == (unsigned long )((void *)0)) {
        {
#line 414
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "Gif2Epsn", "Failed to open output (printer) file.");
#line 414
        exit(-3);
        }
      }
    }
  }
  {
#line 426
  tmp___0 = malloc((size_t )ScreenWidth);
#line 426
  EpsonBuffer = (GifByteType *)tmp___0;
  }
#line 426
  if ((unsigned long )EpsonBuffer == (unsigned long )((void *)0)) {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2Epsn", "Failed to allocate memory required, aborted.");
#line 427
    exit(-3);
    }
  }
#line 430
  if (ColorToBWMapping == 2) {
    {
#line 431
    tmp___3 = malloc(4UL * sizeof(GifRowType *));
#line 431
    DitherBuffer = (GifRowType *)tmp___3;
    }
#line 431
    if ((unsigned long )DitherBuffer != (unsigned long )((void *)0)) {
#line 433
      Size = (int )((unsigned long )ScreenWidth * sizeof(GifPixelType ));
#line 434
      i = 0;
      {
#line 434
      while (1) {
        while_continue: /* CIL Label */ ;
#line 434
        if (! (i < 4)) {
#line 434
          goto while_break;
        }
        {
#line 435
        tmp___2 = malloc((size_t )Size);
#line 435
        tmp___1 = (GifRowType )tmp___2;
#line 435
        *(DitherBuffer + i) = tmp___1;
        }
#line 435
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 436
          DitherBuffer = (GifRowType *)((void *)0);
#line 437
          goto while_break;
        }
#line 434
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 441
    if ((unsigned long )DitherBuffer == (unsigned long )((void *)0)) {
      {
#line 442
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "Gif2Epsn", "Failed to allocate memory required, aborted.");
#line 442
      exit(-3);
      }
    }
  } else {
#line 445
    DitherBuffer = (GifRowType *)((void *)0);
  }
  {
#line 448
  PutString___0(Prt, DirectPrint, (char *)"\033@", 2);
#line 449
  PutString___0(Prt, DirectPrint, (char *)"\033A\b", 3);
#line 452
  LeftCWidth = (80 - ScreenWidth / 8) / 2;
  }
#line 454
  if (InvertFlag___0) {
#line 455
    MapInvert[0] = 1;
#line 456
    MapInvert[1] = 0;
  } else {
#line 459
    MapInvert[0] = 0;
#line 460
    MapInvert[1] = 1;
  }
#line 463
  i = 0;
#line 463
  p = 0;
  {
#line 463
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 463
    if (! (i < ScreenHeight)) {
#line 463
      goto while_break___0;
    }
    {
#line 464
    GifQprintf((char *)"\b\b\b\b%-4d", ScreenHeight - i);
#line 465
    Line = *(ScreenBuffer + i);
    }
#line 468
    if (p == 8) {
#line 469
      Len = ScreenWidth - 1;
      {
#line 469
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 469
        if (! (Len >= 0)) {
#line 469
          goto while_break___1;
        }
#line 470
        if (*(EpsonBuffer + Len)) {
#line 470
          goto while_break___1;
        }
#line 469
        Len --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 473
      tmp___4 = Len;
#line 473
      Len ++;
#line 473
      if (tmp___4 >= 0) {
#line 475
        j = 0;
        {
#line 475
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 475
          if (! (j < LeftCWidth)) {
#line 475
            goto while_break___2;
          }
          {
#line 476
          PutString___0(Prt, DirectPrint, (char *)" ", 1);
#line 475
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 479
        if (NiceFlag) {
          {
#line 480
          PutString___0(Prt, DirectPrint, (char *)"\033L", 2);
#line 481
          LinePrefixLen[0] = (char )((Len * 2) % 256);
#line 482
          LinePrefixLen[1] = (char )((Len * 2) / 256);
#line 483
          PutString___0(Prt, DirectPrint, LinePrefixLen, 2);
#line 484
          PutString2(Prt, DirectPrint, (char *)EpsonBuffer, Len);
          }
        } else {
          {
#line 487
          PutString___0(Prt, DirectPrint, (char *)"\033K", 2);
#line 488
          LinePrefixLen[0] = (char )(Len % 256);
#line 489
          LinePrefixLen[1] = (char )(Len / 256);
#line 490
          PutString___0(Prt, DirectPrint, LinePrefixLen, 2);
#line 491
          PutString___0(Prt, DirectPrint, (char *)EpsonBuffer, Len);
          }
        }
      }
      {
#line 494
      PutString___0(Prt, DirectPrint, (char *)"\r\n", 2);
#line 495
      p = 0;
      }
    }
    {
#line 501
    if (ColorToBWMapping == 0) {
#line 501
      goto case_0;
    }
#line 506
    if (ColorToBWMapping == 1) {
#line 506
      goto case_1;
    }
#line 520
    if (ColorToBWMapping == 2) {
#line 520
      goto case_2;
    }
#line 500
    goto switch_break;
    case_0: /* CIL Label */ 
#line 502
    j = 0;
    {
#line 502
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 502
      if (! (j < ScreenWidth)) {
#line 502
        goto while_break___3;
      }
#line 503
      *(EpsonBuffer + j) = (GifByteType )(((int )*(EpsonBuffer + j) << 1) + MapInvert[(int )*(Line + j) != BackGround___0]);
#line 502
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 505
    goto switch_break;
    case_1: /* CIL Label */ 
#line 507
    j = 0;
    {
#line 507
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 507
      if (! (j < ScreenWidth)) {
#line 507
        goto while_break___4;
      }
#line 508
      ColorMapEntry___0 = ColorMap___0 + *(Line + j);
#line 513
      *(EpsonBuffer + j) = (GifByteType )(((int )*(EpsonBuffer + j) << 1) + MapInvert[(30 * (int )ColorMapEntry___0->Red + 59 * (int )ColorMapEntry___0->Green) + 11 * (int )ColorMapEntry___0->Blue > BWThreshold]);
#line 507
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 519
    goto switch_break;
    case_2: /* CIL Label */ 
#line 521
    tmp___6 = DitheredLinesLeft;
#line 521
    DitheredLinesLeft --;
#line 521
    if (tmp___6 == 0) {
#line 522
      if (i < ScreenHeight - DitherSize) {
#line 522
        tmp___5 = i;
      } else {
#line 522
        tmp___5 = ScreenHeight - DitherSize;
      }
      {
#line 522
      EvalDitheredScanline(ScreenBuffer, tmp___5, ScreenWidth, DitherBuffer);
#line 526
      DitheredLinesLeft = DitherSize - 1;
#line 527
      DitheredLinesCount = 0;
      }
    }
#line 529
    tmp___7 = DitheredLinesCount;
#line 529
    DitheredLinesCount ++;
#line 529
    Line = *(DitherBuffer + tmp___7);
#line 530
    j = 0;
    {
#line 530
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 530
      if (! (j < ScreenWidth)) {
#line 530
        goto while_break___5;
      }
#line 531
      *(EpsonBuffer + j) = (GifByteType )(((int )*(EpsonBuffer + j) << 1) + MapInvert[*(Line + j)]);
#line 530
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 533
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 463
    i ++;
#line 463
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 538
  if (p != 0) {
#line 539
    Len = ScreenWidth - 1;
    {
#line 539
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 539
      if (! (Len >= 0)) {
#line 539
        goto while_break___6;
      }
#line 540
      if (*(EpsonBuffer + Len)) {
#line 540
        goto while_break___6;
      }
#line 539
      Len --;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 541
    tmp___8 = Len;
#line 541
    Len ++;
#line 541
    if (tmp___8 >= 0) {
#line 542
      i = 8 - p;
#line 543
      j = 0;
      {
#line 543
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 543
        if (! (j < ScreenWidth)) {
#line 543
          goto while_break___7;
        }
#line 543
        *(EpsonBuffer + j) = (GifByteType )((int )*(EpsonBuffer + j) << i);
#line 543
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 546
      j = 0;
      {
#line 546
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 546
        if (! (j < LeftCWidth)) {
#line 546
          goto while_break___8;
        }
        {
#line 547
        PutString___0(Prt, DirectPrint, (char *)" ", 1);
#line 546
        j ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 549
      if (NiceFlag) {
        {
#line 550
        PutString___0(Prt, DirectPrint, (char *)"\033L", 2);
#line 551
        LinePrefixLen[0] = (char )((Len * 2) % 256);
#line 552
        LinePrefixLen[1] = (char )((Len * 2) / 256);
#line 553
        PutString___0(Prt, DirectPrint, LinePrefixLen, 2);
#line 554
        PutString2(Prt, DirectPrint, (char *)EpsonBuffer, Len);
        }
      } else {
        {
#line 557
        PutString___0(Prt, DirectPrint, (char *)"\033K", 2);
#line 558
        LinePrefixLen[0] = (char )(Len % 256);
#line 559
        LinePrefixLen[1] = (char )(Len / 256);
#line 560
        PutString___0(Prt, DirectPrint, LinePrefixLen, 2);
#line 561
        PutString___0(Prt, DirectPrint, (char *)EpsonBuffer, Len);
        }
      }
    }
    {
#line 564
    PutString___0(Prt, DirectPrint, (char *)"\r\n", 2);
    }
  }
  {
#line 567
  fclose(Prt);
  }
#line 568
  return;
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static void PutString___0(FILE *Prt , int DirectPrint , char *Str , int Len ) 
{ 
  int i ;

  {
#line 579
  if (DirectPrint) {
    {
#line 583
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2Epsn", "Can not print directly to a printer if not MSDOS.");
#line 583
    exit(-3);
    }
  } else {
#line 587
    i = 0;
    {
#line 587
    while (1) {
      while_continue: /* CIL Label */ ;
#line 587
      if (! (i < Len)) {
#line 587
        goto while_break;
      }
      {
#line 587
      fputc((int )*(Str + i), Prt);
#line 587
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 588
  return;
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2epsn.c"
static void PutString2(FILE *Prt , int DirectPrint , char *Str , int Len ) 
{ 
  int i ;

  {
#line 599
  if (DirectPrint) {
    {
#line 606
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2Epsn", "Can not print directly to a printer if not MSDOS.");
#line 606
    exit(-3);
    }
  } else {
#line 610
    i = 0;
    {
#line 610
    while (1) {
      while_continue: /* CIL Label */ ;
#line 610
      if (! (i < Len)) {
#line 610
        goto while_break;
      }
      {
#line 611
      fputc((int )*(Str + i), Prt);
#line 612
      fputc((int )*(Str + i), Prt);
#line 610
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 614
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___6[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___6[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___6(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___6(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___6(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___6(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___6(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___6(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___6(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___6(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___6(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___6(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___6(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___6(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___6(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___6(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___6(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___6(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___6(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___6(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___6(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___5  ;
#line 141
static int GATestAllSatis___5(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___5(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___5(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___5(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___5(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___5(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___5(int argc , char **argv ) ;
#line 156
static char *MyMalloc___5(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___5  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___5(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___5 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___5 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___5, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___5(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___5((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___5 = LocalToken___5;
#line 264
        *(LocalToken___5 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___5(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___5 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___5 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___5(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___5(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___5(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___5((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___5(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___5 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___5 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___5(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___5((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___5((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___5((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___5((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___5((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___5((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___5((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___5((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___5((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___5((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___5((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___5((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___5(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___5(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___5(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___5(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___6(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___6(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___6(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___6(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___6(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___6(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___6(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___6(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___6(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___6(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___6(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___6(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___6(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___6(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___6[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___6(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___6(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___6[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___6(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___6  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___6  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___6  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___6  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___6  =    100L;
#line 62
static void GetScanLine___6(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___6(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___6(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___6 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___6 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___6;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___6(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___6(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___6(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___7  ;
#line 61
static int SubdivColorMap___7(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___7(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___7(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___7 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___7);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___7];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___7];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___7] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___7] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___7]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___7] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___7] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___7]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___7(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___7] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___7]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___7[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___7[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___7(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___7(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___7(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___7(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___7(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___7(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___7(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___7(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___7(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___7(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___7(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___7(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___7(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___7(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___7(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___7(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___7(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___7(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___7(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___6  ;
#line 141
static int GATestAllSatis___6(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___6(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___6(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___6(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___6(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___6(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___6(int argc , char **argv ) ;
#line 156
static char *MyMalloc___6(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___6  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___6(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___6 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___6 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___6, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___6(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___6((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___6 = LocalToken___6;
#line 264
        *(LocalToken___6 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___6(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___6 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___6 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___6(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___6(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___6(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___6((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___6(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___6 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___6 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___6(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___6((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___6((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___6((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___6((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___6((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___6((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___6((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___6((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___6((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___6((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___6((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___6((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___6(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___6(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___6(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___6(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___7(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___7(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___7(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___7(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___7(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___7(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___7(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___7(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___7(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___7(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___7(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___7(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___7(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___7(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___7[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___7(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___7(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___7[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___7(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrsize.c"
static char *VersionStr___6  =    (char *)"GifRSize Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:00\n(C) Copyright 1989 Gershon Elber.\n";
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrsize.c"
static char *CtrlStr___6  =    (char *)"GifRSize q%- S%-X|Y!d!d s%-Scale!F x%-XScale!F y%-YScale!F h%- GifFile!*s";
#line 69 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrsize.c"
static GifPixelType BackGroundColor  =    (GifPixelType )0;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrsize.c"
static double XScale  =    0.5;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrsize.c"
static double YScale  =    0.5;
#line 74 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrsize.c"
static int XSize  =    0;
#line 74 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrsize.c"
static int YSize  =    0;
#line 78
static void ResizeLine(GifRowType LineIn , GifRowType LineOut , int InLineLen , int OutLineLen ) ;
#line 80
static void QuitGifError___3(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 284 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrsize.c"
static void ResizeLine(GifRowType LineIn , GifRowType LineOut , int InLineLen , int OutLineLen ) 
{ 
  int i ;
  int ix ;
  int last_ix ;
  double x ;
  GifRowType tmp ;
  int tmp___0 ;
  GifRowType tmp___1 ;

  {
#line 290
  OutLineLen --;
#line 292
  i = InLineLen;
#line 292
  x = 0.0;
#line 292
  last_ix = -1;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    tmp___0 = i;
#line 292
    i --;
#line 292
    if (! (tmp___0 > 0)) {
#line 292
      goto while_break;
    }
#line 296
    ix = (int )x;
    {
#line 297
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 297
      if (last_ix < ix) {
#line 297
        if (! (last_ix < OutLineLen)) {
#line 297
          goto while_break___0;
        }
      } else {
#line 297
        goto while_break___0;
      }
#line 298
      tmp = LineOut;
#line 298
      LineOut ++;
#line 298
      *tmp = *LineIn;
#line 297
      last_ix ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 292
    x += XScale;
#line 292
    LineIn ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  LineIn --;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (last_ix < OutLineLen)) {
#line 302
      goto while_break___1;
    }
#line 303
    tmp___1 = LineOut;
#line 303
    LineOut ++;
#line 303
    *tmp___1 = *LineIn;
#line 302
    last_ix ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrsize.c"
static void QuitGifError___3(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 311
  PrintGifError();
  }
#line 312
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 312
    DGifCloseFile(GifFileIn);
    }
  }
#line 313
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 313
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 314
  exit(1);
  }
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___7  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___7  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___7  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___7  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___7  =    100L;
#line 62
static void GetScanLine___7(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___7(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___7(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___7 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___7 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___7;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___7(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___7(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___7(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___8  ;
#line 61
static int SubdivColorMap___8(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___8(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___8(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___8 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___8);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___8];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___8];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___8] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___8] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___8]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___8] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___8] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___8]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___8(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___8] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___8]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___8[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___8[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___8(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___8(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___8(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___8(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___8(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___8(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___8(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___8(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___8(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___8(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___8(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___8(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___8(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___8(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___8(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___8(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___8(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___8(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___8(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___7  ;
#line 141
static int GATestAllSatis___7(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___7(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___7(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___7(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___7(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___7(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___7(int argc , char **argv ) ;
#line 156
static char *MyMalloc___7(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___7  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___7(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___7 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___7 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___7, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___7(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___7((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___7 = LocalToken___7;
#line 264
        *(LocalToken___7 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___7(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___7 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___7 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___7(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___7(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___7(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___7((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___7(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___7 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___7 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___7(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___7((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___7((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___7((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___7((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___7((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___7((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___7((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___7((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___7((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___7((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___7((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___7((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___7(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___7(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___7(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___7(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifovly.c"
static char *VersionStr___7  =    (char *)"gifovly Version 4.1, \tEric Raymond,\tMar  3 2016,   19:57:59\n(C) Copyright 1992 Eric Raymond.\n";
#line 53 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifovly.c"
static char *CtrlStr___7  =    (char *)"gifovly t%-TransparentColor!d h%-";
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___8(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___8(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___8(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___8(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___8(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___8(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___8(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___8(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___8(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___8(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___8(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___8(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___8(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___8(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___8[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___8(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___8(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___8[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___8(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___8  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___8  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___8  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___8  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___8  =    100L;
#line 62
static void GetScanLine___8(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___8(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___8(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___8 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___8 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___8;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___8(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___8(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___8(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___9  ;
#line 61
static int SubdivColorMap___9(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___9(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___9(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                              unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___9 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___9);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___9];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___9];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___9] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___9] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___9]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___9] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___9] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___9]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___9(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___9] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___9]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___9[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___9[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___9(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___9(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___9(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___9(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___9(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___9(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___9(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___9(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___9(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___9(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___9(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___9(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___9(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___9(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___9(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___9(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___9(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___9(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___9(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifflip.c"
static char *VersionStr___8  =    (char *)"GifFlip Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:57\n(C) Copyright 1989 Gershon Elber.\n";
#line 65 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifflip.c"
static char *CtrlStr___8  =    (char *)"GifFlip q%- r%- l%- x%- y%- h%- GifFile!*s";
#line 72 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifflip.c"
static int ImageNum___1  =    0;
#line 75
static int LoadImage(GifFileType *GifFile , GifRowType **ImageBufferPtr ) ;
#line 76
static int DumpImage(GifFileType *GifFile , GifRowType *ImageBuffer , int Width ,
                     int Height , int FlipDirection ) ;
#line 78
static void QuitGifError___4(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 240 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifflip.c"
static int LoadImage(GifFileType *GifFile , GifRowType **ImageBufferPtr ) 
{ 
  int Size ;
  int i ;
  GifRowType *ImageBuffer ;
  void *tmp ;
  GifRowType tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 248
  tmp = malloc((unsigned long )GifFile->Image.Height * sizeof(GifRowType *));
#line 248
  ImageBuffer = (GifRowType *)tmp;
  }
#line 248
  if ((unsigned long )ImageBuffer == (unsigned long )((void *)0)) {
    {
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifFlip", "Failed to allocate memory required, aborted.");
#line 250
    exit(-3);
    }
  }
#line 252
  Size = (int )((unsigned long )GifFile->Image.Width * sizeof(GifPixelType ));
#line 253
  i = 0;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (i < GifFile->Image.Height)) {
#line 253
      goto while_break;
    }
    {
#line 255
    tmp___1 = malloc((size_t )Size);
#line 255
    tmp___0 = (GifRowType )tmp___1;
#line 255
    *(ImageBuffer + i) = tmp___0;
    }
#line 255
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 256
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "GifFlip", "Failed to allocate memory required, aborted.");
#line 256
      exit(-3);
      }
    }
#line 253
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  *ImageBufferPtr = ImageBuffer;
#line 261
  ImageNum___1 ++;
#line 261
  GifQprintf((char *)"\n%s: Image %d at (%d, %d) [%dx%d]:     ", "GifFlip", ImageNum___1,
             GifFile->Image.Left, GifFile->Image.Top, GifFile->Image.Width, GifFile->Image.Height);
#line 265
  i = 0;
  }
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 265
    if (! (i < GifFile->Image.Height)) {
#line 265
      goto while_break___0;
    }
    {
#line 266
    GifQprintf((char *)"\b\b\b\b%-4d", i);
#line 267
    tmp___2 = DGifGetLine(GifFile, *(ImageBuffer + i), GifFile->Image.Width);
    }
#line 267
    if (tmp___2 == 0) {
#line 268
      return (0);
    }
#line 265
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 271
  return (1);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifflip.c"
static int DumpImage(GifFileType *GifFile , GifRowType *ImageBuffer , int Width ,
                     int Height , int FlipDirection ) 
{ 
  int i ;
  int j ;
  int Count ;
  GifRowType Line ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 288
  if (Width > Height) {
#line 288
    tmp = Width;
  } else {
#line 288
    tmp = Height;
  }
  {
#line 288
  tmp___0 = malloc((unsigned long )tmp * sizeof(GifPixelType ));
#line 288
  Line = (GifRowType )tmp___0;
  }
#line 288
  if ((unsigned long )Line == (unsigned long )((void *)0)) {
    {
#line 290
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifFlip", "Failed to allocate memory required, aborted.");
#line 290
    exit(-3);
    }
  }
  {
#line 293
  if (FlipDirection == 1) {
#line 293
    goto case_1;
  }
#line 302
  if (FlipDirection == 2) {
#line 302
    goto case_2;
  }
#line 311
  if (FlipDirection == 3) {
#line 311
    goto case_3;
  }
#line 318
  if (FlipDirection == 4) {
#line 318
    goto case_4;
  }
#line 292
  goto switch_break;
  case_1: /* CIL Label */ 
#line 294
  Count = Width;
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < Width)) {
#line 294
      goto while_break;
    }
    {
#line 295
    tmp___1 = Count;
#line 295
    Count --;
#line 295
    GifQprintf((char *)"\b\b\b\b%-4d", tmp___1);
#line 296
    j = 0;
    }
    {
#line 296
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 296
      if (! (j < Height)) {
#line 296
        goto while_break___0;
      }
#line 297
      *(Line + j) = *(*(ImageBuffer + ((Height - j) - 1)) + i);
#line 296
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 298
    tmp___2 = EGifPutLine(GifFile, Line, Height);
    }
#line 298
    if (tmp___2 == 0) {
#line 299
      return (0);
    }
#line 294
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  goto switch_break;
  case_2: /* CIL Label */ 
#line 303
  i = Width - 1;
  {
#line 303
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 303
    if (! (i >= 0)) {
#line 303
      goto while_break___1;
    }
    {
#line 304
    GifQprintf((char *)"\b\b\b\b%-4d", i + 1);
#line 305
    j = 0;
    }
    {
#line 305
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 305
      if (! (j < Height)) {
#line 305
        goto while_break___2;
      }
#line 306
      *(Line + j) = *(*(ImageBuffer + j) + i);
#line 305
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 307
    tmp___3 = EGifPutLine(GifFile, Line, Height);
    }
#line 307
    if (tmp___3 == 0) {
#line 308
      return (0);
    }
#line 303
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 310
  goto switch_break;
  case_3: /* CIL Label */ 
#line 312
  i = Height - 1;
  {
#line 312
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 312
    if (! (i >= 0)) {
#line 312
      goto while_break___3;
    }
    {
#line 313
    GifQprintf((char *)"\b\b\b\b%-4d", i);
#line 314
    tmp___4 = EGifPutLine(GifFile, *(ImageBuffer + i), Width);
    }
#line 314
    if (tmp___4 == 0) {
#line 315
      return (0);
    }
#line 312
    i --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 317
  goto switch_break;
  case_4: /* CIL Label */ 
#line 319
  Count = Height;
#line 319
  i = 0;
  {
#line 319
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 319
    if (! (i < Height)) {
#line 319
      goto while_break___4;
    }
    {
#line 320
    tmp___5 = Count;
#line 320
    Count --;
#line 320
    GifQprintf((char *)"\b\b\b\b%-4d", tmp___5);
#line 321
    j = 0;
    }
    {
#line 321
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 321
      if (! (j < Width)) {
#line 321
        goto while_break___5;
      }
#line 322
      *(Line + j) = *(*(ImageBuffer + i) + ((Width - j) - 1));
#line 321
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 323
    tmp___6 = EGifPutLine(GifFile, Line, Width);
    }
#line 323
    if (tmp___6 == 0) {
#line 324
      return (0);
    }
#line 319
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 326
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 330
  i = 0;
  {
#line 330
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 330
    if (! (i < Height)) {
#line 330
      goto while_break___6;
    }
    {
#line 330
    free((void *)((char *)*(ImageBuffer + i)));
#line 330
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 331
  free((void *)((char *)ImageBuffer));
#line 333
  free((void *)((char *)Line));
  }
#line 335
  return (1);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifflip.c"
static void QuitGifError___4(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 343
  PrintGifError();
  }
#line 344
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 344
    DGifCloseFile(GifFileIn);
    }
  }
#line 345
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 345
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 346
  exit(1);
  }
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___8  ;
#line 141
static int GATestAllSatis___8(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___8(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___8(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___8(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___8(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___8(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___8(int argc , char **argv ) ;
#line 156
static char *MyMalloc___8(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___8  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___8(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___8 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___8 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___8, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___8(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___8((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___8 = LocalToken___8;
#line 264
        *(LocalToken___8 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___8(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___8 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___8 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___8(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___8(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___8(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___8((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___8(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___8 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___8 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___8(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___8((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___8((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___8((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___8((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___8((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___8((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___8((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___8((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___8((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___8((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___8((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___8((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___8(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___8(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___8(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___8(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___9(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___9(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___9(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___9(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___9(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___9(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___9(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___9(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___9(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___9(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___9(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___9(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___9(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___9(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___9[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___9(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___9(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___9[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___9(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___9  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___9  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___9  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___9  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___9  =    100L;
#line 62
static void GetScanLine___9(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___9(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___9(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___9 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___9 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___9;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___9(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___9(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___9(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___10  ;
#line 61
static int SubdivColorMap___10(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___10(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___10(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___10 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___10);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___10];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___10];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___10] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___10] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___10]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___10] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___10] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___10]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___10(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___10] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___10]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___10[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___10[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___10(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___10(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___10(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___10(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___10(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___10(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___10(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___10(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___10(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___10(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___10(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___10(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___10(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___10(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___10(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___10(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___10(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___10(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___10(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___9  ;
#line 141
static int GATestAllSatis___9(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___9(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) ;
#line 147
static int GAGetParmeters___9(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___9(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___9(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___9(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___9(int argc , char **argv ) ;
#line 156
static char *MyMalloc___9(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___9  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___9(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                              char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___9 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___9 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___9, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___9(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___9((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___9 = LocalToken___9;
#line 264
        *(LocalToken___9 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___9(int **Parameters , int *ParamCount , char *Option ,
                                  char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                  char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___9 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___9 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___9(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___9(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                               argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___9(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                              char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___9((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___9(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                      argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___9 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___9 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___9(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                   int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___9((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___9((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___9((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___9((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___9((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___9((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___9((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___9((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___9((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___9((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___9((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___9((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___9(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___9(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___9(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___9(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___10(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___10(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___10(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___10(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___10(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___10(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___10(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___10(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___10(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___10(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___10(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___10(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___10(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___10(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___10[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___10(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___10(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___10[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___10(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___10  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___10  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___10  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___10  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___10  =    100L;
#line 62
static void GetScanLine___10(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___10(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___10(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___10 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___10 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___10;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___10(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static char *VersionStr___9  =    (char *)"icon2gif Version 4.1, \tEric Raymond,\tMar  3 2016,   19:58:04\n(C) Copyright 1992 Eric Raymond.\n";
#line 54 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static char *CtrlStr___9  =    (char *)"icon2gif q%- d%- t%-Characters!s h%- GifFile(s)!*s";
#line 60 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static char KeyLetters[94]  = 
#line 60
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'!',      (char )'\"', 
        (char )'#',      (char )'$',      (char )'%',      (char )'&', 
        (char )'\'',      (char )'(',      (char )')',      (char )'*', 
        (char )'+',      (char )',',      (char )'-',      (char )'.', 
        (char )'/',      (char )':',      (char )'<',      (char )'=', 
        (char )'>',      (char )'?',      (char )'@',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'{',      (char )'|',      (char )'}', 
        (char )'~',      (char )'\000'};
#line 63
static int HandleGifError___11(GifFileType *GifFile ) ;
#line 64
static void QuitGifError___5(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 71
static void Icon2Gif(char *FileName , FILE *txtin , int fdout ) ;
#line 72
static void Gif2Icon(char *FileName , int fdin , int fdout , char *NameTable ) ;
#line 75
static void VisibleDumpBuffer(char *buf , int len ) ;
#line 76
static int EscapeString(char *cp , char *tp ) ;
#line 392 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static GifPixelType *Raster  ;
#line 392 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static GifPixelType *cp___0  ;
#line 154 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static void Icon2Gif(char *FileName , FILE *txtin , int fdout ) 
{ 
  unsigned int ExtCode ;
  unsigned int ColorMapSize___1 ;
  GifColorType GlobalColorMap[256] ;
  GifColorType LocalColorMap[256] ;
  GifColorType *ColorMap___3 ;
  char GlobalColorKeys[sizeof(KeyLetters) - 1UL] ;
  char LocalColorKeys[sizeof(KeyLetters) - 1UL] ;
  char *KeyTable ;
  int red ;
  int green ;
  int blue ;
  char buf[16384] ;
  char InclusionFile[64] ;
  GifFileType *GifFileOut ;
  SavedImage *NewImage ;
  int n ;
  int LineNum ;
  char *cp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  int ResBits ;
  int tmp___2 ;
  ColorMapObject *NewMap ;
  int tmp___3 ;
  GifBooleanType DoTranslation ;
  GifPixelType Translation___0[256] ;
  GifFileType *Inclusion ;
  SavedImage *NewImage___0 ;
  SavedImage *CopyFrom ;
  int tmp___4 ;
  ColorMapObject *UnionMap ;
  int i ;
  int j ;
  int c ;
  void *tmp___5 ;
  char *dp ;
  GifPixelType *tmp___6 ;
  unsigned short const   **tmp___7 ;
  int Len ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int Len___0 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int Len___1 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;

  {
  {
#line 156
  ColorMapSize___1 = 0U;
#line 157
  ColorMap___3 = GlobalColorMap;
#line 159
  KeyTable = GlobalColorKeys;
#line 165
  NewImage = (SavedImage *)((void *)0);
#line 166
  LineNum = 0;
#line 168
  GifFileOut = EGifOpenFileHandle(fdout);
  }
#line 168
  if ((unsigned long )GifFileOut == (unsigned long )((void *)0)) {
    {
#line 169
    HandleGifError___11(GifFileOut);
    }
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    tmp___37 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)txtin);
    }
#line 173
    if (! ((unsigned long )tmp___37 != (unsigned long )((char *)((void *)0)))) {
#line 173
      goto while_break;
    }
#line 177
    LineNum ++;
#line 182
    cp = buf;
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 182
      tmp = __ctype_b_loc();
      }
#line 182
      if (! ((int const   )*(*tmp + (int )*cp) & 8192)) {
#line 182
        goto while_break___0;
      }
#line 183
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 182
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 184
    if ((int )*cp == 35) {
#line 185
      goto while_continue;
    } else
#line 184
    if ((int )*cp == 0) {
#line 185
      goto while_continue;
    }
    {
#line 191
    cp = strchr((char const   *)(buf), '#');
    }
#line 191
    if (cp) {
      {
#line 191
      tmp___1 = strrchr((char const   *)cp, '#');
      }
#line 191
      if ((unsigned long )cp == (unsigned long )tmp___1) {
        {
#line 193
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 193
          tmp___0 = __ctype_b_loc();
#line 193
          cp --;
          }
#line 193
          if (! ((int const   )*(*tmp___0 + (int )*cp) & 8192)) {
#line 193
            goto while_break___1;
          }
#line 194
          goto while_continue___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 195
        cp ++;
#line 195
        *cp = (char )'\n';
#line 196
        cp ++;
#line 196
        *cp = (char )'\000';
      }
    }
    {
#line 203
    tmp___36 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"screen width %d\n",
                      & GifFileOut->SWidth);
    }
#line 203
    if (tmp___36 == 1) {
#line 204
      goto while_continue;
    } else {
      {
#line 206
      tmp___35 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"screen height %d\n",
                        & GifFileOut->SHeight);
      }
#line 206
      if (tmp___35 == 1) {
#line 207
        goto while_continue;
      } else {
        {
#line 209
        tmp___34 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"screen colors %d\n",
                          & n);
        }
#line 209
        if (tmp___34 == 1) {
          {
#line 211
          tmp___2 = BitSize(n);
#line 211
          ResBits = tmp___2;
          }
#line 213
          if (n > 256) {
            {
#line 215
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                    FileName, LineNum, "Invalid color resolution value.");
#line 216
            exit(1);
            }
          } else
#line 213
          if (n < 0) {
            {
#line 215
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                    FileName, LineNum, "Invalid color resolution value.");
#line 216
            exit(1);
            }
          } else
#line 213
          if (n != 1 << ResBits) {
            {
#line 215
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                    FileName, LineNum, "Invalid color resolution value.");
#line 216
            exit(1);
            }
          }
#line 219
          GifFileOut->SColorResolution = ResBits;
#line 220
          goto while_continue;
        } else {
          {
#line 223
          tmp___33 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"screen background %d\n",
                            & GifFileOut->SBackGroundColor);
          }
#line 223
          if (tmp___33 == 1) {
#line 226
            goto while_continue;
          } else {
            {
#line 232
            tmp___32 = strcmp((char const   *)(buf), "screen map\n");
            }
#line 232
            if (tmp___32 == 0) {
#line 234
              if ((unsigned long )GifFileOut->SColorMap != (unsigned long )((void *)0)) {
                {
#line 236
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                        FileName, LineNum, "You\'ve already declared a global color map.");
#line 237
                exit(1);
                }
              }
              {
#line 240
              ColorMapSize___1 = 0U;
#line 241
              ColorMap___3 = GlobalColorMap;
#line 242
              KeyTable = GlobalColorKeys;
#line 243
              memset((void *)(GlobalColorKeys), '\000', sizeof(GlobalColorKeys));
              }
            } else {
              {
#line 246
              tmp___31 = strcmp((char const   *)(buf), "image map\n");
              }
#line 246
              if (tmp___31 == 0) {
#line 248
                if ((unsigned long )NewImage == (unsigned long )((void *)0)) {
                  {
#line 250
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                          FileName, LineNum, "No previous image declaration.");
#line 251
                  exit(1);
                  }
                }
                {
#line 254
                ColorMapSize___1 = 0U;
#line 255
                ColorMap___3 = LocalColorMap;
#line 256
                KeyTable = LocalColorKeys;
#line 257
                memset((void *)(LocalColorKeys), '\000', sizeof(LocalColorKeys));
                }
              } else {
                {
#line 260
                tmp___30 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"\trgb %d %d %d is %c",
                                  & red, & green, & blue, KeyTable + ColorMapSize___1);
                }
#line 260
                if (tmp___30 == 4) {
#line 263
                  (ColorMap___3 + ColorMapSize___1)->Red = (GifByteType )red;
#line 264
                  (ColorMap___3 + ColorMapSize___1)->Green = (GifByteType )green;
#line 265
                  (ColorMap___3 + ColorMapSize___1)->Blue = (GifByteType )blue;
#line 266
                  ColorMapSize___1 ++;
                } else {
                  {
#line 269
                  tmp___29 = strcmp((char const   *)(buf), "end\n");
                  }
#line 269
                  if (tmp___29 == 0) {
                    {
#line 274
                    tmp___3 = BitSize((int )ColorMapSize___1);
#line 274
                    NewMap = MakeMapObject(1 << tmp___3, (GifColorType const   *)ColorMap___3);
                    }
#line 275
                    if ((unsigned long )NewMap == (unsigned long )((ColorMapObject *)((void *)0))) {
                      {
#line 277
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                              FileName, LineNum, "Out of memory while allocating new color map.");
#line 278
                      exit(1);
                      }
                    }
#line 281
                    if (NewImage) {
#line 282
                      NewImage->ImageDesc.ColorMap = NewMap;
                    } else {
#line 284
                      GifFileOut->SColorMap = NewMap;
                    }
                  } else {
                    {
#line 288
                    tmp___28 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"include %s",
                                      InclusionFile);
                    }
#line 288
                    if (tmp___28 == 1) {
                      {
#line 296
                      Inclusion = DGifOpenFileName((char const   *)(InclusionFile));
                      }
#line 296
                      if ((unsigned long )Inclusion == (unsigned long )((void *)0)) {
                        {
#line 299
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                FileName, LineNum, "Inclusion read failed.");
#line 300
                        QuitGifError___5(Inclusion, GifFileOut);
                        }
                      } else {
                        {
#line 296
                        tmp___4 = DGifSlurp(Inclusion);
                        }
#line 296
                        if (tmp___4 == 0) {
                          {
#line 299
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                  FileName, LineNum, "Inclusion read failed.");
#line 300
                          QuitGifError___5(Inclusion, GifFileOut);
                          }
                        }
                      }
#line 303
                      DoTranslation = (unsigned long )GifFileOut->SColorMap != (unsigned long )((ColorMapObject *)((void *)0));
#line 303
                      if (DoTranslation) {
                        {
#line 307
                        UnionMap = UnionColorMap((ColorMapObject const   *)GifFileOut->SColorMap,
                                                 (ColorMapObject const   *)Inclusion->SColorMap,
                                                 Translation___0);
                        }
#line 310
                        if ((unsigned long )UnionMap == (unsigned long )((void *)0)) {
                          {
#line 312
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                  FileName, LineNum, "Inclusion failed --- global map conflict.");
#line 313
                          QuitGifError___5(Inclusion, GifFileOut);
                          }
                        }
                        {
#line 316
                        FreeMapObject(GifFileOut->SColorMap);
#line 317
                        GifFileOut->SColorMap = UnionMap;
                        }
                      }
#line 320
                      CopyFrom = Inclusion->SavedImages;
                      {
#line 320
                      while (1) {
                        while_continue___2: /* CIL Label */ ;
#line 320
                        if (! ((unsigned long )CopyFrom < (unsigned long )(Inclusion->SavedImages + Inclusion->ImageCount))) {
#line 320
                          goto while_break___2;
                        }
                        {
#line 324
                        NewImage___0 = MakeSavedImage(GifFileOut, (SavedImage const   *)CopyFrom);
                        }
#line 324
                        if ((unsigned long )NewImage___0 == (unsigned long )((void *)0)) {
                          {
#line 326
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                  FileName, LineNum, "Inclusion failed --- out of memory.");
#line 327
                          QuitGifError___5(Inclusion, GifFileOut);
                          }
                        } else
#line 329
                        if (DoTranslation) {
                          {
#line 330
                          ApplyTranslation(NewImage___0, Translation___0);
                          }
                        }
                        {
#line 332
                        GifQprintf((char *)"%s: Image %d at (%d, %d) [%dx%d]: from %s\n",
                                   "icon2gif", GifFileOut->ImageCount, NewImage___0->ImageDesc.Left,
                                   NewImage___0->ImageDesc.Top, NewImage___0->ImageDesc.Width,
                                   NewImage___0->ImageDesc.Height, InclusionFile);
#line 320
                        CopyFrom ++;
                        }
                      }
                      while_break___2: /* CIL Label */ ;
                      }
                      {
#line 340
                      DGifCloseFile(Inclusion);
                      }
                    } else {
                      {
#line 347
                      tmp___27 = strcmp((char const   *)(buf), "image\n");
                      }
#line 347
                      if (tmp___27 == 0) {
                        {
#line 349
                        NewImage = MakeSavedImage(GifFileOut, (SavedImage const   *)((void *)0));
                        }
#line 349
                        if ((unsigned long )NewImage == (unsigned long )((SavedImage *)((void *)0))) {
                          {
#line 351
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                  FileName, LineNum, "Out of memory while allocating image block.");
#line 352
                          exit(1);
                          }
                        }
#line 356
                        ColorMap___3 = GlobalColorMap;
#line 357
                        KeyTable = GlobalColorKeys;
                      } else
#line 364
                      if ((unsigned long )NewImage == (unsigned long )((SavedImage *)((void *)0))) {
                        {
#line 366
                        fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)stderr);
#line 367
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                FileName, LineNum, "Syntax error in header block.");
#line 368
                        exit(1);
                        }
                      } else {
                        {
#line 374
                        tmp___26 = sscanf((char const   */* __restrict  */)(buf),
                                          (char const   */* __restrict  */)"image top %d\n",
                                          & NewImage->ImageDesc.Top);
                        }
#line 374
                        if (tmp___26 == 1) {
#line 375
                          goto while_continue;
                        } else {
                          {
#line 377
                          tmp___25 = sscanf((char const   */* __restrict  */)(buf),
                                            (char const   */* __restrict  */)"image left %d\n",
                                            & NewImage->ImageDesc.Left);
                          }
#line 377
                          if (tmp___25 == 1) {
#line 378
                            goto while_continue;
                          } else {
                            {
#line 380
                            tmp___24 = strcmp((char const   *)(buf), "image interlaced\n");
                            }
#line 380
                            if (tmp___24 == 0) {
#line 382
                              NewImage->ImageDesc.Interlace = 1;
#line 383
                              goto while_continue;
                            } else {
                              {
#line 386
                              tmp___23 = sscanf((char const   */* __restrict  */)(buf),
                                                (char const   */* __restrict  */)"image bits %d by %d\n",
                                                & NewImage->ImageDesc.Width, & NewImage->ImageDesc.Height);
                              }
#line 386
                              if (tmp___23 == 2) {
                                {
#line 395
                                tmp___5 = malloc((sizeof(GifPixelType ) * (unsigned long )NewImage->ImageDesc.Width) * (unsigned long )NewImage->ImageDesc.Height);
#line 395
                                Raster = (GifPixelType *)tmp___5;
                                }
#line 395
                                if ((unsigned long )Raster == (unsigned long )((void *)0)) {
                                  {
#line 397
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                          FileName, LineNum, "Failed to allocate raster block, aborted.");
#line 398
                                  exit(1);
                                  }
                                }
#line 401
                                if (! GifQuietPrint) {
                                  {
#line 402
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Image %d at (%d, %d) [%dx%d]:     ",
                                          "icon2gif", GifFileOut->ImageCount, NewImage->ImageDesc.Left,
                                          NewImage->ImageDesc.Top, NewImage->ImageDesc.Width,
                                          NewImage->ImageDesc.Height);
                                  }
                                }
#line 407
                                cp___0 = Raster;
#line 408
                                i = 0;
                                {
#line 408
                                while (1) {
                                  while_continue___3: /* CIL Label */ ;
#line 408
                                  if (! (i < NewImage->ImageDesc.Height)) {
#line 408
                                    goto while_break___3;
                                  }
#line 412
                                  j = 0;
                                  {
#line 412
                                  while (1) {
                                    while_continue___4: /* CIL Label */ ;
#line 412
                                    if (! (j < NewImage->ImageDesc.Width)) {
#line 412
                                      goto while_break___4;
                                    }
                                    {
#line 413
                                    c = fgetc(txtin);
                                    }
#line 413
                                    if (c == -1) {
                                      {
#line 414
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                              FileName, LineNum, "input file ended prematurely.");
#line 415
                                      exit(1);
                                      }
                                    } else
#line 417
                                    if (c == 10) {
#line 419
                                      j --;
#line 420
                                      LineNum ++;
                                    } else {
                                      {
#line 422
                                      tmp___7 = __ctype_b_loc();
                                      }
#line 422
                                      if ((int const   )*(*tmp___7 + c) & 8192) {
#line 423
                                        j --;
                                      } else {
                                        {
#line 424
                                        dp = strchr((char const   *)KeyTable, c);
                                        }
#line 424
                                        if (dp) {
#line 425
                                          tmp___6 = cp___0;
#line 425
                                          cp___0 ++;
#line 425
                                          *tmp___6 = (GifPixelType )(dp - KeyTable);
                                        } else {
                                          {
#line 427
                                          fprintf((FILE */* __restrict  */)stderr,
                                                  (char const   */* __restrict  */)"%s:%d: %s\n",
                                                  FileName, LineNum, "Invalid pixel value.");
#line 428
                                          exit(1);
                                          }
                                        }
                                      }
                                    }
#line 412
                                    j ++;
                                  }
                                  while_break___4: /* CIL Label */ ;
                                  }
#line 431
                                  if (! GifQuietPrint) {
                                    {
#line 432
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\b\b\b\b%-4d",
                                            i);
                                    }
                                  }
#line 408
                                  i ++;
                                }
                                while_break___3: /* CIL Label */ ;
                                }
#line 435
                                if (! GifQuietPrint) {
                                  {
#line 436
                                  _IO_putc('\n', stderr);
                                  }
                                }
#line 438
                                NewImage->RasterBits = Raster;
                              } else {
                                {
#line 440
                                tmp___22 = sscanf((char const   */* __restrict  */)(buf),
                                                  (char const   */* __restrict  */)"comment");
                                }
#line 440
                                if (tmp___22) {
                                  {
#line 442
                                  MakeExtension(NewImage, 254);
                                  }
                                  {
#line 443
                                  while (1) {
                                    while_continue___5: /* CIL Label */ ;
                                    {
#line 443
                                    tmp___11 = fgets((char */* __restrict  */)(buf),
                                                     (int )sizeof(buf), (FILE */* __restrict  */)txtin);
                                    }
#line 443
                                    if (! ((unsigned long )tmp___11 != (unsigned long )((char *)((void *)0)))) {
#line 443
                                      goto while_break___5;
                                    }
                                    {
#line 444
                                    tmp___10 = strcmp((char const   *)(buf), "end\n");
                                    }
#line 444
                                    if (tmp___10 == 0) {
#line 445
                                      goto while_break___5;
                                    } else {
                                      {
#line 450
                                      tmp___8 = strlen((char const   *)(buf));
#line 450
                                      buf[tmp___8 - 1UL] = (char )'\000';
#line 451
                                      Len = EscapeString(buf, buf);
#line 452
                                      tmp___9 = AddExtensionBlock(NewImage, Len, (unsigned char *)(buf));
                                      }
#line 452
                                      if (tmp___9 == 0) {
                                        {
#line 453
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                                FileName, LineNum, "out of memory while adding comment block.");
#line 454
                                        exit(1);
                                        }
                                      }
                                    }
                                  }
                                  while_break___5: /* CIL Label */ ;
                                  }
                                } else {
                                  {
#line 458
                                  tmp___21 = sscanf((char const   */* __restrict  */)(buf),
                                                    (char const   */* __restrict  */)"plaintext");
                                  }
#line 458
                                  if (tmp___21) {
                                    {
#line 460
                                    MakeExtension(NewImage, 1);
                                    }
                                    {
#line 461
                                    while (1) {
                                      while_continue___6: /* CIL Label */ ;
                                      {
#line 461
                                      tmp___15 = fgets((char */* __restrict  */)(buf),
                                                       (int )sizeof(buf), (FILE */* __restrict  */)txtin);
                                      }
#line 461
                                      if (! ((unsigned long )tmp___15 != (unsigned long )((char *)((void *)0)))) {
#line 461
                                        goto while_break___6;
                                      }
                                      {
#line 462
                                      tmp___14 = strcmp((char const   *)(buf), "end\n");
                                      }
#line 462
                                      if (tmp___14 == 0) {
#line 463
                                        goto while_break___6;
                                      } else {
                                        {
#line 468
                                        tmp___12 = strlen((char const   *)(buf));
#line 468
                                        buf[tmp___12 - 1UL] = (char )'\000';
#line 469
                                        Len___0 = EscapeString(buf, buf);
#line 470
                                        tmp___13 = AddExtensionBlock(NewImage, Len___0,
                                                                     (unsigned char *)(buf));
                                        }
#line 470
                                        if (tmp___13 == 0) {
                                          {
#line 471
                                          fprintf((FILE */* __restrict  */)stderr,
                                                  (char const   */* __restrict  */)"%s:%d: %s\n",
                                                  FileName, LineNum, "out of memory while adding plaintext block.");
#line 472
                                          exit(1);
                                          }
                                        }
                                      }
                                    }
                                    while_break___6: /* CIL Label */ ;
                                    }
                                  } else {
                                    {
#line 476
                                    tmp___20 = sscanf((char const   */* __restrict  */)(buf),
                                                      (char const   */* __restrict  */)"extension %02x",
                                                      & ExtCode);
                                    }
#line 476
                                    if (tmp___20) {
                                      {
#line 478
                                      MakeExtension(NewImage, (int )ExtCode);
                                      }
                                      {
#line 479
                                      while (1) {
                                        while_continue___7: /* CIL Label */ ;
                                        {
#line 479
                                        tmp___19 = fgets((char */* __restrict  */)(buf),
                                                         (int )sizeof(buf), (FILE */* __restrict  */)txtin);
                                        }
#line 479
                                        if (! ((unsigned long )tmp___19 != (unsigned long )((char *)((void *)0)))) {
#line 479
                                          goto while_break___7;
                                        }
                                        {
#line 480
                                        tmp___18 = strcmp((char const   *)(buf), "end\n");
                                        }
#line 480
                                        if (tmp___18 == 0) {
#line 481
                                          goto while_break___7;
                                        } else {
                                          {
#line 486
                                          tmp___16 = strlen((char const   *)(buf));
#line 486
                                          buf[tmp___16 - 1UL] = (char )'\000';
#line 487
                                          Len___1 = EscapeString(buf, buf);
#line 488
                                          tmp___17 = AddExtensionBlock(NewImage, Len___1,
                                                                       (unsigned char *)(buf));
                                          }
#line 488
                                          if (tmp___17 == 0) {
                                            {
#line 489
                                            fprintf((FILE */* __restrict  */)stderr,
                                                    (char const   */* __restrict  */)"%s:%d: %s\n",
                                                    FileName, LineNum, "out of memory while adding extension block.");
#line 490
                                            exit(1);
                                            }
                                          }
                                        }
                                      }
                                      while_break___7: /* CIL Label */ ;
                                      }
                                    } else {
                                      {
#line 496
                                      fputs((char const   */* __restrict  */)(buf),
                                            (FILE */* __restrict  */)stderr);
#line 497
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
                                              FileName, LineNum, "Syntax error in image description.");
#line 498
                                      exit(1);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 502
  tmp___38 = EGifSpew(GifFileOut);
  }
#line 502
  if (tmp___38 == 0) {
    {
#line 503
    HandleGifError___11(GifFileOut);
    }
  }
#line 504
  return;
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static void Gif2Icon(char *FileName , int fdin , int fdout , char *NameTable ) 
{ 
  int i ;
  int ExtCode ;
  int ImageNum___5 ;
  GifPixelType *Line ;
  GifPixelType *cp ;
  GifRecordType RecordType ;
  GifByteType *Extension ;
  GifFileType *GifFile ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 510
  ImageNum___5 = 1;
#line 516
  if (fdin == -1) {
    {
#line 517
    GifFile = DGifOpenFileName((char const   *)FileName);
    }
#line 517
    if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
      {
#line 518
      PrintGifError();
#line 519
      exit(1);
      }
    }
  } else {
    {
#line 524
    GifFile = DGifOpenFileHandle(fdin);
    }
#line 524
    if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
      {
#line 525
      PrintGifError();
#line 526
      exit(1);
      }
    }
  }
  {
#line 530
  printf((char const   */* __restrict  */)"screen width %d\nscreen height %d\n", GifFile->SWidth,
         GifFile->SHeight);
#line 533
  printf((char const   */* __restrict  */)"screen colors %d\nscreen background %d\n\n",
         GifFile->SColorResolution, GifFile->SBackGroundColor);
  }
#line 537
  if (GifFile->SColorMap) {
    {
#line 539
    tmp = strlen((char const   *)NameTable);
    }
#line 539
    if ((GifFile->SColorMap)->ColorCount >= (int )tmp) {
      {
#line 541
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: global color map has unprintable pixels\n",
              FileName);
#line 544
      exit(1);
      }
    }
    {
#line 547
    printf((char const   */* __restrict  */)"screen map\n");
#line 549
    i = 0;
    }
    {
#line 549
    while (1) {
      while_continue: /* CIL Label */ ;
#line 549
      if (! (i < (GifFile->SColorMap)->ColorCount)) {
#line 549
        goto while_break;
      }
      {
#line 550
      printf((char const   */* __restrict  */)"\trgb %03d %03d %03d is %c\n", (int )((GifFile->SColorMap)->Colors + i)->Red,
             (int )((GifFile->SColorMap)->Colors + i)->Green, (int )((GifFile->SColorMap)->Colors + i)->Blue,
             (int )*(NameTable + i));
#line 549
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 555
    printf((char const   */* __restrict  */)"end\n\n");
    }
  }
  {
#line 558
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 559
    tmp___0 = DGifGetRecordType(GifFile, & RecordType);
    }
#line 559
    if (tmp___0 == 0) {
      {
#line 560
      PrintGifError();
#line 561
      exit(1);
      }
    }
    {
#line 564
    if ((unsigned int )RecordType == 2U) {
#line 564
      goto case_2;
    }
#line 615
    if ((unsigned int )RecordType == 3U) {
#line 615
      goto case_3;
    }
#line 642
    if ((unsigned int )RecordType == 4U) {
#line 642
      goto case_4;
    }
#line 644
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 565
    tmp___1 = DGifGetImageDesc(GifFile);
    }
#line 565
    if (tmp___1 == 0) {
      {
#line 566
      PrintGifError();
#line 567
      exit(1);
      }
    }
    {
#line 569
    tmp___2 = ImageNum___5;
#line 569
    ImageNum___5 ++;
#line 569
    printf((char const   */* __restrict  */)"image # %d\nimage left %d\nimage top %d\n",
           tmp___2, GifFile->Image.Left, GifFile->Image.Top);
    }
#line 572
    if (GifFile->Image.Interlace) {
      {
#line 573
      printf((char const   */* __restrict  */)"interlaced\n");
      }
    }
#line 575
    if (GifFile->Image.ColorMap) {
      {
#line 577
      tmp___3 = strlen((char const   *)NameTable);
      }
#line 577
      if ((GifFile->Image.ColorMap)->ColorCount >= (int )tmp___3) {
        {
#line 579
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: global color map has unprintable pixels\n",
                FileName);
#line 582
        exit(1);
        }
      }
      {
#line 585
      printf((char const   */* __restrict  */)"image map\n");
#line 587
      i = 0;
      }
      {
#line 587
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 587
        if (! (i < (GifFile->Image.ColorMap)->ColorCount)) {
#line 587
          goto while_break___1;
        }
        {
#line 588
        printf((char const   */* __restrict  */)"\trgb %03d %03d %03d is %c\n", (int )((GifFile->Image.ColorMap)->Colors + i)->Red,
               (int )((GifFile->Image.ColorMap)->Colors + i)->Green, (int )((GifFile->Image.ColorMap)->Colors + i)->Blue,
               (int )*(NameTable + i));
#line 587
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 593
      printf((char const   */* __restrict  */)"end\n\n");
      }
    }
    {
#line 596
    printf((char const   */* __restrict  */)"image bits %d by %d\n", GifFile->Image.Width,
           GifFile->Image.Height);
#line 599
    tmp___4 = malloc((unsigned long )GifFile->Image.Width * sizeof(GifPixelType ));
#line 599
    Line = (GifPixelType *)tmp___4;
#line 601
    i = 0;
    }
    {
#line 601
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 601
      if (! (i < GifFile->Image.Height)) {
#line 601
        goto while_break___2;
      }
      {
#line 602
      tmp___5 = DGifGetLine(GifFile, Line, GifFile->Image.Width);
      }
#line 602
      if (tmp___5 == 0) {
        {
#line 604
        PrintGifError();
#line 605
        exit(1);
        }
      }
#line 607
      cp = Line;
      {
#line 607
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 607
        if (! ((unsigned long )cp < (unsigned long )(Line + GifFile->Image.Width))) {
#line 607
          goto while_break___3;
        }
        {
#line 608
        putchar((int )*(NameTable + *cp));
#line 607
        cp ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 609
      putchar('\n');
#line 601
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 611
    free((void *)((char *)Line));
#line 612
    putchar('\n');
    }
#line 614
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 616
    tmp___6 = DGifGetExtension(GifFile, & ExtCode, & Extension);
    }
#line 616
    if (tmp___6 == 0) {
      {
#line 617
      PrintGifError();
#line 618
      exit(1);
      }
    }
#line 621
    if (ExtCode == 254) {
      {
#line 622
      printf((char const   */* __restrict  */)"comment\n");
      }
    } else
#line 623
    if (ExtCode == 1) {
      {
#line 624
      printf((char const   */* __restrict  */)"plaintext\n");
      }
    } else {
      {
#line 625
      tmp___7 = __ctype_b_loc();
      }
#line 625
      if ((int const   )*(*tmp___7 + ExtCode) & 1024) {
        {
#line 626
        printf((char const   */* __restrict  */)"extension %02x    # %c\n", ExtCode,
               ExtCode);
        }
      } else {
        {
#line 628
        printf((char const   */* __restrict  */)"extension %02x\n", ExtCode);
        }
      }
    }
    {
#line 630
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 630
      if (! ((unsigned long )Extension != (unsigned long )((void *)0))) {
#line 630
        goto while_break___4;
      }
      {
#line 631
      VisibleDumpBuffer((char *)(Extension + 1), (int )*(Extension + 0));
#line 632
      putchar('\n');
#line 634
      tmp___8 = DGifGetExtensionNext(GifFile, & Extension);
      }
#line 634
      if (tmp___8 == 0) {
        {
#line 635
        PrintGifError();
#line 636
        exit(1);
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 639
    printf((char const   */* __restrict  */)"end\n\n");
    }
#line 641
    goto switch_break;
    case_4: /* CIL Label */ 
#line 643
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 558
    if (! ((unsigned int )RecordType != 4U)) {
#line 558
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 652
  printf((char const   */* __restrict  */)"# The following sets edit modes for GNU EMACS\n");
#line 653
  printf((char const   */* __restrict  */)"# Local ");
#line 654
  printf((char const   */* __restrict  */)"Variables:\n");
#line 655
  printf((char const   */* __restrict  */)"# mode:picture\n");
#line 656
  printf((char const   */* __restrict  */)"# truncate-lines:t\n");
#line 657
  printf((char const   */* __restrict  */)"# End:\n");
  }
#line 659
  if (fdin == -1) {
    {
#line 660
    printf((char const   */* __restrict  */)"# End of %s dump\n", FileName);
    }
  }
  {
#line 662
  tmp___9 = DGifCloseFile(GifFile);
  }
#line 662
  if (tmp___9 == 0) {
    {
#line 663
    PrintGifError();
#line 664
    exit(1);
    }
  }
#line 666
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static int EscapeString(char *cp , char *tp ) 
{ 
  char *StartAddr ;
  int cval ;
  char *dp ;
  char *hex ;
  int dcount ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 671
  StartAddr = tp;
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
#line 673
    if (! *cp) {
#line 673
      goto while_break;
    }
#line 675
    cval = 0;
#line 677
    if ((int )*cp == 92) {
      {
#line 677
      tmp___7 = strchr("0123456789xX", (int )*(cp + 1));
      }
#line 677
      if (tmp___7) {
#line 679
        hex = (char *)"00112233445566778899aAbBcCdDeEfF";
#line 680
        dcount = 0;
#line 682
        cp ++;
#line 682
        if ((int )*cp == 120) {
#line 682
          goto _L;
        } else
#line 682
        if ((int )*cp == 88) {
          _L: /* CIL Label */ 
#line 683
          cp ++;
          {
#line 683
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 683
            dp = strchr((char const   *)hex, (int )*cp);
            }
#line 683
            if (dp) {
#line 683
              tmp = dcount;
#line 683
              dcount ++;
#line 683
              if (! (tmp < 2)) {
#line 683
                goto while_break___0;
              }
            } else {
#line 683
              goto while_break___0;
            }
#line 684
            cval = (int )((long )(cval * 16) + (dp - hex) / 2L);
#line 683
            cp ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else
#line 685
        if ((int )*cp == 48) {
          {
#line 686
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 686
            tmp___1 = strchr("01234567", (int )*cp);
            }
#line 686
            if ((unsigned long )tmp___1 != (unsigned long )((char *)((void *)0))) {
#line 686
              tmp___2 = dcount;
#line 686
              dcount ++;
#line 686
              if (! (tmp___2 < 3)) {
#line 686
                goto while_break___1;
              }
            } else {
#line 686
              goto while_break___1;
            }
#line 687
            tmp___0 = cp;
#line 687
            cp ++;
#line 687
            cval = cval * 8 + ((int )*tmp___0 - 48);
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
          {
#line 689
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 689
            tmp___4 = strchr("0123456789", (int )*cp);
            }
#line 689
            if ((unsigned long )tmp___4 != (unsigned long )((char *)((void *)0))) {
#line 689
              tmp___5 = dcount;
#line 689
              dcount ++;
#line 689
              if (! (tmp___5 < 3)) {
#line 689
                goto while_break___2;
              }
            } else {
#line 689
              goto while_break___2;
            }
#line 690
            tmp___3 = cp;
#line 690
            cp ++;
#line 690
            cval = cval * 10 + ((int )*tmp___3 - 48);
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      } else {
#line 677
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 692
    if ((int )*cp == 92) {
#line 694
      cp ++;
      {
#line 696
      if ((int )*cp == 92) {
#line 696
        goto case_92;
      }
#line 697
      if ((int )*cp == 110) {
#line 697
        goto case_110;
      }
#line 698
      if ((int )*cp == 116) {
#line 698
        goto case_116;
      }
#line 699
      if ((int )*cp == 98) {
#line 699
        goto case_98;
      }
#line 700
      if ((int )*cp == 114) {
#line 700
        goto case_114;
      }
#line 701
      goto switch_default;
      case_92: /* CIL Label */ 
#line 696
      cval = '\\';
#line 696
      goto switch_break;
      case_110: /* CIL Label */ 
#line 697
      cval = '\n';
#line 697
      goto switch_break;
      case_116: /* CIL Label */ 
#line 698
      cval = '\t';
#line 698
      goto switch_break;
      case_98: /* CIL Label */ 
#line 699
      cval = '\b';
#line 699
      goto switch_break;
      case_114: /* CIL Label */ 
#line 700
      cval = '\r';
#line 700
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 701
      cval = (int )*cp;
      switch_break: /* CIL Label */ ;
      }
#line 703
      cp ++;
    } else
#line 705
    if ((int )*cp == 94) {
#line 707
      cp ++;
#line 707
      cval = (int )*cp & 31;
#line 708
      cp ++;
    } else {
#line 711
      tmp___6 = cp;
#line 711
      cp ++;
#line 711
      cval = (int )*tmp___6;
    }
#line 712
    tmp___8 = tp;
#line 712
    tp ++;
#line 712
    *tmp___8 = (char )cval;
  }
  while_break: /* CIL Label */ ;
  }
#line 715
  return ((int )(tp - StartAddr));
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static void VisibleDumpBuffer(char *buf , int len ) 
{ 
  char *cp ;
  unsigned short const   **tmp ;

  {
#line 723
  cp = buf;
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! ((unsigned long )cp < (unsigned long )(buf + len))) {
#line 723
      goto while_break;
    }
    {
#line 725
    tmp = __ctype_b_loc();
    }
#line 725
    if ((int const   )*(*tmp + (int )*cp) & 16384) {
      {
#line 726
      putchar((int )*cp);
      }
    } else
#line 725
    if ((int )*cp == 32) {
      {
#line 726
      putchar((int )*cp);
      }
    } else
#line 727
    if ((int )*cp == 10) {
      {
#line 729
      putchar('\\');
#line 729
      putchar('n');
      }
    } else
#line 731
    if ((int )*cp == 13) {
      {
#line 733
      putchar('\\');
#line 733
      putchar('r');
      }
    } else
#line 735
    if ((int )*cp == 8) {
      {
#line 737
      putchar('\\');
#line 737
      putchar('b');
      }
    } else
#line 739
    if ((int )*cp < 32) {
      {
#line 741
      putchar('\\');
#line 741
      putchar('^');
#line 741
      putchar(64 + (int )*cp);
      }
    } else {
      {
#line 744
      printf((char const   */* __restrict  */)"\\0x%02x", (int )*cp);
      }
    }
#line 723
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  return;
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static int HandleGifError___11(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 753
  tmp = GifLastError();
#line 753
  i = tmp;
#line 755
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 755
  if (tmp___0 == 0) {
    {
#line 756
    GifLastError();
    }
  }
#line 758
  return (i);
}
}
#line 764 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/icon2gif.c"
static void QuitGifError___5(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 766
  PrintGifError();
  }
#line 767
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 767
    DGifCloseFile(GifFileIn);
    }
  }
#line 768
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 768
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 769
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___10(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___10(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___11  ;
#line 61
static int SubdivColorMap___11(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___11(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___11(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___11 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___11);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___11];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___11];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___11] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___11] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___11]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___11] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___11] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___11]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___11(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___11] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___11]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___11[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___11[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___11(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___11(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___11(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___11(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___11(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___11(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___11(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___11(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___11(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___11(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___11(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___11(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___11(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___11(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___11(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___11(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___11(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___11(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___11(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___10  ;
#line 141
static int GATestAllSatis___10(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___10(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___10(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___10(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___10(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___10(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___10(int argc , char **argv ) ;
#line 156
static char *MyMalloc___10(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___10  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___10(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___10 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___10 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___10, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___10(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___10((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___10 = LocalToken___10;
#line 264
        *(LocalToken___10 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___10(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___10 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___10 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___10(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___10(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___10(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___10((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___10(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___10 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___10 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___10(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___10((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___10((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___10((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___10((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___10((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___10((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___10((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___10((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___10((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___10((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___10((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___10((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___10(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___10(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___10(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___10(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___11(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___11(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___11(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___11(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___11(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___11(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___11(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___11(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___11(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___11(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___11(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___11(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___11(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___11(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___11[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___11(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___11(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___11[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___11(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___11  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___11  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___11  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___11  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___11  =    100L;
#line 62
static void GetScanLine___11(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___12(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___11(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___11 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___11 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___11;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___12(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrotat.c"
static char *VersionStr___10  =    (char *)"GifRotat Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:05\n(C) Copyright 1989 Gershon Elber.\n";
#line 68 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrotat.c"
static char *CtrlStr___10  =    (char *)"GifRotat a!-Angle!d q%- s%-Width|Height!d!d h%- GifFile!*s";
#line 74 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrotat.c"
static int InterlacedOffset___1[4]  = {      0,      4,      2,      1};
#line 74 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrotat.c"
static int InterlacedJumps___1[4]  = {      8,      8,      4,      2};
#line 78
static void RotateGifImage(GifRowType *ScreenBuffer , GifFileType *SrcGifFile , int Angle ,
                           ColorMapObject *ColorMap___3 , int DstWidth , int DstHeight ) ;
#line 81
static void RotateGifLine(GifRowType *ScreenBuffer , int BackGroundColor___0 , int SrcWidth ,
                          int SrcHeight , int Angle , GifRowType DstLine , int DstWidth ,
                          int DstHeight , int y ) ;
#line 85
static void QuitGifError___6(GifFileType *DstGifFile ) ;
#line 252 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrotat.c"
static void RotateGifImage(GifRowType *ScreenBuffer , GifFileType *SrcGifFile , int Angle ,
                           ColorMapObject *ColorMap___3 , int DstWidth , int DstHeight ) 
{ 
  int i ;
  int LineSize ;
  GifFileType *DstGifFile ;
  GifRowType LineBuffer ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 256
  LineSize = (int )((unsigned long )DstWidth * sizeof(GifPixelType ));
#line 261
  tmp = malloc((size_t )LineSize);
#line 261
  LineBuffer = (GifRowType )tmp;
  }
#line 261
  if ((unsigned long )LineBuffer == (unsigned long )((void *)0)) {
    {
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifRotat", "Failed to allocate memory required, aborted.");
#line 262
    exit(-3);
    }
  }
  {
#line 265
  DstGifFile = EGifOpenFileHandle(1);
  }
#line 265
  if ((unsigned long )DstGifFile == (unsigned long )((void *)0)) {
    {
#line 266
    QuitGifError___6(DstGifFile);
    }
  }
  {
#line 268
  tmp___0 = EGifPutScreenDesc(DstGifFile, DstWidth, DstHeight, ColorMap___3->BitsPerPixel,
                              0, (ColorMapObject const   *)ColorMap___3);
  }
#line 268
  if (tmp___0 == 0) {
    {
#line 272
    QuitGifError___6(DstGifFile);
    }
  } else {
    {
#line 268
    tmp___1 = EGifPutImageDesc(DstGifFile, 0, 0, DstWidth, DstHeight, 0, (ColorMapObject const   *)((void *)0));
    }
#line 268
    if (tmp___1 == 0) {
      {
#line 272
      QuitGifError___6(DstGifFile);
      }
    }
  }
#line 274
  i = 0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < DstHeight)) {
#line 274
      goto while_break;
    }
    {
#line 275
    RotateGifLine(ScreenBuffer, SrcGifFile->SBackGroundColor, SrcGifFile->SWidth,
                  SrcGifFile->SHeight, Angle, LineBuffer, DstWidth, DstHeight, i);
#line 278
    tmp___2 = EGifPutLine(DstGifFile, LineBuffer, DstWidth);
    }
#line 278
    if (tmp___2 == 0) {
      {
#line 279
      QuitGifError___6(DstGifFile);
      }
    }
    {
#line 280
    GifQprintf((char *)"\b\b\b\b%-4d", (DstHeight - i) - 1);
#line 274
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  tmp___3 = EGifCloseFile(DstGifFile);
  }
#line 283
  if (tmp___3 == 0) {
    {
#line 284
    QuitGifError___6(DstGifFile);
    }
  }
#line 285
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrotat.c"
static void RotateGifLine(GifRowType *ScreenBuffer , int BackGroundColor___0 , int SrcWidth ,
                          int SrcHeight , int Angle , GifRowType DstLine , int DstWidth ,
                          int DstHeight , int y ) 
{ 
  int x ;
  int TransSrcX ;
  int TransSrcY ;
  int TransDstX ;
  int TransDstY ;
  double SinAngle ;
  double tmp ;
  double CosAngle ;
  double tmp___0 ;
  int xc ;
  int yc ;
  int SrcX ;
  int SrcY ;
  GifRowType tmp___1 ;
  GifRowType tmp___2 ;

  {
  {
#line 296
  TransSrcX = SrcWidth / 2;
#line 296
  TransSrcY = SrcHeight / 2;
#line 296
  TransDstX = DstWidth / 2;
#line 296
  TransDstY = DstHeight / 2;
#line 301
  tmp = sin(((double )Angle * 3.14159265358979323846) / 180.0);
#line 301
  SinAngle = tmp;
#line 301
  tmp___0 = cos(((double )Angle * 3.14159265358979323846) / 180.0);
#line 301
  CosAngle = tmp___0;
#line 304
  x = 0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (x < DstWidth)) {
#line 304
      goto while_break;
    }
#line 306
    xc = x - TransDstX;
#line 306
    yc = y - TransDstY;
#line 306
    SrcX = (int )(((double )xc * CosAngle - (double )yc * SinAngle) + (double )TransSrcX);
#line 306
    SrcY = (int )(((double )xc * SinAngle + (double )yc * CosAngle) + (double )TransSrcY);
#line 311
    if (SrcX < 0) {
#line 315
      tmp___1 = DstLine;
#line 315
      DstLine ++;
#line 315
      *tmp___1 = (unsigned char )BackGroundColor___0;
    } else
#line 311
    if (SrcX >= SrcWidth) {
#line 315
      tmp___1 = DstLine;
#line 315
      DstLine ++;
#line 315
      *tmp___1 = (unsigned char )BackGroundColor___0;
    } else
#line 311
    if (SrcY < 0) {
#line 315
      tmp___1 = DstLine;
#line 315
      DstLine ++;
#line 315
      *tmp___1 = (unsigned char )BackGroundColor___0;
    } else
#line 311
    if (SrcY >= SrcHeight) {
#line 315
      tmp___1 = DstLine;
#line 315
      DstLine ++;
#line 315
      *tmp___1 = (unsigned char )BackGroundColor___0;
    } else {
#line 318
      tmp___2 = DstLine;
#line 318
      DstLine ++;
#line 318
      *tmp___2 = *(*(ScreenBuffer + SrcY) + SrcX);
    }
#line 304
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifrotat.c"
static void QuitGifError___6(GifFileType *DstGifFile ) 
{ 


  {
  {
#line 327
  PrintGifError();
  }
#line 328
  if ((unsigned long )DstGifFile != (unsigned long )((void *)0)) {
    {
#line 328
    EGifCloseFile(DstGifFile);
    }
  }
  {
#line 329
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___11(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___11(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___12  ;
#line 61
static int SubdivColorMap___12(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___12(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___12(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___12 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___12);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___12];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___12];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___12] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___12] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___12]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___12] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___12] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___12]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___12(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___12] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___12]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___12[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___12[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___12(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___12(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___12(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___12(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___12(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___12(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___12(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___12(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___12(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___12(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___12(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___12(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___12(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___12(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___12(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___12(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___12(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___12(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___12(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___11  ;
#line 141
static int GATestAllSatis___11(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___11(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___11(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___11(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___11(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___11(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___11(int argc , char **argv ) ;
#line 156
static char *MyMalloc___11(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___11  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___11(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___11 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___11 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___11, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___11(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___11((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___11 = LocalToken___11;
#line 264
        *(LocalToken___11 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___11(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___11 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___11 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___11(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___11(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___11(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___11((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___11(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___11 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___11 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___11(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___11((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___11((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___11((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___11((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___11((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___11((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___11((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___11((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___11((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___11((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___11((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___11((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___11(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___11(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___11(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___11(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___12(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___12(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___12(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___12(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___12(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___12(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___12(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___12(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___12(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___12(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___12(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___12(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___12(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___12(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___12[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___12(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___12(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___12[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___12(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giffix.c"
static char *VersionStr___11  =    (char *)"GifFix Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:56\n(C) Copyright 1989 Gershon Elber.\n";
#line 55 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giffix.c"
static char *CtrlStr___11  =    (char *)"GifFix q%- h%- GifFile!*s";
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giffix.c"
static int ImageNum___2  =    0;
#line 65
static void QuitGifError___7(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 213 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giffix.c"
static void QuitGifError___7(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 215
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nFollowing unrecoverable error occured:");
#line 216
  PrintGifError();
  }
#line 217
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 217
    DGifCloseFile(GifFileIn);
    }
  }
#line 218
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 218
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 219
  exit(1);
  }
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___12  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___12  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___12  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___12  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___12  =    100L;
#line 62
static void GetScanLine___12(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___13(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___12(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___12 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___12 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___12;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___13(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___12(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___12(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___13  ;
#line 61
static int SubdivColorMap___13(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___13(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___13(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___13 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___13);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___13];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___13];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___13] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___13] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___13]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___13] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___13] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___13]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___13(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___13] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___13]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___13[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___13[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___13(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___13(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___13(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___13(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___13(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___13(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___13(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___13(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___13(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___13(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___13(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___13(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___13(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___13(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___13(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___13(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___13(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___13(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___13(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___12  ;
#line 141
static int GATestAllSatis___12(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___12(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___12(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___12(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___12(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___12(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___12(int argc , char **argv ) ;
#line 156
static char *MyMalloc___12(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___12  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___12(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___12 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___12 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___12, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___12(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___12((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___12 = LocalToken___12;
#line 264
        *(LocalToken___12 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___12(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___12 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___12 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___12(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___12(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___12(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___12((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___12(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___12 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___12 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___12(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___12((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___12((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___12((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___12((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___12((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___12((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___12((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___12((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___12((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___12((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___12((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___12((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___12(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___12(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___12(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___12(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___13(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___13(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___13(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___13(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___13(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___13(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___13(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___13(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___13(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___13(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___13(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___13(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___13(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___13(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___13[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___13(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___13(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___13[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___13(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___13  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___13  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___13  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___13  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___13  =    100L;
#line 62
static void GetScanLine___13(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___14(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___13(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___13 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___13 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___13;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___14(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifhisto.c"
static char *VersionStr___12  =    (char *)"GifHisto Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:57\n(C) Copyright 1989 Gershon Elber.\n";
#line 65 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifhisto.c"
static char *CtrlStr___12  =    (char *)"GifHisto q%- t%- s%-Width|Height!d!d n%-ImageNumber!d b%- h%- GifFile!*s";
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifhisto.c"
static int ImageWidth___0  =    100;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifhisto.c"
static int ImageHeight___0  =    256;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifhisto.c"
static int ImageN  =    1;
#line 75 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifhisto.c"
static GifColorType HistoColorMap[4]  = {      {(GifByteType )0, (GifByteType )0, (GifByteType )0}, 
        {(GifByteType )255, (GifByteType )0, (GifByteType )0}, 
        {(GifByteType )0, (GifByteType )255, (GifByteType )0}, 
        {(GifByteType )0, (GifByteType )0, (GifByteType )255}};
#line 83
static void QuitGifError___8(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 266 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifhisto.c"
static void QuitGifError___8(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 268
  PrintGifError();
  }
#line 269
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 269
    DGifCloseFile(GifFileIn);
    }
  }
#line 270
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 270
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 271
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___13(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___13(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___14  ;
#line 61
static int SubdivColorMap___14(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___14(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___14(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___14 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___14);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___14];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___14];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___14] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___14] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___14]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___14] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___14] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___14]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___14(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___14] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___14]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___14[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___14[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___14(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___14(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___14(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___14(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___14(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___14(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___14(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___14(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___14(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___14(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___14(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___14(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___14(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___14(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___14(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___14(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___14(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___14(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___14(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___13  ;
#line 141
static int GATestAllSatis___13(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___13(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___13(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___13(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___13(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___13(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___13(int argc , char **argv ) ;
#line 156
static char *MyMalloc___13(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___13  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___13(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___13 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___13 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___13, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___13(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___13((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___13 = LocalToken___13;
#line 264
        *(LocalToken___13 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___13(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___13 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___13 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___13(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___13(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___13(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___13((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___13(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___13 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___13 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___13(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___13((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___13((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___13((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___13((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___13((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___13((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___13((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___13((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___13((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___13((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___13((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___13((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___13(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___13(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___13(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___13(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___14(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___14(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___14(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___14(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___14(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___14(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___14(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___14(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___14(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___14(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___14(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___14(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___14(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___14(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___14[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___14(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___14(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___14[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___14(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___14  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___14  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___14  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___14  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___14  =    100L;
#line 62
static void GetScanLine___14(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___15(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___14(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___14 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___14 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___14;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___15(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 209
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) tmpnam)(char *__s ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinto.c"
static char *VersionStr___13  =    (char *)"GifInto Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:58\n(C) Copyright 1989 Gershon Elber.\n";
#line 65 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinto.c"
static char *CtrlStr___13  =    (char *)"GifInto q%- s%-MinFileSize!d h%- GifFile!*s";
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinto.c"
static int MinFileSize  =    14;
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___14(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___14(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___15  ;
#line 61
static int SubdivColorMap___15(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___15(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___15(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___15 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___15);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___15];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___15];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___15] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___15] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___15]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___15] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___15] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___15]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___15(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___15] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___15]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___15[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___15[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___15(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___15(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___15(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___15(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___15(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___15(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___15(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___15(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___15(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___15(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___15(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___15(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___15(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___15(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___15(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___15(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___15(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___15(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___15(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___14  ;
#line 141
static int GATestAllSatis___14(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___14(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___14(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___14(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___14(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___14(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___14(int argc , char **argv ) ;
#line 156
static char *MyMalloc___14(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___14  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___14(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___14 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___14 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___14, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___14(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___14((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___14 = LocalToken___14;
#line 264
        *(LocalToken___14 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___14(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___14 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___14 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___14(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___14(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___14(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___14((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___14(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___14 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___14 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___14(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___14((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___14((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___14((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___14((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___14((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___14((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___14((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___14((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___14((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___14((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___14((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___14((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___14(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___14(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___14(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___14(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___15(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___15(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___15(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___15(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___15(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___15(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___15(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___15(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___15(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___15(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___15(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___15(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___15(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___15(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___15[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___15(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___15(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___15[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___15(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___15  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___15  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___15  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___15  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___15  =    100L;
#line 62
static void GetScanLine___15(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___16(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___15(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___15 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___15 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___15;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___16(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___15(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___15(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static char *VersionStr___14  =    (char *)"GifAsm Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:54\n(C) Copyright 1989 Gershon Elber.\n";
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static char *CtrlStr___14  =    (char *)"GifAsm q%- A%-Delay!d a%- d%-OutFileName!s h%- GifFile(s)!*s";
#line 68 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static int AsmGifAnimFlag  =    0;
#line 68 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static int AsmGifAnimNumIters  =    1;
#line 68 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static int AsmGifAnimDelay  =    0;
#line 68 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static int AsmGifAnimUserWait  =    0;
#line 68 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static int AsmFlag  =    0;
#line 79
static void DoAssembly(int NumFiles , char **FileNames ) ;
#line 80
static void DoDisassembly(char *InFileName , char *OutFileName ) ;
#line 81
static void QuitGifError___9(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 213 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static unsigned char ExtStr___0[4]  = {      (unsigned char)4,      (unsigned char)0,      (unsigned char)0,      (unsigned char)255};
#line 130 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static void DoAssembly(int NumFiles , char **FileNames ) 
{ 
  int i ;
  int j ;
  int k ;
  int Len ;
  int ExtCode ;
  int ReMapColor[256] ;
  ColorMapObject FirstColorMap ;
  GifRecordType RecordType ;
  GifByteType *Line ;
  GifByteType *Extension ;
  GifFileType *GifFileIn ;
  GifFileType *GifFileOut ;
  int tmp ;
  void *tmp___0 ;
  unsigned char ExtStr[3] ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int MinIndex ;
  int MinDist ;
  GifColorType *CMap1 ;
  GifColorType *c ;
  int Dist ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 132
  Len = 0;
#line 135
  Line = (GifByteType *)((void *)0);
#line 136
  GifFileIn = (GifFileType *)((void *)0);
#line 136
  GifFileOut = (GifFileType *)((void *)0);
#line 139
  GifFileOut = EGifOpenFileHandle(1);
  }
#line 139
  if ((unsigned long )GifFileOut == (unsigned long )((void *)0)) {
    {
#line 140
    QuitGifError___9(GifFileIn, GifFileOut);
    }
  }
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < NumFiles)) {
#line 143
      goto while_break;
    }
    {
#line 144
    GifFileIn = DGifOpenFileName((char const   *)*(FileNames + i));
    }
#line 144
    if ((unsigned long )GifFileIn == (unsigned long )((void *)0)) {
      {
#line 145
      QuitGifError___9(GifFileIn, GifFileOut);
      }
    }
#line 148
    if (i == 0) {
      {
#line 149
      tmp = EGifPutScreenDesc(GifFileOut, GifFileIn->SWidth, GifFileIn->SHeight, GifFileIn->SColorResolution,
                              GifFileIn->SBackGroundColor, (ColorMapObject const   *)GifFileIn->SColorMap);
      }
#line 149
      if (tmp == 0) {
        {
#line 153
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
      {
#line 155
      FirstColorMap = *(GifFileIn->SColorMap);
#line 156
      tmp___0 = malloc(sizeof(GifColorType ) * (unsigned long )FirstColorMap.ColorCount);
#line 156
      FirstColorMap.Colors = (GifColorType *)tmp___0;
#line 159
      memcpy((void */* __restrict  */)FirstColorMap.Colors, (void const   */* __restrict  */)(GifFileIn->SColorMap)->Colors,
             sizeof(GifColorType ) * (unsigned long )FirstColorMap.ColorCount);
      }
#line 162
      if (AsmGifAnimFlag) {
        {
#line 165
        ExtStr[0] = (unsigned char )(AsmGifAnimNumIters % 256);
#line 166
        ExtStr[1] = (unsigned char )(AsmGifAnimNumIters / 256);
#line 167
        ExtStr[2] = (unsigned char)0;
#line 170
        tmp___1 = strlen("NETSCAPE2.0");
#line 170
        EGifPutExtensionFirst(GifFileOut, 255, (int )tmp___1, (void const   *)"NETSCAPE2.0");
#line 172
        EGifPutExtensionLast(GifFileOut, 255, 3, (void const   *)(ExtStr));
#line 174
        tmp___2 = strlen("(c) Gershon Elber, GifLib");
#line 174
        EGifPutExtension(GifFileOut, 254, (int )tmp___2, (void const   *)"(c) Gershon Elber, GifLib");
        }
      }
#line 177
      j = 0;
      {
#line 177
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 177
        if (! (j < (GifFileIn->SColorMap)->ColorCount)) {
#line 177
          goto while_break___0;
        }
#line 178
        ReMapColor[j] = j;
#line 177
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 182
      j = 0;
      {
#line 182
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 182
        if (! (j < (GifFileIn->SColorMap)->ColorCount)) {
#line 182
          goto while_break___1;
        }
#line 183
        MinIndex = 0;
#line 183
        MinDist = 196608;
#line 185
        CMap1 = FirstColorMap.Colors;
#line 185
        c = (GifFileIn->SColorMap)->Colors;
#line 189
        k = 0;
        {
#line 189
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 189
          if (! (k < FirstColorMap.ColorCount)) {
#line 189
            goto while_break___2;
          }
#line 190
          Dist = (((int )(c + j)->Red - (int )(CMap1 + k)->Red) * ((int )(c + j)->Red - (int )(CMap1 + k)->Red) + ((int )(c + j)->Green - (int )(CMap1 + k)->Green) * ((int )(c + j)->Green - (int )(CMap1 + k)->Green)) + ((int )(c + j)->Blue - (int )(CMap1 + k)->Blue) * ((int )(c + j)->Blue - (int )(CMap1 + k)->Blue);
#line 194
          if (MinDist > Dist) {
#line 195
            MinDist = Dist;
#line 196
            MinIndex = k;
          }
#line 189
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 199
        ReMapColor[j] = MinIndex;
#line 182
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 203
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 204
      tmp___3 = DGifGetRecordType(GifFileIn, & RecordType);
      }
#line 204
      if (tmp___3 == 0) {
        {
#line 205
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
      {
#line 208
      if ((unsigned int )RecordType == 2U) {
#line 208
        goto case_2;
      }
#line 252
      if ((unsigned int )RecordType == 3U) {
#line 252
        goto case_3;
      }
#line 267
      if ((unsigned int )RecordType == 4U) {
#line 267
        goto case_4;
      }
#line 269
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 209
      tmp___4 = DGifGetImageDesc(GifFileIn);
      }
#line 209
      if (tmp___4 == 0) {
        {
#line 210
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
#line 212
      if (AsmGifAnimFlag) {
#line 216
        if (AsmGifAnimUserWait) {
#line 216
          ExtStr___0[0] = (unsigned char)6;
        } else {
#line 216
          ExtStr___0[0] = (unsigned char)4;
        }
        {
#line 217
        ExtStr___0[1] = (unsigned char )(AsmGifAnimDelay % 256);
#line 218
        ExtStr___0[2] = (unsigned char )(AsmGifAnimDelay / 256);
#line 221
        EGifPutExtension(GifFileOut, 249, 4, (void const   *)(ExtStr___0));
        }
      }
#line 225
      if (i == 0) {
        {
#line 226
        Len = (int )(sizeof(GifPixelType ) * (unsigned long )GifFileIn->Image.Width);
#line 227
        tmp___5 = malloc((size_t )Len);
#line 227
        Line = (GifRowType )tmp___5;
        }
#line 227
        if ((unsigned long )Line == (unsigned long )((void *)0)) {
          {
#line 228
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                  "GifAsm", "Failed to allocate memory required, aborted.");
#line 228
          exit(-3);
          }
        }
      }
      {
#line 232
      tmp___6 = EGifPutImageDesc(GifFileOut, GifFileIn->Image.Left, GifFileIn->Image.Top,
                                 GifFileIn->Image.Width, GifFileIn->Image.Height,
                                 GifFileIn->Image.Interlace, (ColorMapObject const   *)GifFileIn->Image.ColorMap);
      }
#line 232
      if (tmp___6 == 0) {
        {
#line 237
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
#line 240
      k = 0;
      {
#line 240
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 240
        if (! (k < GifFileIn->Image.Height)) {
#line 240
          goto while_break___4;
        }
        {
#line 241
        tmp___8 = DGifGetLine(GifFileIn, Line, Len);
        }
#line 241
        if (tmp___8 != 0) {
#line 242
          j = 0;
          {
#line 242
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 242
            if (! (j < Len)) {
#line 242
              goto while_break___5;
            }
#line 243
            *(Line + j) = (GifByteType )ReMapColor[*(Line + j)];
#line 242
            j ++;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 245
          tmp___7 = EGifPutLine(GifFileOut, Line, Len);
          }
#line 245
          if (tmp___7 == 0) {
            {
#line 246
            QuitGifError___9(GifFileIn, GifFileOut);
            }
          }
        } else {
          {
#line 249
          QuitGifError___9(GifFileIn, GifFileOut);
          }
        }
#line 240
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 251
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 254
      tmp___9 = DGifGetExtension(GifFileIn, & ExtCode, & Extension);
      }
#line 254
      if (tmp___9 == 0) {
        {
#line 256
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
      {
#line 257
      tmp___10 = EGifPutExtension(GifFileOut, ExtCode, (int )*(Extension + 0), (void const   *)Extension);
      }
#line 257
      if (tmp___10 == 0) {
        {
#line 259
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
      {
#line 262
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 262
        if (! ((unsigned long )Extension != (unsigned long )((void *)0))) {
#line 262
          goto while_break___6;
        }
        {
#line 263
        tmp___11 = DGifGetExtensionNext(GifFileIn, & Extension);
        }
#line 263
        if (tmp___11 == 0) {
          {
#line 265
          QuitGifError___9(GifFileIn, GifFileOut);
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 266
      goto switch_break;
      case_4: /* CIL Label */ 
#line 268
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 270
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 203
      if (! ((unsigned int )RecordType != 4U)) {
#line 203
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 275
    tmp___12 = DGifCloseFile(GifFileIn);
    }
#line 275
    if (tmp___12 == 0) {
      {
#line 276
      QuitGifError___9(GifFileIn, GifFileOut);
      }
    }
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  tmp___13 = EGifCloseFile(GifFileOut);
  }
#line 279
  if (tmp___13 == 0) {
    {
#line 280
    QuitGifError___9(GifFileIn, GifFileOut);
    }
  }
#line 281
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static void DoDisassembly(char *InFileName , char *OutFileName ) 
{ 
  int ExtCode ;
  int CodeSize ;
  int FileNum ;
  int FileEmpty ;
  GifRecordType RecordType ;
  char CrntFileName[80] ;
  GifByteType *Extension ;
  GifByteType *CodeBlock ;
  GifFileType *GifFileIn ;
  GifFileType *GifFileOut ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 288
  FileNum = 0;
#line 292
  GifFileIn = (GifFileType *)((void *)0);
#line 292
  GifFileOut = (GifFileType *)((void *)0);
#line 317
  if ((unsigned long )InFileName != (unsigned long )((void *)0)) {
    {
#line 318
    GifFileIn = DGifOpenFileName((char const   *)InFileName);
    }
#line 318
    if ((unsigned long )GifFileIn == (unsigned long )((void *)0)) {
      {
#line 319
      QuitGifError___9(GifFileIn, GifFileOut);
      }
    }
  } else {
    {
#line 323
    GifFileIn = DGifOpenFileHandle(0);
    }
#line 323
    if ((unsigned long )GifFileIn == (unsigned long )((void *)0)) {
      {
#line 324
      QuitGifError___9(GifFileIn, GifFileOut);
      }
    }
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 329
    tmp = FileNum;
#line 329
    FileNum ++;
#line 329
    sprintf((char */* __restrict  */)(CrntFileName), (char const   */* __restrict  */)"%s%02d.gif",
            OutFileName, tmp);
#line 330
    GifFileOut = EGifOpenFileName((char const   *)(CrntFileName), 1);
    }
#line 330
    if ((unsigned long )GifFileOut == (unsigned long )((void *)0)) {
      {
#line 331
      QuitGifError___9(GifFileIn, GifFileOut);
      }
    }
    {
#line 332
    FileEmpty = 1;
#line 335
    tmp___0 = EGifPutScreenDesc(GifFileOut, GifFileIn->SWidth, GifFileIn->SHeight,
                                GifFileIn->SColorResolution, GifFileIn->SBackGroundColor,
                                (ColorMapObject const   *)GifFileIn->SColorMap);
    }
#line 335
    if (tmp___0 == 0) {
      {
#line 339
      QuitGifError___9(GifFileIn, GifFileOut);
      }
    }
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 342
      tmp___1 = DGifGetRecordType(GifFileIn, & RecordType);
      }
#line 342
      if (tmp___1 == 0) {
        {
#line 343
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
      {
#line 346
      if ((unsigned int )RecordType == 2U) {
#line 346
        goto case_2;
      }
#line 368
      if ((unsigned int )RecordType == 3U) {
#line 368
        goto case_3;
      }
#line 384
      if ((unsigned int )RecordType == 4U) {
#line 384
        goto case_4;
      }
#line 386
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 347
      FileEmpty = 0;
#line 348
      tmp___2 = DGifGetImageDesc(GifFileIn);
      }
#line 348
      if (tmp___2 == 0) {
        {
#line 349
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
      {
#line 351
      tmp___3 = EGifPutImageDesc(GifFileOut, GifFileIn->Image.Left, GifFileIn->Image.Top,
                                 GifFileIn->Image.Width, GifFileIn->Image.Height,
                                 GifFileIn->Image.Interlace, (ColorMapObject const   *)GifFileIn->Image.ColorMap);
      }
#line 351
      if (tmp___3 == 0) {
        {
#line 356
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
      {
#line 360
      tmp___4 = DGifGetCode(GifFileIn, & CodeSize, & CodeBlock);
      }
#line 360
      if (tmp___4 == 0) {
        {
#line 362
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      } else {
        {
#line 360
        tmp___5 = EGifPutCode(GifFileOut, CodeSize, (GifByteType const   *)CodeBlock);
        }
#line 360
        if (tmp___5 == 0) {
          {
#line 362
          QuitGifError___9(GifFileIn, GifFileOut);
          }
        }
      }
      {
#line 363
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 363
        if (! ((unsigned long )CodeBlock != (unsigned long )((void *)0))) {
#line 363
          goto while_break___1;
        }
        {
#line 364
        tmp___6 = DGifGetCodeNext(GifFileIn, & CodeBlock);
        }
#line 364
        if (tmp___6 == 0) {
          {
#line 366
          QuitGifError___9(GifFileIn, GifFileOut);
          }
        } else {
          {
#line 364
          tmp___7 = EGifPutCodeNext(GifFileOut, (GifByteType const   *)CodeBlock);
          }
#line 364
          if (tmp___7 == 0) {
            {
#line 366
            QuitGifError___9(GifFileIn, GifFileOut);
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 367
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 369
      FileEmpty = 0;
#line 371
      tmp___8 = DGifGetExtension(GifFileIn, & ExtCode, & Extension);
      }
#line 371
      if (tmp___8 == 0) {
        {
#line 373
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
      {
#line 374
      tmp___9 = EGifPutExtension(GifFileOut, ExtCode, (int )*(Extension + 0), (void const   *)Extension);
      }
#line 374
      if (tmp___9 == 0) {
        {
#line 376
        QuitGifError___9(GifFileIn, GifFileOut);
        }
      }
      {
#line 379
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 379
        if (! ((unsigned long )Extension != (unsigned long )((void *)0))) {
#line 379
          goto while_break___2;
        }
        {
#line 380
        tmp___10 = DGifGetExtensionNext(GifFileIn, & Extension);
        }
#line 380
        if (tmp___10 == 0) {
          {
#line 382
          QuitGifError___9(GifFileIn, GifFileOut);
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 383
      goto switch_break;
      case_4: /* CIL Label */ 
#line 385
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 387
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 341
      if ((unsigned int )RecordType != 2U) {
#line 341
        if (! ((unsigned int )RecordType != 4U)) {
#line 341
          goto while_break___0;
        }
      } else {
#line 341
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 393
    tmp___11 = EGifCloseFile(GifFileOut);
    }
#line 393
    if (tmp___11 == 0) {
      {
#line 394
      QuitGifError___9(GifFileIn, GifFileOut);
      }
    }
#line 395
    if (FileEmpty) {
      {
#line 397
      unlink((char const   *)(CrntFileName));
      }
    }
#line 328
    if (! ((unsigned int )RecordType != 4U)) {
#line 328
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 402
  tmp___12 = DGifCloseFile(GifFileIn);
  }
#line 402
  if (tmp___12 == 0) {
    {
#line 403
    QuitGifError___9(GifFileIn, GifFileOut);
    }
  }
#line 404
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifasm.c"
static void QuitGifError___9(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 411
  PrintGifError();
  }
#line 412
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 412
    DGifCloseFile(GifFileIn);
    }
  }
#line 413
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 413
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 414
  exit(1);
  }
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___16  ;
#line 61
static int SubdivColorMap___16(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___16(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___16(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___16 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___16);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___16];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___16];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___16] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___16] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___16]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___16] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___16] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___16]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___16(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___16] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___16]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___16[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___16[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___16(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___16(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___16(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___16(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___16(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___16(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___16(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___16(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___16(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___16(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___16(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___16(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___16(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___16(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___16(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___16(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___16(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___16(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___16(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___15  ;
#line 141
static int GATestAllSatis___15(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___15(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___15(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___15(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___15(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___15(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___15(int argc , char **argv ) ;
#line 156
static char *MyMalloc___15(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___15  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___15(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___15 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___15 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___15, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___15(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___15((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___15 = LocalToken___15;
#line 264
        *(LocalToken___15 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___15(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___15 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___15 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___15(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___15(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___15(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___15((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___15(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___15 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___15 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___15(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___15((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___15((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___15((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___15((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___15((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___15((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___15((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___15((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___15((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___15((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___15((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___15((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___15(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___15(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___15(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___15(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static char *VersionStr___15  =    (char *)"Gif2RGB Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:54\n(C) Copyright 1989 Gershon Elber.\n";
#line 63 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static char *CtrlStr___15  =    (char *)"Gif2RGB q%- 1%- o%-OutFileName!s h%- GifFile!*s";
#line 70 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static int ImageNum___3  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static int BackGround___1  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static int OneFileFlag  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static int HelpFlag___1  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static int InterlacedOffset___2[4]  = {      0,      4,      2,      1};
#line 70 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static int InterlacedJumps___2[4]  = {      8,      8,      4,      2};
#line 77 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static ColorMapObject *ColorMap___1  ;
#line 80
static void DumpScreen2RGB(char *FileName , int OneFileFlag___1 , GifRowType *ScreenBuffer ,
                           int ScreenWidth , int ScreenHeight ) ;
#line 255 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static GifColorType *ColorMapEntry  ;
#line 265 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static char *Postfixes[3]  = {      (char *)".R",      (char *)".G",      (char *)".B"};
#line 249 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2rgb.c"
static void DumpScreen2RGB(char *FileName , int OneFileFlag___1 , GifRowType *ScreenBuffer ,
                           int ScreenWidth , int ScreenHeight ) 
{ 
  int i ;
  int j ;
  GifRowType GifRow ;
  FILE *f[3] ;
  char OneFileName[80] ;
  FILE *tmp ;
  unsigned char *Buffer ;
  unsigned char *BufferP ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  size_t tmp___4 ;
  unsigned char *Buffers[3] ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 258
  if ((unsigned long )FileName != (unsigned long )((void *)0)) {
#line 261
    if (OneFileFlag___1) {
      {
#line 262
      f[0] = fopen((char const   */* __restrict  */)FileName, (char const   */* __restrict  */)"wb");
      }
#line 262
      if ((unsigned long )f[0] == (unsigned long )((void *)0)) {
        {
#line 263
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "Gif2RGB", "Can\'t open input file name.");
#line 263
        exit(-3);
        }
      }
    } else {
#line 267
      i = 0;
      {
#line 267
      while (1) {
        while_continue: /* CIL Label */ ;
#line 267
        if (! (i < 3)) {
#line 267
          goto while_break;
        }
        {
#line 268
        strcpy((char */* __restrict  */)(OneFileName), (char const   */* __restrict  */)FileName);
#line 269
        strcat((char */* __restrict  */)(OneFileName), (char const   */* __restrict  */)Postfixes[i]);
#line 271
        tmp = fopen((char const   */* __restrict  */)(OneFileName), (char const   */* __restrict  */)"wb");
#line 271
        f[i] = tmp;
        }
#line 271
        if ((unsigned long )tmp == (unsigned long )((void *)0)) {
          {
#line 272
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                  "Gif2RGB", "Can\'t open input file name.");
#line 272
          exit(-3);
          }
        }
#line 267
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
#line 277
    OneFileFlag___1 = 1;
#line 283
    f[0] = stdout;
  }
#line 286
  if (OneFileFlag___1) {
    {
#line 289
    tmp___0 = malloc((size_t )(ScreenWidth * 3));
#line 289
    Buffer = (unsigned char *)tmp___0;
    }
#line 289
    if ((unsigned long )Buffer == (unsigned long )((void *)0)) {
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "Gif2RGB", "Failed to allocate memory required, aborted.");
#line 290
      exit(-3);
      }
    }
#line 291
    i = 0;
    {
#line 291
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 291
      if (! (i < ScreenHeight)) {
#line 291
        goto while_break___0;
      }
      {
#line 292
      GifRow = *(ScreenBuffer + i);
#line 293
      GifQprintf((char *)"\b\b\b\b%-4d", ScreenHeight - i);
#line 294
      j = 0;
#line 294
      BufferP = Buffer;
      }
      {
#line 294
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 294
        if (! (j < ScreenWidth)) {
#line 294
          goto while_break___1;
        }
#line 295
        ColorMapEntry = ColorMap___1->Colors + *(GifRow + j);
#line 296
        tmp___1 = BufferP;
#line 296
        BufferP ++;
#line 296
        *tmp___1 = ColorMapEntry->Red;
#line 297
        tmp___2 = BufferP;
#line 297
        BufferP ++;
#line 297
        *tmp___2 = ColorMapEntry->Green;
#line 298
        tmp___3 = BufferP;
#line 298
        BufferP ++;
#line 298
        *tmp___3 = ColorMapEntry->Blue;
#line 294
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 300
      tmp___4 = fwrite((void const   */* __restrict  */)Buffer, (size_t )(ScreenWidth * 3),
                       (size_t )1, (FILE */* __restrict  */)f[0]);
      }
#line 300
      if (tmp___4 != 1UL) {
        {
#line 301
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "Gif2RGB", "Write to file(s) failed.");
#line 301
        exit(-3);
        }
      }
#line 291
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 304
    free((void *)((char *)Buffer));
#line 305
    fclose(f[0]);
    }
  } else {
    {
#line 309
    tmp___5 = malloc((size_t )ScreenWidth);
#line 309
    Buffers[0] = (unsigned char *)tmp___5;
    }
#line 309
    if ((unsigned long )Buffers[0] == (unsigned long )((void *)0)) {
      {
#line 312
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "Gif2RGB", "Failed to allocate memory required, aborted.");
#line 312
      exit(-3);
      }
    } else {
      {
#line 309
      tmp___6 = malloc((size_t )ScreenWidth);
#line 309
      Buffers[1] = (unsigned char *)tmp___6;
      }
#line 309
      if ((unsigned long )Buffers[1] == (unsigned long )((void *)0)) {
        {
#line 312
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "Gif2RGB", "Failed to allocate memory required, aborted.");
#line 312
        exit(-3);
        }
      } else {
        {
#line 309
        tmp___7 = malloc((size_t )ScreenWidth);
#line 309
        Buffers[2] = (unsigned char *)tmp___7;
        }
#line 309
        if ((unsigned long )Buffers[2] == (unsigned long )((void *)0)) {
          {
#line 312
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                  "Gif2RGB", "Failed to allocate memory required, aborted.");
#line 312
          exit(-3);
          }
        }
      }
    }
#line 314
    i = 0;
    {
#line 314
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 314
      if (! (i < ScreenHeight)) {
#line 314
        goto while_break___2;
      }
      {
#line 315
      GifRow = *(ScreenBuffer + i);
#line 316
      GifQprintf((char *)"\b\b\b\b%-4d", ScreenHeight - i);
#line 317
      j = 0;
      }
      {
#line 317
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 317
        if (! (j < ScreenWidth)) {
#line 317
          goto while_break___3;
        }
#line 318
        ColorMapEntry = ColorMap___1->Colors + *(GifRow + j);
#line 319
        *(Buffers[0] + j) = ColorMapEntry->Red;
#line 320
        *(Buffers[1] + j) = ColorMapEntry->Green;
#line 321
        *(Buffers[2] + j) = ColorMapEntry->Blue;
#line 317
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 323
      tmp___8 = fwrite((void const   */* __restrict  */)Buffers[0], (size_t )ScreenWidth,
                       (size_t )1, (FILE */* __restrict  */)f[0]);
      }
#line 323
      if (tmp___8 != 1UL) {
        {
#line 326
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "Gif2RGB", "Write to file(s) failed.");
#line 326
        exit(-3);
        }
      } else {
        {
#line 323
        tmp___9 = fwrite((void const   */* __restrict  */)Buffers[1], (size_t )ScreenWidth,
                         (size_t )1, (FILE */* __restrict  */)f[1]);
        }
#line 323
        if (tmp___9 != 1UL) {
          {
#line 326
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                  "Gif2RGB", "Write to file(s) failed.");
#line 326
          exit(-3);
          }
        } else {
          {
#line 323
          tmp___10 = fwrite((void const   */* __restrict  */)Buffers[2], (size_t )ScreenWidth,
                            (size_t )1, (FILE */* __restrict  */)f[2]);
          }
#line 323
          if (tmp___10 != 1UL) {
            {
#line 326
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                    "Gif2RGB", "Write to file(s) failed.");
#line 326
            exit(-3);
            }
          }
        }
      }
#line 314
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 329
    free((void *)((char *)Buffers[0]));
#line 330
    free((void *)((char *)Buffers[1]));
#line 331
    free((void *)((char *)Buffers[2]));
#line 332
    fclose(f[0]);
#line 333
    fclose(f[1]);
#line 334
    fclose(f[2]);
    }
  }
#line 336
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___16(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___16(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___16(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___16(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___16(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___16(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___16(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___16(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___16(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___16(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___16(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___16(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___16(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___16(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___16[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___16(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___16(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___16[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___16(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___16  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___16  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___16  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___16  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___16  =    100L;
#line 62
static void GetScanLine___16(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___17(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___16(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___16 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___16 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___16;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___17(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___16(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___16(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___17  ;
#line 61
static int SubdivColorMap___17(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___17(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___17(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___17 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___17);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___17];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___17];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___17] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___17] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___17]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___17] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___17] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___17]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___17(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___17] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___17]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___17[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___17[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___17(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___17(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___17(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___17(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___17(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___17(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___17(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___17(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___17(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___17(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___17(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___17(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___17(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___17(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___17(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___17(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___17(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___17(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___17(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___16  ;
#line 141
static int GATestAllSatis___16(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___16(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___16(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___16(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___16(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___16(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___16(int argc , char **argv ) ;
#line 156
static char *MyMalloc___16(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___16  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___16(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___16 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___16 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___16, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___16(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___16((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___16 = LocalToken___16;
#line 264
        *(LocalToken___16 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___16(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___16 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___16 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___16(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___16(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___16(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___16((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___16(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___16 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___16 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___16(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___16((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___16((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___16((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___16((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___16((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___16((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___16((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___16((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___16((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___16((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___16((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___16((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___16(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___16(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___16(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___16(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___17(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___17(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___17(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___17(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___17(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___17(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___17(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___17(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___17(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___17(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___17(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___17(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___17(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___17(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___17[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___17(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___17(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___17[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___17(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___17  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___17  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___17  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___17  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___17  =    100L;
#line 62
static void GetScanLine___17(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___18(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___17(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___17 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___17 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___17;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___18(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclip.c"
static char *VersionStr___16  =    (char *)"GifClip Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:55\n(C) Copyright 1989 Gershon Elber.\n";
#line 57 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclip.c"
static char *CtrlStr___16  =    (char *)"GifClip q%- c%- i%-Xmin|Ymin|Xmax|Ymax!d!d!d!d n%-n|Xmin|Ymin|Xmax|Ymax!d!d!d!d!d h%- GifFile!*s";
#line 63
static void QuitGifError___10(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 317 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifclip.c"
static void QuitGifError___10(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 319
  PrintGifError();
  }
#line 320
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 320
    DGifCloseFile(GifFileIn);
    }
  }
#line 321
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 321
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 322
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___17(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___17(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___18  ;
#line 61
static int SubdivColorMap___18(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___18(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___18(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___18 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___18);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___18];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___18];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___18] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___18] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___18]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___18] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___18] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___18]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___18(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___18] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___18]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___18[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___18[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___18(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___18(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___18(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___18(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___18(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___18(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___18(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___18(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___18(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___18(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___18(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___18(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___18(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___18(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___18(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___18(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___18(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___18(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___18(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___17  ;
#line 141
static int GATestAllSatis___17(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___17(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___17(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___17(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___17(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___17(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___17(int argc , char **argv ) ;
#line 156
static char *MyMalloc___17(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___17  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___17(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___17 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___17 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___17, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___17(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___17((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___17 = LocalToken___17;
#line 264
        *(LocalToken___17 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___17(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___17 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___17 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___17(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___17(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___17(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___17((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___17(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___17 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___17 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___17(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___17((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___17((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___17((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___17((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___17((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___17((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___17((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___17((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___17((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___17((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___17((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___17((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___17(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___17(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___17(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___17(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___18(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___18(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___18(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___18(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___18(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___18(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___18(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___18(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___18(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___18(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___18(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___18(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___18(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___18(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___18[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___18(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___18(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___18[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___18(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___18  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___18  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___18  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___18  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___18  =    100L;
#line 62
static void GetScanLine___18(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___19(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___18(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___18 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___18 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___18;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___19(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 1453 "/usr/include/X11/Xlib.h"
extern XImage *XCreateImage(Display * , Visual * , unsigned int  , int  , int  , char * ,
                            unsigned int  , unsigned int  , int  , int  ) ;
#line 1495
extern Display *XOpenDisplay(char const   * ) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1588
extern Cursor XCreateFontCursor(Display * , unsigned int  ) ;
#line 1616
extern Pixmap XCreateBitmapFromData(Display * , Drawable  , char const   * , unsigned int  ,
                                    unsigned int  ) ;
#line 1648
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1900
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2243
extern int XDefineCursor(Display * , Window  , Cursor  ) ;
#line 2537
extern int XFreeColors(Display * , Colormap  , unsigned long * , int  , unsigned long  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2915
extern int XPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                     int  , unsigned int  , unsigned int  ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3166
extern int XSetBackground(Display * , GC  , unsigned long  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 617
extern int XSetStandardProperties(Display * , Window  , char const   * , char const   * ,
                                  Pixmap  , char ** , int  , XSizeHints * ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static char *VersionStr___17  =    (char *)"Gif2X11 Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:06\n(C) Copyright 1989 Gershon Elber.\n";
#line 73 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static char *CtrlStr___17  =    (char *)"Gif2X11 q%- p%-PosX|PosY!d!d d%-Display!s f%- h%- GifFile!*s";
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int PosFlag___0  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int HelpFlag___2  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int DisplayFlag  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int ForceFlag  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int ColorMapSize  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int BackGround___2  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int XPosX  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int XPosY  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int InterlacedOffset___3[4]  = {      0,      4,      2,      1};
#line 80 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int InterlacedJumps___3[4]  = {      8,      8,      4,      2};
#line 91 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static char *DisplayName  =    (char *)((void *)0);
#line 93 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static ColorMapObject *ColorMap___2  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static XColor XColorTable[256]  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static unsigned long XPixelTable[256]  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static Display *XDisplay  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static int XScreen  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static Window Xroot  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static Window XImageWndw  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static Colormap XColorMap  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static GC XGraphContext  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static Visual *XVisual  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static XImage *XImageBuffer  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static Pixmap XIcon  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static Cursor XCursor  ;
#line 114
static void Screen2X(int argc , char **argv , GifRowType *ScreenBuffer , int ScreenWidth ,
                     int ScreenHeight ) ;
#line 116
static void AllocateColors1(void) ;
#line 117
static void AllocateColors2(void) ;
#line 305 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static void Screen2X(int argc , char **argv , GifRowType *ScreenBuffer , int ScreenWidth ,
                     int ScreenHeight ) 
{ 
  int rc ;
  Atom atomKill ;
  int i ;
  int j ;
  int c ;
  int Size ;
  int x ;
  int y ;
  int MinIntensity ;
  int MaxIntensity ;
  int AvgIntensity ;
  int IconSizeX ;
  int IconSizeY ;
  char *XImageData ;
  char *XIconData ;
  char KeyBuffer[81] ;
  unsigned long ValueMask ;
  GifColorType *ColorMapEntry___0 ;
  XSetWindowAttributes SetWinAttr ;
  XSizeHints Hints ;
  XEvent Event ;
  XExposeEvent *EEvent ;
  XKeyEvent *KEvent ;
  XComposeStatus Stat ;
  KeySym KS ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 317
  ColorMapEntry___0 = ColorMap___2->Colors;
#line 327
  MaxIntensity = 0;
#line 328
  MinIntensity = 25600;
#line 329
  i = 0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! (i < ColorMapSize)) {
#line 329
      goto while_break;
    }
#line 330
    c = ((int )(ColorMapEntry___0 + i)->Red * 30 + (int )(ColorMapEntry___0 + i)->Green * 59) + (int )(ColorMapEntry___0 + i)->Blue * 11;
#line 333
    if (c > MaxIntensity) {
#line 333
      MaxIntensity = c;
    }
#line 334
    if (c < MinIntensity) {
#line 334
      MinIntensity = c;
    }
#line 329
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  AvgIntensity = (MinIntensity + MaxIntensity) / 2;
#line 339
  if (ForceFlag) {
    {
#line 340
    AllocateColors2();
    }
  } else {
    {
#line 342
    AllocateColors1();
    }
  }
#line 344
  SetWinAttr.background_pixel = (((_XPrivDisplay )XDisplay)->screens + XScreen)->black_pixel;
#line 345
  SetWinAttr.border_pixel = (((_XPrivDisplay )XDisplay)->screens + XScreen)->white_pixel;
#line 346
  ValueMask = (unsigned long )((1L << 1) | (1L << 3));
#line 348
  Hints.flags = ((1L << 3) | (1L << 4)) | (1L << 5);
#line 349
  Hints.y = 1;
#line 349
  Hints.x = Hints.y;
#line 350
  Hints.max_width = ScreenWidth;
#line 350
  Hints.min_width = Hints.max_width;
#line 350
  Hints.width = Hints.min_width;
#line 351
  Hints.max_height = ScreenHeight;
#line 351
  Hints.min_height = Hints.max_height;
#line 351
  Hints.height = Hints.min_height;
#line 352
  if (PosFlag___0) {
#line 353
    Hints.flags |= 1L;
#line 354
    Hints.x = XPosX;
#line 355
    Hints.y = XPosY;
  }
  {
#line 358
  XImageWndw = XCreateWindow(XDisplay, Xroot, XPosX, XPosY, (unsigned int )ScreenWidth,
                             (unsigned int )ScreenHeight, 1U, 0, 0U, (Visual *)0L,
                             ValueMask, & SetWinAttr);
  }
#line 365
  if (ScreenWidth > ScreenHeight) {
#line 366
    IconSizeX = 56;
#line 367
    IconSizeY = (ScreenHeight * 60) / ScreenWidth;
  } else {
#line 370
    IconSizeY = 60;
#line 371
    IconSizeX = (((ScreenWidth * 60) / ScreenHeight) / 8) * 8;
  }
  {
#line 373
  tmp = malloc((size_t )((IconSizeX * IconSizeY) / 8));
#line 373
  XIconData = (char *)tmp;
#line 374
  memset((void *)XIconData, 0, (size_t )((IconSizeX * IconSizeY) / 8));
#line 375
  i = 0;
  }
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 375
    if (! (i < IconSizeY)) {
#line 375
      goto while_break___0;
    }
#line 376
    y = (i * ScreenHeight) / IconSizeY;
#line 377
    Size = (i * IconSizeX) / 8;
#line 378
    j = 0;
    {
#line 378
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 378
      if (! (j < IconSizeX)) {
#line 378
        goto while_break___1;
      }
#line 379
      x = (j * ScreenWidth) / IconSizeX;
#line 380
      c = (int )*(*(ScreenBuffer + y) + x);
#line 381
      c = ((int )(ColorMapEntry___0 + c)->Red * 30 + (int )(ColorMapEntry___0 + c)->Green * 59) + (int )(ColorMapEntry___0 + c)->Blue * 11 > AvgIntensity;
#line 384
      *(XIconData + (Size + j / 8)) = (char )((int )*(XIconData + (Size + j / 8)) | (c << j % 8));
#line 378
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 375
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 388
  XIcon = XCreateBitmapFromData(XDisplay, XImageWndw, (char const   *)XIconData, (unsigned int )IconSizeX,
                                (unsigned int )IconSizeY);
#line 391
  XSetStandardProperties(XDisplay, XImageWndw, "Gif2X11", "Gif2X11", XIcon, argv,
                         argc, & Hints);
#line 396
  free((void *)XIconData);
#line 398
  atomKill = XInternAtom(XDisplay, "WM_DELETE_WINDOW", 0);
#line 399
  rc = XSetWMProtocols(XDisplay, XImageWndw, & atomKill, 1);
  }
#line 400
  if (rc == 0) {
    {
#line 401
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2X11", "Failed to trap WM_DELETE_WINDOW event");
#line 401
    exit(-3);
    }
  }
  {
#line 403
  XSelectInput(XDisplay, XImageWndw, (1L << 15) | 1L);
#line 406
  XCursor = XCreateFontCursor(XDisplay, 36U);
#line 407
  XDefineCursor(XDisplay, XImageWndw, XCursor);
#line 409
  XMapWindow(XDisplay, XImageWndw);
#line 412
  tmp___0 = malloc((size_t )((ScreenWidth * ScreenHeight) * 4));
#line 412
  XImageData = (char *)tmp___0;
  }
#line 412
  if ((unsigned long )XImageData == (unsigned long )((void *)0)) {
    {
#line 413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2X11", "Failed to allocate memory required, aborted.");
#line 413
    exit(-3);
    }
  }
#line 415
  i = 0;
  {
#line 415
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 415
    if (! (i < ScreenHeight)) {
#line 415
      goto while_break___2;
    }
#line 416
    y = i * ScreenWidth;
#line 417
    j = 0;
    {
#line 417
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 417
      if (! (j < ScreenWidth)) {
#line 417
        goto while_break___3;
      }
#line 418
      *(XImageData + (y + j) * 4) = (char )XColorTable[*(*(ScreenBuffer + i) + j)].blue;
#line 419
      *(XImageData + ((y + j) * 4 + 1)) = (char )XColorTable[*(*(ScreenBuffer + i) + j)].green;
#line 420
      *(XImageData + ((y + j) * 4 + 2)) = (char )XColorTable[*(*(ScreenBuffer + i) + j)].red;
#line 417
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 415
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 423
  XImageBuffer = XCreateImage(XDisplay, XVisual, (unsigned int )(((_XPrivDisplay )XDisplay)->screens + ((_XPrivDisplay )XDisplay)->default_screen)->root_depth,
                              2, 0, XImageData, (unsigned int )ScreenWidth, (unsigned int )ScreenHeight,
                              ((_XPrivDisplay )XDisplay)->bitmap_pad, ScreenWidth * 4);
  }
  {
#line 427
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 428
    XNextEvent(XDisplay, & Event);
    }
    {
#line 430
    if (Event.type == 12) {
#line 430
      goto case_12;
    }
#line 437
    if (Event.type == 2) {
#line 437
      goto case_2;
    }
#line 443
    if (Event.type == 33) {
#line 443
      goto case_33;
    }
#line 429
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 431
    EEvent = (XExposeEvent *)(& Event);
#line 432
    XPutImage(XDisplay, XImageWndw, XGraphContext, XImageBuffer, EEvent->x, EEvent->y,
              EEvent->x, EEvent->y, (unsigned int )EEvent->width, (unsigned int )EEvent->height);
    }
#line 436
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 438
    KEvent = (XKeyEvent *)(& Event);
#line 439
    XLookupString(KEvent, KeyBuffer, 80, & KS, & Stat);
    }
#line 440
    if ((int )KeyBuffer[0] == 3) {
#line 440
      return;
    }
#line 442
    goto switch_break;
    case_33: /* CIL Label */ 
#line 444
    if ((Atom )Event.xclient.data.l[0] == atomKill) {
#line 444
      return;
    }
#line 445
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static void AllocateColors1(void) 
{ 
  int Strip ;
  int Msk ;
  int i ;
  char Msg[80] ;
  int tmp ;

  {
#line 460
  i = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (i < 256)) {
#line 460
      goto while_break;
    }
#line 461
    XPixelTable[i] = 0UL;
#line 460
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  Strip = 0;
#line 463
  Msk = 255;
  {
#line 463
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 463
    if (! (Strip < 8)) {
#line 463
      goto while_break___0;
    }
#line 464
    i = 0;
    {
#line 464
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 464
      if (! (i < ColorMapSize)) {
#line 464
        goto while_break___1;
      }
      {
#line 466
      XColorTable[i].red = (unsigned short )(((int )(ColorMap___2->Colors + i)->Red & Msk) << 8);
#line 467
      XColorTable[i].green = (unsigned short )(((int )(ColorMap___2->Colors + i)->Green & Msk) << 8);
#line 468
      XColorTable[i].blue = (unsigned short )(((int )(ColorMap___2->Colors + i)->Blue & Msk) << 8);
#line 469
      XColorTable[i].flags = (char )((1 | (1 << 1)) | (1 << 2));
#line 470
      tmp = XAllocColor(XDisplay, XColorMap, & XColorTable[i]);
      }
#line 470
      if (tmp) {
#line 471
        XPixelTable[i] = XColorTable[i].pixel;
      } else {
#line 473
        goto while_break___1;
      }
#line 464
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 475
    if (i < ColorMapSize) {
      {
#line 476
      XFreeColors(XDisplay, XColorMap, XPixelTable, i, 0UL);
      }
    } else {
#line 478
      goto while_break___0;
    }
#line 463
    Strip ++;
#line 463
    Msk <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 481
  if (Strip == 8) {
    {
#line 482
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2X11", "Can not display the image - not enough colors available.");
#line 482
    exit(-3);
    }
  }
#line 484
  if (Strip != 0) {
    {
#line 485
    sprintf((char */* __restrict  */)(Msg), (char const   */* __restrict  */)"%d bits were stripped off the color map.",
            Strip);
#line 486
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2X11", Msg);
    }
  }
#line 488
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gif2x11.c"
static void AllocateColors2(void) 
{ 
  int i ;
  int j ;
  int Index ;
  int Count ;
  int XNumOfColors ;
  char Msg[80] ;
  unsigned long D ;
  unsigned long Distance ;
  unsigned long AvgDistance ;
  unsigned long Red ;
  unsigned long Green ;
  unsigned long Blue ;
  GifBooleanType Failed ;
  XColor *XOldColorTable ;
  int tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 503
  Index = 0;
#line 503
  Count = 0;
#line 505
  AvgDistance = 0UL;
#line 506
  Failed = 0;
#line 509
  i = 0;
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! (i < 256)) {
#line 509
      goto while_break;
    }
#line 510
    if (i < ColorMapSize) {
#line 511
      XColorTable[i].red = (unsigned short )((int )(ColorMap___2->Colors + i)->Red << 8);
#line 512
      XColorTable[i].green = (unsigned short )((int )(ColorMap___2->Colors + i)->Green << 8);
#line 513
      XColorTable[i].blue = (unsigned short )((int )(ColorMap___2->Colors + i)->Blue << 8);
#line 514
      XColorTable[i].flags = (char )((1 | (1 << 1)) | (1 << 2));
#line 515
      XPixelTable[i] = 0xffffffffffffffffUL;
    } else {
#line 518
      XPixelTable[i] = 0UL;
    }
#line 509
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  i = 0;
  {
#line 521
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 521
    if (! (i < ColorMapSize)) {
#line 521
      goto while_break___0;
    }
    {
#line 522
    tmp = XAllocColor(XDisplay, XColorMap, & XColorTable[i]);
    }
#line 522
    if (tmp) {
#line 523
      XPixelTable[i] = XColorTable[i].pixel;
    } else {
#line 525
      Failed = 1;
    }
#line 521
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 527
  if (Failed) {
    {
#line 528
    XNumOfColors = ((((_XPrivDisplay )XDisplay)->screens + XScreen)->root_visual)->map_entries;
#line 529
    tmp___0 = malloc(sizeof(XColor ) * (unsigned long )XNumOfColors);
#line 529
    XOldColorTable = (XColor *)tmp___0;
#line 530
    i = 0;
    }
    {
#line 530
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 530
      if (! (i < XNumOfColors)) {
#line 530
        goto while_break___1;
      }
#line 530
      (XOldColorTable + i)->pixel = (unsigned long )i;
#line 530
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 531
    XQueryColors(XDisplay, XColorMap, XOldColorTable, XNumOfColors);
#line 533
    i = 0;
    }
    {
#line 533
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 533
      if (! (i < ColorMapSize)) {
#line 533
        goto while_break___2;
      }
#line 535
      if (XPixelTable[i] == 0xffffffffffffffffUL) {
#line 536
        Distance = 4294967295UL;
#line 538
        Red = (unsigned long )XColorTable[i].red;
#line 539
        Green = (unsigned long )XColorTable[i].green;
#line 540
        Blue = (unsigned long )XColorTable[i].blue;
#line 542
        j = 0;
        {
#line 542
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 542
          if (! (j < XNumOfColors)) {
#line 542
            goto while_break___3;
          }
#line 544
          if (Red - (unsigned long )(XOldColorTable + j)->red > 0UL) {
#line 544
            tmp___1 = Red - (unsigned long )(XOldColorTable + j)->red;
          } else {
#line 544
            tmp___1 = - (Red - (unsigned long )(XOldColorTable + j)->red);
          }
#line 544
          if (Green - (unsigned long )(XOldColorTable + j)->green > 0UL) {
#line 544
            tmp___2 = Green - (unsigned long )(XOldColorTable + j)->green;
          } else {
#line 544
            tmp___2 = - (Green - (unsigned long )(XOldColorTable + j)->green);
          }
#line 544
          if (Blue - (unsigned long )(XOldColorTable + j)->blue > 0UL) {
#line 544
            tmp___3 = Blue - (unsigned long )(XOldColorTable + j)->blue;
          } else {
#line 544
            tmp___3 = - (Blue - (unsigned long )(XOldColorTable + j)->blue);
          }
#line 544
          D = (tmp___1 + tmp___2) + tmp___3;
#line 544
          if (D < Distance) {
#line 547
            Distance = D;
#line 548
            Index = j;
          }
#line 542
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 551
        XPixelTable[i] = (unsigned long )Index;
#line 553
        AvgDistance += Distance;
#line 554
        Count ++;
      }
#line 533
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 557
    free((void *)XOldColorTable);
#line 559
    sprintf((char */* __restrict  */)(Msg), (char const   */* __restrict  */)"Colors will be approximated (average error = %ld).\n",
            AvgDistance / (unsigned long )Count);
#line 561
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Gif2X11", Msg);
    }
  }
#line 563
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___18(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___18(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___19  ;
#line 61
static int SubdivColorMap___19(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___19(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___19(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___19 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___19);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___19];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___19];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___19] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___19] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___19]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___19] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___19] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___19]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___19(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___19] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___19]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___19[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___19[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___19(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___19(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___19(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___19(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___19(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___19(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___19(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___19(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___19(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___19(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___19(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___19(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___19(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___19(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___19(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___19(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___19(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___19(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___19(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___18  ;
#line 141
static int GATestAllSatis___18(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___18(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___18(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___18(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___18(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___18(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___18(int argc , char **argv ) ;
#line 156
static char *MyMalloc___18(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___18  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___18(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___18 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___18 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___18, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___18(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___18((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___18 = LocalToken___18;
#line 264
        *(LocalToken___18 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___18(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___18 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___18 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___18(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___18(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___18(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___18((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___18(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___18 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___18 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___18(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___18((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___18((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___18((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___18((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___18((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___18((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___18((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___18((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___18((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___18((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___18((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___18((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___18(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___18(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___18(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___18(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___19(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___19(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___19(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___19(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___19(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___19(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___19(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___19(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___19(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___19(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___19(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___19(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___19(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___19(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___19[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___19(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___19(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___19[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___19(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___19  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___19  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___19  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___19  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___19  =    100L;
#line 62
static void GetScanLine___19(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___20(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___19(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___19 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___19 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___19;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___20(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifcolor.c"
static char *VersionStr___18  =    (char *)"GifColor Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:04\n(C) Copyright 1989 Gershon Elber.\n";
#line 59 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifcolor.c"
static char *CtrlStr___18  =    (char *)"GifColor q%- b%-Background!d h%-";
#line 63 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifcolor.c"
static int BackGround___3  =    0;
#line 64
static void QuitGifError___11(GifFileType *GifFile ) ;
#line 65
static void GenRasterTextLine(GifRowType *RasterBuffer , char *TextLine , int BufferWidth ,
                              int ForeGroundIndex ) ;
#line 160 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifcolor.c"
static void GenRasterTextLine(GifRowType *RasterBuffer , char *TextLine , int BufferWidth ,
                              int ForeGroundIndex ) 
{ 
  unsigned char c ;
  unsigned char Byte ;
  unsigned char Mask ;
  int i ;
  int j ;
  int k ;
  int CharPosX ;
  int Len ;
  size_t tmp ;

  {
  {
#line 165
  tmp = strlen((char const   *)TextLine);
#line 165
  Len = (int )tmp;
#line 167
  i = 0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < BufferWidth)) {
#line 167
      goto while_break;
    }
#line 168
    j = 0;
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      if (! (j < 8)) {
#line 168
        goto while_break___0;
      }
#line 168
      *(*(RasterBuffer + j) + i) = (unsigned char )BackGround___3;
#line 168
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  CharPosX = 0;
#line 170
  i = CharPosX;
  {
#line 170
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 170
    if (! (i < Len)) {
#line 170
      goto while_break___1;
    }
#line 171
    c = (unsigned char )*(TextLine + i);
#line 172
    j = 0;
    {
#line 172
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 172
      if (! (j < 8)) {
#line 172
        goto while_break___2;
      }
#line 173
      Byte = AsciiTable[(unsigned short )c][j];
#line 174
      k = 0;
#line 174
      Mask = (unsigned char)128;
      {
#line 174
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 174
        if (! (k < 8)) {
#line 174
          goto while_break___3;
        }
#line 175
        if ((int )Byte & (int )Mask) {
#line 176
          *(*(RasterBuffer + j) + (CharPosX + k)) = (unsigned char )ForeGroundIndex;
        }
#line 174
        k ++;
#line 174
        Mask = (unsigned char )((int )Mask >> 1);
      }
      while_break___3: /* CIL Label */ ;
      }
#line 172
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 170
    i ++;
#line 170
    CharPosX += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifcolor.c"
static void QuitGifError___11(GifFileType *GifFile ) 
{ 


  {
  {
#line 186
  PrintGifError();
  }
#line 187
  if ((unsigned long )GifFile != (unsigned long )((void *)0)) {
    {
#line 187
    EGifCloseFile(GifFile);
    }
  }
  {
#line 188
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___19(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___19(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___20  ;
#line 61
static int SubdivColorMap___20(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___20(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___20(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___20 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___20);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___20];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___20];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___20] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___20] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___20]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___20] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___20] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___20]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___20(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___20] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___20]);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinfo.c"
static char *VersionStr___19  =    (char *)"GifInfo Version 4.1, \tMartin Edlman,\tMar  3 2016,   19:58:04\n(C) Copyright 1999 Martin Edlman.\n";
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinfo.c"
static char *CtrlStr___19  =    (char *)"GifInfo f%-Format!s h%- GifFile!*s";
#line 74 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinfo.c"
static int HelpFlag___3  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___20[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___20[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___20(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___20(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___20(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___20(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___20(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___20(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___20(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___20(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___20(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___20(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___20(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___20(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___20(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___20(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___20(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___20(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___20(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___20(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___20(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___19  ;
#line 141
static int GATestAllSatis___19(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___19(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___19(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___19(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___19(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___19(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___19(int argc , char **argv ) ;
#line 156
static char *MyMalloc___19(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___19  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___19(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___19 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___19 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___19, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___19(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___19((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___19 = LocalToken___19;
#line 264
        *(LocalToken___19 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___19(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___19 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___19 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___19(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___19(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___19(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___19((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___19(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___19 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___19 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___19(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___19((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___19((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___19((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___19((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___19((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___19((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___19((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___19((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___19((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___19((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___19((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___19((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___19(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___19(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___19(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___19(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___20(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___20(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___20(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___20(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___20(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___20(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___20(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___20(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___20(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___20(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___20(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___20(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___20(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___20(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___20[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___20(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___20(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___20[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___20(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___20  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___20  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___20  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___20  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___20  =    100L;
#line 62
static void GetScanLine___20(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___21(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___20(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___20 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___20 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___20;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___21(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___20(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___20(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___21  ;
#line 61
static int SubdivColorMap___21(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___21(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___21(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___21 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___21);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___21];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___21];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___21] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___21] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___21]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___21] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___21] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___21]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___21(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___21] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___21]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___21[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___21[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___21(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___21(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___21(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___21(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___21(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___21(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___21(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___21(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___21(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___21(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___21(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___21(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___21(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___21(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___21(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___21(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___21(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___21(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___21(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/text2gif.c"
static char *VersionStr___20  =    (char *)"Text2Gif Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:02\n(C) Copyright 1989 Gershon Elber.\n";
#line 69 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/text2gif.c"
static char *CtrlStr___20  =    (char *)"Text2Gif q%- s%-ClrMapSize!d f%-FGClr!d c%-R|G|B!d!d!d t%-\"Text\"!s h%-";
#line 75 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/text2gif.c"
static unsigned int RedColor___0  =    255U;
#line 75 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/text2gif.c"
static unsigned int GreenColor___0  =    255U;
#line 75 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/text2gif.c"
static unsigned int BlueColor___0  =    255U;
#line 80
static void QuitGifError___12(GifFileType *GifFile ) ;
#line 81
static void GenRasterTextLine___0(GifRowType *RasterBuffer , char *TextLine , int BufferWidth ,
                                  int ForeGroundIndex ) ;
#line 203 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/text2gif.c"
static void GenRasterTextLine___0(GifRowType *RasterBuffer , char *TextLine , int BufferWidth ,
                                  int ForeGroundIndex ) 
{ 
  unsigned char c ;
  unsigned char Byte ;
  unsigned char Mask ;
  int i ;
  int j ;
  int k ;
  int CharPosX ;
  int Len ;
  size_t tmp ;

  {
  {
#line 208
  tmp = strlen((char const   *)TextLine);
#line 208
  Len = (int )tmp;
#line 210
  i = 0;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < BufferWidth)) {
#line 210
      goto while_break;
    }
#line 211
    j = 0;
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 211
      if (! (j < 8)) {
#line 211
        goto while_break___0;
      }
#line 211
      *(*(RasterBuffer + j) + i) = (unsigned char)0;
#line 211
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  CharPosX = 0;
#line 213
  i = CharPosX;
  {
#line 213
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 213
    if (! (i < Len)) {
#line 213
      goto while_break___1;
    }
#line 214
    c = (unsigned char )*(TextLine + i);
#line 215
    j = 0;
    {
#line 215
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 215
      if (! (j < 8)) {
#line 215
        goto while_break___2;
      }
#line 216
      Byte = AsciiTable[(unsigned short )c][j];
#line 217
      k = 0;
#line 217
      Mask = (unsigned char)128;
      {
#line 217
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 217
        if (! (k < 8)) {
#line 217
          goto while_break___3;
        }
#line 218
        if ((int )Byte & (int )Mask) {
#line 219
          *(*(RasterBuffer + j) + (CharPosX + k)) = (unsigned char )ForeGroundIndex;
        }
#line 217
        k ++;
#line 217
        Mask = (unsigned char )((int )Mask >> 1);
      }
      while_break___3: /* CIL Label */ ;
      }
#line 215
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 213
    i ++;
#line 213
    CharPosX += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/text2gif.c"
static void QuitGifError___12(GifFileType *GifFile ) 
{ 


  {
  {
#line 229
  PrintGifError();
  }
#line 230
  if ((unsigned long )GifFile != (unsigned long )((void *)0)) {
    {
#line 230
    EGifCloseFile(GifFile);
    }
  }
  {
#line 231
  exit(1);
  }
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___20  ;
#line 141
static int GATestAllSatis___20(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___20(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___20(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___20(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___20(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___20(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___20(int argc , char **argv ) ;
#line 156
static char *MyMalloc___20(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___20  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___20(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___20 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___20 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___20, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___20(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___20((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___20 = LocalToken___20;
#line 264
        *(LocalToken___20 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___20(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___20 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___20 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___20(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___20(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___20(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___20((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___20(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___20 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___20 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___20(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___20((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___20((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___20((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___20((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___20((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___20((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___20((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___20((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___20((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___20((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___20((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___20((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___20(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___20(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___20(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___20(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___21(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___21(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___21(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___21(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___21(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___21(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___21(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___21(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___21(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___21(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___21(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___21(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___21(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___21(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___21[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___21(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___21(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___21[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___21(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___21  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___21  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___21  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___21  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___21  =    100L;
#line 62
static void GetScanLine___21(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___22(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___21(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___21 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___21 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___21;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___22(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___21(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___21(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___22  ;
#line 61
static int SubdivColorMap___22(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___22(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___22(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___22 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___22);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___22];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___22];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___22] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___22] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___22]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___22] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___22] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___22]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___22(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___22] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___22]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___22[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___22[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___22(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___22(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___22(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___22(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___22(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___22(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___22(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___22(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___22(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___22(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___22(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___22(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___22(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___22(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___22(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___22(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___22(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___22(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___22(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___21  ;
#line 141
static int GATestAllSatis___21(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___21(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___21(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___21(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___21(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___21(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___21(int argc , char **argv ) ;
#line 156
static char *MyMalloc___21(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___21  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___21(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___21 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___21 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___21, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___21(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___21((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___21 = LocalToken___21;
#line 264
        *(LocalToken___21 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___21(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___21 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___21 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___21(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___21(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___21(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___21((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___21(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___21 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___21 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___21(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___21((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___21((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___21((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___21((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___21((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___21((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___21((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___21((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___21((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___21((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___21((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___21((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___21(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___21(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___21(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___21(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___22(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___22(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___22(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___22(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___22(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___22(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___22(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___22(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___22(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___22(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___22(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___22(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___22(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___22(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___22[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___22(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___22(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___22[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___22(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___22  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___22  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___22  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___22  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___22  =    100L;
#line 62
static void GetScanLine___22(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___23(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___22(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___22 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___22 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___22;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___23(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static char *VersionStr___21  =    (char *)"RGB2Gif Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:02\n(C) Copyright 1989 Gershon Elber.\n";
#line 64 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static char *CtrlStr___21  =    (char *)"RGB2Gif q%- c%-#Colors!d 1%- s!-Width|Height!d!d h%- RGBFile!*s";
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static int ColorFlag  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static int ExpNumOfColors  =    8;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static int OneFileFlag___0  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static int HelpFlag___4  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static int ColorMapSize___0  =    256;
#line 78
static void LoadRGB(char *FileName , int OneFileFlag___1 , GifByteType **RedBuffer ,
                    GifByteType **GreenBuffer , GifByteType **BlueBuffer , int Width ,
                    int Height ) ;
#line 84
static void SaveGif(GifByteType *OutputBuffer , ColorMapObject *OutputColorMap , int ExpColorMapSize ,
                    int Width , int Height ) ;
#line 87
static void QuitGifError___13(GifFileType *GifFile ) ;
#line 186 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static char *Postfixes___0[3]  = {      (char *)".R",      (char *)".G",      (char *)".B"};
#line 151 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static void LoadRGB(char *FileName , int OneFileFlag___1 , GifByteType **RedBuffer ,
                    GifByteType **GreenBuffer , GifByteType **BlueBuffer , int Width ,
                    int Height ) 
{ 
  int i ;
  int j ;
  unsigned long Size ;
  GifByteType *RedP ;
  GifByteType *GreenP ;
  GifByteType *BlueP ;
  FILE *f[3] ;
  GifByteType *tmp ;
  void *tmp___0 ;
  GifByteType *tmp___1 ;
  void *tmp___2 ;
  GifByteType *tmp___3 ;
  void *tmp___4 ;
  char OneFileName[80] ;
  FILE *tmp___5 ;
  GifByteType *Buffer ;
  GifByteType *BufferP ;
  void *tmp___6 ;
  size_t tmp___7 ;
  GifByteType *tmp___8 ;
  GifByteType *tmp___9 ;
  GifByteType *tmp___10 ;
  GifByteType *tmp___11 ;
  GifByteType *tmp___12 ;
  GifByteType *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;

  {
  {
#line 163
  Size = (unsigned long )((long )Width * (long )Height) * sizeof(GifByteType );
#line 169
  tmp___0 = malloc((size_t )((unsigned int )Size));
#line 169
  tmp = (GifByteType *)tmp___0;
#line 169
  *RedBuffer = tmp;
  }
#line 169
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 172
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "RGB2Gif", "Failed to allocate memory required, aborted.");
#line 172
    exit(-3);
    }
  } else {
    {
#line 169
    tmp___2 = malloc((size_t )((unsigned int )Size));
#line 169
    tmp___1 = (GifByteType *)tmp___2;
#line 169
    *GreenBuffer = tmp___1;
    }
#line 169
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 172
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "RGB2Gif", "Failed to allocate memory required, aborted.");
#line 172
      exit(-3);
      }
    } else {
      {
#line 169
      tmp___4 = malloc((size_t )((unsigned int )Size));
#line 169
      tmp___3 = (GifByteType *)tmp___4;
#line 169
      *BlueBuffer = tmp___3;
      }
#line 169
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
        {
#line 172
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "RGB2Gif", "Failed to allocate memory required, aborted.");
#line 172
        exit(-3);
        }
      }
    }
  }
#line 174
  RedP = *RedBuffer;
#line 175
  GreenP = *GreenBuffer;
#line 176
  BlueP = *BlueBuffer;
#line 178
  if ((unsigned long )FileName != (unsigned long )((void *)0)) {
#line 181
    if (OneFileFlag___1) {
      {
#line 182
      f[0] = fopen((char const   */* __restrict  */)FileName, (char const   */* __restrict  */)"rb");
      }
#line 182
      if ((unsigned long )f[0] == (unsigned long )((void *)0)) {
        {
#line 183
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "RGB2Gif", "Can\'t open input file name.");
#line 183
        exit(-3);
        }
      }
    } else {
#line 188
      i = 0;
      {
#line 188
      while (1) {
        while_continue: /* CIL Label */ ;
#line 188
        if (! (i < 3)) {
#line 188
          goto while_break;
        }
        {
#line 189
        strcpy((char */* __restrict  */)(OneFileName), (char const   */* __restrict  */)FileName);
#line 190
        strcat((char */* __restrict  */)(OneFileName), (char const   */* __restrict  */)Postfixes___0[i]);
#line 192
        tmp___5 = fopen((char const   */* __restrict  */)(OneFileName), (char const   */* __restrict  */)"rb");
#line 192
        f[i] = tmp___5;
        }
#line 192
        if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
          {
#line 193
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                  "RGB2Gif", "Can\'t open input file name.");
#line 193
          exit(-3);
          }
        }
#line 188
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
#line 198
    OneFileFlag___1 = 1;
#line 204
    f[0] = stdin;
  }
  {
#line 207
  GifQprintf((char *)"\n%s: RGB image:     ", "RGB2Gif");
  }
#line 209
  if (OneFileFlag___1) {
    {
#line 212
    tmp___6 = malloc((size_t )(Width * 3));
#line 212
    Buffer = (GifByteType *)tmp___6;
    }
#line 212
    if ((unsigned long )Buffer == (unsigned long )((void *)0)) {
      {
#line 213
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "RGB2Gif", "Failed to allocate memory required, aborted.");
#line 213
      exit(-3);
      }
    }
#line 215
    i = 0;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (! (i < Height)) {
#line 215
        goto while_break___0;
      }
      {
#line 216
      GifQprintf((char *)"\b\b\b\b%-4d", i);
#line 217
      tmp___7 = fread((void */* __restrict  */)Buffer, (size_t )(Width * 3), (size_t )1,
                      (FILE */* __restrict  */)f[0]);
      }
#line 217
      if (tmp___7 != 1UL) {
        {
#line 218
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "RGB2Gif", "Input file(s) terminated prematurly.");
#line 218
        exit(-3);
        }
      }
#line 219
      j = 0;
#line 219
      BufferP = Buffer;
      {
#line 219
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 219
        if (! (j < Width)) {
#line 219
          goto while_break___1;
        }
#line 220
        tmp___8 = RedP;
#line 220
        RedP ++;
#line 220
        tmp___9 = BufferP;
#line 220
        BufferP ++;
#line 220
        *tmp___8 = *tmp___9;
#line 221
        tmp___10 = GreenP;
#line 221
        GreenP ++;
#line 221
        tmp___11 = BufferP;
#line 221
        BufferP ++;
#line 221
        *tmp___10 = *tmp___11;
#line 222
        tmp___12 = BlueP;
#line 222
        BlueP ++;
#line 222
        tmp___13 = BufferP;
#line 222
        BufferP ++;
#line 222
        *tmp___12 = *tmp___13;
#line 219
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 215
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 226
    free((void *)((char *)Buffer));
#line 227
    fclose(f[0]);
    }
  } else {
#line 230
    i = 0;
    {
#line 230
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 230
      if (! (i < Height)) {
#line 230
        goto while_break___2;
      }
      {
#line 231
      GifQprintf((char *)"\b\b\b\b%-4d", i);
#line 232
      tmp___14 = fread((void */* __restrict  */)RedP, (size_t )Width, (size_t )1,
                       (FILE */* __restrict  */)f[0]);
      }
#line 232
      if (tmp___14 != 1UL) {
        {
#line 235
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "RGB2Gif", "Input file(s) terminated prematurly.");
#line 235
        exit(-3);
        }
      } else {
        {
#line 232
        tmp___15 = fread((void */* __restrict  */)GreenP, (size_t )Width, (size_t )1,
                         (FILE */* __restrict  */)f[1]);
        }
#line 232
        if (tmp___15 != 1UL) {
          {
#line 235
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                  "RGB2Gif", "Input file(s) terminated prematurly.");
#line 235
          exit(-3);
          }
        } else {
          {
#line 232
          tmp___16 = fread((void */* __restrict  */)BlueP, (size_t )Width, (size_t )1,
                           (FILE */* __restrict  */)f[2]);
          }
#line 232
          if (tmp___16 != 1UL) {
            {
#line 235
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                    "RGB2Gif", "Input file(s) terminated prematurly.");
#line 235
            exit(-3);
            }
          }
        }
      }
#line 236
      RedP += Width;
#line 237
      GreenP += Width;
#line 238
      BlueP += Width;
#line 230
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 241
    fclose(f[0]);
#line 242
    fclose(f[1]);
#line 243
    fclose(f[2]);
    }
  }
#line 245
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static void SaveGif(GifByteType *OutputBuffer , ColorMapObject *OutputColorMap , int ExpColorMapSize ,
                    int Width , int Height ) 
{ 
  int i ;
  GifFileType *GifFile ;
  GifByteType *Ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 256
  Ptr = OutputBuffer;
#line 259
  GifFile = EGifOpenFileHandle(1);
  }
#line 259
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
    {
#line 260
    QuitGifError___13(GifFile);
    }
  }
  {
#line 262
  tmp = EGifPutScreenDesc(GifFile, Width, Height, ExpColorMapSize, 0, (ColorMapObject const   *)OutputColorMap);
  }
#line 262
  if (tmp == 0) {
    {
#line 268
    QuitGifError___13(GifFile);
    }
  } else {
    {
#line 262
    tmp___0 = EGifPutImageDesc(GifFile, 0, 0, Width, Height, 0, (ColorMapObject const   *)((void *)0));
    }
#line 262
    if (tmp___0 == 0) {
      {
#line 268
      QuitGifError___13(GifFile);
      }
    }
  }
  {
#line 270
  GifQprintf((char *)"\n%s: Image 1 at (%d, %d) [%dx%d]:     ", "RGB2Gif", GifFile->Image.Left,
             GifFile->Image.Top, GifFile->Image.Width, GifFile->Image.Height);
#line 274
  i = 0;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < Height)) {
#line 274
      goto while_break;
    }
    {
#line 275
    tmp___1 = EGifPutLine(GifFile, Ptr, Width);
    }
#line 275
    if (tmp___1 == 0) {
      {
#line 276
      QuitGifError___13(GifFile);
      }
    }
    {
#line 277
    GifQprintf((char *)"\b\b\b\b%-4d", (Height - i) - 1);
#line 279
    Ptr += Width;
#line 274
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  tmp___2 = EGifCloseFile(GifFile);
  }
#line 282
  if (tmp___2 == 0) {
    {
#line 283
    QuitGifError___13(GifFile);
    }
  }
#line 284
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/rgb2gif.c"
static void QuitGifError___13(GifFileType *GifFile ) 
{ 


  {
  {
#line 291
  PrintGifError();
  }
#line 292
  if ((unsigned long )GifFile != (unsigned long )((void *)0)) {
    {
#line 292
    EGifCloseFile(GifFile);
    }
  }
  {
#line 293
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___22(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___22(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___23  ;
#line 61
static int SubdivColorMap___23(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___23(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___23(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___23 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___23);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___23];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___23];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___23] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___23] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___23]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___23] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___23] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___23]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___23(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___23] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___23]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___23[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___23[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___23(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___23(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___23(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___23(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___23(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___23(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___23(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___23(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___23(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___23(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___23(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___23(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___23(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___23(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___23(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___23(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___23(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___23(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___23(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___22  ;
#line 141
static int GATestAllSatis___22(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___22(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___22(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___22(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___22(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___22(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___22(int argc , char **argv ) ;
#line 156
static char *MyMalloc___22(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___22  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___22(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___22 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___22 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___22, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___22(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___22((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___22 = LocalToken___22;
#line 264
        *(LocalToken___22 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___22(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___22 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___22 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___22(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___22(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___22(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___22((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___22(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___22 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___22 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___22(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___22((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___22((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___22((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___22((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___22((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___22((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___22((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___22((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___22((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___22((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___22((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___22((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___22(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___22(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___22(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___22(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static char *VersionStr___22  =    (char *)"GifInter Version 4.1, \tGershon Elber,\tMar  3 2016,   19:57:58\n(C) Copyright 1989 Gershon Elber.\n";
#line 57 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static char *CtrlStr___22  =    (char *)"GifInter q%- i%- s%- h%- GifFile!*s";
#line 64 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static int ImageNum___4  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static int SequencialFlag  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static int InterlacedFlag  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static int HelpFlag___5  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static int InterlacedOffset___4[4]  = {      0,      4,      2,      1};
#line 64 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static int InterlacedJumps___4[4]  = {      8,      8,      4,      2};
#line 72
static int LoadImage___0(GifFileType *GifFile , GifRowType **ImageBufferPtr ) ;
#line 73
static int DumpImage___0(GifFileType *GifFile , GifRowType *ImageBuffer ) ;
#line 74
static void QuitGifError___14(GifFileType *GifFileIn , GifFileType *GifFileOut ) ;
#line 188 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static int LoadImage___0(GifFileType *GifFile , GifRowType **ImageBufferPtr ) 
{ 
  int Size ;
  int i ;
  int j ;
  int Count ;
  GifRowType *ImageBuffer ;
  void *tmp ;
  GifRowType tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 196
  tmp = malloc((unsigned long )GifFile->Image.Height * sizeof(GifRowType *));
#line 196
  ImageBuffer = (GifRowType *)tmp;
  }
#line 196
  if ((unsigned long )ImageBuffer == (unsigned long )((void *)0)) {
    {
#line 198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "GifInter", "Failed to allocate memory required, aborted.");
#line 198
    exit(-3);
    }
  }
#line 200
  Size = (int )((unsigned long )GifFile->Image.Width * sizeof(GifPixelType ));
#line 201
  i = 0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i < GifFile->Image.Height)) {
#line 201
      goto while_break;
    }
    {
#line 203
    tmp___1 = malloc((size_t )Size);
#line 203
    tmp___0 = (GifRowType )tmp___1;
#line 203
    *(ImageBuffer + i) = tmp___0;
    }
#line 203
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 204
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "GifInter", "Failed to allocate memory required, aborted.");
#line 204
      exit(-3);
      }
    }
#line 201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  *ImageBufferPtr = ImageBuffer;
#line 209
  ImageNum___4 ++;
#line 209
  GifQprintf((char *)"\n%s: Image %d at (%d, %d) [%dx%d]:     ", "GifInter", ImageNum___4,
             GifFile->Image.Left, GifFile->Image.Top, GifFile->Image.Width, GifFile->Image.Height);
  }
#line 212
  if (GifFile->Image.Interlace) {
#line 214
    i = 0;
#line 214
    Count = i;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! (i < 4)) {
#line 214
        goto while_break___0;
      }
#line 215
      j = InterlacedOffset___4[i];
      {
#line 215
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 215
        if (! (j < GifFile->Image.Height)) {
#line 215
          goto while_break___1;
        }
        {
#line 217
        tmp___2 = Count;
#line 217
        Count ++;
#line 217
        GifQprintf((char *)"\b\b\b\b%-4d", tmp___2);
#line 218
        tmp___3 = DGifGetLine(GifFile, *(ImageBuffer + j), GifFile->Image.Width);
        }
#line 218
        if (tmp___3 == 0) {
#line 219
          return (0);
        }
#line 215
        j += InterlacedJumps___4[i];
      }
      while_break___1: /* CIL Label */ ;
      }
#line 214
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 223
    i = 0;
    {
#line 223
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 223
      if (! (i < GifFile->Image.Height)) {
#line 223
        goto while_break___2;
      }
      {
#line 224
      GifQprintf((char *)"\b\b\b\b%-4d", i);
#line 225
      tmp___4 = DGifGetLine(GifFile, *(ImageBuffer + i), GifFile->Image.Width);
      }
#line 225
      if (tmp___4 == 0) {
#line 226
        return (0);
      }
#line 223
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 230
  return (1);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static int DumpImage___0(GifFileType *GifFile , GifRowType *ImageBuffer ) 
{ 
  int i ;
  int j ;
  int Count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 243
  if (GifFile->Image.Interlace) {
#line 245
    Count = GifFile->Image.Height;
#line 245
    i = 0;
    {
#line 245
    while (1) {
      while_continue: /* CIL Label */ ;
#line 245
      if (! (i < 4)) {
#line 245
        goto while_break;
      }
#line 246
      j = InterlacedOffset___4[i];
      {
#line 246
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 246
        if (! (j < GifFile->Image.Height)) {
#line 246
          goto while_break___0;
        }
        {
#line 248
        tmp = Count;
#line 248
        Count --;
#line 248
        GifQprintf((char *)"\b\b\b\b%-4d", tmp);
#line 249
        tmp___0 = EGifPutLine(GifFile, *(ImageBuffer + j), GifFile->Image.Width);
        }
#line 249
        if (tmp___0 == 0) {
#line 250
          return (0);
        }
#line 246
        j += InterlacedJumps___4[i];
      }
      while_break___0: /* CIL Label */ ;
      }
#line 245
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 254
    Count = GifFile->Image.Height;
#line 254
    i = 0;
    {
#line 254
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 254
      if (! (i < GifFile->Image.Height)) {
#line 254
        goto while_break___1;
      }
      {
#line 255
      tmp___1 = Count;
#line 255
      Count --;
#line 255
      GifQprintf((char *)"\b\b\b\b%-4d", tmp___1);
#line 256
      tmp___2 = EGifPutLine(GifFile, *(ImageBuffer + i), GifFile->Image.Width);
      }
#line 256
      if (tmp___2 == 0) {
#line 257
        return (0);
      }
#line 254
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 262
    if (! (i < GifFile->Image.Height)) {
#line 262
      goto while_break___2;
    }
    {
#line 262
    free((void *)((char *)*(ImageBuffer + i)));
#line 262
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 263
  free((void *)((char *)ImageBuffer));
  }
#line 265
  return (1);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifinter.c"
static void QuitGifError___14(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 273
  PrintGifError();
  }
#line 274
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 274
    DGifCloseFile(GifFileIn);
    }
  }
#line 275
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 275
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 276
  exit(1);
  }
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___23(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___23(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___23(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___23(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___23(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___23(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___23(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___23(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___23(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___23(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___23(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___23(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___23(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___23(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___23[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___23(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___23(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___23[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___23(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___23  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___23  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___23  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___23  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___23  =    100L;
#line 62
static void GetScanLine___23(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___24(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___23(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___23 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___23 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___23;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___24(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___23(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___23(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___24  ;
#line 61
static int SubdivColorMap___24(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___24(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___24(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___24 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___24);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___24];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___24];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___24] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___24] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___24]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___24] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___24] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___24]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___24(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___24] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___24]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___24[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___24[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___24(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___24(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___24(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___24(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___24(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___24(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___24(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___24(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___24(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___24(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___24(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___24(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___24(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___24(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___24(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___24(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___24(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___24(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___24(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___23  ;
#line 141
static int GATestAllSatis___23(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___23(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___23(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___23(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___23(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___23(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___23(int argc , char **argv ) ;
#line 156
static char *MyMalloc___23(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___23  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___23(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___23 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___23 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___23, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___23(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___23((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___23 = LocalToken___23;
#line 264
        *(LocalToken___23 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___23(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___23 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___23 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___23(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___23(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___23(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___23((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___23(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___23 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___23 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___23(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___23((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___23((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___23((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___23((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___23((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___23((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___23((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___23((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___23((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___23((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___23((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___23((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___23(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___23(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___23(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___23(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___24(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___24(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___24(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___24(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___24(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___24(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___24(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___24(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___24(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___24(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___24(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___24(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___24(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___24(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___24[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___24(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___24(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___24[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___24(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___24  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___24  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___24  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___24  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___24  =    100L;
#line 62
static void GetScanLine___24(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___25(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___24(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___24 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___24 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___24;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___25(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___24(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___24(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___25  ;
#line 61
static int SubdivColorMap___25(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___25(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___25(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___25 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___25);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___25];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___25];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___25] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___25] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___25]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___25] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___25] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___25]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___25(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___25] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___25]);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/giffiltr.c"
static void QuitGifError___15(GifFileType *GifFileIn , GifFileType *GifFileOut ) 
{ 


  {
  {
#line 51
  PrintGifError();
  }
#line 52
  if ((unsigned long )GifFileIn != (unsigned long )((void *)0)) {
    {
#line 52
    DGifCloseFile(GifFileIn);
    }
  }
#line 53
  if ((unsigned long )GifFileOut != (unsigned long )((void *)0)) {
    {
#line 53
    EGifCloseFile(GifFileOut);
    }
  }
  {
#line 54
  exit(1);
  }
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___25[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___25[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___25(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___25(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___25(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___25(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___25(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___25(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___25(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___25(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___25(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___25(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___25(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___25(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___25(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___25(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___25(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___25(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___25(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___25(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___25(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___24  ;
#line 141
static int GATestAllSatis___24(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___24(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___24(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___24(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___24(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___24(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___24(int argc , char **argv ) ;
#line 156
static char *MyMalloc___24(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___24  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___24(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___24 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___24 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___24, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___24(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___24((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___24 = LocalToken___24;
#line 264
        *(LocalToken___24 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___24(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___24 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___24 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___24(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___24(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___24(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___24((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___24(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___24 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___24 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___24(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___24((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___24((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___24((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___24((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___24((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___24((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___24((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___24((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___24((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___24((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___24((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___24((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___24(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___24(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___24(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___24(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___25(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___25(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___25(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___25(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___25(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___25(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___25(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___25(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___25(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___25(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___25(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___25(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___25(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___25(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___25[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___25(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___25(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___25[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___25(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___25  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___25  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___25  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___25  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___25  =    100L;
#line 62
static void GetScanLine___25(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___26(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___25(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___25 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___25 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___25;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___26(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___25(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___25(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___26  ;
#line 61
static int SubdivColorMap___26(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___26(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___26(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___26 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___26);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___26];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___26];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___26] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___26] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___26]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___26] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___26] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___26]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___26(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___26] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___26]);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifwedge.c"
static char *VersionStr___23  =    (char *)"GifWedge Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:01\n(C) Copyright 1989 Gershon Elber.\n";
#line 63 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifwedge.c"
static char *CtrlStr___23  =    (char *)"GifWedge q%- l%-#Lvls!d s%-Width|Height!d!d h%-";
#line 69 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifwedge.c"
static int NumLevels___0  =    16;
#line 69 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifwedge.c"
static int ImageWidth___1  =    640;
#line 69 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifwedge.c"
static int ImageHeight___1  =    350;
#line 74
static void QuitGifError___16(GifFileType *GifFile ) ;
#line 171 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/gifwedge.c"
static void QuitGifError___16(GifFileType *GifFile ) 
{ 


  {
  {
#line 173
  PrintGifError();
  }
#line 174
  if ((unsigned long )GifFile != (unsigned long )((void *)0)) {
    {
#line 174
    DGifCloseFile(GifFile);
    }
  }
  {
#line 175
  exit(1);
  }
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___26[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___26[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___26(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___26(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___26(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___26(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___26(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___26(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___26(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___26(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___26(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___26(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___26(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___26(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___26(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___26(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___26(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___26(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___26(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___26(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___26(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___25  ;
#line 141
static int GATestAllSatis___25(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___25(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___25(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___25(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___25(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___25(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___25(int argc , char **argv ) ;
#line 156
static char *MyMalloc___25(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___25  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___25(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___25 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___25 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___25, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___25(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___25((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___25 = LocalToken___25;
#line 264
        *(LocalToken___25 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___25(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___25 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___25 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___25(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___25(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___25(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___25((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___25(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___25 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___25 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___25(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___25((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___25((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___25((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___25((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___25((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___25((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___25((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___25((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___25((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___25((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___25((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___25((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___25(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___25(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___25(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___25(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___26(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___26(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___26(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___26(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___26(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___26(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___26(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___26(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___26(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___26(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___26(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___26(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___26(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___26(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___26[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___26(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___26(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___26[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___26(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___26  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___26  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___26  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___26  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___26  =    100L;
#line 62
static void GetScanLine___26(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___27(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___26(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___26 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___26 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___26;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___27(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___26(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___26(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortRGBAxis___27  ;
#line 61
static int SubdivColorMap___27(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) ;
#line 64
static int SortCmpRtn___27(void const   *Entry1 , void const   *Entry2 ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SubdivColorMap___27(NewColorMapType *NewColorSubdiv , unsigned int ColorMapSize___1 ,
                               unsigned int *NewColorMapSize ) 
{ 
  int MaxSize ;
  unsigned int i ;
  unsigned int j ;
  unsigned int Index ;
  unsigned int NumEntries ;
  unsigned int MinColor ;
  unsigned int MaxColor ;
  long Sum ;
  long Count ;
  QuantizedColorType *QuantizedColor ;
  QuantizedColorType **SortArray ;
  void *tmp ;

  {
#line 226
  Index = 0U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (ColorMapSize___1 > *NewColorMapSize)) {
#line 230
      goto while_break;
    }
#line 232
    MaxSize = -1;
#line 233
    i = 0U;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < *NewColorMapSize)) {
#line 233
        goto while_break___0;
      }
#line 234
      j = 0U;
      {
#line 234
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 234
        if (! (j < 3U)) {
#line 234
          goto while_break___1;
        }
#line 235
        if ((int )(NewColorSubdiv + i)->RGBWidth[j] > MaxSize) {
#line 235
          if ((NewColorSubdiv + i)->NumEntries > 1U) {
#line 237
            MaxSize = (int )(NewColorSubdiv + i)->RGBWidth[j];
#line 238
            Index = i;
#line 239
            SortRGBAxis___27 = (int )j;
          }
        }
#line 234
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (MaxSize == -1) {
#line 245
      return (1);
    }
    {
#line 251
    tmp = malloc(sizeof(QuantizedColorType *) * (unsigned long )(NewColorSubdiv + Index)->NumEntries);
#line 251
    SortArray = (QuantizedColorType **)tmp;
    }
#line 254
    if ((unsigned long )SortArray == (unsigned long )((void *)0)) {
#line 255
      return (0);
    }
#line 256
    j = 0U;
#line 256
    QuantizedColor = (NewColorSubdiv + Index)->QuantizedColors;
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (j < (NewColorSubdiv + Index)->NumEntries) {
#line 256
        if (! ((unsigned long )QuantizedColor != (unsigned long )((void *)0))) {
#line 256
          goto while_break___2;
        }
      } else {
#line 256
        goto while_break___2;
      }
#line 259
      *(SortArray + j) = QuantizedColor;
#line 256
      j ++;
#line 256
      QuantizedColor = QuantizedColor->Pnext;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 261
    qsort((void *)SortArray, (size_t )(NewColorSubdiv + Index)->NumEntries, sizeof(QuantizedColorType *),
          & SortCmpRtn___27);
#line 265
    j = 0U;
    }
    {
#line 265
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 265
      if (! (j < (NewColorSubdiv + Index)->NumEntries - 1U)) {
#line 265
        goto while_break___3;
      }
#line 266
      (*(SortArray + j))->Pnext = *(SortArray + (j + 1U));
#line 265
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 267
    (*(SortArray + ((NewColorSubdiv + Index)->NumEntries - 1U)))->Pnext = (struct QuantizedColorType *)((void *)0);
#line 268
    QuantizedColor = *(SortArray + 0);
#line 268
    (NewColorSubdiv + Index)->QuantizedColors = QuantizedColor;
#line 269
    free((void *)((char *)SortArray));
#line 272
    Sum = (long )((NewColorSubdiv + Index)->Count / 2UL - (unsigned long )QuantizedColor->Count);
#line 273
    NumEntries = 1U;
#line 274
    Count = QuantizedColor->Count;
    }
    {
#line 275
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 275
      Sum -= (QuantizedColor->Pnext)->Count;
#line 275
      if (Sum >= 0L) {
#line 275
        if ((unsigned long )QuantizedColor->Pnext != (unsigned long )((void *)0)) {
#line 275
          if (! ((unsigned long )(QuantizedColor->Pnext)->Pnext != (unsigned long )((void *)0))) {
#line 275
            goto while_break___4;
          }
        } else {
#line 275
          goto while_break___4;
        }
      } else {
#line 275
        goto while_break___4;
      }
#line 278
      QuantizedColor = QuantizedColor->Pnext;
#line 279
      NumEntries ++;
#line 280
      Count += QuantizedColor->Count;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 287
    MaxColor = (unsigned int )QuantizedColor->RGB[SortRGBAxis___27];
#line 288
    MinColor = (unsigned int )(QuantizedColor->Pnext)->RGB[SortRGBAxis___27];
#line 289
    MaxColor <<= 3;
#line 290
    MinColor <<= 3;
#line 293
    (NewColorSubdiv + *NewColorMapSize)->QuantizedColors = QuantizedColor->Pnext;
#line 295
    QuantizedColor->Pnext = (struct QuantizedColorType *)((void *)0);
#line 296
    (NewColorSubdiv + *NewColorMapSize)->Count = (unsigned long )Count;
#line 297
    (NewColorSubdiv + Index)->Count -= (unsigned long )Count;
#line 298
    (NewColorSubdiv + *NewColorMapSize)->NumEntries = (NewColorSubdiv + Index)->NumEntries - NumEntries;
#line 300
    (NewColorSubdiv + Index)->NumEntries = NumEntries;
#line 301
    j = 0U;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (j < 3U)) {
#line 301
        goto while_break___5;
      }
#line 302
      (NewColorSubdiv + *NewColorMapSize)->RGBMin[j] = (NewColorSubdiv + Index)->RGBMin[j];
#line 304
      (NewColorSubdiv + *NewColorMapSize)->RGBWidth[j] = (NewColorSubdiv + Index)->RGBWidth[j];
#line 301
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 307
    (NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___27] = (GifByteType )((unsigned int )((int )(NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___27] + (int )(NewColorSubdiv + *NewColorMapSize)->RGBWidth[SortRGBAxis___27]) - MinColor);
#line 310
    (NewColorSubdiv + *NewColorMapSize)->RGBMin[SortRGBAxis___27] = (GifByteType )MinColor;
#line 312
    (NewColorSubdiv + Index)->RGBWidth[SortRGBAxis___27] = (GifByteType )(MaxColor - (unsigned int )(NewColorSubdiv + Index)->RGBMin[SortRGBAxis___27]);
#line 315
    (*NewColorMapSize) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (1);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/quantize.c"
static int SortCmpRtn___27(void const   *Entry1 , void const   *Entry2 ) 
{ 


  {
#line 328
  return ((int )(*((QuantizedColorType **)Entry1))->RGB[SortRGBAxis___27] - (int )(*((QuantizedColorType **)Entry2))->RGB[SortRGBAxis___27]);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static GifPixelType CodeMask___27[9]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
  {      (GifPixelType )0,      (GifPixelType )1,      (GifPixelType )3,      (GifPixelType )7, 
        (GifPixelType )15,      (GifPixelType )31,      (GifPixelType )63,      (GifPixelType )127, 
        (GifPixelType )255};
#line 71 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static char GifVersionPrefix___27[(sizeof("GIFVER") - 1UL) + 1UL]  = {      (char )'G',      (char )'I',      (char )'F',      (char )'8', 
        (char )'7',      (char )'a',      (char )'\000'};
#line 78
static int EGifPutWord___27(int Word , GifFileType *GifFile ) ;
#line 79
static int EGifSetupCompress___27(GifFileType *GifFile ) ;
#line 80
static int EGifCompressLine___27(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 82
static int EGifCompressOutput___27(GifFileType *GifFile , int Code ) ;
#line 83
static int EGifBufferedOutput___27(GifFileType *GifFile , GifByteType *Buf , int c ) ;
#line 770 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifPutWord___27(int Word , GifFileType *GifFile ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 776
  c[0] = (unsigned char )(Word & 255);
#line 777
  c[1] = (unsigned char )((Word >> 8) & 255);
#line 779
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 779
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(c),
                                                               2);
#line 779
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 779
    tmp___0 = fwrite((void const   */* __restrict  */)(c), (size_t )1, (size_t )2,
                     (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 779
    tmp___1 = tmp___0;
    }
  }
#line 779
  if (tmp___1 == 2UL) {
#line 780
    return (1);
  } else {
#line 782
    return (0);
  }
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifSetupCompress___27(GifFileType *GifFile ) 
{ 
  int BitsPerPixel ;
  GifByteType Buf ;
  GifFilePrivateType *Private ;
  int tmp ;

  {
#line 796
  Private = (GifFilePrivateType *)GifFile->Private;
#line 799
  if (GifFile->Image.ColorMap) {
#line 800
    BitsPerPixel = (GifFile->Image.ColorMap)->BitsPerPixel;
  } else
#line 801
  if (GifFile->SColorMap) {
#line 802
    BitsPerPixel = (GifFile->SColorMap)->BitsPerPixel;
  } else {
#line 804
    _GifError = 5;
#line 805
    return (0);
  }
#line 808
  if (BitsPerPixel < 2) {
#line 808
    BitsPerPixel = 2;
  } else {
#line 808
    BitsPerPixel = BitsPerPixel;
  }
#line 808
  Buf = (GifByteType )BitsPerPixel;
#line 809
  if (((GifFilePrivateType *)GifFile->Private)->Write) {
    {
#line 809
    (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)(& Buf),
                                                         1);
    }
  } else {
    {
#line 809
    fwrite((void const   */* __restrict  */)(& Buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
  {
#line 811
  Private->Buf[0] = (GifByteType )0;
#line 812
  Private->BitsPerPixel = BitsPerPixel;
#line 813
  Private->ClearCode = 1 << BitsPerPixel;
#line 814
  Private->EOFCode = Private->ClearCode + 1;
#line 815
  Private->RunningCode = Private->EOFCode + 1;
#line 816
  Private->RunningBits = BitsPerPixel + 1;
#line 817
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 818
  Private->CrntCode = 4097;
#line 819
  Private->CrntShiftState = 0;
#line 820
  Private->CrntShiftDWord = 0UL;
#line 823
  _ClearHashTable(Private->HashTable);
#line 825
  tmp = EGifCompressOutput___27(GifFile, Private->ClearCode);
  }
#line 825
  if (tmp == 0) {
#line 826
    _GifError = 8;
#line 827
    return (0);
  }
#line 829
  return (1);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressLine___27(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int CrntCode ;
  int NewCode ;
  unsigned long NewKey ;
  GifPixelType Pixel ;
  GifHashTableType *HashTable ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GifWord tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 843
  i = 0;
#line 847
  Private = (GifFilePrivateType *)GifFile->Private;
#line 849
  HashTable = Private->HashTable;
#line 851
  if (Private->CrntCode == 4097) {
#line 852
    tmp = i;
#line 852
    i ++;
#line 852
    CrntCode = (int )*(Line + tmp);
  } else {
#line 854
    CrntCode = Private->CrntCode;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < LineLen)) {
#line 856
      goto while_break;
    }
    {
#line 857
    tmp___0 = i;
#line 857
    i ++;
#line 857
    Pixel = *(Line + tmp___0);
#line 861
    NewKey = (unsigned long )(((u_int32_t )CrntCode << 8) + (u_int32_t )Pixel);
#line 862
    NewCode = _ExistsHashTable(HashTable, (u_int32_t )NewKey);
    }
#line 862
    if (NewCode >= 0) {
#line 866
      CrntCode = NewCode;
    } else {
      {
#line 871
      tmp___1 = EGifCompressOutput___27(GifFile, CrntCode);
      }
#line 871
      if (tmp___1 == 0) {
#line 872
        _GifError = 8;
#line 873
        return (0);
      }
#line 875
      CrntCode = (int )Pixel;
#line 880
      if (Private->RunningCode >= 4095) {
        {
#line 882
        tmp___2 = EGifCompressOutput___27(GifFile, Private->ClearCode);
        }
#line 882
        if (tmp___2 == 0) {
#line 884
          _GifError = 8;
#line 885
          return (0);
        }
        {
#line 887
        Private->RunningCode = Private->EOFCode + 1;
#line 888
        Private->RunningBits = Private->BitsPerPixel + 1;
#line 889
        Private->MaxCode1 = 1 << Private->RunningBits;
#line 890
        _ClearHashTable(HashTable);
        }
      } else {
        {
#line 893
        tmp___3 = Private->RunningCode;
#line 893
        (Private->RunningCode) ++;
#line 893
        _InsertHashTable(HashTable, (u_int32_t )NewKey, tmp___3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  Private->CrntCode = CrntCode;
#line 902
  if (Private->PixelCount == 0UL) {
    {
#line 904
    tmp___4 = EGifCompressOutput___27(GifFile, CrntCode);
    }
#line 904
    if (tmp___4 == 0) {
#line 905
      _GifError = 8;
#line 906
      return (0);
    }
    {
#line 908
    tmp___5 = EGifCompressOutput___27(GifFile, Private->EOFCode);
    }
#line 908
    if (tmp___5 == 0) {
#line 909
      _GifError = 8;
#line 910
      return (0);
    }
    {
#line 912
    tmp___6 = EGifCompressOutput___27(GifFile, 4096);
    }
#line 912
    if (tmp___6 == 0) {
#line 913
      _GifError = 8;
#line 914
      return (0);
    }
  }
#line 918
  return (1);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifCompressOutput___27(GifFileType *GifFile , int Code ) 
{ 
  GifFilePrivateType *Private ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  Private = (GifFilePrivateType *)GifFile->Private;
#line 932
  retval = 1;
#line 934
  if (Code == 4096) {
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (Private->CrntShiftState > 0)) {
#line 935
        goto while_break;
      }
      {
#line 937
      tmp = EGifBufferedOutput___27(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 937
      if (tmp == 0) {
#line 939
        retval = 0;
      }
#line 940
      Private->CrntShiftDWord >>= 8;
#line 941
      Private->CrntShiftState -= 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 943
    Private->CrntShiftState = 0;
#line 944
    tmp___0 = EGifBufferedOutput___27(GifFile, Private->Buf, 4096);
    }
#line 944
    if (tmp___0 == 0) {
#line 946
      retval = 0;
    }
  } else {
#line 948
    Private->CrntShiftDWord |= (unsigned long )((long )Code << Private->CrntShiftState);
#line 949
    Private->CrntShiftState += Private->RunningBits;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (Private->CrntShiftState >= 8)) {
#line 950
        goto while_break___0;
      }
      {
#line 952
      tmp___1 = EGifBufferedOutput___27(GifFile, Private->Buf, (int )(Private->CrntShiftDWord & 255UL));
      }
#line 952
      if (tmp___1 == 0) {
#line 954
        retval = 0;
      }
#line 955
      Private->CrntShiftDWord >>= 8;
#line 956
      Private->CrntShiftState -= 8;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 962
  if (Private->RunningCode >= Private->MaxCode1) {
#line 962
    if (Code <= 4095) {
#line 963
      (Private->RunningBits) ++;
#line 963
      Private->MaxCode1 = 1 << Private->RunningBits;
    }
  }
#line 966
  return (retval);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/egif_lib.c"
static int EGifBufferedOutput___27(GifFileType *GifFile , GifByteType *Buf , int c ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 980
  if (c == 4096) {
#line 982
    if ((int )*(Buf + 0) != 0) {
#line 982
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 982
        tmp = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                   (int )*(Buf + 0) + 1);
#line 982
        tmp___1 = (size_t )tmp;
        }
      } else {
        {
#line 982
        tmp___0 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 982
        tmp___1 = tmp___0;
        }
      }
#line 982
      if (tmp___1 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 984
        _GifError = 2;
#line 985
        return (0);
      }
    }
#line 988
    *(Buf + 0) = (GifByteType )0;
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Write) {
      {
#line 989
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                     1);
#line 989
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 989
      tmp___3 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )1,
                       (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___4 = tmp___3;
      }
    }
#line 989
    if (tmp___4 != 1UL) {
#line 990
      _GifError = 2;
#line 991
      return (0);
    }
  } else {
#line 994
    if ((int )*(Buf + 0) == 255) {
#line 996
      if (((GifFilePrivateType *)GifFile->Private)->Write) {
        {
#line 996
        tmp___5 = (*(((GifFilePrivateType *)GifFile->Private)->Write))(GifFile, (GifByteType const   *)Buf,
                                                                       (int )*(Buf + 0) + 1);
#line 996
        tmp___7 = (size_t )tmp___5;
        }
      } else {
        {
#line 996
        tmp___6 = fwrite((void const   */* __restrict  */)Buf, (size_t )1, (size_t )((int )*(Buf + 0) + 1),
                         (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 996
        tmp___7 = tmp___6;
        }
      }
#line 996
      if (tmp___7 != (size_t )((unsigned int )((int )*(Buf + 0) + 1))) {
#line 997
        _GifError = 2;
#line 998
        return (0);
      }
#line 1000
      *(Buf + 0) = (GifByteType )0;
    }
#line 1002
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) + 1);
#line 1002
    *(Buf + *(Buf + 0)) = (GifByteType )c;
  }
#line 1005
  return (1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *GAErrorToken___26  ;
#line 141
static int GATestAllSatis___26(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) ;
#line 144
static int GAUpdateParameters___26(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) ;
#line 147
static int GAGetParmeters___26(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) ;
#line 150
static int GAGetMultiParmeters___26(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) ;
#line 152
static void GASetParamCount___26(char *CtrlStr___25 , int Max , int *ParamCount ) ;
#line 153
static void GAByteCopy___26(char *Dst , char *Src , unsigned int n ) ;
#line 154
static int GAOptionExists___26(int argc , char **argv ) ;
#line 156
static char *MyMalloc___26(unsigned int size ) ;
#line 239 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *LocalToken___26  =    (char *)((void *)0);
#line 230 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GATestAllSatis___26(char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                               char ***argv , int **Parameters , int *ParamCount ) 
{ 
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 244
  if ((unsigned long )LocalToken___26 == (unsigned long )((void *)0)) {
    {
#line 245
    tmp = malloc((size_t )3);
#line 245
    LocalToken___26 = (char *)tmp;
#line 246
    strcpy((char */* __restrict  */)LocalToken___26, (char const   */* __restrict  */)"-?");
    }
  }
  {
#line 252
  tmp___0 = strlen((char const   *)CtrlStr___25);
#line 252
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (i > 0) {
#line 252
      if (! (! ((int )*(CtrlStr___25 + i) <= 32))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (! ((int )*(CtrlStr___25 + (i + 2)) == 37)) {
#line 253
    if (! ((int )*(CtrlStr___25 + (i + 2)) == 33)) {
      {
#line 254
      GASetParamCount___26(CtrlStr___25, i, ParamCount);
#line 255
      tmp___1 = *ParamCount;
#line 255
      (*ParamCount) ++;
#line 255
      *(*(Parameters + tmp___1)) = *argc;
#line 256
      tmp___2 = *ParamCount;
#line 256
      (*ParamCount) ++;
#line 256
      GAByteCopy___26((char *)*(Parameters + tmp___2), (char *)argv, (unsigned int )sizeof(char *));
      }
    }
  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 261
    i ++;
#line 261
    tmp___3 = strlen((char const   *)CtrlStrCopy);
    }
#line 261
    if (! (i < (int )tmp___3)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((int )*(CtrlStrCopy + i) == 45) {
#line 262
      if ((int )*(CtrlStrCopy + (i - 1)) == 33) {
#line 263
        GAErrorToken___26 = LocalToken___26;
#line 264
        *(LocalToken___26 + 1) = *(CtrlStrCopy + (i - 2));
#line 265
        return (5);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAUpdateParameters___26(int **Parameters , int *ParamCount , char *Option ,
                                   char *CtrlStrCopy , char *CtrlStr___25 , int *argc ,
                                   char ***argv ) 
{ 
  int i ;
  int BooleanTrue ;
  size_t tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 283
  BooleanTrue = (int )*(Option + 2) != 45;
#line 285
  if ((int )*(Option + 0) != 45) {
#line 286
    GAErrorToken___26 = Option;
#line 287
    return (1);
  }
#line 289
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 290
    tmp = strlen((char const   *)CtrlStrCopy);
    }
#line 290
    if (! (i + 2 < (int )tmp)) {
#line 290
      goto while_break;
    }
#line 291
    if ((int )*(CtrlStrCopy + i) == (int )*(Option + 1)) {
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 37) {
#line 291
        goto _L;
      } else
#line 291
      if ((int )*(CtrlStrCopy + (i + 1)) == 33) {
        _L: /* CIL Label */ 
#line 291
        if ((int )*(CtrlStrCopy + (i + 2)) == 45) {
#line 294
          goto while_break;
        }
      }
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  tmp___0 = strlen((char const   *)CtrlStrCopy);
  }
#line 298
  if (i + 2 >= (int )tmp___0) {
#line 299
    GAErrorToken___26 = Option;
#line 300
    return (2);
  }
  {
#line 304
  tmp___2 = (char )' ';
#line 304
  *(CtrlStrCopy + (i + 2)) = tmp___2;
#line 304
  tmp___1 = tmp___2;
#line 304
  *(CtrlStrCopy + (i + 1)) = tmp___1;
#line 304
  *(CtrlStrCopy + i) = tmp___1;
#line 305
  GASetParamCount___26(CtrlStr___25, i, ParamCount);
#line 307
  i += 3;
#line 309
  tmp___3 = *ParamCount;
#line 309
  (*ParamCount) ++;
#line 309
  *(*(Parameters + tmp___3)) = BooleanTrue;
  }
#line 310
  if ((int )*(CtrlStrCopy + i) <= 32) {
#line 311
    return (0);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if ((int )*(CtrlStrCopy + i) == 37) {
#line 314
      goto while_break___0;
    } else
#line 314
    if ((int )*(CtrlStrCopy + i) == 33) {
#line 314
      goto while_break___0;
    }
#line 315
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  tmp___4 = GAGetParmeters___26(Parameters, ParamCount, CtrlStrCopy + i, Option, argc,
                                argv);
  }
#line 317
  return (tmp___4);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetParmeters___26(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                               char *Option , int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  char **tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  int tmp___11 ;
  char **tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  char **tmp___18 ;
  char **tmp___19 ;
  int tmp___20 ;

  {
#line 332
  i = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (! ((int )*(CtrlStrCopy + i) <= 32))) {
#line 334
      goto while_break;
    }
    {
#line 336
    if ((int )*(CtrlStrCopy + (i + 1)) == 100) {
#line 336
      goto case_100;
    }
#line 340
    if ((int )*(CtrlStrCopy + (i + 1)) == 117) {
#line 340
      goto case_117;
    }
#line 344
    if ((int )*(CtrlStrCopy + (i + 1)) == 120) {
#line 344
      goto case_120;
    }
#line 348
    if ((int )*(CtrlStrCopy + (i + 1)) == 111) {
#line 348
      goto case_111;
    }
#line 352
    if ((int )*(CtrlStrCopy + (i + 1)) == 68) {
#line 352
      goto case_68;
    }
#line 356
    if ((int )*(CtrlStrCopy + (i + 1)) == 85) {
#line 356
      goto case_85;
    }
#line 360
    if ((int )*(CtrlStrCopy + (i + 1)) == 88) {
#line 360
      goto case_88;
    }
#line 364
    if ((int )*(CtrlStrCopy + (i + 1)) == 79) {
#line 364
      goto case_79;
    }
#line 368
    if ((int )*(CtrlStrCopy + (i + 1)) == 102) {
#line 368
      goto case_102;
    }
#line 371
    if ((int )*(CtrlStrCopy + (i + 1)) == 70) {
#line 371
      goto case_70;
    }
#line 375
    if ((int )*(CtrlStrCopy + (i + 1)) == 115) {
#line 375
      goto case_115;
    }
#line 380
    if ((int )*(CtrlStrCopy + (i + 1)) == 42) {
#line 380
      goto case_42;
    }
#line 388
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 337
    tmp = *ParamCount;
#line 337
    (*ParamCount) ++;
#line 337
    tmp___0 = *argv;
#line 337
    (*argv) ++;
#line 337
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___0, (char const   */* __restrict  */)"%d",
                     *(Parameters + tmp));
    }
#line 339
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 341
    tmp___1 = *ParamCount;
#line 341
    (*ParamCount) ++;
#line 341
    tmp___2 = *argv;
#line 341
    (*argv) ++;
#line 341
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___2, (char const   */* __restrict  */)"%u",
                     (unsigned int *)*(Parameters + tmp___1));
    }
#line 343
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 345
    tmp___3 = *ParamCount;
#line 345
    (*ParamCount) ++;
#line 345
    tmp___4 = *argv;
#line 345
    (*argv) ++;
#line 345
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%x",
                     (unsigned int *)*(Parameters + tmp___3));
    }
#line 347
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 349
    tmp___5 = *ParamCount;
#line 349
    (*ParamCount) ++;
#line 349
    tmp___6 = *argv;
#line 349
    (*argv) ++;
#line 349
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___6, (char const   */* __restrict  */)"%o",
                     (unsigned int *)*(Parameters + tmp___5));
    }
#line 351
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 353
    tmp___7 = *ParamCount;
#line 353
    (*ParamCount) ++;
#line 353
    tmp___8 = *argv;
#line 353
    (*argv) ++;
#line 353
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___8, (char const   */* __restrict  */)"%ld",
                     (long *)*(Parameters + tmp___7));
    }
#line 355
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 357
    tmp___9 = *ParamCount;
#line 357
    (*ParamCount) ++;
#line 357
    tmp___10 = *argv;
#line 357
    (*argv) ++;
#line 357
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)*(Parameters + tmp___9));
    }
#line 359
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 361
    tmp___11 = *ParamCount;
#line 361
    (*ParamCount) ++;
#line 361
    tmp___12 = *argv;
#line 361
    (*argv) ++;
#line 361
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___12, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)*(Parameters + tmp___11));
    }
#line 363
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 365
    tmp___13 = *ParamCount;
#line 365
    (*ParamCount) ++;
#line 365
    tmp___14 = *argv;
#line 365
    (*argv) ++;
#line 365
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___14, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)*(Parameters + tmp___13));
    }
#line 367
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 369
    tmp___15 = *ParamCount;
#line 369
    (*ParamCount) ++;
#line 369
    tmp___16 = *argv;
#line 369
    (*argv) ++;
#line 369
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%f",
                     (float *)*(Parameters + tmp___15));
    }
    case_70: /* CIL Label */ 
    {
#line 372
    tmp___17 = *ParamCount;
#line 372
    (*ParamCount) ++;
#line 372
    tmp___18 = *argv;
#line 372
    (*argv) ++;
#line 372
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___18, (char const   */* __restrict  */)"%lf",
                     (double *)*(Parameters + tmp___17));
    }
#line 374
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 376
    ScanRes = 1;
#line 377
    tmp___19 = *argv;
#line 377
    (*argv) ++;
#line 377
    tmp___20 = *ParamCount;
#line 377
    (*ParamCount) ++;
#line 377
    GAByteCopy___26((char *)*(Parameters + tmp___20), (char *)tmp___19, (unsigned int )sizeof(char *));
    }
#line 379
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 381
    ScanRes = GAGetMultiParmeters___26(Parameters, ParamCount, CtrlStrCopy + i, argc,
                                       argv);
    }
#line 383
    if (ScanRes == 0) {
#line 383
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 384
        GAErrorToken___26 = Option;
#line 385
        return (3);
      }
    }
#line 387
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 392
    if (ScanRes == 0) {
#line 392
      if ((int )*(CtrlStrCopy + i) == 33) {
#line 393
        GAErrorToken___26 = Option;
#line 394
        return (4);
      }
    }
#line 396
    if ((int )*(CtrlStrCopy + (i + 1)) != 42) {
#line 397
      (*argc) --;
#line 398
      i += 2;
    } else {
#line 400
      i += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAGetMultiParmeters___26(int **Parameters , int *ParamCount , char *CtrlStrCopy ,
                                    int *argc , char ***argv ) 
{ 
  int i ;
  int ScanRes ;
  int NumOfPrm ;
  int **Pmain ;
  int **Ptemp ;
  union TmpArray TmpArray ;
  char *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char **tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char **tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char **tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  char **tmp___30 ;
  char *tmp___31 ;
  int **tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 421
  i = 0;
#line 421
  NumOfPrm = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 432
    if ((int )*(CtrlStrCopy + 2) == 100) {
#line 432
      goto case_100;
    }
#line 437
    if ((int )*(CtrlStrCopy + 2) == 117) {
#line 437
      goto case_117;
    }
#line 442
    if ((int )*(CtrlStrCopy + 2) == 111) {
#line 442
      goto case_111;
    }
#line 447
    if ((int )*(CtrlStrCopy + 2) == 120) {
#line 447
      goto case_120;
    }
#line 452
    if ((int )*(CtrlStrCopy + 2) == 68) {
#line 452
      goto case_68;
    }
#line 457
    if ((int )*(CtrlStrCopy + 2) == 85) {
#line 457
      goto case_85;
    }
#line 463
    if ((int )*(CtrlStrCopy + 2) == 79) {
#line 463
      goto case_79;
    }
#line 469
    if ((int )*(CtrlStrCopy + 2) == 88) {
#line 469
      goto case_88;
    }
#line 475
    if ((int )*(CtrlStrCopy + 2) == 102) {
#line 475
      goto case_102;
    }
#line 480
    if ((int )*(CtrlStrCopy + 2) == 70) {
#line 480
      goto case_70;
    }
#line 486
    if ((int )*(CtrlStrCopy + 2) == 115) {
#line 486
      goto case_115;
    }
#line 495
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 433
    tmp = MyMalloc___26((unsigned int )sizeof(int ));
#line 433
    TmpArray.IntArray[NumOfPrm] = (int *)tmp;
#line 434
    tmp___0 = NumOfPrm;
#line 434
    NumOfPrm ++;
#line 434
    tmp___1 = *argv;
#line 434
    (*argv) ++;
#line 434
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___1, (char const   */* __restrict  */)"%d",
                     TmpArray.IntArray[tmp___0]);
    }
#line 436
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 438
    tmp___2 = MyMalloc___26((unsigned int )sizeof(int ));
#line 438
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___2;
#line 439
    tmp___3 = NumOfPrm;
#line 439
    NumOfPrm ++;
#line 439
    tmp___4 = *argv;
#line 439
    (*argv) ++;
#line 439
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___4, (char const   */* __restrict  */)"%u",
                     (unsigned int *)TmpArray.IntArray[tmp___3]);
    }
#line 441
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 443
    tmp___5 = MyMalloc___26((unsigned int )sizeof(int ));
#line 443
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___5;
#line 444
    tmp___6 = NumOfPrm;
#line 444
    NumOfPrm ++;
#line 444
    tmp___7 = *argv;
#line 444
    (*argv) ++;
#line 444
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___7, (char const   */* __restrict  */)"%o",
                     (unsigned int *)TmpArray.IntArray[tmp___6]);
    }
#line 446
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 448
    tmp___8 = MyMalloc___26((unsigned int )sizeof(int ));
#line 448
    TmpArray.IntArray[NumOfPrm] = (int *)tmp___8;
#line 449
    tmp___9 = NumOfPrm;
#line 449
    NumOfPrm ++;
#line 449
    tmp___10 = *argv;
#line 449
    (*argv) ++;
#line 449
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___10, (char const   */* __restrict  */)"%x",
                     (unsigned int *)TmpArray.IntArray[tmp___9]);
    }
#line 451
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 453
    tmp___11 = MyMalloc___26((unsigned int )sizeof(long ));
#line 453
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___11;
#line 454
    tmp___12 = NumOfPrm;
#line 454
    NumOfPrm ++;
#line 454
    tmp___13 = *argv;
#line 454
    (*argv) ++;
#line 454
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___13, (char const   */* __restrict  */)"%ld",
                     (long *)TmpArray.IntArray[tmp___12]);
    }
#line 456
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 458
    tmp___14 = MyMalloc___26((unsigned int )sizeof(long ));
#line 458
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___14;
#line 459
    tmp___15 = NumOfPrm;
#line 459
    NumOfPrm ++;
#line 459
    tmp___16 = *argv;
#line 459
    (*argv) ++;
#line 459
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___16, (char const   */* __restrict  */)"%lu",
                     (unsigned long *)TmpArray.IntArray[tmp___15]);
    }
#line 462
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 464
    tmp___17 = MyMalloc___26((unsigned int )sizeof(long ));
#line 464
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___17;
#line 465
    tmp___18 = NumOfPrm;
#line 465
    NumOfPrm ++;
#line 465
    tmp___19 = *argv;
#line 465
    (*argv) ++;
#line 465
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___19, (char const   */* __restrict  */)"%lo",
                     (unsigned long *)TmpArray.IntArray[tmp___18]);
    }
#line 468
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 470
    tmp___20 = MyMalloc___26((unsigned int )sizeof(long ));
#line 470
    TmpArray.LngArray[NumOfPrm] = (long *)tmp___20;
#line 471
    tmp___21 = NumOfPrm;
#line 471
    NumOfPrm ++;
#line 471
    tmp___22 = *argv;
#line 471
    (*argv) ++;
#line 471
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___22, (char const   */* __restrict  */)"%lx",
                     (unsigned long *)TmpArray.IntArray[tmp___21]);
    }
#line 474
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 476
    tmp___23 = MyMalloc___26((unsigned int )sizeof(float ));
#line 476
    TmpArray.FltArray[NumOfPrm] = (float *)tmp___23;
#line 477
    tmp___24 = NumOfPrm;
#line 477
    NumOfPrm ++;
#line 477
    tmp___25 = *argv;
#line 477
    (*argv) ++;
#line 477
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___25, (char const   */* __restrict  */)"%f",
                     (float *)TmpArray.LngArray[tmp___24]);
    }
#line 479
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 481
    tmp___26 = MyMalloc___26((unsigned int )sizeof(double ));
#line 481
    TmpArray.DblArray[NumOfPrm] = (double *)tmp___26;
#line 483
    tmp___27 = NumOfPrm;
#line 483
    NumOfPrm ++;
#line 483
    tmp___28 = *argv;
#line 483
    (*argv) ++;
#line 483
    ScanRes = sscanf((char const   */* __restrict  */)*tmp___28, (char const   */* __restrict  */)"%lf",
                     (double *)TmpArray.LngArray[tmp___27]);
    }
#line 485
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (*argc) {
#line 487
        if (! ((int )*(*(*argv) + 0) != 45)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
#line 488
      tmp___29 = NumOfPrm;
#line 488
      NumOfPrm ++;
#line 488
      tmp___30 = *argv;
#line 488
      (*argv) ++;
#line 488
      TmpArray.ChrArray[tmp___29] = *tmp___30;
#line 489
      (*argc) --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 491
    ScanRes = 0;
#line 492
    NumOfPrm ++;
#line 493
    (*argv) ++;
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 496
    ScanRes = 0;
    switch_break: /* CIL Label */ ;
    }
#line 498
    (*argc) --;
#line 430
    if (! (ScanRes == 1)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  (*argv) --;
#line 502
  NumOfPrm --;
#line 503
  (*argc) ++;
#line 506
  tmp___31 = MyMalloc___26((unsigned int )((unsigned long )((unsigned int )(NumOfPrm + 1)) * sizeof(int *)));
#line 506
  Pmain = (int **)tmp___31;
#line 506
  Ptemp = Pmain;
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! (i < NumOfPrm)) {
#line 509
      goto while_break___1;
    }
#line 510
    tmp___32 = Ptemp;
#line 510
    Ptemp ++;
#line 510
    *tmp___32 = TmpArray.IntArray[i];
#line 509
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 511
  *Ptemp = (int *)((void *)0);
#line 515
  tmp___33 = *ParamCount;
#line 515
  (*ParamCount) ++;
#line 515
  *(*(Parameters + tmp___33)) = NumOfPrm;
#line 516
  tmp___34 = *ParamCount;
#line 516
  (*ParamCount) ++;
#line 516
  GAByteCopy___26((char *)*(Parameters + tmp___34), (char *)(& Pmain), (unsigned int )sizeof(char *));
  }
#line 518
  return (NumOfPrm);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GASetParamCount___26(char *CtrlStr___25 , int Max , int *ParamCount ) 
{ 
  int i ;

  {
#line 536
  *ParamCount = 0;
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < Max)) {
#line 537
      goto while_break;
    }
#line 538
    if ((int )*(CtrlStr___25 + i) == 37) {
#line 538
      goto _L;
    } else
#line 538
    if ((int )*(CtrlStr___25 + i) == 33) {
      _L: /* CIL Label */ 
#line 539
      if ((int )*(CtrlStr___25 + (i + 1)) == 42) {
#line 540
        *ParamCount += 2;
      } else {
#line 542
        (*ParamCount) ++;
      }
    }
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static void GAByteCopy___26(char *Dst , char *Src , unsigned int n ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___1 = n;
#line 555
    n --;
#line 555
    if (! tmp___1) {
#line 555
      goto while_break;
    }
#line 556
    tmp = Dst;
#line 556
    Dst ++;
#line 556
    tmp___0 = Src;
#line 556
    Src ++;
#line 556
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static int GAOptionExists___26(int argc , char **argv ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___0 = argc;
#line 567
    argc --;
#line 567
    if (! tmp___0) {
#line 567
      goto while_break;
    }
#line 568
    tmp = argv;
#line 568
    argv ++;
#line 568
    if ((int )*(*tmp + 0) == 45) {
#line 569
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/getarg.c"
static char *MyMalloc___26(unsigned int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 688
  tmp = malloc((size_t )size);
#line 688
  p = (char *)tmp;
  }
#line 688
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 689
    return (p);
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory, exit.\n");
#line 692
  exit(2);
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___27(GifFileType *GifFile , GifWord *Word ) ;
#line 52
static int DGifSetupDecompress___27(GifFileType *GifFile ) ;
#line 53
static int DGifDecompressLine___27(GifFileType *GifFile , GifPixelType *Line , int LineLen ) ;
#line 55
static int DGifGetPrefixChar___27(GifPrefixType *Prefix , int Code , int ClearCode ) ;
#line 56
static int DGifDecompressInput___27(GifFileType *GifFile , int *Code ) ;
#line 57
static int DGifBufferedInput___27(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetWord___27(GifFileType *GifFile , GifWord *Word ) 
{ 
  unsigned char c[2] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 630
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 630
    tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, c, 2);
#line 630
    tmp___1 = (size_t )tmp;
    }
  } else {
    {
#line 630
    tmp___0 = fread((void */* __restrict  */)(c), (size_t )1, (size_t )2, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 630
    tmp___1 = tmp___0;
    }
  }
#line 630
  if (tmp___1 != 2UL) {
#line 631
    _GifError = 102;
#line 632
    return (0);
  }
#line 635
  *Word = (GifWord )(((unsigned int )c[1] << 8) + (unsigned int )c[0]);
#line 636
  return (1);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifSetupDecompress___27(GifFileType *GifFile ) 
{ 
  int i ;
  int BitsPerPixel ;
  GifByteType CodeSize ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;

  {
#line 706
  Private = (GifFilePrivateType *)GifFile->Private;
#line 708
  if (((GifFilePrivateType *)GifFile->Private)->Read) {
    {
#line 708
    (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, & CodeSize, 1);
    }
  } else {
    {
#line 708
    fread((void */* __restrict  */)(& CodeSize), (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
    }
  }
#line 709
  BitsPerPixel = (int )CodeSize;
#line 711
  Private->Buf[0] = (GifByteType )0;
#line 712
  Private->BitsPerPixel = BitsPerPixel;
#line 713
  Private->ClearCode = 1 << BitsPerPixel;
#line 714
  Private->EOFCode = Private->ClearCode + 1;
#line 715
  Private->RunningCode = Private->EOFCode + 1;
#line 716
  Private->RunningBits = BitsPerPixel + 1;
#line 717
  Private->MaxCode1 = 1 << Private->RunningBits;
#line 718
  Private->StackPtr = 0;
#line 719
  Private->LastCode = 4098;
#line 720
  Private->CrntShiftState = 0;
#line 721
  Private->CrntShiftDWord = 0UL;
#line 723
  Prefix = Private->Prefix;
#line 724
  i = 0;
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i <= 4095)) {
#line 724
      goto while_break;
    }
#line 725
    *(Prefix + i) = (GifPrefixType )4098;
#line 724
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressLine___27(GifFileType *GifFile , GifPixelType *Line , int LineLen ) 
{ 
  int i ;
  int j ;
  int CrntCode ;
  int EOFCode ;
  int ClearCode ;
  int CrntPrefix ;
  int LastCode ;
  int StackPtr ;
  GifByteType *Stack ;
  GifByteType *Suffix ;
  GifPrefixType *Prefix ;
  GifFilePrivateType *Private ;
  int tmp ;
  int tmp___0 ;
  GifWord tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GifByteType tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 741
  i = 0;
#line 745
  Private = (GifFilePrivateType *)GifFile->Private;
#line 747
  StackPtr = Private->StackPtr;
#line 748
  Prefix = Private->Prefix;
#line 749
  Suffix = Private->Suffix;
#line 750
  Stack = Private->Stack;
#line 751
  EOFCode = Private->EOFCode;
#line 752
  ClearCode = Private->ClearCode;
#line 753
  LastCode = Private->LastCode;
#line 755
  if (StackPtr > 4095) {
#line 756
    return (0);
  }
#line 759
  if (StackPtr != 0) {
    {
#line 761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 761
      if (StackPtr != 0) {
#line 761
        if (! (i < LineLen)) {
#line 761
          goto while_break;
        }
      } else {
#line 761
        goto while_break;
      }
#line 762
      tmp = i;
#line 762
      i ++;
#line 762
      StackPtr --;
#line 762
      *(Line + tmp) = *(Stack + StackPtr);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i < LineLen)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    tmp___0 = DGifDecompressInput___27(GifFile, & CrntCode);
    }
#line 766
    if (tmp___0 == 0) {
#line 767
      return (0);
    }
#line 769
    if (CrntCode == EOFCode) {
#line 773
      if (i != LineLen - 1) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      } else
#line 773
      if (Private->PixelCount != 0UL) {
#line 774
        _GifError = 113;
#line 775
        return (0);
      }
#line 777
      i ++;
    } else
#line 778
    if (CrntCode == ClearCode) {
#line 780
      j = 0;
      {
#line 780
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 780
        if (! (j <= 4095)) {
#line 780
          goto while_break___1;
        }
#line 781
        *(Prefix + j) = (GifPrefixType )4098;
#line 780
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 782
      Private->RunningCode = Private->EOFCode + 1;
#line 783
      Private->RunningBits = Private->BitsPerPixel + 1;
#line 784
      Private->MaxCode1 = 1 << Private->RunningBits;
#line 785
      tmp___1 = 4098;
#line 785
      Private->LastCode = tmp___1;
#line 785
      LastCode = tmp___1;
    } else {
#line 790
      if (CrntCode < ClearCode) {
#line 792
        tmp___2 = i;
#line 792
        i ++;
#line 792
        *(Line + tmp___2) = (GifPixelType )CrntCode;
      } else {
#line 798
        if (*(Prefix + CrntCode) == 4098U) {
#line 803
          if (CrntCode == Private->RunningCode - 2) {
            {
#line 804
            CrntPrefix = LastCode;
#line 805
            tmp___3 = StackPtr;
#line 805
            StackPtr ++;
#line 805
            tmp___5 = DGifGetPrefixChar___27(Prefix, LastCode, ClearCode);
#line 805
            tmp___4 = (GifByteType )tmp___5;
#line 805
            *(Stack + tmp___3) = tmp___4;
#line 805
            *(Suffix + (Private->RunningCode - 2)) = tmp___4;
            }
          } else {
#line 810
            _GifError = 112;
#line 811
            return (0);
          }
        } else {
#line 814
          CrntPrefix = CrntCode;
        }
#line 821
        j = 0;
        {
#line 822
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 822
          tmp___7 = j;
#line 822
          j ++;
#line 822
          if (tmp___7 <= 4095) {
#line 822
            if (CrntPrefix > ClearCode) {
#line 822
              if (! (CrntPrefix <= 4095)) {
#line 822
                goto while_break___2;
              }
            } else {
#line 822
              goto while_break___2;
            }
          } else {
#line 822
            goto while_break___2;
          }
#line 824
          tmp___6 = StackPtr;
#line 824
          StackPtr ++;
#line 824
          *(Stack + tmp___6) = *(Suffix + CrntPrefix);
#line 825
          CrntPrefix = (int )*(Prefix + CrntPrefix);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 827
        if (j >= 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        } else
#line 827
        if (CrntPrefix > 4095) {
#line 828
          _GifError = 112;
#line 829
          return (0);
        }
#line 832
        tmp___8 = StackPtr;
#line 832
        StackPtr ++;
#line 832
        *(Stack + tmp___8) = (GifByteType )CrntPrefix;
        {
#line 835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 835
          if (StackPtr != 0) {
#line 835
            if (! (i < LineLen)) {
#line 835
              goto while_break___3;
            }
          } else {
#line 835
            goto while_break___3;
          }
#line 836
          tmp___9 = i;
#line 836
          i ++;
#line 836
          StackPtr --;
#line 836
          *(Line + tmp___9) = *(Stack + StackPtr);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 838
      if (LastCode != 4098) {
#line 839
        *(Prefix + (Private->RunningCode - 2)) = (GifPrefixType )LastCode;
#line 841
        if (CrntCode == Private->RunningCode - 2) {
          {
#line 846
          tmp___10 = DGifGetPrefixChar___27(Prefix, LastCode, ClearCode);
#line 846
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___10;
          }
        } else {
          {
#line 849
          tmp___11 = DGifGetPrefixChar___27(Prefix, CrntCode, ClearCode);
#line 849
          *(Suffix + (Private->RunningCode - 2)) = (GifByteType )tmp___11;
          }
        }
      }
#line 853
      LastCode = CrntCode;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  Private->LastCode = LastCode;
#line 858
  Private->StackPtr = StackPtr;
#line 860
  return (1);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifGetPrefixChar___27(GifPrefixType *Prefix , int Code , int ClearCode ) 
{ 
  int i ;
  int tmp ;

  {
#line 874
  i = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (Code > ClearCode) {
#line 876
      tmp = i;
#line 876
      i ++;
#line 876
      if (! (tmp <= 4095)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 877
    if (Code > 4095) {
#line 878
      return (4098);
    }
#line 880
    Code = (int )*(Prefix + Code);
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return (Code);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static unsigned short CodeMasks___27[13]  = 
#line 936
  {      (unsigned short)0,      (unsigned short)1,      (unsigned short)3,      (unsigned short)7, 
        (unsigned short)15,      (unsigned short)31,      (unsigned short)63,      (unsigned short)127, 
        (unsigned short)255,      (unsigned short)511,      (unsigned short)1023,      (unsigned short)2047, 
        (unsigned short)4095};
#line 929 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifDecompressInput___27(GifFileType *GifFile , int *Code ) 
{ 
  GifFilePrivateType *Private ;
  GifByteType NextByte ;
  int tmp ;

  {
#line 933
  Private = (GifFilePrivateType *)GifFile->Private;
#line 943
  if (Private->RunningBits > 12) {
#line 944
    _GifError = 112;
#line 945
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (Private->CrntShiftState < Private->RunningBits)) {
#line 948
      goto while_break;
    }
    {
#line 950
    tmp = DGifBufferedInput___27(GifFile, Private->Buf, & NextByte);
    }
#line 950
    if (tmp == 0) {
#line 951
      return (0);
    }
#line 953
    Private->CrntShiftDWord |= (unsigned long )NextByte << Private->CrntShiftState;
#line 955
    Private->CrntShiftState += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  *Code = (int )(Private->CrntShiftDWord & (unsigned long )CodeMasks___27[Private->RunningBits]);
#line 959
  Private->CrntShiftDWord >>= Private->RunningBits;
#line 960
  Private->CrntShiftState -= Private->RunningBits;
#line 967
  if (Private->RunningCode < 4097) {
#line 967
    (Private->RunningCode) ++;
#line 967
    if (Private->RunningCode > Private->MaxCode1) {
#line 967
      if (Private->RunningBits < 12) {
#line 970
        Private->MaxCode1 <<= 1;
#line 971
        (Private->RunningBits) ++;
      }
    }
  }
#line 973
  return (1);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dgif_lib.c"
static int DGifBufferedInput___27(GifFileType *GifFile , GifByteType *Buf , GifByteType *NextByte ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  GifByteType tmp___5 ;

  {
#line 987
  if ((int )*(Buf + 0) == 0) {
#line 989
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 989
      tmp = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf, 1);
#line 989
      tmp___1 = (size_t )tmp;
      }
    } else {
      {
#line 989
      tmp___0 = fread((void */* __restrict  */)Buf, (size_t )1, (size_t )1, (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 989
      tmp___1 = tmp___0;
      }
    }
#line 989
    if (tmp___1 != 1UL) {
#line 990
      _GifError = 102;
#line 991
      return (0);
    }
#line 997
    if ((int )*(Buf + 0) == 0) {
#line 998
      _GifError = 112;
#line 999
      return (0);
    }
#line 1005
    if ((int )*(Buf + 0) == 0) {
#line 1006
      _GifError = 112;
#line 1007
      return (0);
    }
#line 1009
    if (((GifFilePrivateType *)GifFile->Private)->Read) {
      {
#line 1009
      tmp___2 = (*(((GifFilePrivateType *)GifFile->Private)->Read))(GifFile, Buf + 1,
                                                                    (int )*(Buf + 0));
#line 1009
      tmp___4 = (size_t )tmp___2;
      }
    } else {
      {
#line 1009
      tmp___3 = fread((void */* __restrict  */)(Buf + 1), (size_t )1, (size_t )*(Buf + 0),
                      (FILE */* __restrict  */)((GifFilePrivateType *)GifFile->Private)->File);
#line 1009
      tmp___4 = tmp___3;
      }
    }
#line 1009
    if (tmp___4 != (size_t )*(Buf + 0)) {
#line 1010
      _GifError = 102;
#line 1011
      return (0);
    }
#line 1013
    *NextByte = *(Buf + 1);
#line 1014
    *(Buf + 1) = (GifByteType )2;
#line 1015
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  } else {
#line 1017
    tmp___5 = *(Buf + 1);
#line 1017
    *(Buf + 1) = (GifByteType )((int )*(Buf + 1) + 1);
#line 1017
    *NextByte = *(Buf + tmp___5);
#line 1018
    *(Buf + 0) = (GifByteType )((int )*(Buf + 0) - 1);
  }
#line 1021
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphDriver___27  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int GraphMode___27  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int ScreenColorBits___27  =    1;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenXMax___27  =    100L;
#line 46 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static long ScreenYMax___27  =    100L;
#line 62
static void GetScanLine___27(GifPixelType *ScanLine___0 , int Y ) ;
#line 63
static int HandleGifError___28(GifFileType *GifFile ) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static void GetScanLine___27(GifPixelType *ScanLine___0 , int Y ) 
{ 


  {
  {
#line 487
  if (GraphDriver___27 == 1001) {
#line 487
    goto case_1001;
  }
#line 493
  goto switch_default;
  case_1001: /* CIL Label */ 
  {
#line 488
  memcpy((void */* __restrict  */)ScanLine___0, (void const   */* __restrict  */)GlblGifBufferPtr,
         (unsigned long )ScreenXMax___27 * sizeof(GifPixelType ));
#line 490
  GlblGifBufferPtr += ScreenXMax___27;
  }
#line 491
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/dev2gif.c"
static int HandleGifError___28(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 504
  tmp = GifLastError();
#line 504
  i = tmp;
#line 506
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 506
  if (tmp___0 == 0) {
    {
#line 507
    GifLastError();
    }
  }
#line 509
  return (i);
}
}
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/raw2gif.c"
static char *VersionStr___24  =    (char *)"Raw2Gif Version 4.1, \tGershon Elber,\tMar  3 2016,   19:58:01\n(C) Copyright 1989 Gershon Elber.\n";
#line 64 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/raw2gif.c"
static char *CtrlStr___24  =    (char *)"Raw2Gif q%- s!-Width|Height!d!d p%-ColorMapFile!s h%- RawFile!*s";
#line 70 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/raw2gif.c"
static GifColorType EGAPalette[16]  = 
#line 70
  {      {(GifByteType )0, (GifByteType )0, (GifByteType )0}, 
        {(GifByteType )0, (GifByteType )0, (GifByteType )170}, 
        {(GifByteType )0, (GifByteType )170, (GifByteType )0}, 
        {(GifByteType )0, (GifByteType )170, (GifByteType )170}, 
        {(GifByteType )170, (GifByteType )0, (GifByteType )0}, 
        {(GifByteType )170, (GifByteType )0, (GifByteType )170}, 
        {(GifByteType )170, (GifByteType )170, (GifByteType )0}, 
        {(GifByteType )170, (GifByteType )170, (GifByteType )170}, 
        {(GifByteType )85, (GifByteType )85, (GifByteType )85}, 
        {(GifByteType )85, (GifByteType )85, (GifByteType )255}, 
        {(GifByteType )85, (GifByteType )255, (GifByteType )85}, 
        {(GifByteType )85, (GifByteType )255, (GifByteType )255}, 
        {(GifByteType )255, (GifByteType )85, (GifByteType )85}, 
        {(GifByteType )255, (GifByteType )85, (GifByteType )255}, 
        {(GifByteType )255, (GifByteType )255, (GifByteType )85}, 
        {(GifByteType )255, (GifByteType )255, (GifByteType )255}};
#line 91
int Raw2Gif(int ImageWidth___2 , int ImageHeight___2 , ColorMapObject *ColorMap___3 ) ;
#line 92
static int HandleGifError___29(GifFileType *GifFile ) ;
#line 186 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/raw2gif.c"
static GifPixelType *ScanLine  ;
#line 183 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/raw2gif.c"
int Raw2Gif(int ImageWidth___2 , int ImageHeight___2 , ColorMapObject *ColorMap___3 ) 
{ 
  int i ;
  int j ;
  GifFileType *GifFile ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 189
  tmp = malloc(sizeof(GifPixelType ) * (unsigned long )ImageWidth___2);
#line 189
  ScanLine = (GifPixelType *)tmp;
  }
#line 189
  if ((unsigned long )ScanLine == (unsigned long )((void *)0)) {
    {
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
            "Raw2Gif", "Failed to allocate scan line, aborted.");
#line 192
    exit(1);
    }
  }
  {
#line 195
  GifFile = EGifOpenFileHandle(1);
  }
#line 195
  if ((unsigned long )GifFile == (unsigned long )((void *)0)) {
    {
#line 196
    free((void *)((char *)ScanLine));
#line 197
    tmp___0 = HandleGifError___29(GifFile);
    }
#line 197
    return (tmp___0);
  }
  {
#line 200
  tmp___2 = EGifPutScreenDesc(GifFile, ImageWidth___2, ImageHeight___2, ColorMap___3->BitsPerPixel,
                              0, (ColorMapObject const   *)ColorMap___3);
  }
#line 200
  if (tmp___2 == 0) {
    {
#line 202
    free((void *)((char *)ScanLine));
#line 203
    tmp___1 = HandleGifError___29(GifFile);
    }
#line 203
    return (tmp___1);
  }
  {
#line 206
  tmp___4 = EGifPutImageDesc(GifFile, 0, 0, ImageWidth___2, ImageHeight___2, 0, (ColorMapObject const   *)((void *)0));
  }
#line 206
  if (tmp___4 == 0) {
    {
#line 208
    free((void *)((char *)ScanLine));
#line 209
    tmp___3 = HandleGifError___29(GifFile);
    }
#line 209
    return (tmp___3);
  }
  {
#line 213
  GifQprintf((char *)"\n%s: Image 1 at (0, 0) [%dx%d]:     ", "Raw2Gif", ImageWidth___2,
             ImageHeight___2);
#line 215
  i = 0;
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < ImageHeight___2)) {
#line 215
      goto while_break;
    }
    {
#line 218
    tmp___5 = fread((void */* __restrict  */)ScanLine, (size_t )1, (size_t )ImageWidth___2,
                    (FILE */* __restrict  */)stdin);
    }
#line 218
    if (tmp___5 != (size_t )((unsigned int )ImageWidth___2)) {
      {
#line 219
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
              "Raw2Gif", "RAW input file ended prematurely.");
#line 220
      exit(1);
      }
    }
#line 223
    j = 0;
    {
#line 223
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 223
      if (! (j < ImageWidth___2)) {
#line 223
        goto while_break___0;
      }
#line 224
      if ((int )*(ScanLine + j) >= ColorMap___3->ColorCount) {
        {
#line 225
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s\n",
                "Raw2Gif", "Warning: RAW data color > maximum color map entry.");
        }
      }
#line 223
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 227
    tmp___7 = EGifPutLine(GifFile, ScanLine, ImageWidth___2);
    }
#line 227
    if (tmp___7 == 0) {
      {
#line 228
      free((void *)((char *)ScanLine));
#line 229
      tmp___6 = HandleGifError___29(GifFile);
      }
#line 229
      return (tmp___6);
    }
    {
#line 231
    GifQprintf((char *)"\b\b\b\b%-4d", i);
#line 215
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  tmp___9 = EGifCloseFile(GifFile);
  }
#line 234
  if (tmp___9 == 0) {
    {
#line 235
    free((void *)((char *)ScanLine));
#line 236
    tmp___8 = HandleGifError___29(GifFile);
    }
#line 236
    return (tmp___8);
  }
  {
#line 239
  free((void *)((char *)ScanLine));
  }
#line 240
  return (0);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/util/raw2gif.c"
static int HandleGifError___29(GifFileType *GifFile ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 248
  tmp = GifLastError();
#line 248
  i = tmp;
#line 250
  tmp___0 = EGifCloseFile(GifFile);
  }
#line 250
  if (tmp___0 == 0) {
    {
#line 251
    GifLastError();
    }
  }
#line 253
  return (i);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___27(u_int32_t Item ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/giflib-4.1.6/lib/gif_hash.c"
static int KeyItem___27(u_int32_t Item ) 
{ 


  {
#line 146
  return ((int )(((Item >> 12) ^ Item) & 8191U));
}
}
