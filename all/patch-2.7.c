/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned long size_t;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef long ptrdiff_t;
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef int wchar_t;
#line 352 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int wint_t;
#line 49 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.h"
enum __anonenum_arg_type_27 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 49 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.h"
typedef enum __anonenum_arg_type_27 arg_type;
#line 91 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.h"
union __anonunion_a_29 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 91 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.h"
struct __anonstruct_argument_28 {
   arg_type type ;
   union __anonunion_a_29 a ;
};
#line 91 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.h"
typedef struct __anonstruct_argument_28 argument;
#line 141 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.h"
struct __anonstruct_arguments_30 {
   size_t count ;
   argument *arg ;
   argument direct_alloc_arg[7] ;
};
#line 141 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.h"
typedef struct __anonstruct_arguments_30 arguments;
#line 53 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-parse.h"
struct __anonstruct_char_directive_31 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 53 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-parse.h"
typedef struct __anonstruct_char_directive_31 char_directive;
#line 70 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-parse.h"
struct __anonstruct_char_directives_32 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
   char_directive direct_alloc_dir[7] ;
};
#line 70 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-parse.h"
typedef struct __anonstruct_char_directives_32 char_directives;
#line 134 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 56 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 180 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 32 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 239
struct quoting_options;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_24 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_23 {
   int __count ;
   union __anonunion___value_24 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_23 __mbstate_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 55 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 718 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 135 "/usr/include/stdint.h"
typedef long intmax_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 110 "parse-datetime.y"
typedef long long_time_t;
#line 128 "parse-datetime.y"
struct __anonstruct_textint_27 {
   _Bool negative ;
   long value ;
   size_t digits ;
};
#line 128 "parse-datetime.y"
typedef struct __anonstruct_textint_27 textint;
#line 136 "parse-datetime.y"
struct __anonstruct_table_28 {
   char const   *name ;
   int type ;
   int value ;
};
#line 136 "parse-datetime.y"
typedef struct __anonstruct_table_28 table;
#line 149 "parse-datetime.y"
struct __anonstruct_relative_time_31 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long_time_t seconds ;
   long ns ;
};
#line 149 "parse-datetime.y"
typedef struct __anonstruct_relative_time_31 relative_time;
#line 171 "parse-datetime.y"
struct __anonstruct_parser_control_32 {
   char const   *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
#line 171 "parse-datetime.y"
typedef struct __anonstruct_parser_control_32 parser_control;
#line 216
union YYSTYPE;
#line 432 "parse-datetime.c"
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
#line 432 "parse-datetime.c"
typedef union YYSTYPE YYSTYPE;
#line 467 "parse-datetime.c"
typedef unsigned char yytype_uint8;
#line 474 "parse-datetime.c"
typedef signed char yytype_int8;
#line 488 "parse-datetime.c"
typedef short yytype_int16;
#line 619 "parse-datetime.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 123 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 52 "/home/wslee/gnu_benchmarks/patch-2.7/lib/malloca.c"
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
#line 56 "/home/wslee/gnu_benchmarks/patch-2.7/lib/malloca.c"
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 53 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 65 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 67
struct hash_table;
#line 69 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.h"
typedef struct hash_table Hash_table;
#line 46 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 109 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_list.h"
struct gl_list_impl;
#line 111 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_list.h"
typedef struct gl_list_impl *gl_list_t;
#line 113
struct gl_list_node_impl;
#line 117 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_list.h"
typedef struct gl_list_node_impl *gl_list_node_t;
#line 119
struct gl_list_implementation;
#line 121 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_list.h"
typedef struct gl_list_implementation  const  *gl_list_implementation_t;
#line 345 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_list.h"
struct __anonstruct_gl_list_iterator_t_1 {
   struct gl_list_implementation  const  *vtable ;
   gl_list_t list ;
   size_t count ;
   void *p ;
   void *q ;
   size_t i ;
   size_t j ;
};
#line 345 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_list.h"
typedef struct __anonstruct_gl_list_iterator_t_1 gl_list_iterator_t;
#line 462 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_list.h"
struct gl_list_implementation {
   gl_list_t (*nx_create_empty)(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                             void const   *elt2 ) ,
                                size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                                _Bool allow_duplicates ) ;
   gl_list_t (*nx_create)(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                       void const   *elt2 ) ,
                          size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                          _Bool allow_duplicates , size_t count , void const   **contents ) ;
   size_t (*size)(gl_list_t list ) ;
   void const   *(*node_value)(gl_list_t list , gl_list_node_t node ) ;
   int (*node_nx_set_value)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*next_node)(gl_list_t list , gl_list_node_t node ) ;
   gl_list_node_t (*previous_node)(gl_list_t list , gl_list_node_t node ) ;
   void const   *(*get_at)(gl_list_t list , size_t position ) ;
   gl_list_node_t (*nx_set_at)(gl_list_t list , size_t position , void const   *elt ) ;
   gl_list_node_t (*search_from_to)(gl_list_t list , size_t start_index , size_t end_index ,
                                    void const   *elt ) ;
   size_t (*indexof_from_to)(gl_list_t list , size_t start_index , size_t end_index ,
                             void const   *elt ) ;
   gl_list_node_t (*nx_add_first)(gl_list_t list , void const   *elt ) ;
   gl_list_node_t (*nx_add_last)(gl_list_t list , void const   *elt ) ;
   gl_list_node_t (*nx_add_before)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*nx_add_after)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*nx_add_at)(gl_list_t list , size_t position , void const   *elt ) ;
   _Bool (*remove_node)(gl_list_t list , gl_list_node_t node ) ;
   _Bool (*remove_at)(gl_list_t list , size_t position ) ;
   _Bool (*remove_elt)(gl_list_t list , void const   *elt ) ;
   void (*list_free)(gl_list_t list ) ;
   gl_list_iterator_t (*iterator)(gl_list_t list ) ;
   gl_list_iterator_t (*iterator_from_to)(gl_list_t list , size_t start_index , size_t end_index ) ;
   _Bool (*iterator_next)(gl_list_iterator_t *iterator , void const   **eltp , gl_list_node_t *nodep ) ;
   void (*iterator_free)(gl_list_iterator_t *iterator ) ;
   gl_list_node_t (*sortedlist_search)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                      void const   *elt2 ) ,
                                       void const   *elt ) ;
   gl_list_node_t (*sortedlist_search_from_to)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                              void const   *elt2 ) ,
                                               size_t start_index , size_t end_index ,
                                               void const   *elt ) ;
   size_t (*sortedlist_indexof)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                               void const   *elt2 ) ,
                                void const   *elt ) ;
   size_t (*sortedlist_indexof_from_to)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                       void const   *elt2 ) ,
                                        size_t start_index , size_t end_index , void const   *elt ) ;
   gl_list_node_t (*sortedlist_nx_add)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                      void const   *elt2 ) ,
                                       void const   *elt ) ;
   _Bool (*sortedlist_remove)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                             void const   *elt2 ) ,
                              void const   *elt ) ;
};
#line 533 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_list.h"
struct gl_list_impl_base {
   struct gl_list_implementation  const  *vtable ;
   _Bool (*equals_fn)(void const   *elt1 , void const   *elt2 ) ;
   size_t (*hashcode_fn)(void const   *elt ) ;
   void (*dispose_fn)(void const   *elt ) ;
   _Bool allow_duplicates ;
};
#line 23 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list1.h"
struct gl_list_node_impl {
   struct gl_list_node_impl *next ;
   struct gl_list_node_impl *prev ;
   void const   *value ;
};
#line 34 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list1.h"
struct gl_list_impl {
   struct gl_list_impl_base base ;
   struct gl_list_node_impl root ;
   size_t count ;
};
#line 158 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 92 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 196 "./getopt.h"
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 62 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt_int.h"
enum __ord {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 68 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __ord __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 485 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
struct option_list {
   struct rpl_option  const  *p ;
   struct option_list *next ;
};
#line 28 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.h"
enum backup_type {
    no_backups = 0,
    simple_backups = 1,
    numbered_existing_backups = 2,
    numbered_backups = 3
} ;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 146 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.c"
enum numbered_backup_result {
    BACKUP_IS_SAME_LENGTH = 0,
    BACKUP_IS_LONGER = 1,
    BACKUP_IS_NEW = 2
} ;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 69 "./common.h"
typedef off_t lin;
#line 107
enum __anonenum_verbosity_22 {
    DEFAULT_VERBOSITY = 0,
    SILENT = 1,
    VERBOSE = 2
} ;
#line 115
enum diff {
    NO_DIFF = 0,
    CONTEXT_DIFF = 1,
    NORMAL_DIFF = 2,
    ED_DIFF = 3,
    NEW_CONTEXT_DIFF = 4,
    UNI_DIFF = 5,
    GIT_BINARY_DIFF = 6
} ;
#line 191 "./common.h"
struct outstate {
   FILE *ofp ;
   _Bool after_newline ;
   _Bool zero_output ;
};
#line 209
enum conflict_style {
    MERGE_MERGE = 0,
    MERGE_DIFF3 = 1
} ;
#line 101 "../lib/diffseq.h"
struct context {
   char *xchar ;
   char *ychar ;
   lin *fdiag ;
   lin *bdiag ;
   _Bool heuristic ;
   lin too_expensive ;
};
#line 136 "../lib/diffseq.h"
struct partition {
   lin xmid ;
   lin ymid ;
   _Bool lo_minimal ;
   _Bool hi_minimal ;
};
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 50 "/usr/include/sys/types.h"
typedef __ino_t ino_t;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_7 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_7 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 158 "./common.h"
typedef long file_offset;
#line 30 "./util.h"
enum file_id_type {
    UNKNOWN = 0,
    CREATED = 1,
    DELETE_LATER = 2,
    OVERWRITTEN = 3
} ;
#line 72
enum file_attributes {
    FA_TIMES = 1,
    FA_IDS = 2,
    FA_MODE = 4,
    FA_XATTRS = 8
} ;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_35 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_36 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_37 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_38 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_39 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_33 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_34 _kill ;
   struct __anonstruct__timer_35 _timer ;
   struct __anonstruct__rt_36 _rt ;
   struct __anonstruct__sigchld_37 _sigchld ;
   struct __anonstruct__sigfault_38 _sigfault ;
   struct __anonstruct__sigpoll_39 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_33 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_51 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_51 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 56 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
struct __anonstruct_file_id_55 {
   dev_t dev ;
   ino_t ino ;
   enum file_id_type type ;
   _Bool queued_output ;
};
#line 56 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
typedef struct __anonstruct_file_id_55 file_id;
#line 20 "./pch.h"
enum nametype {
    OLD = 0,
    NEW = 1,
    INDEX = 2,
    NONE = 3
} ;
#line 79 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
enum __anonenum_read_only_behavior_34 {
    RO_IGNORE = 0,
    RO_WARN = 1,
    RO_FAIL = 2
} ;
#line 1362
enum __anonenum_def_state_35 {
    OUTSIDE = 0,
    IN_IFNDEF = 1,
    IN_IFDEF = 2,
    IN_ELSE = 3
} ;
#line 1686 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
struct file_to_delete {
   char *name ;
   struct stat st ;
   _Bool backup ;
};
#line 1749 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
struct file_to_output {
   char *from ;
   struct stat from_st ;
   char *to ;
   mode_t mode ;
   _Bool backup ;
};
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 48 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xvasprintf.h"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 376 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 47 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 49
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 106
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 108
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 108 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 111
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 111
    tmp = -1;
  } else {
#line 111
    tmp = -2;
  }
#line 111
  if ((size_t )tmp / s < n) {
    {
#line 112
    xalloc_die();
    }
  }
  {
#line 113
  tmp___0 = xmalloc(n * s);
  }
#line 113
  return (tmp___0);
}
}
#line 51 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 57
  sum = size1 + size2;
#line 58
  if (sum >= size1) {
#line 58
    tmp = sum;
  } else {
#line 58
    tmp = 0xffffffffffffffffUL;
  }
#line 58
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 32 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xvasprintf.c"
__inline static char *xstrcat(size_t argcount , va_list args ) 
{ 
  char *result ;
  va_list ap ;
  size_t totalsize ;
  size_t i ;
  char *p ;
  char const   *next ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *next___0 ;
  char const   *tmp___8 ;
  size_t len ;
  size_t tmp___9 ;

  {
  {
#line 42
  totalsize = (size_t )0;
#line 43
  __builtin_va_copy(ap, args);
#line 44
  i = argcount;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i > 0UL)) {
#line 44
      goto while_break;
    }
    {
#line 46
    tmp___0 = __builtin_va_arg(ap, char const   *);
#line 46
    next = tmp___0;
#line 47
    tmp___1 = strlen(next);
#line 47
    tmp___2 = xsum(totalsize, tmp___1);
#line 47
    totalsize = (size_t )tmp___2;
#line 44
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  __builtin_va_end(ap);
  }
#line 54
  if (totalsize == 0xffffffffffffffffUL) {
    {
#line 56
    tmp___3 = __errno_location();
#line 56
    *tmp___3 = 75;
    }
#line 57
    return ((char *)((void *)0));
  } else
#line 54
  if (totalsize > 2147483647UL) {
    {
#line 56
    tmp___3 = __errno_location();
#line 56
    *tmp___3 = 75;
    }
#line 57
    return ((char *)((void *)0));
  }
#line 61
  if (sizeof(char ) == 1UL) {
    {
#line 61
    tmp___4 = xmalloc(totalsize + 1UL);
#line 61
    tmp___6 = tmp___4;
    }
  } else {
    {
#line 61
    tmp___5 = xnmalloc(totalsize + 1UL, sizeof(char ));
#line 61
    tmp___6 = tmp___5;
    }
  }
#line 61
  result = (char *)tmp___6;
#line 62
  p = result;
#line 63
  i = argcount;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (i > 0UL)) {
#line 63
      goto while_break___0;
    }
    {
#line 65
    tmp___8 = __builtin_va_arg(args, char const   *);
#line 65
    next___0 = tmp___8;
#line 66
    tmp___9 = strlen(next___0);
#line 66
    len = tmp___9;
#line 67
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)next___0,
           len);
#line 68
    p += len;
#line 63
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 70
  *p = (char )'\000';
#line 72
  return (result);
}
}
#line 75 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xvasprintf.c"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args ) 
{ 
  char *result ;
  size_t argcount ;
  char const   *f ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 84
  argcount = (size_t )0;
#line 87
  f = format;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if ((int const   )*f == 0) {
      {
#line 91
      tmp = xstrcat(argcount, args);
      }
#line 91
      return (tmp);
    }
#line 92
    if ((int const   )*f != 37) {
#line 93
      goto while_break;
    }
#line 94
    f ++;
#line 95
    if ((int const   )*f != 115) {
#line 96
      goto while_break;
    }
#line 97
    f ++;
#line 98
    argcount ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  tmp___1 = vasprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)format,
                      args);
  }
#line 102
  if (tmp___1 < 0) {
    {
#line 104
    tmp___0 = __errno_location();
    }
#line 104
    if (*tmp___0 == 12) {
      {
#line 105
      xalloc_die();
      }
    }
#line 106
    return ((char *)((void *)0));
  }
#line 109
  return (result);
}
}
#line 23 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 181 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
#line 29 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 32
  tmp = strndup(string, n);
#line 32
  s = tmp;
  }
#line 33
  if (! s) {
    {
#line 34
    xalloc_die();
    }
  }
#line 35
  return (s);
}
}
#line 51 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc.h"
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 53
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 55
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 57
void *x2realloc(void *p , size_t *pn ) ;
#line 58
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 60
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 184 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 187
  n = *pn;
#line 189
  if (! p) {
#line 191
    if (! n) {
#line 199
      n = 128UL / s;
#line 200
      n += (size_t )(! n);
    }
  } else {
#line 209
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 210
      xalloc_die();
      }
    }
#line 211
    n += (n + 1UL) / 2UL;
  }
  {
#line 214
  *pn = n;
#line 215
  tmp = xrealloc(p, n * s);
  }
#line 215
  return (tmp);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 40 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 40 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 43
  tmp = malloc(n);
#line 43
  p = tmp;
  }
#line 44
  if (! p) {
#line 44
    if (n != 0UL) {
      {
#line 45
      xalloc_die();
      }
    }
  }
#line 46
  return (p);
}
}
#line 52
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 52 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 55
  if (! n) {
#line 55
    if (p) {
      {
#line 59
      free(p);
      }
#line 60
      return ((void *)0);
    }
  }
  {
#line 63
  p = realloc(p, n);
  }
#line 64
  if (! p) {
#line 64
    if (n) {
      {
#line 65
      xalloc_die();
      }
    }
  }
#line 66
  return (p);
}
}
#line 75 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 78
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 78
  return (tmp);
}
}
#line 85
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 85 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 88
  tmp = xmalloc(s);
#line 88
  tmp___0 = memset(tmp, 0, s);
  }
#line 88
  return (tmp___0);
}
}
#line 94
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 94 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 102
  p = calloc(n, s);
  }
#line 102
  if (! p) {
    {
#line 104
    xalloc_die();
    }
  }
#line 105
  return (p);
}
}
#line 112
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 112 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 115
  tmp = xmalloc(s);
#line 115
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 115
  return (tmp___0);
}
}
#line 120
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 120 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 123
  tmp = strlen(string);
#line 123
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 123
  return ((char *)tmp___0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 46 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xvasprintf.h"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) ;
#line 23 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xasprintf.c"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 29
  __builtin_va_start(args, format);
#line 30
  result = xvasprintf(format, args);
#line 31
  __builtin_va_end(args);
  }
#line 33
  return (result);
}
}
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 42 "/home/wslee/gnu_benchmarks/patch-2.7/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/wslee/gnu_benchmarks/patch-2.7/lib/exitfail.h"
int volatile   exit_failure ;
#line 31 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 34
  error((int )exit_failure, 0, "%s", "memory exhausted");
#line 40
  abort();
  }
}
}
#line 45 "/home/wslee/gnu_benchmarks/patch-2.7/lib/error.h"
extern void ( /* format attribute */  error_at_line)(int __status , int __errnum ,
                                                     char const   *__fname , unsigned int __lineno ,
                                                     char const   *__format  , ...) ;
#line 34 "/home/wslee/gnu_benchmarks/patch-2.7/lib/verror.h"
void ( /* format attribute */  verror)(int status , int errnum , char const   *format ,
                                       va_list args ) ;
#line 45
void ( /* format attribute */  verror_at_line)(int status , int errnum , char const   *file ,
                                               unsigned int line_number , char const   *format ,
                                               va_list args ) ;
#line 42 "/home/wslee/gnu_benchmarks/patch-2.7/lib/verror.c"
void ( /* format attribute */  verror)(int status , int errnum , char const   *format ,
                                       va_list args ) 
{ 


  {
  {
#line 45
  verror_at_line(status, errnum, (char const   *)((void *)0), 0U, format, args);
  }
#line 46
  return;
}
}
#line 54 "/home/wslee/gnu_benchmarks/patch-2.7/lib/verror.c"
void ( /* format attribute */  verror_at_line)(int status , int errnum , char const   *file ,
                                               unsigned int line_number , char const   *format ,
                                               va_list args ) 
{ 
  char *message ;
  char *tmp ;
  int *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 58
  tmp = xvasprintf(format, args);
#line 58
  message = tmp;
  }
#line 59
  if (message) {
#line 64
    if (file) {
      {
#line 65
      error_at_line(status, errnum, file, line_number, "%s", message);
      }
    } else {
      {
#line 67
      error(status, errnum, "%s", message);
      }
    }
  } else {
    {
#line 73
    tmp___0 = __errno_location();
#line 73
    error(0, *tmp___0, "unable to display error message");
#line 74
    abort();
    }
  }
  {
#line 76
  free((void *)message);
  }
#line 77
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 72 "/home/wslee/gnu_benchmarks/patch-2.7/lib/vasnprintf.h"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) ;
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 154 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 188 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 72 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 78
  tmp = xsum(size1, size2);
#line 78
  tmp___0 = xsum((size_t )tmp, size3);
#line 78
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
#line 78
  return (tmp___1);
}
}
#line 82 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 90
  if (size1 >= size2) {
#line 90
    tmp = size1;
  } else {
#line 90
    tmp = size2;
  }
#line 90
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 1772 "/home/wslee/gnu_benchmarks/patch-2.7/lib/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf___0 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  arg_type type ;
  int flags ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  int orig_errno ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  size_t n___0 ;
  char const   *mp ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  size_t n___1 ;
  char const   *mp___0 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___33 ;
  size_t __attribute__((__pure__))  tmp___34 ;
  size_t __attribute__((__pure__))  tmp___35 ;
  void *tmp___36 ;
  void *tmp___37 ;
  size_t __attribute__((__pure__))  tmp___38 ;
  int *tmp___39 ;
  int count ;
  int retcount ;
  size_t maxlen ;
  int *tmp___40 ;
  int arg ;
  unsigned int arg___0 ;
  int arg___1 ;
  unsigned int arg___2 ;
  int arg___3 ;
  unsigned int arg___4 ;
  long arg___5 ;
  unsigned long arg___6 ;
  long long arg___7 ;
  unsigned long long arg___8 ;
  double arg___9 ;
  long double arg___10 ;
  int arg___11 ;
  wint_t arg___12 ;
  char const   *arg___13 ;
  wchar_t const   *arg___14 ;
  void *arg___15 ;
  int saved_errno ;
  int *tmp___41 ;
  int *tmp___42 ;
  int tmp___43 ;
  size_t n___2 ;
  size_t tmp___44 ;
  size_t __attribute__((__pure__))  tmp___45 ;
  size_t __attribute__((__pure__))  tmp___46 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  int *tmp___50 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___51 ;
  size_t __attribute__((__pure__))  tmp___52 ;
  size_t __attribute__((__pure__))  tmp___53 ;
  void *tmp___54 ;
  void *tmp___55 ;
  size_t __attribute__((__pure__))  tmp___56 ;
  char *memory___4 ;
  void *tmp___57 ;
  int *tmp___58 ;
  int *tmp___59 ;
  void *__cil_tmp124 ;
  void *__cil_tmp125 ;
  void *__cil_tmp126 ;
  void *__cil_tmp127 ;
  void *__cil_tmp128 ;

  {
  {
#line 1779
  tmp = printf_parse(format, & d, & a);
  }
#line 1779
  if (tmp < 0) {
#line 1781
    return ((char *)((void *)0));
  }
  {
#line 1789
  tmp___1 = printf_fetchargs(args, & a);
  }
#line 1789
  if (tmp___1 < 0) {
#line 1791
    if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
      {
#line 1791
      free((void *)d.dir);
      }
    }
#line 1791
    if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
      {
#line 1791
      free((void *)a.arg);
      }
    }
    {
#line 1792
    tmp___0 = __errno_location();
#line 1792
    *tmp___0 = 22;
    }
#line 1793
    return ((char *)((void *)0));
  }
  {
#line 1810
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1810
  buf_neededlength = (size_t )tmp___2;
  }
#line 1813
  if (buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1815
    tmp___3 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1815
    buf___0 = (char *)tmp___3;
#line 1816
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1821
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1821
      tmp___4 = buf_neededlength * sizeof(char );
    } else {
#line 1821
      tmp___4 = 0xffffffffffffffffUL;
    }
#line 1821
    buf_memsize = tmp___4;
#line 1822
    if (buf_memsize == 0xffffffffffffffffUL) {
#line 1823
      goto out_of_memory_1;
    }
    {
#line 1824
    tmp___5 = malloc(buf_memsize);
#line 1824
    buf___0 = (char *)tmp___5;
    }
#line 1825
    if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 1826
      goto out_of_memory_1;
    }
#line 1827
    buf_malloced = buf___0;
  }
#line 1830
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1832
    result = resultbuf;
#line 1833
    allocated = *lengthp;
  } else {
#line 1837
    result = (char *)((void *)0);
#line 1838
    allocated = (size_t )0;
  }
#line 1840
  length = (size_t )0;
#line 1870
  cp = format;
#line 1870
  i = (size_t )0;
#line 1870
  dp = d.dir + 0;
  {
#line 1870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1872
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
#line 1874
      n = (size_t )(dp->dir_start - cp);
#line 1875
      tmp___6 = xsum(length, n);
#line 1875
      augmented_length = (size_t )tmp___6;
      }
#line 1877
      if (augmented_length > allocated) {
#line 1877
        if (allocated > 0UL) {
#line 1877
          if (allocated <= 9223372036854775807UL) {
#line 1877
            tmp___7 = allocated * 2UL;
          } else {
#line 1877
            tmp___7 = 0xffffffffffffffffUL;
          }
#line 1877
          allocated = tmp___7;
        } else {
#line 1877
          allocated = (size_t )12;
        }
#line 1877
        if (augmented_length > allocated) {
#line 1877
          allocated = augmented_length;
        }
#line 1877
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1877
          memory_size = allocated * sizeof(char );
        } else {
#line 1877
          memory_size = 0xffffffffffffffffUL;
        }
#line 1877
        if (memory_size == 0xffffffffffffffffUL) {
#line 1877
          goto out_of_memory;
        }
#line 1877
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1877
          tmp___8 = malloc(memory_size);
#line 1877
          memory = (char *)tmp___8;
          }
        } else
#line 1877
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1877
          tmp___8 = malloc(memory_size);
#line 1877
          memory = (char *)tmp___8;
          }
        } else {
          {
#line 1877
          tmp___9 = realloc((void *)result, memory_size);
#line 1877
          memory = (char *)tmp___9;
          }
        }
#line 1877
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1877
          goto out_of_memory;
        }
#line 1877
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1877
          if (length > 0UL) {
            {
#line 1877
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1877
        result = memory;
      }
#line 1881
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1883
        memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)cp,
               n);
#line 1884
        length = augmented_length;
        }
      } else {
        {
#line 1888
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1889
          tmp___10 = length;
#line 1889
          length ++;
#line 1889
          tmp___11 = cp;
#line 1889
          cp ++;
#line 1889
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
#line 1888
          n --;
#line 1888
          if (! (n > 0UL)) {
#line 1888
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1893
    if (i == d.count) {
#line 1894
      goto while_break;
    }
#line 1897
    if ((int )dp->conversion == 37) {
#line 1901
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
        {
#line 1902
        abort();
        }
      }
      {
#line 1903
      tmp___12 = xsum(length, (size_t )1);
#line 1903
      augmented_length___0 = (size_t )tmp___12;
      }
#line 1904
      if (augmented_length___0 > allocated) {
#line 1904
        if (allocated > 0UL) {
#line 1904
          if (allocated <= 9223372036854775807UL) {
#line 1904
            tmp___13 = allocated * 2UL;
          } else {
#line 1904
            tmp___13 = 0xffffffffffffffffUL;
          }
#line 1904
          allocated = tmp___13;
        } else {
#line 1904
          allocated = (size_t )12;
        }
#line 1904
        if (augmented_length___0 > allocated) {
#line 1904
          allocated = augmented_length___0;
        }
#line 1904
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1904
          memory_size___0 = allocated * sizeof(char );
        } else {
#line 1904
          memory_size___0 = 0xffffffffffffffffUL;
        }
#line 1904
        if (memory_size___0 == 0xffffffffffffffffUL) {
#line 1904
          goto out_of_memory;
        }
#line 1904
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1904
          tmp___14 = malloc(memory_size___0);
#line 1904
          memory___0 = (char *)tmp___14;
          }
        } else
#line 1904
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1904
          tmp___14 = malloc(memory_size___0);
#line 1904
          memory___0 = (char *)tmp___14;
          }
        } else {
          {
#line 1904
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1904
          memory___0 = (char *)tmp___15;
          }
        }
#line 1904
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1904
          goto out_of_memory;
        }
#line 1904
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1904
          if (length > 0UL) {
            {
#line 1904
            memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1904
        result = memory___0;
      }
#line 1905
      *(result + length) = (char )'%';
#line 1906
      length = augmented_length___0;
    } else {
#line 1910
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
        {
#line 1911
        abort();
        }
      }
#line 1913
      if ((int )dp->conversion == 110) {
        {
#line 1917
        if ((unsigned int )(a.arg + dp->arg_index)->type == 18U) {
#line 1917
          goto case_18;
        }
#line 1920
        if ((unsigned int )(a.arg + dp->arg_index)->type == 19U) {
#line 1920
          goto case_19;
        }
#line 1923
        if ((unsigned int )(a.arg + dp->arg_index)->type == 20U) {
#line 1923
          goto case_20;
        }
#line 1926
        if ((unsigned int )(a.arg + dp->arg_index)->type == 21U) {
#line 1926
          goto case_21;
        }
#line 1930
        if ((unsigned int )(a.arg + dp->arg_index)->type == 22U) {
#line 1930
          goto case_22;
        }
#line 1934
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1918
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1919
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1921
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1922
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1924
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1925
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1927
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1928
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1931
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1932
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1935
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 4606
        type = (a.arg + dp->arg_index)->type;
#line 4607
        flags = dp->flags;
#line 4768
        fbp = buf___0;
#line 4769
        tmp___16 = fbp;
#line 4769
        fbp ++;
#line 4769
        *tmp___16 = (char )'%';
#line 4775
        if (flags & 1) {
#line 4776
          tmp___17 = fbp;
#line 4776
          fbp ++;
#line 4776
          *tmp___17 = (char )'\'';
        }
#line 4778
        if (flags & 2) {
#line 4779
          tmp___18 = fbp;
#line 4779
          fbp ++;
#line 4779
          *tmp___18 = (char )'-';
        }
#line 4780
        if (flags & 4) {
#line 4781
          tmp___19 = fbp;
#line 4781
          fbp ++;
#line 4781
          *tmp___19 = (char )'+';
        }
#line 4782
        if (flags & 8) {
#line 4783
          tmp___20 = fbp;
#line 4783
          fbp ++;
#line 4783
          *tmp___20 = (char )' ';
        }
#line 4784
        if (flags & 16) {
#line 4785
          tmp___21 = fbp;
#line 4785
          fbp ++;
#line 4785
          *tmp___21 = (char )'#';
        }
#line 4787
        if (flags & 64) {
#line 4788
          tmp___22 = fbp;
#line 4788
          fbp ++;
#line 4788
          *tmp___22 = (char )'I';
        }
#line 4792
        if (flags & 32) {
#line 4793
          tmp___23 = fbp;
#line 4793
          fbp ++;
#line 4793
          *tmp___23 = (char )'0';
        }
#line 4794
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4796
          n___0 = (size_t )(dp->width_end - dp->width_start);
#line 4799
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4801
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->width_start,
                   n___0 * sizeof(char ));
#line 4802
            fbp += n___0;
            }
          } else {
#line 4806
            mp = dp->width_start;
            {
#line 4807
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4808
              tmp___24 = fbp;
#line 4808
              fbp ++;
#line 4808
              tmp___25 = mp;
#line 4808
              mp ++;
#line 4808
              *tmp___24 = (char )((unsigned char )*tmp___25);
#line 4807
              n___0 --;
#line 4807
              if (! (n___0 > 0UL)) {
#line 4807
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 4815
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4817
          n___1 = (size_t )(dp->precision_end - dp->precision_start);
#line 4820
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4822
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->precision_start,
                   n___1 * sizeof(char ));
#line 4823
            fbp += n___1;
            }
          } else {
#line 4827
            mp___0 = dp->precision_start;
            {
#line 4828
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 4829
              tmp___26 = fbp;
#line 4829
              fbp ++;
#line 4829
              tmp___27 = mp___0;
#line 4829
              mp___0 ++;
#line 4829
              *tmp___26 = (char )((unsigned char )*tmp___27);
#line 4828
              n___1 --;
#line 4828
              if (! (n___1 > 0UL)) {
#line 4828
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        {
#line 4839
        if ((unsigned int )type == 10U) {
#line 4839
          goto case_10;
        }
#line 4839
        if ((unsigned int )type == 9U) {
#line 4839
          goto case_10;
        }
#line 4856
        if ((unsigned int )type == 16U) {
#line 4856
          goto case_16;
        }
#line 4856
        if ((unsigned int )type == 14U) {
#line 4856
          goto case_16;
        }
#line 4856
        if ((unsigned int )type == 8U) {
#line 4856
          goto case_16;
        }
#line 4856
        if ((unsigned int )type == 7U) {
#line 4856
          goto case_16;
        }
#line 4860
        if ((unsigned int )type == 12U) {
#line 4860
          goto case_12;
        }
#line 4863
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4846
        tmp___28 = fbp;
#line 4846
        fbp ++;
#line 4846
        *tmp___28 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4858
        tmp___29 = fbp;
#line 4858
        fbp ++;
#line 4858
        *tmp___29 = (char )'l';
#line 4859
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4861
        tmp___30 = fbp;
#line 4861
        fbp ++;
#line 4861
        *tmp___30 = (char )'L';
#line 4862
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4864
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4871
        *fbp = dp->conversion;
#line 4902
        *(fbp + 1) = (char )'\000';
#line 4909
        prefix_count = 0U;
#line 4910
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 4912
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4913
            abort();
            }
          }
#line 4914
          tmp___31 = prefix_count;
#line 4914
          prefix_count ++;
#line 4914
          prefixes[tmp___31] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4916
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 4918
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4919
            abort();
            }
          }
#line 4920
          tmp___32 = prefix_count;
#line 4920
          prefix_count ++;
#line 4920
          prefixes[tmp___32] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4932
        tmp___38 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
        }
#line 4932
        if (tmp___38 > (size_t __attribute__((__pure__))  )allocated) {
#line 4932
          if (allocated > 0UL) {
#line 4932
            if (allocated <= 9223372036854775807UL) {
#line 4932
              tmp___33 = allocated * 2UL;
            } else {
#line 4932
              tmp___33 = 0xffffffffffffffffUL;
            }
#line 4932
            allocated = tmp___33;
          } else {
#line 4932
            allocated = (size_t )12;
          }
          {
#line 4932
          tmp___35 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
          }
#line 4932
          if (tmp___35 > (size_t __attribute__((__pure__))  )allocated) {
            {
#line 4932
            tmp___34 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4932
            allocated = (size_t )tmp___34;
            }
          }
#line 4932
          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4932
            memory_size___1 = allocated * sizeof(char );
          } else {
#line 4932
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 4932
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 4932
            goto out_of_memory;
          }
#line 4932
          if ((unsigned long )result == (unsigned long )resultbuf) {
            {
#line 4932
            tmp___36 = malloc(memory_size___1);
#line 4932
            memory___1 = (char *)tmp___36;
            }
          } else
#line 4932
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 4932
            tmp___36 = malloc(memory_size___1);
#line 4932
            memory___1 = (char *)tmp___36;
            }
          } else {
            {
#line 4932
            tmp___37 = realloc((void *)result, memory_size___1);
#line 4932
            memory___1 = (char *)tmp___37;
            }
          }
#line 4932
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4932
            goto out_of_memory;
          }
#line 4932
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4932
            if (length > 0UL) {
              {
#line 4932
              memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)result,
                     length);
              }
            }
          }
#line 4932
          result = memory___1;
        }
        {
#line 4937
        *(result + length) = (char )'\000';
#line 4940
        tmp___39 = __errno_location();
#line 4940
        orig_errno = *tmp___39;
        }
        {
#line 4942
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4944
          count = -1;
#line 4947
          retcount = 0;
#line 4948
          maxlen = allocated - length;
#line 4951
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4952
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
          {
#line 4953
          maxlen *= sizeof(char ) / sizeof(char );
#line 4995
          tmp___40 = __errno_location();
#line 4995
          *tmp___40 = 0;
          }
          {
#line 4998
          if ((unsigned int )type == 1U) {
#line 4998
            goto case_1;
          }
#line 5004
          if ((unsigned int )type == 2U) {
#line 5004
            goto case_2___0;
          }
#line 5010
          if ((unsigned int )type == 3U) {
#line 5010
            goto case_3;
          }
#line 5016
          if ((unsigned int )type == 4U) {
#line 5016
            goto case_4;
          }
#line 5022
          if ((unsigned int )type == 5U) {
#line 5022
            goto case_5;
          }
#line 5028
          if ((unsigned int )type == 6U) {
#line 5028
            goto case_6;
          }
#line 5034
          if ((unsigned int )type == 7U) {
#line 5034
            goto case_7___0;
          }
#line 5040
          if ((unsigned int )type == 8U) {
#line 5040
            goto case_8___0;
          }
#line 5047
          if ((unsigned int )type == 9U) {
#line 5047
            goto case_9___0;
          }
#line 5053
          if ((unsigned int )type == 10U) {
#line 5053
            goto case_10___0;
          }
#line 5060
          if ((unsigned int )type == 11U) {
#line 5060
            goto case_11;
          }
#line 5066
          if ((unsigned int )type == 12U) {
#line 5066
            goto case_12___0;
          }
#line 5072
          if ((unsigned int )type == 13U) {
#line 5072
            goto case_13;
          }
#line 5079
          if ((unsigned int )type == 14U) {
#line 5079
            goto case_14___0;
          }
#line 5086
          if ((unsigned int )type == 15U) {
#line 5086
            goto case_15;
          }
#line 5093
          if ((unsigned int )type == 16U) {
#line 5093
            goto case_16___0;
          }
#line 5100
          if ((unsigned int )type == 17U) {
#line 5100
            goto case_17;
          }
#line 5106
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 5000
          arg = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 5001
          if (prefix_count == 0U) {
#line 5001
            goto case_0;
          }
#line 5001
          if (prefix_count == 1U) {
#line 5001
            goto case_1___0;
          }
#line 5001
          if (prefix_count == 2U) {
#line 5001
            goto case_2;
          }
#line 5001
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg, & count);
          }
#line 5001
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg, & count);
          }
#line 5001
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg, & count);
          }
#line 5001
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 5001
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }
#line 5003
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 5006
          arg___0 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 5007
          if (prefix_count == 0U) {
#line 5007
            goto case_0___0;
          }
#line 5007
          if (prefix_count == 1U) {
#line 5007
            goto case_1___1;
          }
#line 5007
          if (prefix_count == 2U) {
#line 5007
            goto case_2___1;
          }
#line 5007
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___0, & count);
          }
#line 5007
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___0, & count);
          }
#line 5007
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___0, & count);
          }
#line 5007
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 5007
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }
#line 5009
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 5012
          arg___1 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 5013
          if (prefix_count == 0U) {
#line 5013
            goto case_0___1;
          }
#line 5013
          if (prefix_count == 1U) {
#line 5013
            goto case_1___2;
          }
#line 5013
          if (prefix_count == 2U) {
#line 5013
            goto case_2___2;
          }
#line 5013
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 5013
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___1, & count);
          }
#line 5013
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 5013
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___1, & count);
          }
#line 5013
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 5013
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___1, & count);
          }
#line 5013
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 5013
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }
#line 5015
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 5018
          arg___2 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 5019
          if (prefix_count == 0U) {
#line 5019
            goto case_0___2;
          }
#line 5019
          if (prefix_count == 1U) {
#line 5019
            goto case_1___3;
          }
#line 5019
          if (prefix_count == 2U) {
#line 5019
            goto case_2___3;
          }
#line 5019
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 5019
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___2, & count);
          }
#line 5019
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 5019
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___2, & count);
          }
#line 5019
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 5019
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___2, & count);
          }
#line 5019
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 5019
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }
#line 5021
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 5024
          arg___3 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 5025
          if (prefix_count == 0U) {
#line 5025
            goto case_0___3;
          }
#line 5025
          if (prefix_count == 1U) {
#line 5025
            goto case_1___4;
          }
#line 5025
          if (prefix_count == 2U) {
#line 5025
            goto case_2___4;
          }
#line 5025
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 5025
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___3, & count);
          }
#line 5025
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 5025
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___3, & count);
          }
#line 5025
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 5025
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___3, & count);
          }
#line 5025
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 5025
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }
#line 5027
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 5030
          arg___4 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 5031
          if (prefix_count == 0U) {
#line 5031
            goto case_0___4;
          }
#line 5031
          if (prefix_count == 1U) {
#line 5031
            goto case_1___5;
          }
#line 5031
          if (prefix_count == 2U) {
#line 5031
            goto case_2___5;
          }
#line 5031
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 5031
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___4, & count);
          }
#line 5031
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 5031
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___4, & count);
          }
#line 5031
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 5031
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___4, & count);
          }
#line 5031
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 5031
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }
#line 5033
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 5036
          arg___5 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 5037
          if (prefix_count == 0U) {
#line 5037
            goto case_0___5;
          }
#line 5037
          if (prefix_count == 1U) {
#line 5037
            goto case_1___6;
          }
#line 5037
          if (prefix_count == 2U) {
#line 5037
            goto case_2___6;
          }
#line 5037
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 5037
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___5, & count);
          }
#line 5037
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 5037
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___5, & count);
          }
#line 5037
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 5037
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___5, & count);
          }
#line 5037
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 5037
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }
#line 5039
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 5042
          arg___6 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 5043
          if (prefix_count == 0U) {
#line 5043
            goto case_0___6;
          }
#line 5043
          if (prefix_count == 1U) {
#line 5043
            goto case_1___7;
          }
#line 5043
          if (prefix_count == 2U) {
#line 5043
            goto case_2___7;
          }
#line 5043
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 5043
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___6, & count);
          }
#line 5043
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 5043
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___6, & count);
          }
#line 5043
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 5043
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___6, & count);
          }
#line 5043
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 5043
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }
#line 5045
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 5049
          arg___7 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 5050
          if (prefix_count == 0U) {
#line 5050
            goto case_0___7;
          }
#line 5050
          if (prefix_count == 1U) {
#line 5050
            goto case_1___8;
          }
#line 5050
          if (prefix_count == 2U) {
#line 5050
            goto case_2___8;
          }
#line 5050
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 5050
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___7, & count);
          }
#line 5050
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 5050
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___7, & count);
          }
#line 5050
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 5050
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___7, & count);
          }
#line 5050
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 5050
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }
#line 5052
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 5055
          arg___8 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 5056
          if (prefix_count == 0U) {
#line 5056
            goto case_0___8;
          }
#line 5056
          if (prefix_count == 1U) {
#line 5056
            goto case_1___9;
          }
#line 5056
          if (prefix_count == 2U) {
#line 5056
            goto case_2___9;
          }
#line 5056
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___8, & count);
          }
#line 5056
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___8, & count);
          }
#line 5056
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___8, & count);
          }
#line 5056
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 5056
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }
#line 5058
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 5062
          arg___9 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 5063
          if (prefix_count == 0U) {
#line 5063
            goto case_0___9;
          }
#line 5063
          if (prefix_count == 1U) {
#line 5063
            goto case_1___10;
          }
#line 5063
          if (prefix_count == 2U) {
#line 5063
            goto case_2___10;
          }
#line 5063
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___9, & count);
          }
#line 5063
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___9, & count);
          }
#line 5063
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___9, & count);
          }
#line 5063
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 5063
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }
#line 5065
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 5068
          arg___10 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 5069
          if (prefix_count == 0U) {
#line 5069
            goto case_0___10;
          }
#line 5069
          if (prefix_count == 1U) {
#line 5069
            goto case_1___11;
          }
#line 5069
          if (prefix_count == 2U) {
#line 5069
            goto case_2___11;
          }
#line 5069
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 5069
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___10,
                              & count);
          }
#line 5069
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 5069
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___10, & count);
          }
#line 5069
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 5069
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___10, & count);
          }
#line 5069
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 5069
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }
#line 5071
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 5074
          arg___11 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5075
          if (prefix_count == 0U) {
#line 5075
            goto case_0___11;
          }
#line 5075
          if (prefix_count == 1U) {
#line 5075
            goto case_1___12;
          }
#line 5075
          if (prefix_count == 2U) {
#line 5075
            goto case_2___12;
          }
#line 5075
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5075
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___11,
                              & count);
          }
#line 5075
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5075
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___11, & count);
          }
#line 5075
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5075
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___11, & count);
          }
#line 5075
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5075
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }
#line 5077
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5081
          arg___12 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5082
          if (prefix_count == 0U) {
#line 5082
            goto case_0___12;
          }
#line 5082
          if (prefix_count == 1U) {
#line 5082
            goto case_1___13;
          }
#line 5082
          if (prefix_count == 2U) {
#line 5082
            goto case_2___13;
          }
#line 5082
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5082
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___12,
                              & count);
          }
#line 5082
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5082
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___12, & count);
          }
#line 5082
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5082
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___12, & count);
          }
#line 5082
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5082
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }
#line 5084
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5088
          arg___13 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5089
          if (prefix_count == 0U) {
#line 5089
            goto case_0___13;
          }
#line 5089
          if (prefix_count == 1U) {
#line 5089
            goto case_1___14;
          }
#line 5089
          if (prefix_count == 2U) {
#line 5089
            goto case_2___14;
          }
#line 5089
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5089
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___13,
                              & count);
          }
#line 5089
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5089
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___13, & count);
          }
#line 5089
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5089
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___13, & count);
          }
#line 5089
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5089
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }
#line 5091
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5095
          arg___14 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5096
          if (prefix_count == 0U) {
#line 5096
            goto case_0___14;
          }
#line 5096
          if (prefix_count == 1U) {
#line 5096
            goto case_1___15;
          }
#line 5096
          if (prefix_count == 2U) {
#line 5096
            goto case_2___15;
          }
#line 5096
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5096
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___14,
                              & count);
          }
#line 5096
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5096
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___14, & count);
          }
#line 5096
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5096
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___14, & count);
          }
#line 5096
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5096
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }
#line 5098
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5102
          arg___15 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5103
          if (prefix_count == 0U) {
#line 5103
            goto case_0___15;
          }
#line 5103
          if (prefix_count == 1U) {
#line 5103
            goto case_1___16;
          }
#line 5103
          if (prefix_count == 2U) {
#line 5103
            goto case_2___16;
          }
#line 5103
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5103
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, arg___15,
                              & count);
          }
#line 5103
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5103
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              arg___15, & count);
          }
#line 5103
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5103
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___0, prefixes[0],
                              prefixes[1], arg___15, & count);
          }
#line 5103
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5103
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }
#line 5105
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5107
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5115
          if (count >= 0) {
#line 5119
            if ((size_t )count < maxlen) {
#line 5119
              if ((int )*((result + length) + count) != 0) {
                {
#line 5121
                abort();
                }
              }
            }
#line 5123
            if (retcount > count) {
#line 5124
              count = retcount;
            }
          } else
#line 5130
          if ((int )*(fbp + 1) != 0) {
#line 5134
            *(fbp + 1) = (char )'\000';
#line 5135
            goto __Cont;
          } else
#line 5140
          if (! (retcount < 0)) {
#line 5182
            count = retcount;
          }
#line 5188
          if (count < 0) {
            {
#line 5192
            tmp___41 = __errno_location();
#line 5192
            saved_errno = *tmp___41;
            }
#line 5194
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5194
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                {
#line 5195
                free((void *)result);
                }
              }
            }
#line 5196
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              {
#line 5197
              free((void *)buf_malloced);
              }
            }
#line 5198
            if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
              {
#line 5198
              free((void *)d.dir);
              }
            }
#line 5198
            if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
              {
#line 5198
              free((void *)a.arg);
              }
            }
            {
#line 5199
            tmp___42 = __errno_location();
            }
#line 5199
            if (saved_errno != 0) {
#line 5199
              *tmp___42 = saved_errno;
            } else {
#line 5199
              if ((int )dp->conversion == 99) {
#line 5199
                tmp___43 = 84;
              } else
#line 5199
              if ((int )dp->conversion == 115) {
#line 5199
                tmp___43 = 84;
              } else {
#line 5199
                tmp___43 = 22;
              }
#line 5199
              *tmp___42 = tmp___43;
            }
#line 5205
            return ((char *)((void *)0));
          }
#line 5214
          if ((size_t )((unsigned int )count + 1U) >= maxlen) {
#line 5219
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5220
              goto overflow;
            } else {
#line 5232
              if (allocated <= 9223372036854775807UL) {
#line 5232
                tmp___44 = allocated * 2UL;
              } else {
#line 5232
                tmp___44 = 0xffffffffffffffffUL;
              }
              {
#line 5232
              tmp___45 = xsum(length, (((unsigned long )((unsigned int )count + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 5232
              tmp___46 = xmax((size_t )tmp___45, tmp___44);
#line 5232
              n___2 = (size_t )tmp___46;
              }
#line 5239
              if (n___2 > allocated) {
#line 5239
                if (allocated > 0UL) {
#line 5239
                  if (allocated <= 9223372036854775807UL) {
#line 5239
                    tmp___47 = allocated * 2UL;
                  } else {
#line 5239
                    tmp___47 = 0xffffffffffffffffUL;
                  }
#line 5239
                  allocated = tmp___47;
                } else {
#line 5239
                  allocated = (size_t )12;
                }
#line 5239
                if (n___2 > allocated) {
#line 5239
                  allocated = n___2;
                }
#line 5239
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5239
                  memory_size___2 = allocated * sizeof(char );
                } else {
#line 5239
                  memory_size___2 = 0xffffffffffffffffUL;
                }
#line 5239
                if (memory_size___2 == 0xffffffffffffffffUL) {
#line 5239
                  goto out_of_memory;
                }
#line 5239
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 5239
                  tmp___48 = malloc(memory_size___2);
#line 5239
                  memory___2 = (char *)tmp___48;
                  }
                } else
#line 5239
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 5239
                  tmp___48 = malloc(memory_size___2);
#line 5239
                  memory___2 = (char *)tmp___48;
                  }
                } else {
                  {
#line 5239
                  tmp___49 = realloc((void *)result, memory_size___2);
#line 5239
                  memory___2 = (char *)tmp___49;
                  }
                }
#line 5239
                if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 5239
                  goto out_of_memory;
                }
#line 5239
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5239
                  if (length > 0UL) {
                    {
#line 5239
                    memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 5239
                result = memory___2;
              }
#line 5240
              goto __Cont;
            }
          }
#line 5536
          length += (size_t )count;
#line 5537
          goto while_break___3;
          __Cont: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 5539
        tmp___50 = __errno_location();
#line 5539
        *tmp___50 = orig_errno;
        }
      }
    }
#line 1870
    cp = dp->dir_end;
#line 1870
    i ++;
#line 1870
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5547
  tmp___56 = xsum(length, (size_t )1);
  }
#line 5547
  if (tmp___56 > (size_t __attribute__((__pure__))  )allocated) {
#line 5547
    if (allocated > 0UL) {
#line 5547
      if (allocated <= 9223372036854775807UL) {
#line 5547
        tmp___51 = allocated * 2UL;
      } else {
#line 5547
        tmp___51 = 0xffffffffffffffffUL;
      }
#line 5547
      allocated = tmp___51;
    } else {
#line 5547
      allocated = (size_t )12;
    }
    {
#line 5547
    tmp___53 = xsum(length, (size_t )1);
    }
#line 5547
    if (tmp___53 > (size_t __attribute__((__pure__))  )allocated) {
      {
#line 5547
      tmp___52 = xsum(length, (size_t )1);
#line 5547
      allocated = (size_t )tmp___52;
      }
    }
#line 5547
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5547
      memory_size___3 = allocated * sizeof(char );
    } else {
#line 5547
      memory_size___3 = 0xffffffffffffffffUL;
    }
#line 5547
    if (memory_size___3 == 0xffffffffffffffffUL) {
#line 5547
      goto out_of_memory;
    }
#line 5547
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
#line 5547
      tmp___54 = malloc(memory_size___3);
#line 5547
      memory___3 = (char *)tmp___54;
      }
    } else
#line 5547
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 5547
      tmp___54 = malloc(memory_size___3);
#line 5547
      memory___3 = (char *)tmp___54;
      }
    } else {
      {
#line 5547
      tmp___55 = realloc((void *)result, memory_size___3);
#line 5547
      memory___3 = (char *)tmp___55;
      }
    }
#line 5547
    if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5547
      goto out_of_memory;
    }
#line 5547
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5547
      if (length > 0UL) {
        {
#line 5547
        memcpy((void */* __restrict  */)memory___3, (void const   */* __restrict  */)result,
               length);
        }
      }
    }
#line 5547
    result = memory___3;
  }
#line 5548
  *(result + length) = (char )'\000';
#line 5550
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5550
    if (length + 1UL < allocated) {
      {
#line 5555
      tmp___57 = realloc((void *)result, (length + 1UL) * sizeof(char ));
#line 5555
      memory___4 = (char *)tmp___57;
      }
#line 5556
      if ((unsigned long )memory___4 != (unsigned long )((void *)0)) {
#line 5557
        result = memory___4;
      }
    }
  }
#line 5560
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5561
    free((void *)buf_malloced);
    }
  }
#line 5562
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5562
    free((void *)d.dir);
    }
  }
#line 5562
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5562
    free((void *)a.arg);
    }
  }
#line 5563
  *lengthp = length;
#line 5568
  return (result);
  overflow: 
#line 5572
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5572
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5573
      free((void *)result);
      }
    }
  }
#line 5574
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5575
    free((void *)buf_malloced);
    }
  }
#line 5576
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5576
    free((void *)d.dir);
    }
  }
#line 5576
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5576
    free((void *)a.arg);
    }
  }
  {
#line 5577
  tmp___58 = __errno_location();
#line 5577
  *tmp___58 = 75;
  }
#line 5578
  return ((char *)((void *)0));
  out_of_memory: 
#line 5582
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5582
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5583
      free((void *)result);
      }
    }
  }
#line 5584
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5585
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
#line 5587
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5587
    free((void *)d.dir);
    }
  }
#line 5587
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5587
    free((void *)a.arg);
    }
  }
  {
#line 5588
  tmp___59 = __errno_location();
#line 5588
  *tmp___59 = 12;
  }
#line 5589
  return ((char *)((void *)0));
}
}
#line 21 "/home/wslee/gnu_benchmarks/patch-2.7/lib/utimens.h"
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) ;
#line 22
int utimens(char const   *file , struct timespec  const  *timespec ) ;
#line 23
int lutimens(char const   *file , struct timespec  const  *timespec ) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf ) ;
#line 364
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) utimensat)(int __fd ,
                                                                                      char const   *__path ,
                                                                                      struct timespec  const  *__times ,
                                                                                      int __flags ) ;
#line 372
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec  const  *__times ) ;
#line 140 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utimes)(char const   *__file ,
                                                                                   struct timeval  const  *__tvp ) ;
#line 156
extern  __attribute__((__nothrow__)) int futimesat(int __fd , char const   *__file ,
                                                   struct timeval  const  *__tvp ) ;
#line 54 "/home/wslee/gnu_benchmarks/patch-2.7/lib/stat-time.h"
__inline long get_stat_atime_ns(struct stat  const  *st ) 
{ 


  {
#line 58
  return ((long )st->st_atim.tv_nsec);
}
}
#line 67 "/home/wslee/gnu_benchmarks/patch-2.7/lib/stat-time.h"
__inline long get_stat_ctime_ns(struct stat  const  *st ) 
{ 


  {
#line 71
  return ((long )st->st_ctim.tv_nsec);
}
}
#line 80 "/home/wslee/gnu_benchmarks/patch-2.7/lib/stat-time.h"
__inline long get_stat_mtime_ns(struct stat  const  *st ) 
{ 


  {
#line 84
  return ((long )st->st_mtim.tv_nsec);
}
}
#line 93 "/home/wslee/gnu_benchmarks/patch-2.7/lib/stat-time.h"
__inline long get_stat_birthtime_ns(struct stat  const  *st ) 
{ 


  {
#line 103
  return (0L);
}
}
#line 108 "/home/wslee/gnu_benchmarks/patch-2.7/lib/stat-time.h"
__inline struct timespec get_stat_atime(struct stat  const  *st ) 
{ 


  {
#line 112
  return ((struct timespec )st->st_atim);
}
}
#line 122 "/home/wslee/gnu_benchmarks/patch-2.7/lib/stat-time.h"
__inline struct timespec get_stat_ctime(struct stat  const  *st ) 
{ 


  {
#line 126
  return ((struct timespec )st->st_ctim);
}
}
#line 136 "/home/wslee/gnu_benchmarks/patch-2.7/lib/stat-time.h"
__inline struct timespec get_stat_mtime(struct stat  const  *st ) 
{ 


  {
#line 140
  return ((struct timespec )st->st_mtim);
}
}
#line 151 "/home/wslee/gnu_benchmarks/patch-2.7/lib/stat-time.h"
__inline struct timespec get_stat_birthtime(struct stat  const  *st ) 
{ 
  struct timespec t ;
  void *__cil_tmp3 ;

  {
#line 170
  t.tv_sec = (__time_t )-1;
#line 171
  t.tv_nsec = -1L;
#line 191
  return (t);
}
}
#line 57 "/home/wslee/gnu_benchmarks/patch-2.7/lib/timespec.h"
__inline int timespec_cmp(struct timespec a , struct timespec b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 60
  if (a.tv_sec < b.tv_sec) {
#line 60
    tmp___0 = -1;
  } else {
#line 60
    if (a.tv_sec > b.tv_sec) {
#line 60
      tmp = 1;
    } else {
#line 60
      tmp = (int )(a.tv_nsec - b.tv_nsec);
    }
#line 60
    tmp___0 = tmp;
  }
#line 60
  return (tmp___0);
}
}
#line 67 "/home/wslee/gnu_benchmarks/patch-2.7/lib/timespec.h"
__inline int timespec_sign(struct timespec a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 70
  if (a.tv_sec < 0L) {
#line 70
    tmp___0 = -1;
  } else {
#line 70
    if (a.tv_sec) {
#line 70
      tmp = 1;
    } else
#line 70
    if (a.tv_nsec) {
#line 70
      tmp = 1;
    } else {
#line 70
      tmp = 0;
    }
#line 70
    tmp___0 = tmp;
  }
#line 70
  return (tmp___0);
}
}
#line 81 "/home/wslee/gnu_benchmarks/patch-2.7/lib/timespec.h"
__inline double timespectod(struct timespec a ) 
{ 


  {
#line 84
  return ((double )a.tv_sec + (double )a.tv_nsec / 1e9);
}
}
#line 87
void gettime(struct timespec *ts ) ;
#line 74 "/home/wslee/gnu_benchmarks/patch-2.7/lib/utimens.c"
static int utimensat_works_really  ;
#line 75 "/home/wslee/gnu_benchmarks/patch-2.7/lib/utimens.c"
static int lutimensat_works_really  ;
#line 85 "/home/wslee/gnu_benchmarks/patch-2.7/lib/utimens.c"
static int validate_timespec(struct timespec *timespec ) 
{ 
  int result ;
  int utime_omit_count ;
  int *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 88
  result = 0;
#line 89
  utime_omit_count = 0;
#line 90
  if (! timespec) {
    {
#line 90
    __assert_fail("timespec", "/home/wslee/gnu_benchmarks/patch-2.7/lib/utimens.c",
                  90U, "validate_timespec");
    }
  }
#line 91
  if ((timespec + 0)->tv_nsec != (1L << 30) - 1L) {
#line 91
    if ((timespec + 0)->tv_nsec != (1L << 30) - 2L) {
#line 91
      if ((timespec + 0)->tv_nsec < 0L) {
        {
#line 98
        tmp = __errno_location();
#line 98
        *tmp = 22;
        }
#line 99
        return (-1);
      } else
#line 91
      if (1000000000L <= (timespec + 0)->tv_nsec) {
        {
#line 98
        tmp = __errno_location();
#line 98
        *tmp = 22;
        }
#line 99
        return (-1);
      } else {
#line 91
        goto _L___0;
      }
    } else {
#line 91
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 91
  if ((timespec + 1)->tv_nsec != (1L << 30) - 1L) {
#line 91
    if ((timespec + 1)->tv_nsec != (1L << 30) - 2L) {
#line 91
      if ((timespec + 1)->tv_nsec < 0L) {
        {
#line 98
        tmp = __errno_location();
#line 98
        *tmp = 22;
        }
#line 99
        return (-1);
      } else
#line 91
      if (1000000000L <= (timespec + 1)->tv_nsec) {
        {
#line 98
        tmp = __errno_location();
#line 98
        *tmp = 22;
        }
#line 99
        return (-1);
      }
    }
  }
#line 105
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 105
    goto _L___1;
  } else
#line 105
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    _L___1: /* CIL Label */ 
#line 108
    (timespec + 0)->tv_sec = (__time_t )0;
#line 109
    result = 1;
#line 110
    if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 111
      utime_omit_count ++;
    }
  }
#line 113
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 113
    goto _L___2;
  } else
#line 113
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    _L___2: /* CIL Label */ 
#line 116
    (timespec + 1)->tv_sec = (__time_t )0;
#line 117
    result = 1;
#line 118
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 119
      utime_omit_count ++;
    }
  }
#line 121
  return (result + (utime_omit_count == 1));
}
}
#line 130 "/home/wslee/gnu_benchmarks/patch-2.7/lib/utimens.c"
static _Bool update_timespec(struct stat  const  *statbuf , struct timespec **ts ) 
{ 
  struct timespec *timespec ;

  {
#line 133
  timespec = *ts;
#line 134
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 134
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 136
      return ((_Bool)1);
    }
  }
#line 137
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 137
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 140
      *ts = (struct timespec *)((void *)0);
#line 141
      return ((_Bool)0);
    }
  }
#line 144
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    {
#line 145
    *(timespec + 0) = get_stat_atime(statbuf);
    }
  } else
#line 146
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    {
#line 147
    gettime(timespec + 0);
    }
  }
#line 149
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    {
#line 150
    *(timespec + 1) = get_stat_mtime(statbuf);
    }
  } else
#line 151
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
    {
#line 152
    gettime(timespec + 1);
    }
  }
#line 154
  return ((_Bool)0);
}
}
#line 167 "/home/wslee/gnu_benchmarks/patch-2.7/lib/utimens.c"
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int *tmp___0 ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  struct timeval timeval[2] ;
  struct timeval *t ;
  int tmp___12 ;
  _Bool abig ;
  _Bool mbig ;
  time_t adiff ;
  time_t mdiff ;
  struct timeval *tt ;
  struct timeval truncated_timeval[2] ;
  long tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp36 ;
  int __cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  int __cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  int __cil_tmp48 ;
  void *__cil_tmp49 ;

  {
#line 171
  if (timespec) {
#line 171
    tmp = adjusted_timespec;
  } else {
#line 171
    tmp = (struct timespec *)((void *)0);
  }
#line 171
  ts = tmp;
#line 172
  adjustment_needed = 0;
#line 175
  if (ts) {
    {
#line 177
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 178
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 179
    adjustment_needed = validate_timespec((struct timespec *)ts);
    }
  }
#line 181
  if (adjustment_needed < 0) {
#line 182
    return (-1);
  }
#line 187
  if (fd < 0) {
#line 187
    if (! file) {
      {
#line 189
      tmp___0 = __errno_location();
#line 189
      *tmp___0 = 9;
      }
#line 190
      return (-1);
    }
  }
#line 216
  if (0 <= utimensat_works_really) {
#line 228
    if (adjustment_needed == 2) {
#line 230
      if (fd < 0) {
        {
#line 230
        tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
#line 230
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 230
        tmp___2 = fstat(fd, & st);
#line 230
        tmp___3 = tmp___2;
        }
      }
#line 230
      if (tmp___3) {
#line 231
        return (-1);
      }
#line 232
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 233
        *(ts + 0) = get_stat_atime((struct stat  const  *)(& st));
        }
      } else
#line 234
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 235
        *(ts + 1) = get_stat_mtime((struct stat  const  *)(& st));
        }
      }
#line 237
      adjustment_needed ++;
    }
#line 241
    if (fd < 0) {
      {
#line 243
      result = utimensat(-100, file, (struct timespec  const  *)ts, 0);
      }
#line 252
      if (0 < result) {
        {
#line 253
        tmp___4 = __errno_location();
#line 253
        *tmp___4 = 38;
        }
      }
#line 255
      if (result == 0) {
#line 257
        utimensat_works_really = 1;
#line 258
        return (result);
      } else {
        {
#line 255
        tmp___5 = __errno_location();
        }
#line 255
        if (*tmp___5 != 38) {
#line 257
          utimensat_works_really = 1;
#line 258
          return (result);
        }
      }
    }
#line 263
    if (0 <= fd) {
      {
#line 265
      result = futimens(fd, (struct timespec  const  *)ts);
      }
#line 268
      if (0 < result) {
        {
#line 269
        tmp___6 = __errno_location();
#line 269
        *tmp___6 = 38;
        }
      }
#line 271
      if (result == 0) {
#line 273
        utimensat_works_really = 1;
#line 274
        return (result);
      } else {
        {
#line 271
        tmp___7 = __errno_location();
        }
#line 271
        if (*tmp___7 != 38) {
#line 273
          utimensat_works_really = 1;
#line 274
          return (result);
        }
      }
    }
  }
#line 279
  utimensat_works_really = -1;
#line 280
  lutimensat_works_really = -1;
#line 287
  if (adjustment_needed) {
#line 287
    goto _L;
  } else
#line 287
  if (0) {
    _L: /* CIL Label */ 
#line 289
    if (adjustment_needed != 3) {
#line 289
      if (fd < 0) {
        {
#line 289
        tmp___8 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
#line 289
        tmp___10 = tmp___8;
        }
      } else {
        {
#line 289
        tmp___9 = fstat(fd, & st);
#line 289
        tmp___10 = tmp___9;
        }
      }
#line 289
      if (tmp___10) {
#line 291
        return (-1);
      }
    }
#line 292
    if (ts) {
      {
#line 292
      tmp___11 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
      }
#line 292
      if (tmp___11) {
#line 293
        return (0);
      }
    }
  }
#line 300
  if (ts) {
#line 302
    timeval[0].tv_sec = (ts + 0)->tv_sec;
#line 303
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
#line 304
    timeval[1].tv_sec = (ts + 1)->tv_sec;
#line 305
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
#line 306
    t = timeval;
  } else {
#line 309
    t = (struct timeval *)((void *)0);
  }
#line 311
  if (fd < 0) {
    {
#line 314
    tmp___12 = futimesat(-100, file, (struct timeval  const  *)t);
    }
#line 314
    return (tmp___12);
  } else {
    {
#line 335
    tmp___16 = futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)t);
    }
#line 335
    if (tmp___16 == 0) {
#line 343
      if (t) {
#line 345
        abig = (_Bool )(500000L <= (t + 0)->tv_usec);
#line 346
        mbig = (_Bool )(500000L <= (t + 1)->tv_usec);
#line 347
        if ((int )abig | (int )mbig) {
          {
#line 347
          tmp___15 = fstat(fd, & st);
          }
#line 347
          if (tmp___15 == 0) {
#line 351
            adiff = st.st_atim.tv_sec - (t + 0)->tv_sec;
#line 352
            mdiff = st.st_mtim.tv_sec - (t + 1)->tv_sec;
#line 354
            tt = (struct timeval *)((void *)0);
#line 356
            truncated_timeval[0] = *(t + 0);
#line 357
            truncated_timeval[1] = *(t + 1);
#line 358
            if (abig) {
#line 358
              if (adiff == 1L) {
                {
#line 358
                tmp___13 = get_stat_atime_ns((struct stat  const  *)(& st));
                }
#line 358
                if (tmp___13 == 0L) {
#line 360
                  tt = truncated_timeval;
#line 361
                  (tt + 0)->tv_usec = (__suseconds_t )0;
                }
              }
            }
#line 363
            if (mbig) {
#line 363
              if (mdiff == 1L) {
                {
#line 363
                tmp___14 = get_stat_mtime_ns((struct stat  const  *)(& st));
                }
#line 363
                if (tmp___14 == 0L) {
#line 365
                  tt = truncated_timeval;
#line 366
                  (tt + 1)->tv_usec = (__suseconds_t )0;
                }
              }
            }
#line 368
            if (tt) {
              {
#line 369
              futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)tt);
              }
            }
          }
        }
      }
#line 374
      return (0);
    }
  }
#line 380
  if (! file) {
#line 386
    return (-1);
  }
  {
#line 390
  tmp___17 = utimes(file, (struct timeval  const  *)t);
  }
#line 390
  return (tmp___17);
}
}
#line 412 "/home/wslee/gnu_benchmarks/patch-2.7/lib/utimens.c"
int utimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  int tmp ;

  {
  {
#line 415
  tmp = fdutimens(-1, file, timespec);
  }
#line 415
  return (tmp);
}
}
#line 422 "/home/wslee/gnu_benchmarks/patch-2.7/lib/utimens.c"
int lutimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int result ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
#line 426
  if (timespec) {
#line 426
    tmp = adjusted_timespec;
  } else {
#line 426
    tmp = (struct timespec *)((void *)0);
  }
#line 426
  ts = tmp;
#line 427
  adjustment_needed = 0;
#line 430
  if (ts) {
    {
#line 432
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 433
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 434
    adjustment_needed = validate_timespec((struct timespec *)ts);
    }
  }
#line 436
  if (adjustment_needed < 0) {
#line 437
    return (-1);
  }
#line 445
  if (0 <= lutimensat_works_really) {
#line 457
    if (adjustment_needed == 2) {
      {
#line 459
      tmp___0 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
      }
#line 459
      if (tmp___0) {
#line 460
        return (-1);
      }
#line 461
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 462
        *(ts + 0) = get_stat_atime((struct stat  const  *)(& st));
        }
      } else
#line 463
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 464
        *(ts + 1) = get_stat_mtime((struct stat  const  *)(& st));
        }
      }
#line 466
      adjustment_needed ++;
    }
    {
#line 469
    result = utimensat(-100, file, (struct timespec  const  *)ts, 256);
    }
#line 478
    if (0 < result) {
      {
#line 479
      tmp___1 = __errno_location();
#line 479
      *tmp___1 = 38;
      }
    }
#line 481
    if (result == 0) {
#line 483
      utimensat_works_really = 1;
#line 484
      lutimensat_works_really = 1;
#line 485
      return (result);
    } else {
      {
#line 481
      tmp___2 = __errno_location();
      }
#line 481
      if (*tmp___2 != 38) {
#line 483
        utimensat_works_really = 1;
#line 484
        lutimensat_works_really = 1;
#line 485
        return (result);
      }
    }
  }
#line 488
  lutimensat_works_really = -1;
#line 495
  if (adjustment_needed) {
#line 495
    goto _L;
  } else
#line 495
  if (0) {
    _L: /* CIL Label */ 
#line 497
    if (adjustment_needed != 3) {
      {
#line 497
      tmp___3 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
      }
#line 497
      if (tmp___3) {
#line 498
        return (-1);
      }
    }
#line 499
    if (ts) {
      {
#line 499
      tmp___4 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
      }
#line 499
      if (tmp___4) {
#line 500
        return (0);
      }
    }
  }
#line 528
  if (! adjustment_needed) {
    {
#line 528
    tmp___5 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
    }
#line 528
    if (tmp___5) {
#line 529
      return (-1);
    }
  }
#line 530
  if (! ((st.st_mode & 61440U) == 40960U)) {
    {
#line 531
    tmp___6 = fdutimens(-1, file, (struct timespec  const  *)ts);
    }
#line 531
    return (tmp___6);
  }
  {
#line 532
  tmp___7 = __errno_location();
#line 532
  *tmp___7 = 38;
  }
#line 533
  return (-1);
}
}
#line 48 "/home/wslee/gnu_benchmarks/patch-2.7/lib/tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 321 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 623 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 179 "/home/wslee/gnu_benchmarks/patch-2.7/lib/tempname.c"
static char const   letters[63]  = 
#line 179 "/home/wslee/gnu_benchmarks/patch-2.7/lib/tempname.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 200 "/home/wslee/gnu_benchmarks/patch-2.7/lib/tempname.c"
static uint64_t value  ;
#line 195 "/home/wslee/gnu_benchmarks/patch-2.7/lib/tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ 
  int len ;
  char *XXXXXX ;
  uint64_t random_time_bits ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  struct stat st ;
  unsigned int attempts ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  struct timeval tv ;
  __pid_t tmp___3 ;
  uint64_t v ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 203
  fd = -1;
#line 204
  tmp = __errno_location();
#line 204
  save_errno = *tmp;
#line 220
  attempts = 238328U;
#line 223
  tmp___0 = strlen((char const   *)tmpl);
#line 223
  len = (int )tmp___0;
  }
#line 224
  if (len < 6 + suffixlen) {
    {
#line 226
    tmp___1 = __errno_location();
#line 226
    *tmp___1 = 22;
    }
#line 227
    return (-1);
  } else {
    {
#line 224
    tmp___2 = memcmp((void const   *)(tmpl + ((len - 6) - suffixlen)), (void const   *)"XXXXXX",
                     (size_t )6);
    }
#line 224
    if (tmp___2) {
      {
#line 226
      tmp___1 = __errno_location();
#line 226
      *tmp___1 = 22;
      }
#line 227
      return (-1);
    }
  }
  {
#line 231
  XXXXXX = tmpl + ((len - 6) - suffixlen);
#line 239
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 240
  random_time_bits = ((uint64_t )tv.tv_usec << 16) ^ (unsigned long )tv.tv_sec;
#line 243
  tmp___3 = getpid();
#line 243
  value += random_time_bits ^ (unsigned long )tmp___3;
#line 245
  count = 0U;
  }
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (count < attempts)) {
#line 245
      goto while_break;
    }
#line 247
    v = value;
#line 250
    *(XXXXXX + 0) = (char )letters[v % 62UL];
#line 251
    v /= 62UL;
#line 252
    *(XXXXXX + 1) = (char )letters[v % 62UL];
#line 253
    v /= 62UL;
#line 254
    *(XXXXXX + 2) = (char )letters[v % 62UL];
#line 255
    v /= 62UL;
#line 256
    *(XXXXXX + 3) = (char )letters[v % 62UL];
#line 257
    v /= 62UL;
#line 258
    *(XXXXXX + 4) = (char )letters[v % 62UL];
#line 259
    v /= 62UL;
#line 260
    *(XXXXXX + 5) = (char )letters[v % 62UL];
    {
#line 264
    if (kind == 0) {
#line 264
      goto case_0;
    }
#line 270
    if (kind == 1) {
#line 270
      goto case_1;
    }
#line 274
    if (kind == 2) {
#line 274
      goto case_2;
    }
#line 292
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 265
    fd = open((char const   *)tmpl, (((flags & -4) | 2) | 64) | 128, 384);
    }
#line 268
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 271
    fd = mkdir((char const   *)tmpl, (__mode_t )448);
    }
#line 272
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 279
    tmp___6 = lstat((char const   */* __restrict  */)tmpl, (struct stat */* __restrict  */)(& st));
    }
#line 279
    if (tmp___6 < 0) {
      {
#line 281
      tmp___5 = __errno_location();
      }
#line 281
      if (*tmp___5 == 2) {
        {
#line 283
        tmp___4 = __errno_location();
#line 283
        *tmp___4 = save_errno;
        }
#line 284
        return (0);
      } else {
#line 288
        return (-1);
      }
    }
#line 290
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 293
    __assert_fail("! \"invalid KIND in __gen_tempname\"", "/home/wslee/gnu_benchmarks/patch-2.7/lib/tempname.c",
                  293U, "gen_tempname");
#line 294
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 297
    if (fd >= 0) {
      {
#line 299
      tmp___7 = __errno_location();
#line 299
      *tmp___7 = save_errno;
      }
#line 300
      return (fd);
    } else {
      {
#line 302
      tmp___8 = __errno_location();
      }
#line 302
      if (*tmp___8 != 17) {
#line 303
        return (-1);
      }
    }
    __Cont: /* CIL Label */ 
#line 245
    value += 7777UL;
#line 245
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  tmp___9 = __errno_location();
#line 307
  *tmp___9 = 17;
  }
#line 308
  return (-1);
}
}
#line 40 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 42
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 44
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/wslee/gnu_benchmarks/patch-2.7/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 37 "/home/wslee/gnu_benchmarks/patch-2.7/lib/safe-write.h"
size_t safe_write(int fd , void const   *buf___0 , size_t count ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 55 "/home/wslee/gnu_benchmarks/patch-2.7/lib/safe-read.c"
size_t safe_write(int fd , void const   *buf___0 , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = write(fd, buf___0, count);
#line 66
    result = tmp;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      tmp___1 = __errno_location();
      }
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
        {
#line 72
        tmp___0 = __errno_location();
        }
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 236 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 237
enum quoting_style  const  quoting_style_vals[8] ;
#line 247
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 250
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 254
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 263
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 269
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 280
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 295
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 302
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 311
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 321
char *quotearg_n(int n , char const   *arg ) ;
#line 324
char *quotearg(char const   *arg ) ;
#line 329
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 332
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 337
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 342
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 346
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 349
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 354
char *quotearg_char(char const   *arg , char ch ) ;
#line 357
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 360
char *quotearg_colon(char const   *arg ) ;
#line 363
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 369
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 374
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 379
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 384
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 389
void quotearg_free(void) ;
#line 23 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quote.h"
struct quoting_options quote_quoting_options ;
#line 27
char const   *quote_n(int n , char const   *name ) ;
#line 31
char const   *quote(char const   *name ) ;
#line 106 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 221
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 223
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 223 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 226
  if (sizeof(char ) == 1UL) {
    {
#line 226
    tmp = xmalloc(n);
#line 226
    tmp___1 = tmp;
    }
  } else {
    {
#line 226
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 226
    tmp___1 = tmp___0;
    }
  }
#line 226
  return ((char *)tmp___1);
}
}
#line 42 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 32 "/home/wslee/gnu_benchmarks/patch-2.7/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 359 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 137 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 75 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 75 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 89 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 89
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 102 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 107 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 110
  tmp = __errno_location();
#line 110
  e = *tmp;
  }
#line 111
  if (o) {
#line 111
    tmp___0 = o;
  } else {
#line 111
    tmp___0 = & default_quoting_options;
  }
  {
#line 111
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 111
  p = (struct quoting_options *)tmp___1;
#line 113
  tmp___2 = __errno_location();
#line 113
  *tmp___2 = e;
  }
#line 114
  return (p);
}
}
#line 118 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 121
  if (o) {
#line 121
    tmp = o;
  } else {
#line 121
    tmp = & default_quoting_options;
  }
#line 121
  return (tmp->style);
}
}
#line 126 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 129
  if (o) {
#line 129
    tmp = o;
  } else {
#line 129
    tmp = & default_quoting_options;
  }
#line 129
  tmp->style = s;
#line 130
  return;
}
}
#line 137 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 140
  uc = (unsigned char )c;
#line 141
  if (o) {
#line 141
    tmp = o;
  } else {
#line 141
    tmp = & default_quoting_options;
  }
#line 141
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 143
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 144
  r = (int )((*p >> shift) & 1U);
#line 145
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 146
  return (r);
}
}
#line 153 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 157
  if (! o) {
#line 158
    o = & default_quoting_options;
  }
#line 159
  r = o->flags;
#line 160
  o->flags = i;
#line 161
  return (r);
}
}
#line 164 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 168
  if (! o) {
#line 169
    o = & default_quoting_options;
  }
#line 170
  o->style = (enum quoting_style )8;
#line 171
  if (! left_quote) {
    {
#line 172
    abort();
    }
  } else
#line 171
  if (! right_quote) {
    {
#line 172
    abort();
    }
  }
#line 173
  o->left_quote = left_quote;
#line 174
  o->right_quote = right_quote;
#line 175
  return;
}
}
#line 178 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
#line 181
  o.style = (enum quoting_style )0;
#line 181
  o.flags = 0;
#line 181
  o.quote_these_too[0] = 0U;
#line 181
  tmp = 1U;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (tmp >= 8U) {
#line 181
      goto while_break;
    }
#line 181
    o.quote_these_too[tmp] = 0U;
#line 181
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  o.left_quote = (char const   *)((void *)0);
#line 181
  o.right_quote = (char const   *)((void *)0);
#line 182
  if ((unsigned int )style == 8U) {
    {
#line 183
    abort();
    }
  }
#line 184
  o.style = style;
#line 185
  return (o);
}
}
#line 192 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char const   *locale_code ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 195
  translation = msgid;
#line 198
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 199
    return (translation);
  }
  {
#line 219
  locale_code = locale_charset();
#line 220
  tmp___0 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 220
  if (tmp___0 == 0) {
#line 221
    if ((int const   )*(msgid + 0) == 96) {
#line 221
      tmp = "\342\200\230";
    } else {
#line 221
      tmp = "\342\200\231";
    }
#line 221
    return (tmp);
  }
  {
#line 222
  tmp___2 = c_strcasecmp(locale_code, "GB18030");
  }
#line 222
  if (tmp___2 == 0) {
#line 223
    if ((int const   )*(msgid + 0) == 96) {
#line 223
      tmp___1 = "\241\ae";
    } else {
#line 223
      tmp___1 = "\241\257";
    }
#line 223
    return (tmp___1);
  }
#line 225
  if ((unsigned int )s == 7U) {
#line 225
    tmp___3 = "\"";
  } else {
#line 225
    tmp___3 = "\'";
  }
#line 225
  return (tmp___3);
}
}
#line 241 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 250
  len = (size_t )0;
#line 251
  quote_string = (char const   *)0;
#line 252
  quote_string_len = (size_t )0;
#line 253
  backslash_escapes = (_Bool)0;
#line 254
  tmp = __ctype_get_mb_cur_max();
#line 254
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 255
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 268
  if ((unsigned int )quoting_style == 4U) {
#line 268
    goto case_4;
  }
#line 272
  if ((unsigned int )quoting_style == 3U) {
#line 272
    goto case_3;
  }
#line 280
  if ((unsigned int )quoting_style == 5U) {
#line 280
    goto case_5;
  }
#line 287
  if ((unsigned int )quoting_style == 8U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 7U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 6U) {
#line 287
    goto case_8;
  }
#line 324
  if ((unsigned int )quoting_style == 1U) {
#line 324
    goto case_1;
  }
#line 328
  if ((unsigned int )quoting_style == 2U) {
#line 328
    goto case_2;
  }
#line 335
  if ((unsigned int )quoting_style == 0U) {
#line 335
    goto case_0;
  }
#line 339
  goto switch_default;
  case_4: /* CIL Label */ 
#line 269
  quoting_style = (enum quoting_style )3;
#line 270
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 273
  if (! elide_outer_quotes) {
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (len < buffersize) {
#line 274
        *(buffer + len) = (char )'\"';
      }
#line 274
      len ++;
#line 274
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 275
  backslash_escapes = (_Bool)1;
#line 276
  quote_string = "\"";
#line 277
  quote_string_len = (size_t )1;
#line 278
  goto switch_break;
  case_5: /* CIL Label */ 
#line 281
  backslash_escapes = (_Bool)1;
#line 282
  elide_outer_quotes = (_Bool)0;
#line 283
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 289
  if ((unsigned int )quoting_style != 8U) {
    {
#line 312
    left_quote = gettext_quote("`", quoting_style);
#line 313
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 315
  if (! elide_outer_quotes) {
#line 316
    quote_string = left_quote;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! *quote_string) {
#line 316
        goto while_break___0;
      }
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (len < buffersize) {
#line 317
          *(buffer + len) = (char )*quote_string;
        }
#line 317
        len ++;
#line 317
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 316
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 318
  backslash_escapes = (_Bool)1;
#line 319
  quote_string = right_quote;
#line 320
  quote_string_len = strlen(quote_string);
  }
#line 322
  goto switch_break;
  case_1: /* CIL Label */ 
#line 325
  quoting_style = (enum quoting_style )2;
#line 326
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 329
  if (! elide_outer_quotes) {
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 330
      if (len < buffersize) {
#line 330
        *(buffer + len) = (char )'\'';
      }
#line 330
      len ++;
#line 330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 331
  quote_string = "\'";
#line 332
  quote_string_len = (size_t )1;
#line 333
  goto switch_break;
  case_0: /* CIL Label */ 
#line 336
  elide_outer_quotes = (_Bool)0;
#line 337
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 340
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 343
  i = (size_t )0;
  {
#line 343
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 343
    if (argsize == 0xffffffffffffffffUL) {
#line 343
      tmp___6 = (int const   )*(arg + i) == 0;
    } else {
#line 343
      tmp___6 = i == argsize;
    }
#line 343
    if (tmp___6) {
#line 343
      goto while_break___3;
    }
#line 347
    is_right_quote = (_Bool)0;
#line 349
    if (backslash_escapes) {
#line 349
      if (quote_string_len) {
#line 349
        if (i + quote_string_len <= argsize) {
          {
#line 349
          tmp___0 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 349
          if (tmp___0 == 0) {
#line 354
            if (elide_outer_quotes) {
#line 355
              goto force_outer_quoting_style;
            }
#line 356
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 359
    c = (unsigned char )*(arg + i);
    {
#line 362
    if ((int )c == 0) {
#line 362
      goto case_0___0;
    }
#line 388
    if ((int )c == 63) {
#line 388
      goto case_63;
    }
#line 426
    if ((int )c == 7) {
#line 426
      goto case_7___0;
    }
#line 427
    if ((int )c == 8) {
#line 427
      goto case_8___0;
    }
#line 428
    if ((int )c == 12) {
#line 428
      goto case_12;
    }
#line 429
    if ((int )c == 10) {
#line 429
      goto case_10;
    }
#line 430
    if ((int )c == 13) {
#line 430
      goto case_13;
    }
#line 431
    if ((int )c == 9) {
#line 431
      goto case_9;
    }
#line 432
    if ((int )c == 11) {
#line 432
      goto case_11;
    }
#line 433
    if ((int )c == 92) {
#line 433
      goto case_92;
    }
#line 452
    if ((int )c == 125) {
#line 452
      goto case_125;
    }
#line 452
    if ((int )c == 123) {
#line 452
      goto case_125;
    }
#line 456
    if ((int )c == 126) {
#line 456
      goto case_126;
    }
#line 456
    if ((int )c == 35) {
#line 456
      goto case_126;
    }
#line 468
    if ((int )c == 124) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 96) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 94) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 91) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 62) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 61) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 60) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 59) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 42) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 41) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 40) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 38) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 36) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 34) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 33) {
#line 468
      goto case_124;
    }
#line 468
    if ((int )c == 32) {
#line 468
      goto case_124;
    }
#line 478
    if ((int )c == 39) {
#line 478
      goto case_39___0;
    }
#line 500
    if ((int )c == 122) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 121) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 120) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 119) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 118) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 117) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 116) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 115) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 114) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 113) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 112) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 111) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 110) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 109) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 108) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 107) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 106) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 105) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 104) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 103) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 102) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 101) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 100) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 99) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 98) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 97) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 95) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 93) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 90) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 89) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 88) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 87) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 86) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 85) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 84) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 83) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 82) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 81) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 80) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 79) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 78) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 77) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 76) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 75) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 74) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 73) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 72) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 71) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 70) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 69) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 68) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 67) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 66) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 65) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 58) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 57) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 56) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 55) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 54) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 53) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 52) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 51) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 50) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 49) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 48) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 47) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 46) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 45) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 44) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 43) {
#line 500
      goto case_122;
    }
#line 500
    if ((int )c == 37) {
#line 500
      goto case_122;
    }
#line 513
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 363
    if (backslash_escapes) {
#line 365
      if (elide_outer_quotes) {
#line 366
        goto force_outer_quoting_style;
      }
      {
#line 367
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 367
        if (len < buffersize) {
#line 367
          *(buffer + len) = (char )'\\';
        }
#line 367
        len ++;
#line 367
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 373
      if (i + 1UL < argsize) {
#line 373
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 373
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            {
#line 375
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 375
              if (len < buffersize) {
#line 375
                *(buffer + len) = (char )'0';
              }
#line 375
              len ++;
#line 375
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 376
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 376
              if (len < buffersize) {
#line 376
                *(buffer + len) = (char )'0';
              }
#line 376
              len ++;
#line 376
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 378
      c = (unsigned char )'0';
    } else
#line 384
    if (flags & 1) {
#line 385
      goto __Cont;
    }
#line 386
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 391
    if ((unsigned int )quoting_style == 2U) {
#line 391
      goto case_2___0;
    }
#line 396
    if ((unsigned int )quoting_style == 3U) {
#line 396
      goto case_3___0;
    }
#line 421
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 392
    if (elide_outer_quotes) {
#line 393
      goto force_outer_quoting_style;
    }
#line 394
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 397
    if (flags & 4) {
#line 397
      if (i + 2UL < argsize) {
#line 397
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 403
            goto case_62;
          }
#line 403
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 403
            goto case_62;
          }
#line 416
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 406
          if (elide_outer_quotes) {
#line 407
            goto force_outer_quoting_style;
          }
#line 408
          c = (unsigned char )*(arg + (i + 2UL));
#line 409
          i += 2UL;
          {
#line 410
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 410
            if (len < buffersize) {
#line 410
              *(buffer + len) = (char )'?';
            }
#line 410
            len ++;
#line 410
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 411
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 411
            if (len < buffersize) {
#line 411
              *(buffer + len) = (char )'\"';
            }
#line 411
            len ++;
#line 411
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 412
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 412
            if (len < buffersize) {
#line 412
              *(buffer + len) = (char )'\"';
            }
#line 412
            len ++;
#line 412
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 413
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 413
            if (len < buffersize) {
#line 413
              *(buffer + len) = (char )'?';
            }
#line 413
            len ++;
#line 413
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 414
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 417
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 419
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 422
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 424
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 426
    esc = (unsigned char )'a';
#line 426
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 427
    esc = (unsigned char )'b';
#line 427
    goto c_escape;
    case_12: /* CIL Label */ 
#line 428
    esc = (unsigned char )'f';
#line 428
    goto c_escape;
    case_10: /* CIL Label */ 
#line 429
    esc = (unsigned char )'n';
#line 429
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 430
    esc = (unsigned char )'r';
#line 430
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 431
    esc = (unsigned char )'t';
#line 431
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 432
    esc = (unsigned char )'v';
#line 432
    goto c_escape;
    case_92: /* CIL Label */ 
#line 433
    esc = c;
#line 436
    if (backslash_escapes) {
#line 436
      if (elide_outer_quotes) {
#line 436
        if (quote_string_len) {
#line 437
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 440
    if ((unsigned int )quoting_style == 2U) {
#line 440
      if (elide_outer_quotes) {
#line 442
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 445
    if (backslash_escapes) {
#line 447
      c = esc;
#line 448
      goto store_escape;
    }
#line 450
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 453
    if (argsize == 0xffffffffffffffffUL) {
#line 453
      tmp___1 = (int const   )*(arg + 1) == 0;
    } else {
#line 453
      tmp___1 = argsize == 1UL;
    }
#line 453
    if (! tmp___1) {
#line 454
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 457
    if (i != 0UL) {
#line 458
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 473
    if ((unsigned int )quoting_style == 2U) {
#line 473
      if (elide_outer_quotes) {
#line 475
        goto force_outer_quoting_style;
      }
    }
#line 476
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 479
    if ((unsigned int )quoting_style == 2U) {
#line 481
      if (elide_outer_quotes) {
#line 482
        goto force_outer_quoting_style;
      }
      {
#line 483
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 483
        if (len < buffersize) {
#line 483
          *(buffer + len) = (char )'\'';
        }
#line 483
        len ++;
#line 483
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 484
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 484
        if (len < buffersize) {
#line 484
          *(buffer + len) = (char )'\\';
        }
#line 484
        len ++;
#line 484
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 485
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 485
        if (len < buffersize) {
#line 485
          *(buffer + len) = (char )'\'';
        }
#line 485
        len ++;
#line 485
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 487
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 511
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 525
    if (unibyte_locale) {
      {
#line 527
      m = (size_t )1;
#line 528
      tmp___2 = __ctype_b_loc();
#line 528
      printable = (_Bool )(((int const   )*(*tmp___2 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 533
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 535
      m = (size_t )0;
#line 536
      printable = (_Bool)1;
      }
#line 537
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 538
        argsize = strlen(arg);
        }
      }
      {
#line 540
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 543
        tmp___3 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), & mbstate);
#line 543
        bytes = tmp___3;
        }
#line 545
        if (bytes == 0UL) {
#line 546
          goto while_break___14;
        } else
#line 547
        if (bytes == 0xffffffffffffffffUL) {
#line 549
          printable = (_Bool)0;
#line 550
          goto while_break___14;
        } else
#line 552
        if (bytes == 0xfffffffffffffffeUL) {
#line 554
          printable = (_Bool)0;
          {
#line 555
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 555
            if (i + m < argsize) {
#line 555
              if (! *(arg + (i + m))) {
#line 555
                goto while_break___15;
              }
            } else {
#line 555
              goto while_break___15;
            }
#line 556
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 557
          goto while_break___14;
        } else {
#line 565
          if (elide_outer_quotes) {
#line 565
            if ((unsigned int )quoting_style == 2U) {
#line 569
              j = (size_t )1;
              {
#line 569
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 569
                if (! (j < bytes)) {
#line 569
                  goto while_break___16;
                }
                {
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 573
                  goto case_124___0;
                }
#line 573
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 573
                  goto case_124___0;
                }
#line 576
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 574
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 577
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 569
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 581
          tmp___4 = iswprint((wint_t )w);
          }
#line 581
          if (! tmp___4) {
#line 582
            printable = (_Bool)0;
          }
#line 583
          m += bytes;
        }
        {
#line 540
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 540
        if (tmp___5) {
#line 540
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 589
    if (1UL < m) {
#line 589
      goto _L___0;
    } else
#line 589
    if (backslash_escapes) {
#line 589
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 593
        ilim = i + m;
        {
#line 595
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 597
          if (backslash_escapes) {
#line 597
            if (! printable) {
#line 599
              if (elide_outer_quotes) {
#line 600
                goto force_outer_quoting_style;
              }
              {
#line 601
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 601
                if (len < buffersize) {
#line 601
                  *(buffer + len) = (char )'\\';
                }
#line 601
                len ++;
#line 601
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 602
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 602
                if (len < buffersize) {
#line 602
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 602
                len ++;
#line 602
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 603
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 603
                if (len < buffersize) {
#line 603
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 603
                len ++;
#line 603
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 604
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 597
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 606
          if (is_right_quote) {
            {
#line 608
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 608
              if (len < buffersize) {
#line 608
                *(buffer + len) = (char )'\\';
              }
#line 608
              len ++;
#line 608
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 609
            is_right_quote = (_Bool)0;
          }
#line 611
          if (ilim <= i + 1UL) {
#line 612
            goto while_break___17;
          }
          {
#line 613
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 613
            if (len < buffersize) {
#line 613
              *(buffer + len) = (char )c;
            }
#line 613
            len ++;
#line 613
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 614
          i ++;
#line 614
          c = (unsigned char )*(arg + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 617
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 622
    if (backslash_escapes) {
#line 622
      goto _L___3;
    } else
#line 622
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 622
      if (quote_these_too) {
#line 622
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 622
          goto _L___2;
        }
      } else {
#line 622
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 622
    if (! is_right_quote) {
#line 626
      goto store_c;
    }
    store_escape: 
#line 629
    if (elide_outer_quotes) {
#line 630
      goto force_outer_quoting_style;
    }
    {
#line 631
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 631
      if (len < buffersize) {
#line 631
        *(buffer + len) = (char )'\\';
      }
#line 631
      len ++;
#line 631
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 634
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 634
      if (len < buffersize) {
#line 634
        *(buffer + len) = (char )c;
      }
#line 634
      len ++;
#line 634
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 343
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 637
  if (len == 0UL) {
#line 637
    if ((unsigned int )quoting_style == 2U) {
#line 637
      if (elide_outer_quotes) {
#line 639
        goto force_outer_quoting_style;
      }
    }
  }
#line 641
  if (quote_string) {
#line 641
    if (! elide_outer_quotes) {
      {
#line 642
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 642
        if (! *quote_string) {
#line 642
          goto while_break___25;
        }
        {
#line 643
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 643
          if (len < buffersize) {
#line 643
            *(buffer + len) = (char )*quote_string;
          }
#line 643
          len ++;
#line 643
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 642
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 645
  if (len < buffersize) {
#line 646
    *(buffer + len) = (char )'\000';
  }
#line 647
  return (len);
  force_outer_quoting_style: 
  {
#line 652
  tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 652
  return (tmp___7);
}
}
#line 667 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 672
  if (o) {
#line 672
    tmp = o;
  } else {
#line 672
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 672
  p = tmp;
#line 673
  tmp___0 = __errno_location();
#line 673
  e = *tmp___0;
#line 674
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 674
  r = tmp___1;
#line 677
  tmp___2 = __errno_location();
#line 677
  *tmp___2 = e;
  }
#line 678
  return (r);
}
}
#line 682 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 686
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 686
  return (tmp);
}
}
#line 695 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *buf___0 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 699
  if (o) {
#line 699
    tmp = o;
  } else {
#line 699
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 699
  p = tmp;
#line 700
  tmp___0 = __errno_location();
#line 700
  e = *tmp___0;
  }
#line 702
  if (size) {
#line 702
    tmp___1 = 0;
  } else {
#line 702
    tmp___1 = 1;
  }
  {
#line 702
  flags = (int )(p->flags | (int const   )tmp___1);
#line 703
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 703
  bufsize___0 = tmp___2 + 1UL;
#line 707
  tmp___3 = xcharalloc(bufsize___0);
#line 707
  buf___0 = tmp___3;
#line 708
  quotearg_buffer_restyled(buf___0, bufsize___0, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 711
  tmp___4 = __errno_location();
#line 711
  *tmp___4 = e;
  }
#line 712
  if (size) {
#line 713
    *size = bufsize___0 - 1UL;
  }
#line 714
  return (buf___0);
}
}
#line 726 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
static char slot0[256]  ;
#line 727 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
static unsigned int nslots  =    1U;
#line 728 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 729 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 731 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 734
  sv = slotvec;
#line 736
  i = 1U;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (i < nslots)) {
#line 736
      goto while_break;
    }
    {
#line 737
    free((void *)(sv + i)->val);
#line 736
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 740
    free((void *)(sv + 0)->val);
#line 741
    slotvec0.size = sizeof(slot0);
#line 742
    slotvec0.val = slot0;
    }
  }
#line 744
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 746
    free((void *)sv);
#line 747
    slotvec = & slotvec0;
    }
  }
#line 749
  nslots = 1U;
#line 750
  return;
}
}
#line 760 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 764
  tmp = __errno_location();
#line 764
  e = *tmp;
#line 766
  n0 = (unsigned int )n;
#line 767
  sv = slotvec;
  }
#line 769
  if (n < 0) {
    {
#line 770
    abort();
    }
  }
#line 772
  if (nslots <= n0) {
#line 779
    n1 = (size_t )(n0 + 1U);
#line 780
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 782
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 782
      tmp___0 = -1;
    } else {
#line 782
      tmp___0 = -2;
    }
#line 782
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 783
      xalloc_die();
      }
    }
#line 785
    if (preallocated) {
#line 785
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 785
      tmp___1 = sv;
    }
    {
#line 785
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 785
    sv = (struct slotvec *)tmp___2;
#line 785
    slotvec = sv;
    }
#line 786
    if (preallocated) {
#line 787
      *sv = slotvec0;
    }
    {
#line 788
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 789
    nslots = (unsigned int )n1;
    }
  }
  {
#line 793
  size = (sv + n)->size;
#line 794
  val = (sv + n)->val;
#line 796
  flags = (int )(options->flags | 1);
#line 797
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 797
  qsize = tmp___3;
  }
#line 803
  if (size <= qsize) {
#line 805
    size = qsize + 1UL;
#line 805
    (sv + n)->size = size;
#line 806
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 807
      free((void *)val);
      }
    }
    {
#line 808
    val = xcharalloc(size);
#line 808
    (sv + n)->val = val;
#line 809
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 815
  tmp___4 = __errno_location();
#line 815
  *tmp___4 = e;
  }
#line 816
  return (val);
}
}
#line 820 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 823
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 823
  return (tmp);
}
}
#line 826 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 829
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 829
  return (tmp);
}
}
#line 832 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 835
  tmp = quotearg_n(0, arg);
  }
#line 835
  return (tmp);
}
}
#line 838 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 841
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 841
  return (tmp);
}
}
#line 844 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 847
  tmp = quoting_options_from_style(s);
#line 847
  o = tmp;
#line 848
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 848
  return (tmp___0);
}
}
#line 851 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
#line 855
  tmp = quoting_options_from_style(s);
#line 855
  o = tmp;
#line 856
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 856
  return (tmp___0);
}
}
#line 859 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 862
  tmp = quotearg_n_style(0, s, arg);
  }
#line 862
  return (tmp);
}
}
#line 865 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 868
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 868
  return (tmp);
}
}
#line 871 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 875
  options = default_quoting_options;
#line 876
  set_char_quoting(& options, ch, 1);
#line 877
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 877
  return (tmp);
}
}
#line 880 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 883
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 883
  return (tmp);
}
}
#line 886 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 889
  tmp = quotearg_char(arg, (char )':');
  }
#line 889
  return (tmp);
}
}
#line 892 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 895
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 895
  return (tmp);
}
}
#line 898 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 902
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
  }
#line 902
  return (tmp);
}
}
#line 906 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 911
  o = default_quoting_options;
#line 912
  set_custom_quoting(& o, left_quote, right_quote);
#line 913
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 913
  return (tmp);
}
}
#line 916 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 920
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 920
  return (tmp);
}
}
#line 923 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 927
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 927
  return (tmp);
}
}
#line 933 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )6, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 941 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 944
  tmp = quotearg_n_options(n, name, (size_t )-1, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 944
  return ((char const   *)tmp);
}
}
#line 947 "/home/wslee/gnu_benchmarks/patch-2.7/lib/quotearg.c"
char const   *quote(char const   *name ) 
{ 
  char const   *tmp ;

  {
  {
#line 950
  tmp = quote_n(0, name);
  }
#line 950
  return (tmp);
}
}
#line 32 "/home/wslee/gnu_benchmarks/patch-2.7/lib/progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 55 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 55
extern char *program_invocation_short_name ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 33 "/home/wslee/gnu_benchmarks/patch-2.7/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "/home/wslee/gnu_benchmarks/patch-2.7/lib/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 54
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
  }
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7L) {
    {
#line 61
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 61
    if (tmp___1 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 64
      if (tmp___0 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 82 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  char c ;
  char const   *tmp ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___2 ;
  size_t __attribute__((__pure__))  tmp___3 ;
  size_t tmp___4 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___10 ;
  size_t __attribute__((__pure__))  tmp___11 ;
  size_t tmp___12 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___18 ;
  size_t tmp___19 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;

  {
#line 85
  cp = format;
#line 86
  arg_posn = (size_t )0;
#line 89
  max_width_length = (size_t )0;
#line 90
  max_precision_length = (size_t )0;
#line 92
  d->count = (size_t )0;
#line 93
  d_allocated = (size_t )7;
#line 94
  d->dir = d->direct_alloc_dir;
#line 96
  a->count = (size_t )0;
#line 97
  a_allocated = (size_t )7;
#line 98
  a->arg = a->direct_alloc_arg;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((int const   )*cp != 0)) {
#line 134
      goto while_break;
    }
#line 136
    tmp = cp;
#line 136
    cp ++;
#line 136
    c = (char )*tmp;
#line 137
    if ((int )c == 37) {
#line 139
      arg_index = ~ ((size_t )0);
#line 140
      dp = d->dir + d->count;
#line 143
      dp->dir_start = cp - 1;
#line 144
      dp->flags = 0;
#line 145
      dp->width_start = (char const   *)((void *)0);
#line 146
      dp->width_end = (char const   *)((void *)0);
#line 147
      dp->width_arg_index = ~ ((size_t )0);
#line 148
      dp->precision_start = (char const   *)((void *)0);
#line 149
      dp->precision_end = (char const   *)((void *)0);
#line 150
      dp->precision_arg_index = ~ ((size_t )0);
#line 151
      dp->arg_index = ~ ((size_t )0);
#line 154
      if ((int const   )*cp >= 48) {
#line 154
        if ((int const   )*cp <= 57) {
#line 158
          np = cp;
          {
#line 158
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 158
            if ((int const   )*np >= 48) {
#line 158
              if (! ((int const   )*np <= 57)) {
#line 158
                goto while_break___0;
              }
            } else {
#line 158
              goto while_break___0;
            }
#line 158
            np ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 160
          if ((int const   )*np == 36) {
#line 162
            n = (size_t )0;
#line 164
            np = cp;
            {
#line 164
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 164
              if ((int const   )*np >= 48) {
#line 164
                if (! ((int const   )*np <= 57)) {
#line 164
                  goto while_break___1;
                }
              } else {
#line 164
                goto while_break___1;
              }
#line 165
              if (n <= 1844674407370955161UL) {
#line 165
                tmp___0 = n * 10UL;
              } else {
#line 165
                tmp___0 = 0xffffffffffffffffUL;
              }
              {
#line 165
              tmp___1 = xsum(tmp___0, (size_t )((int const   )*np - 48));
#line 165
              n = (size_t )tmp___1;
#line 164
              np ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 166
            if (n == 0UL) {
#line 168
              goto error;
            }
#line 169
            if (n == 0xffffffffffffffffUL) {
#line 171
              goto error;
            }
#line 172
            arg_index = n - 1UL;
#line 173
            cp = np + 1;
          }
        }
      }
      {
#line 178
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 180
        if ((int const   )*cp == 39) {
#line 182
          dp->flags |= 1;
#line 183
          cp ++;
        } else
#line 185
        if ((int const   )*cp == 45) {
#line 187
          dp->flags |= 2;
#line 188
          cp ++;
        } else
#line 190
        if ((int const   )*cp == 43) {
#line 192
          dp->flags |= 4;
#line 193
          cp ++;
        } else
#line 195
        if ((int const   )*cp == 32) {
#line 197
          dp->flags |= 8;
#line 198
          cp ++;
        } else
#line 200
        if ((int const   )*cp == 35) {
#line 202
          dp->flags |= 16;
#line 203
          cp ++;
        } else
#line 205
        if ((int const   )*cp == 48) {
#line 207
          dp->flags |= 32;
#line 208
          cp ++;
        } else
#line 211
        if ((int const   )*cp == 73) {
#line 213
          dp->flags |= 64;
#line 214
          cp ++;
        } else {
#line 218
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 222
      if ((int const   )*cp == 42) {
#line 224
        dp->width_start = cp;
#line 225
        cp ++;
#line 226
        dp->width_end = cp;
#line 227
        if (max_width_length < 1UL) {
#line 228
          max_width_length = (size_t )1;
        }
#line 231
        if ((int const   )*cp >= 48) {
#line 231
          if ((int const   )*cp <= 57) {
#line 235
            np___0 = cp;
            {
#line 235
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 235
              if ((int const   )*np___0 >= 48) {
#line 235
                if (! ((int const   )*np___0 <= 57)) {
#line 235
                  goto while_break___3;
                }
              } else {
#line 235
                goto while_break___3;
              }
#line 235
              np___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 237
            if ((int const   )*np___0 == 36) {
#line 239
              n___0 = (size_t )0;
#line 241
              np___0 = cp;
              {
#line 241
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 241
                if ((int const   )*np___0 >= 48) {
#line 241
                  if (! ((int const   )*np___0 <= 57)) {
#line 241
                    goto while_break___4;
                  }
                } else {
#line 241
                  goto while_break___4;
                }
#line 242
                if (n___0 <= 1844674407370955161UL) {
#line 242
                  tmp___2 = n___0 * 10UL;
                } else {
#line 242
                  tmp___2 = 0xffffffffffffffffUL;
                }
                {
#line 242
                tmp___3 = xsum(tmp___2, (size_t )((int const   )*np___0 - 48));
#line 242
                n___0 = (size_t )tmp___3;
#line 241
                np___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 243
              if (n___0 == 0UL) {
#line 245
                goto error;
              }
#line 246
              if (n___0 == 0xffffffffffffffffUL) {
#line 248
                goto error;
              }
#line 249
              dp->width_arg_index = n___0 - 1UL;
#line 250
              cp = np___0 + 1;
            }
          }
        }
#line 253
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 255
          tmp___4 = arg_posn;
#line 255
          arg_posn ++;
#line 255
          dp->width_arg_index = tmp___4;
#line 256
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 258
            goto error;
          }
        }
#line 260
        n___1 = dp->width_arg_index;
#line 260
        if (n___1 >= a_allocated) {
#line 260
          if (a_allocated <= 9223372036854775807UL) {
#line 260
            a_allocated *= 2UL;
          } else {
#line 260
            a_allocated = 0xffffffffffffffffUL;
          }
#line 260
          if (a_allocated <= n___1) {
            {
#line 260
            tmp___5 = xsum(n___1, (size_t )1);
#line 260
            a_allocated = (size_t )tmp___5;
            }
          }
#line 260
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 260
            memory_size = a_allocated * sizeof(argument );
          } else {
#line 260
            memory_size = 0xffffffffffffffffUL;
          }
#line 260
          if (memory_size == 0xffffffffffffffffUL) {
#line 260
            goto out_of_memory;
          }
#line 260
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
#line 260
            tmp___6 = realloc((void *)a->arg, memory_size);
#line 260
            tmp___8 = tmp___6;
            }
          } else {
            {
#line 260
            tmp___7 = malloc(memory_size);
#line 260
            tmp___8 = tmp___7;
            }
          }
#line 260
          memory = (argument *)tmp___8;
#line 260
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 260
            goto out_of_memory;
          }
#line 260
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
#line 260
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)a->arg,
                   a->count * sizeof(argument ));
            }
          }
#line 260
          a->arg = memory;
        }
        {
#line 260
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 260
          if (! (a->count <= n___1)) {
#line 260
            goto while_break___5;
          }
#line 260
          tmp___9 = a->count;
#line 260
          (a->count) ++;
#line 260
          (a->arg + tmp___9)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 260
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 260
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 260
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 260
          goto error;
        }
      } else
#line 262
      if ((int const   )*cp >= 48) {
#line 262
        if ((int const   )*cp <= 57) {
#line 266
          dp->width_start = cp;
          {
#line 267
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 267
            if ((int const   )*cp >= 48) {
#line 267
              if (! ((int const   )*cp <= 57)) {
#line 267
                goto while_break___6;
              }
            } else {
#line 267
              goto while_break___6;
            }
#line 267
            cp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 269
          dp->width_end = cp;
#line 270
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 271
          if (max_width_length < width_length) {
#line 272
            max_width_length = width_length;
          }
        }
      }
#line 276
      if ((int const   )*cp == 46) {
#line 278
        cp ++;
#line 279
        if ((int const   )*cp == 42) {
#line 281
          dp->precision_start = cp - 1;
#line 282
          cp ++;
#line 283
          dp->precision_end = cp;
#line 284
          if (max_precision_length < 2UL) {
#line 285
            max_precision_length = (size_t )2;
          }
#line 288
          if ((int const   )*cp >= 48) {
#line 288
            if ((int const   )*cp <= 57) {
#line 292
              np___1 = cp;
              {
#line 292
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 292
                if ((int const   )*np___1 >= 48) {
#line 292
                  if (! ((int const   )*np___1 <= 57)) {
#line 292
                    goto while_break___7;
                  }
                } else {
#line 292
                  goto while_break___7;
                }
#line 292
                np___1 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 294
              if ((int const   )*np___1 == 36) {
#line 296
                n___2 = (size_t )0;
#line 298
                np___1 = cp;
                {
#line 298
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 298
                  if ((int const   )*np___1 >= 48) {
#line 298
                    if (! ((int const   )*np___1 <= 57)) {
#line 298
                      goto while_break___8;
                    }
                  } else {
#line 298
                    goto while_break___8;
                  }
#line 299
                  if (n___2 <= 1844674407370955161UL) {
#line 299
                    tmp___10 = n___2 * 10UL;
                  } else {
#line 299
                    tmp___10 = 0xffffffffffffffffUL;
                  }
                  {
#line 299
                  tmp___11 = xsum(tmp___10, (size_t )((int const   )*np___1 - 48));
#line 299
                  n___2 = (size_t )tmp___11;
#line 298
                  np___1 ++;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 300
                if (n___2 == 0UL) {
#line 302
                  goto error;
                }
#line 303
                if (n___2 == 0xffffffffffffffffUL) {
#line 306
                  goto error;
                }
#line 307
                dp->precision_arg_index = n___2 - 1UL;
#line 308
                cp = np___1 + 1;
              }
            }
          }
#line 311
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 313
            tmp___12 = arg_posn;
#line 313
            arg_posn ++;
#line 313
            dp->precision_arg_index = tmp___12;
#line 314
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 316
              goto error;
            }
          }
#line 318
          n___3 = dp->precision_arg_index;
#line 318
          if (n___3 >= a_allocated) {
#line 318
            if (a_allocated <= 9223372036854775807UL) {
#line 318
              a_allocated *= 2UL;
            } else {
#line 318
              a_allocated = 0xffffffffffffffffUL;
            }
#line 318
            if (a_allocated <= n___3) {
              {
#line 318
              tmp___13 = xsum(n___3, (size_t )1);
#line 318
              a_allocated = (size_t )tmp___13;
              }
            }
#line 318
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 318
              memory_size___0 = a_allocated * sizeof(argument );
            } else {
#line 318
              memory_size___0 = 0xffffffffffffffffUL;
            }
#line 318
            if (memory_size___0 == 0xffffffffffffffffUL) {
#line 318
              goto out_of_memory;
            }
#line 318
            if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
              {
#line 318
              tmp___14 = realloc((void *)a->arg, memory_size___0);
#line 318
              tmp___16 = tmp___14;
              }
            } else {
              {
#line 318
              tmp___15 = malloc(memory_size___0);
#line 318
              tmp___16 = tmp___15;
              }
            }
#line 318
            memory___0 = (argument *)tmp___16;
#line 318
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 318
              goto out_of_memory;
            }
#line 318
            if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
              {
#line 318
              memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)a->arg,
                     a->count * sizeof(argument ));
              }
            }
#line 318
            a->arg = memory___0;
          }
          {
#line 318
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 318
            if (! (a->count <= n___3)) {
#line 318
              goto while_break___9;
            }
#line 318
            tmp___17 = a->count;
#line 318
            (a->count) ++;
#line 318
            (a->arg + tmp___17)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 318
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 318
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 318
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 318
            goto error;
          }
        } else {
#line 324
          dp->precision_start = cp - 1;
          {
#line 325
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 325
            if ((int const   )*cp >= 48) {
#line 325
              if (! ((int const   )*cp <= 57)) {
#line 325
                goto while_break___10;
              }
            } else {
#line 325
              goto while_break___10;
            }
#line 325
            cp ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 327
          dp->precision_end = cp;
#line 328
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 329
          if (max_precision_length < precision_length) {
#line 330
            max_precision_length = precision_length;
          }
        }
      }
#line 339
      flags = 0;
      {
#line 341
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 343
        if ((int const   )*cp == 104) {
#line 345
          flags |= 1 << (flags & 1);
#line 346
          cp ++;
        } else
#line 348
        if ((int const   )*cp == 76) {
#line 350
          flags |= 4;
#line 351
          cp ++;
        } else
#line 353
        if ((int const   )*cp == 108) {
#line 355
          flags += 8;
#line 356
          cp ++;
        } else
#line 358
        if ((int const   )*cp == 106) {
#line 360
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 363
            flags += 16;
          } else
#line 365
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 368
            flags += 8;
          }
#line 370
          cp ++;
        } else
#line 372
        if ((int const   )*cp == 122) {
#line 372
          goto _L;
        } else
#line 372
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 377
          if (sizeof(size_t ) > sizeof(long )) {
#line 380
            flags += 16;
          } else
#line 382
          if (sizeof(size_t ) > sizeof(int )) {
#line 385
            flags += 8;
          }
#line 387
          cp ++;
        } else
#line 389
        if ((int const   )*cp == 116) {
#line 391
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 394
            flags += 16;
          } else
#line 396
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 399
            flags += 8;
          }
#line 401
          cp ++;
        } else {
#line 442
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 446
      tmp___18 = cp;
#line 446
      cp ++;
#line 446
      c = (char )*tmp___18;
      {
#line 449
      if ((int )c == 105) {
#line 449
        goto case_105;
      }
#line 449
      if ((int )c == 100) {
#line 449
        goto case_105;
      }
#line 467
      if ((int )c == 88) {
#line 467
        goto case_88;
      }
#line 467
      if ((int )c == 120) {
#line 467
        goto case_88;
      }
#line 467
      if ((int )c == 117) {
#line 467
        goto case_88;
      }
#line 467
      if ((int )c == 111) {
#line 467
        goto case_88;
      }
#line 486
      if ((int )c == 65) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 97) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 71) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 103) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 69) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 101) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 70) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 102) {
#line 486
        goto case_65;
      }
#line 492
      if ((int )c == 99) {
#line 492
        goto case_99;
      }
#line 503
      if ((int )c == 67) {
#line 503
        goto case_67;
      }
#line 508
      if ((int )c == 115) {
#line 508
        goto case_115;
      }
#line 519
      if ((int )c == 83) {
#line 519
        goto case_83;
      }
#line 524
      if ((int )c == 112) {
#line 524
        goto case_112;
      }
#line 527
      if ((int )c == 110) {
#line 527
        goto case_110;
      }
#line 556
      if ((int )c == 37) {
#line 556
        goto case_37;
      }
#line 559
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 452
      if (flags >= 16) {
#line 453
        type = (arg_type )9;
      } else
#line 452
      if (flags & 4) {
#line 453
        type = (arg_type )9;
      } else
#line 458
      if (flags >= 8) {
#line 459
        type = (arg_type )7;
      } else
#line 460
      if (flags & 2) {
#line 461
        type = (arg_type )1;
      } else
#line 462
      if (flags & 1) {
#line 463
        type = (arg_type )3;
      } else {
#line 465
        type = (arg_type )5;
      }
#line 466
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 470
      if (flags >= 16) {
#line 471
        type = (arg_type )10;
      } else
#line 470
      if (flags & 4) {
#line 471
        type = (arg_type )10;
      } else
#line 476
      if (flags >= 8) {
#line 477
        type = (arg_type )8;
      } else
#line 478
      if (flags & 2) {
#line 479
        type = (arg_type )2;
      } else
#line 480
      if (flags & 1) {
#line 481
        type = (arg_type )4;
      } else {
#line 483
        type = (arg_type )6;
      }
#line 484
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 487
      if (flags >= 16) {
#line 488
        type = (arg_type )12;
      } else
#line 487
      if (flags & 4) {
#line 488
        type = (arg_type )12;
      } else {
#line 490
        type = (arg_type )11;
      }
#line 491
      goto switch_break;
      case_99: /* CIL Label */ 
#line 493
      if (flags >= 8) {
#line 495
        type = (arg_type )14;
      } else {
#line 500
        type = (arg_type )13;
      }
#line 501
      goto switch_break;
      case_67: /* CIL Label */ 
#line 504
      type = (arg_type )14;
#line 505
      c = (char )'c';
#line 506
      goto switch_break;
      case_115: /* CIL Label */ 
#line 509
      if (flags >= 8) {
#line 511
        type = (arg_type )16;
      } else {
#line 516
        type = (arg_type )15;
      }
#line 517
      goto switch_break;
      case_83: /* CIL Label */ 
#line 520
      type = (arg_type )16;
#line 521
      c = (char )'s';
#line 522
      goto switch_break;
      case_112: /* CIL Label */ 
#line 525
      type = (arg_type )17;
#line 526
      goto switch_break;
      case_110: /* CIL Label */ 
#line 530
      if (flags >= 16) {
#line 531
        type = (arg_type )22;
      } else
#line 530
      if (flags & 4) {
#line 531
        type = (arg_type )22;
      } else
#line 536
      if (flags >= 8) {
#line 537
        type = (arg_type )21;
      } else
#line 538
      if (flags & 2) {
#line 539
        type = (arg_type )18;
      } else
#line 540
      if (flags & 1) {
#line 541
        type = (arg_type )19;
      } else {
#line 543
        type = (arg_type )20;
      }
#line 544
      goto switch_break;
      case_37: /* CIL Label */ 
#line 557
      type = (arg_type )0;
#line 558
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 561
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 565
      if ((unsigned int )type != 0U) {
#line 567
        dp->arg_index = arg_index;
#line 568
        if (dp->arg_index == 0xffffffffffffffffUL) {
#line 570
          tmp___19 = arg_posn;
#line 570
          arg_posn ++;
#line 570
          dp->arg_index = tmp___19;
#line 571
          if (dp->arg_index == 0xffffffffffffffffUL) {
#line 573
            goto error;
          }
        }
#line 575
        n___4 = dp->arg_index;
#line 575
        if (n___4 >= a_allocated) {
#line 575
          if (a_allocated <= 9223372036854775807UL) {
#line 575
            a_allocated *= 2UL;
          } else {
#line 575
            a_allocated = 0xffffffffffffffffUL;
          }
#line 575
          if (a_allocated <= n___4) {
            {
#line 575
            tmp___20 = xsum(n___4, (size_t )1);
#line 575
            a_allocated = (size_t )tmp___20;
            }
          }
#line 575
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 575
            memory_size___1 = a_allocated * sizeof(argument );
          } else {
#line 575
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 575
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 575
            goto out_of_memory;
          }
#line 575
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
#line 575
            tmp___21 = realloc((void *)a->arg, memory_size___1);
#line 575
            tmp___23 = tmp___21;
            }
          } else {
            {
#line 575
            tmp___22 = malloc(memory_size___1);
#line 575
            tmp___23 = tmp___22;
            }
          }
#line 575
          memory___1 = (argument *)tmp___23;
#line 575
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 575
            goto out_of_memory;
          }
#line 575
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
#line 575
            memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)a->arg,
                   a->count * sizeof(argument ));
            }
          }
#line 575
          a->arg = memory___1;
        }
        {
#line 575
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 575
          if (! (a->count <= n___4)) {
#line 575
            goto while_break___12;
          }
#line 575
          tmp___24 = a->count;
#line 575
          (a->count) ++;
#line 575
          (a->arg + tmp___24)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 575
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 575
          (a->arg + n___4)->type = type;
        } else
#line 575
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 575
          goto error;
        }
      }
#line 577
      dp->conversion = c;
#line 578
      dp->dir_end = cp;
#line 581
      (d->count) ++;
#line 582
      if (d->count >= d_allocated) {
#line 587
        if (d_allocated <= 9223372036854775807UL) {
#line 587
          d_allocated *= 2UL;
        } else {
#line 587
          d_allocated = 0xffffffffffffffffUL;
        }
#line 588
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
#line 588
          memory_size___2 = d_allocated * sizeof(char_directive );
        } else {
#line 588
          memory_size___2 = 0xffffffffffffffffUL;
        }
#line 589
        if (memory_size___2 == 0xffffffffffffffffUL) {
#line 591
          goto out_of_memory;
        }
#line 592
        if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
          {
#line 592
          tmp___25 = realloc((void *)d->dir, memory_size___2);
#line 592
          tmp___27 = tmp___25;
          }
        } else {
          {
#line 592
          tmp___26 = malloc(memory_size___2);
#line 592
          tmp___27 = tmp___26;
          }
        }
#line 592
        memory___2 = (char_directive *)tmp___27;
#line 595
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 597
          goto out_of_memory;
        }
#line 598
        if ((unsigned long )d->dir == (unsigned long )(d->direct_alloc_dir)) {
          {
#line 599
          memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)d->dir,
                 d->count * sizeof(char_directive ));
          }
        }
#line 600
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  (d->dir + d->count)->dir_start = cp;
#line 613
  d->max_width_length = max_width_length;
#line 614
  d->max_precision_length = max_precision_length;
#line 615
  return (0);
  error: 
#line 618
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
#line 619
    free((void *)a->arg);
    }
  }
#line 620
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
#line 621
    free((void *)d->dir);
    }
  }
  {
#line 622
  tmp___28 = __errno_location();
#line 622
  *tmp___28 = 22;
  }
#line 623
  return (-1);
  out_of_memory: 
#line 626
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
#line 627
    free((void *)a->arg);
    }
  }
#line 628
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
#line 629
    free((void *)d->dir);
    }
  }
  {
#line 630
  tmp___29 = __errno_location();
#line 630
  *tmp___29 = 12;
  }
#line 631
  return (-1);
}
}
#line 112 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 35 "/home/wslee/gnu_benchmarks/patch-2.7/lib/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;
  char *__cil_tmp30 ;

  {
#line 41
  i = (size_t )0;
#line 41
  ap = a->arg + 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < a->count)) {
#line 41
      goto while_break;
    }
    {
#line 44
    if ((unsigned int )ap->type == 1U) {
#line 44
      goto case_1;
    }
#line 47
    if ((unsigned int )ap->type == 2U) {
#line 47
      goto case_2;
    }
#line 50
    if ((unsigned int )ap->type == 3U) {
#line 50
      goto case_3;
    }
#line 53
    if ((unsigned int )ap->type == 4U) {
#line 53
      goto case_4;
    }
#line 56
    if ((unsigned int )ap->type == 5U) {
#line 56
      goto case_5;
    }
#line 59
    if ((unsigned int )ap->type == 6U) {
#line 59
      goto case_6;
    }
#line 62
    if ((unsigned int )ap->type == 7U) {
#line 62
      goto case_7;
    }
#line 65
    if ((unsigned int )ap->type == 8U) {
#line 65
      goto case_8;
    }
#line 69
    if ((unsigned int )ap->type == 9U) {
#line 69
      goto case_9;
    }
#line 72
    if ((unsigned int )ap->type == 10U) {
#line 72
      goto case_10;
    }
#line 76
    if ((unsigned int )ap->type == 11U) {
#line 76
      goto case_11;
    }
#line 79
    if ((unsigned int )ap->type == 12U) {
#line 79
      goto case_12;
    }
#line 82
    if ((unsigned int )ap->type == 13U) {
#line 82
      goto case_13;
    }
#line 86
    if ((unsigned int )ap->type == 14U) {
#line 86
      goto case_14;
    }
#line 96
    if ((unsigned int )ap->type == 15U) {
#line 96
      goto case_15;
    }
#line 105
    if ((unsigned int )ap->type == 16U) {
#line 105
      goto case_16;
    }
#line 123
    if ((unsigned int )ap->type == 17U) {
#line 123
      goto case_17;
    }
#line 126
    if ((unsigned int )ap->type == 18U) {
#line 126
      goto case_18;
    }
#line 129
    if ((unsigned int )ap->type == 19U) {
#line 129
      goto case_19;
    }
#line 132
    if ((unsigned int )ap->type == 20U) {
#line 132
      goto case_20;
    }
#line 135
    if ((unsigned int )ap->type == 21U) {
#line 135
      goto case_21;
    }
#line 139
    if ((unsigned int )ap->type == 22U) {
#line 139
      goto case_22;
    }
#line 182
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 45
    tmp = __builtin_va_arg(args, int );
#line 45
    ap->a.a_schar = tmp;
    }
#line 46
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 48
    tmp___0 = __builtin_va_arg(args, int );
#line 48
    ap->a.a_uchar = tmp___0;
    }
#line 49
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 51
    tmp___1 = __builtin_va_arg(args, int );
#line 51
    ap->a.a_short = tmp___1;
    }
#line 52
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 54
    tmp___2 = __builtin_va_arg(args, int );
#line 54
    ap->a.a_ushort = tmp___2;
    }
#line 55
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 57
    tmp___3 = __builtin_va_arg(args, int );
#line 57
    ap->a.a_int = tmp___3;
    }
#line 58
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 60
    tmp___4 = __builtin_va_arg(args, unsigned int );
#line 60
    ap->a.a_uint = tmp___4;
    }
#line 61
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 63
    tmp___5 = __builtin_va_arg(args, long );
#line 63
    ap->a.a_longint = tmp___5;
    }
#line 64
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 66
    tmp___6 = __builtin_va_arg(args, unsigned long );
#line 66
    ap->a.a_ulongint = tmp___6;
    }
#line 67
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 70
    tmp___7 = __builtin_va_arg(args, long long );
#line 70
    ap->a.a_longlongint = tmp___7;
    }
#line 71
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 73
    tmp___8 = __builtin_va_arg(args, unsigned long long );
#line 73
    ap->a.a_ulonglongint = tmp___8;
    }
#line 74
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 77
    tmp___9 = __builtin_va_arg(args, double );
#line 77
    ap->a.a_double = tmp___9;
    }
#line 78
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 80
    tmp___10 = __builtin_va_arg(args, long double );
#line 80
    ap->a.a_longdouble = tmp___10;
    }
#line 81
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 83
    tmp___11 = __builtin_va_arg(args, int );
#line 83
    ap->a.a_char = tmp___11;
    }
#line 84
    goto switch_break;
    case_14: /* CIL Label */ 
#line 90
    if (sizeof(wint_t ) < sizeof(int )) {
      {
#line 90
      tmp___13 = __builtin_va_arg(args, int );
#line 90
      ap->a.a_wide_char = (wint_t )tmp___13;
      }
    } else {
      {
#line 90
      tmp___15 = __builtin_va_arg(args, wint_t );
#line 90
      ap->a.a_wide_char = tmp___15;
      }
    }
#line 94
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 97
    tmp___16 = __builtin_va_arg(args, char const   *);
#line 97
    ap->a.a_string = tmp___16;
    }
#line 101
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 102
      ap->a.a_string = "(NULL)";
    }
#line 103
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 106
    tmp___17 = __builtin_va_arg(args, wchar_t const   *);
#line 106
    ap->a.a_wide_string = tmp___17;
    }
#line 110
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 119
      ap->a.a_wide_string = wide_null_string;
    }
#line 121
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 124
    tmp___18 = __builtin_va_arg(args, void *);
#line 124
    ap->a.a_pointer = tmp___18;
    }
#line 125
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 127
    tmp___19 = __builtin_va_arg(args, signed char *);
#line 127
    ap->a.a_count_schar_pointer = tmp___19;
    }
#line 128
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 130
    tmp___20 = __builtin_va_arg(args, short *);
#line 130
    ap->a.a_count_short_pointer = tmp___20;
    }
#line 131
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 133
    tmp___21 = __builtin_va_arg(args, int *);
#line 133
    ap->a.a_count_int_pointer = tmp___21;
    }
#line 134
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 136
    tmp___22 = __builtin_va_arg(args, long *);
#line 136
    ap->a.a_count_longint_pointer = tmp___22;
    }
#line 137
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 140
    tmp___23 = __builtin_va_arg(args, long long *);
#line 140
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
#line 141
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 184
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 41
    i ++;
#line 41
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (0);
}
}
#line 21 "/home/wslee/gnu_benchmarks/patch-2.7/lib/unistd-safer.h"
int fd_safer(int fd ) ;
#line 22
int pipe_safer(int *fd ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 414
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 30 "/home/wslee/gnu_benchmarks/patch-2.7/lib/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = pipe(fd);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 193 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 237
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 22 "/home/wslee/gnu_benchmarks/patch-2.7/lib/parse-datetime.h"
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) ;
#line 123 "./c-ctype.h"
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 131
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 136
int c_toupper(int c )  __attribute__((__const__)) ;
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 766
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 118 "parse-datetime.y"
__inline static unsigned char to_uchar(char ch ) 
{ 


  {
#line 118
  return ((unsigned char )ch);
}
}
#line 217
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
#line 218
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) ;
#line 219
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
#line 224 "parse-datetime.y"
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 


  {
#line 227
  if (pc->dates_seen) {
#line 227
    if (! pc->year.digits) {
#line 227
      if (! pc->rels_seen) {
#line 227
        if (pc->times_seen) {
#line 229
          pc->year = text_int;
        } else
#line 227
        if (2UL < text_int.digits) {
#line 229
          pc->year = text_int;
        } else {
#line 227
          goto _L___1;
        }
      } else {
#line 227
        goto _L___1;
      }
    } else {
#line 227
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 232
  if (4UL < text_int.digits) {
#line 234
    (pc->dates_seen) ++;
#line 235
    pc->day = text_int.value % 100L;
#line 236
    pc->month = (text_int.value / 100L) % 100L;
#line 237
    pc->year.value = text_int.value / 10000L;
#line 238
    pc->year.digits = text_int.digits - 4UL;
  } else {
#line 242
    (pc->times_seen) ++;
#line 243
    if (text_int.digits <= 2UL) {
#line 245
      pc->hour = text_int.value;
#line 246
      pc->minutes = 0L;
    } else {
#line 250
      pc->hour = text_int.value / 100L;
#line 251
      pc->minutes = text_int.value % 100L;
    }
#line 253
    pc->seconds.tv_sec = (__time_t )0;
#line 254
    pc->seconds.tv_nsec = 0L;
#line 255
    pc->meridian = 2;
  }
#line 258
  return;
}
}
#line 261 "parse-datetime.y"
static void apply_relative_time(parser_control *pc , relative_time rel , int factor ) 
{ 


  {
#line 264
  pc->rel.ns += (long )factor * rel.ns;
#line 265
  pc->rel.seconds += (long_time_t )factor * rel.seconds;
#line 266
  pc->rel.minutes += (long )factor * rel.minutes;
#line 267
  pc->rel.hour += (long )factor * rel.hour;
#line 268
  pc->rel.day += (long )factor * rel.day;
#line 269
  pc->rel.month += (long )factor * rel.month;
#line 270
  pc->rel.year += (long )factor * rel.year;
#line 271
  pc->rels_seen = (_Bool)1;
#line 272
  return;
}
}
#line 275 "parse-datetime.y"
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec ) 
{ 


  {
#line 279
  pc->hour = hour;
#line 280
  pc->minutes = minutes;
#line 281
  pc->seconds.tv_sec = sec;
#line 282
  pc->seconds.tv_nsec = nsec;
#line 283
  return;
}
}
#line 696 "parse-datetime.c"
static yytype_uint8 const   yytranslate[278]  = 
#line 696 "parse-datetime.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )25,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22};
#line 822 "parse-datetime.c"
static yytype_uint8 const   yyr1[92]  = 
#line 822
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )53};
#line 837 "parse-datetime.c"
static yytype_uint8 const   yyr2[92]  = 
#line 837
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2};
#line 854 "parse-datetime.c"
static yytype_uint8 const   yydefact[114]  = 
#line 854
  {      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )85,      (yytype_uint8 const   )87,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )4,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )56,      (yytype_uint8 const   )59,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )73,      (yytype_uint8 const   )62,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )35,      (yytype_uint8 const   )28,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )30,      (yytype_uint8 const   )0,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )16,      (yytype_uint8 const   )8,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )13,      (yytype_uint8 const   )52,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )0,      (yytype_uint8 const   )45,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )63,      (yytype_uint8 const   )66,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )39,      (yytype_uint8 const   )36,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )77,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )64,      (yytype_uint8 const   )67,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )40,      (yytype_uint8 const   )18,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )51,      (yytype_uint8 const   )44,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )34,      (yytype_uint8 const   )43,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )46,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )25,      (yytype_uint8 const   )20,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )25};
#line 871 "parse-datetime.c"
static yytype_int8 const   yydefgoto[26]  = 
#line 871
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )35,      (yytype_int8 const   )103,      (yytype_int8 const   )104,      (yytype_int8 const   )36, 
        (yytype_int8 const   )37,      (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )40, 
        (yytype_int8 const   )41,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )45, 
        (yytype_int8 const   )46,      (yytype_int8 const   )93};
#line 881 "parse-datetime.c"
static yytype_int8 const   yypact[114]  = 
#line 881
  {      (yytype_int8 const   )38,      (yytype_int8 const   )27,      (yytype_int8 const   )77,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )62,      (yytype_int8 const   )-93,      (yytype_int8 const   )82,      (yytype_int8 const   )-3, 
        (yytype_int8 const   )66,      (yytype_int8 const   )3,      (yytype_int8 const   )74,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )75,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-93,      (yytype_int8 const   )93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )78,      (yytype_int8 const   )72,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )25, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )21, 
        (yytype_int8 const   )19,      (yytype_int8 const   )79,      (yytype_int8 const   )80,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )81,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )85, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-6,      (yytype_int8 const   )76, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )87,      (yytype_int8 const   )69,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )88,      (yytype_int8 const   )89,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )18,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )69,      (yytype_int8 const   )91};
#line 898 "parse-datetime.c"
static yytype_int8 const   yypgoto[26]  = 
#line 898
  {      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )20,      (yytype_int8 const   )-68,      (yytype_int8 const   )-27,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )60,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-92,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )43};
#line 909 "parse-datetime.c"
static yytype_uint8 const   yytable[113]  = 
#line 909
  {      (yytype_uint8 const   )79,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )100,      (yytype_uint8 const   )107,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )101,      (yytype_uint8 const   )110,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )77,      (yytype_uint8 const   )59,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )92,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )106,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )111,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )88,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )1,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )79,      (yytype_uint8 const   )30,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )12,      (yytype_uint8 const   )57,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )60,      (yytype_uint8 const   )48,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )6,      (yytype_uint8 const   )83,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )26,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )89,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )101,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )88};
#line 931 "parse-datetime.c"
static yytype_int8 const   yycheck[113]  = 
#line 931
  {      (yytype_int8 const   )27,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )4, 
        (yytype_int8 const   )12,      (yytype_int8 const   )15,      (yytype_int8 const   )102,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )19,      (yytype_int8 const   )15,      (yytype_int8 const   )19, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )25, 
        (yytype_int8 const   )112,      (yytype_int8 const   )25,      (yytype_int8 const   )19,      (yytype_int8 const   )27, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )107, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )25,      (yytype_int8 const   )25, 
        (yytype_int8 const   )25,      (yytype_int8 const   )113,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )25,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )23,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )96,      (yytype_int8 const   )24,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )0,      (yytype_int8 const   )12,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )25,      (yytype_int8 const   )4,      (yytype_int8 const   )27, 
        (yytype_int8 const   )26,      (yytype_int8 const   )20,      (yytype_int8 const   )30,      (yytype_int8 const   )22, 
        (yytype_int8 const   )9,      (yytype_int8 const   )9,      (yytype_int8 const   )19,      (yytype_int8 const   )24, 
        (yytype_int8 const   )3,      (yytype_int8 const   )19,      (yytype_int8 const   )26,      (yytype_int8 const   )20, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )59,      (yytype_int8 const   )27, 
        (yytype_int8 const   )84,      (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )25};
#line 949 "parse-datetime.c"
static yytype_uint8 const   yystos[114]  = 
#line 949
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )24,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )27,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )3,      (yytype_uint8 const   )19,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )53,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )53,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )36,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )50};
#line 1484 "parse-datetime.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 
  char *__cil_tmp5 ;

  {
#line 1498
  if (! yymsg) {
#line 1499
    yymsg = "Deleting";
  }
  {
#line 1505
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1506
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1508
  return;
}
}
#line 1520
int yyparse(parser_control *pc ) ;
#line 1544 "parse-datetime.c"
int yyparse(parser_control *pc ) 
{ 
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  long tmp___0 ;
  relative_time __constr_expr_0 ;
  relative_time __constr_expr_1 ;
  relative_time __constr_expr_2 ;
  relative_time __constr_expr_3 ;
  relative_time __constr_expr_4 ;
  relative_time __constr_expr_5 ;
  relative_time __constr_expr_6 ;
  relative_time __constr_expr_7 ;
  relative_time __constr_expr_8 ;
  relative_time __constr_expr_9 ;
  relative_time __constr_expr_10 ;
  relative_time __constr_expr_11 ;
  relative_time __constr_expr_12 ;
  relative_time __constr_expr_13 ;
  relative_time __constr_expr_14 ;
  relative_time __constr_expr_15 ;
  relative_time __constr_expr_16 ;
  relative_time __constr_expr_17 ;
  relative_time __constr_expr_18 ;
  relative_time __constr_expr_19 ;
  relative_time __constr_expr_20 ;
  relative_time __constr_expr_21 ;
  relative_time __constr_expr_22 ;
  relative_time __constr_expr_23 ;
  relative_time __constr_expr_24 ;
  relative_time __constr_expr_25 ;
  relative_time __constr_expr_26 ;
  int tmp___1 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;
  void *__cil_tmp82 ;
  void *__cil_tmp83 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  void *__cil_tmp86 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  void *__cil_tmp89 ;
  void *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;

  {
#line 1604
  yylen = 0;
#line 1606
  yytoken = 0;
#line 1607
  yyss = yyssa;
#line 1608
  yyvs = yyvsa;
#line 1609
  yystacksize = 20UL;
#line 1613
  yystate = 0;
#line 1614
  yyerrstatus = 0;
#line 1615
  yynerrs = 0;
#line 1616
  yychar = -2;
#line 1622
  yyssp = yyss;
#line 1623
  yyvsp = yyvs;
#line 1625
  goto yysetstate;
  yynewstate: 
#line 1633
  yyssp ++;
  yysetstate: 
#line 1636
  *yyssp = (yytype_int16 )yystate;
#line 1638
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1641
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1668
    if (20UL <= yystacksize) {
#line 1669
      goto yyexhaustedlab;
    }
#line 1670
    yystacksize *= 2UL;
#line 1671
    if (20UL < yystacksize) {
#line 1672
      yystacksize = 20UL;
    }
    {
#line 1675
    yyss1 = yyss;
#line 1676
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1676
    yyptr = (union yyalloc *)tmp;
    }
#line 1678
    if (! yyptr) {
#line 1679
      goto yyexhaustedlab;
    }
    {
#line 1680
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1680
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1680
      yyss = & yyptr->yyss_alloc;
#line 1680
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1680
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1680
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1681
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1681
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1681
      yyvs = & yyptr->yyvs_alloc;
#line 1681
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1681
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1681
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1683
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1684
      free((void *)yyss1);
      }
    }
#line 1689
    yyssp = (yyss + yysize) - 1;
#line 1690
    yyvsp = (yyvs + yysize) - 1;
#line 1695
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1696
      goto yyabortlab;
    }
  }
#line 1701
  if (yystate == 12) {
#line 1702
    goto yyacceptlab;
  }
#line 1704
  goto yybackup;
  yybackup: 
#line 1715
  yyn = (int )yypact[yystate];
#line 1716
  if (yyn == -93) {
#line 1717
    goto yydefault;
  }
#line 1722
  if (yychar == -2) {
    {
#line 1725
    yychar = yylex(& yylval, pc);
    }
  }
#line 1728
  if (yychar <= 0) {
#line 1730
    yytoken = 0;
#line 1730
    yychar = yytoken;
  } else
#line 1735
  if ((unsigned int )yychar <= 277U) {
#line 1735
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1735
    yytoken = 2;
  }
#line 1741
  yyn += yytoken;
#line 1742
  if (yyn < 0) {
#line 1743
    goto yydefault;
  } else
#line 1742
  if (112 < yyn) {
#line 1743
    goto yydefault;
  } else
#line 1742
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1743
    goto yydefault;
  }
#line 1744
  yyn = (int )yytable[yyn];
#line 1745
  if (yyn <= 0) {
#line 1749
    yyn = - yyn;
#line 1750
    goto yyreduce;
  }
#line 1755
  if (yyerrstatus) {
#line 1756
    yyerrstatus --;
  }
#line 1762
  yychar = -2;
#line 1764
  yystate = yyn;
#line 1765
  yyvsp ++;
#line 1765
  *yyvsp = yylval;
#line 1767
  goto yynewstate;
  yydefault: 
#line 1774
  yyn = (int )yydefact[yystate];
#line 1775
  if (yyn == 0) {
#line 1776
    goto yyerrlab;
  }
#line 1777
  goto yyreduce;
  yyreduce: 
#line 1785
  yylen = (int )yyr2[yyn];
#line 1795
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1801
  if (yyn == 4) {
#line 1801
    goto case_4;
  }
#line 336
  if (yyn == 7) {
#line 336 "parse-datetime.y"
    goto case_7;
  }
#line 346
  if (yyn == 8) {
#line 346
    goto case_8;
  }
#line 348
  if (yyn == 9) {
#line 348
    goto case_9;
  }
#line 350
  if (yyn == 10) {
#line 350
    goto case_10;
  }
#line 352
  if (yyn == 11) {
#line 352
    goto case_11;
  }
#line 354
  if (yyn == 12) {
#line 354
    goto case_12;
  }
#line 356
  if (yyn == 18) {
#line 356
    goto case_18;
  }
#line 375
  if (yyn == 19) {
#line 375
    goto case_19;
  }
#line 380
  if (yyn == 20) {
#line 380
    goto case_20;
  }
#line 385
  if (yyn == 22) {
#line 385
    goto case_22;
  }
#line 394
  if (yyn == 23) {
#line 394
    goto case_23;
  }
#line 399
  if (yyn == 24) {
#line 399
    goto case_24;
  }
#line 404
  if (yyn == 27) {
#line 404
    goto case_27;
  }
#line 417
  if (yyn == 28) {
#line 417
    goto case_28;
  }
#line 425
  if (yyn == 29) {
#line 425
    goto case_29;
  }
#line 430
  if (yyn == 30) {
#line 430
    goto case_30;
  }
#line 437
  if (yyn == 31) {
#line 437
    goto case_31;
  }
#line 439
  if (yyn == 32) {
#line 439
    goto case_32;
  }
#line 442
  if (yyn == 33) {
#line 442
    goto case_33;
  }
#line 445
  if (yyn == 34) {
#line 445
    goto case_34;
  }
#line 447
  if (yyn == 35) {
#line 447
    goto case_35;
  }
#line 449
  if (yyn == 36) {
#line 449
    goto case_36;
  }
#line 451
  if (yyn == 37) {
#line 451
    goto case_37;
  }
#line 459
  if (yyn == 38) {
#line 459
    goto case_38;
  }
#line 464
  if (yyn == 39) {
#line 464
    goto case_39;
  }
#line 469
  if (yyn == 40) {
#line 469
    goto case_40;
  }
#line 474
  if (yyn == 41) {
#line 474
    goto case_41;
  }
#line 482
  if (yyn == 42) {
#line 482
    goto case_42;
  }
#line 502
  if (yyn == 43) {
#line 502
    goto case_43;
  }
#line 510
  if (yyn == 44) {
#line 510
    goto case_44;
  }
#line 518
  if (yyn == 45) {
#line 518
    goto case_45;
  }
#line 523
  if (yyn == 46) {
#line 523
    goto case_46;
  }
#line 529
  if (yyn == 47) {
#line 529
    goto case_47;
  }
#line 534
  if (yyn == 48) {
#line 534
    goto case_48;
  }
#line 540
  if (yyn == 50) {
#line 540
    goto case_50;
  }
#line 551
  if (yyn == 51) {
#line 551
    goto case_51;
  }
#line 556
  if (yyn == 52) {
#line 556
    goto case_52;
  }
#line 558
  if (yyn == 53) {
#line 558
    goto case_53;
  }
#line 560
  if (yyn == 54) {
#line 560
    goto case_54;
  }
#line 565
  if (yyn == 55) {
#line 565
    goto case_55;
  }
#line 567
  if (yyn == 56) {
#line 567
    goto case_56;
  }
#line 569
  if (yyn == 57) {
#line 569
    goto case_57;
  }
#line 571
  if (yyn == 58) {
#line 571
    goto case_58;
  }
#line 573
  if (yyn == 59) {
#line 573
    goto case_59;
  }
#line 575
  if (yyn == 60) {
#line 575
    goto case_60;
  }
#line 577
  if (yyn == 61) {
#line 577
    goto case_61;
  }
#line 579
  if (yyn == 62) {
#line 579
    goto case_62;
  }
#line 581
  if (yyn == 63) {
#line 581
    goto case_63;
  }
#line 583
  if (yyn == 64) {
#line 583
    goto case_64;
  }
#line 585
  if (yyn == 65) {
#line 585
    goto case_65;
  }
#line 587
  if (yyn == 66) {
#line 587
    goto case_66;
  }
#line 589
  if (yyn == 67) {
#line 589
    goto case_67;
  }
#line 591
  if (yyn == 68) {
#line 591
    goto case_68;
  }
#line 593
  if (yyn == 69) {
#line 593
    goto case_69;
  }
#line 595
  if (yyn == 70) {
#line 595
    goto case_70;
  }
#line 597
  if (yyn == 71) {
#line 597
    goto case_71;
  }
#line 599
  if (yyn == 72) {
#line 599
    goto case_72;
  }
#line 601
  if (yyn == 73) {
#line 601
    goto case_73;
  }
#line 603
  if (yyn == 75) {
#line 603
    goto case_75;
  }
#line 609
  if (yyn == 76) {
#line 609
    goto case_76;
  }
#line 611
  if (yyn == 77) {
#line 611
    goto case_77;
  }
#line 613
  if (yyn == 78) {
#line 613
    goto case_78;
  }
#line 615
  if (yyn == 79) {
#line 615
    goto case_79;
  }
#line 617
  if (yyn == 80) {
#line 617
    goto case_80;
  }
#line 619
  if (yyn == 81) {
#line 619
    goto case_81;
  }
#line 624
  if (yyn == 85) {
#line 624
    goto case_85;
  }
#line 632
  if (yyn == 87) {
#line 632
    goto case_87;
  }
#line 638
  if (yyn == 88) {
#line 638
    goto case_88;
  }
#line 643
  if (yyn == 89) {
#line 643
    goto case_89;
  }
#line 653
  if (yyn == 90) {
#line 653
    goto case_90;
  }
#line 658
  if (yyn == 91) {
#line 658
    goto case_91;
  }
#line 2410 "parse-datetime.c"
  goto switch_default;
  case_4: /* CIL Label */ 
#line 331 "parse-datetime.y"
  pc->seconds = (yyvsp + 0)->timespec;
#line 332
  pc->timespec_seen = (_Bool)1;
#line 334
  goto switch_break;
  case_7: /* CIL Label */ 
#line 343
  (pc->times_seen) ++;
#line 343
  (pc->dates_seen) ++;
#line 344
  goto switch_break;
  case_8: /* CIL Label */ 
#line 345
  (pc->times_seen) ++;
#line 346
  goto switch_break;
  case_9: /* CIL Label */ 
#line 347
  (pc->local_zones_seen) ++;
#line 348
  goto switch_break;
  case_10: /* CIL Label */ 
#line 349
  (pc->zones_seen) ++;
#line 350
  goto switch_break;
  case_11: /* CIL Label */ 
#line 351
  (pc->dates_seen) ++;
#line 352
  goto switch_break;
  case_12: /* CIL Label */ 
#line 353
  (pc->days_seen) ++;
#line 354
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 370
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
#line 371
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 373
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 375
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
#line 376
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 378
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 380
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 381
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 383
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 389
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
#line 390
  pc->meridian = 2;
  }
#line 392
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 394
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
#line 395
  pc->meridian = 2;
  }
#line 397
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 399
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 400
  pc->meridian = 2;
  }
#line 402
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 412
  (pc->zones_seen) ++;
#line 413
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
#line 415
  goto switch_break;
  case_28: /* CIL Label */ 
#line 420
  pc->local_isdst = (int )(yyvsp + 0)->intval;
#line 421
  pc->dsts_seen += (size_t )(0L < (yyvsp + 0)->intval);
#line 423
  goto switch_break;
  case_29: /* CIL Label */ 
#line 425
  pc->local_isdst = 1;
#line 426
  pc->dsts_seen += (size_t )((0L < (yyvsp + -1)->intval) + 1);
#line 428
  goto switch_break;
  case_30: /* CIL Label */ 
#line 434
  pc->time_zone = (yyvsp + 0)->intval;
#line 435
  goto switch_break;
  case_31: /* CIL Label */ 
#line 436
  pc->time_zone = 420L;
#line 437
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 438
  pc->time_zone = (yyvsp + -1)->intval;
#line 439
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 440
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 441
  pc->time_zone = 420L;
#line 442
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 443
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 444
  tmp___0 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 444
  pc->time_zone = (yyvsp + -2)->intval + tmp___0;
  }
#line 445
  goto switch_break;
  case_35: /* CIL Label */ 
#line 446
  pc->time_zone = (yyvsp + 0)->intval + 60L;
#line 447
  goto switch_break;
  case_36: /* CIL Label */ 
#line 448
  pc->time_zone = (yyvsp + -1)->intval + 60L;
#line 449
  goto switch_break;
  case_37: /* CIL Label */ 
#line 454
  pc->day_ordinal = 0L;
#line 455
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 457
  goto switch_break;
  case_38: /* CIL Label */ 
#line 459
  pc->day_ordinal = 0L;
#line 460
  pc->day_number = (int )(yyvsp + -1)->intval;
#line 462
  goto switch_break;
  case_39: /* CIL Label */ 
#line 464
  pc->day_ordinal = (yyvsp + -1)->intval;
#line 465
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 467
  goto switch_break;
  case_40: /* CIL Label */ 
#line 469
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
#line 470
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 472
  goto switch_break;
  case_41: /* CIL Label */ 
#line 477
  pc->month = (yyvsp + -2)->textintval.value;
#line 478
  pc->day = (yyvsp + 0)->textintval.value;
#line 480
  goto switch_break;
  case_42: /* CIL Label */ 
#line 487
  if (4UL <= (yyvsp + -4)->textintval.digits) {
#line 489
    pc->year = (yyvsp + -4)->textintval;
#line 490
    pc->month = (yyvsp + -2)->textintval.value;
#line 491
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
#line 495
    pc->month = (yyvsp + -4)->textintval.value;
#line 496
    pc->day = (yyvsp + -2)->textintval.value;
#line 497
    pc->year = (yyvsp + 0)->textintval;
  }
#line 500
  goto switch_break;
  case_43: /* CIL Label */ 
#line 503
  pc->day = (yyvsp + -2)->textintval.value;
#line 504
  pc->month = (yyvsp + -1)->intval;
#line 505
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 506
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 508
  goto switch_break;
  case_44: /* CIL Label */ 
#line 511
  pc->month = (yyvsp + -2)->intval;
#line 512
  pc->day = - (yyvsp + -1)->textintval.value;
#line 513
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 514
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 516
  goto switch_break;
  case_45: /* CIL Label */ 
#line 518
  pc->month = (yyvsp + -1)->intval;
#line 519
  pc->day = (yyvsp + 0)->textintval.value;
#line 521
  goto switch_break;
  case_46: /* CIL Label */ 
#line 523
  pc->month = (yyvsp + -3)->intval;
#line 524
  pc->day = (yyvsp + -2)->textintval.value;
#line 525
  pc->year = (yyvsp + 0)->textintval;
#line 527
  goto switch_break;
  case_47: /* CIL Label */ 
#line 529
  pc->day = (yyvsp + -1)->textintval.value;
#line 530
  pc->month = (yyvsp + 0)->intval;
#line 532
  goto switch_break;
  case_48: /* CIL Label */ 
#line 534
  pc->day = (yyvsp + -2)->textintval.value;
#line 535
  pc->month = (yyvsp + -1)->intval;
#line 536
  pc->year = (yyvsp + 0)->textintval;
#line 538
  goto switch_break;
  case_50: /* CIL Label */ 
#line 545
  pc->year = (yyvsp + -2)->textintval;
#line 546
  pc->month = - (yyvsp + -1)->textintval.value;
#line 547
  pc->day = - (yyvsp + 0)->textintval.value;
#line 549
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 553
  apply_relative_time(pc, (yyvsp + -1)->rel, (int )(yyvsp + 0)->intval);
  }
#line 554
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 555
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 556
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 557
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 558
  goto switch_break;
  case_54: /* CIL Label */ 
#line 562
  __constr_expr_0.year = 0L;
#line 562
  __constr_expr_0.month = 0L;
#line 562
  __constr_expr_0.day = 0L;
#line 562
  __constr_expr_0.hour = 0L;
#line 562
  __constr_expr_0.minutes = 0L;
#line 562
  __constr_expr_0.seconds = (long_time_t )0;
#line 562
  __constr_expr_0.ns = 0L;
#line 562
  yyval.rel = __constr_expr_0;
#line 562
  yyval.rel.year = (yyvsp + -1)->intval;
#line 563
  goto switch_break;
  case_55: /* CIL Label */ 
#line 564
  __constr_expr_1.year = 0L;
#line 564
  __constr_expr_1.month = 0L;
#line 564
  __constr_expr_1.day = 0L;
#line 564
  __constr_expr_1.hour = 0L;
#line 564
  __constr_expr_1.minutes = 0L;
#line 564
  __constr_expr_1.seconds = (long_time_t )0;
#line 564
  __constr_expr_1.ns = 0L;
#line 564
  yyval.rel = __constr_expr_1;
#line 564
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 565
  goto switch_break;
  case_56: /* CIL Label */ 
#line 566
  __constr_expr_2.year = 0L;
#line 566
  __constr_expr_2.month = 0L;
#line 566
  __constr_expr_2.day = 0L;
#line 566
  __constr_expr_2.hour = 0L;
#line 566
  __constr_expr_2.minutes = 0L;
#line 566
  __constr_expr_2.seconds = (long_time_t )0;
#line 566
  __constr_expr_2.ns = 0L;
#line 566
  yyval.rel = __constr_expr_2;
#line 566
  yyval.rel.year = 1L;
#line 567
  goto switch_break;
  case_57: /* CIL Label */ 
#line 568
  __constr_expr_3.year = 0L;
#line 568
  __constr_expr_3.month = 0L;
#line 568
  __constr_expr_3.day = 0L;
#line 568
  __constr_expr_3.hour = 0L;
#line 568
  __constr_expr_3.minutes = 0L;
#line 568
  __constr_expr_3.seconds = (long_time_t )0;
#line 568
  __constr_expr_3.ns = 0L;
#line 568
  yyval.rel = __constr_expr_3;
#line 568
  yyval.rel.month = (yyvsp + -1)->intval;
#line 569
  goto switch_break;
  case_58: /* CIL Label */ 
#line 570
  __constr_expr_4.year = 0L;
#line 570
  __constr_expr_4.month = 0L;
#line 570
  __constr_expr_4.day = 0L;
#line 570
  __constr_expr_4.hour = 0L;
#line 570
  __constr_expr_4.minutes = 0L;
#line 570
  __constr_expr_4.seconds = (long_time_t )0;
#line 570
  __constr_expr_4.ns = 0L;
#line 570
  yyval.rel = __constr_expr_4;
#line 570
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 571
  goto switch_break;
  case_59: /* CIL Label */ 
#line 572
  __constr_expr_5.year = 0L;
#line 572
  __constr_expr_5.month = 0L;
#line 572
  __constr_expr_5.day = 0L;
#line 572
  __constr_expr_5.hour = 0L;
#line 572
  __constr_expr_5.minutes = 0L;
#line 572
  __constr_expr_5.seconds = (long_time_t )0;
#line 572
  __constr_expr_5.ns = 0L;
#line 572
  yyval.rel = __constr_expr_5;
#line 572
  yyval.rel.month = 1L;
#line 573
  goto switch_break;
  case_60: /* CIL Label */ 
#line 574
  __constr_expr_6.year = 0L;
#line 574
  __constr_expr_6.month = 0L;
#line 574
  __constr_expr_6.day = 0L;
#line 574
  __constr_expr_6.hour = 0L;
#line 574
  __constr_expr_6.minutes = 0L;
#line 574
  __constr_expr_6.seconds = (long_time_t )0;
#line 574
  __constr_expr_6.ns = 0L;
#line 574
  yyval.rel = __constr_expr_6;
#line 574
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
#line 575
  goto switch_break;
  case_61: /* CIL Label */ 
#line 576
  __constr_expr_7.year = 0L;
#line 576
  __constr_expr_7.month = 0L;
#line 576
  __constr_expr_7.day = 0L;
#line 576
  __constr_expr_7.hour = 0L;
#line 576
  __constr_expr_7.minutes = 0L;
#line 576
  __constr_expr_7.seconds = (long_time_t )0;
#line 576
  __constr_expr_7.ns = 0L;
#line 576
  yyval.rel = __constr_expr_7;
#line 576
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 577
  goto switch_break;
  case_62: /* CIL Label */ 
#line 578
  __constr_expr_8.year = 0L;
#line 578
  __constr_expr_8.month = 0L;
#line 578
  __constr_expr_8.day = 0L;
#line 578
  __constr_expr_8.hour = 0L;
#line 578
  __constr_expr_8.minutes = 0L;
#line 578
  __constr_expr_8.seconds = (long_time_t )0;
#line 578
  __constr_expr_8.ns = 0L;
#line 578
  yyval.rel = __constr_expr_8;
#line 578
  yyval.rel.day = (yyvsp + 0)->intval;
#line 579
  goto switch_break;
  case_63: /* CIL Label */ 
#line 580
  __constr_expr_9.year = 0L;
#line 580
  __constr_expr_9.month = 0L;
#line 580
  __constr_expr_9.day = 0L;
#line 580
  __constr_expr_9.hour = 0L;
#line 580
  __constr_expr_9.minutes = 0L;
#line 580
  __constr_expr_9.seconds = (long_time_t )0;
#line 580
  __constr_expr_9.ns = 0L;
#line 580
  yyval.rel = __constr_expr_9;
#line 580
  yyval.rel.hour = (yyvsp + -1)->intval;
#line 581
  goto switch_break;
  case_64: /* CIL Label */ 
#line 582
  __constr_expr_10.year = 0L;
#line 582
  __constr_expr_10.month = 0L;
#line 582
  __constr_expr_10.day = 0L;
#line 582
  __constr_expr_10.hour = 0L;
#line 582
  __constr_expr_10.minutes = 0L;
#line 582
  __constr_expr_10.seconds = (long_time_t )0;
#line 582
  __constr_expr_10.ns = 0L;
#line 582
  yyval.rel = __constr_expr_10;
#line 582
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 583
  goto switch_break;
  case_65: /* CIL Label */ 
#line 584
  __constr_expr_11.year = 0L;
#line 584
  __constr_expr_11.month = 0L;
#line 584
  __constr_expr_11.day = 0L;
#line 584
  __constr_expr_11.hour = 0L;
#line 584
  __constr_expr_11.minutes = 0L;
#line 584
  __constr_expr_11.seconds = (long_time_t )0;
#line 584
  __constr_expr_11.ns = 0L;
#line 584
  yyval.rel = __constr_expr_11;
#line 584
  yyval.rel.hour = 1L;
#line 585
  goto switch_break;
  case_66: /* CIL Label */ 
#line 586
  __constr_expr_12.year = 0L;
#line 586
  __constr_expr_12.month = 0L;
#line 586
  __constr_expr_12.day = 0L;
#line 586
  __constr_expr_12.hour = 0L;
#line 586
  __constr_expr_12.minutes = 0L;
#line 586
  __constr_expr_12.seconds = (long_time_t )0;
#line 586
  __constr_expr_12.ns = 0L;
#line 586
  yyval.rel = __constr_expr_12;
#line 586
  yyval.rel.minutes = (yyvsp + -1)->intval;
#line 587
  goto switch_break;
  case_67: /* CIL Label */ 
#line 588
  __constr_expr_13.year = 0L;
#line 588
  __constr_expr_13.month = 0L;
#line 588
  __constr_expr_13.day = 0L;
#line 588
  __constr_expr_13.hour = 0L;
#line 588
  __constr_expr_13.minutes = 0L;
#line 588
  __constr_expr_13.seconds = (long_time_t )0;
#line 588
  __constr_expr_13.ns = 0L;
#line 588
  yyval.rel = __constr_expr_13;
#line 588
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 589
  goto switch_break;
  case_68: /* CIL Label */ 
#line 590
  __constr_expr_14.year = 0L;
#line 590
  __constr_expr_14.month = 0L;
#line 590
  __constr_expr_14.day = 0L;
#line 590
  __constr_expr_14.hour = 0L;
#line 590
  __constr_expr_14.minutes = 0L;
#line 590
  __constr_expr_14.seconds = (long_time_t )0;
#line 590
  __constr_expr_14.ns = 0L;
#line 590
  yyval.rel = __constr_expr_14;
#line 590
  yyval.rel.minutes = 1L;
#line 591
  goto switch_break;
  case_69: /* CIL Label */ 
#line 592
  __constr_expr_15.year = 0L;
#line 592
  __constr_expr_15.month = 0L;
#line 592
  __constr_expr_15.day = 0L;
#line 592
  __constr_expr_15.hour = 0L;
#line 592
  __constr_expr_15.minutes = 0L;
#line 592
  __constr_expr_15.seconds = (long_time_t )0;
#line 592
  __constr_expr_15.ns = 0L;
#line 592
  yyval.rel = __constr_expr_15;
#line 592
  yyval.rel.seconds = (yyvsp + -1)->intval;
#line 593
  goto switch_break;
  case_70: /* CIL Label */ 
#line 594
  __constr_expr_16.year = 0L;
#line 594
  __constr_expr_16.month = 0L;
#line 594
  __constr_expr_16.day = 0L;
#line 594
  __constr_expr_16.hour = 0L;
#line 594
  __constr_expr_16.minutes = 0L;
#line 594
  __constr_expr_16.seconds = (long_time_t )0;
#line 594
  __constr_expr_16.ns = 0L;
#line 594
  yyval.rel = __constr_expr_16;
#line 594
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 595
  goto switch_break;
  case_71: /* CIL Label */ 
#line 596
  __constr_expr_17.year = 0L;
#line 596
  __constr_expr_17.month = 0L;
#line 596
  __constr_expr_17.day = 0L;
#line 596
  __constr_expr_17.hour = 0L;
#line 596
  __constr_expr_17.minutes = 0L;
#line 596
  __constr_expr_17.seconds = (long_time_t )0;
#line 596
  __constr_expr_17.ns = 0L;
#line 596
  yyval.rel = __constr_expr_17;
#line 596
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 596
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 597
  goto switch_break;
  case_72: /* CIL Label */ 
#line 598
  __constr_expr_18.year = 0L;
#line 598
  __constr_expr_18.month = 0L;
#line 598
  __constr_expr_18.day = 0L;
#line 598
  __constr_expr_18.hour = 0L;
#line 598
  __constr_expr_18.minutes = 0L;
#line 598
  __constr_expr_18.seconds = (long_time_t )0;
#line 598
  __constr_expr_18.ns = 0L;
#line 598
  yyval.rel = __constr_expr_18;
#line 598
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 598
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 599
  goto switch_break;
  case_73: /* CIL Label */ 
#line 600
  __constr_expr_19.year = 0L;
#line 600
  __constr_expr_19.month = 0L;
#line 600
  __constr_expr_19.day = 0L;
#line 600
  __constr_expr_19.hour = 0L;
#line 600
  __constr_expr_19.minutes = 0L;
#line 600
  __constr_expr_19.seconds = (long_time_t )0;
#line 600
  __constr_expr_19.ns = 0L;
#line 600
  yyval.rel = __constr_expr_19;
#line 600
  yyval.rel.seconds = (long_time_t )1;
#line 601
  goto switch_break;
  case_75: /* CIL Label */ 
#line 606
  __constr_expr_20.year = 0L;
#line 606
  __constr_expr_20.month = 0L;
#line 606
  __constr_expr_20.day = 0L;
#line 606
  __constr_expr_20.hour = 0L;
#line 606
  __constr_expr_20.minutes = 0L;
#line 606
  __constr_expr_20.seconds = (long_time_t )0;
#line 606
  __constr_expr_20.ns = 0L;
#line 606
  yyval.rel = __constr_expr_20;
#line 606
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 607
  goto switch_break;
  case_76: /* CIL Label */ 
#line 608
  __constr_expr_21.year = 0L;
#line 608
  __constr_expr_21.month = 0L;
#line 608
  __constr_expr_21.day = 0L;
#line 608
  __constr_expr_21.hour = 0L;
#line 608
  __constr_expr_21.minutes = 0L;
#line 608
  __constr_expr_21.seconds = (long_time_t )0;
#line 608
  __constr_expr_21.ns = 0L;
#line 608
  yyval.rel = __constr_expr_21;
#line 608
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 609
  goto switch_break;
  case_77: /* CIL Label */ 
#line 610
  __constr_expr_22.year = 0L;
#line 610
  __constr_expr_22.month = 0L;
#line 610
  __constr_expr_22.day = 0L;
#line 610
  __constr_expr_22.hour = 0L;
#line 610
  __constr_expr_22.minutes = 0L;
#line 610
  __constr_expr_22.seconds = (long_time_t )0;
#line 610
  __constr_expr_22.ns = 0L;
#line 610
  yyval.rel = __constr_expr_22;
#line 610
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 611
  goto switch_break;
  case_78: /* CIL Label */ 
#line 612
  __constr_expr_23.year = 0L;
#line 612
  __constr_expr_23.month = 0L;
#line 612
  __constr_expr_23.day = 0L;
#line 612
  __constr_expr_23.hour = 0L;
#line 612
  __constr_expr_23.minutes = 0L;
#line 612
  __constr_expr_23.seconds = (long_time_t )0;
#line 612
  __constr_expr_23.ns = 0L;
#line 612
  yyval.rel = __constr_expr_23;
#line 612
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 613
  goto switch_break;
  case_79: /* CIL Label */ 
#line 614
  __constr_expr_24.year = 0L;
#line 614
  __constr_expr_24.month = 0L;
#line 614
  __constr_expr_24.day = 0L;
#line 614
  __constr_expr_24.hour = 0L;
#line 614
  __constr_expr_24.minutes = 0L;
#line 614
  __constr_expr_24.seconds = (long_time_t )0;
#line 614
  __constr_expr_24.ns = 0L;
#line 614
  yyval.rel = __constr_expr_24;
#line 614
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 615
  goto switch_break;
  case_80: /* CIL Label */ 
#line 616
  __constr_expr_25.year = 0L;
#line 616
  __constr_expr_25.month = 0L;
#line 616
  __constr_expr_25.day = 0L;
#line 616
  __constr_expr_25.hour = 0L;
#line 616
  __constr_expr_25.minutes = 0L;
#line 616
  __constr_expr_25.seconds = (long_time_t )0;
#line 616
  __constr_expr_25.ns = 0L;
#line 616
  yyval.rel = __constr_expr_25;
#line 616
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 617
  goto switch_break;
  case_81: /* CIL Label */ 
#line 621
  __constr_expr_26.year = 0L;
#line 621
  __constr_expr_26.month = 0L;
#line 621
  __constr_expr_26.day = 0L;
#line 621
  __constr_expr_26.hour = 0L;
#line 621
  __constr_expr_26.minutes = 0L;
#line 621
  __constr_expr_26.seconds = (long_time_t )0;
#line 621
  __constr_expr_26.ns = 0L;
#line 621
  yyval.rel = __constr_expr_26;
#line 621
  yyval.rel.day = (yyvsp + 0)->intval;
#line 622
  goto switch_break;
  case_85: /* CIL Label */ 
#line 629
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 629
  yyval.timespec.tv_nsec = 0L;
#line 630
  goto switch_break;
  case_87: /* CIL Label */ 
#line 635
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 635
  yyval.timespec.tv_nsec = 0L;
#line 636
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 640
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
  }
#line 641
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 648
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
#line 649
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 651
  goto switch_break;
  case_90: /* CIL Label */ 
#line 655
  yyval.intval = -1L;
#line 656
  goto switch_break;
  case_91: /* CIL Label */ 
#line 657
  yyval.intval = (yyvsp + 0)->textintval.value;
#line 658
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2410 "parse-datetime.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2425
  yyvsp -= yylen;
#line 2425
  yyssp -= yylen;
#line 2426
  yylen = 0;
#line 2429
  yyvsp ++;
#line 2429
  *yyvsp = yyval;
#line 2435
  yyn = (int )yyr1[yyn];
#line 2437
  yystate = (int )((int const   )yypgoto[yyn - 28] + (int const   )*yyssp);
#line 2438
  if (0 <= yystate) {
#line 2438
    if (yystate <= 112) {
#line 2438
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2439
        yystate = (int )yytable[yystate];
      } else {
#line 2441
        yystate = (int )yydefgoto[yyn - 28];
      }
    } else {
#line 2441
      yystate = (int )yydefgoto[yyn - 28];
    }
  } else {
#line 2441
    yystate = (int )yydefgoto[yyn - 28];
  }
#line 2443
  goto yynewstate;
  yyerrlab: 
#line 2452
  if (yychar == -2) {
#line 2452
    yytoken = -2;
  } else {
#line 2452
    if ((unsigned int )yychar <= 277U) {
#line 2452
      tmp___1 = (int const   )yytranslate[yychar];
    } else {
#line 2452
      tmp___1 = (int const   )2;
    }
#line 2452
    yytoken = (int )tmp___1;
  }
#line 2455
  if (! yyerrstatus) {
    {
#line 2457
    yynerrs ++;
#line 2459
    yyerror((parser_control const   *)pc, "syntax error");
    }
  }
#line 2496
  if (yyerrstatus == 3) {
#line 2501
    if (yychar <= 0) {
#line 2504
      if (yychar == 0) {
#line 2505
        goto yyabortlab;
      }
    } else {
      {
#line 2509
      yydestruct("Error: discarding", yytoken, & yylval, pc);
#line 2511
      yychar = -2;
      }
    }
  }
#line 2517
  goto yyerrlab1;
#line 2533
  yyvsp -= yylen;
#line 2533
  yyssp -= yylen;
#line 2534
  yylen = 0;
#line 2536
  yystate = (int )*yyssp;
#line 2537
  goto yyerrlab1;
  yyerrlab1: 
#line 2544
  yyerrstatus = 3;
  {
#line 2546
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2548
    yyn = (int )yypact[yystate];
#line 2549
    if (! (yyn == -93)) {
#line 2551
      yyn ++;
#line 2552
      if (0 <= yyn) {
#line 2552
        if (yyn <= 112) {
#line 2552
          if ((int const   )yycheck[yyn] == 1) {
#line 2554
            yyn = (int )yytable[yyn];
#line 2555
            if (0 < yyn) {
#line 2556
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2561
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2562
      goto yyabortlab;
    }
    {
#line 2565
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, pc);
#line 2567
    yyvsp --;
#line 2567
    yyssp --;
#line 2568
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2572
  yyvsp ++;
#line 2572
  *yyvsp = yylval;
#line 2578
  yystate = yyn;
#line 2579
  goto yynewstate;
  yyacceptlab: 
#line 2586
  yyresult = 0;
#line 2587
  goto yyreturn;
  yyabortlab: 
#line 2593
  yyresult = 1;
#line 2594
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2601
  yyerror((parser_control const   *)pc, "memory exhausted");
#line 2602
  yyresult = 2;
  }
  yyreturn: 
#line 2607
  if (yychar != -2) {
#line 2611
    if ((unsigned int )yychar <= 277U) {
#line 2611
      yytoken = (int )yytranslate[yychar];
    } else {
#line 2611
      yytoken = 2;
    }
    {
#line 2612
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, pc);
    }
  }
#line 2617
  yyvsp -= yylen;
#line 2617
  yyssp -= yylen;
  {
#line 2619
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2619
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2619
      goto while_break___2;
    }
    {
#line 2621
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
#line 2623
    yyvsp --;
#line 2623
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2626
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2627
    free((void *)yyss);
    }
  }
#line 2634
  return (yyresult);
}
}
#line 662 "parse-datetime.y"
static table const   meridian_table[5]  = {      {"AM", 270, 0}, 
        {"A.M.", 270, 0}, 
        {"PM", 270, 1}, 
        {"P.M.", 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 671 "parse-datetime.y"
static table const   dst_table[1]  = {      {"DST", 259, 0}};
#line 676 "parse-datetime.y"
static table const   month_and_day_table[25]  = 
#line 676
  {      {"JANUARY", 271, 1}, 
        {"FEBRUARY", 271, 2}, 
        {"MARCH", 271, 3}, 
        {"APRIL", 271, 4}, 
        {"MAY", 271, 5}, 
        {"JUNE", 271, 6}, 
        {"JULY", 271, 7}, 
        {"AUGUST", 271, 8}, 
        {"SEPTEMBER", 271, 9}, 
        {"SEPT", 271, 9}, 
        {"OCTOBER", 271, 10}, 
        {"NOVEMBER", 271, 11}, 
        {"DECEMBER", 271, 12}, 
        {"SUNDAY", 267, 0}, 
        {"MONDAY", 267, 1}, 
        {"TUESDAY", 267, 2}, 
        {"TUES", 267, 2}, 
        {"WEDNESDAY", 267, 3}, 
        {"WEDNES", 267, 3}, 
        {"THURSDAY", 267, 4}, 
        {"THUR", 267, 4}, 
        {"THURS", 267, 4}, 
        {"FRIDAY", 267, 5}, 
        {"SATURDAY", 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 705 "parse-datetime.y"
static table const   time_units_table[11]  = 
#line 705
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 721 "parse-datetime.y"
static table const   relative_time_table[21]  = 
#line 721
  {      {"TOMORROW", 266, 1}, 
        {"YESTERDAY", 266, -1}, 
        {"TODAY", 266, 0}, 
        {"NOW", 266, 0}, 
        {"LAST", 272, -1}, 
        {"THIS", 272, 0}, 
        {"NEXT", 272, 1}, 
        {"FIRST", 272, 1}, 
        {"THIRD", 272, 3}, 
        {"FOURTH", 272, 4}, 
        {"FIFTH", 272, 5}, 
        {"SIXTH", 272, 6}, 
        {"SEVENTH", 272, 7}, 
        {"EIGHTH", 272, 8}, 
        {"NINTH", 272, 9}, 
        {"TENTH", 272, 10}, 
        {"ELEVENTH", 272, 11}, 
        {"TWELFTH", 272, 12}, 
        {"AGO", 258, -1}, 
        {"HENCE", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 750 "parse-datetime.y"
static table const   universal_time_zone_table[4]  = {      {"GMT", 273, 0}, 
        {"UT", 273, 0}, 
        {"UTC", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 763 "parse-datetime.y"
static table const   time_zone_table[48]  = 
#line 763
  {      {"WET", 273, 0}, 
        {"WEST", 268, 0}, 
        {"BST", 268, 0}, 
        {"ART", 273, -180}, 
        {"BRT", 273, -180}, 
        {"BRST", 268, -180}, 
        {"NST", 273, -210}, 
        {"NDT", 268, -210}, 
        {"AST", 273, -240}, 
        {"ADT", 268, -240}, 
        {"CLT", 273, -240}, 
        {"CLST", 268, -240}, 
        {"EST", 273, -300}, 
        {"EDT", 268, -300}, 
        {"CST", 273, -360}, 
        {"CDT", 268, -360}, 
        {"MST", 273, -420}, 
        {"MDT", 268, -420}, 
        {"PST", 273, -480}, 
        {"PDT", 268, -480}, 
        {"AKST", 273, -540}, 
        {"AKDT", 268, -540}, 
        {"HST", 273, -600}, 
        {"HAST", 273, -600}, 
        {"HADT", 268, -600}, 
        {"SST", 273, -720}, 
        {"WAT", 273, 60}, 
        {"CET", 273, 60}, 
        {"CEST", 268, 60}, 
        {"MET", 273, 60}, 
        {"MEZ", 273, 60}, 
        {"MEST", 268, 60}, 
        {"MESZ", 268, 60}, 
        {"EET", 273, 120}, 
        {"EEST", 268, 120}, 
        {"CAT", 273, 120}, 
        {"SAST", 273, 120}, 
        {"EAT", 273, 180}, 
        {"MSK", 273, 180}, 
        {"MSD", 268, 180}, 
        {"IST", 273, 330}, 
        {"SGT", 273, 480}, 
        {"KST", 273, 540}, 
        {"JST", 273, 540}, 
        {"GST", 273, 600}, 
        {"NZST", 273, 720}, 
        {"NZDT", 268, 720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 819 "parse-datetime.y"
static table const   military_table[26]  = 
#line 819
  {      {"A", 273, -60}, 
        {"B", 273, -120}, 
        {"C", 273, -180}, 
        {"D", 273, -240}, 
        {"E", 273, -300}, 
        {"F", 273, -360}, 
        {"G", 273, -420}, 
        {"H", 273, -480}, 
        {"I", 273, -540}, 
        {"K", 273, -600}, 
        {"L", 273, -660}, 
        {"M", 273, -720}, 
        {"N", 273, 60}, 
        {"O", 273, 120}, 
        {"P", 273, 180}, 
        {"Q", 273, 240}, 
        {"R", 273, 300}, 
        {"S", 273, 360}, 
        {"T", 'T', 0}, 
        {"U", 273, 480}, 
        {"V", 273, 540}, 
        {"W", 273, 600}, 
        {"X", 273, 660}, 
        {"Y", 273, 720}, 
        {"Z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 858 "parse-datetime.y"
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) 
{ 
  long n_minutes ;
  long tmp ;
  int tmp___0 ;

  {
#line 865
  if (s.digits <= 2UL) {
#line 865
    if (mm < 0L) {
#line 866
      s.value *= 100L;
    }
  }
#line 868
  if (mm < 0L) {
#line 869
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
#line 871
    if (s.negative) {
#line 871
      tmp = - mm;
    } else {
#line 871
      tmp = mm;
    }
#line 871
    n_minutes = s.value * 60L + tmp;
  }
  {
#line 876
  tmp___0 = abs((int )n_minutes);
  }
#line 876
  if (1440 < tmp___0) {
#line 877
    (pc->zones_seen) ++;
  }
#line 879
  return (n_minutes);
}
}
#line 882 "parse-datetime.y"
static int to_hour(long hours , int meridian ) 
{ 
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 890
  if (meridian == 0) {
#line 890
    goto case_0;
  }
#line 892
  if (meridian == 1) {
#line 892
    goto case_1;
  }
#line 887
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 889
  if (0L <= hours) {
#line 889
    if (hours < 24L) {
#line 889
      tmp = hours;
    } else {
#line 889
      tmp = -1L;
    }
  } else {
#line 889
    tmp = -1L;
  }
#line 889
  return ((int )tmp);
  case_0: /* CIL Label */ 
#line 891
  if (0L < hours) {
#line 891
    if (hours < 12L) {
#line 891
      tmp___1 = hours;
    } else {
#line 891
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 891
    if (hours == 12L) {
#line 891
      tmp___0 = 0;
    } else {
#line 891
      tmp___0 = -1;
    }
#line 891
    tmp___1 = (long )tmp___0;
  }
#line 891
  return ((int )tmp___1);
  case_1: /* CIL Label */ 
#line 893
  if (0L < hours) {
#line 893
    if (hours < 12L) {
#line 893
      tmp___3 = hours + 12L;
    } else {
#line 893
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 893
    if (hours == 12L) {
#line 893
      tmp___2 = 12;
    } else {
#line 893
      tmp___2 = -1;
    }
#line 893
    tmp___3 = (long )tmp___2;
  }
#line 893
  return ((int )tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 897 "parse-datetime.y"
static long to_year(textint textyear ) 
{ 
  long year ;
  int tmp ;

  {
#line 900
  year = textyear.value;
#line 902
  if (year < 0L) {
#line 903
    year = - year;
  } else
#line 907
  if (textyear.digits == 2UL) {
#line 908
    if (year < 69L) {
#line 908
      tmp = 2000;
    } else {
#line 908
      tmp = 1900;
    }
#line 908
    year += (long )tmp;
  }
#line 910
  return (year);
}
}
#line 913 "parse-datetime.y"
static table const   * __attribute__((__pure__)) lookup_zone(parser_control const   *pc ,
                                                             char const   *name ) 
{ 
  table const   *tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 918
  tp = universal_time_zone_table;
  {
#line 918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 918
    if (! tp->name) {
#line 918
      goto while_break;
    }
    {
#line 919
    tmp = strcmp(name, (char const   *)tp->name);
    }
#line 919
    if (tmp == 0) {
#line 920
      return ((table const   */* __attribute__((__pure__)) */)tp);
    }
#line 918
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 924
  tp = (table const   *)(pc->local_time_zone_table);
  {
#line 924
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 924
    if (! tp->name) {
#line 924
      goto while_break___0;
    }
    {
#line 925
    tmp___0 = strcmp(name, (char const   *)tp->name);
    }
#line 925
    if (tmp___0 == 0) {
#line 926
      return ((table const   */* __attribute__((__pure__)) */)tp);
    }
#line 924
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 928
  tp = time_zone_table;
  {
#line 928
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 928
    if (! tp->name) {
#line 928
      goto while_break___1;
    }
    {
#line 929
    tmp___1 = strcmp(name, (char const   *)tp->name);
    }
#line 929
    if (tmp___1 == 0) {
#line 930
      return ((table const   */* __attribute__((__pure__)) */)tp);
    }
#line 928
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 932
  return ((table const   */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 962 "parse-datetime.y"
static table const   *lookup_word(parser_control const   *pc , char *word ) 
{ 
  char *p ;
  char *q ;
  size_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  table const   * __attribute__((__pure__)) tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char tmp___10 ;
  table const   * __attribute__((__pure__)) tmp___11 ;

  {
#line 973
  p = word;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! *p) {
#line 973
      goto while_break;
    }
    {
#line 975
    ch = (unsigned char )*p;
#line 976
    tmp = c_toupper((int )ch);
#line 976
    *p = (char )tmp;
#line 973
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  tp = meridian_table;
  {
#line 979
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 979
    if (! tp->name) {
#line 979
      goto while_break___0;
    }
    {
#line 980
    tmp___0 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 980
    if (tmp___0 == 0) {
#line 981
      return (tp);
    }
#line 979
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 984
  wordlen = strlen((char const   *)word);
  }
#line 985
  if (wordlen == 3UL) {
#line 985
    tmp___1 = 1;
  } else
#line 985
  if (wordlen == 4UL) {
#line 985
    if ((int )*(word + 3) == 46) {
#line 985
      tmp___1 = 1;
    } else {
#line 985
      tmp___1 = 0;
    }
  } else {
#line 985
    tmp___1 = 0;
  }
#line 985
  abbrev = (_Bool )tmp___1;
#line 987
  tp = month_and_day_table;
  {
#line 987
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 987
    if (! tp->name) {
#line 987
      goto while_break___1;
    }
#line 988
    if (abbrev) {
      {
#line 988
      tmp___2 = strncmp((char const   *)word, (char const   *)tp->name, (size_t )3);
#line 988
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 988
      tmp___3 = strcmp((char const   *)word, (char const   *)tp->name);
#line 988
      tmp___4 = tmp___3;
      }
    }
#line 988
    if (tmp___4 == 0) {
#line 989
      return (tp);
    }
#line 987
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 991
  tmp___5 = lookup_zone(pc, (char const   *)word);
#line 991
  tp = (table const   *)tmp___5;
  }
#line 991
  if (tp) {
#line 992
    return (tp);
  }
  {
#line 994
  tmp___6 = strcmp((char const   *)word, (char const   *)dst_table[0].name);
  }
#line 994
  if (tmp___6 == 0) {
#line 995
    return (dst_table);
  }
#line 997
  tp = time_units_table;
  {
#line 997
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 997
    if (! tp->name) {
#line 997
      goto while_break___2;
    }
    {
#line 998
    tmp___7 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 998
    if (tmp___7 == 0) {
#line 999
      return (tp);
    }
#line 997
    tp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1002
  if ((int )*(word + (wordlen - 1UL)) == 83) {
#line 1004
    *(word + (wordlen - 1UL)) = (char )'\000';
#line 1005
    tp = time_units_table;
    {
#line 1005
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1005
      if (! tp->name) {
#line 1005
        goto while_break___3;
      }
      {
#line 1006
      tmp___8 = strcmp((char const   *)word, (char const   *)tp->name);
      }
#line 1006
      if (tmp___8 == 0) {
#line 1007
        return (tp);
      }
#line 1005
      tp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1008
    *(word + (wordlen - 1UL)) = (char )'S';
  }
#line 1011
  tp = relative_time_table;
  {
#line 1011
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1011
    if (! tp->name) {
#line 1011
      goto while_break___4;
    }
    {
#line 1012
    tmp___9 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 1012
    if (tmp___9 == 0) {
#line 1013
      return (tp);
    }
#line 1011
    tp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1016
  if (wordlen == 1UL) {
#line 1017
    tp = military_table;
    {
#line 1017
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1017
      if (! tp->name) {
#line 1017
        goto while_break___5;
      }
#line 1018
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
#line 1019
        return (tp);
      }
#line 1017
      tp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1022
  period_found = (_Bool)0;
#line 1022
  q = word;
#line 1022
  p = q;
  {
#line 1022
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1022
    tmp___10 = *q;
#line 1022
    *p = tmp___10;
#line 1022
    if (! tmp___10) {
#line 1022
      goto while_break___6;
    }
#line 1023
    if ((int )*q == 46) {
#line 1024
      period_found = (_Bool)1;
    } else {
#line 1026
      p ++;
    }
#line 1022
    q ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1027
  if (period_found) {
    {
#line 1027
    tmp___11 = lookup_zone(pc, (char const   *)word);
#line 1027
    tp = (table const   *)tmp___11;
    }
#line 1027
    if (tp) {
#line 1028
      return (tp);
    }
  }
#line 1030
  return ((table const   *)((void *)0));
}
}
#line 1033 "parse-datetime.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) 
{ 
  unsigned char c ;
  size_t count ;
  _Bool tmp ;
  char const   *p ;
  int sign ;
  unsigned long value___0 ;
  _Bool tmp___0 ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  char const   *tmp___8 ;
  unsigned char tmp___9 ;
  char const   *tmp___10 ;
  void *__cil_tmp28 ;

  {
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1041
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1041
      c = (unsigned char )*(pc->input);
#line 1041
      tmp = c_isspace((int )c);
      }
#line 1041
      if (! tmp) {
#line 1041
        goto while_break___0;
      }
#line 1042
      (pc->input) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1044
    if ((unsigned int )c - 48U <= 9U) {
#line 1044
      goto _L___2;
    } else
#line 1044
    if ((int )c == 45) {
#line 1044
      goto _L___2;
    } else
#line 1044
    if ((int )c == 43) {
      _L___2: /* CIL Label */ 
#line 1049
      if ((int )c == 45) {
#line 1049
        goto _L;
      } else
#line 1049
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 1051
        if ((int )c == 45) {
#line 1051
          sign = -1;
        } else {
#line 1051
          sign = 1;
        }
        {
#line 1052
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1052
          (pc->input) ++;
#line 1052
          c = (unsigned char )*(pc->input);
#line 1052
          tmp___0 = c_isspace((int )c);
          }
#line 1052
          if (! tmp___0) {
#line 1052
            goto while_break___1;
          }
#line 1053
          goto while_continue___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1054
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1056
          goto __Cont;
        }
      } else {
#line 1059
        sign = 0;
      }
#line 1060
      p = pc->input;
#line 1061
      value___0 = 0UL;
      {
#line 1061
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1063
        value1 = value___0 + (unsigned long )((int )c - 48);
#line 1064
        if (value1 < value___0) {
#line 1065
          return ('?');
        }
#line 1066
        value___0 = value1;
#line 1067
        p ++;
#line 1067
        c = (unsigned char )*p;
#line 1068
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1069
          goto while_break___2;
        }
#line 1070
        if (1844674407370955161UL < value___0) {
#line 1071
          return ('?');
        }
#line 1061
        value___0 *= 10UL;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1073
      if ((int )c == 46) {
#line 1073
        goto _L___1;
      } else
#line 1073
      if ((int )c == 44) {
        _L___1: /* CIL Label */ 
#line 1073
        if ((unsigned int )*(p + 1) - 48U <= 9U) {
#line 1081
          if (sign < 0) {
#line 1083
            s = (time_t )(- value___0);
#line 1084
            if (0L < s) {
#line 1085
              return ('?');
            }
#line 1086
            value1___0 = (unsigned long )(- s);
          } else {
#line 1090
            s = (time_t )value___0;
#line 1091
            if (s < 0L) {
#line 1092
              return ('?');
            }
#line 1093
            value1___0 = (unsigned long )s;
          }
#line 1095
          if (value___0 != value1___0) {
#line 1096
            return ('?');
          }
#line 1099
          p ++;
#line 1100
          tmp___1 = p;
#line 1100
          p ++;
#line 1100
          ns = (int )((int const   )*tmp___1 - 48);
#line 1101
          digits = 2;
          {
#line 1101
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1101
            if (! (digits <= 9)) {
#line 1101
              goto while_break___3;
            }
#line 1103
            ns *= 10;
#line 1104
            if ((unsigned int )*p - 48U <= 9U) {
#line 1105
              tmp___2 = p;
#line 1105
              p ++;
#line 1105
              ns += (int )((int const   )*tmp___2 - 48);
            }
#line 1101
            digits ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1109
          if (sign < 0) {
            {
#line 1110
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1110
              if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1110
                goto while_break___4;
              }
#line 1111
              if ((int const   )*p != 48) {
#line 1113
                ns ++;
#line 1114
                goto while_break___4;
              }
#line 1110
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          {
#line 1116
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1116
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1116
              goto while_break___5;
            }
#line 1117
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1122
          if (sign < 0) {
#line 1122
            if (ns) {
#line 1124
              s --;
#line 1125
              if (! (s < 0L)) {
#line 1126
                return ('?');
              }
#line 1127
              ns = 1000000000 - ns;
            }
          }
#line 1130
          lvalp->timespec.tv_sec = s;
#line 1131
          lvalp->timespec.tv_nsec = (long )ns;
#line 1132
          pc->input = p;
#line 1133
          if (sign) {
#line 1133
            tmp___3 = 276;
          } else {
#line 1133
            tmp___3 = 277;
          }
#line 1133
          return (tmp___3);
        } else {
#line 1073
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1137
        lvalp->textintval.negative = (_Bool )(sign < 0);
#line 1138
        if (sign < 0) {
#line 1140
          lvalp->textintval.value = (long )(- value___0);
#line 1141
          if (0L < lvalp->textintval.value) {
#line 1142
            return ('?');
          }
        } else {
#line 1146
          lvalp->textintval.value = (long )value___0;
#line 1147
          if (lvalp->textintval.value < 0L) {
#line 1148
            return ('?');
          }
        }
#line 1150
        lvalp->textintval.digits = (size_t )(p - pc->input);
#line 1151
        pc->input = p;
#line 1152
        if (sign) {
#line 1152
          tmp___4 = 274;
        } else {
#line 1152
          tmp___4 = 275;
        }
#line 1152
        return (tmp___4);
      }
    }
    {
#line 1156
    tmp___7 = c_isalpha((int )c);
    }
#line 1156
    if (tmp___7) {
#line 1159
      p___0 = buff;
      {
#line 1162
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1164
        if ((unsigned long )(p___0 - buff) < sizeof(buff) - 1UL) {
#line 1165
          tmp___5 = p___0;
#line 1165
          p___0 ++;
#line 1165
          *tmp___5 = (char )c;
        }
        {
#line 1166
        (pc->input) ++;
#line 1166
        c = (unsigned char )*(pc->input);
#line 1162
        tmp___6 = c_isalpha((int )c);
        }
#line 1162
        if (! tmp___6) {
#line 1162
          if (! ((int )c == 46)) {
#line 1162
            goto while_break___6;
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1170
      *p___0 = (char )'\000';
#line 1171
      tp = lookup_word((parser_control const   *)pc, buff);
      }
#line 1172
      if (! tp) {
#line 1173
        return ('?');
      }
#line 1174
      lvalp->intval = (long )tp->value;
#line 1175
      return ((int )tp->type);
    }
#line 1178
    if ((int )c != 40) {
      {
#line 1179
      tmp___8 = pc->input;
#line 1179
      (pc->input) ++;
#line 1179
      tmp___9 = to_uchar((char )*tmp___8);
      }
#line 1179
      return ((int )tmp___9);
    }
#line 1181
    count = (size_t )0;
    {
#line 1182
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1184
      tmp___10 = pc->input;
#line 1184
      (pc->input) ++;
#line 1184
      c = (unsigned char )*tmp___10;
#line 1185
      if ((int )c == 0) {
#line 1186
        return ((int )c);
      }
#line 1187
      if ((int )c == 40) {
#line 1188
        count ++;
      } else
#line 1189
      if ((int )c == 41) {
#line 1190
        count --;
      }
#line 1182
      if (! (count != 0UL)) {
#line 1182
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1197 "parse-datetime.y"
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 


  {
#line 1201
  return (0);
}
}
#line 1208 "parse-datetime.y"
static _Bool mktime_ok(struct tm  const  *tm0 , struct tm  const  *tm1 , time_t t ) 
{ 
  struct tm *tmp ;

  {
#line 1211
  if (t == -1L) {
    {
#line 1216
    tmp = localtime((time_t const   *)(& t));
#line 1216
    tm1 = (struct tm  const  *)tmp;
    }
#line 1217
    if (! tm1) {
#line 1218
      return ((_Bool)0);
    }
  }
#line 1221
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
#line 1235 "parse-datetime.y"
static char *get_tz(char *tzbuf ) 
{ 
  char *tz ;
  char *tmp ;
  size_t tzsize ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp8 ;

  {
  {
#line 1238
  tmp = getenv("TZ");
#line 1238
  tz = tmp;
  }
#line 1239
  if (tz) {
    {
#line 1241
    tmp___0 = strlen((char const   *)tz);
#line 1241
    tzsize = tmp___0 + 1UL;
    }
#line 1242
    if (tzsize <= 100UL) {
      {
#line 1242
      tmp___1 = memcpy((void */* __restrict  */)tzbuf, (void const   */* __restrict  */)tz,
                       tzsize);
#line 1242
      tz = (char *)tmp___1;
      }
    } else {
      {
#line 1242
      tmp___2 = xmemdup((void const   *)tz, tzsize);
#line 1242
      tz = (char *)tmp___2;
      }
    }
  }
#line 1246
  return (tz);
}
}
#line 1253 "parse-datetime.y"
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) 
{ 
  time_t Start ;
  long Start_ns ;
  struct tm  const  *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  unsigned char c ;
  _Bool tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  _Bool ok ;
  struct tm *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tzbase ;
  size_t tzsize ;
  char const   *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  _Bool large_tz ;
  _Bool setenv_ok ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  relative_time __constr_expr_27 ;
  int quarter ;
  time_t probe ;
  struct tm  const  *probe_tm ;
  struct tm *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long time_zone ;
  long abs_time_zone ;
  long tmp___10 ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[sizeof("XXX+0:00") + (sizeof(pc.time_zone) * 8UL) / 3UL] ;
  int tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  int year ;
  int month ;
  int day ;
  long delta ;
  time_t t1 ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long_time_t d3 ;
  long_time_t t3 ;
  long d4 ;
  long_time_t t4 ;
  time_t t5 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;

  {
#line 1265
  tz_was_altered = (_Bool)0;
#line 1266
  tz0 = (char *)((void *)0);
#line 1268
  ok = (_Bool)1;
#line 1270
  if (! now) {
    {
#line 1272
    gettime(& gettime_buffer);
#line 1273
    now = (struct timespec  const  *)(& gettime_buffer);
    }
  }
  {
#line 1276
  Start = (time_t )now->tv_sec;
#line 1277
  Start_ns = (long )now->tv_nsec;
#line 1279
  tmp___0 = localtime(& now->tv_sec);
#line 1279
  tmp = (struct tm  const  *)tmp___0;
  }
#line 1280
  if (! tmp) {
#line 1281
    return ((_Bool)0);
  }
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1283
    c = (unsigned char )*p;
#line 1283
    tmp___1 = c_isspace((int )c);
    }
#line 1283
    if (! tmp___1) {
#line 1283
      goto while_break;
    }
#line 1284
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1286
  tmp___5 = strncmp(p, "TZ=\"", (size_t )4);
  }
#line 1286
  if (tmp___5 == 0) {
#line 1288
    tzbase = p + 4;
#line 1289
    tzsize = (size_t )1;
#line 1292
    s = tzbase;
    {
#line 1292
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1292
      if (! *s) {
#line 1292
        goto while_break___0;
      }
#line 1293
      if ((int const   )*s == 92) {
#line 1295
        s ++;
#line 1296
        if (! ((int const   )*s == 92)) {
#line 1296
          if (! ((int const   )*s == 34)) {
#line 1297
            goto while_break___0;
          }
        }
      } else
#line 1299
      if ((int const   )*s == 34) {
        {
#line 1304
        large_tz = (_Bool )(100UL < tzsize);
#line 1307
        free((void *)tz0);
#line 1308
        tz0 = get_tz((char *)(tz0buf));
        }
#line 1309
        if (large_tz) {
          {
#line 1309
          tmp___2 = xmalloc(tzsize);
#line 1309
          tz1 = (char *)tmp___2;
          }
        } else {
#line 1309
          tz1 = tz1buf;
        }
#line 1309
        z = tz1;
#line 1310
        s = tzbase;
        {
#line 1310
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1310
          if (! ((int const   )*s != 34)) {
#line 1310
            goto while_break___1;
          }
#line 1311
          tmp___3 = z;
#line 1311
          z ++;
#line 1311
          s += (int const   )*s == 92;
#line 1311
          *tmp___3 = (char )*s;
#line 1310
          s ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1312
        *z = (char )'\000';
#line 1313
        tmp___4 = setenv("TZ", (char const   *)tz1, 1);
#line 1313
        setenv_ok = (_Bool )(tmp___4 == 0);
        }
#line 1314
        if (large_tz) {
          {
#line 1315
          free((void *)tz1);
          }
        }
#line 1316
        if (! setenv_ok) {
#line 1317
          goto fail;
        }
#line 1318
        tz_was_altered = (_Bool)1;
#line 1319
        p = s + 1;
      }
#line 1292
      s ++;
#line 1292
      tzsize ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1326
  if ((int const   )*p == 0) {
#line 1327
    p = "0";
  }
#line 1329
  pc.input = p;
#line 1330
  pc.year.value = (long )tmp->tm_year;
#line 1331
  pc.year.value += 1900L;
#line 1332
  pc.year.digits = (size_t )0;
#line 1333
  pc.month = (long )(tmp->tm_mon + 1);
#line 1334
  pc.day = (long )tmp->tm_mday;
#line 1335
  pc.hour = (long )tmp->tm_hour;
#line 1336
  pc.minutes = (long )tmp->tm_min;
#line 1337
  pc.seconds.tv_sec = (__time_t )tmp->tm_sec;
#line 1338
  pc.seconds.tv_nsec = Start_ns;
#line 1339
  tm.tm_isdst = (int )tmp->tm_isdst;
#line 1341
  pc.meridian = 2;
#line 1342
  __constr_expr_27.year = 0L;
#line 1342
  __constr_expr_27.month = 0L;
#line 1342
  __constr_expr_27.day = 0L;
#line 1342
  __constr_expr_27.hour = 0L;
#line 1342
  __constr_expr_27.minutes = 0L;
#line 1342
  __constr_expr_27.seconds = (long_time_t )0;
#line 1342
  __constr_expr_27.ns = 0L;
#line 1342
  pc.rel = __constr_expr_27;
#line 1343
  pc.timespec_seen = (_Bool)0;
#line 1344
  pc.rels_seen = (_Bool)0;
#line 1345
  pc.dates_seen = (size_t )0;
#line 1346
  pc.days_seen = (size_t )0;
#line 1347
  pc.times_seen = (size_t )0;
#line 1348
  pc.local_zones_seen = (size_t )0;
#line 1349
  pc.dsts_seen = (size_t )0;
#line 1350
  pc.zones_seen = (size_t )0;
#line 1353
  pc.local_time_zone_table[0].name = (char const   *)tmp->tm_zone;
#line 1354
  pc.local_time_zone_table[0].type = 269;
#line 1355
  pc.local_time_zone_table[0].value = (int )tmp->tm_isdst;
#line 1356
  pc.local_time_zone_table[1].name = (char const   *)((void *)0);
#line 1362
  quarter = 1;
  {
#line 1362
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1362
    if (! (quarter <= 3)) {
#line 1362
      goto while_break___2;
    }
    {
#line 1364
    probe = Start + (time_t )(quarter * 7776000);
#line 1365
    tmp___6 = localtime((time_t const   *)(& probe));
#line 1365
    probe_tm = (struct tm  const  *)tmp___6;
    }
#line 1366
    if (probe_tm) {
#line 1366
      if (probe_tm->tm_zone) {
#line 1366
        if (probe_tm->tm_isdst != (int const   )pc.local_time_zone_table[0].value) {
#line 1370
          pc.local_time_zone_table[1].name = (char const   *)probe_tm->tm_zone;
#line 1371
          pc.local_time_zone_table[1].type = 269;
#line 1372
          pc.local_time_zone_table[1].value = (int )probe_tm->tm_isdst;
#line 1373
          pc.local_time_zone_table[2].name = (char const   *)((void *)0);
#line 1375
          goto while_break___2;
        }
      }
    }
#line 1362
    quarter ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1399
  if (pc.local_time_zone_table[0].name) {
#line 1399
    if (pc.local_time_zone_table[1].name) {
      {
#line 1399
      tmp___7 = strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
      }
#line 1399
      if (! tmp___7) {
#line 1406
        pc.local_time_zone_table[0].value = -1;
#line 1407
        pc.local_time_zone_table[1].name = (char const   *)((void *)0);
      }
    }
  }
  {
#line 1410
  tmp___8 = yyparse(& pc);
  }
#line 1410
  if (tmp___8 != 0) {
#line 1411
    goto fail;
  }
#line 1413
  if (pc.timespec_seen) {
#line 1414
    *result = pc.seconds;
  } else {
#line 1417
    if (1UL < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
#line 1419
      goto fail;
    }
    {
#line 1421
    tmp___9 = to_year(pc.year);
#line 1421
    tm.tm_year = (int )(tmp___9 - 1900L);
#line 1422
    tm.tm_mon = (int )(pc.month - 1L);
#line 1423
    tm.tm_mday = (int )pc.day;
    }
#line 1424
    if (pc.times_seen) {
#line 1424
      goto _L;
    } else
#line 1424
    if (pc.rels_seen) {
#line 1424
      if (! pc.dates_seen) {
#line 1424
        if (! pc.days_seen) {
          _L: /* CIL Label */ 
          {
#line 1426
          tm.tm_hour = to_hour(pc.hour, pc.meridian);
          }
#line 1427
          if (tm.tm_hour < 0) {
#line 1428
            goto fail;
          }
#line 1429
          tm.tm_min = (int )pc.minutes;
#line 1430
          tm.tm_sec = (int )pc.seconds.tv_sec;
        } else {
#line 1434
          tm.tm_sec = 0;
#line 1434
          tm.tm_min = tm.tm_sec;
#line 1434
          tm.tm_hour = tm.tm_min;
#line 1435
          pc.seconds.tv_nsec = 0L;
        }
      } else {
#line 1434
        tm.tm_sec = 0;
#line 1434
        tm.tm_min = tm.tm_sec;
#line 1434
        tm.tm_hour = tm.tm_min;
#line 1435
        pc.seconds.tv_nsec = 0L;
      }
    } else {
#line 1434
      tm.tm_sec = 0;
#line 1434
      tm.tm_min = tm.tm_sec;
#line 1434
      tm.tm_hour = tm.tm_min;
#line 1435
      pc.seconds.tv_nsec = 0L;
    }
#line 1439
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
#line 1440
      tm.tm_isdst = -1;
    }
#line 1444
    if (pc.local_zones_seen) {
#line 1445
      tm.tm_isdst = pc.local_isdst;
    }
    {
#line 1447
    tm0 = tm;
#line 1449
    Start = mktime(& tm);
#line 1451
    tmp___13 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                         Start);
    }
#line 1451
    if (! tmp___13) {
#line 1453
      if (! pc.zones_seen) {
#line 1454
        goto fail;
      } else {
#line 1467
        time_zone = pc.time_zone;
#line 1468
        if (time_zone < 0L) {
#line 1468
          tmp___10 = - time_zone;
        } else {
#line 1468
          tmp___10 = time_zone;
        }
#line 1468
        abs_time_zone = tmp___10;
#line 1469
        abs_time_zone_hour = abs_time_zone / 60L;
#line 1470
        abs_time_zone_min = (int )(abs_time_zone % 60L);
#line 1473
        if (! tz_was_altered) {
          {
#line 1474
          tz0 = get_tz((char *)(tz0buf));
          }
        }
        {
#line 1475
        sprintf((char */* __restrict  */)(tz1buf___0), (char const   */* __restrict  */)"XXX%s%ld:%02d",
                "-" + (time_zone < 0L), abs_time_zone_hour, abs_time_zone_min);
#line 1477
        tmp___11 = setenv("TZ", (char const   *)(tz1buf___0), 1);
        }
#line 1477
        if (tmp___11 != 0) {
#line 1478
          goto fail;
        }
        {
#line 1479
        tz_was_altered = (_Bool)1;
#line 1480
        tm = tm0;
#line 1481
        Start = mktime(& tm);
#line 1482
        tmp___12 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                             Start);
        }
#line 1482
        if (! tmp___12) {
#line 1483
          goto fail;
        }
      }
    }
#line 1487
    if (pc.days_seen) {
#line 1487
      if (! pc.dates_seen) {
#line 1489
        if (0L < pc.day_ordinal) {
#line 1489
          if (tm.tm_wday != pc.day_number) {
#line 1489
            tmp___14 = 1;
          } else {
#line 1489
            tmp___14 = 0;
          }
        } else {
#line 1489
          tmp___14 = 0;
        }
        {
#line 1489
        tm.tm_mday = (int )((long )tm.tm_mday + ((long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )tmp___14)));
#line 1493
        tm.tm_isdst = -1;
#line 1494
        Start = mktime(& tm);
        }
#line 1495
        if (Start == -1L) {
#line 1496
          goto fail;
        }
      }
    }
#line 1500
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
#line 1502
      year = (int )((long )tm.tm_year + pc.rel.year);
#line 1503
      month = (int )((long )tm.tm_mon + pc.rel.month);
#line 1504
      day = (int )((long )tm.tm_mday + pc.rel.day);
#line 1505
      if ((((year < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
#line 1508
        goto fail;
      }
      {
#line 1509
      tm.tm_year = year;
#line 1510
      tm.tm_mon = month;
#line 1511
      tm.tm_mday = day;
#line 1512
      tm.tm_hour = tm0.tm_hour;
#line 1513
      tm.tm_min = tm0.tm_min;
#line 1514
      tm.tm_sec = tm0.tm_sec;
#line 1515
      tm.tm_isdst = tm0.tm_isdst;
#line 1516
      Start = mktime(& tm);
      }
#line 1517
      if (Start == -1L) {
#line 1518
        goto fail;
      }
    }
#line 1523
    if (pc.zones_seen) {
#line 1525
      delta = pc.time_zone * 60L;
#line 1528
      delta -= tm.tm_gmtoff;
#line 1536
      t1 = Start - delta;
#line 1537
      if ((Start < t1) != (delta < 0L)) {
#line 1538
        goto fail;
      }
#line 1539
      Start = t1;
    }
#line 1550
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
#line 1551
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
#line 1552
    t0 = Start;
#line 1553
    d1 = 3600L * pc.rel.hour;
#line 1554
    t1___0 = t0 + d1;
#line 1555
    d2 = 60L * pc.rel.minutes;
#line 1556
    t2 = t1___0 + d2;
#line 1557
    d3 = pc.rel.seconds;
#line 1558
    t3 = t2 + d3;
#line 1559
    d4 = (sum_ns - normalized_ns) / 1000000000L;
#line 1560
    t4 = t3 + d4;
#line 1561
    t5 = t4;
#line 1563
    if (((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) | (long )(t5 != t4)) {
#line 1570
      goto fail;
    }
#line 1572
    result->tv_sec = t5;
#line 1573
    result->tv_nsec = normalized_ns;
  }
#line 1577
  goto done;
  fail: 
#line 1580
  ok = (_Bool)0;
  done: 
#line 1582
  if (tz_was_altered) {
#line 1583
    if (tz0) {
      {
#line 1583
      tmp___15 = setenv("TZ", (char const   *)tz0, 1);
#line 1583
      tmp___17 = tmp___15;
      }
    } else {
      {
#line 1583
      tmp___16 = unsetenv("TZ");
#line 1583
      tmp___17 = tmp___16;
      }
    }
#line 1583
    ok = (_Bool )((int )ok & (tmp___17 == 0));
  }
#line 1584
  if ((unsigned long )tz0 != (unsigned long )(tz0buf)) {
    {
#line 1585
    free((void *)tz0);
    }
  }
#line 1586
  return (ok);
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 142
extern DIR *fdopendir(int __fd ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dirfd)(DIR *__dirp ) ;
#line 22 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 20 "/home/wslee/gnu_benchmarks/patch-2.7/lib/unistd-safer.h"
int dup_safer(int fd ) ;
#line 30 "/home/wslee/gnu_benchmarks/patch-2.7/lib/opendir-safer.c"
DIR *opendir_safer(char const   *name ) 
{ 
  DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 33
  tmp = opendir(name);
#line 33
  dp = tmp;
  }
#line 35
  if (dp) {
    {
#line 37
    tmp___0 = dirfd(dp);
#line 37
    fd = tmp___0;
    }
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
        {
#line 52
        tmp___1 = dup_safer(fd);
#line 52
        f = tmp___1;
        }
#line 53
        if (f < 0) {
          {
#line 55
          tmp___2 = __errno_location();
#line 55
          e = *tmp___2;
#line 56
          newdp = (DIR *)((void *)0);
          }
        } else {
          {
#line 60
          newdp = fdopendir(f);
#line 61
          tmp___3 = __errno_location();
#line 61
          e = *tmp___3;
          }
#line 62
          if (! newdp) {
            {
#line 63
            close(f);
            }
          }
        }
        {
#line 69
        closedir(dp);
#line 70
        tmp___4 = __errno_location();
#line 70
        *tmp___4 = e;
#line 71
        dp = newdp;
        }
      }
    }
  }
#line 75
  return (dp);
}
}
#line 63 "/home/wslee/gnu_benchmarks/patch-2.7/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 67
void freea(void *p ) ;
#line 63 "/home/wslee/gnu_benchmarks/patch-2.7/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 67 "/home/wslee/gnu_benchmarks/patch-2.7/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  char *p ;
  void *tmp ;
  size_t slot ;

  {
#line 73
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 75
  if (nplus >= n) {
    {
#line 77
    tmp = malloc(nplus);
#line 77
    p = (char *)tmp;
    }
#line 79
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 83
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 86
      *((int *)p + -1) = 336984906;
#line 89
      slot = (uintptr_t )p % 257UL;
#line 90
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
#line 91
      mmalloca_results[slot] = (void *)p;
#line 93
      return ((void *)p);
    }
  }
#line 97
  return ((void *)0);
}
}
#line 108 "/home/wslee/gnu_benchmarks/patch-2.7/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  char *p_begin ;

  {
#line 112
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 118
    if (*((int *)p + -1) == 336984906) {
#line 122
      slot = (uintptr_t )p % 257UL;
#line 123
      chain = & mmalloca_results[slot];
      {
#line 124
      while (1) {
        while_continue: /* CIL Label */ ;
#line 124
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 124
          goto while_break;
        }
#line 126
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 129
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 130
          *chain = ((struct header *)p_begin)->next;
#line 131
          free((void *)p_begin);
          }
#line 132
          return;
        }
#line 134
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 139
  return;
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 532
extern int getc_unlocked(FILE *__stream ) ;
#line 675
extern int ungetc(int __c , FILE *__stream ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 584 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 114 "/home/wslee/gnu_benchmarks/patch-2.7/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 117 "/home/wslee/gnu_benchmarks/patch-2.7/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 122
  cp = (char const   *)charset_aliases;
#line 123
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 127
    base = "charset.alias";
#line 132
    tmp = getenv("CHARSETALIASDIR");
#line 132
    dir = (char const   *)tmp;
    }
#line 133
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 134
      dir = "/usr/local/lib";
    } else
#line 133
    if ((int const   )*(dir + 0) == 0) {
#line 134
      dir = "/usr/local/lib";
    }
    {
#line 138
    tmp___0 = strlen(dir);
#line 138
    dir_len___0 = tmp___0;
#line 139
    tmp___1 = strlen(base);
#line 139
    base_len___0 = tmp___1;
    }
#line 140
    if (dir_len___0 > 0UL) {
#line 140
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 140
        tmp___2 = 1;
      } else {
#line 140
        tmp___2 = 0;
      }
    } else {
#line 140
      tmp___2 = 0;
    }
    {
#line 140
    add_slash = tmp___2;
#line 141
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 141
    file_name = (char *)tmp___3;
    }
#line 142
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 144
      memcpy((void */* __restrict  */)file_name, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 145
      if (add_slash) {
#line 146
        *(file_name + dir_len___0) = (char )'/';
      }
      {
#line 147
      memcpy((void */* __restrict  */)((file_name + dir_len___0) + add_slash), (void const   */* __restrict  */)base,
             base_len___0 + 1UL);
      }
    }
#line 151
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 153
      cp = "";
    } else {
      {
#line 165
      fd = open((char const   *)file_name, 131072);
      }
#line 167
      if (fd < 0) {
#line 169
        cp = "";
      } else {
        {
#line 174
        fp = fdopen(fd, "r");
        }
#line 175
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 178
          close(fd);
#line 179
          cp = "";
          }
        } else {
#line 184
          res_ptr = (char *)((void *)0);
#line 185
          res_size = (size_t )0;
          {
#line 187
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 195
            c = getc_unlocked(fp);
            }
#line 196
            if (c == -1) {
#line 197
              goto while_break;
            }
#line 198
            if (c == 10) {
#line 199
              goto __Cont;
            } else
#line 198
            if (c == 32) {
#line 199
              goto __Cont;
            } else
#line 198
            if (c == 9) {
#line 199
              goto __Cont;
            }
#line 200
            if (c == 35) {
              {
#line 203
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 204
                c = getc_unlocked(fp);
                }
#line 203
                if (c == -1) {
#line 203
                  goto while_break___0;
                } else
#line 203
                if (c == 10) {
#line 203
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 206
              if (c == -1) {
#line 207
                goto while_break;
              }
#line 208
              goto __Cont;
            }
            {
#line 210
            ungetc(c, fp);
#line 211
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 211
            if (tmp___4 < 2) {
#line 212
              goto while_break;
            }
            {
#line 213
            l1 = strlen((char const   *)(buf1));
#line 214
            l2 = strlen((char const   *)(buf2));
#line 215
            old_res_ptr = res_ptr;
            }
#line 216
            if (res_size == 0UL) {
              {
#line 218
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 219
              tmp___5 = malloc(res_size + 1UL);
#line 219
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 223
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 224
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 224
              res_ptr = (char *)tmp___6;
              }
            }
#line 226
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 229
              res_size = (size_t )0;
#line 230
              free((void *)old_res_ptr);
              }
#line 231
              goto while_break;
            }
            {
#line 233
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 234
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 236
          fclose(fp);
          }
#line 237
          if (res_size == 0UL) {
#line 238
            cp = "";
          } else {
#line 241
            *(res_ptr + res_size) = (char )'\000';
#line 242
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 247
      free((void *)file_name);
      }
    }
#line 341
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 344
  return (cp);
}
}
#line 356 "/home/wslee/gnu_benchmarks/patch-2.7/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 367
  tmp = nl_langinfo(14);
#line 367
  codeset = (char const   *)tmp;
  }
#line 524
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 526
    codeset = "";
  }
  {
#line 529
  aliases = get_charset_aliases();
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! ((int const   )*aliases != 0)) {
#line 529
      goto while_break;
    }
    {
#line 532
    tmp___3 = strcmp(codeset, aliases);
    }
#line 532
    if (tmp___3 == 0) {
      {
#line 535
      tmp___2 = strlen(aliases);
#line 535
      codeset = (aliases + tmp___2) + 1;
      }
#line 536
      goto while_break;
    } else
#line 532
    if ((int const   )*(aliases + 0) == 42) {
#line 532
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 535
        tmp___2 = strlen(aliases);
#line 535
        codeset = (aliases + tmp___2) + 1;
        }
#line 536
        goto while_break;
      }
    }
    {
#line 529
    tmp___0 = strlen(aliases);
#line 529
    aliases += tmp___0 + 1UL;
#line 529
    tmp___1 = strlen(aliases);
#line 529
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  if ((int const   )*(codeset + 0) == 0) {
#line 543
    codeset = "ASCII";
  }
#line 545
  return (codeset);
}
}
#line 333 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 72 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 73
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 74
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 75
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 76
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 77
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 78
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 81
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 82
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 83
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) ;
#line 84
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 87
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 88
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 89
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 92
void hash_clear(Hash_table *table ) ;
#line 93
void hash_free(Hash_table *table ) ;
#line 96
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 97
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) ;
#line 100
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent )  __attribute__((__deprecated__)) ;
#line 103
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 105
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 76 "/home/wslee/gnu_benchmarks/patch-2.7/lib/bitrotate.h"
__inline static size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 79
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 130 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 149
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 149 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 152
  return ((size_t )table->n_buckets);
}
}
#line 157
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 157 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 160
  return ((size_t )table->n_buckets_used);
}
}
#line 165
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 165 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 168
  return ((size_t )table->n_entries);
}
}
#line 173
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 173 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 179
      goto while_break;
    }
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        cursor = (struct hash_entry  const  *)cursor->next;
#line 186
        if (! cursor) {
#line 186
          goto while_break___0;
        }
#line 187
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
#line 179
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (max_bucket_length);
}
}
#line 200
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 200 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 207
      goto while_break;
    }
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        cursor = (struct hash_entry  const  *)cursor->next;
#line 218
        if (! cursor) {
#line 218
          goto while_break___0;
        }
#line 219
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 207
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 223
    if (n_entries == (size_t )table->n_entries) {
#line 224
      return ((_Bool)1);
    }
  }
#line 226
  return ((_Bool)0);
}
}
#line 229 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 232
  tmp = hash_get_n_entries(table);
#line 232
  n_entries = tmp;
#line 233
  tmp___0 = hash_get_n_buckets(table);
#line 233
  n_buckets = tmp___0;
#line 234
  tmp___1 = hash_get_n_buckets_used(table);
#line 234
  n_buckets_used = tmp___1;
#line 235
  tmp___2 = hash_get_max_bucket_length(table);
#line 235
  max_bucket_length = tmp___2;
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          n_entries);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          n_buckets);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 242
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          max_bucket_length);
  }
#line 244
  return;
}
}
#line 248 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static struct hash_entry *safe_hasher(Hash_table const   *table , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 260 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 263
  tmp = safe_hasher(table, entry);
#line 263
  bucket = (struct hash_entry  const  *)tmp;
  }
#line 266
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! cursor) {
#line 269
      goto while_break;
    }
#line 270
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 271
      return ((void *)cursor->data);
    } else {
      {
#line 270
      tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
      }
#line 270
      if (tmp___0) {
#line 271
        return ((void *)cursor->data);
      }
    }
#line 269
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return ((void *)0);
}
}
#line 287
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 287 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 292
  if (table->n_entries == 0UL) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 297
      abort();
      }
    } else
#line 298
    if (bucket->data) {
#line 299
      return ((void *)bucket->data);
    }
#line 295
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 306 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 309
  tmp = safe_hasher(table, entry);
#line 309
  bucket = (struct hash_entry  const  *)tmp;
#line 313
  cursor = bucket;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = (struct hash_entry  const  *)cursor->next;
#line 314
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    bucket ++;
#line 323
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 323
      goto while_break___0;
    }
#line 324
    if (bucket->data) {
#line 325
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return ((void *)0);
}
}
#line 335 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 343
      goto while_break;
    }
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! cursor) {
#line 347
          goto while_break___0;
        }
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        tmp = counter;
#line 351
        counter ++;
#line 351
        *(buffer + tmp) = (void *)cursor->data;
#line 347
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 343
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (counter);
}
}
#line 367 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 375
      goto while_break;
    }
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! cursor) {
#line 379
          goto while_break___0;
        }
        {
#line 381
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 381
        if (! tmp) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
#line 379
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 375
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (counter);
}
}
#line 427
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 427 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value___0 ;
  unsigned char ch ;

  {
#line 430
  value___0 = (size_t )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    ch = (unsigned char )*string;
#line 433
    if (! ch) {
#line 433
      goto while_break;
    }
#line 434
    value___0 = (value___0 * 31UL + (size_t )ch) % n_buckets;
#line 433
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (value___0);
}
}
#line 443
static _Bool is_prime(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 478 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 481
  *tuning = (Hash_tuning )default_tuning;
#line 482
  return;
}
}
#line 485 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime(candidate);
  }
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = -1;
  } else {
#line 554
    tmp = -2;
  }
#line 554
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 593 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  void *tmp___2 ;

  {
#line 600
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 601
    hasher = & raw_hasher;
  }
#line 602
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 603
    comparator = & raw_comparator;
  }
  {
#line 605
  tmp = malloc(sizeof(*table));
#line 605
  table = (Hash_table *)tmp;
  }
#line 606
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
  {
#line 611
  table->tuning = tuning;
#line 612
  tmp___0 = check_tuning(table);
  }
#line 612
  if (! tmp___0) {
#line 619
    goto fail;
  }
  {
#line 622
  tmp___1 = compute_bucket_size(candidate, tuning);
#line 622
  table->n_buckets = (size_t )tmp___1;
  }
#line 623
  if (! table->n_buckets) {
#line 624
    goto fail;
  }
  {
#line 626
  tmp___2 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 626
  table->bucket = (struct hash_entry *)tmp___2;
  }
#line 627
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 630
  table->n_buckets_used = (size_t )0;
#line 631
  table->n_entries = (size_t )0;
#line 633
  table->hasher = hasher;
#line 634
  table->comparator = comparator;
#line 635
  table->data_freer = data_freer;
#line 637
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table);
  fail: 
  {
#line 644
  free((void *)table);
  }
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 652 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table->bucket;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 657
      goto while_break;
    }
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
      {
#line 665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 665
        if (! cursor) {
#line 665
          goto while_break___0;
        }
#line 667
        if (table->data_freer) {
          {
#line 668
          (*(table->data_freer))(cursor->data);
          }
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table->free_entry_list;
#line 675
        table->free_entry_list = cursor;
#line 665
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 679
      if (table->data_freer) {
        {
#line 680
        (*(table->data_freer))(bucket->data);
        }
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 657
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  table->n_buckets_used = (size_t )0;
#line 687
  table->n_entries = (size_t )0;
#line 688
  return;
}
}
#line 695 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table->data_freer) {
#line 703
    if (table->n_entries) {
#line 705
      bucket = table->bucket;
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 705
          goto while_break;
        }
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
          {
#line 709
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 709
            if (! cursor) {
#line 709
              goto while_break___0;
            }
            {
#line 710
            (*(table->data_freer))(cursor->data);
#line 709
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 705
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 722
  bucket = table->bucket;
  {
#line 722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 722
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 722
      goto while_break___1;
    }
#line 724
    cursor = bucket->next;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! cursor) {
#line 724
        goto while_break___2;
      }
      {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
#line 724
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 722
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  cursor = table->free_entry_list;
  {
#line 732
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 732
    if (! cursor) {
#line 732
      goto while_break___3;
    }
    {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
#line 732
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 741
  free((void *)table->bucket);
#line 742
  free((void *)table);
  }
#line 743
  return;
}
}
#line 750 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 942 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t __attribute__((__pure__))  tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  void *__cil_tmp11 ;

  {
  {
#line 947
  tmp = compute_bucket_size(candidate, table->tuning);
#line 947
  new_size = (size_t )tmp;
  }
#line 949
  if (! new_size) {
#line 950
    return ((_Bool)0);
  }
#line 951
  if (new_size == table->n_buckets) {
#line 952
    return ((_Bool)1);
  }
  {
#line 953
  new_table = & storage;
#line 954
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 955
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 956
    return ((_Bool)0);
  }
  {
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table->tuning;
#line 962
  new_table->hasher = table->hasher;
#line 963
  new_table->comparator = table->comparator;
#line 964
  new_table->data_freer = table->data_freer;
#line 984
  new_table->free_entry_list = table->free_entry_list;
#line 986
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
  }
#line 986
  if (tmp___1) {
    {
#line 989
    free((void *)table->bucket);
#line 990
    table->bucket = new_table->bucket;
#line 991
    table->bucket_limit = new_table->bucket_limit;
#line 992
    table->n_buckets = new_table->n_buckets;
#line 993
    table->n_buckets_used = new_table->n_buckets_used;
#line 994
    table->free_entry_list = new_table->free_entry_list;
    }
#line 996
    return ((_Bool)1);
  }
  {
#line 1012
  table->free_entry_list = new_table->free_entry_list;
#line 1013
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
  }
#line 1013
  if (tmp___2) {
    {
#line 1013
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
    }
#line 1013
    if (! tmp___3) {
      {
#line 1015
      abort();
      }
    }
  } else {
    {
#line 1015
    abort();
    }
  }
  {
#line 1017
  free((void *)new_table->bucket);
  }
#line 1018
  return ((_Bool)0);
}
}
#line 1037 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1047
  if (! entry) {
    {
#line 1048
    abort();
    }
  }
  {
#line 1051
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 1051
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1053
    if (matched_ent) {
#line 1054
      *matched_ent = (void const   *)data;
    }
#line 1055
    return (0);
  }
#line 1063
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 1068
    check_tuning(table);
    }
#line 1069
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1072
      tuning = table->tuning;
#line 1073
      if (tuning->is_n_buckets) {
#line 1073
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1073
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1073
      candidate = (float )tmp;
#line 1079
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1080
        return (-1);
      }
      {
#line 1083
      tmp___0 = hash_rehash(table, (size_t )candidate);
      }
#line 1083
      if (! tmp___0) {
#line 1084
        return (-1);
      }
      {
#line 1087
      tmp___1 = hash_find_entry(table, entry, & bucket, (_Bool)0);
      }
#line 1087
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1088
        abort();
        }
      }
    }
  }
#line 1094
  if (bucket->data) {
    {
#line 1096
    tmp___2 = allocate_entry(table);
#line 1096
    new_entry = tmp___2;
    }
#line 1098
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1099
      return (-1);
    }
#line 1103
    new_entry->data = (void *)entry;
#line 1104
    new_entry->next = bucket->next;
#line 1105
    bucket->next = new_entry;
#line 1106
    (table->n_entries) ++;
#line 1107
    return (1);
  }
#line 1112
  bucket->data = (void *)entry;
#line 1113
  (table->n_entries) ++;
#line 1114
  (table->n_buckets_used) ++;
#line 1116
  return (1);
}
}
#line 1121
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent )  __attribute__((__deprecated__)) ;
#line 1121 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  int tmp ;

  {
  {
#line 1124
  tmp = hash_insert_if_absent(table, entry, matched_ent);
  }
#line 1124
  return (tmp);
}
}
#line 1133 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) 
{ 
  void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1137
  tmp = hash_insert_if_absent(table, entry, & matched_ent);
#line 1137
  err = tmp;
  }
#line 1138
  if (err == -1) {
#line 1138
    tmp___1 = (void *)0;
  } else {
#line 1138
    if (err == 0) {
#line 1138
      tmp___0 = matched_ent;
    } else {
#line 1138
      tmp___0 = entry;
    }
#line 1138
    tmp___1 = (void *)tmp___0;
  }
#line 1138
  return (tmp___1);
}
}
#line 1147 "/home/wslee/gnu_benchmarks/patch-2.7/lib/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1153
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 1154
  if (! data) {
#line 1155
    return ((void *)0);
  }
#line 1157
  (table->n_entries) --;
#line 1158
  if (! bucket->data) {
#line 1160
    (table->n_buckets_used) --;
#line 1165
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1170
      check_tuning(table);
      }
#line 1171
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1174
        tuning = table->tuning;
#line 1175
        if (tuning->is_n_buckets) {
#line 1175
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1175
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1175
        candidate = (size_t )tmp;
#line 1181
        tmp___0 = hash_rehash(table, candidate);
        }
#line 1181
        if (! tmp___0) {
#line 1189
          cursor = table->free_entry_list;
          {
#line 1191
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1191
            if (! cursor) {
#line 1191
              goto while_break;
            }
            {
#line 1193
            next = cursor->next;
#line 1194
            free((void *)cursor);
#line 1195
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1197
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1204
  return (data);
}
}
#line 27 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_linked_list.h"
struct gl_list_implementation  const  gl_linked_list_implementation ;
#line 39 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_t gl_linked_nx_create_empty(gl_list_implementation_t implementation ,
                                           _Bool (*equals_fn)(void const   *elt1 ,
                                                              void const   *elt2 ) ,
                                           size_t (*hashcode_fn)(void const   *elt ) ,
                                           void (*dispose_fn)(void const   *elt ) ,
                                           _Bool allow_duplicates ) 
{ 
  struct gl_list_impl *list ;
  void *tmp ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 46
  tmp = malloc(sizeof(struct gl_list_impl ));
#line 46
  list = (struct gl_list_impl *)tmp;
  }
#line 49
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 50
    return ((gl_list_t )((void *)0));
  }
#line 52
  list->base.vtable = implementation;
#line 53
  list->base.equals_fn = equals_fn;
#line 54
  list->base.hashcode_fn = hashcode_fn;
#line 55
  list->base.dispose_fn = dispose_fn;
#line 56
  list->base.allow_duplicates = allow_duplicates;
#line 64
  list->root.next = & list->root;
#line 65
  list->root.prev = & list->root;
#line 66
  list->count = (size_t )0;
#line 68
  return (list);
}
}
#line 77 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_t gl_linked_nx_create(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                                  void const   *elt2 ) ,
                                     size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                                     _Bool allow_duplicates , size_t count , void const   **contents ) 
{ 
  struct gl_list_impl *list ;
  void *tmp ;
  gl_list_node_t tail ;
  gl_list_node_t node ;
  void *tmp___0 ;
  gl_list_node_t node___0 ;
  gl_list_node_t prev ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
#line 85
  tmp = malloc(sizeof(struct gl_list_impl ));
#line 85
  list = (struct gl_list_impl *)tmp;
  }
#line 89
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 90
    return ((gl_list_t )((void *)0));
  }
#line 92
  list->base.vtable = implementation;
#line 93
  list->base.equals_fn = equals_fn;
#line 94
  list->base.hashcode_fn = hashcode_fn;
#line 95
  list->base.dispose_fn = dispose_fn;
#line 96
  list->base.allow_duplicates = allow_duplicates;
#line 111
  list->count = count;
#line 112
  tail = & list->root;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (count > 0UL)) {
#line 113
      goto while_break;
    }
    {
#line 115
    tmp___0 = malloc(sizeof(struct gl_list_node_impl ));
#line 115
    node = (struct gl_list_node_impl *)tmp___0;
    }
#line 118
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 119
      goto fail2;
    }
#line 121
    node->value = *contents;
#line 137
    node->prev = tail;
#line 138
    tail->next = node;
#line 139
    tail = node;
#line 113
    contents ++;
#line 113
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  tail->next = & list->root;
#line 142
  list->root.prev = tail;
#line 144
  return (list);
  fail2: 
#line 150
  node___0 = tail;
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )node___0 != (unsigned long )(& list->root))) {
#line 150
      goto while_break___0;
    }
    {
#line 152
    prev = node___0->prev;
#line 154
    free((void *)node___0);
#line 155
    node___0 = prev;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 162
  free((void *)list);
  }
#line 163
  return ((gl_list_t )((void *)0));
}
}
#line 166 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static size_t gl_linked_size(gl_list_t list ) 
{ 


  {
#line 169
  return (list->count);
}
}
#line 172 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static void const   *gl_linked_node_value(gl_list_t list , gl_list_node_t node ) 
{ 


  {
#line 175
  return (node->value);
}
}
#line 178 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static int gl_linked_node_nx_set_value(gl_list_t list , gl_list_node_t node , void const   *elt ) 
{ 


  {
#line 213
  node->value = elt;
#line 215
  return (0);
}
}
#line 218 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_next_node(gl_list_t list , gl_list_node_t node ) 
{ 
  struct gl_list_node_impl *tmp ;

  {
#line 221
  if ((unsigned long )node->next != (unsigned long )(& list->root)) {
#line 221
    tmp = node->next;
  } else {
#line 221
    tmp = (struct gl_list_node_impl *)((void *)0);
  }
#line 221
  return (tmp);
}
}
#line 224 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_previous_node(gl_list_t list , gl_list_node_t node ) 
{ 
  struct gl_list_node_impl *tmp ;

  {
#line 227
  if ((unsigned long )node->prev != (unsigned long )(& list->root)) {
#line 227
    tmp = node->prev;
  } else {
#line 227
    tmp = (struct gl_list_node_impl *)((void *)0);
  }
#line 227
  return (tmp);
}
}
#line 230 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static void const   *gl_linked_get_at(gl_list_t list , size_t position ) 
{ 
  size_t count ;
  gl_list_node_t node ;

  {
#line 233
  count = list->count;
#line 236
  if (! (position < count)) {
    {
#line 238
    abort();
    }
  }
#line 240
  if (position <= (count - 1UL) / 2UL) {
#line 242
    node = list->root.next;
    {
#line 243
    while (1) {
      while_continue: /* CIL Label */ ;
#line 243
      if (! (position > 0UL)) {
#line 243
        goto while_break;
      }
#line 244
      node = node->next;
#line 243
      position --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 248
    position = (count - 1UL) - position;
#line 249
    node = list->root.prev;
    {
#line 250
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 250
      if (! (position > 0UL)) {
#line 250
        goto while_break___0;
      }
#line 251
      node = node->prev;
#line 250
      position --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 253
  return (node->value);
}
}
#line 256 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_set_at(gl_list_t list , size_t position , void const   *elt ) 
{ 
  size_t count ;
  gl_list_node_t node ;

  {
#line 259
  count = list->count;
#line 262
  if (! (position < count)) {
    {
#line 264
    abort();
    }
  }
#line 266
  if (position <= (count - 1UL) / 2UL) {
#line 268
    node = list->root.next;
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (! (position > 0UL)) {
#line 269
        goto while_break;
      }
#line 270
      node = node->next;
#line 269
      position --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 274
    position = (count - 1UL) - position;
#line 275
    node = list->root.prev;
    {
#line 276
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 276
      if (! (position > 0UL)) {
#line 276
        goto while_break___0;
      }
#line 277
      node = node->prev;
#line 276
      position --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 310
  node->value = elt;
#line 312
  return (node);
}
}
#line 315 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_search_from_to(gl_list_t list , size_t start_index ,
                                               size_t end_index , void const   *elt ) 
{ 
  size_t count ;
  _Bool (*equals)(void const   *elt1 , void const   *elt2 ) ;
  gl_list_node_t node ;
  _Bool tmp ;

  {
#line 319
  count = list->count;
#line 321
  if (start_index <= end_index) {
#line 321
    if (! (end_index <= count)) {
      {
#line 323
      abort();
      }
    }
  } else {
    {
#line 323
    abort();
    }
  }
#line 444
  equals = list->base.equals_fn;
#line 445
  node = list->root.next;
#line 447
  end_index -= start_index;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (! (start_index > 0UL)) {
#line 448
      goto while_break;
    }
#line 449
    node = node->next;
#line 448
    start_index --;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  if ((unsigned long )equals != (unsigned long )((void *)0)) {
    {
#line 453
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 453
      if (! (end_index > 0UL)) {
#line 453
        goto while_break___0;
      }
      {
#line 454
      tmp = (*equals)(elt, node->value);
      }
#line 454
      if (tmp) {
#line 455
        return (node);
      }
#line 453
      node = node->next;
#line 453
      end_index --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 459
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 459
      if (! (end_index > 0UL)) {
#line 459
        goto while_break___1;
      }
#line 460
      if ((unsigned long )elt == (unsigned long )node->value) {
#line 461
        return (node);
      }
#line 459
      node = node->next;
#line 459
      end_index --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 463
  return ((gl_list_node_t )((void *)0));
}
}
#line 468 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static size_t gl_linked_indexof_from_to(gl_list_t list , size_t start_index , size_t end_index ,
                                        void const   *elt ) 
{ 
  size_t count ;
  _Bool (*equals)(void const   *elt1 , void const   *elt2 ) ;
  size_t index ;
  gl_list_node_t node ;
  _Bool tmp ;

  {
#line 472
  count = list->count;
#line 474
  if (start_index <= end_index) {
#line 474
    if (! (end_index <= count)) {
      {
#line 476
      abort();
      }
    }
  } else {
    {
#line 476
    abort();
    }
  }
#line 567
  equals = list->base.equals_fn;
#line 568
  index = start_index;
#line 569
  node = list->root.next;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (start_index > 0UL)) {
#line 571
      goto while_break;
    }
#line 572
    node = node->next;
#line 571
    start_index --;
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  if ((unsigned long )equals != (unsigned long )((void *)0)) {
    {
#line 576
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 576
      if (! (index < end_index)) {
#line 576
        goto while_break___0;
      }
      {
#line 579
      tmp = (*equals)(elt, node->value);
      }
#line 579
      if (tmp) {
#line 580
        return (index);
      }
#line 576
      node = node->next;
#line 576
      index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 584
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 584
      if (! (index < end_index)) {
#line 584
        goto while_break___1;
      }
#line 587
      if ((unsigned long )elt == (unsigned long )node->value) {
#line 588
        return (index);
      }
#line 584
      node = node->next;
#line 584
      index ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 590
  return ((size_t )-1);
}
}
#line 595 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_first(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t node ;
  void *tmp ;

  {
  {
#line 598
  tmp = malloc(sizeof(struct gl_list_node_impl ));
#line 598
  node = (struct gl_list_node_impl *)tmp;
  }
#line 601
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 602
    return ((gl_list_node_t )((void *)0));
  }
#line 604
  node->value = elt;
#line 620
  node->prev = & list->root;
#line 621
  node->next = list->root.next;
#line 622
  (node->next)->prev = node;
#line 623
  list->root.next = node;
#line 624
  (list->count) ++;
#line 630
  return (node);
}
}
#line 633 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_last(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t node ;
  void *tmp ;

  {
  {
#line 636
  tmp = malloc(sizeof(struct gl_list_node_impl ));
#line 636
  node = (struct gl_list_node_impl *)tmp;
  }
#line 639
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 640
    return ((gl_list_node_t )((void *)0));
  }
#line 642
  node->value = elt;
#line 658
  node->next = & list->root;
#line 659
  node->prev = list->root.prev;
#line 660
  (node->prev)->next = node;
#line 661
  list->root.prev = node;
#line 662
  (list->count) ++;
#line 668
  return (node);
}
}
#line 671 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_before(gl_list_t list , gl_list_node_t node ,
                                              void const   *elt ) 
{ 
  gl_list_node_t new_node ;
  void *tmp ;

  {
  {
#line 674
  tmp = malloc(sizeof(struct gl_list_node_impl ));
#line 674
  new_node = (struct gl_list_node_impl *)tmp;
  }
#line 677
  if ((unsigned long )new_node == (unsigned long )((void *)0)) {
#line 678
    return ((gl_list_node_t )((void *)0));
  }
#line 680
  new_node->value = elt;
#line 696
  new_node->next = node;
#line 697
  new_node->prev = node->prev;
#line 698
  (new_node->prev)->next = new_node;
#line 699
  node->prev = new_node;
#line 700
  (list->count) ++;
#line 706
  return (new_node);
}
}
#line 709 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_after(gl_list_t list , gl_list_node_t node ,
                                             void const   *elt ) 
{ 
  gl_list_node_t new_node ;
  void *tmp ;

  {
  {
#line 712
  tmp = malloc(sizeof(struct gl_list_node_impl ));
#line 712
  new_node = (struct gl_list_node_impl *)tmp;
  }
#line 715
  if ((unsigned long )new_node == (unsigned long )((void *)0)) {
#line 716
    return ((gl_list_node_t )((void *)0));
  }
#line 718
  new_node->value = elt;
#line 734
  new_node->prev = node;
#line 735
  new_node->next = node->next;
#line 736
  (new_node->next)->prev = new_node;
#line 737
  node->next = new_node;
#line 738
  (list->count) ++;
#line 744
  return (new_node);
}
}
#line 747 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_nx_add_at(gl_list_t list , size_t position , void const   *elt ) 
{ 
  size_t count ;
  gl_list_node_t new_node ;
  void *tmp ;
  gl_list_node_t node ;
  gl_list_node_t node___0 ;

  {
#line 750
  count = list->count;
#line 753
  if (! (position <= count)) {
    {
#line 755
    abort();
    }
  }
  {
#line 757
  tmp = malloc(sizeof(struct gl_list_node_impl ));
#line 757
  new_node = (struct gl_list_node_impl *)tmp;
  }
#line 758
  if ((unsigned long )new_node == (unsigned long )((void *)0)) {
#line 759
    return ((gl_list_node_t )((void *)0));
  }
#line 761
  new_node->value = elt;
#line 777
  if (position <= count / 2UL) {
#line 781
    node = & list->root;
    {
#line 782
    while (1) {
      while_continue: /* CIL Label */ ;
#line 782
      if (! (position > 0UL)) {
#line 782
        goto while_break;
      }
#line 783
      node = node->next;
#line 782
      position --;
    }
    while_break: /* CIL Label */ ;
    }
#line 784
    new_node->prev = node;
#line 785
    new_node->next = node->next;
#line 786
    (new_node->next)->prev = new_node;
#line 787
    node->next = new_node;
  } else {
#line 793
    position = count - position;
#line 794
    node___0 = & list->root;
    {
#line 795
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 795
      if (! (position > 0UL)) {
#line 795
        goto while_break___0;
      }
#line 796
      node___0 = node___0->prev;
#line 795
      position --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 797
    new_node->next = node___0;
#line 798
    new_node->prev = node___0->prev;
#line 799
    (new_node->prev)->next = new_node;
#line 800
    node___0->prev = new_node;
  }
#line 802
  (list->count) ++;
#line 808
  return (new_node);
}
}
#line 811 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static _Bool gl_linked_remove_node(gl_list_t list , gl_list_node_t node ) 
{ 
  gl_list_node_t prev ;
  gl_list_node_t next ;

  {
#line 823
  prev = node->prev;
#line 824
  next = node->next;
#line 826
  prev->next = next;
#line 827
  next->prev = prev;
#line 828
  (list->count) --;
#line 830
  if ((unsigned long )list->base.dispose_fn != (unsigned long )((void *)0)) {
    {
#line 831
    (*(list->base.dispose_fn))(node->value);
    }
  }
  {
#line 832
  free((void *)node);
  }
#line 833
  return ((_Bool)1);
}
}
#line 836 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static _Bool gl_linked_remove_at(gl_list_t list , size_t position ) 
{ 
  size_t count ;
  gl_list_node_t removed_node ;
  gl_list_node_t node ;
  gl_list_node_t after_removed ;
  gl_list_node_t node___0 ;
  gl_list_node_t before_removed ;

  {
#line 839
  count = list->count;
#line 842
  if (! (position < count)) {
    {
#line 844
    abort();
    }
  }
#line 846
  if (position <= (count - 1UL) / 2UL) {
#line 851
    node = & list->root;
    {
#line 852
    while (1) {
      while_continue: /* CIL Label */ ;
#line 852
      if (! (position > 0UL)) {
#line 852
        goto while_break;
      }
#line 853
      node = node->next;
#line 852
      position --;
    }
    while_break: /* CIL Label */ ;
    }
#line 854
    removed_node = node->next;
#line 855
    after_removed = (node->next)->next;
#line 856
    node->next = after_removed;
#line 857
    after_removed->prev = node;
  } else {
#line 864
    position = (count - 1UL) - position;
#line 865
    node___0 = & list->root;
    {
#line 866
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 866
      if (! (position > 0UL)) {
#line 866
        goto while_break___0;
      }
#line 867
      node___0 = node___0->prev;
#line 866
      position --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 868
    removed_node = node___0->prev;
#line 869
    before_removed = (node___0->prev)->prev;
#line 870
    node___0->prev = before_removed;
#line 871
    before_removed->next = node___0;
  }
#line 876
  (list->count) --;
#line 878
  if ((unsigned long )list->base.dispose_fn != (unsigned long )((void *)0)) {
    {
#line 879
    (*(list->base.dispose_fn))(removed_node->value);
    }
  }
  {
#line 880
  free((void *)removed_node);
  }
#line 881
  return ((_Bool)1);
}
}
#line 884 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static _Bool gl_linked_remove(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t node ;
  gl_list_node_t tmp ;
  _Bool tmp___0 ;

  {
  {
#line 887
  tmp = gl_linked_search_from_to(list, (size_t )0, list->count, elt);
#line 887
  node = tmp;
  }
#line 889
  if ((unsigned long )node != (unsigned long )((void *)0)) {
    {
#line 890
    tmp___0 = gl_linked_remove_node(list, node);
    }
#line 890
    return (tmp___0);
  } else {
#line 892
    return ((_Bool)0);
  }
}
}
#line 895 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static void gl_linked_list_free(gl_list_t list ) 
{ 
  void (*dispose)(void const   *elt ) ;
  gl_list_node_t node ;
  gl_list_node_t next ;

  {
#line 898
  dispose = list->base.dispose_fn;
#line 901
  node = list->root.next;
  {
#line 901
  while (1) {
    while_continue: /* CIL Label */ ;
#line 901
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 901
      goto while_break;
    }
#line 903
    next = node->next;
#line 904
    if ((unsigned long )dispose != (unsigned long )((void *)0)) {
      {
#line 905
      (*dispose)(node->value);
      }
    }
    {
#line 906
    free((void *)node);
#line 907
    node = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 912
  free((void *)list);
  }
#line 913
  return;
}
}
#line 917 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_iterator_t gl_linked_iterator(gl_list_t list ) 
{ 
  gl_list_iterator_t result ;
  void *__cil_tmp3 ;

  {
#line 922
  result.vtable = list->base.vtable;
#line 923
  result.list = list;
#line 924
  result.p = (void *)list->root.next;
#line 925
  result.q = (void *)(& list->root);
#line 932
  return (result);
}
}
#line 935 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_iterator_t gl_linked_iterator_from_to(gl_list_t list , size_t start_index ,
                                                     size_t end_index ) 
{ 
  gl_list_iterator_t result ;
  size_t n1 ;
  size_t n2 ;
  size_t n3 ;
  gl_list_node_t node ;
  size_t i ;
  gl_list_node_t node___0 ;
  size_t i___0 ;
  gl_list_node_t node___1 ;
  size_t i___1 ;
  void *__cil_tmp14 ;

  {
#line 942
  if (start_index <= end_index) {
#line 942
    if (! (end_index <= list->count)) {
      {
#line 944
      abort();
      }
    }
  } else {
    {
#line 944
    abort();
    }
  }
#line 945
  result.vtable = list->base.vtable;
#line 946
  result.list = list;
#line 947
  n1 = start_index;
#line 948
  n2 = end_index - start_index;
#line 949
  n3 = list->count - end_index;
#line 952
  if (n1 > n2) {
#line 952
    if (n1 > n3) {
#line 958
      node = & list->root;
#line 959
      i = n3;
      {
#line 959
      while (1) {
        while_continue: /* CIL Label */ ;
#line 959
        if (! (i > 0UL)) {
#line 959
          goto while_break;
        }
#line 960
        node = node->prev;
#line 959
        i --;
      }
      while_break: /* CIL Label */ ;
      }
#line 961
      result.q = (void *)node;
#line 962
      i = n2;
      {
#line 962
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 962
        if (! (i > 0UL)) {
#line 962
          goto while_break___0;
        }
#line 963
        node = node->prev;
#line 962
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 964
      result.p = (void *)node;
    } else {
#line 952
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 966
  if (n2 > n3) {
#line 972
    node___0 = list->root.next;
#line 973
    i___0 = n1;
    {
#line 973
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 973
      if (! (i___0 > 0UL)) {
#line 973
        goto while_break___1;
      }
#line 974
      node___0 = node___0->next;
#line 973
      i___0 --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 975
    result.p = (void *)node___0;
#line 977
    node___0 = & list->root;
#line 978
    i___0 = n3;
    {
#line 978
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 978
      if (! (i___0 > 0UL)) {
#line 978
        goto while_break___2;
      }
#line 979
      node___0 = node___0->prev;
#line 978
      i___0 --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 980
    result.q = (void *)node___0;
  } else {
#line 988
    node___1 = list->root.next;
#line 989
    i___1 = n1;
    {
#line 989
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 989
      if (! (i___1 > 0UL)) {
#line 989
        goto while_break___3;
      }
#line 990
      node___1 = node___1->next;
#line 989
      i___1 --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 991
    result.p = (void *)node___1;
#line 992
    i___1 = n2;
    {
#line 992
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 992
      if (! (i___1 > 0UL)) {
#line 992
        goto while_break___4;
      }
#line 993
      node___1 = node___1->next;
#line 992
      i___1 --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 994
    result.q = (void *)node___1;
  }
#line 1003
  return (result);
}
}
#line 1006 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static _Bool gl_linked_iterator_next(gl_list_iterator_t *iterator , void const   **eltp ,
                                     gl_list_node_t *nodep ) 
{ 
  gl_list_node_t node ;

  {
#line 1010
  if ((unsigned long )iterator->p != (unsigned long )iterator->q) {
#line 1012
    node = (gl_list_node_t )iterator->p;
#line 1013
    *eltp = node->value;
#line 1014
    if ((unsigned long )nodep != (unsigned long )((void *)0)) {
#line 1015
      *nodep = node;
    }
#line 1016
    iterator->p = (void *)node->next;
#line 1017
    return ((_Bool)1);
  } else {
#line 1020
    return ((_Bool)0);
  }
}
}
#line 1023 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static void gl_linked_iterator_free(gl_list_iterator_t *iterator ) 
{ 


  {
#line 1026
  return;
}
}
#line 1030 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_sortedlist_search(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                 void const   *elt2 ) ,
                                                  void const   *elt ) 
{ 
  gl_list_node_t node ;
  int cmp ;
  int tmp ;

  {
#line 1036
  node = list->root.next;
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1036
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 1036
      goto while_break;
    }
    {
#line 1038
    tmp = (*compar)(node->value, elt);
#line 1038
    cmp = tmp;
    }
#line 1040
    if (cmp > 0) {
#line 1041
      goto while_break;
    }
#line 1042
    if (cmp == 0) {
#line 1043
      return (node);
    }
#line 1036
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1045
  return ((gl_list_node_t )((void *)0));
}
}
#line 1048 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_sortedlist_search_from_to(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                         void const   *elt2 ) ,
                                                          size_t low , size_t high ,
                                                          void const   *elt ) 
{ 
  size_t count ;
  size_t position ;
  gl_list_node_t node ;
  int cmp ;
  int tmp ;

  {
#line 1054
  count = list->count;
#line 1056
  if (low <= high) {
#line 1056
    if (! (high <= list->count)) {
      {
#line 1058
      abort();
      }
    }
  } else {
    {
#line 1058
    abort();
    }
  }
#line 1060
  high -= low;
#line 1061
  if (high > 0UL) {
#line 1064
    position = low;
#line 1067
    if (position <= (count - 1UL) / 2UL) {
#line 1069
      node = list->root.next;
      {
#line 1070
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1070
        if (! (position > 0UL)) {
#line 1070
          goto while_break;
        }
#line 1071
        node = node->next;
#line 1070
        position --;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1075
      position = (count - 1UL) - position;
#line 1076
      node = list->root.prev;
      {
#line 1077
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1077
        if (! (position > 0UL)) {
#line 1077
          goto while_break___0;
        }
#line 1078
        node = node->prev;
#line 1077
        position --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1081
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1083
      tmp = (*compar)(node->value, elt);
#line 1083
      cmp = tmp;
      }
#line 1085
      if (cmp > 0) {
#line 1086
        goto while_break___1;
      }
#line 1087
      if (cmp == 0) {
#line 1088
        return (node);
      }
#line 1089
      node = node->next;
#line 1081
      high --;
#line 1081
      if (! (high > 0UL)) {
#line 1081
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1093
  return ((gl_list_node_t )((void *)0));
}
}
#line 1096 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static size_t gl_linked_sortedlist_indexof(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                          void const   *elt2 ) ,
                                           void const   *elt ) 
{ 
  gl_list_node_t node ;
  size_t index ;
  int cmp ;
  int tmp ;

  {
#line 1103
  node = list->root.next;
#line 1103
  index = (size_t )0;
  {
#line 1103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1103
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 1103
      goto while_break;
    }
    {
#line 1107
    tmp = (*compar)(node->value, elt);
#line 1107
    cmp = tmp;
    }
#line 1109
    if (cmp > 0) {
#line 1110
      goto while_break;
    }
#line 1111
    if (cmp == 0) {
#line 1112
      return (index);
    }
#line 1103
    node = node->next;
#line 1103
    index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1114
  return ((size_t )-1);
}
}
#line 1117 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static size_t gl_linked_sortedlist_indexof_from_to(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                  void const   *elt2 ) ,
                                                   size_t low , size_t high , void const   *elt ) 
{ 
  size_t count ;
  size_t index ;
  size_t position ;
  gl_list_node_t node ;
  int cmp ;
  int tmp ;

  {
#line 1123
  count = list->count;
#line 1125
  if (low <= high) {
#line 1125
    if (! (high <= list->count)) {
      {
#line 1127
      abort();
      }
    }
  } else {
    {
#line 1127
    abort();
    }
  }
#line 1129
  high -= low;
#line 1130
  if (high > 0UL) {
#line 1133
    index = low;
#line 1134
    position = low;
#line 1137
    if (position <= (count - 1UL) / 2UL) {
#line 1139
      node = list->root.next;
      {
#line 1140
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1140
        if (! (position > 0UL)) {
#line 1140
          goto while_break;
        }
#line 1141
        node = node->next;
#line 1140
        position --;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1145
      position = (count - 1UL) - position;
#line 1146
      node = list->root.prev;
      {
#line 1147
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1147
        if (! (position > 0UL)) {
#line 1147
          goto while_break___0;
        }
#line 1148
        node = node->prev;
#line 1147
        position --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1151
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1153
      tmp = (*compar)(node->value, elt);
#line 1153
      cmp = tmp;
      }
#line 1155
      if (cmp > 0) {
#line 1156
        goto while_break___1;
      }
#line 1157
      if (cmp == 0) {
#line 1158
        return (index);
      }
#line 1159
      node = node->next;
#line 1160
      index ++;
#line 1151
      high --;
#line 1151
      if (! (high > 0UL)) {
#line 1151
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1164
  return ((size_t )-1);
}
}
#line 1167 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_sortedlist_nx_add(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                 void const   *elt2 ) ,
                                                  void const   *elt ) 
{ 
  gl_list_node_t node ;
  gl_list_node_t tmp ;
  int tmp___0 ;
  gl_list_node_t tmp___1 ;

  {
#line 1173
  node = list->root.next;
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 1173
      goto while_break;
    }
    {
#line 1174
    tmp___0 = (*compar)(node->value, elt);
    }
#line 1174
    if (tmp___0 >= 0) {
      {
#line 1175
      tmp = gl_linked_nx_add_before(list, node, elt);
      }
#line 1175
      return (tmp);
    }
#line 1173
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1176
  tmp___1 = gl_linked_nx_add_last(list, elt);
  }
#line 1176
  return (tmp___1);
}
}
#line 1179 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_anylinked_list2.h"
static _Bool gl_linked_sortedlist_remove(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                        void const   *elt2 ) ,
                                         void const   *elt ) 
{ 
  gl_list_node_t node ;
  int cmp ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 1185
  node = list->root.next;
  {
#line 1185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1185
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 1185
      goto while_break;
    }
    {
#line 1187
    tmp = (*compar)(node->value, elt);
#line 1187
    cmp = tmp;
    }
#line 1189
    if (cmp > 0) {
#line 1190
      goto while_break;
    }
#line 1191
    if (cmp == 0) {
      {
#line 1192
      tmp___0 = gl_linked_remove_node(list, node);
      }
#line 1192
      return (tmp___0);
    }
#line 1185
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1194
  return ((_Bool)0);
}
}
#line 32 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_linked_list.c"
struct gl_list_implementation  const  gl_linked_list_implementation  = 
#line 32 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gl_linked_list.c"
     {& gl_linked_nx_create_empty, & gl_linked_nx_create, & gl_linked_size, & gl_linked_node_value,
    & gl_linked_node_nx_set_value, & gl_linked_next_node, & gl_linked_previous_node,
    & gl_linked_get_at, & gl_linked_nx_set_at, & gl_linked_search_from_to, & gl_linked_indexof_from_to,
    & gl_linked_nx_add_first, & gl_linked_nx_add_last, & gl_linked_nx_add_before,
    & gl_linked_nx_add_after, & gl_linked_nx_add_at, & gl_linked_remove_node, & gl_linked_remove_at,
    & gl_linked_remove, & gl_linked_list_free, & gl_linked_iterator, & gl_linked_iterator_from_to,
    & gl_linked_iterator_next, & gl_linked_iterator_free, & gl_linked_sortedlist_search,
    & gl_linked_sortedlist_search_from_to, & gl_linked_sortedlist_indexof, & gl_linked_sortedlist_indexof_from_to,
    & gl_linked_sortedlist_nx_add, & gl_linked_sortedlist_remove};
#line 336 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 28 "/home/wslee/gnu_benchmarks/patch-2.7/lib/gettime.c"
void gettime(struct timespec *ts ) 
{ 
  int tmp ;
  struct timeval tv ;
  void *__cil_tmp4 ;

  {
  {
#line 36
  tmp = clock_gettime(0, ts);
  }
#line 36
  if (tmp == 0) {
#line 37
    return;
  }
  {
#line 42
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 43
  ts->tv_sec = tv.tv_sec;
#line 44
  ts->tv_nsec = tv.tv_usec * 1000L;
  }
#line 48
  return;
}
}
#line 245 "./getopt.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc ,
                                                                                       char **argv ,
                                                                                       char const   *options ,
                                                                                       struct rpl_option  const  *long_options ,
                                                                                       int *opt_index ) ;
#line 249
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc ,
                                                                                            char **argv ,
                                                                                            char const   *options ,
                                                                                            struct rpl_option  const  *long_options ,
                                                                                            int *opt_index ) ;
#line 24 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt_int.h"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts___0 ,
                        int *longind , int long_only , int posixly_correct___0 ) ;
#line 118
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts___0 ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct___0 ) ;
#line 124
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 129
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 39 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt1.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc ,
                                                                                       char **argv ,
                                                                                       char const   *options ,
                                                                                       struct rpl_option  const  *long_options ,
                                                                                       int *opt_index ) ;
#line 39 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt1.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc , char **argv ,
                                                         char const   *options , struct rpl_option  const  *long_options ,
                                                         int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = rpl_getopt_internal(argc, argv, options, long_options, opt_index, 0, 0);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt1.c"
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 52
  tmp = _getopt_internal_r(argc, argv, options, long_options, opt_index, 0, d, 0);
  }
#line 52
  return (tmp);
}
}
#line 61
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc ,
                                                                                            char **argv ,
                                                                                            char const   *options ,
                                                                                            struct rpl_option  const  *long_options ,
                                                                                            int *opt_index ) ;
#line 61 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt1.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc , char **argv ,
                                                              char const   *options ,
                                                              struct rpl_option  const  *long_options ,
                                                              int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 66
  tmp = rpl_getopt_internal(argc, argv, options, long_options, opt_index, 1, 0);
  }
#line 66
  return (tmp);
}
}
#line 70 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt1.c"
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 75
  tmp = _getopt_internal_r(argc, argv, options, long_options, opt_index, 1, d, 0);
  }
#line 75
  return (tmp);
}
}
#line 148 "./getopt.h"
char *rpl_optarg  ;
#line 162
int rpl_optind ;
#line 167
int rpl_opterr ;
#line 171
int rpl_optopt ;
#line 241
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc ,
                                                                                  char * const  *argv ,
                                                                                  char const   *optstring ) ;
#line 555 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 82 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
int rpl_optind  =    1;
#line 87 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
int rpl_opterr  =    1;
#line 93 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
int rpl_optopt  =    '?';
#line 97 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
static struct _getopt_data getopt_data  ;
#line 143 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ 
  int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
#line 146
  bottom = d->__first_nonopt;
#line 147
  middle = d->__last_nonopt;
#line 148
  top = d->rpl_optind;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (top > middle) {
#line 178
      if (! (middle > bottom)) {
#line 178
        goto while_break;
      }
    } else {
#line 178
      goto while_break;
    }
#line 180
    if (top - middle > middle - bottom) {
#line 183
      len = middle - bottom;
#line 187
      i = 0;
      {
#line 187
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 187
        if (! (i < len)) {
#line 187
          goto while_break___0;
        }
#line 189
        tem = *(argv + (bottom + i));
#line 190
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
#line 191
        *(argv + ((top - (middle - bottom)) + i)) = tem;
#line 187
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 195
      top -= len;
    } else {
#line 200
      len___0 = top - middle;
#line 204
      i___0 = 0;
      {
#line 204
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 204
        if (! (i___0 < len___0)) {
#line 204
          goto while_break___1;
        }
#line 206
        tem = *(argv + (bottom + i___0));
#line 207
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
#line 208
        *(argv + (middle + i___0)) = tem;
#line 204
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 212
      bottom += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
#line 219
  d->__last_nonopt = d->rpl_optind;
#line 220
  return;
}
}
#line 224 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
static char const   *_getopt_initialize(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                                        char const   *optstring , struct _getopt_data *d ,
                                        int posixly_correct___0 ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 233
  tmp = d->rpl_optind;
#line 233
  d->__last_nonopt = tmp;
#line 233
  d->__first_nonopt = tmp;
#line 235
  d->__nextchar = (char *)((void *)0);
#line 237
  if (posixly_correct___0) {
#line 237
    tmp___1 = 1;
  } else {
    {
#line 237
    tmp___0 = getenv("POSIXLY_CORRECT");
    }
#line 237
    if (tmp___0) {
#line 237
      tmp___1 = 1;
    } else {
#line 237
      tmp___1 = 0;
    }
  }
#line 237
  d->__posixly_correct = tmp___1;
#line 241
  if ((int const   )*(optstring + 0) == 45) {
#line 243
    d->__ordering = (enum __ord )2;
#line 244
    optstring ++;
  } else
#line 246
  if ((int const   )*(optstring + 0) == 43) {
#line 248
    d->__ordering = (enum __ord )0;
#line 249
    optstring ++;
  } else
#line 251
  if (d->__posixly_correct) {
#line 252
    d->__ordering = (enum __ord )0;
  } else {
#line 254
    d->__ordering = (enum __ord )1;
  }
#line 286
  return (optstring);
}
}
#line 345 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts___0 ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct___0 ) 
{ 
  int print_errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *nameend ;
  unsigned int namelen ;
  struct rpl_option  const  *p ;
  struct rpl_option  const  *pfound ;
  struct option_list *ambig_list ;
  int exact ;
  int indfound ;
  int option_index ;
  struct option_list *newp ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  struct option_list first ;
  size_t tmp___5 ;
  struct option_list *pn ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char c ;
  char *tmp___13 ;
  char const   *temp ;
  char *tmp___14 ;
  char *nameend___0 ;
  struct rpl_option  const  *p___0 ;
  struct rpl_option  const  *pfound___0 ;
  int exact___0 ;
  int ambig ;
  int indfound___0 ;
  int option_index___0 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
#line 350
  print_errors = d->rpl_opterr;
#line 352
  if (argc < 1) {
#line 353
    return (-1);
  }
#line 355
  d->rpl_optarg = (char *)((void *)0);
#line 357
  if (d->rpl_optind == 0) {
#line 357
    goto _L;
  } else
#line 357
  if (! d->__initialized) {
    _L: /* CIL Label */ 
#line 359
    if (d->rpl_optind == 0) {
#line 360
      d->rpl_optind = 1;
    }
    {
#line 361
    optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct___0);
#line 363
    d->__initialized = 1;
    }
  } else
#line 365
  if ((int const   )*(optstring + 0) == 45) {
#line 366
    optstring ++;
  } else
#line 365
  if ((int const   )*(optstring + 0) == 43) {
#line 366
    optstring ++;
  }
#line 367
  if ((int const   )*(optstring + 0) == 58) {
#line 368
    print_errors = 0;
  }
#line 382
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
#line 382
    goto _L___3;
  } else
#line 382
  if ((int )*(d->__nextchar) == 0) {
    _L___3: /* CIL Label */ 
#line 388
    if (d->__last_nonopt > d->rpl_optind) {
#line 389
      d->__last_nonopt = d->rpl_optind;
    }
#line 390
    if (d->__first_nonopt > d->rpl_optind) {
#line 391
      d->__first_nonopt = d->rpl_optind;
    }
#line 393
    if ((unsigned int )d->__ordering == 1U) {
#line 398
      if (d->__first_nonopt != d->__last_nonopt) {
#line 398
        if (d->__last_nonopt != d->rpl_optind) {
          {
#line 400
          exchange(argv, d);
          }
        } else {
#line 398
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 401
      if (d->__last_nonopt != d->rpl_optind) {
#line 402
        d->__first_nonopt = d->rpl_optind;
      }
      {
#line 407
      while (1) {
        while_continue: /* CIL Label */ ;
#line 407
        if (d->rpl_optind < argc) {
#line 407
          if (! ((int )*(*(argv + d->rpl_optind) + 0) != 45)) {
#line 407
            if (! ((int )*(*(argv + d->rpl_optind) + 1) == 0)) {
#line 407
              goto while_break;
            }
          }
        } else {
#line 407
          goto while_break;
        }
#line 408
        (d->rpl_optind) ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 409
      d->__last_nonopt = d->rpl_optind;
    }
#line 417
    if (d->rpl_optind != argc) {
      {
#line 417
      tmp = strcmp((char const   *)*(argv + d->rpl_optind), "--");
      }
#line 417
      if (! tmp) {
#line 419
        (d->rpl_optind) ++;
#line 421
        if (d->__first_nonopt != d->__last_nonopt) {
#line 421
          if (d->__last_nonopt != d->rpl_optind) {
            {
#line 423
            exchange(argv, d);
            }
          } else {
#line 421
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 424
        if (d->__first_nonopt == d->__last_nonopt) {
#line 425
          d->__first_nonopt = d->rpl_optind;
        }
#line 426
        d->__last_nonopt = argc;
#line 428
        d->rpl_optind = argc;
      }
    }
#line 434
    if (d->rpl_optind == argc) {
#line 438
      if (d->__first_nonopt != d->__last_nonopt) {
#line 439
        d->rpl_optind = d->__first_nonopt;
      }
#line 440
      return (-1);
    }
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
#line 446
      goto _L___2;
    } else
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
      _L___2: /* CIL Label */ 
#line 448
      if ((unsigned int )d->__ordering == 0U) {
#line 449
        return (-1);
      }
#line 450
      tmp___0 = d->rpl_optind;
#line 450
      (d->rpl_optind) ++;
#line 450
      d->rpl_optarg = *(argv + tmp___0);
#line 451
      return (1);
    }
#line 457
    if ((unsigned long )longopts___0 != (unsigned long )((void *)0)) {
#line 457
      if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 457
        tmp___1 = 1;
      } else {
#line 457
        tmp___1 = 0;
      }
    } else {
#line 457
      tmp___1 = 0;
    }
#line 457
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + tmp___1;
  }
#line 476
  if ((unsigned long )longopts___0 != (unsigned long )((void *)0)) {
#line 476
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 476
      goto _L___6;
    } else
#line 476
    if (long_only) {
#line 476
      if (*(*(argv + d->rpl_optind) + 2)) {
#line 476
        goto _L___6;
      } else {
        {
#line 476
        tmp___12 = strchr(optstring, (int )*(*(argv + d->rpl_optind) + 1));
        }
#line 476
        if (! tmp___12) {
          _L___6: /* CIL Label */ 
#line 484
          pfound = (struct rpl_option  const  *)((void *)0);
#line 485
          ambig_list = (struct option_list *)((void *)0);
#line 490
          exact = 0;
#line 491
          indfound = -1;
#line 494
          nameend = d->__nextchar;
          {
#line 494
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 494
            if (*nameend) {
#line 494
              if (! ((int )*nameend != 61)) {
#line 494
                goto while_break___0;
              }
            } else {
#line 494
              goto while_break___0;
            }
#line 494
            nameend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 496
          namelen = (unsigned int )(nameend - d->__nextchar);
#line 500
          p = longopts___0;
#line 500
          option_index = 0;
          {
#line 500
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 500
            if (! p->name) {
#line 500
              goto while_break___1;
            }
            {
#line 501
            tmp___4 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                              (size_t )namelen);
            }
#line 501
            if (! tmp___4) {
              {
#line 503
              tmp___3 = strlen((char const   *)p->name);
              }
#line 503
              if (namelen == (unsigned int )tmp___3) {
#line 506
                pfound = p;
#line 507
                indfound = option_index;
#line 508
                exact = 1;
#line 509
                goto while_break___1;
              } else
#line 511
              if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 514
                pfound = p;
#line 515
                indfound = option_index;
              } else
#line 517
              if (long_only) {
                {
#line 523
                tmp___2 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___2;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
                }
              } else
#line 517
              if (pfound->has_arg != p->has_arg) {
                {
#line 523
                tmp___2 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___2;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
                }
              } else
#line 517
              if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
                {
#line 523
                tmp___2 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___2;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
                }
              } else
#line 517
              if (pfound->val != p->val) {
                {
#line 523
                tmp___2 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___2;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
                }
              }
            }
#line 500
            p ++;
#line 500
            option_index ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 530
          if ((unsigned long )ambig_list != (unsigned long )((void *)0)) {
#line 530
            if (! exact) {
#line 532
              if (print_errors) {
                {
#line 535
                first.p = pfound;
#line 536
                first.next = ambig_list;
#line 537
                ambig_list = & first;
#line 575
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option \'%s\' is ambiguous; possibilities:",
                        *(argv + 0), *(argv + d->rpl_optind));
                }
                {
#line 578
                while (1) {
                  while_continue___2: /* CIL Label */ ;
                  {
#line 580
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" \'--%s\'",
                          (ambig_list->p)->name);
#line 581
                  ambig_list = ambig_list->next;
                  }
#line 578
                  if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 578
                    goto while_break___2;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
                {
#line 585
                fputc('\n', stderr);
                }
              }
              {
#line 588
              tmp___5 = strlen((char const   *)d->__nextchar);
#line 588
              d->__nextchar += tmp___5;
#line 589
              (d->rpl_optind) ++;
#line 590
              d->rpl_optopt = 0;
              }
#line 591
              return ('?');
            }
          }
          {
#line 594
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 594
            if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 594
              goto while_break___3;
            }
            {
#line 596
            pn = ambig_list->next;
#line 597
            free((void *)ambig_list);
#line 598
            ambig_list = pn;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 601
          if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 603
            option_index = indfound;
#line 604
            (d->rpl_optind) ++;
#line 605
            if (*nameend) {
#line 609
              if (pfound->has_arg) {
#line 610
                d->rpl_optarg = nameend + 1;
              } else {
#line 613
                if (print_errors) {
#line 620
                  if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
                    {
#line 628
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option \'--%s\' doesn\'t allow an argument\n",
                            *(argv + 0), pfound->name);
                    }
                  } else {
                    {
#line 642
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option \'%c%s\' doesn\'t allow an argument\n",
                            *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                            pfound->name);
                    }
                  }
                }
                {
#line 668
                tmp___6 = strlen((char const   *)d->__nextchar);
#line 668
                d->__nextchar += tmp___6;
#line 670
                d->rpl_optopt = (int )pfound->val;
                }
#line 671
                return ('?');
              }
            } else
#line 674
            if (pfound->has_arg == 1) {
#line 676
              if (d->rpl_optind < argc) {
#line 677
                tmp___7 = d->rpl_optind;
#line 677
                (d->rpl_optind) ++;
#line 677
                d->rpl_optarg = *(argv + tmp___7);
              } else {
#line 680
                if (print_errors) {
                  {
#line 703
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option \'--%s\' requires an argument\n",
                          *(argv + 0), pfound->name);
                  }
                }
                {
#line 708
                tmp___8 = strlen((char const   *)d->__nextchar);
#line 708
                d->__nextchar += tmp___8;
#line 709
                d->rpl_optopt = (int )pfound->val;
                }
#line 710
                if ((int const   )*(optstring + 0) == 58) {
#line 710
                  tmp___9 = ':';
                } else {
#line 710
                  tmp___9 = '?';
                }
#line 710
                return (tmp___9);
              }
            }
            {
#line 713
            tmp___10 = strlen((char const   *)d->__nextchar);
#line 713
            d->__nextchar += tmp___10;
            }
#line 714
            if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 715
              *longind = option_index;
            }
#line 716
            if (pfound->flag) {
#line 718
              *(pfound->flag) = (int )pfound->val;
#line 719
              return (0);
            }
#line 721
            return ((int )pfound->val);
          }
#line 728
          if (! long_only) {
#line 728
            goto _L___4;
          } else
#line 728
          if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 728
            goto _L___4;
          } else {
            {
#line 728
            tmp___11 = strchr(optstring, (int )*(d->__nextchar));
            }
#line 728
            if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
              _L___4: /* CIL Label */ 
#line 731
              if (print_errors) {
#line 738
                if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
                  {
#line 745
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option \'--%s\'\n",
                          *(argv + 0), d->__nextchar);
                  }
                } else {
                  {
#line 756
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option \'%c%s\'\n",
                          *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0), d->__nextchar);
                  }
                }
              }
#line 778
              d->__nextchar = (char *)"";
#line 779
              (d->rpl_optind) ++;
#line 780
              d->rpl_optopt = 0;
#line 781
              return ('?');
            }
          }
        }
      }
    }
  }
  {
#line 788
  tmp___13 = d->__nextchar;
#line 788
  (d->__nextchar) ++;
#line 788
  c = *tmp___13;
#line 789
  tmp___14 = strchr(optstring, (int )c);
#line 789
  temp = (char const   *)tmp___14;
  }
#line 792
  if ((int )*(d->__nextchar) == 0) {
#line 793
    (d->rpl_optind) ++;
  }
#line 795
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 795
    goto _L___7;
  } else
#line 795
  if ((int )c == 58) {
#line 795
    goto _L___7;
  } else
#line 795
  if ((int )c == 59) {
    _L___7: /* CIL Label */ 
#line 797
    if (print_errors) {
      {
#line 808
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid option -- \'%c\'\n",
              *(argv + 0), (int )c);
      }
    }
#line 828
    d->rpl_optopt = (int )c;
#line 829
    return ('?');
  }
#line 832
  if ((int const   )*(temp + 0) == 87) {
#line 832
    if ((int const   )*(temp + 1) == 59) {
#line 836
      pfound___0 = (struct rpl_option  const  *)((void *)0);
#line 837
      exact___0 = 0;
#line 838
      ambig = 0;
#line 839
      indfound___0 = 0;
#line 842
      if ((unsigned long )longopts___0 == (unsigned long )((void *)0)) {
#line 843
        goto no_longs;
      }
#line 846
      if ((int )*(d->__nextchar) != 0) {
#line 848
        d->rpl_optarg = d->__nextchar;
#line 851
        (d->rpl_optind) ++;
      } else
#line 853
      if (d->rpl_optind == argc) {
#line 855
        if (print_errors) {
          {
#line 877
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option requires an argument -- \'%c\'\n",
                  *(argv + 0), (int )c);
          }
        }
#line 882
        d->rpl_optopt = (int )c;
#line 883
        if ((int const   )*(optstring + 0) == 58) {
#line 884
          c = (char )':';
        } else {
#line 886
          c = (char )'?';
        }
#line 887
        return ((int )c);
      } else {
#line 892
        tmp___15 = d->rpl_optind;
#line 892
        (d->rpl_optind) ++;
#line 892
        d->rpl_optarg = *(argv + tmp___15);
      }
#line 897
      nameend___0 = d->rpl_optarg;
#line 897
      d->__nextchar = nameend___0;
      {
#line 897
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 897
        if (*nameend___0) {
#line 897
          if (! ((int )*nameend___0 != 61)) {
#line 897
            goto while_break___4;
          }
        } else {
#line 897
          goto while_break___4;
        }
#line 897
        nameend___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 903
      p___0 = longopts___0;
#line 903
      option_index___0 = 0;
      {
#line 903
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 903
        if (! p___0->name) {
#line 903
          goto while_break___5;
        }
        {
#line 904
        tmp___17 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                           (size_t )(nameend___0 - d->__nextchar));
        }
#line 904
        if (! tmp___17) {
          {
#line 906
          tmp___16 = strlen((char const   *)p___0->name);
          }
#line 906
          if ((size_t )((unsigned int )(nameend___0 - d->__nextchar)) == tmp___16) {
#line 909
            pfound___0 = p___0;
#line 910
            indfound___0 = option_index___0;
#line 911
            exact___0 = 1;
#line 912
            goto while_break___5;
          } else
#line 914
          if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
#line 917
            pfound___0 = p___0;
#line 918
            indfound___0 = option_index___0;
          } else
#line 920
          if (long_only) {
#line 925
            ambig = 1;
          } else
#line 920
          if (pfound___0->has_arg != p___0->has_arg) {
#line 925
            ambig = 1;
          } else
#line 920
          if ((unsigned long )pfound___0->flag != (unsigned long )p___0->flag) {
#line 925
            ambig = 1;
          } else
#line 920
          if (pfound___0->val != p___0->val) {
#line 925
            ambig = 1;
          }
        }
#line 903
        p___0 ++;
#line 903
        option_index___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 927
      if (ambig) {
#line 927
        if (! exact___0) {
#line 929
          if (print_errors) {
            {
#line 950
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option \'-W %s\' is ambiguous\n",
                    *(argv + 0), d->rpl_optarg);
            }
          }
          {
#line 954
          tmp___18 = strlen((char const   *)d->__nextchar);
#line 954
          d->__nextchar += tmp___18;
#line 955
          (d->rpl_optind) ++;
          }
#line 956
          return ('?');
        }
      }
#line 958
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
#line 960
        option_index___0 = indfound___0;
#line 961
        if (*nameend___0) {
#line 965
          if (pfound___0->has_arg) {
#line 966
            d->rpl_optarg = nameend___0 + 1;
          } else {
#line 969
            if (print_errors) {
              {
#line 992
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option \'-W %s\' doesn\'t allow an argument\n",
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 998
            tmp___19 = strlen((char const   *)d->__nextchar);
#line 998
            d->__nextchar += tmp___19;
            }
#line 999
            return ('?');
          }
        } else
#line 1002
        if (pfound___0->has_arg == 1) {
#line 1004
          if (d->rpl_optind < argc) {
#line 1005
            tmp___20 = d->rpl_optind;
#line 1005
            (d->rpl_optind) ++;
#line 1005
            d->rpl_optarg = *(argv + tmp___20);
          } else {
#line 1008
            if (print_errors) {
              {
#line 1031
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option \'-W %s\' requires an argument\n",
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 1036
            tmp___21 = strlen((char const   *)d->__nextchar);
#line 1036
            d->__nextchar += tmp___21;
            }
#line 1037
            if ((int const   )*(optstring + 0) == 58) {
#line 1037
              tmp___22 = ':';
            } else {
#line 1037
              tmp___22 = '?';
            }
#line 1037
            return (tmp___22);
          }
        } else {
#line 1041
          d->rpl_optarg = (char *)((void *)0);
        }
        {
#line 1042
        tmp___23 = strlen((char const   *)d->__nextchar);
#line 1042
        d->__nextchar += tmp___23;
        }
#line 1043
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 1044
          *longind = option_index___0;
        }
#line 1045
        if (pfound___0->flag) {
#line 1047
          *(pfound___0->flag) = (int )pfound___0->val;
#line 1048
          return (0);
        }
#line 1050
        return ((int )pfound___0->val);
      }
      no_longs: 
#line 1054
      d->__nextchar = (char *)((void *)0);
#line 1055
      return ('W');
    }
  }
#line 1057
  if ((int const   )*(temp + 1) == 58) {
#line 1059
    if ((int const   )*(temp + 2) == 58) {
#line 1062
      if ((int )*(d->__nextchar) != 0) {
#line 1064
        d->rpl_optarg = d->__nextchar;
#line 1065
        (d->rpl_optind) ++;
      } else {
#line 1068
        d->rpl_optarg = (char *)((void *)0);
      }
#line 1069
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1074
      if ((int )*(d->__nextchar) != 0) {
#line 1076
        d->rpl_optarg = d->__nextchar;
#line 1079
        (d->rpl_optind) ++;
      } else
#line 1081
      if (d->rpl_optind == argc) {
#line 1083
        if (print_errors) {
          {
#line 1105
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option requires an argument -- \'%c\'\n",
                  *(argv + 0), (int )c);
          }
        }
#line 1110
        d->rpl_optopt = (int )c;
#line 1111
        if ((int const   )*(optstring + 0) == 58) {
#line 1112
          c = (char )':';
        } else {
#line 1114
          c = (char )'?';
        }
      } else {
#line 1119
        tmp___24 = d->rpl_optind;
#line 1119
        (d->rpl_optind) ++;
#line 1119
        d->rpl_optarg = *(argv + tmp___24);
      }
#line 1120
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1123
  return ((int )c);
}
}
#line 1127 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts___0 ,
                        int *longind , int long_only , int posixly_correct___0 ) 
{ 
  int result ;

  {
  {
#line 1134
  getopt_data.rpl_optind = rpl_optind;
#line 1135
  getopt_data.rpl_opterr = rpl_opterr;
#line 1137
  result = _getopt_internal_r(argc, argv, optstring, longopts___0, longind, long_only,
                              & getopt_data, posixly_correct___0);
#line 1141
  rpl_optind = getopt_data.rpl_optind;
#line 1142
  rpl_optarg = getopt_data.rpl_optarg;
#line 1143
  rpl_optopt = getopt_data.rpl_optopt;
  }
#line 1145
  return (result);
}
}
#line 1156
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc ,
                                                                                  char * const  *argv ,
                                                                                  char const   *optstring ) ;
#line 1156 "/home/wslee/gnu_benchmarks/patch-2.7/lib/getopt.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc , char * const  *argv ,
                                                    char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 1159
  tmp = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option  const  *)0,
                            (int *)0, 0, 1);
  }
#line 1159
  return (tmp);
}
}
#line 29 "/home/wslee/gnu_benchmarks/patch-2.7/lib/full-write.h"
size_t full_write(int fd , void const   *buf___0 , size_t count ) ;
#line 57 "/home/wslee/gnu_benchmarks/patch-2.7/lib/full-write.c"
size_t full_write(int fd , void const   *buf___0 , size_t count ) 
{ 
  size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 60
  total = (size_t )0;
#line 61
  ptr = (char const   *)buf___0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (count > 0UL)) {
#line 63
      goto while_break;
    }
    {
#line 65
    tmp = safe_write(fd, (void const   *)ptr, count);
#line 65
    n_rw = tmp;
    }
#line 66
    if (n_rw == 0xffffffffffffffffUL) {
#line 67
      goto while_break;
    }
#line 68
    if (n_rw == 0UL) {
      {
#line 70
      tmp___0 = __errno_location();
#line 70
      *tmp___0 = 28;
      }
#line 71
      goto while_break;
    }
#line 73
    total += n_rw;
#line 74
    ptr += n_rw;
#line 75
    count -= n_rw;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (total);
}
}
#line 36 "/home/wslee/gnu_benchmarks/patch-2.7/lib/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 39
  if (0 <= fd) {
#line 39
    if (fd <= 2) {
      {
#line 41
      tmp = dup_safer(fd);
#line 41
      f = tmp;
#line 42
      tmp___0 = __errno_location();
#line 42
      e = *tmp___0;
#line 43
      close(fd);
#line 44
      tmp___1 = __errno_location();
#line 44
      *tmp___1 = e;
#line 45
      fd = f;
      }
    }
  }
#line 48
  return (fd);
}
}
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 403 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 232 "/home/wslee/gnu_benchmarks/patch-2.7/lib/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 168 "/home/wslee/gnu_benchmarks/patch-2.7/lib/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list arg ;
  int result ;
  int target ;
  int tmp___0 ;
  int *tmp___1 ;
  int flags ;
  int tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *p ;
  void *tmp___7 ;

  {
  {
#line 172
  result = -1;
#line 173
  __builtin_va_start(arg, action);
  }
  {
#line 217
  if (action == 1030) {
#line 217
    goto case_1030;
  }
#line 298
  goto switch_default;
  case_1030: /* CIL Label */ 
  {
#line 219
  tmp___0 = __builtin_va_arg(arg, int );
#line 219
  target = tmp___0;
  }
#line 233
  if (0 <= have_dupfd_cloexec) {
    {
#line 235
    result = fcntl(fd, action, target);
    }
#line 236
    if (0 <= result) {
#line 238
      have_dupfd_cloexec = 1;
    } else {
      {
#line 236
      tmp___1 = __errno_location();
      }
#line 236
      if (*tmp___1 != 22) {
#line 238
        have_dupfd_cloexec = 1;
      } else {
        {
#line 246
        result = rpl_fcntl(fd, 0, target);
        }
#line 247
        if (result < 0) {
#line 248
          goto switch_break;
        }
#line 249
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    {
#line 253
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 254
  if (0 <= result) {
#line 254
    if (have_dupfd_cloexec == -1) {
      {
#line 256
      tmp___2 = fcntl(result, 1);
#line 256
      flags = tmp___2;
      }
#line 257
      if (flags < 0) {
#line 257
        goto _L;
      } else {
        {
#line 257
        tmp___5 = fcntl(result, 2, flags | 1);
        }
#line 257
        if (tmp___5 == -1) {
          _L: /* CIL Label */ 
          {
#line 259
          tmp___3 = __errno_location();
#line 259
          saved_errno = *tmp___3;
#line 260
          close(result);
#line 261
          tmp___4 = __errno_location();
#line 261
          *tmp___4 = saved_errno;
#line 262
          result = -1;
          }
        }
      }
    }
  }
#line 265
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 301
  tmp___7 = __builtin_va_arg(arg, void *);
#line 301
  p = tmp___7;
#line 302
  result = fcntl(fd, action, p);
  }
#line 306
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 309
  __builtin_va_end(arg);
  }
#line 310
  return (result);
}
}
#line 24 "/home/wslee/gnu_benchmarks/patch-2.7/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 30 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = rpl_fcntl(fd, 0, 3);
  }
#line 33
  return (tmp);
}
}
#line 36 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dirname.h"
char *dir_name(char const   *file ) ;
#line 39
char *mdir_name(char const   *file ) ;
#line 31 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dirname.c"
char *dir_name(char const   *file ) 
{ 
  char *result ;
  char *tmp ;

  {
  {
#line 34
  tmp = mdir_name(file);
#line 34
  result = tmp;
  }
#line 35
  if (! result) {
    {
#line 36
    xalloc_die();
    }
  }
#line 37
  return (result);
}
}
#line 41 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dirname.h"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 47 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 135 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.h"
int c_tolower(int c )  __attribute__((__const__)) ;
#line 26 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
#line 41
    n --;
    }
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 26 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 26 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
    }
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 120 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.h"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 122
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 124
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 125
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 126
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 127
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 128
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 129
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 130
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 132
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 133
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 26 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 26 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 29
  if (c >= 0) {
#line 29
    if (c <= 127) {
#line 29
      tmp = 1;
    } else {
#line 29
      tmp = 0;
    }
  } else {
#line 29
    tmp = 0;
  }
#line 29
  return ((_Bool )tmp);
}
}
#line 32
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 32 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 38
  if (c >= 48) {
#line 38
    if (c <= 57) {
#line 38
      tmp = 1;
    } else {
#line 38
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 38
  if ((c & -33) >= 65) {
#line 38
    if ((c & -33) <= 90) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
  } else {
#line 38
    tmp = 0;
  }
#line 38
  return ((_Bool )tmp);
}
}
#line 67
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 67 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 72
  if ((c & -33) >= 65) {
#line 72
    if ((c & -33) <= 90) {
#line 72
      tmp = 1;
    } else {
#line 72
      tmp = 0;
    }
  } else {
#line 72
    tmp = 0;
  }
#line 72
  return ((_Bool )tmp);
}
}
#line 96
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 96 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 99
  if (c == 32) {
#line 99
    tmp = 1;
  } else
#line 99
  if (c == 9) {
#line 99
    tmp = 1;
  } else {
#line 99
    tmp = 0;
  }
#line 99
  return ((_Bool )tmp);
}
}
#line 102
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 102 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 106
  if ((c & -32) == 0) {
#line 106
    tmp = 1;
  } else
#line 106
  if (c == 127) {
#line 106
    tmp = 1;
  } else {
#line 106
    tmp = 0;
  }
#line 106
  return ((_Bool )tmp);
}
}
#line 136
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 136 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 140
  if (c >= 48) {
#line 140
    if (c <= 57) {
#line 140
      tmp = 1;
    } else {
#line 140
      tmp = 0;
    }
  } else {
#line 140
    tmp = 0;
  }
#line 140
  return ((_Bool )tmp);
}
}
#line 153
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 153 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 157
  if (c >= 97) {
#line 157
    if (c <= 122) {
#line 157
      tmp = 1;
    } else {
#line 157
      tmp = 0;
    }
  } else {
#line 157
    tmp = 0;
  }
#line 157
  return ((_Bool )tmp);
}
}
#line 173
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 173 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 177
  if (c >= 33) {
#line 177
    if (c <= 126) {
#line 177
      tmp = 1;
    } else {
#line 177
      tmp = 0;
    }
  } else {
#line 177
    tmp = 0;
  }
#line 177
  return ((_Bool )tmp);
}
}
#line 207
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 207 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 211
  if (c >= 32) {
#line 211
    if (c <= 126) {
#line 211
      tmp = 1;
    } else {
#line 211
      tmp = 0;
    }
  } else {
#line 211
    tmp = 0;
  }
#line 211
  return ((_Bool )tmp);
}
}
#line 241
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 241 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 245
  if (c >= 33) {
#line 245
    if (c <= 126) {
#line 245
      if (c >= 48) {
#line 245
        if (c <= 57) {
#line 245
          tmp = 0;
        } else {
#line 245
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 245
      if ((c & -33) >= 65) {
#line 245
        if ((c & -33) <= 90) {
#line 245
          tmp = 0;
        } else {
#line 245
          tmp = 1;
        }
      } else {
#line 245
        tmp = 1;
      }
    } else {
#line 245
      tmp = 0;
    }
  } else {
#line 245
    tmp = 0;
  }
#line 245
  return ((_Bool )tmp);
}
}
#line 265
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 265 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 268
  if (c == 32) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 9) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 10) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 11) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 12) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 13) {
#line 268
    tmp = 1;
  } else {
#line 268
    tmp = 0;
  }
#line 268
  return ((_Bool )tmp);
}
}
#line 272
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 272 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 276
  if (c >= 65) {
#line 276
    if (c <= 90) {
#line 276
      tmp = 1;
    } else {
#line 276
      tmp = 0;
    }
  } else {
#line 276
    tmp = 0;
  }
#line 276
  return ((_Bool )tmp);
}
}
#line 292
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 292 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 298
  if (c >= 48) {
#line 298
    if (c <= 57) {
#line 298
      tmp = 1;
    } else {
#line 298
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 298
  if ((c & -33) >= 65) {
#line 298
    if ((c & -33) <= 70) {
#line 298
      tmp = 1;
    } else {
#line 298
      tmp = 0;
    }
  } else {
#line 298
    tmp = 0;
  }
#line 298
  return ((_Bool )tmp);
}
}
#line 319
int c_tolower(int c )  __attribute__((__const__)) ;
#line 319 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 323
  if (c >= 65) {
#line 323
    if (c <= 90) {
#line 323
      tmp = (c - 65) + 97;
    } else {
#line 323
      tmp = c;
    }
  } else {
#line 323
    tmp = c;
  }
#line 323
  return (tmp);
}
}
#line 358
int c_toupper(int c )  __attribute__((__const__)) ;
#line 358 "/home/wslee/gnu_benchmarks/patch-2.7/lib/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 362
  if (c >= 97) {
#line 362
    if (c <= 122) {
#line 362
      tmp = (c - 97) + 65;
    } else {
#line 362
      tmp = c;
    }
  } else {
#line 362
    tmp = c;
  }
#line 362
  return (tmp);
}
}
#line 35 "/home/wslee/gnu_benchmarks/patch-2.7/lib/dirname.h"
char *base_name(char const   *name ) ;
#line 27 "/home/wslee/gnu_benchmarks/patch-2.7/lib/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  {
#line 30
  tmp = last_component(name);
#line 30
  base = (char const   *)tmp;
  }
#line 35
  if (! *base) {
    {
#line 36
    tmp___0 = base_len(name);
#line 36
    tmp___1 = xstrndup(name, tmp___0);
    }
#line 36
    return (tmp___1);
  }
  {
#line 39
  length = base_len(base);
  }
#line 40
  if ((int const   )*(base + length) == 47) {
#line 41
    length ++;
  }
  {
#line 57
  tmp___3 = xstrndup(base, length);
  }
#line 57
  return (tmp___3);
}
}
#line 29 "/home/wslee/gnu_benchmarks/patch-2.7/lib/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/home/wslee/gnu_benchmarks/patch-2.7/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/home/wslee/gnu_benchmarks/patch-2.7/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 47 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.h"
char const   *simple_backup_suffix ;
#line 49
char *find_backup_file_name(char const   *file , enum backup_type backup_type___0 ) ;
#line 50
enum backup_type get_version(char const   *context , char const   *version___0 ) ;
#line 51
enum backup_type xget_version(char const   *context , char const   *version___0 ) ;
#line 52 "/home/wslee/gnu_benchmarks/patch-2.7/lib/argmatch.h"
void (*argmatch_die)(void) ;
#line 79
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 119 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 121
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 121 "/home/wslee/gnu_benchmarks/patch-2.7/lib/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 124
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 124
    tmp = -1;
  } else {
#line 124
    tmp = -2;
  }
#line 124
  if ((size_t )tmp / s < n) {
    {
#line 125
    xalloc_die();
    }
  }
  {
#line 126
  tmp___0 = xrealloc(p, n * s);
  }
#line 126
  return (tmp___0);
}
}
#line 607 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) pathconf)(char const   *__path ,
                                                                                      int __name ) ;
#line 163 "/usr/include/dirent.h"
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 83 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.c"
char const   *simple_backup_suffix  =    "~";
#line 91 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.c"
static void check_extension(char *file , size_t filelen , char e ) 
{ 
  char *base ;
  char *tmp ;
  size_t baselen ;
  size_t tmp___0 ;
  size_t baselen_max ;
  long name_max ;
  char tmp___1[sizeof(".")] ;
  int *tmp___2 ;
  long size ;
  int *tmp___3 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 94
  tmp = last_component((char const   *)file);
#line 94
  base = tmp;
#line 95
  tmp___0 = base_len((char const   *)base);
#line 95
  baselen = tmp___0;
#line 96
  baselen_max = (size_t )255;
  }
#line 98
  if (14UL < baselen) {
    {
#line 106
    memcpy((void */* __restrict  */)(tmp___1), (void const   */* __restrict  */)base,
           sizeof("."));
#line 107
    strcpy((char */* __restrict  */)base, (char const   */* __restrict  */)".");
#line 108
    tmp___2 = __errno_location();
#line 108
    *tmp___2 = 0;
#line 109
    name_max = pathconf((char const   *)file, 3);
    }
#line 110
    if (0L <= name_max) {
#line 110
      goto _L;
    } else {
      {
#line 110
      tmp___3 = __errno_location();
      }
#line 110
      if (*tmp___3 == 0) {
        _L: /* CIL Label */ 
#line 112
        baselen_max = (size_t )name_max;
#line 112
        size = (long )baselen_max;
#line 113
        if (name_max != size) {
#line 114
          baselen_max = (size_t )-1;
        }
      }
    }
    {
#line 116
    memcpy((void */* __restrict  */)base, (void const   */* __restrict  */)(tmp___1),
           sizeof("."));
    }
  }
#line 134
  if (baselen_max < baselen) {
#line 136
    baselen = (size_t )((file + filelen) - base);
#line 137
    if (baselen_max <= baselen) {
#line 138
      baselen = baselen_max - 1UL;
    }
#line 139
    *(base + baselen) = e;
#line 140
    *(base + (baselen + 1UL)) = (char )'\000';
  }
#line 142
  return;
}
}
#line 171 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.c"
static enum numbered_backup_result numbered_backup(char **buffer , size_t buffer_size ,
                                                   size_t filelen ) 
{ 
  enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf___0 ;
  size_t versionlenmax ;
  char *base ;
  char *tmp ;
  size_t base_offset ;
  size_t baselen ;
  size_t tmp___0 ;
  char tmp___1[sizeof(".")] ;
  char const   *p ;
  char *q ;
  _Bool all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 174
  result = (enum numbered_backup_result )2;
#line 177
  buf___0 = *buffer;
#line 178
  versionlenmax = (size_t )1;
#line 179
  tmp = last_component((char const   *)buf___0);
#line 179
  base = tmp;
#line 180
  base_offset = (size_t )(base - buf___0);
#line 181
  tmp___0 = base_len((char const   *)base);
#line 181
  baselen = tmp___0;
#line 186
  memcpy((void */* __restrict  */)(tmp___1), (void const   */* __restrict  */)base,
         sizeof("."));
#line 187
  strcpy((char */* __restrict  */)base, (char const   */* __restrict  */)".");
#line 188
  dirp = opendir_safer((char const   *)buf___0);
#line 189
  memcpy((void */* __restrict  */)base, (void const   */* __restrict  */)(tmp___1),
         sizeof("."));
#line 190
  strcpy((char */* __restrict  */)(base + baselen), (char const   */* __restrict  */)".~1~");
  }
#line 192
  if (! dirp) {
#line 193
    return (result);
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    dp = readdir(dirp);
    }
#line 195
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 195
      goto while_break;
    }
#line 203
    if (! (dp->d_ino != 0UL)) {
#line 204
      goto while_continue;
    } else {
      {
#line 203
      tmp___2 = strlen((char const   *)(dp->d_name));
      }
#line 203
      if (tmp___2 < baselen + 4UL) {
#line 204
        goto while_continue;
      }
    }
    {
#line 206
    tmp___3 = memcmp((void const   *)(buf___0 + base_offset), (void const   *)(dp->d_name),
                     baselen + 2UL);
    }
#line 206
    if (tmp___3 != 0) {
#line 207
      goto while_continue;
    }
#line 209
    p = (char const   *)((dp->d_name + baselen) + 2);
#line 215
    if (49 <= (int )*p) {
#line 215
      if (! ((int const   )*p <= 57)) {
#line 216
        goto while_continue;
      }
    } else {
#line 216
      goto while_continue;
    }
#line 217
    all_9s = (_Bool )((int const   )*p == 57);
#line 218
    versionlen = (size_t )1;
    {
#line 218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 218
      if (! ((unsigned int )*(p + versionlen) - 48U <= 9U)) {
#line 218
        goto while_break___0;
      }
#line 219
      all_9s = (_Bool )((int )all_9s & ((int const   )*(p + versionlen) == 57));
#line 218
      versionlen ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 221
    if ((int const   )*(p + versionlen) == 126) {
#line 221
      if (! *(p + (versionlen + 1UL))) {
#line 221
        if (! (versionlenmax < versionlen)) {
#line 221
          if (versionlenmax == versionlen) {
            {
#line 221
            tmp___4 = memcmp((void const   *)((buf___0 + filelen) + 2), (void const   *)p,
                             versionlen);
            }
#line 221
            if (! (tmp___4 <= 0)) {
#line 225
              goto while_continue;
            }
          } else {
#line 225
            goto while_continue;
          }
        }
      } else {
#line 225
        goto while_continue;
      }
    } else {
#line 225
      goto while_continue;
    }
#line 231
    versionlenmax = (size_t )all_9s + versionlen;
#line 232
    if (all_9s) {
#line 232
      result = (enum numbered_backup_result )1;
    } else {
#line 232
      result = (enum numbered_backup_result )0;
    }
#line 233
    new_buflen = ((filelen + 2UL) + versionlenmax) + 1UL;
#line 234
    if (buffer_size <= new_buflen) {
      {
#line 236
      tmp___5 = xnrealloc((void *)buf___0, (size_t )2, new_buflen);
#line 236
      buf___0 = (char *)tmp___5;
#line 237
      buffer_size = new_buflen * 2UL;
      }
    }
    {
#line 239
    q = buf___0 + filelen;
#line 240
    tmp___6 = q;
#line 240
    q ++;
#line 240
    *tmp___6 = (char )'.';
#line 241
    tmp___7 = q;
#line 241
    q ++;
#line 241
    *tmp___7 = (char )'~';
#line 242
    *q = (char )'0';
#line 243
    q += (int )all_9s;
#line 244
    memcpy((void */* __restrict  */)q, (void const   */* __restrict  */)p, versionlen + 2UL);
#line 248
    q += versionlen;
    }
    {
#line 249
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 249
      q --;
#line 249
      if (! ((int )*q == 57)) {
#line 249
        goto while_break___1;
      }
#line 250
      *q = (char )'0';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 251
    *q = (char )((int )*q + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  closedir(dirp);
#line 255
  *buffer = buf___0;
  }
#line 256
  return (result);
}
}
#line 263 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.c"
char *find_backup_file_name(char const   *file , enum backup_type backup_type___0 ) 
{ 
  size_t filelen ;
  size_t tmp ;
  char *s ;
  size_t ssize ;
  _Bool simple ;
  size_t simple_backup_suffix_size ;
  size_t tmp___0 ;
  size_t backup_suffix_size_guess ;
  void *tmp___1 ;
  enum numbered_backup_result tmp___2 ;

  {
  {
#line 266
  tmp = strlen(file);
#line 266
  filelen = tmp;
#line 269
  simple = (_Bool)1;
#line 273
  tmp___0 = strlen(simple_backup_suffix);
#line 273
  simple_backup_suffix_size = tmp___0 + 1UL;
#line 274
  backup_suffix_size_guess = simple_backup_suffix_size;
  }
#line 276
  if (backup_suffix_size_guess < 9UL) {
#line 277
    backup_suffix_size_guess = (size_t )9;
  }
  {
#line 279
  ssize = (filelen + backup_suffix_size_guess) + 1UL;
#line 280
  tmp___1 = xmalloc(ssize);
#line 280
  s = (char *)tmp___1;
#line 281
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)file, filelen + 1UL);
  }
#line 283
  if ((unsigned int )backup_type___0 != 1U) {
    {
#line 284
    tmp___2 = numbered_backup(& s, ssize, filelen);
    }
    {
#line 286
    if ((unsigned int )tmp___2 == 0U) {
#line 286
      goto case_0;
    }
#line 289
    if ((unsigned int )tmp___2 == 1U) {
#line 289
      goto case_1;
    }
#line 293
    if ((unsigned int )tmp___2 == 2U) {
#line 293
      goto case_2;
    }
#line 284
    goto switch_break;
    case_0: /* CIL Label */ 
#line 287
    return (s);
    case_1: /* CIL Label */ 
#line 290
    simple = (_Bool)0;
#line 291
    goto switch_break;
    case_2: /* CIL Label */ 
#line 294
    simple = (_Bool )((unsigned int )backup_type___0 == 2U);
#line 295
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 298
  if (simple) {
    {
#line 299
    memcpy((void */* __restrict  */)(s + filelen), (void const   */* __restrict  */)simple_backup_suffix,
           simple_backup_suffix_size);
    }
  }
  {
#line 300
  check_extension(s, filelen, (char )'~');
  }
#line 301
  return (s);
}
}
#line 304 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.c"
static char const   * const  backup_args[9]  = 
#line 304
  {      (char const   */* const  */)"none",      (char const   */* const  */)"off",      (char const   */* const  */)"simple",      (char const   */* const  */)"never", 
        (char const   */* const  */)"existing",      (char const   */* const  */)"nil",      (char const   */* const  */)"numbered",      (char const   */* const  */)"t", 
        (char const   */* const  */)((void *)0)};
#line 315 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.c"
static enum backup_type  const  backup_types[8]  = 
#line 315
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
#line 332 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.c"
enum backup_type get_version(char const   *context , char const   *version___0 ) 
{ 
  ptrdiff_t tmp ;

  {
#line 335
  if ((unsigned long )version___0 == (unsigned long )((char const   *)0)) {
#line 336
    return ((enum backup_type )2);
  } else
#line 335
  if ((int const   )*version___0 == 0) {
#line 336
    return ((enum backup_type )2);
  } else {
    {
#line 338
    tmp = __xargmatch_internal(context, version___0, backup_args, (char const   *)(backup_types),
                               sizeof(backup_types[0]), argmatch_die);
    }
#line 338
    return ((enum backup_type )backup_types[tmp]);
  }
}
}
#line 348 "/home/wslee/gnu_benchmarks/patch-2.7/lib/backupfile.c"
enum backup_type xget_version(char const   *context , char const   *version___0 ) 
{ 
  enum backup_type tmp ;
  char *tmp___0 ;
  enum backup_type tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 351
  if (version___0) {
#line 351
    if (*version___0) {
      {
#line 352
      tmp = get_version(context, version___0);
      }
#line 352
      return (tmp);
    } else {
      {
#line 354
      tmp___0 = getenv("VERSION_CONTROL");
#line 354
      tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
      }
#line 354
      return (tmp___1);
    }
  } else {
    {
#line 354
    tmp___0 = getenv("VERSION_CONTROL");
#line 354
    tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
    }
#line 354
    return (tmp___1);
  }
}
}
#line 70 "/home/wslee/gnu_benchmarks/patch-2.7/lib/vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 24 "/home/wslee/gnu_benchmarks/patch-2.7/lib/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 30
  __builtin_va_start(args, format);
#line 31
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 32
  __builtin_va_end(args);
  }
#line 33
  return (result);
}
}
#line 42 "/home/wslee/gnu_benchmarks/patch-2.7/lib/argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 56
void argmatch_invalid(char const   *context , char const   *value___0 , ptrdiff_t problem ) ;
#line 68
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 94
char const   *argmatch_to_argument(char const   *value___0 , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 60 "/home/wslee/gnu_benchmarks/patch-2.7/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 63
  exit((int )exit_failure);
  }
}
}
#line 68 "/home/wslee/gnu_benchmarks/patch-2.7/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 82 "/home/wslee/gnu_benchmarks/patch-2.7/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 88
  matchind = (ptrdiff_t )-1;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen = strlen(arg);
#line 94
  i = (size_t )0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! *(arglist + i)) {
#line 94
      goto while_break;
    }
    {
#line 96
    tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
    }
#line 96
    if (! tmp___1) {
      {
#line 98
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 98
      if (tmp___0 == arglen) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1L) {
#line 103
        matchind = (ptrdiff_t )i;
      } else
#line 107
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
        {
#line 107
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 107
        if (tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (ambiguous) {
#line 119
    return ((ptrdiff_t )-2);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "/home/wslee/gnu_benchmarks/patch-2.7/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value___0 , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 132
  if (problem == -1L) {
#line 132
    tmp = "invalid argument %s for %s";
  } else {
#line 132
    tmp = "ambiguous argument %s for %s";
  }
  {
#line 132
  format = tmp;
#line 136
  tmp___0 = quote_n(1, context);
#line 136
  tmp___1 = quotearg_n_style(0, (enum quoting_style )6, value___0);
#line 136
  error(0, 0, format, tmp___1, tmp___0);
  }
#line 138
  return;
}
}
#line 144 "/home/wslee/gnu_benchmarks/patch-2.7/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  fputs((char const   */* __restrict  */)"Valid arguments are:", (FILE */* __restrict  */)stderr);
#line 154
  i = (size_t )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! *(arglist + i)) {
#line 154
      goto while_break;
    }
#line 155
    if (i == 0UL) {
      {
#line 158
      tmp = quote((char const   *)*(arglist + i));
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
              tmp);
#line 159
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 155
      tmp___1 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 155
      if (tmp___1) {
        {
#line 158
        tmp = quote((char const   *)*(arglist + i));
#line 158
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
                tmp);
#line 159
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 163
        tmp___0 = quote((char const   *)*(arglist + i));
#line 163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", %s",
                tmp___0);
        }
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  _IO_putc('\n', stderr);
  }
#line 166
  return;
}
}
#line 174 "/home/wslee/gnu_benchmarks/patch-2.7/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 180
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = tmp;
  }
#line 181
  if (res >= 0L) {
#line 183
    return (res);
  }
  {
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
  }
#line 190
  return ((ptrdiff_t )-1);
}
}
#line 195
char const   *argmatch_to_argument(char const   *value___0 , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 195 "/home/wslee/gnu_benchmarks/patch-2.7/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value___0 , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 202
  i = (size_t )0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! *(arglist + i)) {
#line 202
      goto while_break;
    }
    {
#line 203
    tmp = memcmp((void const   *)value___0, (void const   *)(vallist + valsize * i),
                 valsize);
    }
#line 203
    if (! tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 99 "./common.h"
int debug ;
#line 107
enum __anonenum_verbosity_22 verbosity ;
#line 110
_Bool canonicalize ;
#line 199
lin in_offset ;
#line 200
lin out_offset ;
#line 203
lin last_frozen_line ;
#line 205
_Bool copy_till(struct outstate *outstate , lin lastline ) ;
#line 206
_Bool similar(char const   *a , size_t alen , char const   *b , size_t blen )  __attribute__((__pure__)) ;
#line 210
enum conflict_style conflict_style ;
#line 212
_Bool merge_hunk(int hunk , struct outstate *outstate , lin where , _Bool *somefailed ) ;
#line 20 "./inp.h"
lin input_lines ;
#line 22
char const   *ifetch(lin line , _Bool whichbuf , size_t *psize ) ;
#line 22 "./pch.h"
lin pch_end(void)  __attribute__((__pure__)) ;
#line 23
lin pch_first(void)  __attribute__((__pure__)) ;
#line 31
lin pch_prefix_context(void)  __attribute__((__pure__)) ;
#line 32
lin pch_ptrn_lines(void)  __attribute__((__pure__)) ;
#line 34
lin pch_suffix_context(void)  __attribute__((__pure__)) ;
#line 36
_Bool pch_write_line(lin line , FILE *file ) ;
#line 38
char *pfetch(lin line )  __attribute__((__pure__)) ;
#line 39
char pch_char(lin line )  __attribute__((__pure__)) ;
#line 42
size_t pch_line_len(lin line )  __attribute__((__pure__)) ;
#line 50
void pch_normalize(enum diff format ) ;
#line 36 "./util.h"
void ( /* format attribute */  say)(char const   *format  , ...) ;
#line 51
char *format_linenum(char *numbuf , lin n ) ;
#line 66
 __attribute__((__noreturn__)) void write_fatal(void) ;
#line 27 "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c"
static lin count_context_lines(void) ;
#line 28
static _Bool context_matches_file(lin old , lin where ) ;
#line 29
static void compute_changes(lin xmin , lin xmax___0 , lin ymin , lin ymax , char *xchar ,
                            char *ychar ) ;
#line 54 "/home/wslee/gnu_benchmarks/patch-2.7/src/bestmatch.h"
static lin bestmatch(lin xoff , lin xlim , lin yoff , lin ylim , lin min , lin max ,
                     lin *py ) 
{ 
  lin dmin ;
  lin dmax ;
  lin fmid ;
  lin fmin ;
  lin fmax ;
  lin *V ;
  lin *fd ;
  lin fmid_plus_2_min ;
  lin ymax ;
  lin c ;
  void *tmp ;
  _Bool tmp___0 ;
  lin d ;
  lin x ;
  lin y ;
  _Bool tmp___1 ;

  {
  {
#line 58
  dmin = xoff - ylim;
#line 59
  dmax = xlim - yoff;
#line 60
  fmid = xoff - yoff;
#line 61
  fmin = fmid;
#line 62
  fmax = fmid;
#line 64
  ymax = (lin )-1;
#line 67
  tmp = malloc((unsigned long )(2L * max + 3L) * sizeof(lin ));
#line 67
  V = (lin *)tmp;
#line 68
  fd = ((V + max) + 1) - fmid;
  }
#line 87
  if (min) {
#line 89
    fmid_plus_2_min = fmid + 2L * min;
#line 90
    min += yoff;
#line 91
    if (min > ylim) {
#line 93
      c = max + 1L;
#line 94
      goto free_and_return;
    }
  } else {
#line 98
    fmid_plus_2_min = (lin )0;
  }
#line 99
  if (! py) {
#line 100
    min = ylim;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (xoff < xlim) {
#line 103
      if (yoff < ylim) {
        {
#line 103
        tmp___0 = context_matches_file(xoff, yoff);
        }
#line 103
        if (! tmp___0) {
#line 103
          goto while_break;
        }
      } else {
#line 103
        goto while_break;
      }
    } else {
#line 103
      goto while_break;
    }
#line 105
    xoff ++;
#line 106
    yoff ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (xoff == xlim) {
#line 108
    if (yoff >= min) {
#line 108
      if (xoff + yoff >= fmid_plus_2_min) {
#line 111
        ymax = yoff;
#line 112
        c = (lin )0;
      } else {
#line 108
        goto _L___0;
      }
    } else {
#line 108
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 116
    *(fd + fmid) = xoff;
#line 117
    c = (lin )1;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (c <= max)) {
#line 117
        goto while_break___0;
      }
#line 121
      if (fmin > dmin) {
#line 122
        fmin --;
#line 122
        *(fd + (fmin - 1L)) = (lin )-1;
      } else {
#line 124
        fmin ++;
      }
#line 125
      if (fmax < dmax) {
#line 126
        fmax ++;
#line 126
        *(fd + (fmax + 1L)) = (lin )-1;
      } else {
#line 128
        fmax --;
      }
#line 129
      d = fmax;
      {
#line 129
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 129
        if (! (d >= fmin)) {
#line 129
          goto while_break___1;
        }
#line 133
        if (*(fd + (d - 1L)) < *(fd + (d + 1L))) {
#line 134
          x = *(fd + (d + 1L));
        } else {
#line 136
          x = *(fd + (d - 1L)) + 1L;
        }
#line 137
        y = x - d;
        {
#line 137
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 137
          if (x < xlim) {
#line 137
            if (y < ylim) {
              {
#line 137
              tmp___1 = context_matches_file(x, y);
              }
#line 137
              if (! tmp___1) {
#line 137
                goto while_break___2;
              }
            } else {
#line 137
              goto while_break___2;
            }
          } else {
#line 137
            goto while_break___2;
          }
#line 137
          x ++;
#line 137
          y ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 141
        *(fd + d) = x;
#line 142
        if (x == xlim) {
#line 142
          if (y >= min) {
#line 142
            if ((x + y) - c >= fmid_plus_2_min) {
#line 145
              if (ymax < y) {
#line 146
                ymax = y;
              }
#line 147
              if (y == ylim) {
#line 148
                goto done;
              }
            }
          }
        }
#line 129
        d -= 2L;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 151
      if (ymax != -1L) {
#line 152
        goto done;
      }
#line 117
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  done: 
#line 157
  if (py) {
#line 158
    *py = ymax;
  }
  free_and_return: 
  {
#line 161
  free((void *)V);
  }
#line 162
  return (c);
}
}
#line 177 "../lib/diffseq.h"
static void diag(lin xoff , lin xlim , lin yoff , lin ylim , _Bool find_minimal ,
                 struct partition *part , struct context *ctxt ) 
{ 
  lin *fd ;
  lin *bd ;
  lin dmin ;
  lin dmax ;
  lin fmid ;
  lin bmid ;
  lin fmin ;
  lin fmax ;
  lin bmin ;
  lin bmax ;
  lin c ;
  _Bool odd ;
  lin d ;
  _Bool big_snake ;
  lin x ;
  lin y ;
  lin tlo ;
  lin thi ;
  lin x0 ;
  lin tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  lin x___0 ;
  lin y___0 ;
  lin tlo___0 ;
  lin thi___0 ;
  lin x0___0 ;
  lin tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  lin best ;
  lin dd ;
  lin x___1 ;
  lin y___1 ;
  lin v ;
  int k ;
  _Bool tmp___5 ;
  lin tmp___6 ;
  lin best___0 ;
  lin dd___0 ;
  lin x___2 ;
  lin y___2 ;
  lin v___0 ;
  int k___0 ;
  _Bool tmp___7 ;
  lin tmp___8 ;
  lin fxybest ;
  lin fxbest ;
  lin bxybest ;
  lin bxbest ;
  lin x___3 ;
  lin tmp___9 ;
  lin y___3 ;
  lin x___4 ;
  lin tmp___10 ;
  lin y___4 ;

  {
#line 181
  fd = ctxt->fdiag;
#line 182
  bd = ctxt->bdiag;
#line 190
  dmin = xoff - ylim;
#line 191
  dmax = xlim - yoff;
#line 192
  fmid = xoff - yoff;
#line 193
  bmid = xlim - ylim;
#line 194
  fmin = fmid;
#line 195
  fmax = fmid;
#line 196
  bmin = bmid;
#line 197
  bmax = bmid;
#line 199
  odd = (_Bool )((fmid - bmid) & 1L);
#line 202
  *(fd + fmid) = xoff;
#line 203
  *(bd + bmid) = xlim;
#line 205
  c = (lin )1;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    big_snake = (_Bool)0;
#line 211
    if (fmin > dmin) {
#line 212
      fmin --;
#line 212
      *(fd + (fmin - 1L)) = (lin )-1;
    } else {
#line 214
      fmin ++;
    }
#line 215
    if (fmax < dmax) {
#line 216
      fmax ++;
#line 216
      *(fd + (fmax + 1L)) = (lin )-1;
    } else {
#line 218
      fmax --;
    }
#line 219
    d = fmax;
    {
#line 219
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 219
      if (! (d >= fmin)) {
#line 219
        goto while_break___0;
      }
#line 223
      tlo = *(fd + (d - 1L));
#line 224
      thi = *(fd + (d + 1L));
#line 225
      if (tlo < thi) {
#line 225
        tmp = thi;
      } else {
#line 225
        tmp = tlo + 1L;
      }
#line 225
      x0 = tmp;
#line 227
      x = x0;
#line 227
      y = x0 - d;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 227
        if (x < xlim) {
#line 227
          if (y < ylim) {
            {
#line 227
            tmp___0 = context_matches_file(x, y);
            }
#line 227
            if (! tmp___0) {
#line 227
              goto while_break___1;
            }
          } else {
#line 227
            goto while_break___1;
          }
        } else {
#line 227
          goto while_break___1;
        }
#line 230
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 227
        x ++;
#line 227
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 231
      if (x - x0 > 20L) {
#line 232
        big_snake = (_Bool)1;
      }
#line 233
      *(fd + d) = x;
#line 234
      if (odd) {
#line 234
        if (bmin <= d) {
#line 234
          if (d <= bmax) {
#line 234
            if (*(bd + d) <= x) {
#line 236
              part->xmid = x;
#line 237
              part->ymid = y;
#line 238
              tmp___1 = (_Bool)1;
#line 238
              part->hi_minimal = tmp___1;
#line 238
              part->lo_minimal = tmp___1;
#line 239
              return;
            }
          }
        }
      }
#line 219
      d -= 2L;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (bmin > dmin) {
#line 245
      bmin --;
#line 245
      *(bd + (bmin - 1L)) = ((1L << (sizeof(lin ) * 8UL - 2UL)) - 1L) * 2L + 1L;
    } else {
#line 247
      bmin ++;
    }
#line 248
    if (bmax < dmax) {
#line 249
      bmax ++;
#line 249
      *(bd + (bmax + 1L)) = ((1L << (sizeof(lin ) * 8UL - 2UL)) - 1L) * 2L + 1L;
    } else {
#line 251
      bmax --;
    }
#line 252
    d = bmax;
    {
#line 252
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 252
      if (! (d >= bmin)) {
#line 252
        goto while_break___2;
      }
#line 256
      tlo___0 = *(bd + (d - 1L));
#line 257
      thi___0 = *(bd + (d + 1L));
#line 258
      if (tlo___0 < thi___0) {
#line 258
        tmp___2 = tlo___0;
      } else {
#line 258
        tmp___2 = thi___0 - 1L;
      }
#line 258
      x0___0 = tmp___2;
#line 260
      x___0 = x0___0;
#line 260
      y___0 = x0___0 - d;
      {
#line 260
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 260
        if (xoff < x___0) {
#line 260
          if (yoff < y___0) {
            {
#line 260
            tmp___3 = context_matches_file(x___0 - 1L, y___0 - 1L);
            }
#line 260
            if (! tmp___3) {
#line 260
              goto while_break___3;
            }
          } else {
#line 260
            goto while_break___3;
          }
        } else {
#line 260
          goto while_break___3;
        }
#line 263
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 260
        x___0 --;
#line 260
        y___0 --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 264
      if (x0___0 - x___0 > 20L) {
#line 265
        big_snake = (_Bool)1;
      }
#line 266
      *(bd + d) = x___0;
#line 267
      if (! odd) {
#line 267
        if (fmin <= d) {
#line 267
          if (d <= fmax) {
#line 267
            if (x___0 <= *(fd + d)) {
#line 269
              part->xmid = x___0;
#line 270
              part->ymid = y___0;
#line 271
              tmp___4 = (_Bool)1;
#line 271
              part->hi_minimal = tmp___4;
#line 271
              part->lo_minimal = tmp___4;
#line 272
              return;
            }
          }
        }
      }
#line 252
      d -= 2L;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 276
    if (find_minimal) {
#line 277
      goto __Cont___1;
    }
#line 288
    if (200L < c) {
#line 288
      if (big_snake) {
#line 288
        if (ctxt->heuristic) {
#line 291
          best = (lin )0;
#line 293
          d = fmax;
          {
#line 293
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 293
            if (! (d >= fmin)) {
#line 293
              goto while_break___4;
            }
#line 295
            dd = d - fmid;
#line 296
            x___1 = *(fd + d);
#line 297
            y___1 = x___1 - d;
#line 298
            v = (x___1 - xoff) * 2L - dd;
#line 300
            if (dd < 0L) {
#line 300
              tmp___6 = - dd;
            } else {
#line 300
              tmp___6 = dd;
            }
#line 300
            if (v > 12L * (c + tmp___6)) {
#line 302
              if (v > best) {
#line 302
                if (xoff + 20L <= x___1) {
#line 302
                  if (x___1 < xlim) {
#line 302
                    if (yoff + 20L <= y___1) {
#line 302
                      if (y___1 < ylim) {
#line 310
                        k = 1;
                        {
#line 310
                        while (1) {
                          while_continue___5: /* CIL Label */ ;
                          {
#line 310
                          tmp___5 = context_matches_file(x___1 - (lin )k, y___1 - (lin )k);
                          }
#line 310
                          if (! tmp___5) {
#line 310
                            goto while_break___5;
                          }
#line 311
                          if (k == 20) {
#line 313
                            best = v;
#line 314
                            part->xmid = x___1;
#line 315
                            part->ymid = y___1;
#line 316
                            goto while_break___5;
                          }
#line 310
                          k ++;
                        }
                        while_break___5: /* CIL Label */ ;
                        }
                      }
                    }
                  }
                }
              }
            }
#line 293
            d -= 2L;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 321
          if (best > 0L) {
#line 323
            part->lo_minimal = (_Bool)1;
#line 324
            part->hi_minimal = (_Bool)0;
#line 325
            return;
          }
#line 330
          best___0 = (lin )0;
#line 332
          d = bmax;
          {
#line 332
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 332
            if (! (d >= bmin)) {
#line 332
              goto while_break___6;
            }
#line 334
            dd___0 = d - bmid;
#line 335
            x___2 = *(bd + d);
#line 336
            y___2 = x___2 - d;
#line 337
            v___0 = (xlim - x___2) * 2L + dd___0;
#line 339
            if (dd___0 < 0L) {
#line 339
              tmp___8 = - dd___0;
            } else {
#line 339
              tmp___8 = dd___0;
            }
#line 339
            if (v___0 > 12L * (c + tmp___8)) {
#line 341
              if (v___0 > best___0) {
#line 341
                if (xoff < x___2) {
#line 341
                  if (x___2 <= xlim - 20L) {
#line 341
                    if (yoff < y___2) {
#line 341
                      if (y___2 <= ylim - 20L) {
#line 349
                        k___0 = 0;
                        {
#line 349
                        while (1) {
                          while_continue___7: /* CIL Label */ ;
                          {
#line 349
                          tmp___7 = context_matches_file(x___2 + (lin )k___0, y___2 + (lin )k___0);
                          }
#line 349
                          if (! tmp___7) {
#line 349
                            goto while_break___7;
                          }
#line 350
                          if (k___0 == 19) {
#line 352
                            best___0 = v___0;
#line 353
                            part->xmid = x___2;
#line 354
                            part->ymid = y___2;
#line 355
                            goto while_break___7;
                          }
#line 349
                          k___0 ++;
                        }
                        while_break___7: /* CIL Label */ ;
                        }
                      }
                    }
                  }
                }
              }
            }
#line 332
            d -= 2L;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 360
          if (best___0 > 0L) {
#line 362
            part->lo_minimal = (_Bool)0;
#line 363
            part->hi_minimal = (_Bool)1;
#line 364
            return;
          }
        }
      }
    }
#line 372
    if (c >= ctxt->too_expensive) {
#line 380
      fxybest = (lin )-1;
#line 381
      d = fmax;
      {
#line 381
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 381
        if (! (d >= fmin)) {
#line 381
          goto while_break___8;
        }
#line 383
        if (*(fd + d) < xlim) {
#line 383
          tmp___9 = *(fd + d);
        } else {
#line 383
          tmp___9 = xlim;
        }
#line 383
        x___3 = tmp___9;
#line 384
        y___3 = x___3 - d;
#line 385
        if (ylim < y___3) {
#line 387
          x___3 = ylim + d;
#line 388
          y___3 = ylim;
        }
#line 390
        if (fxybest < x___3 + y___3) {
#line 392
          fxybest = x___3 + y___3;
#line 393
          fxbest = x___3;
        }
#line 381
        d -= 2L;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 398
      bxybest = ((1L << (sizeof(lin ) * 8UL - 2UL)) - 1L) * 2L + 1L;
#line 399
      d = bmax;
      {
#line 399
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 399
        if (! (d >= bmin)) {
#line 399
          goto while_break___9;
        }
#line 401
        if (xoff > *(bd + d)) {
#line 401
          tmp___10 = xoff;
        } else {
#line 401
          tmp___10 = *(bd + d);
        }
#line 401
        x___4 = tmp___10;
#line 402
        y___4 = x___4 - d;
#line 403
        if (y___4 < yoff) {
#line 405
          x___4 = yoff + d;
#line 406
          y___4 = yoff;
        }
#line 408
        if (x___4 + y___4 < bxybest) {
#line 410
          bxybest = x___4 + y___4;
#line 411
          bxbest = x___4;
        }
#line 399
        d -= 2L;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 416
      if ((xlim + ylim) - bxybest < fxybest - (xoff + yoff)) {
#line 418
        part->xmid = fxbest;
#line 419
        part->ymid = fxybest - fxbest;
#line 420
        part->lo_minimal = (_Bool)1;
#line 421
        part->hi_minimal = (_Bool)0;
      } else {
#line 425
        part->xmid = bxbest;
#line 426
        part->ymid = bxybest - bxbest;
#line 427
        part->lo_minimal = (_Bool)0;
#line 428
        part->hi_minimal = (_Bool)1;
      }
#line 430
      return;
    }
    __Cont___1: /* CIL Label */ 
#line 205
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 453 "../lib/diffseq.h"
static _Bool compareseq(lin xoff , lin xlim , lin yoff , lin ylim , _Bool find_minimal ,
                        struct context *ctxt ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  struct partition part ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  void *__cil_tmp12 ;

  {
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (xoff < xlim) {
#line 466
      if (yoff < ylim) {
        {
#line 466
        tmp = context_matches_file(xoff, yoff);
        }
#line 466
        if (! tmp) {
#line 466
          goto while_break;
        }
      } else {
#line 466
        goto while_break;
      }
    } else {
#line 466
      goto while_break;
    }
#line 468
    xoff ++;
#line 469
    yoff ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 473
    if (xoff < xlim) {
#line 473
      if (yoff < ylim) {
        {
#line 473
        tmp___0 = context_matches_file(xlim - 1L, ylim - 1L);
        }
#line 473
        if (! tmp___0) {
#line 473
          goto while_break___0;
        }
      } else {
#line 473
        goto while_break___0;
      }
    } else {
#line 473
      goto while_break___0;
    }
#line 475
    xlim --;
#line 476
    ylim --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 480
  if (xoff == xlim) {
    {
#line 481
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 481
      if (! (yoff < ylim)) {
#line 481
        goto while_break___1;
      }
#line 483
      *(ctxt->ychar + yoff) = (char )'+';
#line 486
      yoff ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 488
  if (yoff == ylim) {
    {
#line 489
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 489
      if (! (xoff < xlim)) {
#line 489
        goto while_break___2;
      }
#line 491
      *(ctxt->xchar + xoff) = (char )'-';
#line 494
      xoff ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 501
    diag(xoff, xlim, yoff, ylim, find_minimal, & part, ctxt);
#line 504
    tmp___1 = compareseq(xoff, part.xmid, yoff, part.ymid, part.lo_minimal, ctxt);
    }
#line 504
    if (tmp___1) {
#line 505
      return ((_Bool)1);
    }
    {
#line 506
    tmp___2 = compareseq(part.xmid, xlim, part.ymid, ylim, part.hi_minimal, ctxt);
    }
#line 506
    if (tmp___2) {
#line 507
      return ((_Bool)1);
    }
  }
#line 510
  return ((_Bool)0);
}
}
#line 45 "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c"
static lin locate_merge(lin *matched ) 
{ 
  lin first_guess ;
  lin tmp ;
  lin pat_lines ;
  lin tmp___0 ;
  lin context_lines ;
  lin tmp___1 ;
  lin max_where ;
  lin min_where ;
  lin max_pos_offset ;
  lin max_neg_offset ;
  lin max_offset ;
  lin tmp___2 ;
  lin where ;
  lin max_matched ;
  lin min ;
  lin max ;
  lin offset ;
  _Bool match_until_eof ;
  char numbuf0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp___3 ;
  char *tmp___4 ;
  lin tmp___5 ;
  lin tmp___6 ;
  lin tmp___7 ;
  lin guess ;
  lin last ;
  lin changes ;
  lin tmp___8 ;
  lin guess___0 ;
  lin last___0 ;
  lin changes___0 ;
  lin tmp___9 ;
  char numbuf0___0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1___0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf2[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
#line 48
  tmp = pch_first();
#line 48
  first_guess = tmp + in_offset;
#line 49
  tmp___0 = pch_ptrn_lines();
#line 49
  pat_lines = tmp___0;
#line 50
  tmp___1 = count_context_lines();
#line 50
  context_lines = tmp___1;
#line 51
  max_where = ((input_lines - pat_lines) + context_lines) + 1L;
#line 52
  min_where = last_frozen_line + 1L;
#line 53
  max_pos_offset = max_where - first_guess;
#line 54
  max_neg_offset = first_guess - min_where;
  }
#line 55
  if (max_pos_offset < max_neg_offset) {
#line 55
    tmp___2 = max_neg_offset;
  } else {
#line 55
    tmp___2 = max_pos_offset;
  }
#line 55
  max_offset = tmp___2;
#line 57
  where = first_guess;
#line 57
  max_matched = (lin )0;
#line 68
  if (context_lines == 0L) {
#line 69
    goto out;
  }
#line 73
  max = 2L * context_lines;
#line 74
  min = pat_lines - context_lines;
#line 76
  if (debug & 1) {
    {
#line 80
    tmp___3 = format_linenum((char *)(numbuf1), max);
#line 80
    tmp___4 = format_linenum((char *)(numbuf0), min);
#line 80
    say("locating merge: min=%s max=%s ", tmp___4, tmp___3);
    }
  }
  {
#line 87
  tmp___5 = pch_suffix_context();
#line 87
  tmp___6 = pch_prefix_context();
#line 87
  offset = tmp___5 - tmp___6;
  }
#line 88
  if (offset > 0L) {
    {
#line 88
    tmp___7 = pch_first();
    }
#line 88
    if (tmp___7 <= 1L) {
#line 89
      max_pos_offset = (lin )0;
    }
  }
#line 90
  match_until_eof = (_Bool )(offset < 0L);
#line 93
  if (first_guess <= max_neg_offset) {
#line 94
    max_neg_offset = first_guess - 1L;
  }
#line 96
  offset = (lin )0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (offset <= max_offset)) {
#line 96
      goto while_break;
    }
#line 98
    if (offset <= max_pos_offset) {
#line 100
      guess = first_guess + offset;
#line 104
      if (match_until_eof) {
#line 104
        tmp___8 = (input_lines - guess) + 1L;
      } else {
#line 104
        tmp___8 = min;
      }
      {
#line 104
      changes = bestmatch((lin )1, pat_lines + 1L, guess, input_lines + 1L, tmp___8,
                          max, & last);
      }
#line 107
      if (changes <= max) {
#line 107
        if (max_matched < last - guess) {
#line 109
          max_matched = last - guess;
#line 110
          where = guess;
#line 111
          if (changes == 0L) {
#line 112
            goto while_break;
          }
#line 113
          min = last - guess;
#line 114
          max = changes - 1L;
        }
      }
    }
#line 117
    if (0L < offset) {
#line 117
      if (offset <= max_neg_offset) {
#line 119
        guess___0 = first_guess - offset;
#line 123
        if (match_until_eof) {
#line 123
          tmp___9 = (input_lines - guess___0) + 1L;
        } else {
#line 123
          tmp___9 = min;
        }
        {
#line 123
        changes___0 = bestmatch((lin )1, pat_lines + 1L, guess___0, input_lines + 1L,
                                tmp___9, max, & last___0);
        }
#line 126
        if (changes___0 <= max) {
#line 126
          if (max_matched < last___0 - guess___0) {
#line 128
            max_matched = last___0 - guess___0;
#line 129
            where = guess___0;
#line 130
            if (changes___0 == 0L) {
#line 131
              goto while_break;
            }
#line 132
            min = last___0 - guess___0;
#line 133
            max = changes___0 - 1L;
          }
        }
      }
    }
#line 96
    offset ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if (debug & 1) {
    {
#line 142
    tmp___10 = format_linenum((char *)(numbuf2), max + 1L);
#line 142
    tmp___11 = format_linenum((char *)(numbuf1___0), max_matched);
#line 142
    tmp___12 = format_linenum((char *)(numbuf0___0), where);
#line 142
    say("where=%s matched=%s changes=%s\n", tmp___12, tmp___11, tmp___10);
    }
  }
  out: 
#line 149
  *matched = max_matched;
#line 150
  if (where < min_where) {
#line 151
    where = min_where;
  }
#line 152
  return (where);
}
}
#line 155 "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c"
static void print_linerange(lin from , lin to ) 
{ 
  char numbuf0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 161
  if (to <= from) {
    {
#line 162
    tmp = format_linenum((char *)(numbuf0), from);
#line 162
    printf((char const   */* __restrict  */)"%s", tmp);
    }
  } else {
    {
#line 165
    tmp___0 = format_linenum((char *)(numbuf1), to);
#line 165
    tmp___1 = format_linenum((char *)(numbuf0), from);
#line 165
    printf((char const   */* __restrict  */)"%s-%s", tmp___1, tmp___0);
    }
  }
#line 168
  return;
}
}
#line 173 "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c"
static char const   *last_what  ;
#line 170 "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c"
static void merge_result(_Bool *first_result , int hunk , char const   *what , lin from ,
                         lin to ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 175
  if (*first_result) {
#line 175
    if (what) {
      {
#line 177
      printf((char const   */* __restrict  */)"Hunk #%d %s at ", hunk, what);
#line 178
      last_what = what;
      }
    } else {
#line 175
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 180
  if (! what) {
#line 182
    if (! *first_result) {
      {
#line 184
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stdout);
#line 185
      fflush(stdout);
#line 186
      last_what = (char const   *)0;
      }
    }
#line 188
    return;
  } else
#line 190
  if ((unsigned long )last_what == (unsigned long )what) {
    {
#line 191
    fputs((char const   */* __restrict  */)",", (FILE */* __restrict  */)stdout);
    }
  } else {
    {
#line 193
    printf((char const   */* __restrict  */)", %s at ", what);
    }
  }
  {
#line 194
  print_linerange(from + out_offset, to + out_offset);
#line 195
  *first_result = (_Bool)0;
  }
#line 196
  return;
}
}
#line 198 "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c"
_Bool merge_hunk(int hunk , struct outstate *outstate , lin where , _Bool *somefailed ) 
{ 
  _Bool applies_cleanly ;
  _Bool first_result ;
  _Bool already_applied ;
  FILE *fp ;
  lin old ;
  lin firstold ;
  lin tmp ;
  lin new ;
  lin firstnew ;
  lin tmp___0 ;
  lin in ;
  lin firstin ;
  char *oldin ;
  lin matched ;
  lin lastwhere ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  void *tmp___4 ;
  char numbuf0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  lin n ;
  char *tmp___5 ;
  lin tmp___6 ;
  char *tmp___7 ;
  lin tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t size ;
  char const   *line ;
  _Bool tmp___14 ;
  lin lines ;
  char tmp___15 ;
  char tmp___16 ;
  char tmp___17 ;
  char tmp___18 ;
  char tmp___19 ;
  char tmp___20 ;
  char tmp___21 ;
  _Bool tmp___22 ;
  char tmp___23 ;
  char tmp___24 ;
  _Bool tmp___25 ;
  char tmp___26 ;
  char tmp___27 ;
  char tmp___28 ;
  char tmp___29 ;
  char tmp___30 ;
  char tmp___31 ;
  char tmp___32 ;
  char tmp___33 ;
  char tmp___34 ;
  char tmp___35 ;
  char tmp___36 ;
  char tmp___37 ;
  char tmp___38 ;
  char tmp___39 ;
  char tmp___40 ;
  _Bool tmp___41 ;
  int tmp___42 ;
  lin common_prefix ;
  _Bool tmp___43 ;
  lin common_suffix ;
  lin lines___0 ;
  _Bool tmp___44 ;
  _Bool tmp___45 ;
  int tmp___46 ;
  _Bool tmp___47 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;

  {
  {
#line 202
  first_result = (_Bool)1;
#line 204
  fp = outstate->ofp;
#line 205
  old = (lin )1;
#line 206
  tmp = pch_ptrn_lines();
#line 206
  firstold = tmp;
#line 207
  new = firstold + 1L;
#line 208
  tmp___0 = pch_end();
#line 208
  firstnew = tmp___0;
#line 216
  pch_normalize((enum diff )5);
#line 218
  tmp___1 = pch_char(firstnew + 1L);
  }
#line 218
  if (! ((int )tmp___1 == 94)) {
    {
#line 218
    __assert_fail("pch_char (firstnew + 1) == \'^\'", "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c",
                  218U, "merge_hunk");
    }
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 219
    tmp___2 = pch_char(new);
    }
#line 219
    if (! ((int )tmp___2 == 61)) {
      {
#line 219
      tmp___3 = pch_char(new);
      }
#line 219
      if (! ((int )tmp___3 == 10)) {
#line 219
        goto while_break;
      }
    }
#line 220
    new ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (where) {
    {
#line 224
    applies_cleanly = (_Bool)1;
#line 225
    matched = pch_ptrn_lines();
    }
  } else {
    {
#line 229
    where = locate_merge(& matched);
#line 230
    applies_cleanly = (_Bool)0;
    }
  }
  {
#line 233
  in = firstold + 2L;
#line 234
  tmp___4 = xmalloc((size_t )((in + matched) + 1L));
#line 234
  oldin = (char *)tmp___4;
#line 235
  memset((void *)oldin, ' ', (size_t )(in + matched));
#line 236
  *(oldin + 0) = (char )'*';
#line 237
  *(oldin + (in - 1L)) = (char )'=';
#line 238
  *(oldin + (in + matched)) = (char )'^';
#line 239
  compute_changes(old, in - 1L, where, where + matched, oldin + old, oldin + in);
  }
#line 242
  if (debug & 2) {
    {
#line 248
    fputc('\n', stderr);
#line 249
    n = (lin )0;
    }
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if (! (n <= in + matched)) {
#line 249
        goto while_break___0;
      }
      {
#line 251
      tmp___5 = format_linenum((char *)(numbuf0), n);
#line 251
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %c",
              tmp___5, (int )*(oldin + n));
      }
#line 254
      if (n == 0L) {
        {
#line 255
        tmp___6 = pch_ptrn_lines();
#line 255
        tmp___7 = format_linenum((char *)(numbuf1), tmp___6);
#line 255
        tmp___8 = pch_first();
#line 255
        tmp___9 = format_linenum((char *)(numbuf0), tmp___8);
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s,%s\n",
                tmp___9, tmp___7);
        }
      } else
#line 258
      if (n <= firstold) {
        {
#line 259
        tmp___10 = pfetch(n);
#line 259
        tmp___11 = pch_line_len(n);
#line 259
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" |%.*s",
                (int )tmp___11, tmp___10);
        }
      } else
#line 261
      if (n == in - 1L) {
        {
#line 262
        tmp___12 = format_linenum((char *)(numbuf1), matched);
#line 262
        tmp___13 = format_linenum((char *)(numbuf0), where);
#line 262
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s,%s\n",
                tmp___13, tmp___12);
        }
      } else
#line 265
      if (n >= in) {
#line 265
        if (n < in + matched) {
          {
#line 270
          line = ifetch((where + n) - in, (_Bool)0, & size);
#line 271
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" |%.*s",
                  (int )size, line);
          }
        } else {
          {
#line 275
          fputc('\n', stderr);
          }
        }
      } else {
        {
#line 275
        fputc('\n', stderr);
        }
      }
#line 249
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 277
    fflush(stderr);
    }
  }
#line 280
  if (last_frozen_line < where - 1L) {
    {
#line 281
    tmp___14 = copy_till(outstate, where - 1L);
    }
#line 281
    if (! tmp___14) {
#line 282
      return ((_Bool)0);
    }
  }
  {
#line 284
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 286
    firstold = old;
#line 287
    firstnew = new;
#line 288
    firstin = in;
#line 290
    tmp___29 = pch_char(old);
    }
#line 290
    if ((int )tmp___29 == 45) {
#line 290
      goto _L;
    } else {
      {
#line 290
      tmp___30 = pch_char(new);
      }
#line 290
      if ((int )tmp___30 == 43) {
        _L: /* CIL Label */ 
        {
#line 294
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 294
          tmp___15 = pch_char(old);
          }
#line 294
          if (! ((int )tmp___15 == 45)) {
#line 294
            goto while_break___2;
          }
#line 296
          if ((int )*(oldin + old) == 45) {
#line 297
            goto conflict;
          } else
#line 296
          if ((int )*(oldin + in) == 43) {
#line 297
            goto conflict;
          } else
#line 298
          if ((int )*(oldin + old) == 32) {
#line 300
            if (! ((int )*(oldin + in) == 32)) {
              {
#line 300
              __assert_fail("oldin[in] == \' \'", "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c",
                            300U, "merge_hunk");
              }
            }
#line 301
            in ++;
          }
#line 303
          old ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 305
        if ((int )*(oldin + old) == 45) {
#line 306
          goto conflict;
        } else
#line 305
        if ((int )*(oldin + in) == 43) {
#line 306
          goto conflict;
        }
        {
#line 307
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 307
          tmp___16 = pch_char(new);
          }
#line 307
          if (! ((int )tmp___16 == 43)) {
#line 307
            goto while_break___3;
          }
#line 308
          new ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 310
        lines = new - firstnew;
#line 311
        if ((unsigned int )verbosity == 2U) {
          {
#line 313
          merge_result(& first_result, hunk, "merged", where, (where + lines) - 1L);
          }
        } else
#line 311
        if ((unsigned int )verbosity != 1U) {
#line 311
          if (! applies_cleanly) {
            {
#line 313
            merge_result(& first_result, hunk, "merged", where, (where + lines) - 1L);
            }
          }
        }
#line 315
        last_frozen_line += old - firstold;
#line 316
        where += old - firstold;
#line 317
        out_offset += new - firstnew;
#line 319
        if (firstnew < new) {
          {
#line 321
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 321
            if (! (firstnew < new)) {
#line 321
              goto while_break___4;
            }
            {
#line 323
            outstate->after_newline = pch_write_line(firstnew, fp);
#line 324
            firstnew ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 326
          outstate->zero_output = (_Bool)0;
        }
      } else {
        {
#line 329
        tmp___28 = pch_char(old);
        }
#line 329
        if ((int )tmp___28 == 32) {
#line 331
          if ((int )*(oldin + old) == 45) {
            {
#line 333
            while (1) {
              while_continue___5: /* CIL Label */ ;
              {
#line 333
              tmp___19 = pch_char(old);
              }
#line 333
              if (! ((int )tmp___19 == 32)) {
#line 333
                goto while_break___5;
              }
#line 335
              if ((int )*(oldin + old) != 45) {
#line 336
                goto while_break___5;
              }
              {
#line 337
              tmp___18 = pch_char(new);
              }
#line 337
              if ((int )tmp___18 == 43) {
#line 338
                goto conflict;
              } else {
                {
#line 340
                tmp___17 = pch_char(new);
                }
#line 340
                if (! ((int )tmp___17 == 32)) {
                  {
#line 340
                  __assert_fail("pch_char (new) == \' \'", "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c",
                                340U, "merge_hunk");
                  }
                }
              }
#line 341
              old ++;
#line 342
              new ++;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 344
            tmp___20 = pch_char(old);
            }
#line 344
            if ((int )tmp___20 == 45) {
#line 345
              goto conflict;
            } else {
              {
#line 344
              tmp___21 = pch_char(new);
              }
#line 344
              if ((int )tmp___21 == 43) {
#line 345
                goto conflict;
              }
            }
          } else
#line 347
          if ((int )*(oldin + in) == 43) {
            {
#line 349
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 349
              if (! ((int )*(oldin + in) == 43)) {
#line 349
                goto while_break___6;
              }
#line 350
              in ++;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 353
            where += in - firstin;
#line 354
            tmp___22 = copy_till(outstate, where - 1L);
            }
#line 354
            if (! tmp___22) {
#line 355
              return ((_Bool)0);
            }
          } else
#line 357
          if ((int )*(oldin + old) == 32) {
            {
#line 359
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 359
              tmp___23 = pch_char(old);
              }
#line 359
              if ((int )tmp___23 == 32) {
#line 359
                if ((int )*(oldin + old) == 32) {
                  {
#line 359
                  tmp___24 = pch_char(new);
                  }
#line 359
                  if ((int )tmp___24 == 32) {
#line 359
                    if (! ((int )*(oldin + in) == 32)) {
#line 359
                      goto while_break___7;
                    }
                  } else {
#line 359
                    goto while_break___7;
                  }
                } else {
#line 359
                  goto while_break___7;
                }
              } else {
#line 359
                goto while_break___7;
              }
#line 364
              old ++;
#line 365
              new ++;
#line 366
              in ++;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 370
            where += in - firstin;
#line 371
            tmp___25 = copy_till(outstate, where - 1L);
            }
#line 371
            if (! tmp___25) {
#line 372
              return ((_Bool)0);
            }
          }
        } else {
          {
#line 377
          tmp___26 = pch_char(old);
          }
#line 377
          if ((int )tmp___26 == 61) {
            {
#line 377
            tmp___27 = pch_char(new);
            }
#line 377
            if (! ((int )tmp___27 == 94)) {
              {
#line 377
              __assert_fail("pch_char (old) == \'=\' && pch_char (new) == \'^\'",
                            "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c", 377U,
                            "merge_hunk");
              }
            }
          } else {
            {
#line 377
            __assert_fail("pch_char (old) == \'=\' && pch_char (new) == \'^\'", "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c",
                          377U, "merge_hunk");
            }
          }
#line 379
          goto while_break___1;
        }
      }
    }
#line 381
    goto __Cont;
    conflict: 
    {
#line 385
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 387
      tmp___36 = pch_char(old);
      }
#line 387
      if ((int )tmp___36 == 45) {
        {
#line 389
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 389
          if (! ((int )*(oldin + in) == 43)) {
#line 389
            goto while_break___9;
          }
#line 390
          in ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 391
        if ((int )*(oldin + old) == 32) {
#line 393
          if (! ((int )*(oldin + in) == 32)) {
            {
#line 393
            __assert_fail("oldin[in] == \' \'", "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c",
                          393U, "merge_hunk");
            }
          }
#line 394
          in ++;
        }
#line 396
        old ++;
      } else
#line 398
      if ((int )*(oldin + old) == 45) {
        {
#line 400
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 400
          tmp___31 = pch_char(new);
          }
#line 400
          if (! ((int )tmp___31 == 43)) {
#line 400
            goto while_break___10;
          }
#line 401
          new ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 402
        tmp___33 = pch_char(old);
        }
#line 402
        if ((int )tmp___33 == 32) {
          {
#line 404
          tmp___32 = pch_char(new);
          }
#line 404
          if (! ((int )tmp___32 == 32)) {
            {
#line 404
            __assert_fail("pch_char (new) == \' \'", "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c",
                          404U, "merge_hunk");
            }
          }
#line 405
          new ++;
        }
#line 407
        old ++;
      } else {
        {
#line 409
        tmp___35 = pch_char(new);
        }
#line 409
        if ((int )tmp___35 == 43) {
          {
#line 410
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 410
            tmp___34 = pch_char(new);
            }
#line 410
            if (! ((int )tmp___34 == 43)) {
#line 410
              goto while_break___11;
            }
#line 411
            new ++;
          }
          while_break___11: /* CIL Label */ ;
          }
        } else
#line 412
        if ((int )*(oldin + in) == 43) {
          {
#line 413
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 413
            if (! ((int )*(oldin + in) == 43)) {
#line 413
              goto while_break___12;
            }
#line 414
            in ++;
          }
          while_break___12: /* CIL Label */ ;
          }
        } else {
#line 416
          goto while_break___8;
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 418
    tmp___37 = pch_char(old);
    }
#line 418
    if ((int )tmp___37 == 32) {
      {
#line 418
      tmp___38 = pch_char(new);
      }
#line 418
      if ((int )tmp___38 == 32) {
#line 418
        goto _L___1;
      } else {
#line 418
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 418
      tmp___39 = pch_char(old);
      }
#line 418
      if ((int )tmp___39 == 61) {
        {
#line 418
        tmp___40 = pch_char(new);
        }
#line 418
        if ((int )tmp___40 == 94) {
          _L___1: /* CIL Label */ 
#line 418
          if ((int )*(oldin + old) == 32) {
#line 418
            if (! ((int )*(oldin + in) == 32)) {
#line 418
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 418
          if ((int )*(oldin + old) == 61) {
#line 418
            if (! ((int )*(oldin + in) == 94)) {
              {
#line 418
              __assert_fail("((pch_char (old) == \' \' && pch_char (new) == \' \') || (pch_char (old) == \'=\' && pch_char (new) == \'^\')) && ((oldin[old] == \' \' && oldin[in] == \' \') || (oldin[old] == \'=\' && oldin[in] == \'^\'))",
                            "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c", 421U,
                            "merge_hunk");
              }
            }
          } else {
            {
#line 418
            __assert_fail("((pch_char (old) == \' \' && pch_char (new) == \' \') || (pch_char (old) == \'=\' && pch_char (new) == \'^\')) && ((oldin[old] == \' \' && oldin[in] == \' \') || (oldin[old] == \'=\' && oldin[in] == \'^\'))",
                          "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c", 421U,
                          "merge_hunk");
            }
          }
        } else {
          {
#line 418
          __assert_fail("((pch_char (old) == \' \' && pch_char (new) == \' \') || (pch_char (old) == \'=\' && pch_char (new) == \'^\')) && ((oldin[old] == \' \' && oldin[in] == \' \') || (oldin[old] == \'=\' && oldin[in] == \'^\'))",
                        "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c", 421U,
                        "merge_hunk");
          }
        }
      } else {
        {
#line 418
        __assert_fail("((pch_char (old) == \' \' && pch_char (new) == \' \') || (pch_char (old) == \'=\' && pch_char (new) == \'^\')) && ((oldin[old] == \' \' && oldin[in] == \' \') || (oldin[old] == \'=\' && oldin[in] == \'^\'))",
                      "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c", 421U, "merge_hunk");
        }
      }
    }
#line 424
    lastwhere = where;
    {
#line 424
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 424
      if (firstin < in) {
#line 424
        if (firstnew < new) {
          {
#line 424
          tmp___41 = context_matches_file(firstnew, lastwhere);
          }
#line 424
          if (! tmp___41) {
#line 424
            goto while_break___13;
          }
        } else {
#line 424
          goto while_break___13;
        }
      } else {
#line 424
        goto while_break___13;
      }
#line 424
      firstin ++;
#line 424
      firstnew ++;
#line 424
      lastwhere ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 429
    if (firstin == in) {
#line 429
      if (firstnew == new) {
#line 429
        tmp___42 = 1;
      } else {
#line 429
        tmp___42 = 0;
      }
    } else {
#line 429
      tmp___42 = 0;
    }
#line 429
    already_applied = (_Bool )tmp___42;
#line 430
    if (already_applied) {
      {
#line 431
      merge_result(& first_result, hunk, "already applied", where, lastwhere - 1L);
      }
    }
#line 433
    if ((unsigned int )conflict_style == 1U) {
#line 435
      common_prefix = lastwhere - where;
#line 438
      firstin -= common_prefix;
#line 439
      firstnew -= common_prefix;
#line 440
      lastwhere -= common_prefix;
    }
#line 442
    if (where != lastwhere) {
      {
#line 444
      where = lastwhere;
#line 445
      tmp___43 = copy_till(outstate, where - 1L);
      }
#line 445
      if (! tmp___43) {
#line 446
        return ((_Bool)0);
      }
    }
#line 449
    if (! already_applied) {
#line 451
      common_suffix = (lin )0;
#line 454
      if ((unsigned int )conflict_style == 0U) {
#line 457
        lastwhere = where + (in - firstin);
        {
#line 457
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 457
          if (firstin < in) {
#line 457
            if (firstnew < new) {
              {
#line 457
              tmp___44 = context_matches_file(new - 1L, lastwhere - 1L);
              }
#line 457
              if (! tmp___44) {
#line 457
                goto while_break___14;
              }
            } else {
#line 457
              goto while_break___14;
            }
          } else {
#line 457
            goto while_break___14;
          }
#line 457
          in --;
#line 457
          new --;
#line 457
          lastwhere --;
#line 457
          common_suffix ++;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
#line 464
      lines___0 = (3L + (in - firstin)) + (new - firstnew);
#line 465
      if ((unsigned int )conflict_style == 1U) {
#line 466
        lines___0 += 1L + (old - firstold);
      }
      {
#line 467
      merge_result(& first_result, hunk, "NOT MERGED", where, (where + lines___0) - 1L);
#line 469
      out_offset += lines___0 - (in - firstin);
#line 471
      fputs((char const   */* __restrict  */)("\n<<<<<<<\n" + (int )outstate->after_newline),
            (FILE */* __restrict  */)fp);
#line 472
      outstate->after_newline = (_Bool)1;
      }
#line 473
      if (firstin < in) {
        {
#line 475
        where += in - firstin;
#line 476
        tmp___45 = copy_till(outstate, where - 1L);
        }
#line 476
        if (! tmp___45) {
#line 477
          return ((_Bool)0);
        }
      }
#line 480
      if ((unsigned int )conflict_style == 1U) {
        {
#line 482
        fputs((char const   */* __restrict  */)("\n|||||||\n" + (int )outstate->after_newline),
              (FILE */* __restrict  */)fp);
#line 483
        outstate->after_newline = (_Bool)1;
        }
        {
#line 484
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 484
          if (! (firstold < old)) {
#line 484
            goto while_break___15;
          }
          {
#line 486
          outstate->after_newline = pch_write_line(firstold, fp);
#line 487
          firstold ++;
          }
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      {
#line 491
      fputs((char const   */* __restrict  */)("\n=======\n" + (int )outstate->after_newline),
            (FILE */* __restrict  */)fp);
#line 492
      outstate->after_newline = (_Bool)1;
      }
      {
#line 493
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 493
        if (! (firstnew < new)) {
#line 493
          goto while_break___16;
        }
        {
#line 495
        outstate->after_newline = pch_write_line(firstnew, fp);
#line 496
        firstnew ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 498
      fputs((char const   */* __restrict  */)("\n>>>>>>>\n" + (int )outstate->after_newline),
            (FILE */* __restrict  */)fp);
#line 499
      outstate->after_newline = (_Bool)1;
#line 500
      outstate->zero_output = (_Bool)0;
#line 501
      tmp___46 = ferror(fp);
      }
#line 501
      if (tmp___46) {
        {
#line 502
        write_fatal();
        }
      }
#line 505
      if (common_suffix) {
        {
#line 507
        where += common_suffix;
#line 508
        tmp___47 = copy_till(outstate, where - 1L);
        }
#line 508
        if (! tmp___47) {
#line 509
          return ((_Bool)0);
        }
#line 510
        in += common_suffix;
#line 511
        new += common_suffix;
      }
#line 513
      *somefailed = (_Bool)1;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 516
  merge_result(& first_result, 0, (char const   *)0, (lin )0, (lin )0);
  }
#line 518
  if (! (last_frozen_line == where - 1L)) {
    {
#line 518
    __assert_fail("last_frozen_line == where - 1", "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c",
                  518U, "merge_hunk");
    }
  }
  {
#line 519
  free((void *)oldin);
  }
#line 520
  return ((_Bool)1);
}
}
#line 523 "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c"
static lin count_context_lines(void) 
{ 
  lin old ;
  lin lastold ;
  lin tmp ;
  lin context ;
  char tmp___0 ;

  {
  {
#line 527
  tmp = pch_ptrn_lines();
#line 527
  lastold = tmp;
#line 530
  context = (lin )0;
#line 530
  old = (lin )1;
  }
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! (old <= lastold)) {
#line 530
      goto while_break;
    }
    {
#line 531
    tmp___0 = pch_char(old);
    }
#line 531
    if ((int )tmp___0 == 32) {
#line 532
      context ++;
    }
#line 530
    old ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  return (context);
}
}
#line 536 "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c"
static _Bool context_matches_file(lin old , lin where ) 
{ 
  size_t size ;
  char const   *line ;
  size_t tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 542
  line = ifetch(where, (_Bool)0, & size);
  }
#line 543
  if (size) {
#line 543
    if (canonicalize) {
      {
#line 543
      tmp = pch_line_len(old);
#line 543
      tmp___0 = pfetch(old);
#line 543
      tmp___1 = similar((char const   *)tmp___0, tmp, line, size);
#line 543
      tmp___6 = (int )tmp___1;
      }
    } else {
      {
#line 543
      tmp___2 = pch_line_len(old);
      }
#line 543
      if (size == tmp___2) {
        {
#line 543
        tmp___3 = pfetch(old);
#line 543
        tmp___4 = memcmp((void const   *)line, (void const   *)tmp___3, size);
        }
#line 543
        if (tmp___4 == 0) {
#line 543
          tmp___5 = 1;
        } else {
#line 543
          tmp___5 = 0;
        }
      } else {
#line 543
        tmp___5 = 0;
      }
#line 543
      tmp___6 = tmp___5;
    }
#line 543
    if (tmp___6) {
#line 543
      tmp___7 = 1;
    } else {
#line 543
      tmp___7 = 0;
    }
  } else {
#line 543
    tmp___7 = 0;
  }
#line 543
  return ((_Bool )tmp___7);
}
}
#line 550 "/home/wslee/gnu_benchmarks/patch-2.7/src/merge.c"
static void compute_changes(lin xmin , lin xmax___0 , lin ymin , lin ymax , char *xchar ,
                            char *ychar ) 
{ 
  struct context ctxt ;
  lin diags ;
  void *tmp ;
  void *__cil_tmp10 ;

  {
  {
#line 557
  ctxt.xchar = xchar - xmin;
#line 558
  ctxt.ychar = ychar - ymin;
#line 560
  diags = (xmax___0 + ymax) + 3L;
#line 561
  tmp = xmalloc((unsigned long )(2L * diags) * sizeof(*(ctxt.fdiag)));
#line 561
  ctxt.fdiag = (lin *)tmp;
#line 562
  ctxt.bdiag = ctxt.fdiag + diags;
#line 563
  ctxt.fdiag += ymax + 1L;
#line 564
  ctxt.bdiag += ymax + 1L;
#line 566
  ctxt.heuristic = (_Bool)1;
#line 567
  ctxt.too_expensive = xmax___0 + ymax;
#line 569
  compareseq(xmin, xmax___0, ymin, ymax, (_Bool)1, & ctxt);
#line 571
  ctxt.fdiag -= ymax + 1L;
#line 572
  free((void *)ctxt.fdiag);
  }
#line 573
  return;
}
}
#line 3 "./version.h"
void version(void) ;
#line 7 "/home/wslee/gnu_benchmarks/patch-2.7/src/version.c"
static char const   copyright_string[91]  = 
#line 7 "/home/wslee/gnu_benchmarks/patch-2.7/src/version.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'C', 
        (char const   )')',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'3',      (char const   )',',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'9', 
        (char const   )'-',      (char const   )'2',      (char const   )'0',      (char const   )'1', 
        (char const   )'2',      (char const   )' ',      (char const   )'F',      (char const   )'r', 
        (char const   )'e',      (char const   )'e',      (char const   )' ',      (char const   )'S', 
        (char const   )'o',      (char const   )'f',      (char const   )'t',      (char const   )'w', 
        (char const   )'a',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'F',      (char const   )'o',      (char const   )'u',      (char const   )'n', 
        (char const   )'d',      (char const   )'a',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )',',      (char const   )' ', 
        (char const   )'I',      (char const   )'n',      (char const   )'c',      (char const   )'.', 
        (char const   )'\n',      (char const   )'C',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'8',      (char const   )'8',      (char const   )' ', 
        (char const   )'L',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'y',      (char const   )' ',      (char const   )'W',      (char const   )'a', 
        (char const   )'l',      (char const   )'l',      (char const   )'\000'};
#line 11 "/home/wslee/gnu_benchmarks/patch-2.7/src/version.c"
static char const   free_software_msgid[200]  = 
#line 11
  {      (char const   )'L',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )' ', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'v', 
        (char const   )'3',      (char const   )'+',      (char const   )':',      (char const   )' ', 
        (char const   )'G',      (char const   )'N',      (char const   )'U',      (char const   )' ', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )' ', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'3',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'l',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'<', 
        (char const   )'h',      (char const   )'t',      (char const   )'t',      (char const   )'p', 
        (char const   )':',      (char const   )'/',      (char const   )'/',      (char const   )'g', 
        (char const   )'n',      (char const   )'u',      (char const   )'.',      (char const   )'o', 
        (char const   )'r',      (char const   )'g',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'n', 
        (char const   )'s',      (char const   )'e',      (char const   )'s',      (char const   )'/', 
        (char const   )'g',      (char const   )'p',      (char const   )'l',      (char const   )'.', 
        (char const   )'h',      (char const   )'t',      (char const   )'m',      (char const   )'l', 
        (char const   )'>',      (char const   )'.',      (char const   )'\n',      (char const   )'T', 
        (char const   )'h',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'f', 
        (char const   )'r',      (char const   )'e',      (char const   )'e',      (char const   )' ', 
        (char const   )'s',      (char const   )'o',      (char const   )'f',      (char const   )'t', 
        (char const   )'w',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )':',      (char const   )' ',      (char const   )'y',      (char const   )'o', 
        (char const   )'u',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'r', 
        (char const   )'e',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'n',      (char const   )'g',      (char const   )'e', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )'r', 
        (char const   )'i',      (char const   )'b',      (char const   )'u',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'i',      (char const   )'t', 
        (char const   )'.',      (char const   )'\n',      (char const   )'T',      (char const   )'h', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'N', 
        (char const   )'O',      (char const   )' ',      (char const   )'W',      (char const   )'A', 
        (char const   )'R',      (char const   )'R',      (char const   )'A',      (char const   )'N', 
        (char const   )'T',      (char const   )'Y',      (char const   )',',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'e', 
        (char const   )'x',      (char const   )'t',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )'m',      (char const   )'i',      (char const   )'t', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'l', 
        (char const   )'a',      (char const   )'w',      (char const   )'.',      (char const   )'\000'};
#line 16 "/home/wslee/gnu_benchmarks/patch-2.7/src/version.c"
static char const   authorship_msgid[38]  = 
#line 16
  {      (char const   )'W',      (char const   )'r',      (char const   )'i',      (char const   )'t', 
        (char const   )'t',      (char const   )'e',      (char const   )'n',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'L', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'W',      (char const   )'a',      (char const   )'l', 
        (char const   )'l',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'P',      (char const   )'a', 
        (char const   )'u',      (char const   )'l',      (char const   )' ',      (char const   )'E', 
        (char const   )'g',      (char const   )'g',      (char const   )'e',      (char const   )'r', 
        (char const   )'t',      (char const   )'\000'};
#line 19 "/home/wslee/gnu_benchmarks/patch-2.7/src/version.c"
void version(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 22
  printf((char const   */* __restrict  */)"%s %s\n%s\n\n%s\n\n%s\n", "GNU patch",
         "2.7", copyright_string, free_software_msgid, authorship_msgid);
  }
#line 24
  return;
}
}
#line 157 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 348
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 819
extern void perror(char const   *__s ) ;
#line 284 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 73 "./common.h"
char *buf ;
#line 74
size_t bufsize ;
#line 76
_Bool using_plan_a ;
#line 83
_Bool dry_run ;
#line 84
_Bool posixly_correct ;
#line 86
char const   *origprae ;
#line 87
char const   *origbase ;
#line 88
char const   *origsuff ;
#line 103
_Bool force ;
#line 104
_Bool batch ;
#line 105
_Bool noreverse ;
#line 106
_Bool reverse ;
#line 108
_Bool skip_rest_of_patch ;
#line 111
int patch_get ;
#line 112
_Bool set_time ;
#line 113
_Bool set_utc ;
#line 142
 __attribute__((__noreturn__)) void fatal_exit(int sig ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 712 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 357 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 479
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) lchown)(char const   *__file ,
                                                                                   __uid_t __owner ,
                                                                                   __gid_t __group ) ;
#line 695
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 701
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 795
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 819
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) symlink)(char const   *__from ,
                                                                                      char const   *__to ) ;
#line 825
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2))) readlink)(char const   * __restrict  __path ,
                                                                                           char * __restrict  __buf ,
                                                                                           size_t __len ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 851
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) rmdir)(char const   *__path ) ;
#line 118 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , __mode_t __mode ) ;
#line 32 "./util.h"
enum backup_type backup_type  ;
#line 34
_Bool ( /* format attribute */  ok_to_reverse)(char const   *format  , ...) ;
#line 35
void ( /* format attribute */  ask)(char const   *format  , ...) ;
#line 38
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *format 
                                                                     , ...) ;
#line 40
 __attribute__((__noreturn__)) void ( /* format attribute */  pfatal)(char const   *format 
                                                                      , ...) ;
#line 43
void fetchname(char const   *at , int strip_leading , char **pname , char **ptimestr ,
               struct timespec *pstamp ) ;
#line 44
char *parse_name(char const   *s , int strip_leading , char const   **endp ) ;
#line 45
char *savebuf(char const   *s , size_t size ) ;
#line 46
char *savestr(char const   *s ) ;
#line 47
char const   *version_controller(char const   *filename , _Bool readonly , struct stat  const  *filestat ,
                                 char **getbuf , char **diffbuf ) ;
#line 48
_Bool version_get(char const   *filename , char const   *cs , _Bool exists , _Bool readonly ,
                  char const   *getbuf , struct stat *filestat ) ;
#line 49
int create_file(char const   *file , int open_flags , mode_t mode , _Bool to_dir_known_to_exist ) ;
#line 50
int systemic(char const   *command ) ;
#line 52
void Fseek(FILE *stream , file_offset offset , int ptrname ) ;
#line 53
void copy_file(char const   *from , char const   *to , struct stat *tost , int to_flags ,
               mode_t mode , _Bool to_dir_known_to_exist ) ;
#line 54
void append_to_file(char const   *from , char const   *to ) ;
#line 55
 __attribute__((__noreturn__)) void exit_with_signal(int sig ) ;
#line 56
void ignore_signals(void) ;
#line 57
void init_backup_hash_table(void) ;
#line 58
void init_time(void) ;
#line 60
void create_backup(char const   *to , struct stat  const  *to_st , _Bool leave_original ) ;
#line 61
void move_file(char const   *from , int *from_needs_removal , struct stat  const  *fromst ,
               char const   *to , mode_t mode , _Bool backup ) ;
#line 62
 __attribute__((__noreturn__)) void read_fatal(void) ;
#line 63
void remove_prefix(char *p , size_t prefixlen ) ;
#line 64
void removedirs(char const   *name ) ;
#line 65
void set_signals(_Bool reset ) ;
#line 67
void insert_file_id(struct stat  const  *st , enum file_id_type type ) ;
#line 68
enum file_id_type lookup_file_id(struct stat  const  *st ) ;
#line 69
void set_queued_output(struct stat  const  *st , _Bool queued_output ) ;
#line 70
_Bool has_queued_output(struct stat  const  *st ) ;
#line 79
void set_file_attributes(char const   *to , enum file_attributes attr , char const   *from ,
                         struct stat  const  *st , mode_t mode , struct timespec *new_time ) ;
#line 90
int make_tempfile(char const   **name , char letter , char const   *real_name , int flags ,
                  mode_t mode ) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 138
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 222
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 228
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 255
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 266
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 54 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static void makedirs(char const   *name ) ;
#line 66 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static size_t file_id_hasher(void const   *entry , size_t table_size ) 
{ 
  file_id const   *e ;
  size_t i ;

  {
#line 69
  e = (file_id const   *)entry;
#line 70
  i = (size_t )(e->ino + e->dev);
#line 71
  return (i % table_size);
}
}
#line 76 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static _Bool file_id_comparator(void const   *entry1 , void const   *entry2 ) 
{ 
  file_id const   *e1 ;
  file_id const   *e2 ;
  int tmp ;

  {
#line 79
  e1 = (file_id const   *)entry1;
#line 80
  e2 = (file_id const   *)entry2;
#line 81
  if (e1->ino == e2->ino) {
#line 81
    if (e1->dev == e2->dev) {
#line 81
      tmp = 1;
    } else {
#line 81
      tmp = 0;
    }
  } else {
#line 81
    tmp = 0;
  }
#line 81
  return ((_Bool )tmp);
}
}
#line 84 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static Hash_table *file_id_table  ;
#line 88 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void init_backup_hash_table(void) 
{ 


  {
  {
#line 91
  file_id_table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0),
                                  & file_id_hasher, & file_id_comparator, & free);
  }
#line 93
  if (! file_id_table) {
    {
#line 94
    xalloc_die();
    }
  }
#line 95
  return;
}
}
#line 101 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static file_id *next_slot  ;
#line 97 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static file_id *__insert_file_id(struct stat  const  *st , enum file_id_type type ) 
{ 
  file_id *p ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 103
  if (! next_slot) {
    {
#line 104
    tmp = xmalloc(sizeof(*next_slot));
#line 104
    next_slot = (file_id *)tmp;
    }
  }
  {
#line 105
  next_slot->dev = (dev_t )st->st_dev;
#line 106
  next_slot->ino = (ino_t )st->st_ino;
#line 107
  next_slot->queued_output = (_Bool)0;
#line 108
  tmp___0 = hash_insert(file_id_table, (void const   *)next_slot);
#line 108
  p = (file_id *)tmp___0;
  }
#line 109
  if (! p) {
    {
#line 110
    xalloc_die();
    }
  }
#line 111
  if ((unsigned long )p == (unsigned long )next_slot) {
#line 112
    next_slot = (file_id *)((void *)0);
  }
#line 113
  p->type = type;
#line 114
  return (p);
}
}
#line 117 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static file_id *__lookup_file_id(struct stat  const  *st ) 
{ 
  file_id f ;
  void *tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 122
  f.dev = (dev_t )st->st_dev;
#line 123
  f.ino = (ino_t )st->st_ino;
#line 124
  tmp = hash_lookup((Hash_table const   *)file_id_table, (void const   *)(& f));
  }
#line 124
  return ((file_id *)tmp);
}
}
#line 130 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void insert_file_id(struct stat  const  *st , enum file_id_type type ) 
{ 


  {
  {
#line 133
  __insert_file_id(st, type);
  }
#line 134
  return;
}
}
#line 139 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
enum file_id_type lookup_file_id(struct stat  const  *st ) 
{ 
  file_id *p ;
  file_id *tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 142
  tmp = __lookup_file_id(st);
#line 142
  p = tmp;
  }
#line 144
  if (p) {
#line 144
    tmp___0 = (unsigned int )p->type;
  } else {
#line 144
    tmp___0 = 0U;
  }
#line 144
  return ((enum file_id_type )tmp___0);
}
}
#line 147 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void set_queued_output(struct stat  const  *st , _Bool queued_output ) 
{ 
  file_id *p ;
  file_id *tmp ;

  {
  {
#line 150
  tmp = __lookup_file_id(st);
#line 150
  p = tmp;
  }
#line 152
  if (! p) {
    {
#line 153
    p = __insert_file_id(st, (enum file_id_type )0);
    }
  }
#line 154
  p->queued_output = queued_output;
#line 155
  return;
}
}
#line 157 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
_Bool has_queued_output(struct stat  const  *st ) 
{ 
  file_id *p ;
  file_id *tmp ;
  int tmp___0 ;

  {
  {
#line 160
  tmp = __lookup_file_id(st);
#line 160
  p = tmp;
  }
#line 162
  if (p) {
#line 162
    if (p->queued_output) {
#line 162
      tmp___0 = 1;
    } else {
#line 162
      tmp___0 = 0;
    }
  } else {
#line 162
    tmp___0 = 0;
  }
#line 162
  return ((_Bool )tmp___0);
}
}
#line 165 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static _Bool __attribute__((__pure__))  contains_slash(char const   *s ) 
{ 


  {
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! *s) {
#line 168
      goto while_break;
    }
#line 169
    if ((int const   )*s == 47) {
#line 170
      return ((_Bool __attribute__((__pure__))  )1);
    }
#line 168
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return ((_Bool __attribute__((__pure__))  )0);
}
}
#line 220 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static int copy_attr(char const   *src_path , char const   *dst_path ) 
{ 


  {
#line 223
  return (0);
}
}
#line 250 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static uid_t euid  =    (uid_t )-1;
#line 251 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static gid_t egid  =    (gid_t )-1;
#line 228 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void set_file_attributes(char const   *to , enum file_attributes attr , char const   *from ,
                         struct stat  const  *st , mode_t mode , struct timespec *new_time ) 
{ 
  struct timespec times[2] ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  uid_t uid ;
  uid_t gid ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp24 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 233
  if ((unsigned int )attr & 1U) {
#line 236
    if (new_time) {
#line 237
      times[1] = *new_time;
#line 237
      times[0] = times[1];
    } else {
      {
#line 240
      times[0] = get_stat_atime(st);
#line 241
      times[1] = get_stat_mtime(st);
      }
    }
    {
#line 243
    tmp___1 = lutimens(to, (struct timespec  const  *)(times));
    }
#line 243
    if (tmp___1 != 0) {
      {
#line 244
      tmp = quotearg(to);
      }
#line 244
      if ((mode & 61440U) == 40960U) {
#line 244
        tmp___0 = "symbolic link";
      } else {
#line 244
        tmp___0 = "file";
      }
      {
#line 244
      pfatal("Failed to set the timestamps of %s %s", tmp___0, tmp);
      }
    }
  }
#line 248
  if ((unsigned int )attr & 2U) {
#line 255
    if (euid == 4294967295U) {
      {
#line 257
      euid = geteuid();
#line 258
      egid = getegid();
      }
    }
#line 260
    if (euid == (uid_t )st->st_uid) {
#line 260
      uid = (uid_t )-1;
    } else {
#line 260
      uid = (uid_t )st->st_uid;
    }
#line 261
    if (egid == (gid_t )st->st_gid) {
#line 261
      gid = (uid_t )-1;
    } else {
#line 261
      gid = (uid_t )st->st_gid;
    }
#line 265
    if (uid != 4294967295U) {
#line 265
      goto _L___0;
    } else
#line 265
    if (gid != 4294967295U) {
      _L___0: /* CIL Label */ 
      {
#line 265
      tmp___5 = lchown(to, uid, gid);
      }
#line 265
      if (tmp___5 != 0) {
        {
#line 265
        tmp___6 = __errno_location();
        }
#line 265
        if (*tmp___6 != 1) {
#line 265
          goto _L;
        } else
#line 265
        if (uid != 4294967295U) {
          {
#line 265
          uid = (uid_t )-1;
#line 265
          tmp___7 = lchown(to, uid, gid);
          }
#line 265
          if (tmp___7 != 0) {
            {
#line 265
            tmp___8 = __errno_location();
            }
#line 265
            if (*tmp___8 != 1) {
              _L: /* CIL Label */ 
              {
#line 271
              tmp___2 = quotearg(to);
              }
#line 271
              if ((mode & 61440U) == 40960U) {
#line 271
                tmp___3 = "symbolic link";
              } else {
#line 271
                tmp___3 = "file";
              }
#line 271
              if (uid == 4294967295U) {
#line 271
                tmp___4 = "owner";
              } else {
#line 271
                tmp___4 = "owning group";
              }
              {
#line 271
              pfatal("Failed to set the %s of %s %s", tmp___4, tmp___3, tmp___2);
              }
            }
          }
        }
      }
    }
  }
#line 276
  if ((unsigned int )attr & 8U) {
    {
#line 277
    tmp___9 = copy_attr(from, to);
    }
#line 277
    if (tmp___9) {
      {
#line 278
      fatal_exit(0);
      }
    }
  }
#line 280
  if ((unsigned int )attr & 4U) {
#line 288
    if (! ((mode & 61440U) == 40960U)) {
      {
#line 288
      tmp___12 = chmod(to, mode);
      }
#line 288
      if (tmp___12 != 0) {
        {
#line 290
        tmp___10 = quotearg(to);
        }
#line 290
        if ((mode & 61440U) == 40960U) {
#line 290
          tmp___11 = "symbolic link";
        } else {
#line 290
          tmp___11 = "file";
        }
        {
#line 290
        pfatal("Failed to set the permissions of %s %s", tmp___11, tmp___10);
        }
      }
    }
  }
#line 294
  return;
}
}
#line 296 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static void create_backup_copy(char const   *from , char const   *to , struct stat  const  *st ,
                               _Bool to_dir_known_to_exist ) 
{ 


  {
  {
#line 300
  copy_file(from, to, (struct stat *)((void *)0), 0, (mode_t )st->st_mode, to_dir_known_to_exist);
#line 301
  set_file_attributes(to, (enum file_attributes )7, from, st, (mode_t )st->st_mode,
                      (struct timespec *)((void *)0));
  }
#line 302
  return;
}
}
#line 304 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void create_backup(char const   *to , struct stat  const  *to_st , _Bool leave_original ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int try_makedirs_errno ;
  char *bakname ;
  char const   *p ;
  char const   *tmp___1 ;
  char const   *b ;
  char const   *tmp___2 ;
  char const   *s ;
  char const   *tmp___3 ;
  char const   *t ;
  size_t plen ;
  size_t tmp___4 ;
  size_t blen ;
  size_t tmp___5 ;
  size_t slen ;
  size_t tmp___6 ;
  size_t tlen ;
  size_t tmp___7 ;
  char const   *o ;
  size_t olen ;
  void *tmp___8 ;
  _Bool __attribute__((__pure__))  tmp___9 ;
  _Bool __attribute__((__pure__))  tmp___10 ;
  _Bool __attribute__((__pure__))  tmp___11 ;
  int fd ;
  char *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  enum file_id_type tmp___24 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 320
  if (to_st) {
#line 320
    if (! ((to_st->st_mode & 61440U) == 32768U)) {
#line 320
      if (! ((to_st->st_mode & 61440U) == 40960U)) {
#line 321
        if ((to_st->st_mode & 61440U) == 40960U) {
#line 321
          tmp = "symbolic link";
        } else {
#line 321
          tmp = "regular file";
        }
        {
#line 321
        fatal("File %s is not a %s -- refusing to create backup", to, tmp);
        }
      }
    }
  }
#line 324
  if (to_st) {
    {
#line 324
    tmp___24 = lookup_file_id(to_st);
    }
#line 324
    if ((unsigned int )tmp___24 == 1U) {
#line 326
      if (debug & 4) {
        {
#line 327
        tmp___0 = quotearg(to);
#line 327
        say("File %s already seen\n", tmp___0);
        }
      }
    } else {
#line 324
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 331
    try_makedirs_errno = 0;
#line 334
    if (origprae) {
#line 334
      goto _L___0;
    } else
#line 334
    if (origbase) {
#line 334
      goto _L___0;
    } else
#line 334
    if (origsuff) {
      _L___0: /* CIL Label */ 
#line 336
      if (origprae) {
#line 336
        tmp___1 = origprae;
      } else {
#line 336
        tmp___1 = "";
      }
#line 336
      p = tmp___1;
#line 337
      if (origbase) {
#line 337
        tmp___2 = origbase;
      } else {
#line 337
        tmp___2 = "";
      }
#line 337
      b = tmp___2;
#line 338
      if (origsuff) {
#line 338
        tmp___3 = origsuff;
      } else {
#line 338
        tmp___3 = "";
      }
      {
#line 338
      s = tmp___3;
#line 339
      t = to;
#line 340
      tmp___4 = strlen(p);
#line 340
      plen = tmp___4;
#line 341
      tmp___5 = strlen(b);
#line 341
      blen = tmp___5;
#line 342
      tmp___6 = strlen(s);
#line 342
      slen = tmp___6;
#line 343
      tmp___7 = strlen(t);
#line 343
      tlen = tmp___7;
#line 347
      o = t + tlen;
#line 347
      olen = (size_t )0;
      }
      {
#line 347
      while (1) {
        while_continue: /* CIL Label */ ;
#line 347
        if ((unsigned long )o > (unsigned long )t) {
#line 347
          if (! (! ((int const   )*(o - 1) == 47))) {
#line 347
            goto while_break;
          }
        } else {
#line 347
          goto while_break;
        }
#line 347
        o --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 351
      olen = (size_t )((t + tlen) - o);
#line 352
      tlen -= olen;
#line 353
      tmp___8 = xmalloc(((((plen + tlen) + blen) + olen) + slen) + 1UL);
#line 353
      bakname = (char *)tmp___8;
#line 354
      memcpy((void */* __restrict  */)bakname, (void const   */* __restrict  */)p,
             plen);
#line 355
      memcpy((void */* __restrict  */)(bakname + plen), (void const   */* __restrict  */)t,
             tlen);
#line 356
      memcpy((void */* __restrict  */)((bakname + plen) + tlen), (void const   */* __restrict  */)b,
             blen);
#line 357
      memcpy((void */* __restrict  */)(((bakname + plen) + tlen) + blen), (void const   */* __restrict  */)o,
             olen);
#line 358
      memcpy((void */* __restrict  */)((((bakname + plen) + tlen) + blen) + olen),
             (void const   */* __restrict  */)s, slen + 1UL);
      }
#line 360
      if (origprae) {
        {
#line 360
        tmp___9 = contains_slash(origprae + 0);
        }
#line 360
        if (tmp___9) {
#line 364
          try_makedirs_errno = 2;
        } else {
          {
#line 360
          tmp___10 = contains_slash(to);
          }
#line 360
          if (tmp___10) {
#line 364
            try_makedirs_errno = 2;
          } else {
#line 360
            goto _L;
          }
        }
      } else
      _L: /* CIL Label */ 
#line 360
      if (origbase) {
        {
#line 360
        tmp___11 = contains_slash(origbase);
        }
#line 360
        if (tmp___11) {
#line 364
          try_makedirs_errno = 2;
        }
      }
    } else {
      {
#line 368
      bakname = find_backup_file_name(to, backup_type);
      }
#line 369
      if (! bakname) {
        {
#line 370
        xalloc_die();
        }
      }
    }
#line 373
    if (! to_st) {
#line 377
      if (debug & 4) {
        {
#line 378
        tmp___12 = quotearg((char const   *)bakname);
#line 378
        say("Creating empty file %s\n", tmp___12);
        }
      }
      {
#line 380
      try_makedirs_errno = 2;
#line 381
      unlink((char const   *)bakname);
      }
      {
#line 382
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 382
        fd = creat((char const   *)bakname, (__mode_t )438);
        }
#line 382
        if (! (fd < 0)) {
#line 382
          goto while_break___0;
        }
        {
#line 384
        tmp___14 = __errno_location();
        }
#line 384
        if (*tmp___14 != try_makedirs_errno) {
          {
#line 385
          tmp___13 = quotearg((char const   *)bakname);
#line 385
          pfatal("Can\'t create file %s", tmp___13);
          }
        }
        {
#line 386
        makedirs((char const   *)bakname);
#line 387
        try_makedirs_errno = 0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 389
      tmp___16 = close(fd);
      }
#line 389
      if (tmp___16 != 0) {
        {
#line 390
        tmp___15 = quotearg((char const   *)bakname);
#line 390
        pfatal("Can\'t close file %s", tmp___15);
        }
      }
    } else
#line 392
    if (leave_original) {
      {
#line 393
      create_backup_copy(to, (char const   *)bakname, to_st, (_Bool )(try_makedirs_errno == 0));
      }
    } else {
#line 396
      if (debug & 4) {
        {
#line 397
        tmp___17 = quotearg_n(1, (char const   *)bakname);
#line 397
        tmp___18 = quotearg_n(0, to);
#line 397
        say("Renaming file %s to %s\n", tmp___18, tmp___17);
        }
      }
      {
#line 399
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 399
        tmp___23 = rename(to, (char const   *)bakname);
        }
#line 399
        if (! (tmp___23 != 0)) {
#line 399
          goto while_break___1;
        }
        {
#line 401
        tmp___22 = __errno_location();
        }
#line 401
        if (*tmp___22 == try_makedirs_errno) {
          {
#line 403
          makedirs((char const   *)bakname);
#line 404
          try_makedirs_errno = 0;
          }
        } else {
          {
#line 406
          tmp___21 = __errno_location();
          }
#line 406
          if (*tmp___21 == 18) {
            {
#line 408
            create_backup_copy(to, (char const   *)bakname, to_st, (_Bool )(try_makedirs_errno == 0));
#line 410
            unlink(to);
            }
#line 411
            goto while_break___1;
          } else {
            {
#line 414
            tmp___19 = quotearg_n(1, (char const   *)bakname);
#line 414
            tmp___20 = quotearg_n(0, to);
#line 414
            pfatal("Can\'t rename file %s to %s", tmp___20, tmp___19);
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 418
    free((void *)bakname);
    }
  }
#line 420
  return;
}
}
#line 432 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void move_file(char const   *from , int *from_needs_removal , struct stat  const  *fromst ,
               char const   *to , mode_t mode , _Bool backup ) 
{ 
  struct stat to_st ;
  int to_errno ;
  int *tmp___0 ;
  int tmp___1 ;
  struct stat *tmp___2 ;
  _Bool to_dir_known_to_exist ;
  char *buffer ;
  void *tmp___3 ;
  int fd ;
  int size ;
  int i ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  _Bool to_dir_known_to_exist___0 ;
  int tmp___14 ;
  int *tmp___15 ;
  struct stat tost ;
  char *tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
#line 440
  tmp___1 = lstat((char const   */* __restrict  */)to, (struct stat */* __restrict  */)(& to_st));
  }
#line 440
  if (tmp___1 == 0) {
#line 440
    to_errno = 0;
  } else {
    {
#line 440
    tmp___0 = __errno_location();
#line 440
    to_errno = *tmp___0;
    }
  }
#line 441
  if (backup) {
#line 442
    if (to_errno) {
#line 442
      tmp___2 = (struct stat *)((void *)0);
    } else {
#line 442
      tmp___2 = & to_st;
    }
    {
#line 442
    create_backup(to, (struct stat  const  *)tmp___2, (_Bool)0);
    }
  }
#line 443
  if (! to_errno) {
    {
#line 444
    insert_file_id((struct stat  const  *)(& to_st), (enum file_id_type )3);
    }
  }
#line 446
  if (from) {
#line 448
    if ((mode & 61440U) == 40960U) {
      {
#line 450
      to_dir_known_to_exist = (_Bool)0;
#line 454
      tmp___3 = xmalloc((size_t )4096);
#line 454
      buffer = (char *)tmp___3;
#line 455
      size = 0;
#line 457
      fd = open(from, 0);
      }
#line 457
      if (fd < 0) {
        {
#line 458
        tmp___4 = quotearg(from);
#line 458
        pfatal("Can\'t reopen file %s", tmp___4);
        }
      }
      {
#line 459
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 459
        tmp___5 = read(fd, (void *)(buffer + size), (size_t )(4096 - size));
#line 459
        i = (int )tmp___5;
        }
#line 459
        if (! (i > 0)) {
#line 459
          goto while_break;
        }
#line 460
        size += i;
      }
      while_break: /* CIL Label */ ;
      }
#line 461
      if (i != 0) {
        {
#line 462
        read_fatal();
        }
      } else {
        {
#line 461
        tmp___6 = close(fd);
        }
#line 461
        if (tmp___6 != 0) {
          {
#line 462
          read_fatal();
          }
        }
      }
#line 463
      *(buffer + size) = (char)0;
#line 465
      if (! backup) {
        {
#line 467
        tmp___7 = unlink(to);
        }
#line 467
        if (tmp___7 == 0) {
#line 468
          to_dir_known_to_exist = (_Bool)1;
        }
      }
      {
#line 470
      tmp___10 = symlink((char const   *)buffer, to);
      }
#line 470
      if (tmp___10 != 0) {
        {
#line 472
        tmp___8 = __errno_location();
        }
#line 472
        if (*tmp___8 == 2) {
#line 472
          if (! to_dir_known_to_exist) {
            {
#line 473
            makedirs(to);
            }
          }
        }
        {
#line 474
        tmp___9 = symlink((char const   *)buffer, to);
        }
#line 474
        if (tmp___9 != 0) {
          {
#line 475
          pfatal("Can\'t create %s %s", "symbolic link", to);
          }
        }
      }
      {
#line 477
      free((void *)buffer);
#line 478
      tmp___11 = lstat((char const   */* __restrict  */)to, (struct stat */* __restrict  */)(& to_st));
      }
#line 478
      if (tmp___11 != 0) {
        {
#line 479
        pfatal("Can\'t get file attributes of %s %s", "symbolic link", to);
        }
      }
      {
#line 480
      insert_file_id((struct stat  const  *)(& to_st), (enum file_id_type )1);
      }
    } else {
#line 484
      if (debug & 4) {
        {
#line 485
        tmp___12 = quotearg_n(1, to);
#line 485
        tmp___13 = quotearg_n(0, from);
#line 485
        say("Renaming file %s to %s\n", tmp___13, tmp___12);
        }
      }
      {
#line 488
      tmp___22 = rename(from, to);
      }
#line 488
      if (tmp___22 != 0) {
        {
#line 490
        to_dir_known_to_exist___0 = (_Bool)0;
#line 492
        tmp___15 = __errno_location();
        }
#line 492
        if (*tmp___15 == 2) {
#line 492
          if (to_errno == -1) {
#line 492
            goto _L;
          } else
#line 492
          if (to_errno == 2) {
            _L: /* CIL Label */ 
            {
#line 495
            makedirs(to);
#line 496
            to_dir_known_to_exist___0 = (_Bool)1;
#line 497
            tmp___14 = rename(from, to);
            }
#line 497
            if (tmp___14 == 0) {
#line 498
              goto rename_succeeded;
            }
          }
        }
        {
#line 501
        tmp___19 = __errno_location();
        }
#line 501
        if (*tmp___19 == 18) {
#line 504
          if (! backup) {
            {
#line 506
            tmp___18 = unlink(to);
            }
#line 506
            if (tmp___18 == 0) {
#line 507
              to_dir_known_to_exist___0 = (_Bool)1;
            } else {
              {
#line 508
              tmp___17 = __errno_location();
              }
#line 508
              if (*tmp___17 != 2) {
                {
#line 509
                tmp___16 = quotearg(to);
#line 509
                pfatal("Can\'t remove file %s", tmp___16);
                }
              }
            }
          }
          {
#line 511
          copy_file(from, to, & tost, 0, mode, to_dir_known_to_exist___0);
#line 512
          insert_file_id((struct stat  const  *)(& tost), (enum file_id_type )1);
          }
#line 513
          return;
        }
        {
#line 516
        tmp___20 = quotearg_n(1, to);
#line 516
        tmp___21 = quotearg_n(0, from);
#line 516
        pfatal("Can\'t rename file %s to %s", tmp___21, tmp___20);
        }
      }
      rename_succeeded: 
      {
#line 521
      insert_file_id(fromst, (enum file_id_type )1);
      }
#line 525
      if (0 < to_errno) {
#line 525
        goto _L___0;
      } else
#line 525
      if (to_errno == 0) {
#line 525
        if (to_st.st_nlink <= 1UL) {
          _L___0: /* CIL Label */ 
#line 525
          if (from_needs_removal) {
#line 528
            *from_needs_removal = 0;
          }
        }
      }
    }
  } else
#line 531
  if (! backup) {
#line 533
    if (debug & 4) {
      {
#line 534
      tmp___23 = quotearg(to);
#line 534
      say("Removing file %s\n", tmp___23);
      }
    }
    {
#line 535
    tmp___25 = unlink(to);
    }
#line 535
    if (tmp___25 != 0) {
      {
#line 535
      tmp___26 = __errno_location();
      }
#line 535
      if (*tmp___26 != 2) {
        {
#line 536
        tmp___24 = quotearg(to);
#line 536
        pfatal("Can\'t remove file %s", tmp___24);
        }
      }
    }
  }
#line 538
  return;
}
}
#line 543 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
int create_file(char const   *file , int open_flags , mode_t mode , _Bool to_dir_known_to_exist ) 
{ 
  int try_makedirs_errno ;
  int tmp ;
  int fd ;
  char *f ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp12 ;

  {
#line 547
  if (to_dir_known_to_exist) {
#line 547
    tmp = 0;
  } else {
#line 547
    tmp = 2;
  }
#line 547
  try_makedirs_errno = tmp;
#line 549
  mode |= 384U;
#line 550
  mode &= (unsigned int )(~ ((64 | (64 >> 3)) | ((64 >> 3) >> 3)));
  {
#line 551
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 555
    fd = open(file, 576 | open_flags, mode);
    }
#line 556
    if (fd < 0) {
      {
#line 559
      tmp___2 = __errno_location();
      }
#line 559
      if (*tmp___2 != try_makedirs_errno) {
        {
#line 560
        tmp___1 = quotearg(file);
#line 560
        pfatal("Can\'t create file %s", tmp___1);
        }
      }
      {
#line 561
      f = xstrdup(file);
#line 562
      makedirs((char const   *)f);
#line 563
      free((void *)f);
#line 564
      try_makedirs_errno = 0;
      }
    }
#line 551
    if (! (fd < 0)) {
#line 551
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 567
  return (fd);
}
}
#line 570 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static void copy_to_fd(char const   *from , int tofd ) 
{ 
  int fromfd ;
  ssize_t i ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 576
  fromfd = open(from, 0);
  }
#line 576
  if (fromfd < 0) {
    {
#line 577
    tmp = quotearg(from);
#line 577
    pfatal("Can\'t reopen file %s", tmp);
    }
  }
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 578
    i = read(fromfd, (void *)buf, bufsize);
    }
#line 578
    if (! (i != 0L)) {
#line 578
      goto while_break;
    }
#line 580
    if (i == -1L) {
      {
#line 581
      read_fatal();
      }
    }
    {
#line 582
    tmp___0 = full_write(tofd, (void const   *)buf, (size_t )i);
    }
#line 582
    if (tmp___0 != (size_t )i) {
      {
#line 583
      write_fatal();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 585
  tmp___1 = close(fromfd);
  }
#line 585
  if (tmp___1 != 0) {
    {
#line 586
    read_fatal();
    }
  }
#line 587
  return;
}
}
#line 591 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void copy_file(char const   *from , char const   *to , struct stat *tost , int to_flags ,
               mode_t mode , _Bool to_dir_known_to_exist ) 
{ 
  int tofd ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *buffer ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 597
  if (debug & 4) {
    {
#line 598
    tmp = quotearg_n(1, to);
#line 598
    tmp___0 = quotearg_n(0, from);
    }
#line 598
    if ((mode & 61440U) == 40960U) {
#line 598
      tmp___1 = "symbolic link";
    } else {
#line 598
      tmp___1 = "file";
    }
    {
#line 598
    say("Copying %s %s to %s\n", tmp___1, tmp___0, tmp);
    }
  }
#line 602
  if ((mode & 61440U) == 40960U) {
    {
#line 604
    tmp___2 = xmalloc((size_t )4096);
#line 604
    buffer = (char *)tmp___2;
#line 606
    tmp___3 = readlink((char const   */* __restrict  */)from, (char */* __restrict  */)buffer,
                       (size_t )4096);
    }
#line 606
    if (tmp___3 < 0L) {
      {
#line 607
      pfatal("Can\'t read %s %s", "symbolic link", from);
      }
    }
    {
#line 608
    tmp___4 = symlink((char const   *)buffer, to);
    }
#line 608
    if (tmp___4 != 0) {
      {
#line 609
      pfatal("Can\'t create %s %s", "symbolic link", to);
      }
    }
#line 610
    if (tost) {
      {
#line 610
      tmp___5 = lstat((char const   */* __restrict  */)to, (struct stat */* __restrict  */)tost);
      }
#line 610
      if (tmp___5 != 0) {
        {
#line 611
        pfatal("Can\'t get file attributes of %s %s", "symbolic link", to);
        }
      }
    }
    {
#line 612
    free((void *)buffer);
    }
  } else {
#line 616
    if (! ((mode & 61440U) == 32768U)) {
      {
#line 616
      __assert_fail("((((mode)) & 0170000) == (0100000))", "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c",
                    616U, "copy_file");
      }
    }
    {
#line 617
    tofd = create_file(to, 1 | to_flags, mode, to_dir_known_to_exist);
#line 619
    copy_to_fd(from, tofd);
    }
#line 620
    if (tost) {
      {
#line 620
      tmp___6 = fstat(tofd, tost);
      }
#line 620
      if (tmp___6 != 0) {
        {
#line 621
        pfatal("Can\'t get file attributes of %s %s", "file", to);
        }
      }
    }
    {
#line 622
    tmp___7 = close(tofd);
    }
#line 622
    if (tmp___7 != 0) {
      {
#line 623
      write_fatal();
      }
    }
  }
#line 625
  return;
}
}
#line 629 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void append_to_file(char const   *from , char const   *to ) 
{ 
  int tofd ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 634
  tofd = open(to, 1025);
  }
#line 634
  if (tofd < 0) {
    {
#line 635
    tmp = quotearg(to);
#line 635
    pfatal("Can\'t reopen file %s", tmp);
    }
  }
  {
#line 636
  copy_to_fd(from, tofd);
#line 637
  tmp___0 = close(tofd);
  }
#line 637
  if (tmp___0 != 0) {
    {
#line 638
    write_fatal();
    }
  }
#line 639
  return;
}
}
#line 641 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   DEV_NULL[10]  = 
#line 641
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'n',      (char const   )'u',      (char const   )'l', 
        (char const   )'l',      (char const   )'\000'};
#line 643 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   RCSSUFFIX[3]  = {      (char const   )',',      (char const   )'v',      (char const   )'\000'};
#line 644 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   CHECKOUT[6]  = {      (char const   )'c',      (char const   )'o',      (char const   )' ',      (char const   )'%', 
        (char const   )'s',      (char const   )'\000'};
#line 645 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   CHECKOUT_LOCKED[9]  = 
#line 645
  {      (char const   )'c',      (char const   )'o',      (char const   )' ',      (char const   )'-', 
        (char const   )'l',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )'\000'};
#line 646 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   RCSDIFF1[11]  = 
#line 646
  {      (char const   )'r',      (char const   )'c',      (char const   )'s',      (char const   )'d', 
        (char const   )'i',      (char const   )'f',      (char const   )'f',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 648 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   SCCSPREFIX[3]  = {      (char const   )'s',      (char const   )'.',      (char const   )'\000'};
#line 649 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   GET[5]  = {      (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'\000'};
#line 650 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   GET_LOCKED[8]  = 
#line 650
  {      (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'-',      (char const   )'e',      (char const   )' ',      (char const   )'\000'};
#line 651 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   SCCSDIFF1[8]  = 
#line 651
  {      (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'-',      (char const   )'p',      (char const   )' ',      (char const   )'\000'};
#line 652 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   SCCSDIFF2[11]  = 
#line 652
  {      (char const   )'|',      (char const   )'d',      (char const   )'i',      (char const   )'f', 
        (char const   )'f',      (char const   )' ',      (char const   )'-',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 654 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   CLEARTOOL_CO[23]  = 
#line 654
  {      (char const   )'c',      (char const   )'l',      (char const   )'e',      (char const   )'a', 
        (char const   )'r',      (char const   )'t',      (char const   )'o',      (char const   )'o', 
        (char const   )'l',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )' ',      (char const   )'-',      (char const   )'u',      (char const   )'n', 
        (char const   )'r',      (char const   )' ',      (char const   )'-',      (char const   )'n', 
        (char const   )'c',      (char const   )' ',      (char const   )'\000'};
#line 656 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char const   PERFORCE_CO[9]  = 
#line 656
  {      (char const   )'p',      (char const   )'4',      (char const   )' ',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'t',      (char const   )' ', 
        (char const   )'\000'};
#line 658 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static size_t quote_system_arg(char *quoted , char const   *arg ) 
{ 
  char *q ;
  char *tmp ;
  size_t len ;
  size_t tmp___0 ;

  {
  {
#line 661
  tmp = quotearg_style((enum quoting_style )1, arg);
#line 661
  q = tmp;
#line 662
  tmp___0 = strlen((char const   *)q);
#line 662
  len = tmp___0;
  }
#line 664
  if (quoted) {
    {
#line 665
    memcpy((void */* __restrict  */)quoted, (void const   */* __restrict  */)q, len + 1UL);
    }
  }
#line 666
  return (len);
}
}
#line 680 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
char const   *version_controller(char const   *filename , _Bool readonly , struct stat  const  *filestat ,
                                 char **getbuf , char **diffbuf ) 
{ 
  struct stat cstat ;
  char *dir ;
  char *tmp ;
  char *filebase ;
  char *tmp___0 ;
  char const   *dotslash ;
  char const   *tmp___1 ;
  size_t dirlen ;
  size_t tmp___2 ;
  size_t maxfixlen ;
  size_t maxtrysize ;
  size_t tmp___3 ;
  size_t quotelen ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t maxgetsize ;
  size_t maxdiffsize ;
  char *trybuf ;
  void *tmp___6 ;
  char const   *r ;
  char *p ;
  char *tmp___7 ;
  void *tmp___8 ;
  char const   *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *p___0 ;
  char *tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *p___1 ;
  char *tmp___17 ;
  void *tmp___18 ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  char *p___2 ;
  char *tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char *p___3 ;
  char *tmp___28 ;
  void *tmp___29 ;
  size_t tmp___30 ;
  char *p___4 ;
  char *tmp___31 ;
  void *tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;

  {
  {
#line 685
  tmp = dir_name(filename);
#line 685
  dir = tmp;
#line 686
  tmp___0 = base_name(filename);
#line 686
  filebase = tmp___0;
  }
#line 687
  if ((int const   )*filename == 45) {
#line 687
    tmp___1 = "./";
  } else {
#line 687
    tmp___1 = "";
  }
  {
#line 687
  dotslash = tmp___1;
#line 688
  tmp___2 = strlen((char const   *)dir);
#line 688
  dirlen = tmp___2 + 1UL;
#line 689
  maxfixlen = ((sizeof("SCCS/") - 1UL) + sizeof(SCCSPREFIX)) - 1UL;
#line 690
  tmp___3 = strlen((char const   *)filebase);
#line 690
  maxtrysize = ((dirlen + tmp___3) + maxfixlen) + 1UL;
#line 691
  tmp___4 = quote_system_arg((char *)0, (char const   *)dir);
#line 691
  tmp___5 = quote_system_arg((char *)0, (char const   *)filebase);
#line 691
  quotelen = tmp___4 + tmp___5;
#line 692
  maxgetsize = (sizeof(CLEARTOOL_CO) + quotelen) + maxfixlen;
#line 693
  maxdiffsize = ((((sizeof(SCCSDIFF1) + sizeof(SCCSDIFF2)) + sizeof(DEV_NULL)) - 1UL) + 2UL * quotelen) + maxfixlen;
#line 696
  tmp___6 = xmalloc(maxtrysize);
#line 696
  trybuf = (char *)tmp___6;
#line 697
  r = (char const   *)0;
#line 699
  sprintf((char */* __restrict  */)trybuf, (char const   */* __restrict  */)"%s/",
          dir);
#line 707
  sprintf((char */* __restrict  */)(trybuf + dirlen), (char const   */* __restrict  */)"RCS/%s%s",
          filebase, RCSSUFFIX);
#line 707
  tmp___40 = stat((char const   */* __restrict  */)trybuf, (struct stat */* __restrict  */)(& cstat));
  }
#line 707
  if (tmp___40 == 0) {
#line 707
    goto _L___7;
  } else {
    {
#line 707
    sprintf((char */* __restrict  */)(trybuf + dirlen), (char const   */* __restrict  */)"RCS/%s",
            filebase);
#line 707
    tmp___41 = stat((char const   */* __restrict  */)trybuf, (struct stat */* __restrict  */)(& cstat));
    }
#line 707
    if (tmp___41 == 0) {
#line 707
      goto _L___7;
    } else {
      {
#line 707
      sprintf((char */* __restrict  */)(trybuf + dirlen), (char const   */* __restrict  */)"%s%s",
              filebase, RCSSUFFIX);
#line 707
      tmp___42 = stat((char const   */* __restrict  */)trybuf, (struct stat */* __restrict  */)(& cstat));
      }
#line 707
      if (tmp___42 == 0) {
        _L___7: /* CIL Label */ 
#line 707
        if (filestat) {
#line 707
          if (filestat->st_dev == (__dev_t const   )cstat.st_dev) {
#line 707
            if (filestat->st_ino == (__ino_t const   )cstat.st_ino) {
#line 707
              goto _L___4;
            } else {
#line 707
              goto _L___6;
            }
          } else {
#line 707
            goto _L___6;
          }
        } else {
          _L___6: /* CIL Label */ 
#line 714
          if (getbuf) {
            {
#line 716
            tmp___8 = xmalloc(maxgetsize);
#line 716
            tmp___7 = (char *)tmp___8;
#line 716
            *getbuf = tmp___7;
#line 716
            p = tmp___7;
            }
#line 717
            if (readonly) {
#line 717
              tmp___9 = CHECKOUT;
            } else {
#line 717
              tmp___9 = CHECKOUT_LOCKED;
            }
            {
#line 717
            sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___9,
                    dotslash);
#line 718
            tmp___10 = strlen((char const   *)p);
#line 718
            p += tmp___10;
#line 719
            tmp___11 = quote_system_arg(p, filename);
#line 719
            p += tmp___11;
#line 720
            *p = (char )'\000';
            }
          }
#line 723
          if (diffbuf) {
            {
#line 725
            tmp___13 = xmalloc(maxdiffsize);
#line 725
            tmp___12 = (char *)tmp___13;
#line 725
            *diffbuf = tmp___12;
#line 725
            p___0 = tmp___12;
#line 726
            sprintf((char */* __restrict  */)p___0, (char const   */* __restrict  */)(RCSDIFF1),
                    dotslash);
#line 727
            tmp___14 = strlen((char const   *)p___0);
#line 727
            p___0 += tmp___14;
#line 728
            tmp___15 = quote_system_arg(p___0, filename);
#line 728
            p___0 += tmp___15;
#line 729
            tmp___16 = p___0;
#line 729
            p___0 ++;
#line 729
            *tmp___16 = (char )'>';
#line 730
            strcpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)(DEV_NULL));
            }
          }
#line 733
          r = "RCS";
        }
      } else {
        _L___4: /* CIL Label */ 
        {
#line 735
        sprintf((char */* __restrict  */)(trybuf + dirlen), (char const   */* __restrict  */)"SCCS/%s%s",
                SCCSPREFIX, filebase);
#line 735
        tmp___38 = stat((char const   */* __restrict  */)trybuf, (struct stat */* __restrict  */)(& cstat));
        }
#line 735
        if (tmp___38 == 0) {
#line 735
          goto _L___3;
        } else {
          {
#line 735
          sprintf((char */* __restrict  */)(trybuf + dirlen), (char const   */* __restrict  */)"%s%s",
                  SCCSPREFIX, filebase);
#line 735
          tmp___39 = stat((char const   */* __restrict  */)trybuf, (struct stat */* __restrict  */)(& cstat));
          }
#line 735
          if (tmp___39 == 0) {
            _L___3: /* CIL Label */ 
#line 738
            if (getbuf) {
              {
#line 740
              tmp___18 = xmalloc(maxgetsize);
#line 740
              tmp___17 = (char *)tmp___18;
#line 740
              *getbuf = tmp___17;
#line 740
              p___1 = tmp___17;
              }
#line 741
              if (readonly) {
#line 741
                tmp___19 = GET;
              } else {
#line 741
                tmp___19 = GET_LOCKED;
              }
              {
#line 741
              sprintf((char */* __restrict  */)p___1, (char const   */* __restrict  */)tmp___19);
#line 742
              tmp___20 = strlen((char const   *)p___1);
#line 742
              p___1 += tmp___20;
#line 743
              tmp___21 = quote_system_arg(p___1, (char const   *)trybuf);
#line 743
              p___1 += tmp___21;
#line 744
              *p___1 = (char )'\000';
              }
            }
#line 747
            if (diffbuf) {
              {
#line 749
              tmp___23 = xmalloc(maxdiffsize);
#line 749
              tmp___22 = (char *)tmp___23;
#line 749
              *diffbuf = tmp___22;
#line 749
              p___2 = tmp___22;
#line 750
              strcpy((char */* __restrict  */)p___2, (char const   */* __restrict  */)(SCCSDIFF1));
#line 751
              p___2 += sizeof(SCCSDIFF1) - 1UL;
#line 752
              tmp___24 = quote_system_arg(p___2, (char const   *)trybuf);
#line 752
              p___2 += tmp___24;
#line 753
              sprintf((char */* __restrict  */)p___2, (char const   */* __restrict  */)(SCCSDIFF2),
                      dotslash);
#line 754
              tmp___25 = strlen((char const   *)p___2);
#line 754
              p___2 += tmp___25;
#line 755
              tmp___26 = quote_system_arg(p___2, filename);
#line 755
              p___2 += tmp___26;
#line 756
              tmp___27 = p___2;
#line 756
              p___2 ++;
#line 756
              *tmp___27 = (char )'>';
#line 757
              strcpy((char */* __restrict  */)p___2, (char const   */* __restrict  */)(DEV_NULL));
              }
            }
#line 760
            r = "SCCS";
          } else
#line 762
          if (! readonly) {
#line 762
            if (filestat) {
              {
#line 762
              sprintf((char */* __restrict  */)(trybuf + dirlen), (char const   */* __restrict  */)"%s@@",
                      filebase);
#line 762
              tmp___37 = stat((char const   */* __restrict  */)trybuf, (struct stat */* __restrict  */)(& cstat));
              }
#line 762
              if (tmp___37 == 0) {
#line 762
                if ((cstat.st_mode & 61440U) == 16384U) {
#line 765
                  if (getbuf) {
                    {
#line 767
                    tmp___29 = xmalloc(maxgetsize);
#line 767
                    tmp___28 = (char *)tmp___29;
#line 767
                    *getbuf = tmp___28;
#line 767
                    p___3 = tmp___28;
#line 768
                    strcpy((char */* __restrict  */)p___3, (char const   */* __restrict  */)(CLEARTOOL_CO));
#line 769
                    p___3 += sizeof(CLEARTOOL_CO) - 1UL;
#line 770
                    tmp___30 = quote_system_arg(p___3, filename);
#line 770
                    p___3 += tmp___30;
#line 771
                    *p___3 = (char )'\000';
                    }
                  }
#line 774
                  if (diffbuf) {
#line 775
                    *diffbuf = (char *)0;
                  }
#line 777
                  r = "ClearCase";
                } else {
#line 762
                  goto _L___2;
                }
              } else {
#line 762
                goto _L___2;
              }
            } else {
#line 762
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 779
          if (! readonly) {
#line 779
            if (filestat) {
              {
#line 779
              tmp___34 = getenv("P4PORT");
              }
#line 779
              if (tmp___34) {
#line 779
                goto _L;
              } else {
                {
#line 779
                tmp___35 = getenv("P4USER");
                }
#line 779
                if (tmp___35) {
#line 779
                  goto _L;
                } else {
                  {
#line 779
                  tmp___36 = getenv("P4CONFIG");
                  }
#line 779
                  if (tmp___36) {
                    _L: /* CIL Label */ 
#line 782
                    if (getbuf) {
                      {
#line 784
                      tmp___32 = xmalloc(maxgetsize);
#line 784
                      tmp___31 = (char *)tmp___32;
#line 784
                      *getbuf = tmp___31;
#line 784
                      p___4 = tmp___31;
#line 785
                      strcpy((char */* __restrict  */)p___4, (char const   */* __restrict  */)(PERFORCE_CO));
#line 786
                      p___4 += sizeof(PERFORCE_CO) - 1UL;
#line 787
                      tmp___33 = quote_system_arg(p___4, filename);
#line 787
                      p___4 += tmp___33;
#line 788
                      *p___4 = (char )'\000';
                      }
                    }
#line 791
                    if (diffbuf) {
#line 792
                      *diffbuf = (char *)0;
                    }
#line 794
                    r = "Perforce";
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 797
  free((void *)trybuf);
#line 798
  free((void *)filebase);
#line 799
  free((void *)dir);
  }
#line 800
  return (r);
}
}
#line 808 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
_Bool version_get(char const   *filename , char const   *cs , _Bool exists , _Bool readonly ,
                  char const   *getbuf , struct stat *filestat ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 812
  if (patch_get < 0) {
#line 814
    if (readonly) {
#line 814
      tmp = "";
    } else {
#line 814
      tmp = " with lock";
    }
    {
#line 814
    tmp___0 = quotearg(filename);
#line 814
    ask("Get file %s from %s%s? [y] ", tmp___0, cs, tmp);
    }
#line 816
    if ((int )*buf == 110) {
#line 817
      return ((_Bool)0);
    }
  }
#line 820
  if (dry_run) {
#line 822
    if (! exists) {
      {
#line 823
      tmp___1 = quotearg(filename);
#line 823
      fatal("can\'t do dry run on nonexistent version-controlled file %s; invoke \'%s\' and try again",
            tmp___1, getbuf);
      }
    }
  } else {
#line 828
    if ((unsigned int )verbosity == 2U) {
#line 829
      if (readonly) {
#line 829
        tmp___2 = "";
      } else {
#line 829
        tmp___2 = " with lock";
      }
      {
#line 829
      tmp___3 = quotearg(filename);
#line 829
      say("Getting file %s from %s%s...\n", tmp___3, cs, tmp___2);
      }
    }
    {
#line 831
    tmp___5 = systemic(getbuf);
    }
#line 831
    if (tmp___5 != 0) {
      {
#line 832
      tmp___4 = quotearg(filename);
#line 832
      fatal("Can\'t get file %s from %s", tmp___4, cs);
      }
    }
    {
#line 833
    tmp___7 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)filestat);
    }
#line 833
    if (tmp___7 != 0) {
      {
#line 834
      tmp___6 = quotearg(filename);
#line 834
      pfatal("%s", tmp___6);
      }
    }
  }
#line 837
  return ((_Bool)1);
}
}
#line 842 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
char *savebuf(char const   *s , size_t size ) 
{ 
  char *rv ;
  void *tmp ;

  {
#line 847
  if (! size) {
#line 848
    return ((char *)((void *)0));
  }
  {
#line 850
  tmp = malloc(size);
#line 850
  rv = (char *)tmp;
  }
#line 852
  if (! rv) {
#line 854
    if (! using_plan_a) {
      {
#line 855
      xalloc_die();
      }
    }
  } else {
    {
#line 858
    memcpy((void */* __restrict  */)rv, (void const   */* __restrict  */)s, size);
    }
  }
#line 860
  return (rv);
}
}
#line 863 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
char *savestr(char const   *s ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 866
  tmp = strlen(s);
#line 866
  tmp___0 = savebuf(s, tmp + 1UL);
  }
#line 866
  return (tmp___0);
}
}
#line 869 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void remove_prefix(char *p , size_t prefixlen ) 
{ 
  char const   *s ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 872
  s = (char const   *)(p + prefixlen);
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    tmp = p;
#line 873
    p ++;
#line 873
    tmp___1 = s;
#line 873
    s ++;
#line 873
    tmp___0 = (char )*tmp___1;
#line 873
    *tmp = tmp___0;
#line 873
    if (! tmp___0) {
#line 873
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  return;
}
}
#line 877 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
char *format_linenum(char *numbuf , lin n ) 
{ 
  char *p ;

  {
#line 880
  p = (char *)(numbuf + ((sizeof(lin ) * 8UL) / 3UL + 1UL));
#line 881
  *p = (char )'\000';
#line 883
  if (n < 0L) {
    {
#line 885
    while (1) {
      while_continue: /* CIL Label */ ;
#line 886
      p --;
#line 886
      *p = (char )(48 - (int )(n % 10L));
#line 885
      n /= 10L;
#line 885
      if (! (n != 0L)) {
#line 885
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 889
    p --;
#line 889
    *p = (char )'-';
  } else {
    {
#line 893
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 894
      p --;
#line 894
      *p = (char )(48 + (int )(n % 10L));
#line 893
      n /= 10L;
#line 893
      if (! (n != 0L)) {
#line 893
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 898
  return (p);
}
}
#line 903
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *format 
                                                                     , ...) ;
#line 903 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void ( /* format attribute */  fatal)(char const   *format  , ...) 
{ 
  va_list args ;
  char *__cil_tmp3 ;

  {
  {
#line 907
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: **** ",
          program_name);
#line 908
  __builtin_va_start(args, format);
#line 909
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           args);
#line 910
  __builtin_va_end(args);
#line 911
  _IO_putc('\n', stderr);
#line 912
  fflush(stderr);
#line 913
  fatal_exit(0);
  }
}
}
#line 922
 __attribute__((__noreturn__)) void read_fatal(void) ;
#line 922 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void read_fatal(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 925
  pfatal("read error");
  }
}
}
#line 928
 __attribute__((__noreturn__)) void write_fatal(void) ;
#line 928 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void write_fatal(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 931
  pfatal("write error");
  }
}
}
#line 936
 __attribute__((__noreturn__)) void ( /* format attribute */  pfatal)(char const   *format 
                                                                      , ...) ;
#line 936 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void ( /* format attribute */  pfatal)(char const   *format  , ...) 
{ 
  int errnum ;
  int *tmp ;
  va_list args ;
  int *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 939
  tmp = __errno_location();
#line 939
  errnum = *tmp;
#line 941
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: **** ",
          program_name);
#line 942
  __builtin_va_start(args, format);
#line 943
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           args);
#line 944
  __builtin_va_end(args);
#line 945
  fflush(stderr);
#line 946
  tmp___0 = __errno_location();
#line 946
  *tmp___0 = errnum;
#line 947
  perror(" ");
#line 948
  fflush(stderr);
#line 949
  fatal_exit(0);
  }
}
}
#line 954 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static void vsay(char const   *format , va_list args ) 
{ 


  {
  {
#line 957
  vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
           args);
#line 958
  fflush(stdout);
  }
#line 959
  return;
}
}
#line 961 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void ( /* format attribute */  say)(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 965
  __builtin_va_start(args, format);
#line 966
  vsay(format, args);
#line 967
  __builtin_va_end(args);
  }
#line 968
  return;
}
}
#line 975 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static int ttyfd  =    -2;
#line 972 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void ( /* format attribute */  ask)(char const   *format  , ...) 
{ 
  ssize_t r ;
  va_list args ;
  int tmp___0 ;
  int tmp___1 ;
  size_t s ;
  void *tmp___2 ;
  int *tmp___3 ;
  int __x ;
  int tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 979
  __builtin_va_start(args, format);
#line 980
  vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
           args);
#line 981
  __builtin_va_end(args);
#line 982
  fflush(stdout);
  }
#line 984
  if (ttyfd == -2) {
#line 992
    if (posixly_correct) {
      {
#line 992
      tmp___0 = open("/dev/tty", 0);
#line 992
      ttyfd = tmp___0;
      }
    } else {
      {
#line 992
      tmp___1 = isatty(1);
      }
#line 992
      if (tmp___1) {
        {
#line 992
        tmp___0 = open("/dev/tty", 0);
#line 992
        ttyfd = tmp___0;
        }
      } else {
#line 992
        ttyfd = -1;
      }
    }
  }
#line 997
  if (ttyfd < 0) {
    {
#line 1000
    printf((char const   */* __restrict  */)"\n");
#line 1001
    *(buf + 0) = (char )'\n';
#line 1002
    *(buf + 1) = (char )'\000';
    }
  } else {
#line 1006
    s = (size_t )0;
    {
#line 1007
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1007
      r = read(ttyfd, (void *)(buf + s), (bufsize - 1UL) - s);
      }
#line 1007
      if ((size_t )r == (bufsize - 1UL) - s) {
#line 1007
        if (! ((int )*(buf + (bufsize - 2UL)) != 10)) {
#line 1007
          goto while_break;
        }
      } else {
#line 1007
        goto while_break;
      }
      {
#line 1010
      s = bufsize - 1UL;
#line 1011
      bufsize *= 2UL;
#line 1012
      tmp___2 = realloc((void *)buf, bufsize);
#line 1012
      buf = (char *)tmp___2;
      }
#line 1013
      if (! buf) {
        {
#line 1014
        xalloc_die();
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1016
    if (r == 0L) {
      {
#line 1017
      printf((char const   */* __restrict  */)"EOF\n");
      }
    } else
#line 1018
    if (r < 0L) {
      {
#line 1020
      tmp___3 = __errno_location();
#line 1020
      error(0, *tmp___3, "tty read failed");
#line 1021
      tmp___4 = close(ttyfd);
#line 1021
      __x = tmp___4;
#line 1022
      ttyfd = -1;
#line 1023
      r = (ssize_t )0;
      }
    }
#line 1025
    *(buf + (s + (size_t )r)) = (char )'\000';
  }
#line 1027
  return;
}
}
#line 1031 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
_Bool ( /* format attribute */  ok_to_reverse)(char const   *format  , ...) 
{ 
  _Bool r ;
  va_list args ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1034
  r = (_Bool)0;
#line 1036
  if (noreverse) {
    {
#line 1039
    __builtin_va_start(args, format);
#line 1040
    vsay(format, args);
#line 1041
    __builtin_va_end(args);
    }
  } else
#line 1036
  if (force) {
#line 1036
    if (! ((unsigned int )verbosity == 1U)) {
      {
#line 1039
      __builtin_va_start(args, format);
#line 1040
      vsay(format, args);
#line 1041
      __builtin_va_end(args);
      }
    }
  } else {
    {
#line 1039
    __builtin_va_start(args, format);
#line 1040
    vsay(format, args);
#line 1041
    __builtin_va_end(args);
    }
  }
#line 1044
  if (noreverse) {
    {
#line 1046
    say("  Skipping patch.\n");
#line 1047
    skip_rest_of_patch = (_Bool)1;
    }
  } else
#line 1049
  if (force) {
#line 1051
    if ((unsigned int )verbosity != 1U) {
      {
#line 1052
      say("  Applying it anyway.\n");
      }
    }
  } else
#line 1054
  if (batch) {
#line 1056
    if (reverse) {
#line 1056
      tmp = "  Ignoring -R.\n";
    } else {
#line 1056
      tmp = "  Assuming -R.\n";
    }
    {
#line 1056
    say(tmp);
#line 1057
    r = (_Bool)1;
    }
  } else {
#line 1061
    if (reverse) {
#line 1061
      tmp___0 = "  Ignore -R? [n] ";
    } else {
#line 1061
      tmp___0 = "  Assume -R? [n] ";
    }
    {
#line 1061
    ask(tmp___0);
#line 1062
    r = (_Bool )((int )*buf == 121);
    }
#line 1063
    if (! r) {
      {
#line 1065
      ask("Apply anyway? [n] ");
      }
#line 1066
      if ((int )*buf != 121) {
#line 1068
        if ((unsigned int )verbosity != 1U) {
          {
#line 1069
          say("Skipping patch.\n");
          }
        }
#line 1070
        skip_rest_of_patch = (_Bool)1;
      }
    }
  }
#line 1075
  return (r);
}
}
#line 1081 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static int const   sigs[6]  = {      (int const   )1,      (int const   )13,      (int const   )15,      (int const   )24, 
        (int const   )25,      (int const   )2};
#line 1120 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static sigset_t initial_signal_mask  ;
#line 1121 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static sigset_t signals_to_block  ;
#line 1133 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void set_signals(_Bool reset ) 
{ 
  int i ;
  struct sigaction initial_act ;
  struct sigaction fatal_act ;
  _Bool ignoring_signal ;
  int tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  {
#line 1139
  fatal_act.__sigaction_handler.sa_handler = & fatal_exit;
#line 1140
  sigemptyset(& fatal_act.sa_mask);
#line 1141
  fatal_act.sa_flags = 0;
  }
#line 1147
  if (! reset) {
    {
#line 1151
    signal(17, (void (*)(int  ))0);
#line 1153
    sigemptyset(& signals_to_block);
#line 1154
    i = 0;
    }
    {
#line 1154
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1154
      if (! (i < (int )(sizeof(sigs) / sizeof(sigs[0])))) {
#line 1154
        goto while_break;
      }
      {
#line 1158
      tmp = sigaction((int )sigs[i], (struct sigaction  const  */* __restrict  */)((struct sigaction *)0),
                      (struct sigaction */* __restrict  */)(& initial_act));
      }
#line 1158
      if (tmp != 0) {
#line 1159
        goto __Cont;
      }
#line 1160
      ignoring_signal = (_Bool )((unsigned long )initial_act.__sigaction_handler.sa_handler == (unsigned long )((void (*)(int  ))1));
#line 1164
      if (! ignoring_signal) {
        {
#line 1166
        sigaddset(& signals_to_block, (int )sigs[i]);
#line 1167
        sigaction((int )sigs[i], (struct sigaction  const  */* __restrict  */)(& fatal_act),
                  (struct sigaction */* __restrict  */)((struct sigaction *)0));
        }
      }
      __Cont: /* CIL Label */ 
#line 1154
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1175
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& initial_signal_mask), (sigset_t */* __restrict  */)((sigset_t *)0));
    }
  }
#line 1182
  return;
}
}
#line 1186 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void ignore_signals(void) 
{ 


  {
  {
#line 1190
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& signals_to_block), (sigset_t */* __restrict  */)(& initial_signal_mask));
  }
#line 1197
  return;
}
}
#line 1199
 __attribute__((__noreturn__)) void exit_with_signal(int sig ) ;
#line 1199 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void exit_with_signal(int sig ) 
{ 
  sigset_t s ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 1203
  signal(sig, (void (*)(int  ))0);
#line 1204
  sigemptyset(& s);
#line 1205
  sigaddset(& s, sig);
#line 1206
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& s), (sigset_t */* __restrict  */)((sigset_t *)0));
#line 1207
  raise(sig);
#line 1208
  exit(2);
  }
}
}
#line 1211 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
int systemic(char const   *command ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
#line 1214
  if (debug & 8) {
    {
#line 1215
    say("+ %s\n", command);
    }
  }
  {
#line 1216
  fflush(stdout);
#line 1217
  tmp = system(command);
  }
#line 1217
  return (tmp);
}
}
#line 1223 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char *replace_slashes(char *filename ) 
{ 
  char *f ;
  char *last_location_replaced ;
  char const   *component_start ;
  char *slash ;

  {
#line 1227
  last_location_replaced = (char *)0;
#line 1230
  f = filename + 0;
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1230
    if (! ((int )*f == 47)) {
#line 1230
      goto while_break;
    }
#line 1230
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1233
  component_start = (char const   *)f;
  {
#line 1235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1235
    if (! *f) {
#line 1235
      goto while_break___0;
    }
#line 1236
    if ((int )*f == 47) {
#line 1238
      slash = f;
      {
#line 1241
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1241
        if (! ((int )*(f + 1) == 47)) {
#line 1241
          goto while_break___1;
        }
#line 1242
        f ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1245
      if (! *(f + 1)) {
#line 1246
        goto while_break___0;
      }
#line 1249
      if (slash - (char *)component_start <= 2L) {
#line 1249
        if ((int const   )*(component_start + 0) == 46) {
#line 1249
          if (! ((int )*(slash + -1) == 46)) {
#line 1252
            *slash = (char )'\000';
#line 1253
            last_location_replaced = slash;
          }
        } else {
#line 1252
          *slash = (char )'\000';
#line 1253
          last_location_replaced = slash;
        }
      } else {
#line 1252
        *slash = (char )'\000';
#line 1253
        last_location_replaced = slash;
      }
#line 1256
      component_start = (char const   *)(f + 1);
    }
#line 1235
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1259
  return (last_location_replaced);
}
}
#line 1265 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static void makedirs(char const   *name ) 
{ 
  char *filename ;
  char *tmp ;
  char *f ;
  char *flim ;
  char *tmp___0 ;

  {
  {
#line 1268
  tmp = xstrdup(name);
#line 1268
  filename = tmp;
#line 1270
  tmp___0 = replace_slashes(filename);
#line 1270
  flim = tmp___0;
  }
#line 1272
  if (flim) {
#line 1279
    f = filename;
    {
#line 1279
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1279
      if (! ((unsigned long )f <= (unsigned long )flim)) {
#line 1279
        goto while_break;
      }
#line 1280
      if (! *f) {
        {
#line 1282
        mkdir((char const   *)filename, (__mode_t )((((((448 | (256 >> 3)) | (128 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3)));
#line 1286
        *f = (char )'/';
        }
      }
#line 1279
      f ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1289
  free((void *)filename);
  }
#line 1290
  return;
}
}
#line 1295 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void removedirs(char const   *name ) 
{ 
  char *filename ;
  char *tmp ;
  size_t i ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 1298
  tmp = xstrdup(name);
#line 1298
  filename = tmp;
#line 1301
  i = strlen((char const   *)filename);
  }
  {
#line 1301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1301
    if (! (i != 0UL)) {
#line 1301
      goto while_break;
    }
#line 1302
    if ((int )*(filename + i) == 47) {
#line 1302
      if (! ((int )*(filename + (i - 1UL)) == 47)) {
#line 1302
        if ((int )*(filename + (i - 1UL)) == 46) {
#line 1302
          if (! (i == 1UL)) {
#line 1302
            if (! ((int )*(filename + (i - 2UL)) == 47)) {
#line 1302
              if ((int )*(filename + (i - 2UL)) == 46) {
#line 1302
                if (! (i == 2UL)) {
#line 1302
                  if (! ((int )*(filename + (i - 3UL)) == 47)) {
#line 1302
                    goto _L;
                  }
                }
              } else {
#line 1302
                goto _L;
              }
            }
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1311
          *(filename + i) = (char )'\000';
#line 1312
          tmp___1 = rmdir((char const   *)filename);
          }
#line 1312
          if (tmp___1 == 0) {
#line 1312
            if ((unsigned int )verbosity == 2U) {
              {
#line 1313
              tmp___0 = quotearg((char const   *)filename);
#line 1313
              say("Removed empty directory %s\n", tmp___0);
              }
            }
          }
#line 1314
          *(filename + i) = (char )'/';
        }
      }
    }
#line 1301
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1316
  free((void *)filename);
  }
#line 1317
  return;
}
}
#line 1319 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static struct timespec initial_time  ;
#line 1321 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void init_time(void) 
{ 


  {
  {
#line 1324
  gettime(& initial_time);
  }
#line 1325
  return;
}
}
#line 1327 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static char *parse_c_string(char const   *s , char const   **endp ) 
{ 
  char *u ;
  char *v ;
  size_t tmp ;
  void *tmp___0 ;
  char c ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  int acc ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1332
  if (! ((int const   )*s == 34)) {
    {
#line 1332
    __assert_fail("*s == \'\"\'", "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c",
                  1332U, "parse_c_string");
    }
  }
  {
#line 1333
  s ++;
#line 1334
  tmp = strlen(s);
#line 1334
  tmp___0 = xmalloc(tmp);
#line 1334
  v = (char *)tmp___0;
#line 1334
  u = v;
  }
  {
#line 1335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1337
    tmp___1 = s;
#line 1337
    s ++;
#line 1337
    c = (char )*tmp___1;
    {
#line 1341
    if ((int )c == 0) {
#line 1341
      goto case_0;
    }
#line 1344
    if ((int )c == 34) {
#line 1344
      goto case_34;
    }
#line 1353
    if ((int )c == 92) {
#line 1353
      goto case_92;
    }
#line 1356
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1342
    goto fail;
    case_34: /* CIL Label */ 
    {
#line 1345
    tmp___2 = v;
#line 1345
    v ++;
#line 1345
    *tmp___2 = (char)0;
#line 1346
    tmp___3 = realloc((void *)u, (size_t )(v - u));
#line 1346
    v = (char *)tmp___3;
    }
#line 1347
    if (v) {
#line 1348
      u = v;
    }
#line 1349
    if (endp) {
#line 1350
      *endp = s;
    }
#line 1351
    return (u);
    case_92: /* CIL Label */ 
#line 1354
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1357
    tmp___4 = v;
#line 1357
    v ++;
#line 1357
    *tmp___4 = c;
#line 1358
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 1361
    tmp___5 = s;
#line 1361
    s ++;
#line 1361
    c = (char )*tmp___5;
    {
#line 1364
    if ((int )c == 97) {
#line 1364
      goto case_97;
    }
#line 1365
    if ((int )c == 98) {
#line 1365
      goto case_98;
    }
#line 1366
    if ((int )c == 102) {
#line 1366
      goto case_102;
    }
#line 1367
    if ((int )c == 110) {
#line 1367
      goto case_110;
    }
#line 1368
    if ((int )c == 114) {
#line 1368
      goto case_114;
    }
#line 1369
    if ((int )c == 116) {
#line 1369
      goto case_116;
    }
#line 1370
    if ((int )c == 118) {
#line 1370
      goto case_118;
    }
#line 1371
    if ((int )c == 34) {
#line 1371
      goto case_34___0;
    }
#line 1371
    if ((int )c == 92) {
#line 1371
      goto case_34___0;
    }
#line 1373
    if ((int )c == 51) {
#line 1373
      goto case_51;
    }
#line 1373
    if ((int )c == 50) {
#line 1373
      goto case_51;
    }
#line 1373
    if ((int )c == 49) {
#line 1373
      goto case_51;
    }
#line 1373
    if ((int )c == 48) {
#line 1373
      goto case_51;
    }
#line 1388
    goto switch_default___0;
    case_97: /* CIL Label */ 
#line 1364
    c = (char )'\a';
#line 1364
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 1365
    c = (char )'\b';
#line 1365
    goto switch_break___0;
    case_102: /* CIL Label */ 
#line 1366
    c = (char )'\f';
#line 1366
    goto switch_break___0;
    case_110: /* CIL Label */ 
#line 1367
    c = (char )'\n';
#line 1367
    goto switch_break___0;
    case_114: /* CIL Label */ 
#line 1368
    c = (char )'\r';
#line 1368
    goto switch_break___0;
    case_116: /* CIL Label */ 
#line 1369
    c = (char )'\t';
#line 1369
    goto switch_break___0;
    case_118: /* CIL Label */ 
#line 1370
    c = (char )'\v';
#line 1370
    goto switch_break___0;
    case_34___0: /* CIL Label */ 
    case_92___0: /* CIL Label */ 
#line 1372
    goto switch_break___0;
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1375
    acc = ((int )c - 48) << 6;
#line 1377
    tmp___6 = s;
#line 1377
    s ++;
#line 1377
    c = (char )*tmp___6;
#line 1378
    if ((int )c < 48) {
#line 1379
      goto fail;
    } else
#line 1378
    if ((int )c > 55) {
#line 1379
      goto fail;
    }
#line 1380
    acc |= ((int )c - 48) << 3;
#line 1381
    tmp___7 = s;
#line 1381
    s ++;
#line 1381
    c = (char )*tmp___7;
#line 1382
    if ((int )c < 48) {
#line 1383
      goto fail;
    } else
#line 1382
    if ((int )c > 55) {
#line 1383
      goto fail;
    }
#line 1384
    acc |= (int )c - 48;
#line 1385
    c = (char )acc;
#line 1386
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1389
    goto fail;
    switch_break___0: /* CIL Label */ ;
    }
#line 1391
    tmp___8 = v;
#line 1391
    v ++;
#line 1391
    *tmp___8 = c;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  fail: 
  {
#line 1395
  free((void *)u);
  }
#line 1396
  if (endp) {
#line 1397
    *endp = s;
  }
#line 1398
  return ((char *)((void *)0));
}
}
#line 1405 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
static _Bool strip_leading_slashes(char *name , int strip_leading ) 
{ 
  int s ;
  char *p ;
  char *n ;
  size_t tmp ;

  {
#line 1408
  s = strip_leading;
#line 1411
  n = name;
#line 1411
  p = n;
  {
#line 1411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1411
    if (! *p) {
#line 1411
      goto while_break;
    }
#line 1413
    if ((int )*p == 47) {
      {
#line 1415
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1415
        if (! ((int )*(p + 1) == 47)) {
#line 1415
          goto while_break___0;
        }
#line 1416
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1417
      if (strip_leading < 0) {
#line 1418
        n = p + 1;
      } else {
#line 1417
        s --;
#line 1417
        if (s >= 0) {
#line 1418
          n = p + 1;
        }
      }
    }
#line 1411
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1421
  if (strip_leading < 0) {
#line 1421
    goto _L;
  } else
#line 1421
  if (s <= 0) {
    _L: /* CIL Label */ 
#line 1421
    if (*n) {
      {
#line 1423
      tmp = strlen((char const   *)n);
#line 1423
      memmove((void *)name, (void const   *)n, tmp + 1UL);
      }
#line 1424
      return ((_Bool)1);
    } else {
#line 1427
      return ((_Bool)0);
    }
  } else {
#line 1427
    return ((_Bool)0);
  }
}
}
#line 1433 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void fetchname(char const   *at , int strip_leading , char **pname , char **ptimestr ,
               struct timespec *pstamp ) 
{ 
  char *name ;
  char const   *t ;
  char *timestr ;
  struct timespec stamp ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char const   *u ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  char const   *u___0 ;
  size_t tmp___7 ;
  struct timespec lower ;
  struct timespec upper ;
  _Bool tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 1439
  timestr = (char *)((void *)0);
#line 1442
  stamp.tv_sec = (__time_t )-1;
#line 1443
  stamp.tv_nsec = 0L;
  {
#line 1445
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1445
    tmp = __ctype_b_loc();
    }
#line 1445
    if (! ((int const   )*(*tmp + (int )((unsigned char )*at)) & 8192)) {
#line 1445
      goto while_break;
    }
#line 1446
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1447
  if (debug & 128) {
    {
#line 1448
    say("fetchname %s %d\n", at, strip_leading);
    }
  }
#line 1450
  if ((int const   )*at == 34) {
    {
#line 1452
    name = parse_c_string(at, & t);
    }
#line 1453
    if (! name) {
#line 1455
      if (debug & 128) {
        {
#line 1456
        tmp___0 = quotearg(at);
#line 1456
        say("ignoring malformed filename %s\n", tmp___0);
        }
      }
#line 1457
      return;
    }
  } else {
#line 1462
    t = at;
    {
#line 1462
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1462
      if (! *t) {
#line 1462
        goto while_break___0;
      }
      {
#line 1464
      tmp___4 = __ctype_b_loc();
      }
#line 1464
      if ((int const   )*(*tmp___4 + (int )((unsigned char )*t)) & 8192) {
#line 1468
        u = t;
        {
#line 1469
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1469
          if ((int const   )*u != 9) {
            {
#line 1469
            tmp___1 = __ctype_b_loc();
            }
#line 1469
            if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*(u + 1))) & 8192)) {
#line 1469
              goto while_break___1;
            }
          } else {
#line 1469
            goto while_break___1;
          }
#line 1470
          u ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1471
        if ((int const   )*u != 9) {
#line 1471
          if (pstamp) {
#line 1471
            tmp___2 = '\t';
          } else {
#line 1471
            tmp___2 = '\n';
          }
          {
#line 1471
          tmp___3 = strchr(u + 1, tmp___2);
          }
#line 1471
          if (tmp___3) {
#line 1472
            goto __Cont;
          }
        }
#line 1473
        goto while_break___0;
      }
      __Cont: /* CIL Label */ 
#line 1462
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1476
    name = savebuf(at, (size_t )((t - at) + 1L));
#line 1477
    *(name + (t - at)) = (char)0;
    }
  }
  {
#line 1483
  tmp___5 = strcmp((char const   *)name, "/dev/null");
  }
#line 1483
  if (tmp___5 == 0) {
    {
#line 1485
    free((void *)name);
    }
#line 1486
    if (pstamp) {
#line 1488
      pstamp->tv_sec = (__time_t )0;
#line 1489
      pstamp->tv_nsec = 0L;
    }
#line 1491
    return;
  }
  {
#line 1495
  tmp___6 = strip_leading_slashes(name, strip_leading);
  }
#line 1495
  if (! tmp___6) {
    {
#line 1497
    free((void *)name);
    }
#line 1498
    return;
  }
#line 1501
  if (ptimestr) {
    {
#line 1503
    tmp___7 = strlen(t);
#line 1503
    u___0 = t + tmp___7;
    }
#line 1505
    if ((unsigned long )u___0 != (unsigned long )t) {
#line 1505
      if ((int const   )*(u___0 - 1) == 10) {
#line 1506
        u___0 --;
      }
    }
#line 1507
    if ((unsigned long )u___0 != (unsigned long )t) {
#line 1507
      if ((int const   )*(u___0 - 1) == 13) {
#line 1508
        u___0 --;
      }
    }
    {
#line 1509
    timestr = savebuf(t, (size_t )((u___0 - t) + 1L));
#line 1510
    *(timestr + (u___0 - t)) = (char)0;
    }
  }
#line 1513
  if ((int const   )*t != 10) {
#line 1515
    if (! pstamp) {
      {
#line 1517
      free((void *)name);
#line 1518
      free((void *)timestr);
      }
#line 1519
      return;
    }
#line 1522
    if ((int )set_time | (int )set_utc) {
      {
#line 1523
      parse_datetime(& stamp, t, (struct timespec  const  *)(& initial_time));
      }
    } else {
      {
#line 1531
      lower.tv_sec = -90000L;
#line 1531
      lower.tv_nsec = 0L;
#line 1531
      upper.tv_sec = 93600L;
#line 1531
      upper.tv_nsec = 0L;
#line 1533
      tmp___8 = parse_datetime(& stamp, t, (struct timespec  const  *)(& initial_time));
      }
#line 1533
      if (tmp___8) {
        {
#line 1533
        tmp___9 = timespec_cmp(stamp, lower);
        }
#line 1533
        if (tmp___9 > 0) {
          {
#line 1533
          tmp___10 = timespec_cmp(stamp, upper);
          }
#line 1533
          if (tmp___10 < 0) {
#line 1536
            stamp.tv_sec = (__time_t )0;
#line 1537
            stamp.tv_nsec = 0L;
          }
        }
      }
    }
  }
  {
#line 1542
  free((void *)*pname);
#line 1543
  *pname = name;
  }
#line 1544
  if (ptimestr) {
    {
#line 1546
    free((void *)*ptimestr);
#line 1547
    *ptimestr = timestr;
    }
  }
#line 1549
  if (pstamp) {
#line 1550
    *pstamp = stamp;
  }
#line 1551
  return;
}
}
#line 1553 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
char *parse_name(char const   *s , int strip_leading , char const   **endp ) 
{ 
  char *ret ;
  unsigned short const   **tmp ;
  char const   *t ;
  unsigned short const   **tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 1558
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1558
    tmp = __ctype_b_loc();
    }
#line 1558
    if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 1558
      goto while_break;
    }
#line 1559
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1560
  if ((int const   )*s == 34) {
    {
#line 1561
    ret = parse_c_string(s, endp);
    }
  } else {
#line 1566
    t = s;
    {
#line 1566
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1566
      if (*t) {
        {
#line 1566
        tmp___0 = __ctype_b_loc();
        }
#line 1566
        if ((int const   )*(*tmp___0 + (int )((unsigned char )*t)) & 8192) {
#line 1566
          goto while_break___0;
        }
      } else {
#line 1566
        goto while_break___0;
      }
#line 1566
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1568
    ret = savebuf(s, (size_t )((t - s) + 1L));
#line 1569
    *(ret + (t - s)) = (char)0;
    }
#line 1570
    if (endp) {
#line 1571
      *endp = t;
    }
  }
  {
#line 1573
  tmp___1 = strip_leading_slashes(ret, strip_leading);
  }
#line 1573
  if (! tmp___1) {
    {
#line 1575
    free((void *)ret);
#line 1576
    ret = (char *)((void *)0);
    }
  }
#line 1578
  return (ret);
}
}
#line 1581 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
void Fseek(FILE *stream , file_offset offset , int ptrname ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 1584
  tmp = fseek(stream, offset, ptrname);
  }
#line 1584
  if (tmp != 0) {
    {
#line 1585
    pfatal("fseek");
    }
  }
#line 1586
  return;
}
}
#line 1592 "/home/wslee/gnu_benchmarks/patch-2.7/src/util.c"
int make_tempfile(char const   **name , char letter , char const   *real_name , int flags ,
                  mode_t mode ) 
{ 
  int try_makedirs_errno ;
  char *template ;
  char *dirname ;
  char *basename___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmpdir ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int fd ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 1596
  try_makedirs_errno = 2;
#line 1599
  if (real_name) {
    {
#line 1603
    dirname = dir_name(real_name);
#line 1604
    basename___0 = base_name(real_name);
#line 1606
    tmp = strlen((char const   *)dirname);
#line 1606
    tmp___0 = strlen((char const   *)basename___0);
#line 1606
    tmp___1 = xmalloc(((tmp + 1UL) + tmp___0) + 9UL);
#line 1606
    template = (char *)tmp___1;
#line 1607
    sprintf((char */* __restrict  */)template, (char const   */* __restrict  */)"%s/%s.%cXXXXXX",
            dirname, basename___0, (int )letter);
#line 1608
    free((void *)dirname);
#line 1609
    free((void *)basename___0);
    }
  } else {
    {
#line 1615
    tmp___2 = getenv("TMPDIR");
#line 1615
    tmpdir = (char const   *)tmp___2;
    }
#line 1616
    if (! tmpdir) {
      {
#line 1617
      tmp___3 = getenv("TMP");
#line 1617
      tmpdir = (char const   *)tmp___3;
      }
    }
#line 1618
    if (! tmpdir) {
      {
#line 1619
      tmp___4 = getenv("TEMP");
#line 1619
      tmpdir = (char const   *)tmp___4;
      }
    }
#line 1620
    if (! tmpdir) {
#line 1621
      tmpdir = "/tmp";
    }
    {
#line 1623
    tmp___5 = strlen(tmpdir);
#line 1623
    tmp___6 = xmalloc(tmp___5 + 10UL);
#line 1623
    template = (char *)tmp___6;
#line 1624
    sprintf((char */* __restrict  */)template, (char const   */* __restrict  */)"%s/p%cXXXXXX",
            tmpdir, (int )letter);
    }
  }
  {
#line 1626
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1630
    tmp___7 = gen_tempname(template, 0, flags, 2);
    }
#line 1630
    if (tmp___7) {
      {
#line 1631
      pfatal("Can\'t create temporary file %s", template);
      }
    }
    retry: 
    {
#line 1633
    fd = open((char const   *)template, 192 | flags, mode);
    }
#line 1634
    if (fd == -1) {
      {
#line 1636
      tmp___8 = __errno_location();
      }
#line 1636
      if (*tmp___8 == try_makedirs_errno) {
        {
#line 1638
        makedirs((char const   *)template);
#line 1641
        try_makedirs_errno = 0;
        }
#line 1642
        goto retry;
      }
      {
#line 1644
      tmp___9 = __errno_location();
      }
#line 1644
      if (*tmp___9 == 17) {
#line 1645
        goto __Cont;
      }
      {
#line 1646
      pfatal("Can\'t create temporary file %s", template);
      }
    }
#line 1648
    *name = (char const   *)template;
#line 1649
    return (fd);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 846
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 852
extern int pclose(FILE *__stream ) ;
#line 78 "./common.h"
char *inname ;
#line 79
char *outfile ;
#line 80
int inerrno ;
#line 81
int invc ;
#line 82
struct stat instat ;
#line 92
char const   *TMPPATNAME ;
#line 96
int TMPPATNAME_needs_removal ;
#line 109
int strippath ;
#line 126
enum diff diff_type ;
#line 128
char *revision ;
#line 180
_Bool no_strip_trailing_cr ;
#line 82 "./util.h"
__inline static char const   * __attribute__((__pure__)) skip_spaces(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp = __ctype_b_loc();
    }
#line 85
    if (! ((int const   )*(*tmp + (int )((unsigned char )*str)) & 8192)) {
#line 85
      goto while_break;
    }
#line 86
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return ((char const   */* __attribute__((__pure__)) */)str);
}
}
#line 24 "./pch.h"
lin pch_hunk_beg(void)  __attribute__((__pure__)) ;
#line 25
char const   *pch_c_function(void)  __attribute__((__pure__)) ;
#line 26
_Bool pch_git_diff(void)  __attribute__((__pure__)) ;
#line 27
char const   *pch_timestr(_Bool which )  __attribute__((__pure__)) ;
#line 28
char const   *pch_sha1(_Bool which )  __attribute__((__pure__)) ;
#line 29
mode_t pch_mode(_Bool which )  __attribute__((__pure__)) ;
#line 30
lin pch_newfirst(void)  __attribute__((__pure__)) ;
#line 33
lin pch_repl_lines(void)  __attribute__((__pure__)) ;
#line 35
_Bool pch_swap(void) ;
#line 37
_Bool there_is_another_patch(_Bool need_header , mode_t *file_type ) ;
#line 40
int another_hunk(enum diff difftype , _Bool rev ) ;
#line 41
int pch_says_nonexistent(_Bool which )  __attribute__((__pure__)) ;
#line 43
char const   *pch_name(enum nametype type )  __attribute__((__pure__)) ;
#line 44
_Bool pch_copy(void)  __attribute__((__pure__)) ;
#line 45
_Bool pch_rename(void)  __attribute__((__pure__)) ;
#line 46
void do_ed_script(char const   *inname___0 , char const   *outname , int *outname_needs_removal ,
                  FILE *ofp ) ;
#line 47
void open_patch_file(char const   *filename ) ;
#line 48
void re_patch(void) ;
#line 49
void set_hunkmax(void) ;
#line 52 "./pch.h"
struct timespec p_timestamp[2]  ;
#line 39 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static FILE *pfp  ;
#line 40 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static int p_says_nonexistent[2]  ;
#line 44 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static int p_rfc934_nesting  ;
#line 45 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char *p_name[3]  ;
#line 46 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char const   *invalid_names[2]  ;
#line 47 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
_Bool p_copy[2]  ;
#line 48 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
_Bool p_rename[2]  ;
#line 49 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char *p_timestr[2]  ;
#line 50 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char *p_sha1[2]  ;
#line 51 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static mode_t p_mode[2]  ;
#line 52 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static off_t p_filesize  ;
#line 53 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_first  ;
#line 54 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_newfirst  ;
#line 55 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_ptrn_lines  ;
#line 56 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_repl_lines  ;
#line 57 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_end  =    (lin )-1;
#line 58 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_max  ;
#line 59 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_prefix_context  ;
#line 60 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_suffix_context  ;
#line 61 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_input_line  ;
#line 62 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char **p_line  ;
#line 63 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static size_t *p_len  ;
#line 64 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char *p_Char  ;
#line 65 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin hunkmax  =    (lin )125;
#line 66 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static size_t p_indent  ;
#line 67 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static _Bool p_strip_trailing_cr  ;
#line 68 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static _Bool p_pass_comments_through  ;
#line 69 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static file_offset p_base  ;
#line 70 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_bline  ;
#line 71 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static file_offset p_start  ;
#line 72 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_sline  ;
#line 73 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_hunk_beg  ;
#line 74 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_efake  =    (lin )-1;
#line 75 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static lin p_bfake  =    (lin )-1;
#line 76 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char *p_c_function  ;
#line 77 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static _Bool p_git_diff  ;
#line 79
static char *scan_linenum(char *s0 , lin *linenum ) ;
#line 80
static enum diff intuit_diff_type(_Bool need_header , mode_t *p_file_type ) ;
#line 81
static enum nametype best_name(char * const  *name , int const   *ignore ) ;
#line 82
static int prefix_components(char *filename , _Bool checkdirs ) ;
#line 83
static size_t pget_line(size_t indent , int rfc934_nesting , _Bool strip_trailing_cr ,
                        _Bool pass_comments_through ) ;
#line 84
static size_t get_line(void) ;
#line 85
static _Bool incomplete_line(void) ;
#line 86
static _Bool grow_hunkmax(void) ;
#line 87
static  __attribute__((__noreturn__)) void malformed(void) ;
#line 88
static void next_intuit_at(file_offset file_pos , lin file_line ) ;
#line 89
static void skip_to(file_offset file_pos , lin file_line ) ;
#line 90
static char __attribute__((__pure__))  get_ed_command_letter(char const   *line ) ;
#line 94 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
void re_patch(void) 
{ 


  {
#line 97
  p_first = (lin )0;
#line 98
  p_newfirst = (lin )0;
#line 99
  p_ptrn_lines = (lin )0;
#line 100
  p_repl_lines = (lin )0;
#line 101
  p_end = (lin )-1;
#line 102
  p_max = (lin )0;
#line 103
  p_indent = (size_t )0;
#line 104
  p_strip_trailing_cr = (_Bool)0;
#line 105
  return;
}
}
#line 109 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
void open_patch_file(char const   *filename ) 
{ 
  file_offset file_pos ;
  file_offset pos ;
  struct stat st ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t charsread ;
  int fd ;
  int tmp___3 ;
  FILE *read_pfp ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 112
  file_pos = (file_offset )0;
#line 116
  if (! filename) {
#line 117
    pfp = stdin;
  } else
#line 116
  if (! *filename) {
#line 117
    pfp = stdin;
  } else {
    {
#line 116
    tmp___0 = strcmp(filename, "-");
    }
#line 116
    if (tmp___0) {
      {
#line 120
      pfp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
#line 121
      if (! pfp) {
        {
#line 122
        tmp = quotearg(filename);
#line 122
        pfatal("Can\'t open patch file %s", tmp);
        }
      }
    } else {
#line 117
      pfp = stdin;
    }
  }
  {
#line 132
  tmp___1 = fileno(pfp);
#line 132
  tmp___2 = fstat(tmp___1, & st);
  }
#line 132
  if (tmp___2 != 0) {
    {
#line 133
    pfatal("fstat");
    }
  }
#line 134
  if ((st.st_mode & 61440U) == 32768U) {
    {
#line 134
    pos = ftell(pfp);
    }
#line 134
    if (pos != -1L) {
#line 135
      file_pos = pos;
    } else {
#line 134
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 139
    tmp___3 = make_tempfile(& TMPPATNAME, (char )'p', (char const   *)((void *)0),
                            2, (mode_t )0);
#line 139
    fd = tmp___3;
#line 140
    read_pfp = pfp;
#line 141
    TMPPATNAME_needs_removal = 1;
#line 142
    pfp = fdopen(fd, "w+b");
    }
#line 143
    if (! pfp) {
      {
#line 144
      tmp___4 = quotearg(TMPPATNAME);
#line 144
      pfatal("Can\'t open stream for file %s", tmp___4);
      }
    }
#line 145
    st.st_size = (__off_t )0;
    {
#line 145
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 145
      charsread = fread((void */* __restrict  */)buf, (size_t )1, bufsize, (FILE */* __restrict  */)read_pfp);
      }
#line 145
      if (! (charsread != 0UL)) {
#line 145
        goto while_break;
      }
      {
#line 148
      tmp___5 = fwrite((void const   */* __restrict  */)buf, (size_t )1, charsread,
                       (FILE */* __restrict  */)pfp);
      }
#line 148
      if (tmp___5 != charsread) {
        {
#line 149
        write_fatal();
        }
      }
#line 145
      st.st_size = (__off_t )((size_t )st.st_size + charsread);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 150
    tmp___6 = ferror(read_pfp);
    }
#line 150
    if (tmp___6) {
      {
#line 151
      read_fatal();
      }
    } else {
      {
#line 150
      tmp___7 = fclose(read_pfp);
      }
#line 150
      if (tmp___7 != 0) {
        {
#line 151
        read_fatal();
        }
      }
    }
    {
#line 152
    tmp___8 = fflush(pfp);
    }
#line 152
    if (tmp___8 != 0) {
      {
#line 154
      write_fatal();
      }
    } else {
      {
#line 152
      tmp___9 = fseek(pfp, (file_offset )0, 0);
      }
#line 152
      if (tmp___9 != 0) {
        {
#line 154
        write_fatal();
        }
      }
    }
  }
#line 156
  p_filesize = st.st_size;
#line 157
  if (p_filesize != p_filesize) {
    {
#line 158
    fatal("patch file is too long");
    }
  }
  {
#line 159
  next_intuit_at(file_pos, (lin )1);
#line 160
  set_hunkmax();
  }
#line 161
  return;
}
}
#line 165 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
void set_hunkmax(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 168
  if (! p_line) {
    {
#line 169
    tmp = malloc((unsigned long )hunkmax * sizeof(*p_line));
#line 169
    p_line = (char **)tmp;
    }
  }
#line 170
  if (! p_len) {
    {
#line 171
    tmp___0 = malloc((unsigned long )hunkmax * sizeof(*p_len));
#line 171
    p_len = (size_t *)tmp___0;
    }
  }
#line 172
  if (! p_Char) {
    {
#line 173
    tmp___1 = malloc((unsigned long )hunkmax * sizeof(*p_Char));
#line 173
    p_Char = (char *)tmp___1;
    }
  }
#line 174
  return;
}
}
#line 178 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static _Bool grow_hunkmax(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 181
  hunkmax *= 2L;
#line 182
  if (p_line) {
#line 182
    if (p_len) {
#line 182
      if (! p_Char) {
        {
#line 182
        __assert_fail("p_line && p_len && p_Char", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                      182U, "grow_hunkmax");
        }
      }
    } else {
      {
#line 182
      __assert_fail("p_line && p_len && p_Char", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                    182U, "grow_hunkmax");
      }
    }
  } else {
    {
#line 182
    __assert_fail("p_line && p_len && p_Char", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                  182U, "grow_hunkmax");
    }
  }
  {
#line 183
  tmp = realloc((void *)p_line, (unsigned long )hunkmax * sizeof(*p_line));
#line 183
  p_line = (char **)tmp;
  }
#line 183
  if (p_line) {
    {
#line 183
    tmp___0 = realloc((void *)p_len, (unsigned long )hunkmax * sizeof(*p_len));
#line 183
    p_len = (size_t *)tmp___0;
    }
#line 183
    if (p_len) {
      {
#line 183
      tmp___1 = realloc((void *)p_Char, (unsigned long )hunkmax * sizeof(*p_Char));
#line 183
      p_Char = (char *)tmp___1;
      }
#line 183
      if (p_Char) {
#line 186
        return ((_Bool)1);
      }
    }
  }
#line 187
  if (! using_plan_a) {
    {
#line 188
    xalloc_die();
    }
  }
#line 193
  return ((_Bool)0);
}
}
#line 196 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static _Bool maybe_reverse(char const   *name , _Bool nonexistent , _Bool is_empty ) 
{ 
  _Bool looks_reversed ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  _Bool tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 199
  looks_reversed = (_Bool )(! is_empty < p_says_nonexistent[(int )reverse ^ (int )is_empty]);
#line 203
  if (is_empty) {
#line 203
    if (p_says_nonexistent[(int )reverse ^ (int )nonexistent] == 1) {
#line 203
      if (p_says_nonexistent[! reverse ^ (int )nonexistent] == 2) {
#line 206
        return ((_Bool)0);
      }
    }
  }
#line 208
  if (looks_reversed) {
#line 209
    if (nonexistent) {
#line 209
      tmp___0 = "does not exist";
    } else {
#line 209
      if (is_empty) {
#line 209
        tmp = "is already empty";
      } else {
#line 209
        tmp = "already exists";
      }
#line 209
      tmp___0 = tmp;
    }
    {
#line 209
    tmp___1 = quotearg(name);
    }
#line 209
    if (nonexistent) {
#line 209
      tmp___3 = "delete";
    } else {
#line 209
      if (is_empty) {
#line 209
        tmp___2 = "empty out";
      } else {
#line 209
        tmp___2 = "create";
      }
#line 209
      tmp___3 = tmp___2;
    }
#line 209
    if (reverse) {
#line 209
      tmp___4 = ", when reversed,";
    } else {
#line 209
      tmp___4 = "";
    }
    {
#line 209
    tmp___5 = ok_to_reverse("The next patch%s would %s the file %s,\nwhich %s!", tmp___4,
                            tmp___3, tmp___1, tmp___0);
#line 209
    reverse = (_Bool )((int )reverse ^ (int )tmp___5);
    }
  }
#line 219
  return (looks_reversed);
}
}
#line 224 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
_Bool there_is_another_patch(_Bool need_header , mode_t *file_type ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char numbuf[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *t ;
  size_t tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 227
  if (p_base != 0L) {
#line 227
    if (p_base >= p_filesize) {
#line 228
      if ((unsigned int )verbosity == 2U) {
        {
#line 229
        say("done\n");
        }
      }
#line 230
      return ((_Bool)0);
    }
  }
#line 232
  if ((unsigned int )verbosity == 2U) {
    {
#line 233
    say("Hmm...");
    }
  }
  {
#line 234
  diff_type = intuit_diff_type(need_header, file_type);
  }
#line 235
  if ((unsigned int )diff_type == 0U) {
#line 236
    if ((unsigned int )verbosity == 2U) {
#line 237
      if (p_base) {
#line 237
        tmp = "  Ignoring the trailing garbage.\ndone\n";
      } else {
#line 237
        tmp = "  I can\'t seem to find a patch in there anywhere.\n";
      }
      {
#line 237
      say(tmp);
      }
    }
#line 240
    if (! p_base) {
#line 240
      if (p_filesize) {
        {
#line 241
        fatal("Only garbage was found in the patch input.");
        }
      }
    }
#line 242
    return ((_Bool)0);
  }
#line 244
  if (skip_rest_of_patch) {
    {
#line 246
    Fseek(pfp, p_start, 0);
#line 247
    p_input_line = p_sline - 1L;
    }
#line 248
    return ((_Bool)1);
  }
#line 250
  if ((unsigned int )verbosity == 2U) {
#line 251
    if ((unsigned int )diff_type == 5U) {
#line 251
      tmp___4 = "a unified diff";
    } else {
#line 251
      if ((unsigned int )diff_type == 1U) {
#line 251
        tmp___3 = "a context diff";
      } else {
#line 251
        if ((unsigned int )diff_type == 4U) {
#line 251
          tmp___2 = "a new-style context diff";
        } else {
#line 251
          if ((unsigned int )diff_type == 2U) {
#line 251
            tmp___1 = "a normal diff";
          } else {
#line 251
            if ((unsigned int )diff_type == 6U) {
#line 251
              tmp___0 = "a git binary diff";
            } else {
#line 251
              tmp___0 = "an ed script";
            }
#line 251
            tmp___1 = tmp___0;
          }
#line 251
          tmp___2 = tmp___1;
        }
#line 251
        tmp___3 = tmp___2;
      }
#line 251
      tmp___4 = tmp___3;
    }
#line 251
    if (p_base == 0L) {
#line 251
      tmp___5 = "L";
    } else {
#line 251
      tmp___5 = "The next patch l";
    }
    {
#line 251
    say("  %sooks like %s to me...\n", tmp___5, tmp___4);
    }
  }
#line 260
  if (no_strip_trailing_cr) {
#line 261
    p_strip_trailing_cr = (_Bool)0;
  }
#line 263
  if ((unsigned int )verbosity != 1U) {
#line 265
    if (p_indent) {
#line 266
      if (p_indent == 1UL) {
#line 266
        tmp___6 = "";
      } else {
#line 266
        tmp___6 = "s";
      }
      {
#line 266
      say("(Patch is indented %lu space%s.)\n", p_indent, tmp___6);
      }
    }
#line 268
    if (p_strip_trailing_cr) {
      {
#line 269
      say("(Stripping trailing CRs from patch.)\n");
      }
    }
#line 270
    if (! inname) {
      {
#line 273
      tmp___7 = format_linenum((char *)(numbuf), p_sline);
#line 273
      say("can\'t find file to patch at input line %s\n", tmp___7);
      }
#line 275
      if ((unsigned int )diff_type != 3U) {
#line 275
        if ((unsigned int )diff_type != 2U) {
#line 276
          if (strippath == -1) {
#line 276
            tmp___8 = "Perhaps you should have used the -p or --strip option?\n";
          } else {
#line 276
            tmp___8 = "Perhaps you used the wrong -p or --strip option?\n";
          }
          {
#line 276
          say(tmp___8);
          }
        }
      }
    }
  }
  {
#line 282
  skip_to(p_start, p_sline);
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (! inname)) {
#line 283
      goto while_break;
    }
#line 285
    if ((int )force | (int )batch) {
      {
#line 286
      say("No file to patch.  Skipping patch.\n");
#line 287
      skip_rest_of_patch = (_Bool)1;
      }
#line 288
      return ((_Bool)1);
    }
    {
#line 290
    ask("File to patch: ");
#line 291
    tmp___9 = strlen((char const   *)buf);
#line 291
    t = buf + tmp___9;
    }
#line 292
    if ((unsigned long )t > (unsigned long )(buf + 1)) {
#line 292
      if ((int )*(t - 1) == 10) {
        {
#line 294
        inname = savebuf((char const   *)buf, (size_t )(t - buf));
#line 295
        *(inname + ((t - buf) - 1L)) = (char)0;
#line 296
        tmp___10 = lstat((char const   */* __restrict  */)inname, (struct stat */* __restrict  */)(& instat));
        }
#line 296
        if (tmp___10 == 0) {
#line 298
          inerrno = 0;
#line 299
          invc = -1;
        } else {
          {
#line 303
          perror((char const   *)inname);
#line 304
          fflush(stderr);
#line 305
          free((void *)inname);
#line 306
          inname = (char *)0;
          }
        }
      }
    }
#line 309
    if (! inname) {
      {
#line 310
      ask("Skip this patch? [y] ");
      }
#line 311
      if ((int )*buf != 110) {
#line 312
        if ((unsigned int )verbosity != 1U) {
          {
#line 313
          say("Skipping patch.\n");
          }
        }
#line 314
        skip_rest_of_patch = (_Bool)1;
#line 315
        return ((_Bool)1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return ((_Bool)1);
}
}
#line 322 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static mode_t __attribute__((__pure__))  fetchmode(char const   *str ) 
{ 
  char const   *s ;
  mode_t mode ;
  unsigned short const   **tmp ;

  {
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 328
    tmp = __ctype_b_loc();
    }
#line 328
    if (! ((int const   )*(*tmp + (int )((unsigned char )*str)) & 8192)) {
#line 328
      goto while_break;
    }
#line 329
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  s = str;
#line 331
  mode = (mode_t )0;
  {
#line 331
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 331
    if (! ((unsigned long )s < (unsigned long )(str + 6))) {
#line 331
      goto while_break___0;
    }
#line 333
    if ((int const   )*s >= 48) {
#line 333
      if ((int const   )*s <= 55) {
#line 334
        mode = (mode << 3) + (mode_t )((int const   )*s - 48);
      } else {
#line 337
        mode = (mode_t )0;
#line 338
        goto while_break___0;
      }
    } else {
#line 337
      mode = (mode_t )0;
#line 338
      goto while_break___0;
    }
#line 331
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 341
  if ((int const   )*s == 13) {
#line 342
    s ++;
  }
#line 343
  if ((int const   )*s != 10) {
#line 344
    mode = (mode_t )0;
  }
#line 350
  return ((mode_t __attribute__((__pure__))  )mode);
}
}
#line 353 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static void get_sha1(char **sha1 , char const   *start , char const   *end ) 
{ 
  unsigned int len ;
  void *tmp ;

  {
  {
#line 356
  len = (unsigned int )(end - start);
#line 357
  tmp = xmalloc((size_t )(len + 1U));
#line 357
  *sha1 = (char *)tmp;
#line 358
  memcpy((void */* __restrict  */)*sha1, (void const   */* __restrict  */)start, (size_t )len);
#line 359
  *(*sha1 + len) = (char)0;
  }
#line 360
  return;
}
}
#line 362 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static int __attribute__((__pure__))  sha1_says_nonexistent(char const   *sha1 ) 
{ 
  char const   *empty_sha1 ;
  char const   *s ;
  char *__cil_tmp4 ;

  {
#line 365
  empty_sha1 = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
#line 369
  s = sha1;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! *s) {
#line 369
      goto while_break;
    }
#line 370
    if ((int const   )*s != 48) {
#line 371
      goto while_break;
    }
#line 369
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (! *s) {
#line 373
    return ((int __attribute__((__pure__))  )2);
  }
#line 376
  s = sha1;
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    if (! *s) {
#line 376
      goto while_break___0;
    }
#line 377
    if ((int const   )*s != (int const   )*empty_sha1) {
#line 378
      goto while_break___0;
    }
#line 376
    s ++;
#line 376
    empty_sha1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 379
  return ((int __attribute__((__pure__))  )(! *s));
}
}
#line 382 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char const   * __attribute__((__pure__)) skip_hex_digits(char const   *str ) 
{ 
  char const   *s ;
  char const   *tmp ;

  {
#line 387
  s = str;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if ((int const   )*s >= 48) {
#line 387
      if (! ((int const   )*s <= 57)) {
#line 387
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 387
    if ((int const   )*s >= 97) {
#line 387
      if (! ((int const   )*s <= 102)) {
#line 387
        goto while_break;
      }
    } else {
#line 387
      goto while_break;
    }
#line 387
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if ((unsigned long )s == (unsigned long )str) {
#line 389
    tmp = (char const   *)((void *)0);
  } else {
#line 389
    tmp = s;
  }
#line 389
  return ((char const   */* __attribute__((__pure__)) */)tmp);
}
}
#line 392 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static _Bool name_is_valid(char const   *name ) 
{ 
  char const   *n ;
  int i ;
  _Bool is_valid ;
  int tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 397
  is_valid = (_Bool)1;
#line 399
  i = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! ((unsigned long )i < sizeof(invalid_names) / sizeof(invalid_names[0]))) {
#line 399
      goto while_break;
    }
#line 401
    if (! invalid_names[i]) {
#line 402
      goto while_break;
    }
    {
#line 403
    tmp = strcmp(invalid_names[i], name);
    }
#line 403
    if (! tmp) {
#line 404
      return ((_Bool)0);
    }
#line 399
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  if ((int const   )*(name + 0) == 47) {
#line 408
    is_valid = (_Bool)0;
  } else {
#line 410
    n = name;
    {
#line 410
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 410
      if (! *n) {
#line 410
        goto while_break___0;
      }
#line 412
      if ((int const   )*n == 46) {
#line 412
        n ++;
#line 412
        if ((int const   )*n == 46) {
#line 412
          n ++;
#line 412
          if (*n) {
#line 412
            if ((int const   )*n == 47) {
#line 414
              is_valid = (_Bool)0;
#line 415
              goto while_break___0;
            }
          } else {
#line 414
            is_valid = (_Bool)0;
#line 415
            goto while_break___0;
          }
        }
      }
      {
#line 417
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 417
        if (*n) {
#line 417
          if (! (! ((int const   )*n == 47))) {
#line 417
            goto while_break___1;
          }
        } else {
#line 417
          goto while_break___1;
        }
#line 418
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 419
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 419
        if (! ((int const   )*n == 47)) {
#line 419
          goto while_break___2;
        }
#line 420
        n ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 423
  if (! is_valid) {
    {
#line 425
    tmp___0 = quotearg(name);
#line 425
    say("Ignoring potentially dangerous file name %s\n", tmp___0);
    }
#line 426
    if ((unsigned long )i < sizeof(invalid_names) / sizeof(invalid_names[0])) {
#line 427
      invalid_names[i] = name;
    }
  }
#line 429
  return (is_valid);
}
}
#line 434 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static enum diff intuit_diff_type(_Bool need_header , mode_t *p_file_type ) 
{ 
  file_offset this_line ;
  file_offset first_command_line ;
  char first_ed_command_letter ;
  lin fcl_line ;
  _Bool this_is_a_command ;
  _Bool stars_this_line ;
  _Bool extended_headers ;
  enum nametype i ;
  struct stat st[3] ;
  int stat_errno[3] ;
  int version_controlled[3] ;
  enum diff retval ;
  mode_t file_type ;
  char *s ;
  char *t ;
  file_offset previous_line ;
  _Bool last_line_was_command ;
  _Bool stars_last_line ;
  size_t indent ;
  char ed_command_letter ;
  _Bool strip_trailing_cr ;
  size_t chars_read ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char const   *u ;
  unsigned short const   **tmp___1 ;
  char numbuf[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char oldc ;
  char const   *u___0 ;
  unsigned short const   **tmp___4 ;
  char const   * __attribute__((__pure__)) tmp___5 ;
  char const   *u___1 ;
  char const   *v ;
  int __attribute__((__pure__))  tmp___6 ;
  int __attribute__((__pure__))  tmp___7 ;
  mode_t __attribute__((__pure__))  tmp___8 ;
  char const   * __attribute__((__pure__)) tmp___9 ;
  char const   * __attribute__((__pure__)) tmp___10 ;
  char const   * __attribute__((__pure__)) tmp___11 ;
  unsigned short const   **tmp___12 ;
  mode_t __attribute__((__pure__))  tmp___13 ;
  mode_t __attribute__((__pure__))  tmp___14 ;
  mode_t __attribute__((__pure__))  tmp___15 ;
  mode_t __attribute__((__pure__))  tmp___16 ;
  struct timespec timestamp ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  struct timespec ti ;
  char numbuf___0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  file_offset saved_p_base ;
  lin saved_p_bline ;
  int tmp___38 ;
  char numbuf___1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  mode_t new_file_type ;
  enum nametype i0 ;
  int *tmp___43 ;
  _Bool tmp___44 ;
  enum file_id_type tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  enum nametype nope ;
  char const   *cs ;
  char *getbuf ;
  char *diffbuf ;
  _Bool readonly ;
  int tmp___48 ;
  int tmp___49 ;
  _Bool tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  unsigned int tmp___53 ;
  _Bool tmp___54 ;
  int newdirs[3] ;
  int newdirs_min ;
  int distance_from_minimum[3] ;
  int tmp___55 ;
  int tmp___56 ;
  int *tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  void *__cil_tmp109 ;
  int __cil_tmp110 ;
  void *__cil_tmp111 ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;
  void *__cil_tmp115 ;
  void *__cil_tmp116 ;
  void *__cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;
  void *__cil_tmp121 ;
  void *__cil_tmp122 ;
  void *__cil_tmp123 ;
  void *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;

  {
#line 437
  this_line = (file_offset )0;
#line 438
  first_command_line = (file_offset )-1;
#line 439
  first_ed_command_letter = (char)0;
#line 440
  fcl_line = (lin )0;
#line 441
  this_is_a_command = (_Bool)0;
#line 442
  stars_this_line = (_Bool)0;
#line 443
  extended_headers = (_Bool)0;
#line 451
  i = (enum nametype )0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! ((unsigned int )i <= 2U)) {
#line 451
      goto while_break;
    }
#line 452
    if (p_name[i]) {
      {
#line 453
      free((void *)p_name[i]);
#line 454
      p_name[i] = (char *)0;
      }
    }
#line 451
    i = (enum nametype )((unsigned int )i + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  i = (enum nametype )0;
  {
#line 456
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 456
    if (! ((unsigned long )i < sizeof(invalid_names) / sizeof(invalid_names[0]))) {
#line 456
      goto while_break___0;
    }
#line 457
    invalid_names[i] = (char const   *)((void *)0);
#line 456
    i = (enum nametype )((unsigned int )i + 1U);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 458
  i = (enum nametype )0;
  {
#line 458
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 458
    if (! ((unsigned int )i <= 1U)) {
#line 458
      goto while_break___1;
    }
#line 459
    if (p_timestr[i]) {
      {
#line 461
      free((void *)p_timestr[i]);
#line 462
      p_timestr[i] = (char *)0;
      }
    }
#line 458
    i = (enum nametype )((unsigned int )i + 1U);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 464
  i = (enum nametype )0;
  {
#line 464
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 464
    if (! ((unsigned int )i <= 1U)) {
#line 464
      goto while_break___2;
    }
#line 465
    if (p_sha1[i]) {
      {
#line 467
      free((void *)p_sha1[i]);
#line 468
      p_sha1[i] = (char *)0;
      }
    }
#line 464
    i = (enum nametype )((unsigned int )i + 1U);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 470
  p_git_diff = (_Bool)0;
#line 471
  i = (enum nametype )0;
  {
#line 471
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 471
    if (! ((unsigned int )i <= 1U)) {
#line 471
      goto while_break___3;
    }
#line 473
    p_mode[i] = (mode_t )0;
#line 474
    p_copy[i] = (_Bool)0;
#line 475
    p_rename[i] = (_Bool)0;
#line 471
    i = (enum nametype )((unsigned int )i + 1U);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 479
  if ((unsigned int )diff_type == 3U) {
#line 480
    need_header = (_Bool)0;
  } else
#line 479
  if ((unsigned int )diff_type == 2U) {
#line 480
    need_header = (_Bool)0;
  }
  {
#line 482
  version_controlled[0] = -1;
#line 483
  version_controlled[1] = -1;
#line 484
  version_controlled[2] = -1;
#line 485
  p_rfc934_nesting = 0;
#line 486
  p_timestamp[1].tv_sec = (__time_t )-1;
#line 486
  p_timestamp[0].tv_sec = p_timestamp[1].tv_sec;
#line 487
  p_says_nonexistent[1] = 0;
#line 487
  p_says_nonexistent[0] = p_says_nonexistent[1];
#line 488
  Fseek(pfp, p_base, 0);
#line 489
  p_input_line = p_bline - 1L;
  }
  {
#line 490
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 493
    previous_line = this_line;
#line 494
    last_line_was_command = this_is_a_command;
#line 495
    stars_last_line = stars_this_line;
#line 496
    indent = (size_t )0;
#line 501
    this_line = ftell(pfp);
#line 502
    chars_read = pget_line((size_t )0, 0, (_Bool)0, (_Bool)0);
    }
#line 503
    if (chars_read == 0xffffffffffffffffUL) {
      {
#line 504
      xalloc_die();
      }
    }
#line 505
    if (! chars_read) {
#line 506
      if (first_ed_command_letter) {
#line 508
        p_start = first_command_line;
#line 509
        p_sline = fcl_line;
#line 510
        retval = (enum diff )3;
#line 511
        goto scan_exit;
      } else {
#line 514
        p_start = this_line;
#line 515
        p_sline = p_input_line;
#line 516
        if (extended_headers) {
#line 519
          retval = (enum diff )5;
#line 520
          goto scan_exit;
        }
#line 522
        return ((enum diff )0);
      }
    }
#line 525
    if (2UL <= chars_read) {
#line 525
      if ((int )*(buf + (chars_read - 2UL)) == 13) {
#line 525
        tmp = 1;
      } else {
#line 525
        tmp = 0;
      }
    } else {
#line 525
      tmp = 0;
    }
#line 525
    strip_trailing_cr = (_Bool )tmp;
#line 526
    s = buf;
    {
#line 526
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 526
      if (! ((int )*s == 32)) {
#line 526
        if (! ((int )*s == 9)) {
#line 526
          if (! ((int )*s == 88)) {
#line 526
            goto while_break___5;
          }
        }
      }
#line 527
      if ((int )*s == 9) {
#line 528
        indent = (indent + 8UL) & 0xfffffffffffffff8UL;
      } else {
#line 530
        indent ++;
      }
#line 526
      s ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 532
    if ((unsigned int )*s - 48U <= 9U) {
#line 534
      t = s + 1;
      {
#line 534
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 534
        if (! ((unsigned int )*t - 48U <= 9U)) {
#line 534
          if (! ((int )*t == 44)) {
#line 534
            goto while_break___6;
          }
        }
#line 534
        t ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 536
      if ((int )*t == 100) {
#line 536
        goto _L;
      } else
#line 536
      if ((int )*t == 99) {
#line 536
        goto _L;
      } else
#line 536
      if ((int )*t == 97) {
        _L: /* CIL Label */ 
#line 538
        t ++;
        {
#line 538
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 538
          if (! ((unsigned int )*t - 48U <= 9U)) {
#line 538
            if (! ((int )*t == 44)) {
#line 538
              goto while_break___7;
            }
          }
#line 538
          t ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 540
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 540
          if (! ((int )*t == 32)) {
#line 540
            if (! ((int )*t == 9)) {
#line 540
              goto while_break___8;
            }
          }
#line 540
          t ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 542
        if ((int )*t == 13) {
#line 543
          t ++;
        }
#line 544
        this_is_a_command = (_Bool )((int )*t == 10);
      }
    }
#line 547
    if (! need_header) {
#line 547
      if (first_command_line < 0L) {
        {
#line 547
        ed_command_letter = (char )get_ed_command_letter((char const   *)s);
        }
#line 547
        if (ed_command_letter) {
#line 551
          first_command_line = this_line;
#line 552
          first_ed_command_letter = ed_command_letter;
#line 553
          fcl_line = p_input_line;
#line 554
          p_indent = indent;
#line 555
          p_strip_trailing_cr = strip_trailing_cr;
        } else
#line 547
        if (this_is_a_command) {
#line 551
          first_command_line = this_line;
#line 552
          first_ed_command_letter = ed_command_letter;
#line 553
          fcl_line = p_input_line;
#line 554
          p_indent = indent;
#line 555
          p_strip_trailing_cr = strip_trailing_cr;
        }
      }
    }
#line 557
    if (! stars_last_line) {
      {
#line 557
      tmp___32 = strncmp((char const   *)s, "*** ", (size_t )4);
      }
#line 557
      if (tmp___32) {
#line 557
        goto _L___14;
      } else {
        {
#line 559
        fetchname((char const   *)(s + 4), strippath, & p_name[0], & p_timestr[0],
                  & p_timestamp[0]);
#line 561
        need_header = (_Bool)0;
        }
      }
    } else {
      _L___14: /* CIL Label */ 
      {
#line 563
      tmp___31 = strncmp((char const   *)s, "+++ ", (size_t )4);
      }
#line 563
      if (tmp___31) {
        {
#line 571
        tmp___30 = strncmp((char const   *)s, "Index:", (size_t )6);
        }
#line 571
        if (tmp___30) {
          {
#line 577
          tmp___29 = strncmp((char const   *)s, "Prereq:", (size_t )7);
          }
#line 577
          if (tmp___29) {
            {
#line 605
            tmp___28 = strncmp((char const   *)s, "diff --git ", (size_t )11);
            }
#line 605
            if (tmp___28) {
#line 634
              if (p_git_diff) {
                {
#line 634
                tmp___27 = strncmp((char const   *)s, "index ", (size_t )6);
                }
#line 634
                if (tmp___27) {
#line 634
                  goto _L___13;
                } else {
                  {
#line 637
                  tmp___10 = skip_hex_digits((char const   *)(s + 6));
#line 637
                  u___1 = (char const   *)tmp___10;
                  }
#line 637
                  if (u___1) {
#line 637
                    if ((int const   )*(u___1 + 0) == 46) {
#line 637
                      if ((int const   )*(u___1 + 1) == 46) {
                        {
#line 637
                        tmp___11 = skip_hex_digits(u___1 + 2);
#line 637
                        v = (char const   *)tmp___11;
                        }
#line 637
                        if (v) {
#line 637
                          if (! *v) {
#line 637
                            goto _L___3;
                          } else {
                            {
#line 637
                            tmp___12 = __ctype_b_loc();
                            }
#line 637
                            if ((int const   )*(*tmp___12 + (int )((unsigned char )*v)) & 8192) {
                              _L___3: /* CIL Label */ 
                              {
#line 642
                              get_sha1(& p_sha1[0], (char const   *)(s + 6), u___1);
#line 643
                              get_sha1(& p_sha1[1], u___1 + 2, v);
#line 644
                              tmp___6 = sha1_says_nonexistent((char const   *)p_sha1[0]);
#line 644
                              p_says_nonexistent[0] = (int )tmp___6;
#line 645
                              tmp___7 = sha1_says_nonexistent((char const   *)p_sha1[1]);
#line 645
                              p_says_nonexistent[1] = (int )tmp___7;
#line 646
                              tmp___9 = skip_spaces(v);
#line 646
                              v = (char const   *)tmp___9;
                              }
#line 646
                              if (*v) {
                                {
#line 647
                                tmp___8 = fetchmode(v);
#line 647
                                p_mode[1] = (mode_t )tmp___8;
#line 647
                                p_mode[0] = p_mode[1];
                                }
                              }
#line 648
                              extended_headers = (_Bool)1;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else
              _L___13: /* CIL Label */ 
#line 651
              if (p_git_diff) {
                {
#line 651
                tmp___26 = strncmp((char const   *)s, "old mode ", (size_t )9);
                }
#line 651
                if (tmp___26) {
#line 651
                  goto _L___12;
                } else {
                  {
#line 653
                  tmp___13 = fetchmode((char const   *)(s + 9));
#line 653
                  p_mode[0] = (mode_t )tmp___13;
#line 654
                  extended_headers = (_Bool)1;
                  }
                }
              } else
              _L___12: /* CIL Label */ 
#line 656
              if (p_git_diff) {
                {
#line 656
                tmp___25 = strncmp((char const   *)s, "new mode ", (size_t )9);
                }
#line 656
                if (tmp___25) {
#line 656
                  goto _L___11;
                } else {
                  {
#line 658
                  tmp___14 = fetchmode((char const   *)(s + 9));
#line 658
                  p_mode[1] = (mode_t )tmp___14;
#line 659
                  extended_headers = (_Bool)1;
                  }
                }
              } else
              _L___11: /* CIL Label */ 
#line 661
              if (p_git_diff) {
                {
#line 661
                tmp___24 = strncmp((char const   *)s, "deleted file mode ", (size_t )18);
                }
#line 661
                if (tmp___24) {
#line 661
                  goto _L___10;
                } else {
                  {
#line 663
                  tmp___15 = fetchmode((char const   *)(s + 18));
#line 663
                  p_mode[0] = (mode_t )tmp___15;
#line 664
                  p_says_nonexistent[1] = 2;
#line 665
                  extended_headers = (_Bool)1;
                  }
                }
              } else
              _L___10: /* CIL Label */ 
#line 667
              if (p_git_diff) {
                {
#line 667
                tmp___23 = strncmp((char const   *)s, "new file mode ", (size_t )14);
                }
#line 667
                if (tmp___23) {
#line 667
                  goto _L___9;
                } else {
                  {
#line 669
                  tmp___16 = fetchmode((char const   *)(s + 14));
#line 669
                  p_mode[1] = (mode_t )tmp___16;
#line 670
                  p_says_nonexistent[0] = 2;
#line 671
                  extended_headers = (_Bool)1;
                  }
                }
              } else
              _L___9: /* CIL Label */ 
#line 673
              if (p_git_diff) {
                {
#line 673
                tmp___22 = strncmp((char const   *)s, "rename from ", (size_t )12);
                }
#line 673
                if (tmp___22) {
#line 673
                  goto _L___8;
                } else {
#line 677
                  p_rename[0] = (_Bool)1;
#line 678
                  extended_headers = (_Bool)1;
                }
              } else
              _L___8: /* CIL Label */ 
#line 680
              if (p_git_diff) {
                {
#line 680
                tmp___21 = strncmp((char const   *)s, "rename to ", (size_t )10);
                }
#line 680
                if (tmp___21) {
#line 680
                  goto _L___7;
                } else {
#line 684
                  p_rename[1] = (_Bool)1;
#line 685
                  extended_headers = (_Bool)1;
                }
              } else
              _L___7: /* CIL Label */ 
#line 687
              if (p_git_diff) {
                {
#line 687
                tmp___20 = strncmp((char const   *)s, "copy from ", (size_t )10);
                }
#line 687
                if (tmp___20) {
#line 687
                  goto _L___6;
                } else {
#line 691
                  p_copy[0] = (_Bool)1;
#line 692
                  extended_headers = (_Bool)1;
                }
              } else
              _L___6: /* CIL Label */ 
#line 694
              if (p_git_diff) {
                {
#line 694
                tmp___19 = strncmp((char const   *)s, "copy to ", (size_t )8);
                }
#line 694
                if (tmp___19) {
#line 694
                  goto _L___5;
                } else {
#line 698
                  p_copy[1] = (_Bool)1;
#line 699
                  extended_headers = (_Bool)1;
                }
              } else
              _L___5: /* CIL Label */ 
#line 701
              if (p_git_diff) {
                {
#line 701
                tmp___18 = strncmp((char const   *)s, "GIT binary patch", (size_t )16);
                }
#line 701
                if (tmp___18) {
#line 701
                  goto _L___4;
                } else {
#line 703
                  p_start = this_line;
#line 704
                  p_sline = p_input_line;
#line 705
                  retval = (enum diff )6;
#line 706
                  goto scan_exit;
                }
              } else {
                _L___4: /* CIL Label */ 
#line 710
                t = s;
                {
#line 710
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 710
                  if ((int )*(t + 0) == 45) {
#line 710
                    if (! ((int )*(t + 1) == 32)) {
#line 710
                      goto while_break___9;
                    }
                  } else {
#line 710
                    goto while_break___9;
                  }
#line 710
                  t += 2;
                }
                while_break___9: /* CIL Label */ ;
                }
                {
#line 712
                tmp___17 = strncmp((char const   *)t, "--- ", (size_t )4);
                }
#line 712
                if (! tmp___17) {
                  {
#line 715
                  timestamp.tv_sec = (__time_t )-1;
#line 716
                  fetchname((char const   *)(t + 4), strippath, & p_name[1], & p_timestr[1],
                            & timestamp);
#line 718
                  need_header = (_Bool)0;
                  }
#line 719
                  if (timestamp.tv_sec != -1L) {
#line 721
                    p_timestamp[1] = timestamp;
#line 722
                    p_rfc934_nesting = (int )((t - s) >> 1);
                  }
#line 724
                  p_strip_trailing_cr = strip_trailing_cr;
                }
              }
            } else {
#line 609
              if (extended_headers) {
#line 611
                p_start = this_line;
#line 612
                p_sline = p_input_line;
#line 614
                retval = (enum diff )5;
#line 615
                goto scan_exit;
              }
#line 618
              i = (enum nametype )0;
              {
#line 618
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 618
                if (! ((unsigned int )i <= 1U)) {
#line 618
                  goto while_break___10;
                }
                {
#line 620
                free((void *)p_name[i]);
#line 621
                p_name[i] = (char *)0;
#line 618
                i = (enum nametype )((unsigned int )i + 1U);
                }
              }
              while_break___10: /* CIL Label */ ;
              }
              {
#line 623
              p_name[0] = parse_name((char const   *)(s + 11), strippath, & u___0);
              }
#line 623
              if (p_name[0]) {
                {
#line 623
                tmp___4 = __ctype_b_loc();
                }
#line 623
                if ((int const   )*(*tmp___4 + (int )((unsigned char )*u___0)) & 8192) {
                  {
#line 623
                  p_name[1] = parse_name(u___0, strippath, & u___0);
                  }
#line 623
                  if (p_name[1]) {
                    {
#line 623
                    tmp___5 = skip_spaces(u___0);
#line 623
                    u___0 = (char const   *)tmp___5;
                    }
#line 623
                    if (! (! *u___0)) {
#line 623
                      goto _L___2;
                    }
                  } else {
#line 623
                    goto _L___2;
                  }
                } else {
#line 623
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
#line 627
                i = (enum nametype )0;
                {
#line 627
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 627
                  if (! ((unsigned int )i <= 1U)) {
#line 627
                    goto while_break___11;
                  }
                  {
#line 629
                  free((void *)p_name[i]);
#line 630
                  p_name[i] = (char *)0;
#line 627
                  i = (enum nametype )((unsigned int )i + 1U);
                  }
                }
                while_break___11: /* CIL Label */ ;
                }
              }
#line 632
              p_git_diff = (_Bool)1;
            }
          } else {
#line 579
            t = s + 7;
            {
#line 579
            while (1) {
              while_continue___12: /* CIL Label */ ;
              {
#line 579
              tmp___0 = __ctype_b_loc();
              }
#line 579
              if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*t)) & 8192)) {
#line 579
                goto while_break___12;
              }
#line 579
              t ++;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 581
            revision = t;
#line 582
            t = revision;
            {
#line 582
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 582
              if (! *t) {
#line 582
                goto while_break___13;
              }
              {
#line 583
              tmp___3 = __ctype_b_loc();
              }
#line 583
              if ((int const   )*(*tmp___3 + (int )((unsigned char )*t)) & 8192) {
#line 586
                u = (char const   *)(t + 1);
                {
#line 586
                while (1) {
                  while_continue___14: /* CIL Label */ ;
                  {
#line 586
                  tmp___1 = __ctype_b_loc();
                  }
#line 586
                  if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*u)) & 8192)) {
#line 586
                    goto while_break___14;
                  }
#line 586
                  u ++;
                }
                while_break___14: /* CIL Label */ ;
                }
#line 588
                if (*u) {
                  {
#line 591
                  tmp___2 = format_linenum((char *)(numbuf), this_line);
#line 591
                  say("Prereq: with multiple words at line %s of patch\n", tmp___2);
                  }
                }
#line 594
                goto while_break___13;
              }
#line 582
              t ++;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 596
            if ((unsigned long )t == (unsigned long )revision) {
#line 597
              revision = (char *)0;
            } else {
              {
#line 599
              oldc = *t;
#line 600
              *t = (char )'\000';
#line 601
              revision = savestr((char const   *)revision);
#line 602
              *t = oldc;
              }
            }
          }
        } else {
          {
#line 573
          fetchname((char const   *)(s + 6), strippath, & p_name[2], (char **)0, (struct timespec *)((void *)0));
#line 574
          need_header = (_Bool)0;
#line 575
          p_strip_trailing_cr = strip_trailing_cr;
          }
        }
      } else {
        {
#line 566
        fetchname((char const   *)(s + 4), strippath, & p_name[0], & p_timestr[0],
                  & p_timestamp[0]);
#line 568
        need_header = (_Bool)0;
#line 569
        p_strip_trailing_cr = strip_trailing_cr;
        }
      }
    }
#line 727
    if (need_header) {
#line 728
      goto __Cont;
    }
#line 729
    if ((unsigned int )diff_type == 0U) {
#line 729
      goto _L___15;
    } else
#line 729
    if ((unsigned int )diff_type == 3U) {
      _L___15: /* CIL Label */ 
#line 729
      if (first_command_line >= 0L) {
        {
#line 729
        tmp___33 = strcmp((char const   *)s, ".\n");
        }
#line 729
        if (! tmp___33) {
#line 732
          p_start = first_command_line;
#line 733
          p_sline = fcl_line;
#line 734
          retval = (enum diff )3;
#line 735
          goto scan_exit;
        }
      }
    }
#line 737
    if ((unsigned int )diff_type == 0U) {
#line 737
      goto _L___18;
    } else
#line 737
    if ((unsigned int )diff_type == 5U) {
      _L___18: /* CIL Label */ 
      {
#line 737
      tmp___35 = strncmp((char const   *)s, "@@ -", (size_t )4);
      }
#line 737
      if (! tmp___35) {
#line 742
        ti = p_timestamp[0];
#line 743
        p_timestamp[0] = p_timestamp[1];
#line 744
        p_timestamp[1] = ti;
#line 745
        t = p_name[0];
#line 746
        p_name[0] = p_name[1];
#line 747
        p_name[1] = t;
#line 748
        t = p_timestr[0];
#line 749
        p_timestr[0] = p_timestr[1];
#line 750
        p_timestr[1] = t;
#line 752
        s += 4;
#line 753
        if ((int )*(s + 0) == 48) {
#line 753
          if (! ((unsigned int )*(s + 1) - 48U <= 9U)) {
#line 754
            p_says_nonexistent[0] = 1 + ! p_timestamp[0].tv_sec;
          }
        }
        {
#line 755
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 755
          if ((int )*s != 32) {
#line 755
            if (! ((int )*s != 10)) {
#line 755
              goto while_break___15;
            }
          } else {
#line 755
            goto while_break___15;
          }
#line 756
          s ++;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
#line 757
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 757
          if (! ((int )*s == 32)) {
#line 757
            goto while_break___16;
          }
#line 758
          s ++;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 759
        if ((int )*(s + 0) == 43) {
#line 759
          if ((int )*(s + 1) == 48) {
#line 759
            if (! ((unsigned int )*(s + 2) - 48U <= 9U)) {
#line 760
              p_says_nonexistent[1] = 1 + ! p_timestamp[1].tv_sec;
            }
          }
        }
#line 761
        p_indent = indent;
#line 762
        p_start = this_line;
#line 763
        p_sline = p_input_line;
#line 764
        retval = (enum diff )5;
#line 765
        if (p_name[0]) {
#line 765
          goto _L___17;
        } else
#line 765
        if (! p_timestamp[0].tv_sec) {
          _L___17: /* CIL Label */ 
#line 765
          if (! p_name[1]) {
#line 765
            if (! (! p_timestamp[1].tv_sec)) {
#line 765
              goto _L___16;
            }
          }
        } else
        _L___16: /* CIL Label */ 
#line 765
        if (! p_name[2]) {
#line 765
          if (need_header) {
            {
#line 770
            tmp___34 = format_linenum((char *)(numbuf___0), p_sline);
#line 770
            say("missing header for unified diff at line %s of patch\n", tmp___34);
            }
          }
        }
#line 773
        goto scan_exit;
      }
    }
    {
#line 775
    tmp___36 = strncmp((char const   *)s, "********", (size_t )8);
    }
#line 775
    if (tmp___36) {
#line 775
      tmp___37 = 0;
    } else {
#line 775
      tmp___37 = 1;
    }
#line 775
    stars_this_line = (_Bool )tmp___37;
#line 776
    if ((unsigned int )diff_type == 0U) {
#line 776
      goto _L___21;
    } else
#line 776
    if ((unsigned int )diff_type == 1U) {
#line 776
      goto _L___21;
    } else
#line 776
    if ((unsigned int )diff_type == 4U) {
      _L___21: /* CIL Label */ 
#line 776
      if (stars_last_line) {
        {
#line 776
        tmp___40 = strncmp((char const   *)s, "*** ", (size_t )4);
        }
#line 776
        if (! tmp___40) {
#line 780
          s += 4;
#line 781
          if ((int )*(s + 0) == 48) {
#line 781
            if (! ((unsigned int )*(s + 1) - 48U <= 9U)) {
#line 782
              p_says_nonexistent[0] = 1 + ! p_timestamp[0].tv_sec;
            }
          }
          {
#line 785
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 785
            if (! ((int )*s != 10)) {
#line 785
              goto while_break___17;
            }
#line 786
            s ++;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 787
          p_indent = indent;
#line 788
          p_strip_trailing_cr = strip_trailing_cr;
#line 789
          p_start = previous_line;
#line 790
          p_sline = p_input_line - 1L;
#line 791
          if ((int )*(s - 1) == 42) {
#line 791
            retval = (enum diff )4;
          } else {
#line 791
            retval = (enum diff )1;
          }
          {
#line 796
          saved_p_base = p_base;
#line 797
          saved_p_bline = p_bline;
#line 798
          Fseek(pfp, previous_line, 0);
#line 799
          p_input_line -= 2L;
#line 800
          tmp___38 = another_hunk(retval, (_Bool)0);
          }
#line 800
          if (tmp___38) {
#line 800
            if (! p_repl_lines) {
#line 800
              if (p_newfirst == 1L) {
#line 802
                p_says_nonexistent[1] = 1 + ! p_timestamp[1].tv_sec;
              }
            }
          }
          {
#line 803
          next_intuit_at(saved_p_base, saved_p_bline);
          }
#line 806
          if (p_name[0]) {
#line 806
            goto _L___20;
          } else
#line 806
          if (! p_timestamp[0].tv_sec) {
            _L___20: /* CIL Label */ 
#line 806
            if (! p_name[1]) {
#line 806
              if (! (! p_timestamp[1].tv_sec)) {
#line 806
                goto _L___19;
              }
            }
          } else
          _L___19: /* CIL Label */ 
#line 806
          if (! p_name[2]) {
#line 806
            if (need_header) {
              {
#line 811
              tmp___39 = format_linenum((char *)(numbuf___1), p_sline);
#line 811
              say("missing header for context diff at line %s of patch\n", tmp___39);
              }
            }
          }
#line 814
          goto scan_exit;
        }
      }
    }
#line 816
    if ((unsigned int )diff_type == 0U) {
#line 816
      goto _L___22;
    } else
#line 816
    if ((unsigned int )diff_type == 2U) {
      _L___22: /* CIL Label */ 
#line 816
      if (last_line_was_command) {
        {
#line 816
        tmp___41 = strncmp((char const   *)s, "< ", (size_t )2);
        }
#line 816
        if (tmp___41) {
          {
#line 816
          tmp___42 = strncmp((char const   *)s, "> ", (size_t )2);
          }
#line 816
          if (! tmp___42) {
#line 819
            p_start = previous_line;
#line 820
            p_sline = p_input_line - 1L;
#line 821
            p_indent = indent;
#line 822
            retval = (enum diff )2;
#line 823
            goto scan_exit;
          }
        } else {
#line 819
          p_start = previous_line;
#line 820
          p_sline = p_input_line - 1L;
#line 821
          p_indent = indent;
#line 822
          retval = (enum diff )2;
#line 823
          goto scan_exit;
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  scan_exit: 
#line 832
  file_type = p_mode[0] & 61440U;
#line 833
  if (file_type) {
#line 835
    new_file_type = p_mode[1] & 61440U;
#line 836
    if (new_file_type) {
#line 836
      if (file_type != new_file_type) {
#line 837
        file_type = (mode_t )0;
      }
    }
  } else {
#line 841
    file_type = p_mode[1] & 61440U;
#line 842
    if (! file_type) {
#line 843
      file_type = (mode_t )32768;
    }
  }
#line 845
  *p_file_type = file_type;
#line 868
  i = (enum nametype )3;
#line 870
  if (! inname) {
#line 872
    i0 = (enum nametype )3;
#line 874
    if (! posixly_correct) {
#line 874
      if (p_name[0]) {
#line 874
        goto _L___23;
      } else
#line 874
      if (p_name[1]) {
        _L___23: /* CIL Label */ 
#line 874
        if (p_name[2]) {
          {
#line 876
          free((void *)p_name[2]);
#line 877
          p_name[2] = (char *)0;
          }
        }
      }
    }
#line 880
    i = (enum nametype )0;
    {
#line 880
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 880
      if (! ((unsigned int )i <= 2U)) {
#line 880
        goto while_break___18;
      }
#line 881
      if (p_name[i]) {
#line 883
        if ((unsigned int )i0 != 3U) {
          {
#line 883
          tmp___47 = strcmp((char const   *)p_name[i0], (char const   *)p_name[i]);
          }
#line 883
          if (tmp___47 == 0) {
#line 886
            stat_errno[i] = stat_errno[i0];
#line 887
            if (! stat_errno[i]) {
#line 888
              st[i] = st[i0];
            }
          } else {
#line 883
            goto _L___24;
          }
        } else {
          _L___24: /* CIL Label */ 
          {
#line 890
          tmp___46 = lstat((char const   */* __restrict  */)p_name[i], (struct stat */* __restrict  */)(& st[i]));
          }
#line 890
          if (tmp___46 != 0) {
            {
#line 891
            tmp___43 = __errno_location();
#line 891
            stat_errno[i] = *tmp___43;
            }
          } else {
            {
#line 892
            tmp___45 = lookup_file_id((struct stat  const  *)(& st[i]));
            }
#line 892
            if ((unsigned int )tmp___45 == 2U) {
#line 893
              stat_errno[i] = 2;
            } else {
#line 896
              stat_errno[i] = 0;
#line 897
              if (posixly_correct) {
                {
#line 897
                tmp___44 = name_is_valid((char const   *)p_name[i]);
                }
#line 897
                if (tmp___44) {
#line 898
                  goto while_break___18;
                }
              }
            }
          }
        }
#line 900
        i0 = i;
      }
#line 880
      i = (enum nametype )((unsigned int )i + 1U);
    }
    while_break___18: /* CIL Label */ ;
    }
#line 903
    if (! posixly_correct) {
      {
#line 906
      i = best_name((char * const  *)(p_name), (int const   *)(stat_errno));
      }
#line 908
      if ((unsigned int )i == 3U) {
#line 908
        if (patch_get) {
#line 910
          nope = (enum nametype )3;
#line 912
          i = (enum nametype )0;
          {
#line 912
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 912
            if (! ((unsigned int )i <= 2U)) {
#line 912
              goto while_break___19;
            }
#line 913
            if (p_name[i]) {
#line 918
              if (outfile) {
                {
#line 918
                tmp___48 = strcmp((char const   *)outfile, (char const   *)p_name[i]);
                }
#line 918
                if (tmp___48 != 0) {
#line 918
                  tmp___49 = 1;
                } else {
#line 918
                  tmp___49 = 0;
                }
              } else {
#line 918
                tmp___49 = 0;
              }
#line 918
              readonly = (_Bool )tmp___49;
#line 921
              if ((unsigned int )nope == 3U) {
#line 921
                goto _L___25;
              } else {
                {
#line 921
                tmp___51 = strcmp((char const   *)p_name[nope], (char const   *)p_name[i]);
                }
#line 921
                if (tmp___51 != 0) {
                  _L___25: /* CIL Label */ 
                  {
#line 923
                  cs = version_controller((char const   *)p_name[i], readonly, (struct stat  const  *)((struct stat *)0),
                                          & getbuf, & diffbuf);
#line 926
                  version_controlled[i] = ! (! cs);
                  }
#line 927
                  if (cs) {
                    {
#line 929
                    tmp___50 = version_get((char const   *)p_name[i], cs, (_Bool)0,
                                           readonly, (char const   *)getbuf, & st[i]);
                    }
#line 929
                    if (tmp___50) {
#line 931
                      stat_errno[i] = 0;
                    } else {
#line 933
                      version_controlled[i] = 0;
                    }
                    {
#line 935
                    free((void *)getbuf);
#line 936
                    free((void *)diffbuf);
                    }
#line 938
                    if (! stat_errno[i]) {
#line 939
                      goto while_break___19;
                    }
                  }
                }
              }
#line 943
              nope = i;
            }
#line 912
            i = (enum nametype )((unsigned int )i + 1U);
          }
          while_break___19: /* CIL Label */ ;
          }
        }
      }
#line 947
      if ((unsigned int )i0 != 3U) {
#line 947
        if ((unsigned int )i == 3U) {
#line 947
          goto _L___26;
        } else
#line 947
        if ((st[i].st_mode & 61440U) == file_type) {
          _L___26: /* CIL Label */ 
#line 947
          if ((unsigned int )i == 3U) {
#line 947
            tmp___52 = 1;
          } else
#line 947
          if (st[i].st_size == 0L) {
#line 947
            tmp___52 = 1;
          } else {
#line 947
            tmp___52 = 0;
          }
#line 947
          if ((unsigned int )i == 3U) {
#line 947
            tmp___53 = (unsigned int )i0;
          } else {
#line 947
            tmp___53 = (unsigned int )i;
          }
          {
#line 947
          tmp___54 = maybe_reverse((char const   *)p_name[tmp___53], (_Bool )((unsigned int )i == 3U),
                                   (_Bool )tmp___52);
          }
#line 947
          if (tmp___54) {
#line 947
            if ((unsigned int )i == 3U) {
#line 952
              i = i0;
            }
          }
        }
      }
#line 954
      if ((unsigned int )i == 3U) {
#line 954
        if (p_says_nonexistent[reverse]) {
#line 957
          newdirs_min = 2147483647;
#line 960
          i = (enum nametype )0;
          {
#line 960
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 960
            if (! ((unsigned int )i <= 2U)) {
#line 960
              goto while_break___20;
            }
#line 961
            if (p_name[i]) {
              {
#line 963
              tmp___55 = prefix_components(p_name[i], (_Bool)0);
#line 963
              tmp___56 = prefix_components(p_name[i], (_Bool)1);
#line 963
              newdirs[i] = tmp___55 - tmp___56;
              }
#line 965
              if (newdirs[i] < newdirs_min) {
#line 966
                newdirs_min = newdirs[i];
              }
            }
#line 960
            i = (enum nametype )((unsigned int )i + 1U);
          }
          while_break___20: /* CIL Label */ ;
          }
#line 969
          i = (enum nametype )0;
          {
#line 969
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 969
            if (! ((unsigned int )i <= 2U)) {
#line 969
              goto while_break___21;
            }
#line 970
            if (p_name[i]) {
#line 971
              distance_from_minimum[i] = newdirs[i] - newdirs_min;
            }
#line 969
            i = (enum nametype )((unsigned int )i + 1U);
          }
          while_break___21: /* CIL Label */ ;
          }
          {
#line 974
          i = best_name((char * const  *)(p_name), (int const   *)(distance_from_minimum));
          }
        }
      }
    }
  }
#line 979
  if ((unsigned int )i == 3U) {
#line 981
    if (inname) {
      {
#line 983
      tmp___59 = lstat((char const   */* __restrict  */)inname, (struct stat */* __restrict  */)(& instat));
      }
#line 983
      if (tmp___59 == 0) {
#line 983
        inerrno = 0;
      } else {
        {
#line 983
        tmp___58 = __errno_location();
#line 983
        inerrno = *tmp___58;
        }
      }
#line 984
      if (inerrno) {
#line 984
        goto _L___27;
      } else
#line 984
      if ((instat.st_mode & 61440U) == file_type) {
        _L___27: /* CIL Label */ 
#line 985
        if (inerrno) {
#line 985
          tmp___60 = 1;
        } else
#line 985
        if (instat.st_size == 0L) {
#line 985
          tmp___60 = 1;
        } else {
#line 985
          tmp___60 = 0;
        }
        {
#line 985
        maybe_reverse((char const   *)inname, (_Bool )inerrno, (_Bool )tmp___60);
        }
      }
    } else {
#line 988
      inerrno = -1;
    }
  } else {
    {
#line 992
    inname = savestr((char const   *)p_name[i]);
#line 993
    inerrno = stat_errno[i];
#line 994
    invc = version_controlled[i];
#line 995
    instat = st[i];
    }
  }
#line 998
  return (retval);
}
}
#line 1003 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static int prefix_components(char *filename , _Bool checkdirs ) 
{ 
  int count ;
  struct stat stat_buf ;
  int stat_result ;
  char *f ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 1006
  count = 0;
#line 1009
  f = filename + 0;
#line 1011
  if (*f) {
    {
#line 1012
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1012
      f ++;
#line 1012
      if (! *f) {
#line 1012
        goto while_break;
      }
#line 1013
      if ((int )*(f + 0) == 47) {
#line 1013
        if (! ((int )*(f + -1) == 47)) {
#line 1015
          if (checkdirs) {
            {
#line 1017
            *f = (char )'\000';
#line 1018
            stat_result = lstat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& stat_buf));
#line 1019
            *f = (char )'/';
            }
#line 1020
            if (stat_result == 0) {
#line 1020
              if (! ((stat_buf.st_mode & 61440U) == 16384U)) {
#line 1021
                goto while_break;
              }
            } else {
#line 1021
              goto while_break;
            }
          }
#line 1024
          count ++;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1027
  return (count);
}
}
#line 1033 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static enum nametype best_name(char * const  *name , int const   *ignore ) 
{ 
  enum nametype i ;
  int components[3] ;
  int components_min ;
  size_t basename_len[3] ;
  size_t basename_len_min ;
  size_t len[3] ;
  size_t len_min ;
  _Bool tmp ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 1038
  components_min = 2147483647;
#line 1040
  basename_len_min = 0xffffffffffffffffUL;
#line 1042
  len_min = 0xffffffffffffffffUL;
#line 1044
  i = (enum nametype )0;
  {
#line 1044
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1044
    if (! ((unsigned int )i <= 2U)) {
#line 1044
      goto while_break;
    }
#line 1045
    if (*(name + i)) {
#line 1045
      if (! *(ignore + i)) {
        {
#line 1048
        components[i] = prefix_components((char *)*(name + i), (_Bool)0);
        }
#line 1049
        if (components_min < components[i]) {
#line 1050
          goto __Cont;
        }
        {
#line 1051
        components_min = components[i];
#line 1054
        basename_len[i] = base_len((char const   *)*(name + i));
        }
#line 1055
        if (basename_len_min < basename_len[i]) {
#line 1056
          goto __Cont;
        }
        {
#line 1057
        basename_len_min = basename_len[i];
#line 1060
        len[i] = strlen((char const   *)*(name + i));
        }
#line 1061
        if (len_min < len[i]) {
#line 1062
          goto __Cont;
        }
#line 1063
        len_min = len[i];
      }
    }
    __Cont: /* CIL Label */ 
#line 1044
    i = (enum nametype )((unsigned int )i + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 1067
  i = (enum nametype )0;
  {
#line 1067
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1067
    if (! ((unsigned int )i <= 2U)) {
#line 1067
      goto while_break___0;
    }
#line 1068
    if (*(name + i)) {
#line 1068
      if (! *(ignore + i)) {
        {
#line 1068
        tmp = name_is_valid((char const   *)*(name + i));
        }
#line 1068
        if (tmp) {
#line 1068
          if (components[i] == components_min) {
#line 1068
            if (basename_len[i] == basename_len_min) {
#line 1068
              if (len[i] == len_min) {
#line 1073
                goto while_break___0;
              }
            }
          }
        }
      }
    }
#line 1067
    i = (enum nametype )((unsigned int )i + 1U);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1075
  return (i);
}
}
#line 1080 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static void next_intuit_at(file_offset file_pos , lin file_line ) 
{ 


  {
#line 1083
  p_base = file_pos;
#line 1084
  p_bline = file_line;
#line 1085
  return;
}
}
#line 1089 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static void skip_to(file_offset file_pos , lin file_line ) 
{ 
  FILE *i ;
  FILE *o ;
  int c ;
  long tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1092
  i = pfp;
#line 1093
  o = stdout;
#line 1096
  if (! (p_base <= file_pos)) {
    {
#line 1096
    __assert_fail("p_base <= file_pos", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                  1096U, "skip_to");
    }
  }
#line 1097
  if ((unsigned int )verbosity == 2U) {
#line 1097
    goto _L;
  } else
#line 1097
  if (! inname) {
    _L: /* CIL Label */ 
#line 1097
    if (p_base < file_pos) {
      {
#line 1098
      Fseek(i, p_base, 0);
#line 1099
      say("The text leading up to this was:\n--------------------------\n");
      }
      {
#line 1101
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1101
        tmp = ftell(i);
        }
#line 1101
        if (! (tmp < file_pos)) {
#line 1101
          goto while_break;
        }
        {
#line 1103
        _IO_putc('|', o);
        }
        {
#line 1104
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1106
          c = _IO_getc(i);
          }
#line 1106
          if (c == -1) {
            {
#line 1107
            read_fatal();
            }
          }
          {
#line 1108
          _IO_putc(c, o);
          }
#line 1104
          if (! (c != 10)) {
#line 1104
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1113
      say("--------------------------\n");
      }
    } else {
      {
#line 1116
      Fseek(i, file_pos, 0);
      }
    }
  } else {
    {
#line 1116
    Fseek(i, file_pos, 0);
    }
  }
#line 1117
  p_input_line = file_line - 1L;
#line 1118
  return;
}
}
#line 1121
static  __attribute__((__noreturn__)) void malformed(void) ;
#line 1121 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static void malformed(void) 
{ 
  char numbuf[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1125
  tmp = format_linenum((char *)(numbuf), p_input_line);
#line 1125
  fatal("malformed patch at line %s: %s", tmp, buf);
  }
}
}
#line 1132 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char *scan_linenum(char *s0 , lin *linenum ) 
{ 
  char *s ;
  lin n ;
  _Bool overflow ;
  char numbuf[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  lin new_n ;
  char *tmp ;
  char *tmp___0 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1136
  n = (lin )0;
#line 1137
  overflow = (_Bool)0;
#line 1140
  s = s0;
  {
#line 1140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1140
    if (! ((unsigned int )*s - 48U <= 9U)) {
#line 1140
      goto while_break;
    }
#line 1142
    new_n = 10L * n + (lin )((int )*s - 48);
#line 1143
    overflow = (_Bool )((int )overflow | (new_n / 10L != n));
#line 1144
    n = new_n;
#line 1140
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1147
  if ((unsigned long )s == (unsigned long )s0) {
    {
#line 1148
    tmp = format_linenum((char *)(numbuf), p_input_line);
#line 1148
    fatal("missing line number at line %s: %s", tmp, buf);
    }
  }
#line 1151
  if (overflow) {
    {
#line 1152
    tmp___0 = format_linenum((char *)(numbuf), p_input_line);
#line 1152
    fatal("line number %.*s is too large at line %s: %s", (int )(s - s0), s0, tmp___0,
          buf);
    }
  }
#line 1155
  *linenum = n;
#line 1156
  return (s);
}
}
#line 1162 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
int another_hunk(enum diff difftype , _Bool rev ) 
{ 
  char *s ;
  lin context ;
  size_t chars_read ;
  char numbuf0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf2[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf3[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  file_offset line_beginning ;
  long tmp ;
  lin repl_beginning ;
  lin fillcnt ;
  lin fillsrc ;
  lin filldst ;
  _Bool ptrn_spaces_eaten ;
  _Bool some_context ;
  _Bool repl_could_be_missing ;
  _Bool ptrn_missing ;
  _Bool repl_missing ;
  file_offset repl_backtrack_position ;
  lin repl_patch_line ;
  lin repl_context ;
  lin ptrn_prefix_context ;
  lin ptrn_suffix_context ;
  lin repl_prefix_context ;
  lin ptrn_copiable ;
  lin repl_copiable ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  lin tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  _Bool tmp___17 ;
  lin tmp___18 ;
  _Bool tmp___19 ;
  int tmp___20 ;
  lin tmp___21 ;
  _Bool tmp___22 ;
  int tmp___23 ;
  lin tmp___24 ;
  _Bool tmp___25 ;
  int tmp___26 ;
  lin tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  lin tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  file_offset line_beginning___0 ;
  long tmp___38 ;
  lin fillsrc___0 ;
  lin filldst___0 ;
  char ch ;
  int tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  _Bool tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  lin tmp___50 ;
  _Bool tmp___51 ;
  int tmp___52 ;
  lin tmp___53 ;
  _Bool tmp___54 ;
  int tmp___55 ;
  lin tmp___56 ;
  _Bool tmp___57 ;
  int tmp___58 ;
  lin tmp___59 ;
  char hunk_type ;
  int i ;
  lin min ;
  lin max ;
  file_offset line_beginning___1 ;
  long tmp___60 ;
  int tmp___61 ;
  _Bool tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  _Bool tmp___68 ;
  int tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  _Bool tmp___77 ;
  int tmp___78 ;
  _Bool tmp___79 ;
  lin i___0 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  void *__cil_tmp124 ;
  void *__cil_tmp125 ;
  void *__cil_tmp126 ;
  void *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;

  {
#line 1166
  context = (lin )0;
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! (p_end >= 0L)) {
#line 1173
      goto while_break;
    }
#line 1174
    if (p_end == p_efake) {
#line 1175
      p_end = p_bfake;
    } else {
      {
#line 1177
      free((void *)*(p_line + p_end));
      }
    }
#line 1178
    p_end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1180
  if (! (p_end == -1L)) {
    {
#line 1180
    __assert_fail("p_end == -1", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                  1180U, "another_hunk");
    }
  }
#line 1181
  p_efake = (lin )-1;
#line 1183
  if (p_c_function) {
    {
#line 1185
    free((void *)p_c_function);
#line 1186
    p_c_function = (char *)((void *)0);
    }
  }
#line 1189
  p_max = hunkmax;
#line 1190
  if ((unsigned int )difftype == 1U) {
#line 1190
    goto _L___5;
  } else
#line 1190
  if ((unsigned int )difftype == 4U) {
    _L___5: /* CIL Label */ 
    {
#line 1191
    tmp = ftell(pfp);
#line 1191
    line_beginning = tmp;
#line 1193
    repl_beginning = (lin )0;
#line 1194
    fillcnt = (lin )0;
#line 1197
    ptrn_spaces_eaten = (_Bool)0;
#line 1198
    some_context = (_Bool)0;
#line 1199
    repl_could_be_missing = (_Bool)1;
#line 1200
    ptrn_missing = (_Bool)0;
#line 1201
    repl_missing = (_Bool)0;
#line 1202
    repl_backtrack_position = (file_offset )0;
#line 1206
    ptrn_prefix_context = (lin )-1;
#line 1207
    ptrn_suffix_context = (lin )-1;
#line 1208
    repl_prefix_context = (lin )-1;
#line 1209
    ptrn_copiable = (lin )0;
#line 1210
    repl_copiable = (lin )0;
#line 1213
    repl_context = (lin )0;
#line 1213
    repl_patch_line = repl_context;
#line 1213
    filldst = repl_patch_line;
#line 1213
    fillsrc = filldst;
#line 1215
    chars_read = get_line();
    }
#line 1216
    if (chars_read == 0xffffffffffffffffUL) {
#line 1216
      goto _L;
    } else
#line 1216
    if (chars_read <= 8UL) {
#line 1216
      goto _L;
    } else {
      {
#line 1216
      tmp___1 = strncmp((char const   *)buf, "********", (size_t )8);
      }
#line 1216
      if (tmp___1 != 0) {
        _L: /* CIL Label */ 
        {
#line 1219
        next_intuit_at(line_beginning, p_input_line);
        }
#line 1220
        if (chars_read == 0xffffffffffffffffUL) {
#line 1220
          tmp___0 = -1;
        } else {
#line 1220
          tmp___0 = 0;
        }
#line 1220
        return (tmp___0);
      }
    }
#line 1222
    s = buf;
    {
#line 1223
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1223
      if (! ((int )*s == 42)) {
#line 1223
        goto while_break___0;
      }
#line 1224
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1225
    if ((int )*s == 32) {
#line 1227
      p_c_function = s;
      {
#line 1228
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1228
        if (! ((int )*s != 10)) {
#line 1228
          goto while_break___1;
        }
#line 1229
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1230
      *s = (char )'\000';
#line 1231
      p_c_function = savestr((char const   *)p_c_function);
      }
    }
#line 1233
    p_hunk_beg = p_input_line + 1L;
    {
#line 1234
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1234
      if (! (p_end < p_max)) {
#line 1234
        goto while_break___2;
      }
      {
#line 1235
      chars_read = get_line();
      }
#line 1236
      if (chars_read == 0xffffffffffffffffUL) {
#line 1237
        return (-1);
      }
#line 1238
      if (! chars_read) {
#line 1239
        if (repl_beginning) {
#line 1239
          if (repl_could_be_missing) {
#line 1240
            repl_missing = (_Bool)1;
#line 1241
            goto hunk_done;
          }
        }
#line 1243
        if (p_max - p_end < 4L) {
          {
#line 1244
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"  \n");
#line 1245
          chars_read = (size_t )3;
          }
        } else {
          {
#line 1247
          fatal("unexpected end of file in patch");
          }
        }
      }
#line 1250
      p_end ++;
#line 1251
      if (p_end == hunkmax) {
        {
#line 1252
        tmp___2 = format_linenum((char *)(numbuf1), p_input_line);
#line 1252
        tmp___3 = pch_hunk_beg();
#line 1252
        tmp___4 = format_linenum((char *)(numbuf0), tmp___3);
#line 1252
        fatal("unterminated hunk starting at line %s; giving up at line %s: %s", tmp___4,
              tmp___2, buf);
        }
      }
#line 1255
      if (! (p_end < hunkmax)) {
        {
#line 1255
        __assert_fail("p_end < hunkmax", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                      1255U, "another_hunk");
        }
      }
#line 1256
      *(p_Char + p_end) = *buf;
#line 1257
      *(p_len + p_end) = (size_t )0;
#line 1258
      *(p_line + p_end) = (char *)0;
      {
#line 1260
      if ((int )*buf == 42) {
#line 1260
        goto case_42;
      }
#line 1307
      if ((int )*buf == 45) {
#line 1307
        goto case_45;
      }
#line 1389
      if ((int )*buf == 33) {
#line 1389
        goto case_33;
      }
#line 1389
      if ((int )*buf == 43) {
#line 1389
        goto case_33;
      }
#line 1427
      if ((int )*buf == 10) {
#line 1427
        goto case_10;
      }
#line 1427
      if ((int )*buf == 9) {
#line 1427
        goto case_10;
      }
#line 1459
      if ((int )*buf == 32) {
#line 1459
        goto case_32;
      }
#line 1490
      goto switch_default;
      case_42: /* CIL Label */ 
      {
#line 1261
      tmp___6 = strncmp((char const   *)buf, "********", (size_t )8);
      }
#line 1261
      if (! tmp___6) {
#line 1262
        if (repl_beginning) {
#line 1262
          if (repl_could_be_missing) {
#line 1263
            repl_missing = (_Bool)1;
#line 1264
            goto hunk_done;
          } else {
            {
#line 1267
            tmp___5 = format_linenum((char *)(numbuf0), p_input_line);
#line 1267
            fatal("unexpected end of hunk at line %s", tmp___5);
            }
          }
        } else {
          {
#line 1267
          tmp___5 = format_linenum((char *)(numbuf0), p_input_line);
#line 1267
          fatal("unexpected end of hunk at line %s", tmp___5);
          }
        }
      }
#line 1270
      if (p_end != 0L) {
#line 1271
        if (repl_beginning) {
#line 1271
          if (repl_could_be_missing) {
#line 1272
            repl_missing = (_Bool)1;
#line 1273
            goto hunk_done;
          }
        }
        {
#line 1275
        tmp___7 = format_linenum((char *)(numbuf0), p_input_line);
#line 1275
        fatal("unexpected \'***\' at line %s: %s", tmp___7, buf);
        }
      }
      {
#line 1278
      context = (lin )0;
#line 1279
      *(p_len + p_end) = strlen((char const   *)buf);
#line 1280
      tmp___8 = savestr((char const   *)buf);
#line 1280
      *(p_line + p_end) = tmp___8;
      }
#line 1280
      if (! tmp___8) {
#line 1281
        p_end --;
#line 1282
        return (-1);
      }
#line 1284
      s = buf;
      {
#line 1284
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1284
        if (*s) {
#line 1284
          if (! (! ((unsigned int )*s - 48U <= 9U))) {
#line 1284
            goto while_break___3;
          }
        } else {
#line 1284
          goto while_break___3;
        }
#line 1284
        s ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1286
      tmp___9 = strncmp((char const   *)s, "0,0", (size_t )3);
      }
#line 1286
      if (! tmp___9) {
        {
#line 1287
        remove_prefix(s, (size_t )2);
        }
      }
      {
#line 1288
      s = scan_linenum(s, & p_first);
      }
#line 1289
      if ((int )*s == 44) {
        {
#line 1290
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1290
          if (*s) {
#line 1290
            if (! (! ((unsigned int )*s - 48U <= 9U))) {
#line 1290
              goto while_break___4;
            }
          } else {
#line 1290
            goto while_break___4;
          }
#line 1291
          s ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 1292
        scan_linenum(s, & p_ptrn_lines);
#line 1293
        p_ptrn_lines += 1L - p_first;
        }
      } else
#line 1295
      if (p_first) {
#line 1296
        p_ptrn_lines = (lin )1;
      } else {
#line 1298
        p_ptrn_lines = (lin )0;
#line 1299
        p_first = (lin )1;
      }
#line 1301
      p_max = p_ptrn_lines + 6L;
      {
#line 1302
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1302
        if (! (p_max + 1L >= hunkmax)) {
#line 1302
          goto while_break___5;
        }
        {
#line 1303
        tmp___10 = grow_hunkmax();
        }
#line 1303
        if (! tmp___10) {
#line 1304
          return (-1);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1305
      p_max = hunkmax;
#line 1306
      goto switch_break;
      case_45: /* CIL Label */ 
#line 1308
      if ((int )*(buf + 1) != 45) {
#line 1309
        goto change_line;
      }
#line 1310
      if (ptrn_prefix_context == -1L) {
#line 1311
        ptrn_prefix_context = context;
      }
#line 1312
      ptrn_suffix_context = context;
#line 1313
      if (repl_beginning) {
#line 1313
        goto _L___0;
      } else
#line 1313
      if (p_end != (p_ptrn_lines + 1L) + (lin )((int )*(p_Char + (p_end - 1L)) == 10)) {
        _L___0: /* CIL Label */ 
#line 1317
        if (p_end == 1L) {
#line 1321
          ptrn_missing = (_Bool)1;
#line 1322
          p_end = p_ptrn_lines + 1L;
#line 1323
          ptrn_suffix_context = (lin )-1;
#line 1323
          ptrn_prefix_context = ptrn_suffix_context;
#line 1324
          fillsrc = p_end + 1L;
#line 1325
          filldst = (lin )1;
#line 1326
          fillcnt = p_ptrn_lines;
        } else
#line 1328
        if (! repl_beginning) {
          {
#line 1329
          tmp___11 = format_linenum((char *)(numbuf1), p_hunk_beg);
#line 1329
          tmp___12 = format_linenum((char *)(numbuf0), p_input_line);
          }
#line 1329
          if (p_end <= p_ptrn_lines) {
#line 1329
            tmp___13 = "Premature";
          } else {
#line 1329
            tmp___13 = "Overdue";
          }
          {
#line 1329
          fatal("%s \'---\' at line %s; check line numbers at line %s", tmp___13,
                tmp___12, tmp___11);
          }
        } else
#line 1335
        if (! repl_could_be_missing) {
          {
#line 1336
          tmp___14 = format_linenum((char *)(numbuf1), p_hunk_beg + repl_beginning);
#line 1336
          tmp___15 = format_linenum((char *)(numbuf0), p_input_line);
#line 1336
          fatal("duplicate \'---\' at line %s; check line numbers at line %s", tmp___15,
                tmp___14);
          }
        } else {
#line 1342
          repl_missing = (_Bool)1;
#line 1343
          goto hunk_done;
        }
      }
      {
#line 1346
      repl_beginning = p_end;
#line 1347
      repl_backtrack_position = ftell(pfp);
#line 1348
      repl_patch_line = p_input_line;
#line 1349
      repl_context = context;
#line 1350
      *(p_len + p_end) = strlen((char const   *)buf);
#line 1351
      tmp___16 = savestr((char const   *)buf);
#line 1351
      *(p_line + p_end) = tmp___16;
      }
#line 1351
      if (! tmp___16) {
#line 1353
        p_end --;
#line 1354
        return (-1);
      }
#line 1356
      *(p_Char + p_end) = (char )'=';
#line 1357
      s = buf;
      {
#line 1357
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1357
        if (*s) {
#line 1357
          if (! (! ((unsigned int )*s - 48U <= 9U))) {
#line 1357
            goto while_break___6;
          }
        } else {
#line 1357
          goto while_break___6;
        }
#line 1357
        s ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1359
      s = scan_linenum(s, & p_newfirst);
      }
#line 1360
      if ((int )*s == 44) {
        {
#line 1362
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1364
          s ++;
#line 1364
          if (! *s) {
            {
#line 1365
            malformed();
            }
          }
#line 1362
          if (! (! ((unsigned int )*s - 48U <= 9U))) {
#line 1362
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1368
        scan_linenum(s, & p_repl_lines);
#line 1369
        p_repl_lines += 1L - p_newfirst;
        }
      } else
#line 1371
      if (p_newfirst) {
#line 1372
        p_repl_lines = (lin )1;
      } else {
#line 1375
        p_repl_lines = (lin )0;
#line 1376
        p_newfirst = (lin )1;
      }
#line 1378
      p_max = p_repl_lines + p_end;
      {
#line 1379
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1379
        if (! (p_max + 1L >= hunkmax)) {
#line 1379
          goto while_break___8;
        }
        {
#line 1380
        tmp___17 = grow_hunkmax();
        }
#line 1380
        if (! tmp___17) {
#line 1381
          return (-1);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1382
      if (p_repl_lines != ptrn_copiable) {
#line 1382
        if (p_prefix_context != 0L) {
#line 1386
          repl_could_be_missing = (_Bool)0;
        } else
#line 1382
        if (context != 0L) {
#line 1386
          repl_could_be_missing = (_Bool)0;
        } else
#line 1382
        if (p_repl_lines != 1L) {
#line 1386
          repl_could_be_missing = (_Bool)0;
        }
      }
#line 1387
      context = (lin )0;
#line 1388
      goto switch_break;
      case_33: /* CIL Label */ 
      case_43: /* CIL Label */ 
#line 1390
      repl_could_be_missing = (_Bool)0;
      change_line: 
#line 1392
      s = buf + 1;
#line 1393
      chars_read --;
#line 1394
      if ((int )*s == 10) {
#line 1394
        if (canonicalize) {
          {
#line 1395
          strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)" \n");
#line 1396
          chars_read = (size_t )2;
          }
        }
      }
#line 1398
      if ((int )*s == 32) {
#line 1399
        s ++;
#line 1400
        chars_read --;
      } else
#line 1398
      if ((int )*s == 9) {
#line 1399
        s ++;
#line 1400
        chars_read --;
      } else
#line 1401
      if (repl_beginning) {
#line 1401
        if (repl_could_be_missing) {
#line 1402
          repl_missing = (_Bool)1;
#line 1403
          goto hunk_done;
        }
      }
#line 1405
      if (! repl_beginning) {
#line 1407
        if (ptrn_prefix_context == -1L) {
#line 1408
          ptrn_prefix_context = context;
        }
      } else
#line 1412
      if (repl_prefix_context == -1L) {
#line 1413
        repl_prefix_context = context;
      }
#line 1415
      if (1UL < chars_read) {
#line 1415
        if (repl_beginning) {
#line 1415
          tmp___18 = p_max;
        } else {
#line 1415
          tmp___18 = p_ptrn_lines;
        }
#line 1415
        if (p_end == tmp___18) {
          {
#line 1415
          tmp___19 = incomplete_line();
          }
#line 1415
          if (tmp___19) {
#line 1415
            tmp___20 = 1;
          } else {
#line 1415
            tmp___20 = 0;
          }
        } else {
#line 1415
          tmp___20 = 0;
        }
      } else {
#line 1415
        tmp___20 = 0;
      }
      {
#line 1415
      chars_read -= (size_t )tmp___20;
#line 1419
      *(p_len + p_end) = chars_read;
#line 1420
      *(p_line + p_end) = savebuf((char const   *)s, chars_read);
      }
#line 1421
      if (chars_read) {
#line 1421
        if (! *(p_line + p_end)) {
#line 1422
          p_end --;
#line 1423
          return (-1);
        }
      }
#line 1425
      context = (lin )0;
#line 1426
      goto switch_break;
      case_10: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 1428
      s = buf;
#line 1429
      if ((int )*buf == 9) {
#line 1430
        s ++;
#line 1431
        chars_read --;
      }
#line 1433
      if (repl_beginning) {
#line 1433
        if (repl_could_be_missing) {
#line 1433
          if (! ptrn_spaces_eaten) {
#line 1435
            repl_missing = (_Bool)1;
#line 1436
            goto hunk_done;
          } else
#line 1433
          if ((unsigned int )difftype == 4U) {
#line 1435
            repl_missing = (_Bool)1;
#line 1436
            goto hunk_done;
          }
        }
      }
#line 1438
      if (1UL < chars_read) {
#line 1438
        if (repl_beginning) {
#line 1438
          tmp___21 = p_max;
        } else {
#line 1438
          tmp___21 = p_ptrn_lines;
        }
#line 1438
        if (p_end == tmp___21) {
          {
#line 1438
          tmp___22 = incomplete_line();
          }
#line 1438
          if (tmp___22) {
#line 1438
            tmp___23 = 1;
          } else {
#line 1438
            tmp___23 = 0;
          }
        } else {
#line 1438
          tmp___23 = 0;
        }
      } else {
#line 1438
        tmp___23 = 0;
      }
      {
#line 1438
      chars_read -= (size_t )tmp___23;
#line 1442
      *(p_len + p_end) = chars_read;
#line 1443
      *(p_line + p_end) = savebuf((char const   *)buf, chars_read);
      }
#line 1444
      if (chars_read) {
#line 1444
        if (! *(p_line + p_end)) {
#line 1445
          p_end --;
#line 1446
          return (-1);
        }
      }
#line 1448
      if (p_end != p_ptrn_lines + 1L) {
#line 1449
        ptrn_spaces_eaten = (_Bool )((int )ptrn_spaces_eaten | (repl_beginning != 0L));
#line 1450
        some_context = (_Bool)1;
#line 1451
        context ++;
#line 1452
        if (repl_beginning) {
#line 1453
          repl_copiable ++;
        } else {
#line 1455
          ptrn_copiable ++;
        }
#line 1456
        *(p_Char + p_end) = (char )' ';
      }
#line 1458
      goto switch_break;
      case_32: /* CIL Label */ 
#line 1460
      s = buf + 1;
#line 1461
      chars_read --;
#line 1462
      if ((int )*s == 10) {
#line 1462
        if (canonicalize) {
          {
#line 1463
          strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)"\n");
#line 1464
          chars_read = (size_t )2;
          }
        }
      }
#line 1466
      if ((int )*s == 32) {
#line 1467
        s ++;
#line 1468
        chars_read --;
      } else
#line 1466
      if ((int )*s == 9) {
#line 1467
        s ++;
#line 1468
        chars_read --;
      } else
#line 1469
      if (repl_beginning) {
#line 1469
        if (repl_could_be_missing) {
#line 1470
          repl_missing = (_Bool)1;
#line 1471
          goto hunk_done;
        }
      }
#line 1473
      some_context = (_Bool)1;
#line 1474
      context ++;
#line 1475
      if (repl_beginning) {
#line 1476
        repl_copiable ++;
      } else {
#line 1478
        ptrn_copiable ++;
      }
#line 1479
      if (1UL < chars_read) {
#line 1479
        if (repl_beginning) {
#line 1479
          tmp___24 = p_max;
        } else {
#line 1479
          tmp___24 = p_ptrn_lines;
        }
#line 1479
        if (p_end == tmp___24) {
          {
#line 1479
          tmp___25 = incomplete_line();
          }
#line 1479
          if (tmp___25) {
#line 1479
            tmp___26 = 1;
          } else {
#line 1479
            tmp___26 = 0;
          }
        } else {
#line 1479
          tmp___26 = 0;
        }
      } else {
#line 1479
        tmp___26 = 0;
      }
      {
#line 1479
      chars_read -= (size_t )tmp___26;
#line 1483
      *(p_len + p_end) = chars_read;
#line 1484
      *(p_line + p_end) = savebuf((char const   *)s, chars_read);
      }
#line 1485
      if (chars_read) {
#line 1485
        if (! *(p_line + p_end)) {
#line 1486
          p_end --;
#line 1487
          return (-1);
        }
      }
#line 1489
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1491
      if (repl_beginning) {
#line 1491
        if (repl_could_be_missing) {
#line 1492
          repl_missing = (_Bool)1;
#line 1493
          goto hunk_done;
        }
      }
      {
#line 1495
      malformed();
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    hunk_done: 
#line 1500
    if (p_end >= 0L) {
#line 1500
      if (! repl_beginning) {
        {
#line 1501
        tmp___27 = pch_hunk_beg();
#line 1501
        tmp___28 = format_linenum((char *)(numbuf0), tmp___27);
#line 1501
        fatal("no \'---\' found in patch at line %s", tmp___28);
        }
      }
    }
#line 1504
    if (repl_missing) {
#line 1507
      p_input_line = repl_patch_line;
#line 1508
      context = repl_context;
#line 1509
      p_end --;
      {
#line 1509
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1509
        if (! (p_end > repl_beginning)) {
#line 1509
          goto while_break___9;
        }
        {
#line 1510
        free((void *)*(p_line + p_end));
#line 1509
        p_end --;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1511
      Fseek(pfp, repl_backtrack_position, 0);
#line 1515
      fillsrc = (lin )1;
#line 1516
      filldst = repl_beginning + 1L;
#line 1517
      fillcnt = p_repl_lines;
#line 1518
      p_end = p_max;
      }
    } else
#line 1520
    if (! ptrn_missing) {
#line 1520
      if (ptrn_copiable != repl_copiable) {
        {
#line 1521
        tmp___29 = format_linenum((char *)(numbuf0), p_hunk_beg);
#line 1521
        fatal("context mangled in hunk at line %s", tmp___29);
        }
      } else {
#line 1520
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1523
    if (! some_context) {
#line 1523
      if (fillcnt == 1L) {
        {
#line 1526
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1526
          if (! (filldst < p_end)) {
#line 1526
            goto while_break___10;
          }
#line 1527
          *(p_line + filldst) = *(p_line + (filldst + 1L));
#line 1528
          *(p_Char + filldst) = *(p_Char + (filldst + 1L));
#line 1529
          *(p_len + filldst) = *(p_len + (filldst + 1L));
#line 1530
          filldst ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1535
        p_end --;
#line 1536
        p_first ++;
#line 1537
        fillcnt = (lin )0;
#line 1538
        p_ptrn_lines = (lin )0;
      }
    }
#line 1541
    if (repl_prefix_context == -1L) {
#line 1541
      p_prefix_context = ptrn_prefix_context;
    } else
#line 1541
    if (ptrn_prefix_context != -1L) {
#line 1541
      if (ptrn_prefix_context < repl_prefix_context) {
#line 1541
        p_prefix_context = ptrn_prefix_context;
      } else {
#line 1541
        p_prefix_context = repl_prefix_context;
      }
    } else {
#line 1541
      p_prefix_context = repl_prefix_context;
    }
#line 1545
    if (ptrn_suffix_context != -1L) {
#line 1545
      if (ptrn_suffix_context < context) {
#line 1545
        p_suffix_context = ptrn_suffix_context;
      } else {
#line 1545
        p_suffix_context = context;
      }
    } else {
#line 1545
      p_suffix_context = context;
    }
#line 1548
    if (p_prefix_context == -1L) {
      {
#line 1549
      tmp___30 = format_linenum((char *)(numbuf0), p_hunk_beg);
#line 1549
      fatal("replacement text or line numbers mangled in hunk at line %s", tmp___30);
      }
    } else
#line 1548
    if (p_suffix_context == -1L) {
      {
#line 1549
      tmp___30 = format_linenum((char *)(numbuf0), p_hunk_beg);
#line 1549
      fatal("replacement text or line numbers mangled in hunk at line %s", tmp___30);
      }
    }
#line 1552
    if ((unsigned int )difftype == 1U) {
#line 1552
      if (fillcnt) {
#line 1552
        goto _L___2;
      } else
#line 1552
      if (p_first > 1L) {
#line 1552
        if (p_prefix_context + p_suffix_context < ptrn_copiable) {
          _L___2: /* CIL Label */ 
#line 1556
          if ((unsigned int )verbosity == 2U) {
            {
#line 1557
            say("%s\n%s\n%s\n", "(Fascinating -- this is really a new-style context diff but without",
                "the telltale extra asterisks on the *** line that usually indicate",
                "the new style...)");
            }
          }
#line 1561
          difftype = (enum diff )4;
#line 1561
          diff_type = difftype;
        }
      }
    }
#line 1565
    if (fillcnt) {
#line 1566
      p_bfake = filldst;
#line 1567
      p_efake = (filldst + fillcnt) - 1L;
      {
#line 1568
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1568
        tmp___32 = fillcnt;
#line 1568
        fillcnt --;
#line 1568
        if (! (tmp___32 > 0L)) {
#line 1568
          goto while_break___11;
        }
        {
#line 1569
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1569
          if (fillsrc <= p_end) {
#line 1569
            if (fillsrc != repl_beginning) {
#line 1569
              if (! ((int )*(p_Char + fillsrc) != 32)) {
#line 1569
                goto while_break___12;
              }
            } else {
#line 1569
              goto while_break___12;
            }
          } else {
#line 1569
            goto while_break___12;
          }
#line 1571
          fillsrc ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1572
        if (p_end < fillsrc) {
          {
#line 1574
          tmp___31 = format_linenum((char *)(numbuf0), p_hunk_beg);
#line 1574
          fatal("replacement text or line numbers mangled in hunk at line %s", tmp___31);
          }
        } else
#line 1572
        if (fillsrc == repl_beginning) {
          {
#line 1574
          tmp___31 = format_linenum((char *)(numbuf0), p_hunk_beg);
#line 1574
          fatal("replacement text or line numbers mangled in hunk at line %s", tmp___31);
          }
        }
#line 1577
        *(p_line + filldst) = *(p_line + fillsrc);
#line 1578
        *(p_Char + filldst) = *(p_Char + fillsrc);
#line 1579
        *(p_len + filldst) = *(p_len + fillsrc);
#line 1580
        fillsrc ++;
#line 1580
        filldst ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 1582
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1582
        if (fillsrc <= p_end) {
#line 1582
          if (! (fillsrc != repl_beginning)) {
#line 1582
            goto while_break___13;
          }
        } else {
#line 1582
          goto while_break___13;
        }
#line 1584
        if ((int )*(p_Char + fillsrc) == 32) {
          {
#line 1585
          tmp___33 = format_linenum((char *)(numbuf0), p_hunk_beg);
#line 1585
          fatal("replacement text or line numbers mangled in hunk at line %s", tmp___33);
          }
        }
#line 1587
        fillsrc ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1589
      if (debug & 64) {
        {
#line 1590
        tmp___34 = format_linenum((char *)(numbuf3), p_end + 1L);
#line 1590
        tmp___35 = format_linenum((char *)(numbuf2), repl_beginning);
#line 1590
        tmp___36 = format_linenum((char *)(numbuf1), filldst);
#line 1590
        tmp___37 = format_linenum((char *)(numbuf0), fillsrc);
#line 1590
        printf((char const   */* __restrict  */)"fillsrc %s, filldst %s, rb %s, e+1 %s\n",
               tmp___37, tmp___36, tmp___35, tmp___34);
        }
      }
#line 1595
      if (! (fillsrc == p_end + 1L)) {
#line 1595
        if (! (fillsrc == repl_beginning)) {
          {
#line 1595
          __assert_fail("fillsrc==p_end+1 || fillsrc==repl_beginning", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                        1595U, "another_hunk");
          }
        }
      }
#line 1596
      if (! (filldst == p_end + 1L)) {
#line 1596
        if (! (filldst == repl_beginning)) {
          {
#line 1596
          __assert_fail("filldst==p_end+1 || filldst==repl_beginning", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                        1596U, "another_hunk");
          }
        }
      }
    }
  } else
#line 1599
  if ((unsigned int )difftype == 5U) {
    {
#line 1600
    tmp___38 = ftell(pfp);
#line 1600
    line_beginning___0 = tmp___38;
#line 1603
    ch = (char )'\000';
#line 1605
    chars_read = get_line();
    }
#line 1606
    if (chars_read == 0xffffffffffffffffUL) {
#line 1606
      goto _L___3;
    } else
#line 1606
    if (chars_read <= 4UL) {
#line 1606
      goto _L___3;
    } else {
      {
#line 1606
      tmp___40 = strncmp((char const   *)buf, "@@ -", (size_t )4);
      }
#line 1606
      if (tmp___40 != 0) {
        _L___3: /* CIL Label */ 
        {
#line 1609
        next_intuit_at(line_beginning___0, p_input_line);
        }
#line 1610
        if (chars_read == 0xffffffffffffffffUL) {
#line 1610
          tmp___39 = -1;
        } else {
#line 1610
          tmp___39 = 0;
        }
#line 1610
        return (tmp___39);
      }
    }
    {
#line 1612
    s = scan_linenum(buf + 4, & p_first);
    }
#line 1613
    if ((int )*s == 44) {
      {
#line 1614
      s = scan_linenum(s + 1, & p_ptrn_lines);
      }
    } else {
#line 1616
      p_ptrn_lines = (lin )1;
    }
#line 1617
    if ((int )*s == 32) {
#line 1617
      s ++;
    }
#line 1618
    if ((int )*s != 43) {
      {
#line 1619
      malformed();
      }
    }
    {
#line 1620
    s = scan_linenum(s + 1, & p_newfirst);
    }
#line 1621
    if ((int )*s == 44) {
      {
#line 1622
      s = scan_linenum(s + 1, & p_repl_lines);
      }
    } else {
#line 1624
      p_repl_lines = (lin )1;
    }
#line 1625
    if ((int )*s == 32) {
#line 1625
      s ++;
    }
#line 1626
    tmp___41 = s;
#line 1626
    s ++;
#line 1626
    if ((int )*tmp___41 != 64) {
      {
#line 1627
      malformed();
      }
    }
#line 1628
    tmp___42 = s;
#line 1628
    s ++;
#line 1628
    if ((int )*tmp___42 == 64) {
#line 1628
      if ((int )*s == 32) {
#line 1628
        if ((int )*s != 0) {
#line 1630
          p_c_function = s;
          {
#line 1631
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 1631
            if (! ((int )*s != 10)) {
#line 1631
              goto while_break___14;
            }
#line 1632
            s ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          {
#line 1633
          *s = (char )'\000';
#line 1634
          p_c_function = savestr((char const   *)p_c_function);
          }
        }
      }
    }
#line 1636
    if (! p_ptrn_lines) {
#line 1637
      p_first ++;
    }
#line 1638
    if (! p_repl_lines) {
#line 1639
      p_newfirst ++;
    }
#line 1640
    p_max = (p_ptrn_lines + p_repl_lines) + 1L;
    {
#line 1641
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1641
      if (! (p_max + 1L >= hunkmax)) {
#line 1641
        goto while_break___15;
      }
      {
#line 1642
      tmp___43 = grow_hunkmax();
      }
#line 1642
      if (! tmp___43) {
#line 1643
        return (-1);
      }
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 1644
    fillsrc___0 = (lin )1;
#line 1645
    filldst___0 = fillsrc___0 + p_ptrn_lines;
#line 1646
    p_end = filldst___0 + p_repl_lines;
#line 1647
    tmp___44 = format_linenum((char *)(numbuf1), (p_first + p_ptrn_lines) - 1L);
#line 1647
    tmp___45 = format_linenum((char *)(numbuf0), p_first);
#line 1647
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"*** %s,%s ****\n",
            tmp___45, tmp___44);
#line 1650
    *(p_len + 0) = strlen((char const   *)buf);
#line 1651
    tmp___46 = savestr((char const   *)buf);
#line 1651
    *(p_line + 0) = tmp___46;
    }
#line 1651
    if (! tmp___46) {
#line 1652
      p_end = (lin )-1;
#line 1653
      return (-1);
    }
    {
#line 1655
    *(p_Char + 0) = (char )'*';
#line 1656
    tmp___47 = format_linenum((char *)(numbuf1), (p_newfirst + p_repl_lines) - 1L);
#line 1656
    tmp___48 = format_linenum((char *)(numbuf0), p_newfirst);
#line 1656
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"--- %s,%s ----\n",
            tmp___48, tmp___47);
#line 1659
    *(p_len + filldst___0) = strlen((char const   *)buf);
#line 1660
    tmp___49 = savestr((char const   *)buf);
#line 1660
    *(p_line + filldst___0) = tmp___49;
    }
#line 1660
    if (! tmp___49) {
#line 1661
      p_end = (lin )0;
#line 1662
      return (-1);
    }
#line 1664
    tmp___50 = filldst___0;
#line 1664
    filldst___0 ++;
#line 1664
    *(p_Char + tmp___50) = (char )'=';
#line 1665
    p_prefix_context = (lin )-1;
#line 1666
    p_hunk_beg = p_input_line + 1L;
    {
#line 1667
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1667
      if (! (fillsrc___0 <= p_ptrn_lines)) {
#line 1667
        if (! (filldst___0 <= p_end)) {
#line 1667
          goto while_break___16;
        }
      }
      {
#line 1668
      chars_read = get_line();
      }
#line 1669
      if (! chars_read) {
#line 1670
        if (p_max - filldst___0 < 3L) {
          {
#line 1671
          strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)" \n");
#line 1672
          chars_read = (size_t )2;
          }
        } else {
          {
#line 1674
          fatal("unexpected end of file in patch");
          }
        }
      }
#line 1677
      if (chars_read == 0xffffffffffffffffUL) {
#line 1678
        s = (char *)0;
      } else
#line 1679
      if ((int )*buf == 9) {
        {
#line 1680
        ch = (char )' ';
#line 1681
        s = savebuf((char const   *)buf, chars_read);
        }
      } else
#line 1679
      if ((int )*buf == 10) {
        {
#line 1680
        ch = (char )' ';
#line 1681
        s = savebuf((char const   *)buf, chars_read);
        }
      } else {
        {
#line 1684
        ch = *buf;
#line 1685
        chars_read --;
#line 1685
        s = savebuf((char const   *)(buf + 1), chars_read);
        }
      }
#line 1687
      if (chars_read) {
#line 1687
        if (! s) {
          {
#line 1689
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 1689
            filldst___0 --;
#line 1689
            if (! (filldst___0 > p_ptrn_lines)) {
#line 1689
              goto while_break___17;
            }
            {
#line 1690
            free((void *)*(p_line + filldst___0));
            }
          }
          while_break___17: /* CIL Label */ ;
          }
#line 1691
          p_end = fillsrc___0 - 1L;
#line 1692
          return (-1);
        }
      }
      {
#line 1695
      if ((int )ch == 45) {
#line 1695
        goto case_45___0;
      }
#line 1706
      if ((int )ch == 61) {
#line 1706
        goto case_61;
      }
#line 1709
      if ((int )ch == 32) {
#line 1709
        goto case_32___0;
      }
#line 1730
      if ((int )ch == 43) {
#line 1730
        goto case_43___0;
      }
#line 1743
      goto switch_default___0;
      case_45___0: /* CIL Label */ 
#line 1696
      if (fillsrc___0 > p_ptrn_lines) {
        {
#line 1697
        free((void *)s);
#line 1698
        p_end = filldst___0 - 1L;
#line 1699
        malformed();
        }
      }
#line 1701
      if (fillsrc___0 == p_ptrn_lines) {
        {
#line 1701
        tmp___51 = incomplete_line();
        }
#line 1701
        if (tmp___51) {
#line 1701
          tmp___52 = 1;
        } else {
#line 1701
          tmp___52 = 0;
        }
      } else {
#line 1701
        tmp___52 = 0;
      }
#line 1701
      chars_read -= (size_t )tmp___52;
#line 1702
      *(p_Char + fillsrc___0) = ch;
#line 1703
      *(p_line + fillsrc___0) = s;
#line 1704
      tmp___53 = fillsrc___0;
#line 1704
      fillsrc___0 ++;
#line 1704
      *(p_len + tmp___53) = chars_read;
#line 1705
      goto switch_break___0;
      case_61: /* CIL Label */ 
#line 1707
      ch = (char )' ';
      case_32___0: /* CIL Label */ 
#line 1710
      if (fillsrc___0 > p_ptrn_lines) {
        {
#line 1711
        free((void *)s);
        }
        {
#line 1712
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 1712
          filldst___0 --;
#line 1712
          if (! (filldst___0 > p_ptrn_lines)) {
#line 1712
            goto while_break___18;
          }
          {
#line 1713
          free((void *)*(p_line + filldst___0));
          }
        }
        while_break___18: /* CIL Label */ ;
        }
        {
#line 1714
        p_end = fillsrc___0 - 1L;
#line 1715
        malformed();
        }
      }
#line 1717
      context ++;
#line 1718
      if (fillsrc___0 == p_ptrn_lines) {
        {
#line 1718
        tmp___54 = incomplete_line();
        }
#line 1718
        if (tmp___54) {
#line 1718
          tmp___55 = 1;
        } else {
#line 1718
          tmp___55 = 0;
        }
      } else {
#line 1718
        tmp___55 = 0;
      }
      {
#line 1718
      chars_read -= (size_t )tmp___55;
#line 1719
      *(p_Char + fillsrc___0) = ch;
#line 1720
      *(p_line + fillsrc___0) = s;
#line 1721
      tmp___56 = fillsrc___0;
#line 1721
      fillsrc___0 ++;
#line 1721
      *(p_len + tmp___56) = chars_read;
#line 1722
      s = savebuf((char const   *)s, chars_read);
      }
#line 1723
      if (chars_read) {
#line 1723
        if (! s) {
          {
#line 1724
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 1724
            filldst___0 --;
#line 1724
            if (! (filldst___0 > p_ptrn_lines)) {
#line 1724
              goto while_break___19;
            }
            {
#line 1725
            free((void *)*(p_line + filldst___0));
            }
          }
          while_break___19: /* CIL Label */ ;
          }
#line 1726
          p_end = fillsrc___0 - 1L;
#line 1727
          return (-1);
        }
      }
      case_43___0: /* CIL Label */ 
#line 1731
      if (filldst___0 > p_end) {
        {
#line 1732
        free((void *)s);
        }
        {
#line 1733
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 1733
          filldst___0 --;
#line 1733
          if (! (filldst___0 > p_ptrn_lines)) {
#line 1733
            goto while_break___20;
          }
          {
#line 1734
          free((void *)*(p_line + filldst___0));
          }
        }
        while_break___20: /* CIL Label */ ;
        }
        {
#line 1735
        p_end = fillsrc___0 - 1L;
#line 1736
        malformed();
        }
      }
#line 1738
      if (filldst___0 == p_end) {
        {
#line 1738
        tmp___57 = incomplete_line();
        }
#line 1738
        if (tmp___57) {
#line 1738
          tmp___58 = 1;
        } else {
#line 1738
          tmp___58 = 0;
        }
      } else {
#line 1738
        tmp___58 = 0;
      }
#line 1738
      chars_read -= (size_t )tmp___58;
#line 1739
      *(p_Char + filldst___0) = ch;
#line 1740
      *(p_line + filldst___0) = s;
#line 1741
      tmp___59 = filldst___0;
#line 1741
      filldst___0 ++;
#line 1741
      *(p_len + tmp___59) = chars_read;
#line 1742
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 1744
      p_end = filldst___0;
#line 1745
      malformed();
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 1747
      if ((int )ch != 32) {
#line 1748
        if (p_prefix_context == -1L) {
#line 1749
          p_prefix_context = context;
        }
#line 1750
        context = (lin )0;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1753
    if (p_prefix_context == -1L) {
      {
#line 1754
      malformed();
      }
    }
#line 1755
    p_suffix_context = context;
  } else {
    {
#line 1761
    tmp___60 = ftell(pfp);
#line 1761
    line_beginning___1 = tmp___60;
#line 1763
    p_suffix_context = (lin )0;
#line 1763
    p_prefix_context = p_suffix_context;
#line 1764
    chars_read = get_line();
    }
#line 1765
    if (chars_read == 0xffffffffffffffffUL) {
#line 1765
      goto _L___4;
    } else
#line 1765
    if (! chars_read) {
#line 1765
      goto _L___4;
    } else
#line 1765
    if (! ((unsigned int )*buf - 48U <= 9U)) {
      _L___4: /* CIL Label */ 
      {
#line 1766
      next_intuit_at(line_beginning___1, p_input_line);
      }
#line 1767
      if (chars_read == 0xffffffffffffffffUL) {
#line 1767
        tmp___61 = -1;
      } else {
#line 1767
        tmp___61 = 0;
      }
#line 1767
      return (tmp___61);
    }
    {
#line 1769
    s = scan_linenum(buf, & p_first);
    }
#line 1770
    if ((int )*s == 44) {
      {
#line 1771
      s = scan_linenum(s + 1, & p_ptrn_lines);
#line 1772
      p_ptrn_lines += 1L - p_first;
      }
    } else {
#line 1775
      p_ptrn_lines = (lin )((int )*s != 97);
    }
#line 1776
    hunk_type = *s;
#line 1777
    if ((int )hunk_type == 97) {
#line 1778
      p_first ++;
    }
    {
#line 1779
    s = scan_linenum(s + 1, & min);
    }
#line 1780
    if ((int )*s == 44) {
      {
#line 1781
      scan_linenum(s + 1, & max);
      }
    } else {
#line 1783
      max = min;
    }
#line 1784
    if ((int )hunk_type == 100) {
#line 1785
      min ++;
    }
#line 1786
    p_end = (((p_ptrn_lines + 1L) + max) - min) + 1L;
    {
#line 1787
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1787
      if (! (p_end + 1L >= hunkmax)) {
#line 1787
        goto while_break___21;
      }
      {
#line 1788
      tmp___62 = grow_hunkmax();
      }
#line 1788
      if (! tmp___62) {
#line 1790
        p_end = (lin )-1;
#line 1791
        return (-1);
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 1793
    p_newfirst = min;
#line 1794
    p_repl_lines = (max - min) + 1L;
#line 1795
    tmp___63 = format_linenum((char *)(numbuf1), (p_first + p_ptrn_lines) - 1L);
#line 1795
    tmp___64 = format_linenum((char *)(numbuf0), p_first);
#line 1795
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"*** %s,%s\n",
            tmp___64, tmp___63);
#line 1798
    *(p_len + 0) = strlen((char const   *)buf);
#line 1799
    tmp___65 = savestr((char const   *)buf);
#line 1799
    *(p_line + 0) = tmp___65;
    }
#line 1799
    if (! tmp___65) {
#line 1800
      p_end = (lin )-1;
#line 1801
      return (-1);
    }
#line 1803
    *(p_Char + 0) = (char )'*';
#line 1804
    i = 1;
    {
#line 1804
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1804
      if (! ((lin )i <= p_ptrn_lines)) {
#line 1804
        goto while_break___22;
      }
      {
#line 1805
      chars_read = get_line();
      }
#line 1806
      if (chars_read == 0xffffffffffffffffUL) {
#line 1808
        p_end = (lin )(i - 1);
#line 1809
        return (-1);
      }
#line 1811
      if (! chars_read) {
        {
#line 1812
        tmp___66 = format_linenum((char *)(numbuf0), p_input_line);
#line 1812
        fatal("unexpected end of file in patch at line %s", tmp___66);
        }
      }
#line 1814
      if ((int )*(buf + 0) != 60) {
        {
#line 1815
        tmp___67 = format_linenum((char *)(numbuf0), p_input_line);
#line 1815
        fatal("\'<\' expected at line %s of patch", tmp___67);
        }
      } else
#line 1814
      if ((int )*(buf + 1) != 32) {
#line 1814
        if ((int )*(buf + 1) != 9) {
          {
#line 1815
          tmp___67 = format_linenum((char *)(numbuf0), p_input_line);
#line 1815
          fatal("\'<\' expected at line %s of patch", tmp___67);
          }
        }
      }
#line 1817
      if ((lin )i == p_ptrn_lines) {
        {
#line 1817
        tmp___68 = incomplete_line();
        }
#line 1817
        if (tmp___68) {
#line 1817
          tmp___69 = 1;
        } else {
#line 1817
          tmp___69 = 0;
        }
      } else {
#line 1817
        tmp___69 = 0;
      }
      {
#line 1817
      chars_read -= (size_t )(2 + tmp___69);
#line 1818
      *(p_len + i) = chars_read;
#line 1819
      *(p_line + i) = savebuf((char const   *)(buf + 2), chars_read);
      }
#line 1820
      if (chars_read) {
#line 1820
        if (! *(p_line + i)) {
#line 1821
          p_end = (lin )(i - 1);
#line 1822
          return (-1);
        }
      }
#line 1824
      *(p_Char + i) = (char )'-';
#line 1804
      i ++;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 1826
    if ((int )hunk_type == 99) {
      {
#line 1827
      chars_read = get_line();
      }
#line 1828
      if (chars_read == 0xffffffffffffffffUL) {
#line 1830
        p_end = (lin )(i - 1);
#line 1831
        return (-1);
      }
#line 1833
      if (! chars_read) {
        {
#line 1834
        tmp___70 = format_linenum((char *)(numbuf0), p_input_line);
#line 1834
        fatal("unexpected end of file in patch at line %s", tmp___70);
        }
      }
#line 1836
      if ((int )*buf != 45) {
        {
#line 1837
        tmp___71 = format_linenum((char *)(numbuf0), p_input_line);
#line 1837
        fatal("\'---\' expected at line %s of patch", tmp___71);
        }
      }
    }
    {
#line 1840
    tmp___72 = format_linenum((char *)(numbuf1), max);
#line 1840
    tmp___73 = format_linenum((char *)(numbuf0), min);
#line 1840
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"--- %s,%s\n",
            tmp___73, tmp___72);
#line 1843
    *(p_len + i) = strlen((char const   *)buf);
#line 1844
    tmp___74 = savestr((char const   *)buf);
#line 1844
    *(p_line + i) = tmp___74;
    }
#line 1844
    if (! tmp___74) {
#line 1845
      p_end = (lin )(i - 1);
#line 1846
      return (-1);
    }
#line 1848
    *(p_Char + i) = (char )'=';
#line 1849
    i ++;
    {
#line 1849
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 1849
      if (! ((lin )i <= p_end)) {
#line 1849
        goto while_break___23;
      }
      {
#line 1850
      chars_read = get_line();
      }
#line 1851
      if (chars_read == 0xffffffffffffffffUL) {
#line 1853
        p_end = (lin )(i - 1);
#line 1854
        return (-1);
      }
#line 1856
      if (! chars_read) {
        {
#line 1857
        tmp___75 = format_linenum((char *)(numbuf0), p_input_line);
#line 1857
        fatal("unexpected end of file in patch at line %s", tmp___75);
        }
      }
#line 1859
      if ((int )*(buf + 0) != 62) {
        {
#line 1860
        tmp___76 = format_linenum((char *)(numbuf0), p_input_line);
#line 1860
        fatal("\'>\' expected at line %s of patch", tmp___76);
        }
      } else
#line 1859
      if ((int )*(buf + 1) != 32) {
#line 1859
        if ((int )*(buf + 1) != 9) {
          {
#line 1860
          tmp___76 = format_linenum((char *)(numbuf0), p_input_line);
#line 1860
          fatal("\'>\' expected at line %s of patch", tmp___76);
          }
        }
      }
#line 1862
      if ((lin )i == p_end) {
        {
#line 1862
        tmp___77 = incomplete_line();
        }
#line 1862
        if (tmp___77) {
#line 1862
          tmp___78 = 1;
        } else {
#line 1862
          tmp___78 = 0;
        }
      } else {
#line 1862
        tmp___78 = 0;
      }
      {
#line 1862
      chars_read -= (size_t )(2 + tmp___78);
#line 1863
      *(p_len + i) = chars_read;
#line 1864
      *(p_line + i) = savebuf((char const   *)(buf + 2), chars_read);
      }
#line 1865
      if (chars_read) {
#line 1865
        if (! *(p_line + i)) {
#line 1866
          p_end = (lin )(i - 1);
#line 1867
          return (-1);
        }
      }
#line 1869
      *(p_Char + i) = (char )'+';
#line 1849
      i ++;
    }
    while_break___23: /* CIL Label */ ;
    }
  }
#line 1872
  if (rev) {
    {
#line 1873
    tmp___79 = pch_swap();
    }
#line 1873
    if (! tmp___79) {
      {
#line 1874
      say("Not enough memory to swap next hunk!\n");
      }
    }
  }
#line 1875
  if (! (p_end + 1L < hunkmax)) {
    {
#line 1875
    __assert_fail("p_end + 1 < hunkmax", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                  1875U, "another_hunk");
    }
  }
#line 1876
  *(p_Char + (p_end + 1L)) = (char )'^';
#line 1877
  if (debug & 2) {
#line 1880
    i___0 = (lin )0;
    {
#line 1880
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 1880
      if (! (i___0 <= p_end + 1L)) {
#line 1880
        goto while_break___24;
      }
      {
#line 1881
      tmp___80 = format_linenum((char *)(numbuf0), i___0);
#line 1881
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %c",
              tmp___80, (int )*(p_Char + i___0));
      }
#line 1884
      if ((int )*(p_Char + i___0) == 42) {
        {
#line 1885
        tmp___81 = format_linenum((char *)(numbuf1), p_ptrn_lines);
#line 1885
        tmp___82 = format_linenum((char *)(numbuf0), p_first);
#line 1885
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s,%s\n",
                tmp___82, tmp___81);
        }
      } else
#line 1888
      if ((int )*(p_Char + i___0) == 61) {
        {
#line 1889
        tmp___83 = format_linenum((char *)(numbuf1), p_repl_lines);
#line 1889
        tmp___84 = format_linenum((char *)(numbuf0), p_newfirst);
#line 1889
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s,%s\n",
                tmp___84, tmp___83);
        }
      } else
#line 1892
      if ((int )*(p_Char + i___0) != 94) {
        {
#line 1894
        fputs((char const   */* __restrict  */)" |", (FILE */* __restrict  */)stderr);
#line 1895
        pch_write_line(i___0, stderr);
        }
      } else {
        {
#line 1898
        fputc('\n', stderr);
        }
      }
#line 1880
      i___0 ++;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 1900
    fflush(stderr);
    }
  }
#line 1902
  return (1);
}
}
#line 1905 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static size_t get_line(void) 
{ 
  size_t tmp ;

  {
  {
#line 1908
  tmp = pget_line(p_indent, p_rfc934_nesting, p_strip_trailing_cr, p_pass_comments_through);
  }
#line 1908
  return (tmp);
}
}
#line 1923 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static size_t pget_line(size_t indent , int rfc934_nesting , _Bool strip_trailing_cr ,
                        _Bool pass_comments_through ) 
{ 
  FILE *fp ;
  int c ;
  size_t i ;
  char *b ;
  size_t s ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp15 ;

  {
#line 1927
  fp = pfp;
  {
#line 1933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1935
    i = (size_t )0;
    {
#line 1936
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1938
      c = _IO_getc(fp);
      }
#line 1939
      if (c == -1) {
        {
#line 1941
        tmp = ferror(fp);
        }
#line 1941
        if (tmp) {
          {
#line 1942
          read_fatal();
          }
        }
#line 1943
        return ((size_t )0);
      }
#line 1945
      if (indent <= i) {
#line 1946
        goto while_break___0;
      }
#line 1947
      if (c == 32) {
#line 1948
        i ++;
      } else
#line 1947
      if (c == 88) {
#line 1948
        i ++;
      } else
#line 1949
      if (c == 9) {
#line 1950
        i = (i + 8UL) & 0xfffffffffffffff8UL;
      } else {
#line 1952
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1955
    i = (size_t )0;
#line 1956
    b = buf;
    {
#line 1958
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1958
      if (c == 45) {
#line 1958
        rfc934_nesting --;
#line 1958
        if (! (0 <= rfc934_nesting)) {
#line 1958
          goto while_break___1;
        }
      } else {
#line 1958
        goto while_break___1;
      }
      {
#line 1960
      c = _IO_getc(fp);
      }
#line 1961
      if (c == -1) {
#line 1962
        goto patch_ends_in_middle_of_line;
      }
#line 1963
      if (c != 32) {
#line 1965
        i = (size_t )1;
#line 1966
        *(b + 0) = (char )'-';
#line 1967
        goto while_break___1;
      }
      {
#line 1969
      c = _IO_getc(fp);
      }
#line 1970
      if (c == -1) {
#line 1971
        goto patch_ends_in_middle_of_line;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1974
    s = bufsize;
    {
#line 1976
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1978
      if (i == s - 1UL) {
        {
#line 1980
        s *= 2UL;
#line 1981
        tmp___0 = realloc((void *)b, s);
#line 1981
        b = (char *)tmp___0;
        }
#line 1982
        if (! b) {
#line 1984
          if (! using_plan_a) {
            {
#line 1985
            xalloc_die();
            }
          }
#line 1986
          return ((size_t )-1);
        }
#line 1988
        buf = b;
#line 1989
        bufsize = s;
      }
#line 1991
      tmp___1 = i;
#line 1991
      i ++;
#line 1991
      *(b + tmp___1) = (char )c;
#line 1992
      if (c == 10) {
#line 1993
        goto while_break___2;
      }
      {
#line 1994
      c = _IO_getc(fp);
      }
#line 1995
      if (c == -1) {
#line 1996
        goto patch_ends_in_middle_of_line;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1999
    p_input_line ++;
#line 1933
    if ((int )*b == 35) {
#line 1933
      if (! (! pass_comments_through)) {
#line 1933
        goto while_break;
      }
    } else {
#line 1933
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2003
  if (strip_trailing_cr) {
#line 2003
    if (2UL <= i) {
#line 2003
      if ((int )*(b + (i - 2UL)) == 13) {
#line 2004
        tmp___2 = i;
#line 2004
        i --;
#line 2004
        *(b + (tmp___2 - 2UL)) = (char )'\n';
      }
    }
  }
#line 2005
  *(b + i) = (char )'\000';
#line 2006
  return (i);
  patch_ends_in_middle_of_line: 
  {
#line 2009
  tmp___3 = ferror(fp);
  }
#line 2009
  if (tmp___3) {
    {
#line 2010
    read_fatal();
    }
  }
  {
#line 2011
  say("patch unexpectedly ends in middle of line\n");
  }
#line 2012
  return ((size_t )0);
}
}
#line 2015 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static _Bool incomplete_line(void) 
{ 
  FILE *fp ;
  int c ;
  file_offset line_beginning ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 2018
  fp = pfp;
#line 2020
  tmp = ftell(fp);
#line 2020
  line_beginning = tmp;
#line 2022
  tmp___0 = _IO_getc(fp);
  }
#line 2022
  if (tmp___0 == 92) {
    {
#line 2024
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2024
      c = _IO_getc(fp);
      }
#line 2024
      if (c != 10) {
#line 2024
        if (! (c != -1)) {
#line 2024
          goto while_break;
        }
      } else {
#line 2024
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2026
    return ((_Bool)1);
  } else {
    {
#line 2031
    Fseek(pfp, line_beginning, 0);
    }
#line 2032
    return ((_Bool)0);
  }
}
}
#line 2038 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
_Bool pch_swap(void) 
{ 
  char **tp_line ;
  size_t *tp_len ;
  char *tp_char ;
  lin i ;
  lin n ;
  _Bool blankline ;
  char *s ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 2046
  blankline = (_Bool)0;
#line 2049
  i = p_first;
#line 2050
  p_first = p_newfirst;
#line 2051
  p_newfirst = i;
#line 2055
  tp_line = p_line;
#line 2056
  tp_len = p_len;
#line 2057
  tp_char = p_Char;
#line 2058
  p_line = (char **)0;
#line 2059
  p_len = (size_t *)0;
#line 2060
  p_Char = (char *)0;
#line 2061
  set_hunkmax();
  }
#line 2062
  if (! p_line) {
#line 2062
    goto _L;
  } else
#line 2062
  if (! p_len) {
#line 2062
    goto _L;
  } else
#line 2062
  if (! p_Char) {
    _L: /* CIL Label */ 
    {
#line 2063
    free((void *)p_line);
#line 2064
    p_line = tp_line;
#line 2065
    free((void *)p_len);
#line 2066
    p_len = tp_len;
#line 2067
    free((void *)p_Char);
#line 2068
    p_Char = tp_char;
    }
#line 2069
    return ((_Bool)0);
  }
#line 2074
  i = p_ptrn_lines + 1L;
#line 2075
  if ((int )*(tp_char + i) == 10) {
#line 2076
    blankline = (_Bool)1;
#line 2077
    i ++;
  }
#line 2079
  if (p_efake >= 0L) {
#line 2080
    if (p_efake <= i) {
#line 2081
      n = (p_end - i) + 1L;
    } else {
#line 2083
      n = - i;
    }
#line 2084
    p_efake += n;
#line 2085
    p_bfake += n;
  }
#line 2087
  n = (lin )0;
  {
#line 2087
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2087
    if (! (i <= p_end)) {
#line 2087
      goto while_break;
    }
#line 2088
    *(p_line + n) = *(tp_line + i);
#line 2089
    *(p_Char + n) = *(tp_char + i);
#line 2090
    if ((int )*(p_Char + n) == 43) {
#line 2091
      *(p_Char + n) = (char )'-';
    }
#line 2092
    *(p_len + n) = *(tp_len + i);
#line 2087
    i ++;
#line 2087
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2094
  if (blankline) {
#line 2095
    i = p_ptrn_lines + 1L;
#line 2096
    *(p_line + n) = *(tp_line + i);
#line 2097
    *(p_Char + n) = *(tp_char + i);
#line 2098
    *(p_len + n) = *(tp_len + i);
#line 2099
    n ++;
  }
#line 2101
  if (! ((int )*(p_Char + 0) == 61)) {
    {
#line 2101
    __assert_fail("p_Char[0] == \'=\'", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                  2101U, "pch_swap");
    }
  }
#line 2102
  *(p_Char + 0) = (char )'*';
#line 2103
  s = *(p_line + 0);
  {
#line 2103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2103
    if (! *s) {
#line 2103
      goto while_break___0;
    }
#line 2104
    if ((int )*s == 45) {
#line 2105
      *s = (char )'*';
    }
#line 2103
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2109
  if (! ((int )*(tp_char + 0) == 42)) {
    {
#line 2109
    __assert_fail("tp_char[0] == \'*\'", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                  2109U, "pch_swap");
    }
  }
#line 2110
  *(tp_char + 0) = (char )'=';
#line 2111
  s = *(tp_line + 0);
  {
#line 2111
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2111
    if (! *s) {
#line 2111
      goto while_break___1;
    }
#line 2112
    if ((int )*s == 42) {
#line 2113
      *s = (char )'-';
    }
#line 2111
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2114
  i = (lin )0;
  {
#line 2114
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2114
    if (! (n <= p_end)) {
#line 2114
      goto while_break___2;
    }
#line 2115
    *(p_line + n) = *(tp_line + i);
#line 2116
    *(p_Char + n) = *(tp_char + i);
#line 2117
    if ((int )*(p_Char + n) == 45) {
#line 2118
      *(p_Char + n) = (char )'+';
    }
#line 2119
    *(p_len + n) = *(tp_len + i);
#line 2114
    i ++;
#line 2114
    n ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2121
  if (! (i == p_ptrn_lines + 1L)) {
    {
#line 2121
    __assert_fail("i == p_ptrn_lines + 1", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                  2121U, "pch_swap");
    }
  }
  {
#line 2122
  i = p_ptrn_lines;
#line 2123
  p_ptrn_lines = p_repl_lines;
#line 2124
  p_repl_lines = i;
#line 2125
  *(p_Char + (p_end + 1L)) = (char )'^';
#line 2126
  free((void *)tp_line);
#line 2127
  free((void *)tp_len);
#line 2128
  free((void *)tp_char);
  }
#line 2129
  return ((_Bool)1);
}
}
#line 2135
int pch_says_nonexistent(_Bool which )  __attribute__((__pure__)) ;
#line 2135 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
int pch_says_nonexistent(_Bool which ) 
{ 


  {
#line 2138
  return (p_says_nonexistent[which]);
}
}
#line 2141
char const   *pch_name(enum nametype type )  __attribute__((__pure__)) ;
#line 2141 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
char const   *pch_name(enum nametype type ) 
{ 
  char *tmp ;

  {
#line 2144
  if ((unsigned int )type == 3U) {
#line 2144
    tmp = (char *)((void *)0);
  } else {
#line 2144
    tmp = p_name[type];
  }
#line 2144
  return ((char const   *)tmp);
}
}
#line 2147
_Bool pch_copy(void)  __attribute__((__pure__)) ;
#line 2147 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
_Bool pch_copy(void) 
{ 
  int tmp ;

  {
#line 2149
  if (p_copy[0]) {
#line 2149
    if (p_copy[1]) {
#line 2149
      if (p_name[0]) {
#line 2149
        if (p_name[1]) {
#line 2149
          tmp = 1;
        } else {
#line 2149
          tmp = 0;
        }
      } else {
#line 2149
        tmp = 0;
      }
    } else {
#line 2149
      tmp = 0;
    }
  } else {
#line 2149
    tmp = 0;
  }
#line 2149
  return ((_Bool )tmp);
}
}
#line 2153
_Bool pch_rename(void)  __attribute__((__pure__)) ;
#line 2153 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
_Bool pch_rename(void) 
{ 
  int tmp ;

  {
#line 2155
  if (p_rename[0]) {
#line 2155
    if (p_rename[1]) {
#line 2155
      if (p_name[0]) {
#line 2155
        if (p_name[1]) {
#line 2155
          tmp = 1;
        } else {
#line 2155
          tmp = 0;
        }
      } else {
#line 2155
        tmp = 0;
      }
    } else {
#line 2155
      tmp = 0;
    }
  } else {
#line 2155
    tmp = 0;
  }
#line 2155
  return ((_Bool )tmp);
}
}
#line 2161
lin pch_first(void)  __attribute__((__pure__)) ;
#line 2161 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
lin pch_first(void) 
{ 


  {
#line 2164
  return (p_first);
}
}
#line 2169
lin pch_ptrn_lines(void)  __attribute__((__pure__)) ;
#line 2169 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
lin pch_ptrn_lines(void) 
{ 


  {
#line 2172
  return (p_ptrn_lines);
}
}
#line 2177
lin pch_newfirst(void)  __attribute__((__pure__)) ;
#line 2177 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
lin pch_newfirst(void) 
{ 


  {
#line 2180
  return (p_newfirst);
}
}
#line 2185
lin pch_repl_lines(void)  __attribute__((__pure__)) ;
#line 2185 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
lin pch_repl_lines(void) 
{ 


  {
#line 2188
  return (p_repl_lines);
}
}
#line 2193
lin pch_end(void)  __attribute__((__pure__)) ;
#line 2193 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
lin pch_end(void) 
{ 


  {
#line 2196
  return (p_end);
}
}
#line 2201
lin pch_prefix_context(void)  __attribute__((__pure__)) ;
#line 2201 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
lin pch_prefix_context(void) 
{ 


  {
#line 2204
  return (p_prefix_context);
}
}
#line 2209
lin pch_suffix_context(void)  __attribute__((__pure__)) ;
#line 2209 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
lin pch_suffix_context(void) 
{ 


  {
#line 2212
  return (p_suffix_context);
}
}
#line 2217
size_t pch_line_len(lin line )  __attribute__((__pure__)) ;
#line 2217 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
size_t pch_line_len(lin line ) 
{ 


  {
#line 2220
  return (*(p_len + line));
}
}
#line 2227
char pch_char(lin line )  __attribute__((__pure__)) ;
#line 2227 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
char pch_char(lin line ) 
{ 


  {
#line 2230
  return (*(p_Char + line));
}
}
#line 2235
char *pfetch(lin line )  __attribute__((__pure__)) ;
#line 2235 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
char *pfetch(lin line ) 
{ 


  {
#line 2238
  return (*(p_line + line));
}
}
#line 2243 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
_Bool pch_write_line(lin line , FILE *file ) 
{ 
  _Bool after_newline ;
  size_t tmp ;

  {
  {
#line 2246
  after_newline = (_Bool )((int )*(*(p_line + line) + (*(p_len + line) - 1UL)) == 10);
#line 2247
  tmp = fwrite((void const   */* __restrict  */)*(p_line + line), sizeof(*(*(p_line + line))),
               *(p_len + line), (FILE */* __restrict  */)file);
  }
#line 2247
  if (! tmp) {
    {
#line 2248
    write_fatal();
    }
  }
#line 2249
  return (after_newline);
}
}
#line 2254
lin pch_hunk_beg(void)  __attribute__((__pure__)) ;
#line 2254 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
lin pch_hunk_beg(void) 
{ 


  {
#line 2257
  return (p_hunk_beg);
}
}
#line 2260
char const   *pch_c_function(void)  __attribute__((__pure__)) ;
#line 2260 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
char const   *pch_c_function(void) 
{ 


  {
#line 2263
  return ((char const   *)p_c_function);
}
}
#line 2268
_Bool pch_git_diff(void)  __attribute__((__pure__)) ;
#line 2268 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
_Bool pch_git_diff(void) 
{ 


  {
#line 2271
  return (p_git_diff);
}
}
#line 2274
char const   *pch_timestr(_Bool which )  __attribute__((__pure__)) ;
#line 2274 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
char const   *pch_timestr(_Bool which ) 
{ 


  {
#line 2277
  return ((char const   *)p_timestr[which]);
}
}
#line 2280
char const   *pch_sha1(_Bool which )  __attribute__((__pure__)) ;
#line 2280 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
char const   *pch_sha1(_Bool which ) 
{ 


  {
#line 2283
  return ((char const   *)p_sha1[which]);
}
}
#line 2286
mode_t pch_mode(_Bool which )  __attribute__((__pure__)) ;
#line 2286 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
mode_t pch_mode(_Bool which ) 
{ 


  {
#line 2289
  return (p_mode[which]);
}
}
#line 2297 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char __attribute__((__pure__))  get_ed_command_letter(char const   *line ) 
{ 
  char const   *p ;
  char letter ;
  _Bool pair ;
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 2300
  p = line;
#line 2302
  pair = (_Bool)0;
#line 2304
  if ((unsigned int )*p - 48U <= 9U) {
    {
#line 2306
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2306
      p ++;
#line 2306
      if (! ((unsigned int )*p - 48U <= 9U)) {
#line 2306
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2308
    if ((int const   )*p == 44) {
#line 2310
      p ++;
#line 2310
      if (! ((unsigned int )*p - 48U <= 9U)) {
#line 2311
        return ((char __attribute__((__pure__))  )0);
      }
      {
#line 2312
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2312
        p ++;
#line 2312
        if (! ((unsigned int )*p - 48U <= 9U)) {
#line 2312
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2314
      pair = (_Bool)1;
    }
  }
#line 2318
  tmp = p;
#line 2318
  p ++;
#line 2318
  letter = (char )*tmp;
  {
#line 2323
  if ((int )letter == 105) {
#line 2323
    goto case_105;
  }
#line 2323
  if ((int )letter == 97) {
#line 2323
    goto case_105;
  }
#line 2329
  if ((int )letter == 100) {
#line 2329
    goto case_100;
  }
#line 2329
  if ((int )letter == 99) {
#line 2329
    goto case_100;
  }
#line 2332
  if ((int )letter == 115) {
#line 2332
    goto case_115;
  }
#line 2338
  goto switch_default;
  case_105: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 2324
  if (pair) {
#line 2325
    return ((char __attribute__((__pure__))  )0);
  }
#line 2326
  goto switch_break;
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
#line 2330
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 2333
  tmp___0 = strncmp(p, "/.//", (size_t )4);
  }
#line 2333
  if (tmp___0 != 0) {
#line 2334
    return ((char __attribute__((__pure__))  )0);
  }
#line 2335
  p += 4;
#line 2336
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2339
  return ((char __attribute__((__pure__))  )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 2342
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2342
    if (! ((int const   )*p == 32)) {
#line 2342
      if (! ((int const   )*p == 9)) {
#line 2342
        goto while_break___1;
      }
    }
#line 2343
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2344
  if ((int const   )*p == 10) {
#line 2345
    return ((char __attribute__((__pure__))  )letter);
  }
#line 2346
  return ((char __attribute__((__pure__))  )0);
}
}
#line 2355 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
static char const   editor_program[8]  = 
#line 2355
  {      (char const   )'/',      (char const   )'b',      (char const   )'i',      (char const   )'n', 
        (char const   )'/',      (char const   )'e',      (char const   )'d',      (char const   )'\000'};
#line 2351 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
void do_ed_script(char const   *inname___0 , char const   *outname , int *outname_needs_removal ,
                  FILE *ofp ) 
{ 
  file_offset beginning_of_this_line ;
  FILE *pipefp ;
  size_t chars_read ;
  int exclusive ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char ed_command_letter ;
  char __attribute__((__pure__))  tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  FILE *ifp ;
  FILE *tmp___9 ;
  int c ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 2358
  pipefp = (FILE *)0;
#line 2361
  if (! dry_run) {
#line 2361
    if (! skip_rest_of_patch) {
#line 2362
      if (*outname_needs_removal) {
#line 2362
        tmp = 0;
      } else {
#line 2362
        tmp = 128;
      }
#line 2362
      exclusive = tmp;
#line 2363
      if (! (! inerrno)) {
        {
#line 2363
        __assert_fail("! inerrno", "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c",
                      2363U, "do_ed_script");
        }
      }
      {
#line 2364
      *outname_needs_removal = 1;
#line 2365
      copy_file(inname___0, outname, (struct stat *)0, exclusive, instat.st_mode,
                (_Bool)1);
      }
#line 2366
      if ((unsigned int )verbosity == 2U) {
#line 2366
        tmp___0 = "";
      } else {
#line 2366
        tmp___0 = "- ";
      }
      {
#line 2366
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s %s%s",
              editor_program, tmp___0, outname);
#line 2369
      fflush(stdout);
#line 2370
      pipefp = popen((char const   *)buf, "w");
      }
#line 2371
      if (! pipefp) {
        {
#line 2372
        tmp___1 = quotearg((char const   *)buf);
#line 2372
        pfatal("Can\'t open pipe to %s", tmp___1);
        }
      }
    }
  }
  {
#line 2374
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2376
    beginning_of_this_line = ftell(pfp);
#line 2377
    chars_read = get_line();
    }
#line 2378
    if (! chars_read) {
      {
#line 2379
      next_intuit_at(beginning_of_this_line, p_input_line);
      }
#line 2380
      goto while_break;
    }
    {
#line 2382
    tmp___2 = get_ed_command_letter((char const   *)buf);
#line 2382
    ed_command_letter = (char )tmp___2;
    }
#line 2383
    if (ed_command_letter) {
#line 2384
      if (pipefp) {
        {
#line 2385
        tmp___3 = fwrite((void const   */* __restrict  */)buf, sizeof(*buf), chars_read,
                         (FILE */* __restrict  */)pipefp);
        }
#line 2385
        if (! tmp___3) {
          {
#line 2386
          write_fatal();
          }
        }
      }
#line 2387
      if ((int )ed_command_letter != 100) {
#line 2387
        if ((int )ed_command_letter != 115) {
#line 2388
          p_pass_comments_through = (_Bool)1;
          {
#line 2389
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 2389
            chars_read = get_line();
            }
#line 2389
            if (! (chars_read != 0UL)) {
#line 2389
              goto while_break___0;
            }
#line 2390
            if (pipefp) {
              {
#line 2391
              tmp___4 = fwrite((void const   */* __restrict  */)buf, sizeof(*buf),
                               chars_read, (FILE */* __restrict  */)pipefp);
              }
#line 2391
              if (! tmp___4) {
                {
#line 2392
                write_fatal();
                }
              }
            }
#line 2393
            if (chars_read == 2UL) {
              {
#line 2393
              tmp___5 = strcmp((char const   *)buf, ".\n");
              }
#line 2393
              if (! tmp___5) {
#line 2394
                goto while_break___0;
              }
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2396
          p_pass_comments_through = (_Bool)0;
        }
      }
    } else {
      {
#line 2400
      next_intuit_at(beginning_of_this_line, p_input_line);
      }
#line 2401
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2404
  if (! pipefp) {
#line 2405
    return;
  }
  {
#line 2406
  tmp___6 = fwrite((void const   */* __restrict  */)"w\nq\n", sizeof(char ), (size_t )4,
                   (FILE */* __restrict  */)pipefp);
  }
#line 2406
  if (tmp___6 == 0UL) {
    {
#line 2408
    write_fatal();
    }
  } else {
    {
#line 2406
    tmp___7 = fflush(pipefp);
    }
#line 2406
    if (tmp___7 != 0) {
      {
#line 2408
      write_fatal();
      }
    }
  }
  {
#line 2409
  tmp___8 = pclose(pipefp);
  }
#line 2409
  if (tmp___8 != 0) {
    {
#line 2410
    fatal("%s FAILED", editor_program);
    }
  }
#line 2412
  if (ofp) {
    {
#line 2414
    tmp___9 = fopen((char const   */* __restrict  */)outname, (char const   */* __restrict  */)"r");
#line 2414
    ifp = tmp___9;
    }
#line 2416
    if (! ifp) {
      {
#line 2417
      pfatal("can\'t open \'%s\'", outname);
      }
    }
    {
#line 2418
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2418
      c = _IO_getc(ifp);
      }
#line 2418
      if (! (c != -1)) {
#line 2418
        goto while_break___1;
      }
      {
#line 2419
      tmp___10 = _IO_putc(c, ofp);
      }
#line 2419
      if (tmp___10 == -1) {
        {
#line 2420
        write_fatal();
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2421
    tmp___11 = ferror(ifp);
    }
#line 2421
    if (tmp___11) {
      {
#line 2422
      read_fatal();
      }
    } else {
      {
#line 2421
      tmp___12 = fclose(ifp);
      }
#line 2421
      if (tmp___12 != 0) {
        {
#line 2422
        read_fatal();
        }
      }
    }
  }
#line 2424
  return;
}
}
#line 2426 "/home/wslee/gnu_benchmarks/patch-2.7/src/pch.c"
void pch_normalize(enum diff format ) 
{ 
  lin old ;
  lin new ;

  {
#line 2429
  old = (lin )1;
#line 2430
  new = p_ptrn_lines + 1L;
  {
#line 2432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2432
    if (! ((int )*(p_Char + new) == 61)) {
#line 2432
      if (! ((int )*(p_Char + new) == 10)) {
#line 2432
        goto while_break;
      }
    }
#line 2433
    new ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2435
  if ((unsigned int )format == 5U) {
    {
#line 2440
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2440
      if (! (old <= p_ptrn_lines)) {
#line 2440
        goto while_break___0;
      }
#line 2441
      if ((int )*(p_Char + old) == 33) {
#line 2442
        *(p_Char + old) = (char )'-';
      }
#line 2440
      old ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2443
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2443
      if (! (new <= p_end)) {
#line 2443
        goto while_break___1;
      }
#line 2444
      if ((int )*(p_Char + new) == 33) {
#line 2445
        *(p_Char + new) = (char )'+';
      }
#line 2443
      new ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 2452
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2452
      if (! (old <= p_ptrn_lines)) {
#line 2452
        goto while_break___2;
      }
#line 2454
      if ((int )*(p_Char + old) == 45) {
#line 2456
        if (new <= p_end) {
#line 2456
          if ((int )*(p_Char + new) == 43) {
            {
#line 2458
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2460
              *(p_Char + old) = (char )'!';
#line 2461
              old ++;
#line 2458
              if (old <= p_ptrn_lines) {
#line 2458
                if (! ((int )*(p_Char + old) == 45)) {
#line 2458
                  goto while_break___3;
                }
              } else {
#line 2458
                goto while_break___3;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 2464
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2466
              *(p_Char + new) = (char )'!';
#line 2467
              new ++;
#line 2464
              if (new <= p_end) {
#line 2464
                if (! ((int )*(p_Char + new) == 43)) {
#line 2464
                  goto while_break___4;
                }
              } else {
#line 2464
                goto while_break___4;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
          } else {
#line 2456
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 2473
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 2474
            old ++;
#line 2473
            if (old <= p_ptrn_lines) {
#line 2473
              if (! ((int )*(p_Char + old) == 45)) {
#line 2473
                goto while_break___5;
              }
            } else {
#line 2473
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      } else
#line 2478
      if (new <= p_end) {
#line 2478
        if ((int )*(p_Char + new) == 43) {
          {
#line 2480
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2481
            new ++;
#line 2480
            if (new <= p_end) {
#line 2480
              if (! ((int )*(p_Char + new) == 43)) {
#line 2480
                goto while_break___6;
              }
            } else {
#line 2480
              goto while_break___6;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
        } else {
#line 2486
          old ++;
#line 2487
          new ++;
        }
      } else {
#line 2486
        old ++;
#line 2487
        new ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2491
  return;
}
}
#line 309 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void setbuf(FILE * __restrict  __stream , char * __restrict  __buf ) ;
#line 73 "./common.h"
char *buf  ;
#line 74 "./common.h"
size_t bufsize  ;
#line 76 "./common.h"
_Bool using_plan_a  ;
#line 78 "./common.h"
char *inname  ;
#line 79 "./common.h"
char *outfile  ;
#line 80 "./common.h"
int inerrno  ;
#line 81 "./common.h"
int invc  ;
#line 82 "./common.h"
struct stat instat  ;
#line 83 "./common.h"
_Bool dry_run  ;
#line 84 "./common.h"
_Bool posixly_correct  ;
#line 86 "./common.h"
char const   *origprae  ;
#line 87 "./common.h"
char const   *origbase  ;
#line 88 "./common.h"
char const   *origsuff  ;
#line 90 "./common.h"
char const   *TMPINNAME  ;
#line 91 "./common.h"
char const   *TMPOUTNAME  ;
#line 92 "./common.h"
char const   *TMPPATNAME  ;
#line 94 "./common.h"
int TMPINNAME_needs_removal  ;
#line 95 "./common.h"
int TMPOUTNAME_needs_removal  ;
#line 96 "./common.h"
int TMPPATNAME_needs_removal  ;
#line 99 "./common.h"
int debug  ;
#line 103 "./common.h"
_Bool force  ;
#line 104 "./common.h"
_Bool batch  ;
#line 105 "./common.h"
_Bool noreverse  ;
#line 106 "./common.h"
_Bool reverse  ;
#line 107 "./common.h"
enum __anonenum_verbosity_22 verbosity  ;
#line 108 "./common.h"
_Bool skip_rest_of_patch  ;
#line 109 "./common.h"
int strippath  ;
#line 110 "./common.h"
_Bool canonicalize  ;
#line 111 "./common.h"
int patch_get  ;
#line 112 "./common.h"
_Bool set_time  ;
#line 113 "./common.h"
_Bool set_utc  ;
#line 126 "./common.h"
enum diff diff_type  ;
#line 128 "./common.h"
char *revision  ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 493
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 526
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 180 "./common.h"
_Bool no_strip_trailing_cr  ;
#line 199 "./common.h"
lin in_offset  ;
#line 200 "./common.h"
lin out_offset  ;
#line 203 "./common.h"
lin last_frozen_line  ;
#line 210 "./common.h"
enum conflict_style conflict_style  ;
#line 23 "./inp.h"
_Bool get_input_file(char const   *filename , char const   *outname , mode_t mode ) ;
#line 24
void re_input(void) ;
#line 25
void scan_input(char *filename , mode_t file_type ) ;
#line 58 "./pch.h"
__inline static struct timespec pch_timestamp(_Bool which ) 
{ 


  {
#line 60
  return (p_timestamp[which]);
}
}
#line 549 "../lib/gl_list.h"
__inline static gl_list_t gl_list_nx_create_empty_inline(gl_list_implementation_t implementation ,
                                                         _Bool (*equals_fn)(void const   *elt1 ,
                                                                            void const   *elt2 ) ,
                                                         size_t (*hashcode_fn)(void const   *elt ) ,
                                                         void (*dispose_fn)(void const   *elt ) ,
                                                         _Bool allow_duplicates ) 
{ 
  gl_list_t tmp ;

  {
  {
#line 556
  tmp = (*(implementation->nx_create_empty))(implementation, equals_fn, hashcode_fn,
                                             dispose_fn, allow_duplicates);
  }
#line 556
  return (tmp);
}
}
#line 576 "../lib/gl_list.h"
__inline static size_t gl_list_size_inline(gl_list_t list ) 
{ 
  size_t tmp ;

  {
  {
#line 579
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->size))(list);
  }
#line 579
  return (tmp);
}
}
#line 617 "../lib/gl_list.h"
__inline static void const   *gl_list_get_at_inline(gl_list_t list , size_t position ) 
{ 
  void const   *tmp ;

  {
  {
#line 620
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->get_at))(list, position);
  }
#line 620
  return (tmp);
}
}
#line 695 "../lib/gl_list.h"
__inline static gl_list_node_t gl_list_nx_add_last_inline(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 698
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->nx_add_last))(list,
                                                                               elt);
  }
#line 698
  return (tmp);
}
}
#line 735 "../lib/gl_list.h"
__inline static _Bool gl_list_remove_at_inline(gl_list_t list , size_t position ) 
{ 
  _Bool tmp ;

  {
  {
#line 738
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->remove_at))(list,
                                                                             position);
  }
#line 738
  return (tmp);
}
}
#line 758 "../lib/gl_list.h"
__inline static gl_list_iterator_t gl_list_iterator_inline(gl_list_t list ) 
{ 
  gl_list_iterator_t tmp ;
  void *__cil_tmp3 ;

  {
  {
#line 761
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->iterator))(list);
  }
#line 761
  return (tmp);
}
}
#line 774 "../lib/gl_list.h"
__inline static _Bool gl_list_iterator_next_inline(gl_list_iterator_t *iterator ,
                                                   void const   **eltp , gl_list_node_t *nodep ) 
{ 
  _Bool tmp ;

  {
  {
#line 778
  tmp = (*((iterator->vtable)->iterator_next))(iterator, eltp, nodep);
  }
#line 778
  return (tmp);
}
}
#line 782 "../lib/gl_list.h"
__inline static void gl_list_iterator_free_inline(gl_list_iterator_t *iterator ) 
{ 


  {
  {
#line 785
  (*((iterator->vtable)->iterator_free))(iterator);
  }
#line 786
  return;
}
}
#line 61 "../lib/gl_xlist.h"
__inline static gl_list_t gl_list_create_empty_inline(gl_list_implementation_t implementation ,
                                                      _Bool (*equals_fn)(void const   *elt1 ,
                                                                         void const   *elt2 ) ,
                                                      size_t (*hashcode_fn)(void const   *elt ) ,
                                                      void (*dispose_fn)(void const   *elt ) ,
                                                      _Bool allow_duplicates ) 
{ 
  gl_list_t result ;
  gl_list_t tmp ;

  {
  {
#line 68
  tmp = gl_list_nx_create_empty_inline(implementation, equals_fn, hashcode_fn, dispose_fn,
                                       allow_duplicates);
#line 68
  result = tmp;
  }
#line 71
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 72
    xalloc_die();
    }
  }
#line 73
  return (result);
}
}
#line 123 "../lib/gl_xlist.h"
__inline static gl_list_node_t gl_list_add_last_inline(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t result ;
  gl_list_node_t tmp ;

  {
  {
#line 126
  tmp = gl_list_nx_add_last_inline(list, elt);
#line 126
  result = tmp;
  }
#line 127
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 128
    xalloc_die();
    }
  }
#line 129
  return (result);
}
}
#line 39 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static FILE *create_output_file(char const   *name , int open_flags ) ;
#line 40
static lin locate_hunk(lin fuzz ) ;
#line 41
static _Bool apply_hunk(struct outstate *outstate , lin where ) ;
#line 42
static _Bool patch_match(lin base , lin offset , lin prefix_fuzz , lin suffix_fuzz ) ;
#line 43
static _Bool spew_output(struct outstate *outstate , struct stat *st ) ;
#line 44
static int numeric_string(char const   *string , _Bool negative_allowed , char const   *argtype_msgid ) ;
#line 45
static void cleanup(void) ;
#line 46
static void get_some_switches(void) ;
#line 47
static void init_output(struct outstate *outstate ) ;
#line 48
static FILE *open_outfile(char const   *name ) ;
#line 49
static void init_reject(char const   *outname ) ;
#line 50
static void reinitialize_almost_everything(void) ;
#line 51
static void remove_if_needed(char const   *name , int *needs_removal ) ;
#line 52
static  __attribute__((__noreturn__)) void usage(FILE *stream , int status ) ;
#line 54
static void abort_hunk(char const   *outname , _Bool header , _Bool reverse___0 ) ;
#line 55
static void abort_hunk_context(_Bool header , _Bool reverse___0 ) ;
#line 56
static void abort_hunk_unified(_Bool header , _Bool reverse___0 ) ;
#line 58
static void output_file(char const   *from , int *from_needs_removal , struct stat  const  *from_st ,
                        char const   *to , struct stat  const  *to_st , mode_t mode ,
                        _Bool backup ) ;
#line 61
static void init_files_to_delete(void) ;
#line 62
static void init_files_to_output(void) ;
#line 63
static void delete_files(void) ;
#line 64
static void output_files(struct stat  const  *st ) ;
#line 67 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static _Bool merge  ;
#line 72 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static enum diff reject_format  =    (enum diff )0;
#line 73 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static _Bool make_backups  ;
#line 74 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static _Bool backup_if_mismatch  ;
#line 75 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   *version_control  ;
#line 76 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   *version_control_context  ;
#line 77 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static _Bool remove_empty_files  ;
#line 78 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static _Bool explicit_inname  ;
#line 79 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static enum __anonenum_read_only_behavior_34 read_only_behavior  =    (enum __anonenum_read_only_behavior_34 )1;
#line 82 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static _Bool reverse_flag_specified  ;
#line 84 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   *do_defines  ;
#line 85 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   if_defined[12]  = 
#line 85
  {      (char const   )'\n',      (char const   )'#',      (char const   )'i',      (char const   )'f', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\n',      (char const   )'\000'};
#line 86 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   not_defined[13]  = 
#line 86
  {      (char const   )'\n',      (char const   )'#',      (char const   )'i',      (char const   )'f', 
        (char const   )'n',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\n', 
        (char const   )'\000'};
#line 87 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   else_defined[8]  = 
#line 87
  {      (char const   )'\n',      (char const   )'#',      (char const   )'e',      (char const   )'l', 
        (char const   )'s',      (char const   )'e',      (char const   )'\n',      (char const   )'\000'};
#line 88 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   end_defined[9]  = 
#line 88
  {      (char const   )'\n',      (char const   )'#',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'i',      (char const   )'f',      (char const   )'\n', 
        (char const   )'\000'};
#line 90 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static int Argc  ;
#line 91 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char **Argv  ;
#line 93 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static FILE *rejfp  ;
#line 95 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   *patchname  ;
#line 96 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char *rejname  ;
#line 97 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   *TMPREJNAME  ;
#line 98 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static int TMPREJNAME_needs_removal  ;
#line 100 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static lin maxfuzz  =    (lin )2;
#line 102 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char serrbuf[8192]  ;
#line 106 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
int main(int argc , char **argv ) 
{ 
  char const   *val ;
  _Bool somefailed ;
  struct outstate outstate ;
  struct stat tmpoutst ;
  char numbuf[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  _Bool written_to_rejname ;
  _Bool apply_empty_patch ;
  mode_t file_type ;
  int outfd ;
  _Bool have_git_diff ;
  void *tmp ;
  char *tmp___0 ;
  int i ;
  ptrdiff_t tmp___1 ;
  ptrdiff_t tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int hunk ;
  int failed ;
  _Bool mismatch ;
  char const   *outname ;
  _Bool tmp___11 ;
  mode_t tmp___12 ;
  mode_t tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  _Bool tmp___18 ;
  _Bool tmp___19 ;
  struct stat outstat ;
  int outerrno ;
  int *tmp___21 ;
  int tmp___22 ;
  int *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int *tmp___28 ;
  int tmp___29 ;
  _Bool tmp___30 ;
  _Bool tmp___31 ;
  _Bool tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int got_hunk ;
  _Bool apply_anyway ;
  char *tmp___36 ;
  _Bool renamed ;
  int tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___43 ;
  _Bool tmp___44 ;
  char const   *tmp___45 ;
  _Bool tmp___46 ;
  char const   *tmp___47 ;
  lin where ;
  lin newwhere ;
  lin fuzz ;
  lin mymaxfuzz ;
  lin prefix_context ;
  lin tmp___48 ;
  lin suffix_context ;
  lin tmp___49 ;
  lin context ;
  lin tmp___50 ;
  _Bool tmp___51 ;
  _Bool tmp___52 ;
  char const   *tmp___53 ;
  _Bool tmp___54 ;
  lin tmp___55 ;
  lin tmp___56 ;
  char *tmp___57 ;
  char const   *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  _Bool tmp___62 ;
  int tmp___63 ;
  _Bool tmp___64 ;
  _Bool tmp___65 ;
  _Bool backup ;
  int tmp___66 ;
  struct stat *tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;
  mode_t old_mode ;
  mode_t tmp___70 ;
  mode_t new_mode ;
  mode_t tmp___71 ;
  _Bool set_mode ;
  int tmp___72 ;
  enum file_attributes attr ;
  struct timespec new_time ;
  struct timespec tmp___73 ;
  mode_t mode ;
  mode_t tmp___74 ;
  struct timespec old_time ;
  struct timespec tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  int tmp___78 ;
  struct timespec tmp___79 ;
  int tmp___80 ;
  _Bool tmp___81 ;
  _Bool tmp___82 ;
  _Bool tmp___83 ;
  int tmp___84 ;
  struct stat rejst ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  char const   *tmp___88 ;
  char *rej ;
  char const   *s ;
  size_t len ;
  char *tmp___89 ;
  struct stat oldst ;
  int olderrno ;
  int *tmp___91 ;
  int tmp___92 ;
  enum file_id_type tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  _Bool tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  void *__cil_tmp144 ;
  void *__cil_tmp145 ;
  void *__cil_tmp146 ;
  void *__cil_tmp147 ;
  void *__cil_tmp148 ;
  void *__cil_tmp149 ;
  void *__cil_tmp150 ;
  void *__cil_tmp151 ;
  void *__cil_tmp152 ;
  void *__cil_tmp153 ;
  void *__cil_tmp154 ;
  void *__cil_tmp155 ;
  void *__cil_tmp156 ;
  void *__cil_tmp157 ;
  void *__cil_tmp158 ;
  void *__cil_tmp159 ;
  void *__cil_tmp160 ;
  void *__cil_tmp161 ;
  void *__cil_tmp162 ;
  void *__cil_tmp163 ;
  void *__cil_tmp164 ;
  void *__cil_tmp165 ;
  void *__cil_tmp166 ;
  void *__cil_tmp167 ;
  void *__cil_tmp168 ;
  void *__cil_tmp169 ;
  void *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;

  {
  {
#line 110
  somefailed = (_Bool)0;
#line 114
  written_to_rejname = (_Bool)0;
#line 115
  apply_empty_patch = (_Bool)0;
#line 117
  outfd = -1;
#line 118
  have_git_diff = (_Bool)0;
#line 120
  exit_failure = (int volatile   )2;
#line 121
  set_program_name((char const   *)*(argv + 0));
#line 122
  init_time();
#line 124
  setbuf((FILE */* __restrict  */)stderr, (char */* __restrict  */)(serrbuf));
#line 126
  bufsize = (size_t )8192;
#line 127
  tmp = xmalloc(bufsize);
#line 127
  buf = (char *)tmp;
#line 129
  strippath = -1;
#line 131
  tmp___0 = getenv("QUOTING_STYLE");
#line 131
  val = (char const   *)tmp___0;
  }
#line 133
  if (val) {
    {
#line 133
    tmp___1 = argmatch(val, quoting_style_args, (char const   *)0, (size_t )0);
#line 133
    tmp___2 = tmp___1;
    }
  } else {
#line 133
    tmp___2 = (ptrdiff_t )-1;
  }
#line 133
  i = (int )tmp___2;
#line 134
  if (i < 0) {
#line 134
    tmp___3 = 1U;
  } else {
#line 134
    tmp___3 = (unsigned int )((enum quoting_style )i);
  }
  {
#line 134
  set_quoting_style((struct quoting_options *)0, (enum quoting_style )tmp___3);
#line 138
  tmp___4 = getenv("POSIXLY_CORRECT");
#line 138
  posixly_correct = (_Bool )((unsigned long )tmp___4 != (unsigned long )((char *)0));
#line 139
  backup_if_mismatch = (_Bool )(! posixly_correct);
#line 140
  tmp___7 = getenv("PATCH_GET");
#line 140
  val = (char const   *)tmp___7;
  }
#line 140
  if (val) {
    {
#line 140
    tmp___6 = numeric_string(val, (_Bool)1, "PATCH_GET value");
#line 140
    patch_get = tmp___6;
    }
  } else {
#line 140
    patch_get = 0;
  }
  {
#line 144
  tmp___8 = getenv("SIMPLE_BACKUP_SUFFIX");
#line 144
  val = (char const   *)tmp___8;
  }
#line 145
  if (val) {
#line 145
    if (*val) {
#line 145
      simple_backup_suffix = val;
    } else {
#line 145
      simple_backup_suffix = ".orig";
    }
  } else {
#line 145
    simple_backup_suffix = ".orig";
  }
  {
#line 147
  tmp___10 = getenv("PATCH_VERSION_CONTROL");
#line 147
  version_control = (char const   *)tmp___10;
  }
#line 147
  if (version_control) {
#line 148
    version_control_context = "$PATCH_VERSION_CONTROL";
  } else {
    {
#line 149
    tmp___9 = getenv("VERSION_CONTROL");
#line 149
    version_control = (char const   *)tmp___9;
    }
#line 149
    if (version_control) {
#line 150
      version_control_context = "$VERSION_CONTROL";
    }
  }
  {
#line 153
  Argc = argc;
#line 154
  Argv = argv;
#line 155
  get_some_switches();
  }
#line 158
  if (set_utc) {
    {
#line 159
    setenv("TZ", "UTC", 1);
    }
  }
#line 161
  if ((int )make_backups | (int )backup_if_mismatch) {
    {
#line 162
    backup_type = get_version(version_control_context, version_control);
    }
  }
  {
#line 164
  init_backup_hash_table();
#line 165
  init_files_to_delete();
#line 166
  init_files_to_output();
#line 168
  init_output(& outstate);
  }
#line 169
  if (outfile) {
    {
#line 170
    outstate.ofp = open_outfile((char const   *)outfile);
    }
  }
  {
#line 173
  set_signals((_Bool)0);
  }
#line 175
  if (inname) {
#line 175
    if (outfile) {
#line 181
      apply_empty_patch = (_Bool)1;
#line 182
      file_type = (mode_t )32768;
#line 183
      inerrno = -1;
    }
  }
  {
#line 185
  open_patch_file(patchname);
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (inname) {
#line 185
      tmp___95 = 0;
    } else
#line 185
    if (posixly_correct) {
#line 185
      tmp___95 = 0;
    } else {
#line 185
      tmp___95 = 1;
    }
    {
#line 185
    tmp___96 = there_is_another_patch((_Bool )tmp___95, & file_type);
    }
#line 185
    if (! tmp___96) {
#line 185
      if (! apply_empty_patch) {
#line 185
        goto while_break;
      }
    }
    {
#line 192
    hunk = 0;
#line 193
    failed = 0;
#line 194
    mismatch = (_Bool)0;
#line 195
    outname = (char const   *)((void *)0);
#line 197
    tmp___11 = pch_git_diff();
    }
#line 197
    if ((int )have_git_diff != (int )tmp___11) {
      {
#line 199
      have_git_diff = (_Bool )(! have_git_diff);
#line 200
      output_files((struct stat  const  *)((void *)0));
      }
    }
#line 203
    if (TMPREJNAME_needs_removal) {
#line 205
      if (rejfp) {
        {
#line 207
        fclose(rejfp);
#line 208
        rejfp = (FILE *)((void *)0);
        }
      }
      {
#line 210
      remove_if_needed(TMPREJNAME, & TMPREJNAME_needs_removal);
      }
    }
#line 212
    if (TMPOUTNAME_needs_removal) {
#line 214
      if (outfd != -1) {
        {
#line 216
        close(outfd);
#line 217
        outfd = -1;
        }
      }
      {
#line 219
      remove_if_needed(TMPOUTNAME, & TMPOUTNAME_needs_removal);
      }
    }
#line 222
    if (! skip_rest_of_patch) {
#line 222
      if (! file_type) {
        {
#line 224
        tmp___12 = pch_mode((_Bool )(! reverse));
#line 224
        tmp___13 = pch_mode(reverse);
#line 224
        tmp___14 = quotearg((char const   *)inname);
#line 224
        say("File %s: can\'t change file type from 0%o to 0%o.\n", tmp___14, tmp___13 & 61440U,
            tmp___12 & 61440U);
#line 228
        skip_rest_of_patch = (_Bool)1;
#line 229
        somefailed = (_Bool)1;
        }
      }
    }
#line 232
    if (! skip_rest_of_patch) {
#line 234
      if (outfile) {
#line 235
        outname = (char const   *)outfile;
      } else {
        {
#line 236
        tmp___18 = pch_copy();
        }
#line 236
        if (tmp___18) {
#line 236
          goto _L;
        } else {
          {
#line 236
          tmp___19 = pch_rename();
          }
#line 236
          if (tmp___19) {
            _L: /* CIL Label */ 
            {
#line 237
            tmp___15 = pch_name((enum nametype )0);
#line 237
            tmp___16 = strcmp((char const   *)inname, tmp___15);
            }
#line 237
            if (tmp___16) {
#line 237
              tmp___17 = 0;
            } else {
#line 237
              tmp___17 = 1;
            }
            {
#line 237
            outname = pch_name((enum nametype )tmp___17);
            }
          } else {
#line 239
            outname = (char const   *)inname;
          }
        }
      }
    }
    {
#line 242
    tmp___31 = pch_git_diff();
    }
#line 242
    if (tmp___31) {
#line 242
      if (! skip_rest_of_patch) {
        {
#line 245
        outerrno = 0;
#line 251
        tmp___26 = strcmp((char const   *)inname, outname);
        }
#line 251
        if (tmp___26) {
          {
#line 259
          tmp___25 = lstat((char const   */* __restrict  */)outname, (struct stat */* __restrict  */)(& outstat));
          }
#line 259
          if (tmp___25) {
            {
#line 259
            tmp___24 = __errno_location();
#line 259
            outerrno = *tmp___24;
            }
          } else {
#line 259
            outerrno = 0;
          }
        } else {
#line 253
          if (inerrno == -1) {
            {
#line 254
            tmp___22 = lstat((char const   */* __restrict  */)inname, (struct stat */* __restrict  */)(& instat));
            }
#line 254
            if (tmp___22) {
              {
#line 254
              tmp___21 = __errno_location();
#line 254
              inerrno = *tmp___21;
              }
            } else {
#line 254
              inerrno = 0;
            }
          }
#line 255
          outstat = instat;
#line 256
          outerrno = inerrno;
        }
#line 261
        if (! outerrno) {
          {
#line 263
          tmp___30 = has_queued_output((struct stat  const  *)(& outstat));
          }
#line 263
          if (tmp___30) {
            {
#line 265
            output_files((struct stat  const  *)(& outstat));
#line 266
            tmp___29 = lstat((char const   */* __restrict  */)outname, (struct stat */* __restrict  */)(& outstat));
            }
#line 266
            if (tmp___29) {
              {
#line 266
              tmp___28 = __errno_location();
#line 266
              outerrno = *tmp___28;
              }
            } else {
#line 266
              outerrno = 0;
            }
#line 267
            inerrno = -1;
          }
#line 269
          if (! outerrno) {
            {
#line 270
            set_queued_output((struct stat  const  *)(& outstat), (_Bool)1);
            }
          }
        }
      }
    }
#line 274
    if (! skip_rest_of_patch) {
      {
#line 276
      tmp___32 = get_input_file((char const   *)inname, outname, file_type);
      }
#line 276
      if (! tmp___32) {
#line 278
        skip_rest_of_patch = (_Bool)1;
#line 279
        somefailed = (_Bool)1;
      }
    }
#line 283
    if ((unsigned int )read_only_behavior != 0U) {
#line 283
      if (! inerrno) {
#line 283
        if (! ((instat.st_mode & 61440U) == 40960U)) {
          {
#line 283
          tmp___34 = access((char const   *)inname, 2);
          }
#line 283
          if (tmp___34 != 0) {
            {
#line 287
            tmp___33 = quotearg((char const   *)inname);
#line 287
            say("File %s is read-only; ", tmp___33);
            }
#line 288
            if ((unsigned int )read_only_behavior == 1U) {
              {
#line 289
              say("trying to patch anyway\n");
              }
            } else {
              {
#line 292
              say("refusing to patch\n");
#line 293
              skip_rest_of_patch = (_Bool)1;
#line 294
              somefailed = (_Bool)1;
              }
            }
          }
        }
      }
    }
    {
#line 298
    tmpoutst.st_size = (__off_t )-1;
#line 299
    outfd = make_tempfile(& TMPOUTNAME, (char )'o', outname, 1, instat.st_mode);
#line 301
    TMPOUTNAME_needs_removal = 1;
    }
#line 302
    if ((unsigned int )diff_type == 3U) {
      {
#line 303
      outstate.zero_output = (_Bool)0;
#line 304
      somefailed = (_Bool )((int )somefailed | (int )skip_rest_of_patch);
#line 305
      do_ed_script((char const   *)inname, TMPOUTNAME, & TMPOUTNAME_needs_removal,
                   outstate.ofp);
      }
#line 307
      if (! dry_run) {
#line 307
        if (! outfile) {
#line 307
          if (! skip_rest_of_patch) {
            {
#line 309
            tmp___35 = fstat(outfd, & tmpoutst);
            }
#line 309
            if (tmp___35 != 0) {
              {
#line 310
              pfatal("%s", TMPOUTNAME);
              }
            }
#line 311
            outstate.zero_output = (_Bool )(tmpoutst.st_size == 0L);
          }
        }
      }
      {
#line 313
      close(outfd);
#line 314
      outfd = -1;
      }
    } else {
#line 317
      apply_anyway = merge;
#line 319
      if (! skip_rest_of_patch) {
#line 319
        if ((unsigned int )diff_type == 6U) {
          {
#line 320
          tmp___36 = quotearg(outname);
#line 320
          say("File %s: git binary diffs are not supported.\n", tmp___36);
#line 322
          skip_rest_of_patch = (_Bool)1;
#line 323
          somefailed = (_Bool)1;
          }
        }
      }
#line 326
      if (! skip_rest_of_patch) {
#line 326
        if (! outfile) {
          {
#line 328
          init_output(& outstate);
#line 329
          outstate.ofp = fdopen(outfd, "w");
          }
#line 330
          if (! outstate.ofp) {
            {
#line 331
            pfatal("%s", TMPOUTNAME);
            }
          }
        }
      }
#line 335
      if (! skip_rest_of_patch) {
        {
#line 336
        scan_input(inname, file_type);
        }
#line 338
        if ((unsigned int )verbosity != 1U) {
          {
#line 340
          tmp___37 = strcmp((char const   *)inname, outname);
#line 340
          renamed = (_Bool )tmp___37;
          }
#line 342
          if (renamed) {
#line 342
            tmp___38 = ' ';
          } else {
#line 342
            tmp___38 = '\n';
          }
          {
#line 342
          tmp___39 = quotearg(outname);
          }
#line 342
          if ((file_type & 61440U) == 40960U) {
#line 342
            tmp___40 = "symbolic link";
          } else {
#line 342
            tmp___40 = "file";
          }
          {
#line 342
          say("patching %s %s%c", tmp___40, tmp___39, tmp___38);
          }
#line 345
          if (renamed) {
            {
#line 346
            tmp___46 = pch_copy();
            }
#line 346
            if (tmp___46) {
#line 346
              tmp___45 = "copied";
            } else {
              {
#line 346
              tmp___44 = pch_rename();
              }
#line 346
              if (tmp___44) {
#line 346
                tmp___43 = "renamed";
              } else {
#line 346
                tmp___43 = "read";
              }
#line 346
              tmp___45 = tmp___43;
            }
            {
#line 346
            say("(%s from %s)\n", tmp___45, inname);
            }
          }
#line 350
          if ((unsigned int )verbosity == 2U) {
#line 351
            if (using_plan_a) {
#line 351
              tmp___47 = "A";
            } else {
#line 351
              tmp___47 = "B";
            }
            {
#line 351
            say("Using Plan %s...\n", tmp___47);
            }
          }
        }
      }
      {
#line 359
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 359
        got_hunk = another_hunk(diff_type, reverse);
        }
#line 359
        if (! (0 < got_hunk)) {
#line 359
          goto while_break___0;
        }
#line 361
        where = (lin )0;
#line 363
        fuzz = (lin )0;
#line 366
        if (merge) {
#line 369
          mymaxfuzz = (lin )0;
        } else {
          {
#line 373
          tmp___48 = pch_prefix_context();
#line 373
          prefix_context = tmp___48;
#line 374
          tmp___49 = pch_suffix_context();
#line 374
          suffix_context = tmp___49;
          }
#line 375
          if (prefix_context < suffix_context) {
#line 375
            tmp___50 = suffix_context;
          } else {
#line 375
            tmp___50 = prefix_context;
          }
#line 375
          context = tmp___50;
#line 377
          if (maxfuzz < context) {
#line 377
            mymaxfuzz = maxfuzz;
          } else {
#line 377
            mymaxfuzz = context;
          }
        }
#line 380
        hunk ++;
#line 381
        if (! skip_rest_of_patch) {
          {
#line 382
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 383
            where = locate_hunk(fuzz);
            }
#line 384
            if (! where) {
#line 385
              mismatch = (_Bool)1;
            } else
#line 384
            if (fuzz) {
#line 385
              mismatch = (_Bool)1;
            } else
#line 384
            if (in_offset) {
#line 385
              mismatch = (_Bool)1;
            }
#line 386
            if (hunk == 1) {
#line 386
              if (! where) {
#line 386
                if (! ((int )force | (int )apply_anyway)) {
#line 386
                  if ((int )reverse == (int )reverse_flag_specified) {
                    {
#line 389
                    tmp___51 = pch_swap();
                    }
#line 389
                    if (! tmp___51) {
                      {
#line 390
                      say("Not enough memory to try swapped hunk!  Assuming unswapped.\n");
                      }
#line 392
                      goto __Cont;
                    }
                    {
#line 395
                    where = locate_hunk(fuzz);
                    }
#line 396
                    if (where) {
#line 396
                      if (reverse) {
#line 396
                        tmp___53 = "Unreversed";
                      } else {
#line 396
                        tmp___53 = "Reversed (or previously applied)";
                      }
                      {
#line 396
                      tmp___54 = ok_to_reverse("%s patch detected!", tmp___53);
                      }
#line 396
                      if (tmp___54) {
#line 402
                        reverse = (_Bool )(! reverse);
                      } else {
#line 396
                        goto _L___0;
                      }
                    } else {
                      _L___0: /* CIL Label */ 
                      {
#line 406
                      tmp___52 = pch_swap();
                      }
#line 406
                      if (! tmp___52) {
                        {
#line 407
                        fatal("lost hunk on alloc error!");
                        }
                      }
#line 408
                      if (where) {
#line 410
                        apply_anyway = (_Bool)1;
#line 411
                        fuzz --;
#line 412
                        where = (lin )0;
                      }
                    }
                  }
                }
              }
            }
            __Cont: /* CIL Label */ 
#line 382
            if (! skip_rest_of_patch) {
#line 382
              if (! where) {
#line 382
                fuzz ++;
#line 382
                if (! (fuzz <= mymaxfuzz)) {
#line 382
                  goto while_break___1;
                }
              } else {
#line 382
                goto while_break___1;
              }
            } else {
#line 382
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 419
          if (skip_rest_of_patch) {
#line 420
            if (outstate.ofp) {
#line 420
              if (! outfile) {
                {
#line 422
                fclose(outstate.ofp);
#line 423
                outstate.ofp = (FILE *)0;
#line 424
                outfd = -1;
                }
              }
            }
          }
        }
#line 429
        if (where) {
#line 429
          tmp___56 = where;
        } else {
          {
#line 429
          tmp___55 = pch_first();
#line 429
          tmp___56 = tmp___55;
          }
        }
#line 429
        newwhere = tmp___56 + out_offset;
#line 430
        if (skip_rest_of_patch) {
#line 430
          goto _L___6;
        } else
#line 430
        if (merge) {
          {
#line 430
          tmp___62 = merge_hunk(hunk, & outstate, where, & somefailed);
          }
#line 430
          if (tmp___62) {
#line 430
            goto _L___9;
          } else {
#line 430
            goto _L___6;
          }
        } else
        _L___9: /* CIL Label */ 
#line 430
        if (! merge) {
#line 430
          if (where == 1L) {
            {
#line 430
            tmp___63 = pch_says_nonexistent(reverse);
            }
#line 430
            if (tmp___63 == 2) {
#line 430
              if (instat.st_size) {
#line 430
                goto _L___6;
              } else {
#line 430
                goto _L___8;
              }
            } else {
#line 430
              goto _L___8;
            }
          } else
          _L___8: /* CIL Label */ 
#line 430
          if (! where) {
#line 430
            goto _L___6;
          } else {
            {
#line 430
            tmp___64 = apply_hunk(& outstate, where);
            }
#line 430
            if (tmp___64) {
#line 430
              goto _L___5;
            } else {
              _L___6: /* CIL Label */ 
              {
#line 439
              abort_hunk(outname, (_Bool )(! failed), reverse);
#line 440
              failed ++;
              }
#line 441
              if ((unsigned int )verbosity == 2U) {
#line 441
                goto _L___1;
              } else
#line 441
              if (! skip_rest_of_patch) {
#line 441
                if ((unsigned int )verbosity != 1U) {
                  _L___1: /* CIL Label */ 
                  {
#line 443
                  tmp___57 = format_linenum((char *)(numbuf), newwhere);
                  }
#line 443
                  if (skip_rest_of_patch) {
#line 443
                    tmp___58 = "ignored";
                  } else {
#line 443
                    tmp___58 = "FAILED";
                  }
                  {
#line 443
                  say("Hunk #%d %s at %s.\n", hunk, tmp___58, tmp___57);
                  }
                }
              }
            }
          }
        } else
        _L___5: /* CIL Label */ 
#line 447
        if (! merge) {
#line 447
          if ((unsigned int )verbosity == 2U) {
#line 447
            goto _L___3;
          } else
#line 447
          if ((unsigned int )verbosity != 1U) {
#line 447
            if (fuzz) {
#line 447
              goto _L___3;
            } else
#line 447
            if (in_offset) {
              _L___3: /* CIL Label */ 
              {
#line 451
              tmp___59 = format_linenum((char *)(numbuf), newwhere);
#line 451
              say("Hunk #%d succeeded at %s", hunk, tmp___59);
              }
#line 453
              if (fuzz) {
                {
#line 454
                tmp___60 = format_linenum((char *)(numbuf), fuzz);
#line 454
                say(" with fuzz %s", tmp___60);
                }
              }
#line 455
              if (in_offset) {
                {
#line 456
                tmp___61 = format_linenum((char *)(numbuf), in_offset);
#line 456
                say(" (offset %s line%s)", tmp___61, "s" + (in_offset == 1L));
                }
              }
              {
#line 459
              say(".\n");
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 463
      if (! skip_rest_of_patch) {
#line 465
        if (got_hunk < 0) {
#line 465
          if (using_plan_a) {
#line 467
            if (outfile) {
              {
#line 468
              fatal("out of memory using Plan A");
              }
            }
            {
#line 469
            say("\n\nRan out of memory using Plan A -- trying again...\n\n");
            }
#line 470
            if (outstate.ofp) {
              {
#line 472
              fclose(outstate.ofp);
#line 473
              outstate.ofp = (FILE *)0;
              }
            }
#line 475
            goto __Cont___0;
          }
        }
        {
#line 479
        tmp___65 = spew_output(& outstate, & tmpoutst);
        }
#line 479
        if (! tmp___65) {
          {
#line 481
          say("Skipping patch.\n");
#line 482
          skip_rest_of_patch = (_Bool)1;
          }
        }
      }
    }
    {
#line 488
    ignore_signals();
    }
#line 489
    if (! skip_rest_of_patch) {
#line 489
      if (! outfile) {
#line 490
        if (make_backups) {
#line 490
          tmp___66 = 1;
        } else
#line 490
        if (backup_if_mismatch) {
#line 490
          if ((int )mismatch | failed) {
#line 490
            tmp___66 = 1;
          } else {
#line 490
            tmp___66 = 0;
          }
        } else {
#line 490
          tmp___66 = 0;
        }
#line 490
        backup = (_Bool )tmp___66;
#line 492
        if (outstate.zero_output) {
#line 492
          if (remove_empty_files) {
#line 492
            goto _L___17;
          } else {
            {
#line 492
            tmp___84 = pch_says_nonexistent((_Bool )(! reverse));
            }
#line 492
            if (tmp___84 == 2) {
#line 492
              if (! posixly_correct) {
#line 492
                goto _L___17;
              } else {
#line 492
                goto _L___18;
              }
            } else
            _L___18: /* CIL Label */ 
#line 492
            if ((file_type & 61440U) == 40960U) {
              _L___17: /* CIL Label */ 
#line 498
              if (! dry_run) {
#line 499
                if ((unsigned long )inname == (unsigned long )outname) {
#line 499
                  tmp___67 = & instat;
                } else {
#line 499
                  tmp___67 = (struct stat *)((void *)0);
                }
                {
#line 499
                output_file((char const   *)((void *)0), (int *)((void *)0), (struct stat  const  *)((void *)0),
                            outname, (struct stat  const  *)tmp___67, file_type, backup);
                }
              }
            } else {
#line 492
              goto _L___16;
            }
          }
        } else {
          _L___16: /* CIL Label */ 
#line 505
          if (! outstate.zero_output) {
            {
#line 505
            tmp___69 = pch_says_nonexistent((_Bool )(! reverse));
            }
#line 505
            if (tmp___69) {
#line 505
              if (merge) {
#line 505
                if (! somefailed) {
#line 505
                  goto _L___10;
                }
              } else {
                _L___10: /* CIL Label */ 
#line 509
                mismatch = (_Bool)1;
#line 510
                if ((unsigned int )verbosity != 1U) {
                  {
#line 511
                  tmp___68 = quotearg(outname);
#line 511
                  say("File %s is not empty after patch, as expected\n", tmp___68);
                  }
                }
              }
            }
          }
#line 515
          if (! dry_run) {
            {
#line 517
            tmp___70 = pch_mode(reverse);
#line 517
            old_mode = tmp___70;
#line 518
            tmp___71 = pch_mode((_Bool )(! reverse));
#line 518
            new_mode = tmp___71;
            }
#line 519
            if (new_mode) {
#line 519
              if (old_mode != new_mode) {
#line 519
                tmp___72 = 1;
              } else {
#line 519
                tmp___72 = 0;
              }
            } else {
#line 519
              tmp___72 = 0;
            }
#line 519
            set_mode = (_Bool )tmp___72;
#line 522
            if (failed < hunk) {
#line 522
              goto _L___15;
            } else
#line 522
            if ((unsigned int )diff_type == 3U) {
#line 522
              goto _L___15;
            } else
#line 522
            if (set_mode) {
#line 522
              goto _L___15;
            } else {
              {
#line 522
              tmp___82 = pch_copy();
              }
#line 522
              if (tmp___82) {
#line 522
                goto _L___15;
              } else {
                {
#line 522
                tmp___83 = pch_rename();
                }
#line 522
                if (tmp___83) {
                  _L___15: /* CIL Label */ 
                  {
#line 525
                  attr = (enum file_attributes )0;
#line 526
                  tmp___73 = pch_timestamp((_Bool )(! reverse));
#line 526
                  new_time = tmp___73;
                  }
#line 527
                  if (new_mode) {
#line 527
                    tmp___74 = new_mode;
                  } else {
#line 527
                    tmp___74 = instat.st_mode;
                  }
#line 527
                  mode = file_type | (tmp___74 & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3)));
#line 530
                  if ((int )set_time | (int )set_utc) {
#line 530
                    if (new_time.tv_sec != -1L) {
                      {
#line 532
                      tmp___75 = pch_timestamp(reverse);
#line 532
                      old_time = tmp___75;
                      }
#line 534
                      if (! force) {
#line 534
                        if (! inerrno) {
                          {
#line 534
                          tmp___78 = pch_says_nonexistent(reverse);
                          }
#line 534
                          if (tmp___78 != 2) {
#line 534
                            if (old_time.tv_sec != -1L) {
                              {
#line 534
                              tmp___79 = get_stat_mtime((struct stat  const  *)(& instat));
#line 534
                              tmp___80 = timespec_cmp(old_time, tmp___79);
                              }
#line 534
                              if (tmp___80) {
                                {
#line 539
                                tmp___76 = quotearg(outname);
#line 539
                                say("Not setting time of file %s (time mismatch)\n",
                                    tmp___76);
                                }
                              } else {
#line 534
                                goto _L___14;
                              }
                            } else {
#line 534
                              goto _L___14;
                            }
                          } else {
#line 534
                            goto _L___14;
                          }
                        } else {
#line 534
                          goto _L___14;
                        }
                      } else
                      _L___14: /* CIL Label */ 
#line 542
                      if (! force) {
#line 542
                        if ((int )mismatch | failed) {
                          {
#line 543
                          tmp___77 = quotearg(outname);
#line 543
                          say("Not setting time of file %s (contents mismatch)\n",
                              tmp___77);
                          }
                        } else {
#line 547
                          attr = (enum file_attributes )((unsigned int )attr | 1U);
                        }
                      } else {
#line 547
                        attr = (enum file_attributes )((unsigned int )attr | 1U);
                      }
                    }
                  }
#line 550
                  if (inerrno) {
                    {
#line 551
                    set_file_attributes(TMPOUTNAME, attr, (char const   *)((void *)0),
                                        (struct stat  const  *)((void *)0), mode,
                                        & new_time);
                    }
                  } else {
                    {
#line 555
                    attr = (enum file_attributes )((unsigned int )attr | 14U);
#line 556
                    set_file_attributes(TMPOUTNAME, attr, (char const   *)inname,
                                        (struct stat  const  *)(& instat), mode, & new_time);
                    }
                  }
                  {
#line 560
                  output_file(TMPOUTNAME, & TMPOUTNAME_needs_removal, (struct stat  const  *)(& tmpoutst),
                              outname, (struct stat  const  *)((void *)0), mode, backup);
#line 563
                  tmp___81 = pch_rename();
                  }
#line 563
                  if (tmp___81) {
                    {
#line 564
                    output_file((char const   *)((void *)0), (int *)((void *)0), (struct stat  const  *)((void *)0),
                                (char const   *)inname, (struct stat  const  *)(& instat),
                                mode, backup);
                    }
                  }
                } else {
                  {
#line 568
                  output_file(outname, (int *)((void *)0), (struct stat  const  *)(& tmpoutst),
                              (char const   *)((void *)0), (struct stat  const  *)((void *)0),
                              file_type, backup);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 573
    if ((unsigned int )diff_type != 3U) {
#line 576
      if (failed) {
        {
#line 577
        tmp___85 = fileno(rejfp);
#line 577
        tmp___86 = fstat(tmp___85, & rejst);
        }
#line 577
        if (tmp___86 != 0) {
          {
#line 578
          write_fatal();
          }
        } else {
          {
#line 577
          tmp___87 = fclose(rejfp);
          }
#line 577
          if (tmp___87 != 0) {
            {
#line 578
            write_fatal();
            }
          }
        }
#line 579
        rejfp = (FILE *)((void *)0);
#line 580
        somefailed = (_Bool)1;
#line 581
        if (skip_rest_of_patch) {
#line 581
          tmp___88 = "ignored";
        } else {
#line 581
          tmp___88 = "FAILED";
        }
        {
#line 581
        say("%d out of %d hunk%s %s", failed, hunk, "s" + (hunk == 1), tmp___88);
        }
#line 583
        if (outname) {
#line 583
          if (! rejname) {
#line 583
            goto _L___19;
          } else {
            {
#line 583
            tmp___94 = strcmp((char const   *)rejname, "-");
            }
#line 583
            if (tmp___94 != 0) {
              _L___19: /* CIL Label */ 
#line 584
              rej = rejname;
#line 585
              if (! rejname) {
                {
#line 587
                s = simple_backup_suffix;
#line 589
                simple_backup_suffix = ".rej";
#line 590
                rej = find_backup_file_name(outname, (enum backup_type )1);
#line 591
                len = strlen((char const   *)rej);
                }
#line 592
                if ((int )*(rej + (len - 1UL)) == 126) {
#line 593
                  *(rej + (len - 1UL)) = (char )'#';
                }
#line 594
                simple_backup_suffix = s;
              }
              {
#line 596
              tmp___89 = quotearg((char const   *)rej);
#line 596
              say(" -- saving rejects to file %s\n", tmp___89);
              }
#line 597
              if (! dry_run) {
#line 599
                if (rejname) {
#line 601
                  if (! written_to_rejname) {
                    {
#line 603
                    copy_file(TMPREJNAME, (char const   *)rejname, (struct stat *)0,
                              0, (mode_t )33206, (_Bool)1);
#line 605
                    written_to_rejname = (_Bool)1;
                    }
                  } else {
                    {
#line 608
                    append_to_file(TMPREJNAME, (char const   *)rejname);
                    }
                  }
                } else {
                  {
#line 615
                  tmp___92 = lstat((char const   */* __restrict  */)rej, (struct stat */* __restrict  */)(& oldst));
                  }
#line 615
                  if (tmp___92) {
                    {
#line 615
                    tmp___91 = __errno_location();
#line 615
                    olderrno = *tmp___91;
                    }
                  } else {
#line 615
                    olderrno = 0;
                  }
#line 616
                  if (olderrno) {
#line 616
                    if (olderrno != 2) {
                      {
#line 617
                      write_fatal();
                      }
                    }
                  }
#line 618
                  if (! olderrno) {
                    {
#line 618
                    tmp___93 = lookup_file_id((struct stat  const  *)(& oldst));
                    }
#line 618
                    if ((unsigned int )tmp___93 == 1U) {
                      {
#line 619
                      append_to_file(TMPREJNAME, (char const   *)rej);
                      }
                    } else {
                      {
#line 621
                      move_file(TMPREJNAME, & TMPREJNAME_needs_removal, (struct stat  const  *)(& rejst),
                                (char const   *)rej, (mode_t )33206, (_Bool)0);
                      }
                    }
                  } else {
                    {
#line 621
                    move_file(TMPREJNAME, & TMPREJNAME_needs_removal, (struct stat  const  *)(& rejst),
                              (char const   *)rej, (mode_t )33206, (_Bool)0);
                    }
                  }
                }
              }
#line 625
              if (! rejname) {
                {
#line 626
                free((void *)rej);
                }
              }
            } else {
              {
#line 628
              say("\n");
              }
            }
          }
        } else {
          {
#line 628
          say("\n");
          }
        }
      }
    }
    {
#line 631
    set_signals((_Bool)1);
    }
    __Cont___0: /* CIL Label */ 
    {
#line 185
    reinitialize_almost_everything();
#line 185
    apply_empty_patch = (_Bool)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  if (outstate.ofp) {
    {
#line 633
    tmp___97 = ferror(outstate.ofp);
    }
#line 633
    if (tmp___97) {
      {
#line 634
      write_fatal();
      }
    } else {
      {
#line 633
      tmp___98 = fclose(outstate.ofp);
      }
#line 633
      if (tmp___98 != 0) {
        {
#line 634
        write_fatal();
        }
      }
    }
  }
  {
#line 635
  output_files((struct stat  const  *)((void *)0));
#line 636
  delete_files();
#line 637
  cleanup();
  }
#line 638
  if (somefailed) {
    {
#line 639
    exit(1);
    }
  }
#line 640
  return (0);
}
}
#line 645 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void reinitialize_almost_everything(void) 
{ 


  {
  {
#line 648
  re_patch();
#line 649
  re_input();
#line 651
  input_lines = (lin )0;
#line 652
  last_frozen_line = (lin )0;
  }
#line 654
  if (inname) {
#line 654
    if (! explicit_inname) {
      {
#line 655
      free((void *)inname);
#line 656
      inname = (char *)0;
      }
    }
  }
#line 659
  in_offset = (lin )0;
#line 660
  out_offset = (lin )0;
#line 662
  diff_type = (enum diff )0;
#line 664
  if (revision) {
    {
#line 665
    free((void *)revision);
#line 666
    revision = (char *)0;
    }
  }
#line 669
  reverse = reverse_flag_specified;
#line 670
  skip_rest_of_patch = (_Bool)0;
#line 671
  return;
}
}
#line 673 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   shortopts[42]  = 
#line 673
  {      (char const   )'b',      (char const   )'B',      (char const   )':',      (char const   )'c', 
        (char const   )'d',      (char const   )':',      (char const   )'D',      (char const   )':', 
        (char const   )'e',      (char const   )'E',      (char const   )'f',      (char const   )'F', 
        (char const   )':',      (char const   )'g',      (char const   )':',      (char const   )'i', 
        (char const   )':',      (char const   )'l',      (char const   )'n',      (char const   )'N', 
        (char const   )'o',      (char const   )':',      (char const   )'p',      (char const   )':', 
        (char const   )'r',      (char const   )':',      (char const   )'R',      (char const   )'s', 
        (char const   )'t',      (char const   )'T',      (char const   )'u',      (char const   )'v', 
        (char const   )'V',      (char const   )':',      (char const   )'x',      (char const   )':', 
        (char const   )'Y',      (char const   )':',      (char const   )'z',      (char const   )':', 
        (char const   )'Z',      (char const   )'\000'};
#line 679 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static struct rpl_option  const  longopts[41]  = 
#line 679
  {      {"backup", 0, (int *)((void *)0), 'b'}, 
        {"prefix", 1, (int *)((void *)0), 'B'}, 
        {"context", 0, (int *)((void *)0), 'c'}, 
        {"directory", 1, (int *)((void *)0), 'd'}, 
        {"ifdef", 1, (int *)((void *)0), 'D'}, 
        {"ed", 0, (int *)((void *)0), 'e'}, 
        {"remove-empty-files", 0, (int *)((void *)0), 'E'}, 
        {"force", 0, (int *)((void *)0), 'f'}, 
        {"fuzz", 1, (int *)((void *)0), 'F'}, 
        {"get", 1, (int *)((void *)0), 'g'}, 
        {"input", 1, (int *)((void *)0), 'i'}, 
        {"ignore-whitespace", 0, (int *)((void *)0), 'l'}, 
        {"merge", 2, (int *)((void *)0), 'm'}, 
        {"normal", 0, (int *)((void *)0), 'n'}, 
        {"forward", 0, (int *)((void *)0), 'N'}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"strip", 1, (int *)((void *)0), 'p'}, 
        {"reject-file", 1, (int *)((void *)0), 'r'}, 
        {"reverse", 0, (int *)((void *)0), 'R'}, 
        {"quiet", 0, (int *)((void *)0), 's'}, 
        {"silent", 0, (int *)((void *)0), 's'}, 
        {"batch", 0, (int *)((void *)0), 't'}, 
        {"set-time", 0, (int *)((void *)0), 'T'}, 
        {"unified", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"version-control", 1, (int *)((void *)0), 'V'}, 
        {"debug", 1, (int *)((void *)0), 'x'}, 
        {"basename-prefix", 1, (int *)((void *)0), 'Y'}, 
        {"suffix", 1, (int *)((void *)0), 'z'}, 
        {"set-utc", 0, (int *)((void *)0), 'Z'}, 
        {"dry-run", 0, (int *)((void *)0), 128}, 
        {"verbose", 0, (int *)((void *)0), 129}, 
        {"binary", 0, (int *)((void *)0), 130}, 
        {"help", 0, (int *)((void *)0), 131}, 
        {"backup-if-mismatch", 0, (int *)((void *)0), 132}, 
        {"no-backup-if-mismatch", 0, (int *)((void *)0), 133}, 
        {"posix", 0, (int *)((void *)0), 134}, 
        {"quoting-style", 1, (int *)((void *)0), 135}, 
        {"reject-format", 1, (int *)((void *)0), 136}, 
        {"read-only", 1, (int *)((void *)0), 137}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 726 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static char const   * const  option_help[66]  = 
#line 726
  {      (char const   */* const  */)"Input options:",      (char const   */* const  */)"",      (char const   */* const  */)"  -p NUM  --strip=NUM  Strip NUM leading components from file names.",      (char const   */* const  */)"  -F LINES  --fuzz LINES  Set the fuzz factor to LINES for inexact matching.", 
        (char const   */* const  */)"  -l  --ignore-whitespace  Ignore white space changes between patch and input.",      (char const   */* const  */)"",      (char const   */* const  */)"  -c  --context  Interpret the patch as a context difference.",      (char const   */* const  */)"  -e  --ed  Interpret the patch as an ed script.", 
        (char const   */* const  */)"  -n  --normal  Interpret the patch as a normal difference.",      (char const   */* const  */)"  -u  --unified  Interpret the patch as a unified difference.",      (char const   */* const  */)"",      (char const   */* const  */)"  -N  --forward  Ignore patches that appear to be reversed or already applied.", 
        (char const   */* const  */)"  -R  --reverse  Assume patches were created with old and new files swapped.",      (char const   */* const  */)"",      (char const   */* const  */)"  -i PATCHFILE  --input=PATCHFILE  Read patch from PATCHFILE instead of stdin.",      (char const   */* const  */)"", 
        (char const   */* const  */)"Output options:",      (char const   */* const  */)"",      (char const   */* const  */)"  -o FILE  --output=FILE  Output patched files to FILE.",      (char const   */* const  */)"  -r FILE  --reject-file=FILE  Output rejects to FILE.", 
        (char const   */* const  */)"",      (char const   */* const  */)"  -D NAME  --ifdef=NAME  Make merged if-then-else output using NAME.",      (char const   */* const  */)"  -m  --merge  Merge using conflict markers instead of creating reject files.",      (char const   */* const  */)"  -E  --remove-empty-files  Remove output files that are empty after patching.", 
        (char const   */* const  */)"",      (char const   */* const  */)"  -Z  --set-utc  Set times of patched files, assuming diff uses UTC (GMT).",      (char const   */* const  */)"  -T  --set-time  Likewise, assuming local time.",      (char const   */* const  */)"", 
        (char const   */* const  */)"  --quoting-style=WORD   output file names using quoting style WORD.",      (char const   */* const  */)"    Valid WORDs are: literal, shell, shell-always, c, escape.",      (char const   */* const  */)"    Default is taken from QUOTING_STYLE env variable, or \'shell\' if unset.",      (char const   */* const  */)"", 
        (char const   */* const  */)"Backup and version control options:",      (char const   */* const  */)"",      (char const   */* const  */)"  -b  --backup  Back up the original contents of each file.",      (char const   */* const  */)"  --backup-if-mismatch  Back up if the patch does not match exactly.", 
        (char const   */* const  */)"  --no-backup-if-mismatch  Back up mismatches only if otherwise requested.",      (char const   */* const  */)"",      (char const   */* const  */)"  -V STYLE  --version-control=STYLE  Use STYLE version control.",      (char const   */* const  */)"\tSTYLE is either \'simple\', \'numbered\', or \'existing\'.", 
        (char const   */* const  */)"  -B PREFIX  --prefix=PREFIX  Prepend PREFIX to backup file names.",      (char const   */* const  */)"  -Y PREFIX  --basename-prefix=PREFIX  Prepend PREFIX to backup file basenames.",      (char const   */* const  */)"  -z SUFFIX  --suffix=SUFFIX  Append SUFFIX to backup file names.",      (char const   */* const  */)"", 
        (char const   */* const  */)"  -g NUM  --get=NUM  Get files from RCS etc. if positive; ask if negative.",      (char const   */* const  */)"",      (char const   */* const  */)"Miscellaneous options:",      (char const   */* const  */)"", 
        (char const   */* const  */)"  -t  --batch  Ask no questions; skip bad-Prereq patches; assume reversed.",      (char const   */* const  */)"  -f  --force  Like -t, but ignore bad-Prereq patches, and assume unreversed.",      (char const   */* const  */)"  -s  --quiet  --silent  Work silently unless an error occurs.",      (char const   */* const  */)"  --verbose  Output extra information about the work being done.", 
        (char const   */* const  */)"  --dry-run  Do not actually change any files; just print what would happen.",      (char const   */* const  */)"  --posix  Conform to the POSIX standard.",      (char const   */* const  */)"",      (char const   */* const  */)"  -d DIR  --directory=DIR  Change the working directory to DIR first.", 
        (char const   */* const  */)"  --reject-format=FORMAT  Create \'context\' or \'unified\' rejects.",      (char const   */* const  */)"  --binary  Read and write data in binary mode.",      (char const   */* const  */)"  --read-only=BEHAVIOR  How to handle read-only input files: \'ignore\' that they",      (char const   */* const  */)"                        are read-only, \'warn\' (default), or \'fail\'.", 
        (char const   */* const  */)"",      (char const   */* const  */)"  -v  --version  Output version info.",      (char const   */* const  */)"  --help  Output this help.",      (char const   */* const  */)"", 
        (char const   */* const  */)"Report bugs to <bug-patch@gnu.org>.",      (char const   */* const  */)0};
#line 798
static  __attribute__((__noreturn__)) void usage(FILE *stream , int status ) ;
#line 798 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void usage(FILE *stream , int status ) 
{ 
  char const   * const  *p ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 803
  if (status != 0) {
    {
#line 805
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s: Try \'%s --help\' for more information.\n",
            program_name, *(Argv + 0));
    }
  } else {
    {
#line 810
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Usage: %s [OPTION]... [ORIGFILE [PATCHFILE]]\n\n",
            *(Argv + 0));
#line 812
    p = option_help;
    }
    {
#line 812
    while (1) {
      while_continue: /* CIL Label */ ;
#line 812
      if (! *p) {
#line 812
        goto while_break;
      }
      {
#line 813
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s\n",
              *p);
#line 812
      p ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 816
  exit(status);
  }
}
}
#line 821 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void get_some_switches(void) 
{ 
  int optc ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int i ;
  ptrdiff_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 826
  free((void *)rejname);
#line 827
  rejname = (char *)0;
  }
#line 828
  if (rpl_optind == Argc) {
#line 829
    return;
  }
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 830
    optc = rpl_getopt_long(Argc, Argv, shortopts, longopts, (int *)0);
    }
#line 830
    if (! (optc != -1)) {
#line 830
      goto while_break;
    }
    {
#line 833
    if (optc == 98) {
#line 833
      goto case_98;
    }
#line 851
    if (optc == 66) {
#line 851
      goto case_66;
    }
#line 856
    if (optc == 99) {
#line 856
      goto case_99;
    }
#line 859
    if (optc == 100) {
#line 859
      goto case_100;
    }
#line 863
    if (optc == 68) {
#line 863
      goto case_68;
    }
#line 866
    if (optc == 101) {
#line 866
      goto case_101;
    }
#line 869
    if (optc == 69) {
#line 869
      goto case_69;
    }
#line 872
    if (optc == 102) {
#line 872
      goto case_102;
    }
#line 875
    if (optc == 70) {
#line 875
      goto case_70;
    }
#line 878
    if (optc == 103) {
#line 878
      goto case_103;
    }
#line 881
    if (optc == 105) {
#line 881
      goto case_105;
    }
#line 884
    if (optc == 108) {
#line 884
      goto case_108;
    }
#line 888
    if (optc == 109) {
#line 888
      goto case_109;
    }
#line 903
    if (optc == 110) {
#line 903
      goto case_110;
    }
#line 906
    if (optc == 78) {
#line 906
      goto case_78;
    }
#line 909
    if (optc == 111) {
#line 909
      goto case_111;
    }
#line 912
    if (optc == 112) {
#line 912
      goto case_112;
    }
#line 915
    if (optc == 114) {
#line 915
      goto case_114;
    }
#line 918
    if (optc == 82) {
#line 918
      goto case_82;
    }
#line 922
    if (optc == 115) {
#line 922
      goto case_115;
    }
#line 925
    if (optc == 116) {
#line 925
      goto case_116;
    }
#line 928
    if (optc == 84) {
#line 928
      goto case_84;
    }
#line 931
    if (optc == 117) {
#line 931
      goto case_117;
    }
#line 934
    if (optc == 118) {
#line 934
      goto case_118;
    }
#line 938
    if (optc == 86) {
#line 938
      goto case_86;
    }
#line 943
    if (optc == 120) {
#line 943
      goto case_120;
    }
#line 947
    if (optc == 89) {
#line 947
      goto case_89;
    }
#line 952
    if (optc == 122) {
#line 952
      goto case_z;
    }
#line 958
    if (optc == 90) {
#line 958
      goto case_90;
    }
#line 961
    if (optc == 128) {
#line 961
      goto case_128;
    }
#line 964
    if (optc == 129) {
#line 964
      goto case_129;
    }
#line 967
    if (optc == 130) {
#line 967
      goto case_130;
    }
#line 973
    if (optc == 131) {
#line 973
      goto case_131;
    }
#line 975
    if (optc == 132) {
#line 975
      goto case_132;
    }
#line 978
    if (optc == 133) {
#line 978
      goto case_133;
    }
#line 981
    if (optc == 134) {
#line 981
      goto case_134;
    }
#line 984
    if (optc == 135) {
#line 984
      goto case_135;
    }
#line 996
    if (optc == 136) {
#line 996
      goto case_136;
    }
#line 1004
    if (optc == 137) {
#line 1004
      goto case_137;
    }
#line 1014
    goto switch_default;
    case_98: /* CIL Label */ 
#line 834
    make_backups = (_Bool)1;
#line 838
    if (Argc - rpl_optind == 3) {
      {
#line 838
      tmp___0 = strcmp((char const   *)*(Argv + (rpl_optind - 1)), "-b");
      }
#line 838
      if (tmp___0 == 0) {
#line 838
        if ((int )*(*(Argv + rpl_optind) + 0) == 45) {
#line 838
          if (! *(*(Argv + rpl_optind) + 1)) {
#line 838
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 838
        if ((int )*(*(Argv + (rpl_optind + 1)) + 0) == 45) {
#line 838
          if (! *(*(Argv + (rpl_optind + 1)) + 1)) {
#line 838
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 838
        if ((int )*(*(Argv + (rpl_optind + 2)) + 0) == 45) {
#line 838
          if (! *(*(Argv + (rpl_optind + 2)) + 1)) {
#line 838
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 844
          tmp = rpl_optind;
#line 844
          rpl_optind ++;
#line 844
          rpl_optarg = *(Argv + tmp);
#line 845
          if ((unsigned int )verbosity != 1U) {
            {
#line 846
            say("warning: the \'-b %s\' option is obsolete; use \'-b -z %s\' instead\n",
                rpl_optarg, rpl_optarg);
            }
          }
#line 848
          goto case_z;
        }
      }
    }
#line 850
    goto switch_break;
    case_66: /* CIL Label */ 
#line 852
    if (! *rpl_optarg) {
      {
#line 853
      fatal("backup prefix is empty");
      }
    }
    {
#line 854
    tmp___1 = savestr((char const   *)rpl_optarg);
#line 854
    origprae = (char const   *)tmp___1;
    }
#line 855
    goto switch_break;
    case_99: /* CIL Label */ 
#line 857
    diff_type = (enum diff )1;
#line 858
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 860
    tmp___3 = chdir((char const   *)rpl_optarg);
    }
#line 860
    if (tmp___3 < 0) {
      {
#line 861
      tmp___2 = quotearg((char const   *)rpl_optarg);
#line 861
      pfatal("Can\'t change to directory %s", tmp___2);
      }
    }
#line 862
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 864
    tmp___4 = savestr((char const   *)rpl_optarg);
#line 864
    do_defines = (char const   *)tmp___4;
    }
#line 865
    goto switch_break;
    case_101: /* CIL Label */ 
#line 867
    diff_type = (enum diff )3;
#line 868
    goto switch_break;
    case_69: /* CIL Label */ 
#line 870
    remove_empty_files = (_Bool)1;
#line 871
    goto switch_break;
    case_102: /* CIL Label */ 
#line 873
    force = (_Bool)1;
#line 874
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 876
    tmp___5 = numeric_string((char const   *)rpl_optarg, (_Bool)0, "fuzz factor");
#line 876
    maxfuzz = (lin )tmp___5;
    }
#line 877
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 879
    patch_get = numeric_string((char const   *)rpl_optarg, (_Bool)1, "get option value");
    }
#line 880
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 882
    tmp___6 = savestr((char const   *)rpl_optarg);
#line 882
    patchname = (char const   *)tmp___6;
    }
#line 883
    goto switch_break;
    case_108: /* CIL Label */ 
#line 885
    canonicalize = (_Bool)1;
#line 886
    goto switch_break;
    case_109: /* CIL Label */ 
#line 889
    merge = (_Bool)1;
#line 890
    if (rpl_optarg) {
      {
#line 892
      tmp___8 = strcmp((char const   *)rpl_optarg, "merge");
      }
#line 892
      if (tmp___8) {
        {
#line 894
        tmp___7 = strcmp((char const   *)rpl_optarg, "diff3");
        }
#line 894
        if (tmp___7) {
          {
#line 897
          usage(stderr, 2);
          }
        } else {
#line 895
          conflict_style = (enum conflict_style )1;
        }
      } else {
#line 893
        conflict_style = (enum conflict_style )0;
      }
    } else {
#line 900
      conflict_style = (enum conflict_style )0;
    }
#line 901
    goto switch_break;
    case_110: /* CIL Label */ 
#line 904
    diff_type = (enum diff )2;
#line 905
    goto switch_break;
    case_78: /* CIL Label */ 
#line 907
    noreverse = (_Bool)1;
#line 908
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 910
    outfile = savestr((char const   *)rpl_optarg);
    }
#line 911
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 913
    strippath = numeric_string((char const   *)rpl_optarg, (_Bool)0, "strip count");
    }
#line 914
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 916
    rejname = savestr((char const   *)rpl_optarg);
    }
#line 917
    goto switch_break;
    case_82: /* CIL Label */ 
#line 919
    reverse = (_Bool)1;
#line 920
    reverse_flag_specified = (_Bool)1;
#line 921
    goto switch_break;
    case_115: /* CIL Label */ 
#line 923
    verbosity = (enum __anonenum_verbosity_22 )1;
#line 924
    goto switch_break;
    case_116: /* CIL Label */ 
#line 926
    batch = (_Bool)1;
#line 927
    goto switch_break;
    case_84: /* CIL Label */ 
#line 929
    set_time = (_Bool)1;
#line 930
    goto switch_break;
    case_117: /* CIL Label */ 
#line 932
    diff_type = (enum diff )5;
#line 933
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 935
    version();
#line 936
    exit(0);
    }
#line 937
    goto switch_break;
    case_86: /* CIL Label */ 
#line 939
    version_control = (char const   *)rpl_optarg;
#line 940
    version_control_context = "--version-control or -V option";
#line 941
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 944
    debug = numeric_string((char const   *)rpl_optarg, (_Bool)1, "debugging option");
    }
#line 945
    goto switch_break;
    case_89: /* CIL Label */ 
#line 948
    if (! *rpl_optarg) {
      {
#line 949
      fatal("backup basename prefix is empty");
      }
    }
    {
#line 950
    tmp___9 = savestr((char const   *)rpl_optarg);
#line 950
    origbase = (char const   *)tmp___9;
    }
#line 951
    goto switch_break;
    case_z: 
    case_122: /* CIL Label */ 
#line 954
    if (! *rpl_optarg) {
      {
#line 955
      fatal("backup suffix is empty");
      }
    }
    {
#line 956
    tmp___10 = savestr((char const   *)rpl_optarg);
#line 956
    origsuff = (char const   *)tmp___10;
    }
#line 957
    goto switch_break;
    case_90: /* CIL Label */ 
#line 959
    set_utc = (_Bool)1;
#line 960
    goto switch_break;
    case_128: /* CIL Label */ 
#line 962
    dry_run = (_Bool)1;
#line 963
    goto switch_break;
    case_129: /* CIL Label */ 
#line 965
    verbosity = (enum __anonenum_verbosity_22 )2;
#line 966
    goto switch_break;
    case_130: /* CIL Label */ 
#line 968
    no_strip_trailing_cr = (_Bool)1;
#line 972
    goto switch_break;
    case_131: /* CIL Label */ 
    {
#line 974
    usage(stdout, 0);
    }
    case_132: /* CIL Label */ 
#line 976
    backup_if_mismatch = (_Bool)1;
#line 977
    goto switch_break;
    case_133: /* CIL Label */ 
#line 979
    backup_if_mismatch = (_Bool)0;
#line 980
    goto switch_break;
    case_134: /* CIL Label */ 
#line 982
    posixly_correct = (_Bool)1;
#line 983
    goto switch_break;
    case_135: /* CIL Label */ 
    {
#line 986
    tmp___11 = argmatch((char const   *)rpl_optarg, quoting_style_args, (char const   *)0,
                        (size_t )0);
#line 986
    i = (int )tmp___11;
    }
#line 987
    if (i < 0) {
      {
#line 989
      argmatch_invalid("quoting style", (char const   *)rpl_optarg, (ptrdiff_t )i);
#line 990
      usage(stderr, 2);
      }
    }
    {
#line 992
    set_quoting_style((struct quoting_options *)0, (enum quoting_style )i);
    }
#line 995
    goto switch_break;
    case_136: /* CIL Label */ 
    {
#line 997
    tmp___13 = strcmp((char const   *)rpl_optarg, "context");
    }
#line 997
    if (tmp___13 == 0) {
#line 998
      reject_format = (enum diff )4;
    } else {
      {
#line 999
      tmp___12 = strcmp((char const   *)rpl_optarg, "unified");
      }
#line 999
      if (tmp___12 == 0) {
#line 1000
        reject_format = (enum diff )5;
      } else {
        {
#line 1002
        usage(stderr, 2);
        }
      }
    }
#line 1003
    goto switch_break;
    case_137: /* CIL Label */ 
    {
#line 1005
    tmp___16 = strcmp((char const   *)rpl_optarg, "ignore");
    }
#line 1005
    if (tmp___16 == 0) {
#line 1006
      read_only_behavior = (enum __anonenum_read_only_behavior_34 )0;
    } else {
      {
#line 1007
      tmp___15 = strcmp((char const   *)rpl_optarg, "warn");
      }
#line 1007
      if (tmp___15 == 0) {
#line 1008
        read_only_behavior = (enum __anonenum_read_only_behavior_34 )1;
      } else {
        {
#line 1009
        tmp___14 = strcmp((char const   *)rpl_optarg, "fail");
        }
#line 1009
        if (tmp___14 == 0) {
#line 1010
          read_only_behavior = (enum __anonenum_read_only_behavior_34 )2;
        } else {
          {
#line 1012
          usage(stderr, 2);
          }
        }
      }
    }
#line 1013
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1015
    usage(stderr, 2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1020
  if (rpl_optind < Argc) {
    {
#line 1022
    tmp___17 = rpl_optind;
#line 1022
    rpl_optind ++;
#line 1022
    inname = savestr((char const   *)*(Argv + tmp___17));
#line 1023
    explicit_inname = (_Bool)1;
#line 1024
    invc = -1;
    }
#line 1025
    if (rpl_optind < Argc) {
      {
#line 1027
      tmp___18 = rpl_optind;
#line 1027
      rpl_optind ++;
#line 1027
      tmp___19 = savestr((char const   *)*(Argv + tmp___18));
#line 1027
      patchname = (char const   *)tmp___19;
      }
#line 1028
      if (rpl_optind < Argc) {
        {
#line 1030
        tmp___20 = quotearg((char const   *)*(Argv + rpl_optind));
#line 1030
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: extra operand\n",
                program_name, tmp___20);
#line 1032
        usage(stderr, 2);
        }
      }
    }
  }
#line 1036
  return;
}
}
#line 1041 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static int numeric_string(char const   *string , _Bool negative_allowed , char const   *argtype_msgid ) 
{ 
  int value___0 ;
  char const   *p ;
  int sign ;
  int tmp ;
  int tmp___0 ;
  int v10 ;
  int digit ;
  int signed_digit ;
  int next_value ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1046
  value___0 = 0;
#line 1047
  p = string;
#line 1048
  if ((int const   )*p == 45) {
#line 1048
    tmp = -1;
  } else {
#line 1048
    tmp = 1;
  }
#line 1048
  sign = tmp;
#line 1050
  if ((int const   )*p == 45) {
#line 1050
    tmp___0 = 1;
  } else
#line 1050
  if ((int const   )*p == 43) {
#line 1050
    tmp___0 = 1;
  } else {
#line 1050
    tmp___0 = 0;
  }
#line 1050
  p += tmp___0;
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    v10 = value___0 * 10;
#line 1055
    digit = (int )((int const   )*p - 48);
#line 1056
    signed_digit = sign * digit;
#line 1057
    next_value = v10 + signed_digit;
#line 1059
    if (9U < (unsigned int )digit) {
      {
#line 1060
      tmp___1 = quotearg(string);
#line 1060
      fatal("%s %s is not a number", argtype_msgid, tmp___1);
      }
    }
#line 1062
    if (v10 / 10 != value___0) {
      {
#line 1063
      tmp___2 = quotearg(string);
#line 1063
      fatal("%s %s is too large", argtype_msgid, tmp___2);
      }
    } else
#line 1062
    if ((next_value < v10) != (signed_digit < 0)) {
      {
#line 1063
      tmp___2 = quotearg(string);
#line 1063
      fatal("%s %s is too large", argtype_msgid, tmp___2);
      }
    }
#line 1065
    value___0 = next_value;
#line 1052
    p ++;
#line 1052
    if (! *p) {
#line 1052
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  if (value___0 < 0) {
#line 1069
    if (! negative_allowed) {
      {
#line 1070
      tmp___3 = quotearg(string);
#line 1070
      fatal("%s %s is negative", argtype_msgid, tmp___3);
      }
    }
  }
#line 1072
  return (value___0);
}
}
#line 1077 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static lin locate_hunk(lin fuzz ) 
{ 
  lin first_guess ;
  lin tmp ;
  lin offset ;
  lin pat_lines ;
  lin tmp___0 ;
  lin prefix_context ;
  lin tmp___1 ;
  lin suffix_context ;
  lin tmp___2 ;
  lin context ;
  lin tmp___3 ;
  lin prefix_fuzz ;
  lin suffix_fuzz ;
  lin max_where ;
  lin min_where ;
  lin max_pos_offset ;
  lin max_neg_offset ;
  lin max_offset ;
  lin tmp___4 ;
  _Bool tmp___5 ;
  lin tmp___6 ;
  _Bool tmp___7 ;
  char numbuf0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp___8 ;
  char *tmp___9 ;
  _Bool tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  _Bool tmp___13 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 1080
  tmp = pch_first();
#line 1080
  first_guess = tmp + in_offset;
#line 1082
  tmp___0 = pch_ptrn_lines();
#line 1082
  pat_lines = tmp___0;
#line 1083
  tmp___1 = pch_prefix_context();
#line 1083
  prefix_context = tmp___1;
#line 1084
  tmp___2 = pch_suffix_context();
#line 1084
  suffix_context = tmp___2;
  }
#line 1085
  if (prefix_context < suffix_context) {
#line 1085
    tmp___3 = suffix_context;
  } else {
#line 1085
    tmp___3 = prefix_context;
  }
#line 1085
  context = tmp___3;
#line 1087
  prefix_fuzz = (fuzz + prefix_context) - context;
#line 1088
  suffix_fuzz = (fuzz + suffix_context) - context;
#line 1089
  max_where = (input_lines - (pat_lines - suffix_fuzz)) + 1L;
#line 1090
  min_where = (last_frozen_line + 1L) - (prefix_context - prefix_fuzz);
#line 1091
  max_pos_offset = max_where - first_guess;
#line 1092
  max_neg_offset = first_guess - min_where;
#line 1093
  if (max_pos_offset < max_neg_offset) {
#line 1093
    tmp___4 = max_neg_offset;
  } else {
#line 1093
    tmp___4 = max_pos_offset;
  }
#line 1093
  max_offset = tmp___4;
#line 1096
  if (! pat_lines) {
#line 1097
    return (first_guess);
  }
#line 1100
  if (first_guess <= max_neg_offset) {
#line 1101
    max_neg_offset = first_guess - 1L;
  }
#line 1103
  if (prefix_fuzz < 0L) {
    {
#line 1103
    tmp___6 = pch_first();
    }
#line 1103
    if (tmp___6 <= 1L) {
#line 1107
      if (suffix_fuzz < 0L) {
#line 1109
        if (pat_lines != input_lines) {
#line 1110
          return ((lin )0);
        } else
#line 1109
        if (prefix_context < last_frozen_line) {
#line 1110
          return ((lin )0);
        }
      }
#line 1112
      offset = 1L - first_guess;
#line 1113
      if (last_frozen_line <= prefix_context) {
#line 1113
        if (offset <= max_pos_offset) {
          {
#line 1113
          tmp___5 = patch_match(first_guess, offset, (lin )0, suffix_fuzz);
          }
#line 1113
          if (tmp___5) {
#line 1117
            in_offset += offset;
#line 1118
            return (first_guess + offset);
          } else {
#line 1121
            return ((lin )0);
          }
        } else {
#line 1121
          return ((lin )0);
        }
      } else {
#line 1121
        return ((lin )0);
      }
    } else {
#line 1103
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1123
  if (prefix_fuzz < 0L) {
#line 1124
    prefix_fuzz = (lin )0;
  }
#line 1126
  if (suffix_fuzz < 0L) {
#line 1129
    offset = first_guess - ((input_lines - pat_lines) + 1L);
#line 1130
    if (offset <= max_neg_offset) {
      {
#line 1130
      tmp___7 = patch_match(first_guess, - offset, prefix_fuzz, (lin )0);
      }
#line 1130
      if (tmp___7) {
#line 1133
        in_offset -= offset;
#line 1134
        return (first_guess - offset);
      } else {
#line 1137
        return ((lin )0);
      }
    } else {
#line 1137
      return ((lin )0);
    }
  }
#line 1140
  offset = (lin )0;
  {
#line 1140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1140
    if (! (offset <= max_offset)) {
#line 1140
      goto while_break;
    }
#line 1143
    if (offset <= max_pos_offset) {
      {
#line 1143
      tmp___10 = patch_match(first_guess, offset, prefix_fuzz, suffix_fuzz);
      }
#line 1143
      if (tmp___10) {
#line 1145
        if (debug & 1) {
          {
#line 1146
          tmp___8 = format_linenum((char *)(numbuf1), in_offset + offset);
#line 1146
          tmp___9 = format_linenum((char *)(numbuf0), in_offset);
#line 1146
          say("Offset changing from %s to %s\n", tmp___9, tmp___8);
          }
        }
#line 1149
        in_offset += offset;
#line 1150
        return (first_guess + offset);
      }
    }
#line 1152
    if (0L < offset) {
#line 1152
      if (offset <= max_neg_offset) {
        {
#line 1152
        tmp___13 = patch_match(first_guess, - offset, prefix_fuzz, suffix_fuzz);
        }
#line 1152
        if (tmp___13) {
#line 1154
          if (debug & 1) {
            {
#line 1155
            tmp___11 = format_linenum((char *)(numbuf1), in_offset - offset);
#line 1155
            tmp___12 = format_linenum((char *)(numbuf0), in_offset);
#line 1155
            say("Offset changing from %s to %s\n", tmp___12, tmp___11);
            }
          }
#line 1158
          in_offset -= offset;
#line 1159
          return (first_guess - offset);
        }
      }
    }
#line 1140
    offset ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1162
  return ((lin )0);
}
}
#line 1165
static  __attribute__((__noreturn__)) void mangled_patch(lin old , lin new ) ;
#line 1165 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void mangled_patch(lin old , lin new ) 
{ 
  char numbuf0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char tmp ;
  char tmp___0 ;
  lin tmp___1 ;
  char *tmp___2 ;
  lin tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1170
  if (debug & 1) {
    {
#line 1171
    tmp = pch_char(new);
#line 1171
    tmp___0 = pch_char(old);
#line 1171
    say("oldchar = \'%c\', newchar = \'%c\'\n", (int )tmp___0, (int )tmp);
    }
  }
  {
#line 1173
  tmp___1 = pch_hunk_beg();
#line 1173
  tmp___2 = format_linenum((char *)(numbuf1), tmp___1 + new);
#line 1173
  tmp___3 = pch_hunk_beg();
#line 1173
  tmp___4 = format_linenum((char *)(numbuf0), tmp___3 + old);
#line 1173
  fatal("Out-of-sync patch, lines %s,%s -- mangled text or line numbers, maybe?",
        tmp___4, tmp___2);
  }
}
}
#line 1181 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void print_unidiff_range(FILE *fp , lin start , lin count ) 
{ 
  char numbuf0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1189
  if (count == 0L) {
#line 1189
    goto case_0;
  }
#line 1193
  if (count == 1L) {
#line 1193
    goto case_1;
  }
#line 1197
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1190
  tmp = format_linenum((char *)(numbuf0), start - 1L);
#line 1190
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s,0", tmp);
  }
#line 1191
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1194
  tmp___0 = format_linenum((char *)(numbuf0), start);
#line 1194
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", tmp___0);
  }
#line 1195
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1198
  tmp___1 = format_linenum((char *)(numbuf1), count);
#line 1198
  tmp___2 = format_linenum((char *)(numbuf0), start);
#line 1198
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s,%s", tmp___2,
          tmp___1);
  }
#line 1201
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1203
  return;
}
}
#line 1205 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void print_header_line(FILE *fp , char const   *tag , _Bool reverse___0 ) 
{ 
  char const   *name ;
  char const   *tmp ;
  char const   *timestr ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1208
  tmp = pch_name((enum nametype )reverse___0);
#line 1208
  name = tmp;
#line 1209
  tmp___0 = pch_timestr(reverse___0);
#line 1209
  timestr = tmp___0;
  }
#line 1211
  if (timestr) {
#line 1211
    tmp___1 = timestr;
  } else {
#line 1211
    tmp___1 = "";
  }
#line 1211
  if (name) {
#line 1211
    tmp___2 = name;
  } else {
#line 1211
    tmp___2 = "/dev/null";
  }
  {
#line 1211
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s %s%s\n",
          tag, tmp___2, tmp___1);
  }
#line 1213
  return;
}
}
#line 1217 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void abort_hunk_unified(_Bool header , _Bool reverse___0 ) 
{ 
  lin old ;
  lin lastline ;
  lin tmp ;
  lin new ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  lin tmp___2 ;
  lin tmp___3 ;
  lin tmp___4 ;
  char tmp___5 ;
  char tmp___6 ;
  char tmp___7 ;
  char tmp___8 ;
  char tmp___9 ;
  char tmp___10 ;
  char tmp___11 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 1220
  old = (lin )1;
#line 1221
  tmp = pch_ptrn_lines();
#line 1221
  lastline = tmp;
#line 1222
  new = lastline + 1L;
  }
#line 1224
  if (header) {
    {
#line 1226
    tmp___1 = pch_name((enum nametype )2);
    }
#line 1226
    if (tmp___1) {
      {
#line 1227
      tmp___0 = pch_name((enum nametype )2);
#line 1227
      fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"Index: %s\n",
              tmp___0);
      }
    }
    {
#line 1228
    print_header_line(rejfp, "---", reverse___0);
#line 1229
    print_header_line(rejfp, "+++", (_Bool )(! reverse___0));
    }
  }
  {
#line 1233
  fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"@@ -");
#line 1234
  tmp___2 = pch_first();
#line 1234
  print_unidiff_range(rejfp, tmp___2 + out_offset, lastline);
#line 1235
  fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)" +");
#line 1236
  tmp___3 = pch_repl_lines();
#line 1236
  tmp___4 = pch_newfirst();
#line 1236
  print_unidiff_range(rejfp, tmp___4 + out_offset, tmp___3);
#line 1237
  fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)" @@\n");
  }
  {
#line 1239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1239
    tmp___5 = pch_char(new);
    }
#line 1239
    if (! ((int )tmp___5 == 61)) {
      {
#line 1239
      tmp___6 = pch_char(new);
      }
#line 1239
      if (! ((int )tmp___6 == 10)) {
#line 1239
        goto while_break;
      }
    }
#line 1240
    new ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1242
  if ((unsigned int )diff_type != 5U) {
    {
#line 1243
    pch_normalize((enum diff )5);
    }
  }
  {
#line 1245
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1247
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1247
      tmp___7 = pch_char(old);
      }
#line 1247
      if (! ((int )tmp___7 == 45)) {
#line 1247
        goto while_break___1;
      }
      {
#line 1249
      fputc('-', rejfp);
#line 1250
      pch_write_line(old, rejfp);
#line 1247
      old ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1252
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1252
      tmp___8 = pch_char(new);
      }
#line 1252
      if (! ((int )tmp___8 == 43)) {
#line 1252
        goto while_break___2;
      }
      {
#line 1254
      fputc('+', rejfp);
#line 1255
      pch_write_line(new, rejfp);
#line 1252
      new ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1258
    if (old > lastline) {
#line 1259
      goto while_break___0;
    }
    {
#line 1261
    tmp___9 = pch_char(new);
#line 1261
    tmp___10 = pch_char(old);
    }
#line 1261
    if ((int )tmp___9 != (int )tmp___10) {
      {
#line 1262
      mangled_patch(old, new);
      }
    }
    {
#line 1264
    fputc(' ', rejfp);
#line 1265
    pch_write_line(old, rejfp);
#line 1245
    old ++;
#line 1245
    new ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1267
  tmp___11 = pch_char(new);
  }
#line 1267
  if ((int )tmp___11 != 94) {
    {
#line 1268
    mangled_patch(old, new);
    }
  }
#line 1269
  return;
}
}
#line 1273 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void abort_hunk_context(_Bool header , _Bool reverse___0 ) 
{ 
  lin i ;
  lin pat_end ;
  lin tmp ;
  lin oldfirst ;
  lin tmp___0 ;
  lin newfirst ;
  lin tmp___1 ;
  lin oldlast ;
  lin tmp___2 ;
  lin newlast ;
  lin tmp___3 ;
  char const   *stars ;
  char const   *tmp___4 ;
  char const   *minuses ;
  char const   *tmp___5 ;
  char const   *c_function ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char numbuf0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char tmp___17 ;
  int tmp___18 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
  {
#line 1277
  tmp = pch_end();
#line 1277
  pat_end = tmp;
#line 1279
  tmp___0 = pch_first();
#line 1279
  oldfirst = tmp___0 + out_offset;
#line 1280
  tmp___1 = pch_newfirst();
#line 1280
  newfirst = tmp___1 + out_offset;
#line 1281
  tmp___2 = pch_ptrn_lines();
#line 1281
  oldlast = (oldfirst + tmp___2) - 1L;
#line 1282
  tmp___3 = pch_repl_lines();
#line 1282
  newlast = (newfirst + tmp___3) - 1L;
  }
#line 1283
  if (4 <= (int )diff_type) {
#line 1283
    tmp___4 = " ****";
  } else {
#line 1283
    tmp___4 = "";
  }
#line 1283
  stars = tmp___4;
#line 1285
  if (4 <= (int )diff_type) {
#line 1285
    tmp___5 = " ----";
  } else {
#line 1285
    tmp___5 = " -----";
  }
  {
#line 1285
  minuses = tmp___5;
#line 1287
  tmp___6 = pch_c_function();
#line 1287
  c_function = tmp___6;
  }
#line 1289
  if ((unsigned int )diff_type == 5U) {
    {
#line 1290
    pch_normalize((enum diff )4);
    }
  }
#line 1292
  if (header) {
    {
#line 1294
    tmp___8 = pch_name((enum nametype )2);
    }
#line 1294
    if (tmp___8) {
      {
#line 1295
      tmp___7 = pch_name((enum nametype )2);
#line 1295
      fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"Index: %s\n",
              tmp___7);
      }
    }
    {
#line 1296
    print_header_line(rejfp, "***", reverse___0);
#line 1297
    print_header_line(rejfp, "---", (_Bool )(! reverse___0));
    }
  }
#line 1299
  if (c_function) {
#line 1299
    tmp___9 = c_function;
  } else {
#line 1299
    tmp___9 = "";
  }
  {
#line 1299
  fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"***************%s\n",
          tmp___9);
#line 1300
  i = (lin )0;
  }
  {
#line 1300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1300
    if (! (i <= pat_end)) {
#line 1300
      goto while_break;
    }
    {
#line 1303
    tmp___10 = pch_char(i);
    }
    {
#line 1304
    if ((int )tmp___10 == 42) {
#line 1304
      goto case_42;
    }
#line 1315
    if ((int )tmp___10 == 61) {
#line 1315
      goto case_61;
    }
#line 1326
    if ((int )tmp___10 == 33) {
#line 1326
      goto case_33;
    }
#line 1326
    if ((int )tmp___10 == 43) {
#line 1326
      goto case_33;
    }
#line 1326
    if ((int )tmp___10 == 45) {
#line 1326
      goto case_33;
    }
#line 1326
    if ((int )tmp___10 == 32) {
#line 1326
      goto case_33;
    }
#line 1329
    if ((int )tmp___10 == 10) {
#line 1329
      goto case_10;
    }
#line 1332
    goto switch_default;
    case_42: /* CIL Label */ 
#line 1305
    if (oldlast < oldfirst) {
      {
#line 1306
      fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"*** 0%s\n",
              stars);
      }
    } else
#line 1307
    if (oldlast == oldfirst) {
      {
#line 1308
      tmp___11 = format_linenum((char *)(numbuf0), oldfirst);
#line 1308
      fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"*** %s%s\n",
              tmp___11, stars);
      }
    } else {
      {
#line 1311
      tmp___12 = format_linenum((char *)(numbuf1), oldlast);
#line 1311
      tmp___13 = format_linenum((char *)(numbuf0), oldfirst);
#line 1311
      fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"*** %s,%s%s\n",
              tmp___13, tmp___12, stars);
      }
    }
#line 1314
    goto switch_break;
    case_61: /* CIL Label */ 
#line 1316
    if (newlast < newfirst) {
      {
#line 1317
      fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"--- 0%s\n",
              minuses);
      }
    } else
#line 1318
    if (newlast == newfirst) {
      {
#line 1319
      tmp___14 = format_linenum((char *)(numbuf0), newfirst);
#line 1319
      fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"--- %s%s\n",
              tmp___14, minuses);
      }
    } else {
      {
#line 1322
      tmp___15 = format_linenum((char *)(numbuf1), newlast);
#line 1322
      tmp___16 = format_linenum((char *)(numbuf0), newfirst);
#line 1322
      fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"--- %s,%s%s\n",
              tmp___16, tmp___15, minuses);
      }
    }
#line 1325
    goto switch_break;
    case_33: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 1327
    tmp___17 = pch_char(i);
#line 1327
    fprintf((FILE */* __restrict  */)rejfp, (char const   */* __restrict  */)"%c ",
            (int )tmp___17);
    }
    case_10: /* CIL Label */ 
    {
#line 1330
    pch_write_line(i, rejfp);
    }
#line 1331
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1333
    fatal("fatal internal error in abort_hunk_context");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 1335
    tmp___18 = ferror(rejfp);
    }
#line 1335
    if (tmp___18) {
      {
#line 1336
      write_fatal();
      }
    }
#line 1300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1338
  return;
}
}
#line 1342 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void abort_hunk(char const   *outname , _Bool header , _Bool reverse___0 ) 
{ 


  {
#line 1345
  if (! TMPREJNAME_needs_removal) {
    {
#line 1346
    init_reject(outname);
    }
  }
#line 1347
  if ((unsigned int )reject_format == 5U) {
    {
#line 1349
    abort_hunk_unified(header, reverse___0);
    }
  } else
#line 1347
  if ((unsigned int )reject_format == 0U) {
#line 1347
    if ((unsigned int )diff_type == 5U) {
      {
#line 1349
      abort_hunk_unified(header, reverse___0);
      }
    } else {
      {
#line 1351
      abort_hunk_context(header, reverse___0);
      }
    }
  } else {
    {
#line 1351
    abort_hunk_context(header, reverse___0);
    }
  }
#line 1352
  return;
}
}
#line 1356 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static _Bool apply_hunk(struct outstate *outstate , lin where ) 
{ 
  lin old ;
  lin lastline ;
  lin tmp ;
  lin new ;
  enum __anonenum_def_state_35 def_state ;
  char const   *R_do_defines ;
  lin pat_end ;
  lin tmp___0 ;
  FILE *fp ;
  char tmp___1 ;
  char tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  char tmp___9 ;
  int tmp___10 ;
  char tmp___11 ;
  char tmp___12 ;
  int tmp___13 ;
  char tmp___14 ;
  char tmp___15 ;
  char tmp___16 ;
  char tmp___17 ;
  char tmp___18 ;
  _Bool tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char tmp___22 ;
  char tmp___23 ;
  int tmp___24 ;
  lin tmp___25 ;
  lin tmp___26 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 1359
  old = (lin )1;
#line 1360
  tmp = pch_ptrn_lines();
#line 1360
  lastline = tmp;
#line 1361
  new = lastline + 1L;
#line 1362
  def_state = (enum __anonenum_def_state_35 )0;
#line 1363
  R_do_defines = do_defines;
#line 1364
  tmp___0 = pch_end();
#line 1364
  pat_end = tmp___0;
#line 1365
  fp = outstate->ofp;
#line 1367
  where --;
  }
  {
#line 1368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1368
    tmp___1 = pch_char(new);
    }
#line 1368
    if (! ((int )tmp___1 == 61)) {
      {
#line 1368
      tmp___2 = pch_char(new);
      }
#line 1368
      if (! ((int )tmp___2 == 10)) {
#line 1368
        goto while_break;
      }
    }
#line 1369
    new ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1371
    if (! (old <= lastline)) {
#line 1371
      goto while_break___0;
    }
    {
#line 1372
    tmp___18 = pch_char(old);
    }
#line 1372
    if ((int )tmp___18 == 45) {
#line 1373
      if (! outstate->after_newline) {
        {
#line 1373
        __assert_fail("outstate->after_newline", "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c",
                      1373U, "apply_hunk");
        }
      }
      {
#line 1374
      tmp___3 = copy_till(outstate, (where + old) - 1L);
      }
#line 1374
      if (! tmp___3) {
#line 1375
        return ((_Bool)0);
      }
#line 1376
      if (R_do_defines) {
#line 1377
        if ((unsigned int )def_state == 0U) {
          {
#line 1378
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)(not_defined + (int )outstate->after_newline),
                  R_do_defines);
#line 1380
          def_state = (enum __anonenum_def_state_35 )1;
          }
        } else
#line 1382
        if ((unsigned int )def_state == 2U) {
          {
#line 1383
          fputs((char const   */* __restrict  */)(else_defined + (int )outstate->after_newline),
                (FILE */* __restrict  */)fp);
#line 1384
          def_state = (enum __anonenum_def_state_35 )3;
          }
        }
        {
#line 1386
        tmp___4 = ferror(fp);
        }
#line 1386
        if (tmp___4) {
          {
#line 1387
          write_fatal();
          }
        }
        {
#line 1388
        outstate->after_newline = pch_write_line(old, fp);
#line 1389
        outstate->zero_output = (_Bool)0;
        }
      }
#line 1391
      last_frozen_line ++;
#line 1392
      old ++;
    } else
#line 1394
    if (new > pat_end) {
#line 1395
      goto while_break___0;
    } else {
      {
#line 1397
      tmp___17 = pch_char(new);
      }
#line 1397
      if ((int )tmp___17 == 43) {
        {
#line 1398
        tmp___5 = copy_till(outstate, (where + old) - 1L);
        }
#line 1398
        if (! tmp___5) {
#line 1399
          return ((_Bool)0);
        }
#line 1400
        if (R_do_defines) {
#line 1401
          if ((unsigned int )def_state == 1U) {
            {
#line 1402
            fputs((char const   */* __restrict  */)(else_defined + (int )outstate->after_newline),
                  (FILE */* __restrict  */)fp);
#line 1403
            def_state = (enum __anonenum_def_state_35 )3;
            }
          } else
#line 1405
          if ((unsigned int )def_state == 0U) {
            {
#line 1406
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)(if_defined + (int )outstate->after_newline),
                    R_do_defines);
#line 1408
            def_state = (enum __anonenum_def_state_35 )2;
            }
          }
          {
#line 1410
          tmp___6 = ferror(fp);
          }
#line 1410
          if (tmp___6) {
            {
#line 1411
            write_fatal();
            }
          }
        }
        {
#line 1413
        outstate->after_newline = pch_write_line(new, fp);
#line 1414
        outstate->zero_output = (_Bool)0;
#line 1415
        new ++;
        }
      } else {
        {
#line 1417
        tmp___15 = pch_char(new);
#line 1417
        tmp___16 = pch_char(old);
        }
#line 1417
        if ((int )tmp___15 != (int )tmp___16) {
          {
#line 1418
          mangled_patch(old, new);
          }
        } else {
          {
#line 1419
          tmp___14 = pch_char(new);
          }
#line 1419
          if ((int )tmp___14 == 33) {
#line 1420
            if (! outstate->after_newline) {
              {
#line 1420
              __assert_fail("outstate->after_newline", "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c",
                            1420U, "apply_hunk");
              }
            }
            {
#line 1421
            tmp___7 = copy_till(outstate, (where + old) - 1L);
            }
#line 1421
            if (! tmp___7) {
#line 1422
              return ((_Bool)0);
            }
#line 1423
            if (! outstate->after_newline) {
              {
#line 1423
              __assert_fail("outstate->after_newline", "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c",
                            1423U, "apply_hunk");
              }
            }
#line 1424
            if (R_do_defines) {
              {
#line 1425
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)(not_defined + 1),
                      R_do_defines);
#line 1426
              tmp___8 = ferror(fp);
              }
#line 1426
              if (tmp___8) {
                {
#line 1427
                write_fatal();
                }
              }
#line 1428
              def_state = (enum __anonenum_def_state_35 )1;
            }
            {
#line 1431
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1433
              if (R_do_defines) {
                {
#line 1434
                outstate->after_newline = pch_write_line(old, fp);
                }
              }
              {
#line 1436
              last_frozen_line ++;
#line 1437
              old ++;
#line 1431
              tmp___9 = pch_char(old);
              }
#line 1431
              if (! ((int )tmp___9 == 33)) {
#line 1431
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1441
            if (R_do_defines) {
              {
#line 1442
              fputs((char const   */* __restrict  */)(else_defined + (int )outstate->after_newline),
                    (FILE */* __restrict  */)fp);
#line 1443
              tmp___10 = ferror(fp);
              }
#line 1443
              if (tmp___10) {
                {
#line 1444
                write_fatal();
                }
              }
#line 1445
              def_state = (enum __anonenum_def_state_35 )3;
            }
            {
#line 1448
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 1450
              outstate->after_newline = pch_write_line(new, fp);
#line 1451
              new ++;
#line 1448
              tmp___11 = pch_char(new);
              }
#line 1448
              if (! ((int )tmp___11 == 33)) {
#line 1448
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 1454
            outstate->zero_output = (_Bool)0;
          } else {
            {
#line 1457
            tmp___12 = pch_char(new);
            }
#line 1457
            if (! ((int )tmp___12 == 32)) {
              {
#line 1457
              __assert_fail("pch_char(new) == \' \'", "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c",
                            1457U, "apply_hunk");
              }
            }
#line 1458
            old ++;
#line 1459
            new ++;
#line 1460
            if (R_do_defines) {
#line 1460
              if ((unsigned int )def_state != 0U) {
                {
#line 1461
                fputs((char const   */* __restrict  */)(end_defined + (int )outstate->after_newline),
                      (FILE */* __restrict  */)fp);
#line 1462
                tmp___13 = ferror(fp);
                }
#line 1462
                if (tmp___13) {
                  {
#line 1463
                  write_fatal();
                  }
                }
#line 1464
                outstate->after_newline = (_Bool)1;
#line 1465
                def_state = (enum __anonenum_def_state_35 )0;
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1469
  if (new <= pat_end) {
    {
#line 1469
    tmp___23 = pch_char(new);
    }
#line 1469
    if ((int )tmp___23 == 43) {
      {
#line 1470
      tmp___19 = copy_till(outstate, (where + old) - 1L);
      }
#line 1470
      if (! tmp___19) {
#line 1471
        return ((_Bool)0);
      }
#line 1472
      if (R_do_defines) {
#line 1473
        if ((unsigned int )def_state == 0U) {
          {
#line 1474
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)(if_defined + (int )outstate->after_newline),
                  R_do_defines);
#line 1476
          def_state = (enum __anonenum_def_state_35 )2;
          }
        } else
#line 1478
        if ((unsigned int )def_state == 1U) {
          {
#line 1479
          fputs((char const   */* __restrict  */)(else_defined + (int )outstate->after_newline),
                (FILE */* __restrict  */)fp);
#line 1480
          def_state = (enum __anonenum_def_state_35 )3;
          }
        }
        {
#line 1482
        tmp___20 = ferror(fp);
        }
#line 1482
        if (tmp___20) {
          {
#line 1483
          write_fatal();
          }
        }
#line 1484
        outstate->zero_output = (_Bool)0;
      }
      {
#line 1487
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1489
        if (! outstate->after_newline) {
          {
#line 1489
          tmp___21 = _IO_putc('\n', fp);
          }
#line 1489
          if (tmp___21 == -1) {
            {
#line 1490
            write_fatal();
            }
          }
        }
        {
#line 1491
        outstate->after_newline = pch_write_line(new, fp);
#line 1492
        outstate->zero_output = (_Bool)0;
#line 1493
        new ++;
        }
#line 1487
        if (new <= pat_end) {
          {
#line 1487
          tmp___22 = pch_char(new);
          }
#line 1487
          if (! ((int )tmp___22 == 43)) {
#line 1487
            goto while_break___3;
          }
        } else {
#line 1487
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 1497
  if (R_do_defines) {
#line 1497
    if ((unsigned int )def_state != 0U) {
      {
#line 1498
      fputs((char const   */* __restrict  */)(end_defined + (int )outstate->after_newline),
            (FILE */* __restrict  */)fp);
#line 1499
      tmp___24 = ferror(fp);
      }
#line 1499
      if (tmp___24) {
        {
#line 1500
        write_fatal();
        }
      }
#line 1501
      outstate->after_newline = (_Bool)1;
    }
  }
  {
#line 1503
  tmp___25 = pch_repl_lines();
#line 1503
  tmp___26 = pch_ptrn_lines();
#line 1503
  out_offset += tmp___25 - tmp___26;
  }
#line 1504
  return ((_Bool)1);
}
}
#line 1509 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static FILE *create_output_file(char const   *name , int open_flags ) 
{ 
  int fd ;
  int tmp ;
  FILE *f ;
  FILE *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1512
  tmp = create_file(name, 1 | open_flags, instat.st_mode, (_Bool)1);
#line 1512
  fd = tmp;
#line 1514
  tmp___0 = fdopen(fd, "w");
#line 1514
  f = tmp___0;
  }
#line 1515
  if (! f) {
    {
#line 1516
    tmp___1 = quotearg(name);
#line 1516
    pfatal("Can\'t create file %s", tmp___1);
    }
  }
#line 1517
  return (f);
}
}
#line 1522 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void init_output(struct outstate *outstate ) 
{ 


  {
#line 1525
  outstate->ofp = (FILE *)((void *)0);
#line 1526
  outstate->after_newline = (_Bool)1;
#line 1527
  outstate->zero_output = (_Bool)1;
#line 1528
  return;
}
}
#line 1530 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static FILE *open_outfile(char const   *name ) 
{ 
  FILE *tmp ;
  FILE *ofp ;
  int stdout_dup ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1533
  tmp___5 = strcmp(name, "-");
  }
#line 1533
  if (tmp___5 != 0) {
    {
#line 1534
    tmp = create_output_file(name, 0);
    }
#line 1534
    return (tmp);
  } else {
    {
#line 1538
    tmp___0 = fileno(stdout);
#line 1538
    tmp___1 = dup(tmp___0);
#line 1538
    stdout_dup = tmp___1;
    }
#line 1539
    if (stdout_dup == -1) {
      {
#line 1540
      pfatal("Failed to duplicate standard output");
      }
    }
    {
#line 1541
    ofp = fdopen(stdout_dup, "a");
    }
#line 1542
    if (! ofp) {
      {
#line 1543
      pfatal("Failed to duplicate standard output");
      }
    }
    {
#line 1544
    tmp___2 = fileno(stdout);
#line 1544
    tmp___3 = fileno(stderr);
#line 1544
    tmp___4 = dup2(tmp___3, tmp___2);
    }
#line 1544
    if (tmp___4 == -1) {
      {
#line 1545
      pfatal("Failed to redirect messages to standard error");
      }
    }
#line 1547
    return (ofp);
  }
}
}
#line 1553 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void init_reject(char const   *outname ) 
{ 
  int fd ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1557
  fd = make_tempfile(& TMPREJNAME, (char )'r', outname, 1, (mode_t )438);
#line 1559
  TMPREJNAME_needs_removal = 1;
#line 1560
  rejfp = fdopen(fd, "w");
  }
#line 1561
  if (! rejfp) {
    {
#line 1562
    tmp = quotearg(TMPREJNAME);
#line 1562
    pfatal("Can\'t open stream for file %s", tmp);
    }
  }
#line 1563
  return;
}
}
#line 1567 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
_Bool copy_till(struct outstate *outstate , lin lastline ) 
{ 
  lin R_last_frozen_line ;
  FILE *fp ;
  char const   *s ;
  size_t size ;
  int tmp ;
  size_t tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 1570
  R_last_frozen_line = last_frozen_line;
#line 1571
  fp = outstate->ofp;
#line 1575
  if (R_last_frozen_line > lastline) {
    {
#line 1577
    say("misordered hunks! output would be garbled\n");
    }
#line 1578
    return ((_Bool)0);
  }
  {
#line 1580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1580
    if (! (R_last_frozen_line < lastline)) {
#line 1580
      goto while_break;
    }
    {
#line 1582
    R_last_frozen_line ++;
#line 1582
    s = ifetch(R_last_frozen_line, (_Bool)0, & size);
    }
#line 1583
    if (size) {
#line 1585
      if (! outstate->after_newline) {
        {
#line 1585
        tmp = _IO_putc('\n', fp);
        }
#line 1585
        if (tmp == -1) {
          {
#line 1587
          write_fatal();
          }
        } else {
#line 1585
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1585
        tmp___0 = fwrite((void const   */* __restrict  */)s, sizeof(*s), size, (FILE */* __restrict  */)fp);
        }
#line 1585
        if (! tmp___0) {
          {
#line 1587
          write_fatal();
          }
        }
      }
#line 1588
      outstate->after_newline = (_Bool )((int const   )*(s + (size - 1UL)) == 10);
#line 1589
      outstate->zero_output = (_Bool)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1592
  last_frozen_line = R_last_frozen_line;
#line 1593
  return ((_Bool)1);
}
}
#line 1598 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static _Bool spew_output(struct outstate *outstate , struct stat *st ) 
{ 
  char numbuf0[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char numbuf1[((sizeof(lin ) * 8UL) / 3UL + 1UL) + 1UL] ;
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1601
  if (debug & 256) {
    {
#line 1605
    tmp = format_linenum((char *)(numbuf1), last_frozen_line);
#line 1605
    tmp___0 = format_linenum((char *)(numbuf0), input_lines);
#line 1605
    say("il=%s lfl=%s\n", tmp___0, tmp);
    }
  }
#line 1610
  if (last_frozen_line < input_lines) {
    {
#line 1611
    tmp___1 = copy_till(outstate, input_lines);
    }
#line 1611
    if (! tmp___1) {
#line 1612
      return ((_Bool)0);
    }
  }
#line 1614
  if (outstate->ofp) {
#line 1614
    if (! outfile) {
      {
#line 1616
      tmp___2 = fflush(outstate->ofp);
      }
#line 1616
      if (tmp___2 != 0) {
        {
#line 1619
        write_fatal();
        }
      } else {
        {
#line 1616
        tmp___3 = fileno(outstate->ofp);
#line 1616
        tmp___4 = fstat(tmp___3, st);
        }
#line 1616
        if (tmp___4 != 0) {
          {
#line 1619
          write_fatal();
          }
        } else {
          {
#line 1616
          tmp___5 = fclose(outstate->ofp);
          }
#line 1616
          if (tmp___5 != 0) {
            {
#line 1619
            write_fatal();
            }
          }
        }
      }
#line 1620
      outstate->ofp = (FILE *)0;
    }
  }
#line 1623
  return ((_Bool)1);
}
}
#line 1628 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static _Bool patch_match(lin base , lin offset , lin prefix_fuzz , lin suffix_fuzz ) 
{ 
  lin pline ;
  lin iline ;
  lin pat_lines ;
  lin tmp ;
  size_t size ;
  char const   *p ;
  size_t tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1631
  pline = 1L + prefix_fuzz;
#line 1633
  tmp = pch_ptrn_lines();
#line 1633
  pat_lines = tmp - suffix_fuzz;
#line 1637
  iline = (base + offset) + prefix_fuzz;
  }
  {
#line 1637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1637
    if (! (pline <= pat_lines)) {
#line 1637
      goto while_break;
    }
    {
#line 1638
    p = ifetch(iline, (_Bool )(offset >= 0L), & size);
    }
#line 1639
    if (canonicalize) {
      {
#line 1640
      tmp___0 = pch_line_len(pline);
#line 1640
      tmp___1 = pfetch(pline);
#line 1640
      tmp___2 = similar(p, size, (char const   *)tmp___1, tmp___0);
      }
#line 1640
      if (! tmp___2) {
#line 1643
        return ((_Bool)0);
      }
    } else {
      {
#line 1645
      tmp___3 = pch_line_len(pline);
      }
#line 1645
      if (size != tmp___3) {
#line 1647
        return ((_Bool)0);
      } else {
        {
#line 1645
        tmp___4 = pfetch(pline);
#line 1645
        tmp___5 = memcmp((void const   *)p, (void const   *)tmp___4, size);
        }
#line 1645
        if (tmp___5 != 0) {
#line 1647
          return ((_Bool)0);
        }
      }
    }
#line 1637
    pline ++;
#line 1637
    iline ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1649
  return ((_Bool)1);
}
}
#line 1654
_Bool similar(char const   *a , size_t alen , char const   *b , size_t blen )  __attribute__((__pure__)) ;
#line 1654 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
_Bool similar(char const   *a , size_t alen , char const   *b , size_t blen ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1658
  if (alen) {
#line 1658
    if ((int const   )*(a + (alen - 1UL)) == 10) {
#line 1658
      tmp = 1;
    } else {
#line 1658
      tmp = 0;
    }
  } else {
#line 1658
    tmp = 0;
  }
#line 1658
  alen -= (size_t )tmp;
#line 1659
  if (blen) {
#line 1659
    if ((int const   )*(b + (blen - 1UL)) == 10) {
#line 1659
      tmp___0 = 1;
    } else {
#line 1659
      tmp___0 = 0;
    }
  } else {
#line 1659
    tmp___0 = 0;
  }
#line 1659
  blen -= (size_t )tmp___0;
  {
#line 1661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1663
    if (! blen) {
#line 1663
      goto _L___0;
    } else
#line 1663
    if ((int const   )*b == 32) {
#line 1663
      goto _L___0;
    } else
#line 1663
    if ((int const   )*b == 9) {
      _L___0: /* CIL Label */ 
      {
#line 1665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1665
        if (blen) {
#line 1665
          if (! ((int const   )*b == 32)) {
#line 1665
            if (! ((int const   )*b == 9)) {
#line 1665
              goto while_break___0;
            }
          }
        } else {
#line 1665
          goto while_break___0;
        }
#line 1666
        b ++;
#line 1666
        blen --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1667
      if (alen) {
#line 1669
        if (! ((int const   )*a == 32)) {
#line 1669
          if (! ((int const   )*a == 9)) {
#line 1670
            return ((_Bool)0);
          }
        }
        {
#line 1671
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1671
          a ++;
#line 1671
          alen --;
#line 1671
          if (alen) {
#line 1671
            if (! ((int const   )*a == 32)) {
#line 1671
              if (! ((int const   )*a == 9)) {
#line 1671
                goto while_break___1;
              }
            }
          } else {
#line 1671
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1674
      if (! alen) {
#line 1675
        return ((_Bool )(alen == blen));
      } else
#line 1674
      if (! blen) {
#line 1675
        return ((_Bool )(alen == blen));
      }
    } else
#line 1677
    if (! alen) {
#line 1678
      return ((_Bool)0);
    } else {
#line 1677
      tmp___1 = a;
#line 1677
      a ++;
#line 1677
      tmp___2 = b;
#line 1677
      b ++;
#line 1677
      if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1678
        return ((_Bool)0);
      } else {
#line 1680
        alen --;
#line 1680
        blen --;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1692 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static gl_list_t files_to_delete  ;
#line 1694 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void init_files_to_delete(void) 
{ 


  {
  {
#line 1697
  files_to_delete = gl_list_create_empty_inline(& gl_linked_list_implementation, (_Bool (*)(void const   *elt1 ,
                                                                                            void const   *elt2 ))((void *)0),
                                                (size_t (*)(void const   *elt ))((void *)0),
                                                (void (*)(void const   *elt ))((void *)0),
                                                (_Bool)1);
  }
#line 1698
  return;
}
}
#line 1700 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void delete_file_later(char const   *name , struct stat  const  *st , _Bool backup ) 
{ 
  struct file_to_delete *file_to_delete ;
  struct stat st_tmp ;
  int tmp ;
  void *tmp___0 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1706
  if (! st) {
    {
#line 1708
    tmp = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st_tmp));
    }
#line 1708
    if (tmp != 0) {
      {
#line 1709
      pfatal("Can\'t get file attributes of %s %s", "file", name);
      }
    }
#line 1710
    st = (struct stat  const  *)(& st_tmp);
  }
  {
#line 1712
  tmp___0 = xmalloc(sizeof(*file_to_delete));
#line 1712
  file_to_delete = (struct file_to_delete *)tmp___0;
#line 1713
  file_to_delete->name = xstrdup(name);
#line 1714
  file_to_delete->st = (struct stat )*st;
#line 1715
  file_to_delete->backup = backup;
#line 1716
  gl_list_add_last_inline(files_to_delete, (void const   *)file_to_delete);
#line 1717
  insert_file_id(st, (enum file_id_type )2);
  }
#line 1718
  return;
}
}
#line 1720 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void delete_files(void) 
{ 
  gl_list_iterator_t iter ;
  void const   *elt ;
  struct file_to_delete  const  *file_to_delete ;
  mode_t mode ;
  char *tmp ;
  char const   *tmp___0 ;
  enum file_id_type tmp___1 ;
  _Bool tmp___2 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1726
  iter = gl_list_iterator_inline(files_to_delete);
  }
  {
#line 1727
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1727
    tmp___2 = gl_list_iterator_next_inline(& iter, & elt, (gl_list_node_t *)((void *)0));
    }
#line 1727
    if (! tmp___2) {
#line 1727
      goto while_break;
    }
    {
#line 1729
    file_to_delete = (struct file_to_delete  const  *)elt;
#line 1731
    tmp___1 = lookup_file_id(& file_to_delete->st);
    }
#line 1731
    if ((unsigned int )tmp___1 == 2U) {
#line 1733
      mode = (mode_t )file_to_delete->st.st_mode;
#line 1735
      if ((unsigned int )verbosity == 2U) {
        {
#line 1736
        tmp = quotearg((char const   *)file_to_delete->name);
        }
#line 1736
        if ((mode & 61440U) == 40960U) {
#line 1736
          tmp___0 = "symbolic link";
        } else {
#line 1736
          tmp___0 = "file";
        }
        {
#line 1736
        say("Removing %s %s\n", tmp___0, tmp);
        }
      }
      {
#line 1739
      move_file((char const   *)0, (int *)0, (struct stat  const  *)0, (char const   *)file_to_delete->name,
                mode, (_Bool )file_to_delete->backup);
#line 1741
      removedirs((char const   *)file_to_delete->name);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1744
  gl_list_iterator_free_inline(& iter);
  }
#line 1745
  return;
}
}
#line 1757 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static gl_list_t files_to_output  ;
#line 1759 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void output_file_later(char const   *from , int *from_needs_removal , struct stat  const  *from_st ,
                              char const   *to , mode_t mode , _Bool backup ) 
{ 
  struct file_to_output *file_to_output ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 1765
  tmp = xmalloc(sizeof(*file_to_output));
#line 1765
  file_to_output = (struct file_to_output *)tmp;
#line 1766
  file_to_output->from = xstrdup(from);
#line 1767
  file_to_output->from_st = (struct stat )*from_st;
  }
#line 1768
  if (to) {
    {
#line 1768
    tmp___0 = xstrdup(to);
#line 1768
    file_to_output->to = tmp___0;
    }
  } else {
#line 1768
    file_to_output->to = (char *)((void *)0);
  }
  {
#line 1769
  file_to_output->mode = mode;
#line 1770
  file_to_output->backup = backup;
#line 1771
  gl_list_add_last_inline(files_to_output, (void const   *)file_to_output);
  }
#line 1772
  if (from_needs_removal) {
#line 1773
    *from_needs_removal = 0;
  }
#line 1774
  return;
}
}
#line 1776 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void output_file_now(char const   *from , int *from_needs_removal , struct stat  const  *from_st ,
                            char const   *to , mode_t mode , _Bool backup ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1781
  if ((unsigned long )to == (unsigned long )((void *)0)) {
#line 1783
    if (backup) {
      {
#line 1784
      create_backup(from, from_st, (_Bool)1);
      }
    }
  } else {
#line 1788
    if (! (from_st->st_size != -1L)) {
      {
#line 1788
      __assert_fail("from_st->st_size != -1", "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c",
                    1788U, "output_file_now");
      }
    }
    {
#line 1789
    move_file(from, from_needs_removal, from_st, to, mode, backup);
    }
  }
#line 1791
  return;
}
}
#line 1793 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void output_file(char const   *from , int *from_needs_removal , struct stat  const  *from_st ,
                        char const   *to , struct stat  const  *to_st , mode_t mode ,
                        _Bool backup ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 1798
  if ((unsigned long )from == (unsigned long )((void *)0)) {
    {
#line 1804
    delete_file_later(to, to_st, backup);
    }
  } else {
    {
#line 1806
    tmp = pch_git_diff();
    }
#line 1806
    if (tmp) {
      {
#line 1806
      tmp___0 = pch_says_nonexistent(reverse);
      }
#line 1806
      if (tmp___0 != 2) {
        {
#line 1822
        output_file_later(from, from_needs_removal, from_st, to, mode, backup);
        }
      } else {
        {
#line 1825
        output_file_now(from, from_needs_removal, from_st, to, mode, backup);
        }
      }
    } else {
      {
#line 1825
      output_file_now(from, from_needs_removal, from_st, to, mode, backup);
      }
    }
  }
#line 1826
  return;
}
}
#line 1828 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void dispose_file_to_output(void const   *elt ) 
{ 
  struct file_to_output  const  *file_to_output ;

  {
  {
#line 1831
  file_to_output = (struct file_to_output  const  *)elt;
#line 1833
  free((void *)file_to_output->from);
#line 1834
  free((void *)file_to_output->to);
  }
#line 1835
  return;
}
}
#line 1837 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void init_files_to_output(void) 
{ 


  {
  {
#line 1840
  files_to_output = gl_list_create_empty_inline(& gl_linked_list_implementation, (_Bool (*)(void const   *elt1 ,
                                                                                            void const   *elt2 ))((void *)0),
                                                (size_t (*)(void const   *elt ))((void *)0),
                                                & dispose_file_to_output, (_Bool)1);
  }
#line 1842
  return;
}
}
#line 1844 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void gl_list_clear(gl_list_t list ) 
{ 
  size_t tmp ;

  {
  {
#line 1847
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1847
    tmp = gl_list_size_inline(list);
    }
#line 1847
    if (! (tmp > 0UL)) {
#line 1847
      goto while_break;
    }
    {
#line 1848
    gl_list_remove_at_inline(list, (size_t )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1849
  return;
}
}
#line 1851 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void output_files(struct stat  const  *st ) 
{ 
  gl_list_iterator_t iter ;
  void const   *elt ;
  struct file_to_output  const  *file_to_output ;
  int from_needs_removal ;
  struct stat  const  *from_st ;
  void const   *elt2 ;
  void const   *tmp ;
  _Bool tmp___0 ;
  void *__cil_tmp10 ;

  {
  {
#line 1857
  iter = gl_list_iterator_inline(files_to_output);
  }
  {
#line 1858
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1858
    tmp___0 = gl_list_iterator_next_inline(& iter, & elt, (gl_list_node_t *)((void *)0));
    }
#line 1858
    if (! tmp___0) {
#line 1858
      goto while_break;
    }
    {
#line 1860
    file_to_output = (struct file_to_output  const  *)elt;
#line 1861
    from_needs_removal = 1;
#line 1862
    from_st = & file_to_output->from_st;
#line 1864
    output_file_now((char const   *)file_to_output->from, & from_needs_removal, from_st,
                    (char const   *)file_to_output->to, (mode_t )file_to_output->mode,
                    (_Bool )file_to_output->backup);
    }
#line 1867
    if (from_needs_removal) {
      {
#line 1868
      unlink((char const   *)file_to_output->from);
      }
    }
#line 1870
    if (st) {
#line 1870
      if (st->st_dev == from_st->st_dev) {
#line 1870
        if (st->st_ino == from_st->st_ino) {
          {
#line 1873
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 1875
            tmp = gl_list_get_at_inline(files_to_output, (size_t )0);
#line 1875
            elt2 = tmp;
#line 1876
            gl_list_remove_at_inline(files_to_output, (size_t )0);
            }
#line 1877
            if ((unsigned long )elt == (unsigned long )elt2) {
#line 1878
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1880
          gl_list_iterator_free_inline(& iter);
          }
#line 1881
          return;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1884
  gl_list_iterator_free_inline(& iter);
#line 1885
  gl_list_clear(files_to_output);
  }
#line 1886
  return;
}
}
#line 1888 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void forget_output_files(void) 
{ 
  gl_list_iterator_t iter ;
  gl_list_iterator_t tmp ;
  void const   *elt ;
  struct file_to_output  const  *file_to_output ;
  _Bool tmp___0 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 1891
  tmp = gl_list_iterator_inline(files_to_output);
#line 1891
  iter = tmp;
  }
  {
#line 1894
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1894
    tmp___0 = gl_list_iterator_next_inline(& iter, & elt, (gl_list_node_t *)((void *)0));
    }
#line 1894
    if (! tmp___0) {
#line 1894
      goto while_break;
    }
    {
#line 1896
    file_to_output = (struct file_to_output  const  *)elt;
#line 1898
    unlink((char const   *)file_to_output->from);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1900
  gl_list_iterator_free_inline(& iter);
#line 1901
  gl_list_clear(files_to_output);
  }
#line 1902
  return;
}
}
#line 1906
 __attribute__((__noreturn__)) void fatal_exit(int sig ) ;
#line 1906 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
void fatal_exit(int sig ) 
{ 


  {
  {
#line 1909
  cleanup();
  }
#line 1911
  if (sig) {
    {
#line 1912
    exit_with_signal(sig);
    }
  }
  {
#line 1914
  exit(2);
  }
}
}
#line 1917 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void remove_if_needed(char const   *name , int *needs_removal ) 
{ 


  {
#line 1920
  if (*needs_removal) {
    {
#line 1922
    unlink(name);
#line 1923
    *needs_removal = 0;
    }
  }
#line 1925
  return;
}
}
#line 1927 "/home/wslee/gnu_benchmarks/patch-2.7/src/patch.c"
static void cleanup(void) 
{ 


  {
  {
#line 1930
  remove_if_needed(TMPINNAME, & TMPINNAME_needs_removal);
#line 1931
  remove_if_needed(TMPOUTNAME, & TMPOUTNAME_needs_removal);
#line 1932
  remove_if_needed(TMPPATNAME, & TMPPATNAME_needs_removal);
#line 1933
  remove_if_needed(TMPREJNAME, & TMPREJNAME_needs_removal);
#line 1934
  forget_output_files();
  }
#line 1935
  return;
}
}
#line 94 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 20 "./inp.h"
lin input_lines  ;
#line 31 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static char *i_buffer  ;
#line 32 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static char const   **i_ptr  ;
#line 34 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static size_t tibufsize  ;
#line 38 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static int tifd  =    -1;
#line 39 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static char *tibuf[2]  ;
#line 40 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static lin tiline[2]  = {      (lin )-1,      (lin )-1};
#line 41 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static lin lines_per_buf  ;
#line 42 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static size_t tireclen  ;
#line 43 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static size_t last_line_size  ;
#line 45
static _Bool plan_a(char const   *filename ) ;
#line 46
static void plan_b(char const   *filename ) ;
#line 47
static void report_revision(_Bool found_revision ) ;
#line 48
static  __attribute__((__noreturn__)) void too_many_lines(char const   *filename ) ;
#line 52 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
void re_input(void) 
{ 


  {
#line 55
  if (using_plan_a) {
#line 56
    if (i_buffer) {
      {
#line 58
      free((void *)i_buffer);
#line 59
      i_buffer = (char *)0;
#line 60
      free((void *)i_ptr);
      }
    }
  } else {
#line 64
    if (tifd >= 0) {
      {
#line 65
      close(tifd);
      }
    }
#line 66
    tifd = -1;
#line 67
    if (tibuf[0]) {
      {
#line 69
      free((void *)tibuf[0]);
#line 70
      tibuf[0] = (char *)0;
      }
    }
#line 72
    tiline[1] = (lin )-1;
#line 72
    tiline[0] = tiline[1];
#line 73
    tireclen = (size_t )0;
  }
#line 75
  return;
}
}
#line 79 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
void scan_input(char *filename , mode_t file_type ) 
{ 
  _Bool tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 82
  if (! (debug & 16)) {
    {
#line 82
    tmp = plan_a((char const   *)filename);
    }
#line 82
    if (tmp) {
#line 82
      tmp___0 = 1;
    } else {
#line 82
      tmp___0 = 0;
    }
  } else {
#line 82
    tmp___0 = 0;
  }
#line 82
  using_plan_a = (_Bool )tmp___0;
#line 83
  if (! using_plan_a) {
#line 85
    if (! ((file_type & 61440U) == 32768U)) {
#line 87
      if (! ((file_type & 61440U) == 40960U)) {
        {
#line 87
        __assert_fail("((((file_type)) & 0170000) == (0120000))", "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c",
                      87U, "scan_input");
        }
      }
      {
#line 88
      tmp___1 = quotearg((char const   *)filename);
#line 88
      fatal("Can\'t handle %s %s", "symbolic link", tmp___1);
      }
    }
    {
#line 90
    plan_b((char const   *)filename);
    }
  }
#line 92
  return;
}
}
#line 96 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static void report_revision(_Bool found_revision ) 
{ 
  char const   *rev ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 99
  tmp = quotearg((char const   *)revision);
#line 99
  rev = (char const   *)tmp;
  }
#line 101
  if (found_revision) {
#line 103
    if ((unsigned int )verbosity == 2U) {
      {
#line 104
      say("Good.  This file appears to be the %s version.\n", rev);
      }
    }
  } else
#line 106
  if (force) {
#line 108
    if ((unsigned int )verbosity != 1U) {
      {
#line 109
      say("Warning: this file doesn\'t appear to be the %s version -- patching anyway.\n",
          rev);
      }
    }
  } else
#line 112
  if (batch) {
    {
#line 113
    fatal("This file doesn\'t appear to be the %s version -- aborting.", rev);
    }
  } else {
    {
#line 117
    ask("This file doesn\'t appear to be the %s version -- patch anyway? [n] ", rev);
    }
#line 119
    if ((int )*buf != 121) {
      {
#line 120
      fatal("aborted");
      }
    }
  }
#line 122
  return;
}
}
#line 125
static  __attribute__((__noreturn__)) void too_many_lines(char const   *filename ) ;
#line 125 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static void too_many_lines(char const   *filename ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 128
  tmp = quotearg(filename);
#line 128
  fatal("File %s has too many lines", tmp);
  }
}
}
#line 132 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
_Bool get_input_file(char const   *filename , char const   *outname , mode_t mode ) 
{ 
  _Bool elsewhere ;
  int tmp ;
  char const   *cs ;
  char *diffbuf ;
  char *getbuf ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  __uid_t tmp___8 ;
  struct stat *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 135
  tmp = strcmp(filename, outname);
#line 135
  elsewhere = (_Bool )(tmp != 0);
  }
#line 140
  if (inerrno == -1) {
    {
#line 141
    tmp___2 = lstat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& instat));
    }
#line 141
    if (tmp___2 == 0) {
#line 141
      inerrno = 0;
    } else {
      {
#line 141
      tmp___1 = __errno_location();
#line 141
      inerrno = *tmp___1;
      }
    }
  }
#line 144
  if ((mode & 61440U) == 32768U) {
#line 144
    if (patch_get) {
#line 144
      if (invc != 0) {
#line 144
        if (inerrno) {
#line 144
          goto _L___0;
        } else
#line 144
        if (! elsewhere) {
#line 144
          if ((instat.st_mode & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) == 0U) {
#line 144
            goto _L___0;
          } else
#line 144
          if ((instat.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) == 0U) {
            {
#line 144
            tmp___8 = geteuid();
            }
#line 144
            if (instat.st_uid != tmp___8) {
              _L___0: /* CIL Label */ 
#line 144
              if (inerrno) {
#line 144
                tmp___9 = (struct stat *)0;
              } else {
#line 144
                tmp___9 = & instat;
              }
              {
#line 144
              cs = version_controller(filename, elsewhere, (struct stat  const  *)tmp___9,
                                      & getbuf, & diffbuf);
              }
#line 144
              if (cs) {
#line 144
                tmp___10 = 1;
              } else {
#line 144
                tmp___10 = 0;
              }
#line 144
              invc = tmp___10;
#line 144
              if (invc) {
#line 159
                if (! inerrno) {
#line 160
                  if (! elsewhere) {
#line 160
                    if ((instat.st_mode & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) != 0U) {
                      {
#line 163
                      tmp___3 = quotearg(filename);
#line 163
                      fatal("File %s seems to be locked by somebody else under %s",
                            tmp___3, cs);
                      }
                    }
                  }
#line 165
                  if (diffbuf) {
#line 170
                    if ((unsigned int )verbosity == 2U) {
                      {
#line 171
                      tmp___4 = quotearg(filename);
#line 171
                      say("Comparing file %s to default %s version...\n", tmp___4,
                          cs);
                      }
                    }
                    {
#line 174
                    tmp___6 = systemic((char const   *)diffbuf);
                    }
#line 174
                    if (tmp___6 != 0) {
                      {
#line 176
                      tmp___5 = quotearg(filename);
#line 176
                      say("warning: Patching file %s, which does not match default %s version\n",
                          tmp___5, cs);
#line 178
                      cs = (char const   *)0;
                      }
                    }
                  }
#line 181
                  if (dry_run) {
#line 182
                    cs = (char const   *)0;
                  }
                }
#line 185
                if (cs) {
                  {
#line 185
                  tmp___7 = version_get(filename, cs, (_Bool )(! inerrno), elsewhere,
                                        (char const   *)getbuf, & instat);
                  }
#line 185
                  if (tmp___7) {
#line 187
                    inerrno = 0;
                  }
                }
                {
#line 189
                free((void *)getbuf);
#line 190
                free((void *)diffbuf);
                }
              }
            }
          }
        }
      }
    }
  }
#line 193
  if (inerrno) {
#line 195
    instat.st_mode = (__mode_t )((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 196
    instat.st_size = (__off_t )0;
  } else
#line 198
  if ((mode & 61440U) == 32768U) {
#line 198
    goto _L___2;
  } else
#line 198
  if ((mode & 61440U) == 40960U) {
    _L___2: /* CIL Label */ 
#line 198
    if (! ((mode & 61440U) == (instat.st_mode & 61440U))) {
#line 198
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 201
    if ((mode & 61440U) == 40960U) {
#line 201
      tmp___11 = "symbolic link";
    } else {
#line 201
      tmp___11 = "regular file";
    }
    {
#line 201
    tmp___12 = quotearg(filename);
#line 201
    say("File %s is not a %s -- can\'t patch\n", tmp___12, tmp___11);
    }
#line 204
    return ((_Bool)0);
  }
#line 206
  return ((_Bool)1);
}
}
#line 212 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static _Bool plan_a(char const   *filename ) 
{ 
  char const   *s ;
  char const   *lim ;
  char const   **ptr ;
  char *buffer ;
  lin iline ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;
  int ifd ;
  int tmp___1 ;
  size_t buffered ;
  size_t n ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  ssize_t n___0 ;
  char *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  char const   *rev ;
  int rev0 ;
  _Bool found_revision ;
  size_t revlen ;
  size_t tmp___9 ;
  char const   *limrev ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  void *tmp___13 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 220
  size = (size_t )instat.st_size;
#line 224
  if (size == (size_t )instat.st_size) {
#line 224
    if (size) {
#line 224
      tmp = size;
    } else {
#line 224
      tmp = (size_t )1;
    }
    {
#line 224
    tmp___0 = malloc(tmp);
#line 224
    buffer = (char *)tmp___0;
    }
#line 224
    if (! buffer) {
#line 226
      return ((_Bool)0);
    }
  } else {
#line 226
    return ((_Bool)0);
  }
#line 230
  if (size) {
#line 232
    if ((instat.st_mode & 61440U) == 32768U) {
      {
#line 234
      tmp___1 = open(filename, 0);
#line 234
      ifd = tmp___1;
#line 235
      buffered = (size_t )0;
      }
#line 236
      if (ifd < 0) {
        {
#line 237
        tmp___2 = quotearg(filename);
#line 237
        pfatal("can\'t open file %s", tmp___2);
        }
      }
      {
#line 239
      while (1) {
        while_continue: /* CIL Label */ ;
#line 239
        if (! (size - buffered != 0UL)) {
#line 239
          goto while_break;
        }
        {
#line 241
        tmp___3 = read(ifd, (void *)(buffer + buffered), size - buffered);
#line 241
        n = (size_t )tmp___3;
        }
#line 242
        if (n == 0UL) {
#line 246
          size = buffered;
#line 247
          goto while_break;
        }
#line 249
        if (n == 0xffffffffffffffffUL) {
          {
#line 252
          close(ifd);
#line 253
          free((void *)buffer);
          }
#line 254
          return ((_Bool)0);
        }
#line 256
        buffered += n;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 259
      tmp___4 = close(ifd);
      }
#line 259
      if (tmp___4 != 0) {
        {
#line 260
        read_fatal();
        }
      }
    } else
#line 262
    if ((instat.st_mode & 61440U) == 40960U) {
      {
#line 265
      n___0 = readlink((char const   */* __restrict  */)filename, (char */* __restrict  */)buffer,
                       size);
      }
#line 266
      if (n___0 < 0L) {
        {
#line 267
        tmp___5 = quotearg(filename);
#line 267
        pfatal("can\'t read %s %s", "symbolic link", tmp___5);
        }
      }
#line 268
      size = (size_t )n___0;
    } else {
      {
#line 272
      free((void *)buffer);
      }
#line 273
      return ((_Bool)0);
    }
  }
#line 278
  lim = (char const   *)(buffer + size);
#line 279
  iline = (lin )3;
#line 280
  s = (char const   *)buffer;
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 280
    tmp___6 = memchr((void const   *)s, '\n', (size_t )(lim - s));
#line 280
    s = (char const   *)((char *)tmp___6);
    }
#line 280
    if (! s) {
#line 280
      goto while_break___0;
    }
#line 281
    iline ++;
#line 281
    if (iline < 0L) {
      {
#line 282
      too_many_lines(filename);
      }
    }
#line 280
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 283
  if ((size_t )iline == (size_t )iline) {
#line 283
    if (((size_t )iline * sizeof(*ptr)) / sizeof(*ptr) == (size_t )iline) {
      {
#line 283
      tmp___7 = malloc((size_t )iline * sizeof(*ptr));
#line 283
      ptr = (char const   **)tmp___7;
      }
#line 283
      if (! ptr) {
        {
#line 287
        free((void *)buffer);
        }
#line 288
        return ((_Bool)0);
      }
    } else {
      {
#line 287
      free((void *)buffer);
      }
#line 288
      return ((_Bool)0);
    }
  } else {
    {
#line 287
    free((void *)buffer);
    }
#line 288
    return ((_Bool)0);
  }
#line 290
  iline = (lin )0;
#line 291
  s = (char const   *)buffer;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 293
    iline ++;
#line 293
    *(ptr + iline) = s;
#line 294
    tmp___8 = memchr((void const   *)s, '\n', (size_t )(lim - s));
#line 294
    s = (char const   *)((char *)tmp___8);
    }
#line 294
    if (! s) {
#line 295
      goto while_break___1;
    }
#line 291
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 297
  if (size) {
#line 297
    if ((int const   )*(lim + -1) != 10) {
#line 298
      iline ++;
#line 298
      *(ptr + iline) = lim;
    }
  }
#line 299
  input_lines = iline - 1L;
#line 301
  if (revision) {
    {
#line 303
    rev = (char const   *)revision;
#line 304
    rev0 = (int )*(rev + 0);
#line 305
    found_revision = (_Bool)0;
#line 306
    tmp___9 = strlen(rev);
#line 306
    revlen = tmp___9;
    }
#line 308
    if (revlen <= size) {
#line 310
      limrev = lim - revlen;
#line 312
      s = (char const   *)buffer;
      {
#line 312
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 312
        tmp___13 = memchr((void const   *)s, rev0, (size_t )(limrev - s));
#line 312
        s = (char const   *)((char *)tmp___13);
        }
#line 312
        if (! s) {
#line 312
          goto while_break___2;
        }
        {
#line 313
        tmp___10 = memcmp((void const   *)s, (void const   *)rev, revlen);
        }
#line 313
        if (tmp___10 == 0) {
#line 313
          if ((unsigned long )s == (unsigned long )buffer) {
#line 313
            goto _L;
          } else {
            {
#line 313
            tmp___11 = __ctype_b_loc();
            }
#line 313
            if ((int const   )*(*tmp___11 + (int )((unsigned char )*(s + -1))) & 8192) {
              _L: /* CIL Label */ 
#line 313
              if ((unsigned long )(s + 1) == (unsigned long )limrev) {
#line 317
                found_revision = (_Bool)1;
#line 318
                goto while_break___2;
              } else {
                {
#line 313
                tmp___12 = __ctype_b_loc();
                }
#line 313
                if ((int const   )*(*tmp___12 + (int )((unsigned char )*(s + revlen))) & 8192) {
#line 317
                  found_revision = (_Bool)1;
#line 318
                  goto while_break___2;
                }
              }
            }
          }
        }
#line 312
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 322
    report_revision(found_revision);
    }
  }
#line 326
  i_buffer = buffer;
#line 327
  i_ptr = ptr;
#line 328
  return ((_Bool)1);
}
}
#line 333 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
static void plan_b(char const   *filename ) 
{ 
  FILE *ifp ;
  int c ;
  size_t len ;
  size_t maxlen ;
  _Bool found_revision ;
  size_t i ;
  char const   *rev ;
  size_t revlen ;
  lin line ;
  char *tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  void *tmp___3 ;
  char *p ;
  char const   *p0 ;
  ssize_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  ssize_t tmp___8 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 344
  line = (lin )1;
#line 346
  if (instat.st_size == 0L) {
#line 347
    filename = "/dev/null";
  }
  {
#line 348
  ifp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 348
  if (! ifp) {
    {
#line 349
    tmp = quotearg(filename);
#line 349
    pfatal("Can\'t open file %s", tmp);
    }
  }
#line 350
  if (TMPINNAME_needs_removal) {
    {
#line 353
    tifd = create_file(TMPINNAME, 2, (mode_t )0, (_Bool)1);
    }
  } else {
    {
#line 357
    tifd = make_tempfile(& TMPINNAME, (char )'i', (char const   *)((void *)0), 2,
                         (mode_t )384);
#line 359
    TMPINNAME_needs_removal = 1;
    }
  }
#line 361
  i = (size_t )0;
#line 362
  len = (size_t )0;
#line 363
  maxlen = (size_t )1;
#line 364
  rev = (char const   *)revision;
#line 365
  found_revision = (_Bool )(! rev);
#line 366
  if (rev) {
    {
#line 366
    tmp___0 = strlen(rev);
#line 366
    revlen = tmp___0;
    }
  } else {
#line 366
    revlen = (size_t )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    c = _IO_getc(ifp);
    }
#line 368
    if (! (c != -1)) {
#line 368
      goto while_break;
    }
#line 370
    len ++;
#line 372
    if (c == 10) {
#line 374
      line ++;
#line 374
      if (line < 0L) {
        {
#line 375
        too_many_lines(filename);
        }
      }
#line 376
      if (maxlen < len) {
#line 377
        maxlen = len;
      }
#line 378
      len = (size_t )0;
    }
#line 381
    if (! found_revision) {
#line 383
      if (i == revlen) {
        {
#line 385
        tmp___1 = __ctype_b_loc();
#line 385
        found_revision = (_Bool )(((int const   )*(*tmp___1 + (int )((unsigned char )c)) & 8192) != (int const   )0);
#line 386
        i = (size_t )-1;
        }
      } else
#line 388
      if (i != 0xffffffffffffffffUL) {
#line 389
        if ((int const   )*(rev + i) == (int const   )c) {
#line 389
          i ++;
        } else {
#line 389
          i = (size_t )-1;
        }
      }
#line 391
      if (i == 0xffffffffffffffffUL) {
        {
#line 391
        tmp___2 = __ctype_b_loc();
        }
#line 391
        if ((int const   )*(*tmp___2 + (int )((unsigned char )c)) & 8192) {
#line 392
          i = (size_t )0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  if (revision) {
    {
#line 397
    report_revision(found_revision);
    }
  }
  {
#line 398
  Fseek(ifp, (file_offset )0, 0);
#line 399
  tibufsize = (size_t )8192;
  }
  {
#line 399
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 399
    if (! (tibufsize < maxlen)) {
#line 399
      goto while_break___0;
    }
#line 399
    tibufsize <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 401
  lines_per_buf = (lin )(tibufsize / maxlen);
#line 402
  tireclen = maxlen;
#line 403
  tmp___3 = xmalloc(2UL * tibufsize);
#line 403
  tibuf[0] = (char *)tmp___3;
#line 404
  tibuf[1] = tibuf[0] + tibufsize;
#line 406
  line = (lin )1;
  }
  {
#line 406
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 408
    p = tibuf[0] + maxlen * (size_t )(line % lines_per_buf);
#line 409
    p0 = (char const   *)p;
#line 410
    if (! (line % lines_per_buf)) {
      {
#line 411
      tmp___4 = write(tifd, (void const   *)tibuf[0], tibufsize);
      }
#line 411
      if ((size_t )tmp___4 != tibufsize) {
        {
#line 412
        write_fatal();
        }
      }
    }
    {
#line 413
    c = _IO_getc(ifp);
    }
#line 413
    if (c == -1) {
#line 414
      goto while_break___1;
    }
    {
#line 416
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 418
      tmp___5 = p;
#line 418
      p ++;
#line 418
      *tmp___5 = (char )c;
#line 419
      if (c == 10) {
#line 421
        last_line_size = (size_t )(p - (char *)p0);
#line 422
        goto while_break___2;
      }
      {
#line 425
      c = _IO_getc(ifp);
      }
#line 425
      if (c == -1) {
#line 427
        last_line_size = (size_t )(p - (char *)p0);
#line 428
        line ++;
#line 429
        goto EOF_reached;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 406
    line ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  EOF_reached: 
  {
#line 434
  tmp___6 = ferror(ifp);
  }
#line 434
  if (tmp___6) {
    {
#line 435
    read_fatal();
    }
  } else {
    {
#line 434
    tmp___7 = fclose(ifp);
    }
#line 434
    if (tmp___7 != 0) {
      {
#line 435
      read_fatal();
      }
    }
  }
#line 437
  if (line % lines_per_buf != 0L) {
    {
#line 438
    tmp___8 = write(tifd, (void const   *)tibuf[0], tibufsize);
    }
#line 438
    if ((size_t )tmp___8 != tibufsize) {
      {
#line 439
      write_fatal();
      }
    }
  }
#line 440
  input_lines = line - 1L;
#line 441
  return;
}
}
#line 446 "/home/wslee/gnu_benchmarks/patch-2.7/src/inp.c"
char const   *ifetch(lin line , _Bool whichbuf , size_t *psize ) 
{ 
  char const   *q ;
  char const   *p ;
  lin offline ;
  lin baseline ;
  __off_t tmp ;
  ssize_t tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 452
  if (line < 1L) {
#line 453
    *psize = (size_t )0;
#line 454
    return ("");
  } else
#line 452
  if (line > input_lines) {
#line 453
    *psize = (size_t )0;
#line 454
    return ("");
  }
#line 456
  if (using_plan_a) {
#line 457
    p = *(i_ptr + line);
#line 458
    *psize = (size_t )(*(i_ptr + (line + 1L)) - p);
#line 459
    return (p);
  } else {
#line 461
    offline = line % lines_per_buf;
#line 462
    baseline = line - offline;
#line 464
    if (tiline[0] == baseline) {
#line 465
      whichbuf = (_Bool)0;
    } else
#line 466
    if (tiline[1] == baseline) {
#line 467
      whichbuf = (_Bool)1;
    } else {
      {
#line 469
      tiline[whichbuf] = baseline;
#line 470
      tmp = lseek(tifd, (__off_t )((size_t )(baseline / lines_per_buf) * tibufsize),
                  0);
      }
#line 470
      if (tmp == -1L) {
        {
#line 473
        read_fatal();
        }
      } else {
        {
#line 470
        tmp___0 = read(tifd, (void *)tibuf[whichbuf], tibufsize);
        }
#line 470
        if (tmp___0 < 0L) {
          {
#line 473
          read_fatal();
          }
        }
      }
    }
#line 475
    p = (char const   *)(tibuf[whichbuf] + tireclen * (size_t )offline);
#line 476
    if (line == input_lines) {
#line 477
      *psize = last_line_size;
    } else {
#line 479
      q = p;
      {
#line 479
      while (1) {
        while_continue: /* CIL Label */ ;
#line 479
        tmp___1 = q;
#line 479
        q ++;
#line 479
        if (! ((int const   )*tmp___1 != 10)) {
#line 479
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 481
      *psize = (size_t )(q - p);
    }
#line 483
    return (p);
  }
}
}
