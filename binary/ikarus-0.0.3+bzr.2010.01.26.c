/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_6 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_7 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_8 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_9 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_10 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_11 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_12 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_13 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_14 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_15 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_16 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_17 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_18 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_19 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_6 __annonCompField1 ;
   union __anonunion____missing_field_name_7 __annonCompField2 ;
   union __anonunion____missing_field_name_8 __annonCompField3 ;
   union __anonunion____missing_field_name_9 __annonCompField4 ;
   union __anonunion____missing_field_name_10 __annonCompField5 ;
   union __anonunion____missing_field_name_11 __annonCompField6 ;
   union __anonunion____missing_field_name_12 __annonCompField7 ;
   union __anonunion____missing_field_name_13 __annonCompField8 ;
   union __anonunion____missing_field_name_14 __annonCompField9 ;
   union __anonunion____missing_field_name_15 __annonCompField10 ;
   union __anonunion____missing_field_name_16 __annonCompField11 ;
   union __anonunion____missing_field_name_17 __annonCompField12 ;
   union __anonunion____missing_field_name_18 __annonCompField13 ;
   union __anonunion____missing_field_name_19 __annonCompField14 ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 78 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
typedef unsigned long ikptr;
#line 84 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
struct ikpage {
   ikptr base ;
   struct ikpage *next ;
};
#line 84 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
typedef struct ikpage ikpage;
#line 89 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
struct ikpages {
   ikptr base ;
   int size ;
   struct ikpages *next ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
typedef struct ikpages ikpages;
#line 104 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
struct ik_ptr_page {
   long count ;
   struct ik_ptr_page *next ;
   ikptr ptr[((4096UL - sizeof(long )) - sizeof(struct ik_ptr_page *)) / sizeof(ikptr )] ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
typedef struct ik_ptr_page ik_ptr_page;
#line 110 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
struct callback_locative {
   ikptr data ;
   struct callback_locative *next ;
};
#line 110 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
typedef struct callback_locative callback_locative;
#line 115 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
struct ikpcb {
   ikptr allocation_pointer ;
   ikptr allocation_redline ;
   ikptr frame_pointer ;
   ikptr frame_base ;
   ikptr frame_redline ;
   ikptr next_k ;
   ikptr system_stack ;
   ikptr dirty_vector ;
   ikptr arg_list ;
   ikptr engine_counter ;
   ikptr interrupted ;
   ikptr base_rtd ;
   ikptr collect_key ;
   callback_locative *callbacks ;
   ikptr *root0 ;
   ikptr *root1 ;
   unsigned int *segment_vector ;
   ikptr weak_pairs_ap ;
   ikptr weak_pairs_ep ;
   ikptr heap_base ;
   unsigned long heap_size ;
   ikpages *heap_pages ;
   ikpage *cached_pages ;
   ikpage *uncached_pages ;
   ikptr cached_pages_base ;
   int cached_pages_size ;
   ikptr stack_base ;
   unsigned long stack_size ;
   ikptr symbol_table ;
   ikptr gensym_table ;
   ik_ptr_page *protected_list[5] ;
   unsigned int *dirty_vector_base ;
   unsigned int *segment_vector_base ;
   ikptr memory_base ;
   ikptr memory_end ;
   int collection_id ;
   int allocation_count_minor ;
   int allocation_count_major ;
   struct timeval collect_utime ;
   struct timeval collect_stime ;
   struct timeval collect_rtime ;
   int last_errno ;
};
#line 115 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
typedef struct ikpcb ikpcb;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 140 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef unsigned long mp_limb_t;
#line 144 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef unsigned long mp_bitcnt_t;
#line 149 "/usr/include/x86_64-linux-gnu/gmp.h"
struct __anonstruct___mpz_struct_40 {
   int _mp_alloc ;
   int _mp_size ;
   mp_limb_t *_mp_d ;
};
#line 149 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef struct __anonstruct___mpz_struct_40 __mpz_struct;
#line 165 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef mp_limb_t *mp_ptr;
#line 166 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef mp_limb_t const   *mp_srcptr;
#line 174 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef long mp_size_t;
#line 178 "/usr/include/x86_64-linux-gnu/gmp.h"
struct __anonstruct___mpq_struct_41 {
   __mpz_struct _mp_num ;
   __mpz_struct _mp_den ;
};
#line 178 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef struct __anonstruct___mpq_struct_41 __mpq_struct;
#line 223 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpz_struct const   *mpz_srcptr;
#line 224 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpz_struct *mpz_ptr;
#line 227 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpq_struct const   *mpq_srcptr;
#line 228 "/usr/include/x86_64-linux-gnu/gmp.h"
typedef __mpq_struct *mpq_ptr;
#line 164 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
struct __anonstruct_cont_20 {
   ikptr tag ;
   ikptr top ;
   long size ;
   ikptr next ;
};
#line 164 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
typedef struct __anonstruct_cont_20 cont;
#line 51 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
struct qupages_t {
   ikptr p ;
   ikptr q ;
   struct qupages_t *next ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
typedef struct qupages_t qupages_t;
#line 58 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
struct __anonstruct_meta_t_43 {
   ikptr ap ;
   ikptr aq ;
   ikptr ep ;
   ikptr base ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
typedef struct __anonstruct_meta_t_43 meta_t;
#line 92 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
struct gc_t {
   meta_t meta[6] ;
   qupages_t *queues[6] ;
   ikpcb *pcb ;
   unsigned int *segment_vector ;
   int collect_gen ;
   int collect_gen_tag ;
   ikptr tconc_ap ;
   ikptr tconc_ep ;
   ikptr tconc_base ;
   ikpages *tconc_queue ;
   ik_ptr_page *forward_list ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
typedef struct gc_t gc_t;
#line 75 "/usr/include/x86_64-linux-gnu/ffitarget.h"
enum ffi_abi {
    FFI_FIRST_ABI = 0,
    FFI_SYSV = 1,
    FFI_UNIX64 = 2,
    FFI_LAST_ABI = 3,
    FFI_DEFAULT_ABI = 2
} ;
#line 75 "/usr/include/x86_64-linux-gnu/ffitarget.h"
typedef enum ffi_abi ffi_abi;
#line 112 "/usr/include/x86_64-linux-gnu/ffi.h"
struct _ffi_type {
   size_t size ;
   unsigned short alignment ;
   unsigned short type ;
   struct _ffi_type **elements ;
};
#line 112 "/usr/include/x86_64-linux-gnu/ffi.h"
typedef struct _ffi_type ffi_type;
#line 204
enum __anonenum_ffi_status_21 {
    FFI_OK = 0,
    FFI_BAD_TYPEDEF = 1,
    FFI_BAD_ABI = 2
} ;
#line 204 "/usr/include/x86_64-linux-gnu/ffi.h"
typedef enum __anonenum_ffi_status_21 ffi_status;
#line 212 "/usr/include/x86_64-linux-gnu/ffi.h"
struct __anonstruct_ffi_cif_22 {
   ffi_abi abi ;
   unsigned int nargs ;
   ffi_type **arg_types ;
   ffi_type *rtype ;
   unsigned int bytes ;
   unsigned int flags ;
};
#line 212 "/usr/include/x86_64-linux-gnu/ffi.h"
typedef struct __anonstruct_ffi_cif_22 ffi_cif;
#line 304 "/usr/include/x86_64-linux-gnu/ffi.h"
struct __anonstruct_ffi_closure_24 {
   char tramp[24] ;
   ffi_cif *cif ;
   void (*fun)(ffi_cif * , void * , void ** , void * ) ;
   void *user_data ;
};
#line 304 "/usr/include/x86_64-linux-gnu/ffi.h"
typedef struct __anonstruct_ffi_closure_24  __attribute__((__aligned__(8))) ffi_closure;
#line 527 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
struct Point {
   float x ;
   float y ;
};
#line 532 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
struct Rect {
   struct Point tl ;
   struct Point br ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_7 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_7 fd_set;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
typedef int ikchar;
#line 41 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
struct __anonstruct_fasl_port_43 {
   char *membase ;
   char *memp ;
   char *memq ;
   ikptr code_ap ;
   ikptr code_ep ;
   ikptr *marks ;
   int marks_size ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
typedef struct __anonstruct_fasl_port_43 fasl_port;
#line 24 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
struct errno_info {
   int n ;
   char *s ;
   ikptr c ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
typedef struct errno_info errno_info;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_28 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_28 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_49 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_50 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_51 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_52 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_53 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_54 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_55 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_48 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_49 _kill ;
   struct __anonstruct__timer_50 _timer ;
   struct __anonstruct__rt_51 _rt ;
   struct __anonstruct__sigchld_52 _sigchld ;
   struct __anonstruct__sigfault_53 _sigfault ;
   struct __anonstruct__sigpoll_54 _sigpoll ;
   struct __anonstruct__sigsys_55 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_47 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_48 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_47 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_67 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_67 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h"
typedef struct sigaltstack stack_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 189 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
struct signal_info {
   int n ;
   ikptr c ;
};
#line 189 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
typedef struct signal_info signal_info;
#line 284 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 283 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 287 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
union __anonunion_69 {
   int __in ;
   int __i ;
};
#line 286 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
union __anonunion_70 {
   int __in ;
   int __i ;
};
#line 284 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
union __anonunion_67___0 {
   int __in ;
   int __i ;
};
#line 283 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
union __anonunion_68___0 {
   int __in ;
   int __i ;
};
#line 287 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
union __anonunion_69___0 {
   int __in ;
   int __i ;
};
#line 286 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
union __anonunion_70___0 {
   int __in ;
   int __i ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who ,
                                                                                struct rusage *__usage ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
int total_allocated_pages ;
#line 28
int total_malloced ;
#line 82
void ik_error(ikptr args ) ;
#line 174
ikpcb *ik_collect(unsigned long mem_req , ikpcb *pcb ) ;
#line 177
void *ik_malloc(int size ) ;
#line 178
void ik_free(void *x , int size ) ;
#line 180
ikptr ik_mmap(unsigned long size ) ;
#line 181
ikptr ik_mmap_typed(unsigned long size , unsigned int type , ikpcb *pcb ) ;
#line 182
ikptr ik_mmap_ptr(unsigned long size , int gen , ikpcb *pcb ) ;
#line 183
ikptr ik_mmap_data(unsigned long size , int gen , ikpcb *pcb ) ;
#line 184
ikptr ik_mmap_code(unsigned long size , int gen , ikpcb *pcb ) ;
#line 185
ikptr ik_mmap_mixed(unsigned long size , ikpcb *pcb ) ;
#line 186
void ik_munmap(ikptr mem , unsigned long size ) ;
#line 187
void ik_munmap_from_segment(ikptr base , unsigned long size , ikpcb *pcb ) ;
#line 188
ikpcb *ik_make_pcb(void) ;
#line 189
void ik_delete_pcb(ikpcb *pcb ) ;
#line 193
void ik_relocate_code(ikptr code ) ;
#line 197
void ik_fprint(FILE *fh , ikptr x ) ;
#line 207
ikptr ik_unsafe_alloc(ikpcb *pcb , int size ) ;
#line 208
ikptr ik_safe_alloc(ikpcb *pcb , int size ) ;
#line 210
ikptr u_to_number(unsigned long n , ikpcb *pcb ) ;
#line 211
ikptr ull_to_number(unsigned long long n , ikpcb *pcb ) ;
#line 213
ikptr s_to_number(long n , ikpcb *pcb ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 199
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 334
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 717
extern int system(char const   *__command ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 803
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_errno_to_code(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
int total_allocated_pages  =    0;
#line 47
extern char **environ ;
#line 57 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static void extend_table_maybe(ikptr p , unsigned long size , ikpcb *pcb ) 
{ 
  ikptr q ;
  unsigned long new_lo ;
  unsigned long old_lo ;
  unsigned long hi ;
  unsigned long new_vec_size ;
  unsigned long old_vec_size ;
  ikptr v ;
  ikptr tmp ;
  ikptr s ;
  ikptr tmp___0 ;
  unsigned long lo ;
  unsigned long old_hi ;
  unsigned long new_hi ;
  unsigned long new_vec_size___0 ;
  unsigned long old_vec_size___0 ;
  ikptr v___0 ;
  ikptr tmp___1 ;
  ikptr s___0 ;
  ikptr tmp___2 ;

  {
#line 60
  q = p + size;
#line 61
  if (p < pcb->memory_base) {
    {
#line 62
    new_lo = p >> 22;
#line 63
    old_lo = pcb->memory_base >> 22;
#line 64
    hi = pcb->memory_end >> 22;
#line 65
    new_vec_size = (hi - new_lo) * 4096UL;
#line 66
    old_vec_size = (hi - old_lo) * 4096UL;
#line 67
    tmp = ik_mmap(new_vec_size);
#line 67
    v = tmp;
#line 68
    bzero((void *)((char *)((long )v)), new_vec_size - old_vec_size);
#line 69
    memcpy((void */* __restrict  */)((char *)((long )((v + new_vec_size) - old_vec_size))),
           (void const   */* __restrict  */)((char *)((long )pcb->dirty_vector_base)),
           old_vec_size);
#line 72
    ik_munmap((ikptr )((long )pcb->dirty_vector_base), old_vec_size);
#line 73
    pcb->dirty_vector_base = (unsigned int *)((long )v);
#line 74
    pcb->dirty_vector = v - new_lo * 4096UL;
#line 75
    tmp___0 = ik_mmap(new_vec_size);
#line 75
    s = tmp___0;
#line 76
    bzero((void *)((char *)((long )s)), new_vec_size - old_vec_size);
#line 77
    memcpy((void */* __restrict  */)((char *)((long )((s + new_vec_size) - old_vec_size))),
           (void const   */* __restrict  */)((char *)((long )pcb->segment_vector_base)),
           old_vec_size);
#line 80
    ik_munmap((ikptr )((long )pcb->segment_vector_base), old_vec_size);
#line 81
    pcb->segment_vector_base = (unsigned int *)((long )s);
#line 82
    pcb->segment_vector = (unsigned int *)((long )(s - new_lo * 4096UL));
#line 83
    pcb->memory_base = new_lo * 4194304UL;
    }
  } else
#line 85
  if (q >= pcb->memory_end) {
    {
#line 86
    lo = pcb->memory_base >> 22;
#line 87
    old_hi = pcb->memory_end >> 22;
#line 88
    new_hi = ((q + 4194304UL) - 1UL) >> 22;
#line 89
    new_vec_size___0 = (new_hi - lo) * 4096UL;
#line 90
    old_vec_size___0 = (old_hi - lo) * 4096UL;
#line 91
    tmp___1 = ik_mmap(new_vec_size___0);
#line 91
    v___0 = tmp___1;
#line 92
    memcpy((void */* __restrict  */)((char *)((long )v___0)), (void const   */* __restrict  */)((char *)((long )pcb->dirty_vector_base)),
           old_vec_size___0);
#line 95
    bzero((void *)((char *)((long )(v___0 + old_vec_size___0))), new_vec_size___0 - old_vec_size___0);
#line 96
    ik_munmap((ikptr )((long )pcb->dirty_vector_base), old_vec_size___0);
#line 97
    pcb->dirty_vector_base = (unsigned int *)((long )v___0);
#line 98
    pcb->dirty_vector = v___0 - lo * 4096UL;
#line 99
    tmp___2 = ik_mmap(new_vec_size___0);
#line 99
    s___0 = tmp___2;
#line 100
    memcpy((void */* __restrict  */)((char *)((long )s___0)), (void const   */* __restrict  */)pcb->segment_vector_base,
           old_vec_size___0);
#line 101
    bzero((void *)((char *)((long )(s___0 + old_vec_size___0))), new_vec_size___0 - old_vec_size___0);
#line 102
    ik_munmap((ikptr )((long )pcb->segment_vector_base), old_vec_size___0);
#line 103
    pcb->segment_vector_base = (unsigned int *)((long )s___0);
#line 104
    pcb->segment_vector = (unsigned int *)(s___0 - lo * 4096UL);
#line 105
    pcb->memory_end = new_hi * 4194304UL;
    }
  }
#line 107
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static void set_segment_type(ikptr base , unsigned long size , unsigned int type ,
                             ikpcb *pcb ) 
{ 
  unsigned int *p ;
  unsigned int *q ;

  {
#line 115
  p = pcb->segment_vector + (base >> 12);
#line 116
  q = p + (size >> 12);
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )p < (unsigned long )q)) {
#line 117
      goto while_break;
    }
#line 118
    *p = type;
#line 119
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
void ik_munmap_from_segment(ikptr base , unsigned long size , ikpcb *pcb ) 
{ 
  unsigned int *p ;
  unsigned int *s ;
  unsigned int *q ;
  ikpage *r ;
  ikpage *cache ;
  ikpage *next ;

  {
#line 128
  p = (unsigned int *)((long )pcb->segment_vector) + (base >> 12);
#line 130
  s = (unsigned int *)((long )pcb->dirty_vector) + (base >> 12);
#line 132
  q = p + (size >> 12);
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! ((unsigned long )p < (unsigned long )q)) {
#line 133
      goto while_break;
    }
#line 135
    *p = 0U;
#line 136
    *s = 0U;
#line 137
    p ++;
#line 137
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  r = pcb->uncached_pages;
#line 140
  if (r) {
#line 141
    cache = pcb->cached_pages;
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      r->base = base;
#line 144
      next = r->next;
#line 145
      r->next = cache;
#line 146
      cache = r;
#line 147
      r = next;
#line 148
      base += 4096UL;
#line 149
      size -= 4096UL;
#line 142
      if (r) {
#line 142
        if (! size) {
#line 142
          goto while_break___0;
        }
      } else {
#line 142
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 151
    pcb->cached_pages = cache;
#line 152
    pcb->uncached_pages = r;
  }
#line 154
  if (size) {
    {
#line 155
    ik_munmap(base, size);
    }
  }
#line 157
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_mmap_typed(unsigned long size , unsigned int type , ikpcb *pcb ) 
{ 
  ikptr p ;
  ikpage *s ;

  {
#line 164
  if (size == 4096UL) {
#line 165
    s = pcb->cached_pages;
#line 166
    if (s) {
#line 167
      p = s->base;
#line 168
      pcb->cached_pages = s->next;
#line 169
      s->next = pcb->uncached_pages;
#line 170
      pcb->uncached_pages = s;
    } else {
      {
#line 173
      p = ik_mmap(size);
      }
    }
  } else {
    {
#line 177
    p = ik_mmap(size);
    }
  }
  {
#line 179
  extend_table_maybe(p, size, pcb);
#line 180
  set_segment_type(p, size, type, pcb);
  }
#line 181
  return (p);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_mmap_ptr(unsigned long size , int gen , ikpcb *pcb ) 
{ 
  ikptr tmp ;

  {
  {
#line 186
  tmp = ik_mmap_typed(size, (unsigned int )(70400 | gen), pcb);
  }
#line 186
  return (tmp);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_mmap_data(unsigned long size , int gen , ikpcb *pcb ) 
{ 
  ikptr tmp ;

  {
  {
#line 191
  tmp = ik_mmap_typed(size, (unsigned int )(66560 | gen), pcb);
  }
#line 191
  return (tmp);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_mmap_code(unsigned long size , int gen , ikpcb *pcb ) 
{ 
  ikptr p ;
  ikptr tmp ;

  {
  {
#line 196
  tmp = ik_mmap_typed(size, (unsigned int )(70912 | gen), pcb);
#line 196
  p = tmp;
  }
#line 197
  if (size > 4096UL) {
    {
#line 198
    set_segment_type(p + 4096UL, size - 4096UL, (unsigned int )(66560 | gen), pcb);
    }
  }
#line 200
  return (p);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_mmap_mixed(unsigned long size , ikpcb *pcb ) 
{ 
  ikptr tmp ;

  {
  {
#line 206
  tmp = ik_mmap_typed(size, 256U, pcb);
  }
#line 206
  return (tmp);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_mmap(unsigned long size ) 
{ 
  unsigned long pages ;
  unsigned long mapsize ;
  char *mem ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 214
  pages = ((size + 4096UL) - 1UL) / 4096UL;
#line 215
  total_allocated_pages = (int )((unsigned long )total_allocated_pages + pages);
#line 216
  mapsize = pages * 4096UL;
#line 219
  tmp = mmap((void *)0, mapsize, 7, 34, -1, (__off_t )0);
#line 219
  mem = (char *)tmp;
  }
#line 227
  if ((unsigned long )mem == (unsigned long )((void *)-1)) {
    {
#line 228
    tmp___0 = __errno_location();
#line 228
    tmp___1 = strerror(*tmp___0);
#line 228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mapping (0x%lx bytes) failed: %s\n",
            size, tmp___1);
#line 229
    exit(-1);
    }
  }
  {
#line 234
  memset((void *)mem, -1, mapsize);
  }
#line 239
  return ((ikptr )((long )mem));
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
void ik_munmap(ikptr mem , unsigned long size ) 
{ 
  unsigned long pages ;
  unsigned long mapsize ;
  int err ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 244
  pages = ((size + 4096UL) - 1UL) / 4096UL;
#line 245
  mapsize = pages * 4096UL;
#line 248
  total_allocated_pages = (int )((unsigned long )total_allocated_pages - pages);
#line 250
  tmp = munmap((void *)((char *)mem), mapsize);
#line 250
  err = tmp;
  }
#line 251
  if (err != 0) {
    {
#line 252
    tmp___0 = __errno_location();
#line 252
    tmp___1 = strerror(*tmp___0);
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ik_munmap failed: %s\n",
            tmp___1);
#line 253
    exit(-1);
    }
  }
#line 262
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
int total_malloced  =    0;
#line 266 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
void *ik_malloc(int size ) 
{ 
  void *x ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 268
  tmp = malloc((size_t )size);
#line 268
  x = tmp;
  }
#line 269
  if ((unsigned long )x == (unsigned long )((void *)0)) {
    {
#line 270
    tmp___0 = __errno_location();
#line 270
    tmp___1 = strerror(*tmp___0);
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malloc failed: %s\n",
            tmp___1);
#line 271
    exit(-1);
    }
  }
#line 273
  total_malloced += size;
#line 274
  return (x);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
void ik_free(void *x , int size ) 
{ 


  {
  {
#line 278
  total_malloced -= size;
#line 279
  free(x);
  }
#line 280
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikpcb *ik_make_pcb(void) 
{ 
  ikpcb *pcb ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ikpage *p ;
  ikptr tmp___3 ;
  ikpage *q ;
  ikpage *e ;
  ikptr lo_mem ;
  ikptr hi_mem ;
  unsigned long lo_seg ;
  unsigned long hi_seg ;
  unsigned long vec_size ;
  ikptr dvec ;
  ikptr tmp___4 ;
  ikptr svec ;
  ikptr tmp___5 ;
  ikptr r ;
  int tmp___6 ;
  int tmp___7 ;
  ikptr tmp___8 ;

  {
  {
#line 286
  tmp = ik_malloc((int )sizeof(ikpcb ));
#line 286
  pcb = (ikpcb *)tmp;
#line 287
  bzero((void *)pcb, sizeof(ikpcb ));
#line 288
  pcb->collect_key = (ikptr )47;
  }
#line 291
  if ((int )sizeof(ikptr ) == 4) {
#line 291
    tmp___0 = 1;
  } else {
#line 291
    tmp___0 = 2;
  }
  {
#line 291
  pcb->heap_base = ik_mmap((unsigned long )((1024 * tmp___0) * 4096));
  }
#line 292
  if ((int )sizeof(ikptr ) == 4) {
#line 292
    tmp___1 = 1;
  } else {
#line 292
    tmp___1 = 2;
  }
#line 292
  pcb->heap_size = (unsigned long )((1024 * tmp___1) * 4096);
#line 293
  pcb->allocation_pointer = pcb->heap_base;
#line 294
  if ((int )sizeof(ikptr ) == 4) {
#line 294
    tmp___2 = 1;
  } else {
#line 294
    tmp___2 = 2;
  }
  {
#line 294
  pcb->allocation_redline = (pcb->heap_base + (ikptr )((1024 * tmp___2) * 4096)) - 8192UL;
#line 296
  pcb->stack_base = ik_mmap(4194304UL);
#line 297
  pcb->stack_size = 4194304UL;
#line 298
  pcb->frame_pointer = pcb->stack_base + pcb->stack_size;
#line 299
  pcb->frame_base = pcb->frame_pointer;
#line 300
  pcb->frame_redline = pcb->stack_base + 8192UL;
#line 304
  tmp___3 = ik_mmap(4096UL * sizeof(ikpage ));
#line 304
  p = (ikpage *)((long )tmp___3);
#line 305
  pcb->cached_pages_base = (ikptr )((long )p);
#line 306
  pcb->cached_pages_size = (int )(4096UL * sizeof(ikpage ));
#line 307
  q = (ikpage *)0;
#line 308
  e = p + 4096;
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! ((unsigned long )p < (unsigned long )e)) {
#line 309
      goto while_break;
    }
#line 310
    p->next = q;
#line 311
    q = p;
#line 312
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  pcb->uncached_pages = q;
#line 321
  if (pcb->heap_base < pcb->stack_base) {
#line 322
    lo_mem = pcb->heap_base - 4096UL;
#line 323
    hi_mem = (pcb->stack_base + pcb->stack_size) + 4096UL;
  } else {
#line 325
    lo_mem = pcb->stack_base - 4096UL;
#line 326
    hi_mem = (pcb->heap_base + pcb->heap_size) + 4096UL;
  }
  {
#line 329
  lo_seg = lo_mem >> 22;
#line 330
  hi_seg = ((hi_mem + 4194304UL) - 1UL) >> 22;
#line 331
  vec_size = (hi_seg - lo_seg) * 4096UL;
#line 332
  tmp___4 = ik_mmap(vec_size);
#line 332
  dvec = tmp___4;
#line 333
  bzero((void *)((char *)((long )dvec)), vec_size);
#line 334
  pcb->dirty_vector_base = (unsigned int *)((long )dvec);
#line 335
  pcb->dirty_vector = dvec - lo_seg * 4096UL;
#line 336
  tmp___5 = ik_mmap(vec_size);
#line 336
  svec = tmp___5;
#line 337
  bzero((void *)((char *)((long )svec)), vec_size);
#line 338
  pcb->segment_vector_base = (unsigned int *)((long )svec);
#line 339
  pcb->segment_vector = (unsigned int *)((long )(svec - lo_seg * 4096UL));
#line 340
  pcb->memory_base = lo_seg * 4194304UL;
#line 341
  pcb->memory_end = hi_seg * 4194304UL;
#line 342
  set_segment_type(pcb->heap_base, pcb->heap_size, 256U, pcb);
#line 346
  set_segment_type(pcb->stack_base, pcb->stack_size, 512U, pcb);
  }
#line 353
  if ((int )sizeof(ikptr ) == 4) {
#line 353
    tmp___6 = 2;
  } else {
#line 353
    tmp___6 = 3;
  }
#line 353
  if ((int )sizeof(ikptr ) == 4) {
#line 353
    tmp___7 = 2;
  } else {
#line 353
    tmp___7 = 3;
  }
  {
#line 353
  tmp___8 = ik_unsafe_alloc(pcb, (((6 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___6 + 1)) << (tmp___7 + 1));
#line 353
  r = tmp___8 + 5UL;
#line 354
  *((ikptr *)((long )r + -5L) + 0) = r;
#line 355
  *((ikptr *)((long )r + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )(6 * (int )sizeof(ikptr ) - (int )sizeof(ikptr ));
#line 356
  *((ikptr *)((long )r + (long )((int )sizeof(ikptr ) - 5)) + 0) = (ikptr )0;
#line 357
  *((ikptr *)((long )r + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )0;
#line 358
  *((ikptr *)((long )r + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )0;
#line 359
  *((ikptr *)((long )r + (long )(5 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )0;
#line 360
  pcb->base_rtd = r;
  }
#line 362
  return (pcb);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
void ik_delete_pcb(ikpcb *pcb ) 
{ 
  ikpage *p ;
  int i ;
  ik_ptr_page *p___0 ;
  ik_ptr_page *next ;
  ikptr base ;
  ikptr end ;
  unsigned int *segment_vec ;
  long i___0 ;
  long j ;
  unsigned int t ;
  long vecsize ;

  {
#line 366
  p = pcb->cached_pages;
#line 367
  pcb->cached_pages = (ikpage *)0;
#line 368
  pcb->uncached_pages = (ikpage *)0;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! p) {
#line 369
      goto while_break;
    }
    {
#line 370
    ik_munmap(p->base, 4096UL);
#line 371
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 373
  ik_munmap(pcb->cached_pages_base, (unsigned long )pcb->cached_pages_size);
#line 376
  i = 0;
  }
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    if (! (i < 5)) {
#line 376
      goto while_break___0;
    }
#line 377
    p___0 = pcb->protected_list[i];
    {
#line 378
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 378
      if (! p___0) {
#line 378
        goto while_break___1;
      }
      {
#line 379
      next = p___0->next;
#line 380
      ik_munmap((ikptr )((long )p___0), 4096UL);
#line 381
      p___0 = next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 376
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 385
  base = pcb->memory_base;
#line 386
  end = pcb->memory_end;
#line 387
  segment_vec = pcb->segment_vector;
#line 388
  i___0 = (long )(base >> 12);
#line 389
  j = (long )(end >> 12);
  {
#line 390
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 390
    if (! (i___0 < j)) {
#line 390
      goto while_break___2;
    }
#line 391
    t = *(segment_vec + i___0);
#line 392
    if (t != 0U) {
      {
#line 393
      ik_munmap((ikptr )(i___0 << 12), 4096UL);
      }
    }
#line 395
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 397
  vecsize = (long )(((end >> 22) - (base >> 22)) * 4096UL);
#line 398
  ik_munmap((ikptr )((long )pcb->dirty_vector_base), (unsigned long )vecsize);
#line 399
  ik_munmap((ikptr )((long )pcb->segment_vector_base), (unsigned long )vecsize);
#line 400
  ik_free((void *)pcb, (int )sizeof(ikpcb ));
  }
#line 401
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_safe_alloc(ikpcb *pcb , int size ) 
{ 
  ikptr ap ;
  ikptr ep ;
  ikptr nap ;
  ikptr ap___0 ;
  ikptr ep___0 ;
  ikptr nap___0 ;

  {
#line 406
  ap = pcb->allocation_pointer;
#line 407
  ep = pcb->heap_base + pcb->heap_size;
#line 408
  nap = ap + (ikptr )size;
#line 409
  if (nap < ep) {
#line 410
    pcb->allocation_pointer = nap;
#line 411
    return (ap);
  } else {
    {
#line 414
    ik_collect((unsigned long )size, pcb);
#line 415
    ap___0 = pcb->allocation_pointer;
#line 416
    ep___0 = pcb->heap_base + pcb->heap_size;
#line 417
    nap___0 = ap___0 + (ikptr )size;
    }
#line 418
    if (nap___0 < ep___0) {
#line 419
      pcb->allocation_pointer = nap___0;
#line 420
      return (ap___0);
    } else {
      {
#line 422
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ikaurs: BUG: collector did not leave enough room for %d\n",
              size);
#line 425
      exit(-1);
      }
    }
  }
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_unsafe_alloc(ikpcb *pcb , int size ) 
{ 
  ikptr ap ;
  ikptr ep ;
  ikptr nap ;
  ikpages *p ;
  void *tmp ;
  long bytes ;
  long minor ;
  int new_size ;
  int tmp___0 ;

  {
#line 436
  ap = pcb->allocation_pointer;
#line 437
  ep = pcb->heap_base + pcb->heap_size;
#line 438
  nap = ap + (ikptr )size;
#line 439
  if (nap < ep) {
#line 440
    pcb->allocation_pointer = nap;
#line 441
    return (ap);
  } else {
#line 444
    if (ap) {
      {
#line 445
      tmp = ik_malloc((int )sizeof(ikpages ));
#line 445
      p = (ikpages *)tmp;
#line 446
      p->base = pcb->heap_base;
#line 447
      p->size = (int )pcb->heap_size;
#line 448
      p->next = pcb->heap_pages;
#line 449
      pcb->heap_pages = p;
      }
    }
#line 453
    bytes = (long )pcb->allocation_pointer - (long )pcb->heap_base;
#line 456
    minor = bytes + (long )pcb->allocation_count_minor;
    {
#line 457
    while (1) {
      while_continue: /* CIL Label */ ;
#line 457
      if (! (minor >= 268435456L)) {
#line 457
        goto while_break;
      }
#line 458
      minor -= 268435456L;
#line 459
      (pcb->allocation_count_major) ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 461
    pcb->allocation_count_minor = (int )minor;
#line 464
    if (size > 131072) {
#line 464
      tmp___0 = size;
    } else {
#line 464
      tmp___0 = 131072;
    }
    {
#line 464
    new_size = tmp___0;
#line 465
    new_size += 8192;
#line 466
    new_size = (int )(((4095UL + (unsigned long )new_size) >> 12) << 12);
#line 467
    ap = ik_mmap_mixed((unsigned long )new_size, pcb);
#line 468
    pcb->heap_base = ap;
#line 469
    pcb->heap_size = (unsigned long )new_size;
#line 470
    pcb->allocation_redline = (ap + (ikptr )new_size) - 8192UL;
#line 471
    nap = ap + (ikptr )size;
#line 472
    pcb->allocation_pointer = nap;
    }
#line 473
    return (ap);
  }
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
void ik_error(ikptr args ) 
{ 


  {
  {
#line 480
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: ");
#line 481
  ik_fprint(stderr, args);
#line 482
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 483
  exit(0);
  }
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
void ik_stack_overflow(ikpcb *pcb ) 
{ 
  ikptr frame_base ;
  ikptr underflow_handler ;
  ikptr k ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  ikptr tmp___2 ;

  {
  {
#line 491
  set_segment_type(pcb->stack_base, pcb->stack_size, 66560U, pcb);
#line 493
  frame_base = pcb->frame_base;
#line 494
  underflow_handler = *((ikptr *)((long )frame_base + (long )(- ((int )sizeof(ikptr )))) + 0);
  }
#line 499
  if ((int )sizeof(ikptr ) == 4) {
#line 499
    tmp = 2;
  } else {
#line 499
    tmp = 3;
  }
#line 499
  if ((int )sizeof(ikptr ) == 4) {
#line 499
    tmp___0 = 2;
  } else {
#line 499
    tmp___0 = 3;
  }
  {
#line 499
  tmp___1 = ik_unsafe_alloc(pcb, (((4 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp + 1)) << (tmp___0 + 1));
#line 499
  k = tmp___1 + 5UL;
#line 500
  *((ikptr *)((long )k + -5L) + 0) = (ikptr )31;
#line 501
  *((ikptr *)((long )k + (long )((int )sizeof(ikptr ) - 5)) + 0) = pcb->frame_pointer;
#line 502
  *((ikptr *)((long )k + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = (pcb->frame_base - pcb->frame_pointer) - (ikptr )((int )sizeof(ikptr ));
#line 504
  *((ikptr *)((long )k + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = pcb->next_k;
#line 505
  pcb->next_k = k;
#line 507
  tmp___2 = ik_mmap_typed(4194304UL, 512U, pcb);
#line 507
  pcb->stack_base = (ikptr )((long )tmp___2);
#line 508
  pcb->stack_size = 4194304UL;
#line 509
  pcb->frame_base = pcb->stack_base + pcb->stack_size;
#line 510
  pcb->frame_pointer = pcb->frame_base - (ikptr )((int )sizeof(ikptr ));
#line 511
  pcb->frame_redline = pcb->stack_base + 8192UL;
#line 512
  *((ikptr *)((long )pcb->frame_pointer) + 0) = underflow_handler;
  }
#line 513
  return;
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static char const   *uuid_chars  =    "!$%&/0123456789<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
#line 530 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static int uuid_strlen  =    1;
#line 532
ikptr ik_uuid(ikptr bv ) ;
#line 532 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static int fd  =    -1;
#line 531 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_uuid(ikptr bv ) 
{ 
  ikptr tmp ;
  size_t tmp___0 ;
  long n ;
  int tmp___1 ;
  unsigned char *data ;
  int r ;
  ssize_t tmp___2 ;
  ikptr tmp___3 ;
  unsigned char *p ;
  unsigned char *q ;

  {
#line 533
  if (fd == -1) {
    {
#line 534
    fd = open("/dev/urandom", 0);
    }
#line 535
    if (fd == -1) {
      {
#line 536
      tmp = ik_errno_to_code();
      }
#line 536
      return (tmp);
    }
    {
#line 538
    tmp___0 = strlen(uuid_chars);
#line 538
    uuid_strlen = (int )tmp___0;
    }
  }
#line 540
  if ((int )sizeof(ikptr ) == 4) {
#line 540
    tmp___1 = 2;
  } else {
#line 540
    tmp___1 = 3;
  }
  {
#line 540
  n = (long )*((ikptr *)((long )bv + -2L) + 0) >> tmp___1;
#line 541
  data = (unsigned char *)((long )(bv + 6UL));
#line 542
  tmp___2 = read(fd, (void *)data, (size_t )n);
#line 542
  r = (int )tmp___2;
  }
#line 543
  if (r < 0) {
    {
#line 544
    tmp___3 = ik_errno_to_code();
    }
#line 544
    return (tmp___3);
  }
#line 546
  p = data;
#line 547
  q = data + n;
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    if (! ((unsigned long )p < (unsigned long )q)) {
#line 548
      goto while_break;
    }
#line 549
    *p = (unsigned char )*(uuid_chars + (int )*p % uuid_strlen);
#line 550
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  return (bv);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_stat(ikptr filename , ikptr follow ) 
{ 
  char *fn ;
  struct stat s ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;

  {
#line 558
  fn = (char *)(filename + 6UL);
#line 561
  if (follow == 47UL) {
    {
#line 562
    r = lstat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& s));
    }
  } else {
    {
#line 564
    r = stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& s));
    }
  }
#line 566
  if (r == 0) {
#line 567
    if ((s.st_mode & 61440U) == 32768U) {
#line 568
      if ((int )sizeof(ikptr ) == 4) {
#line 568
        tmp = 2;
      } else {
#line 568
        tmp = 3;
      }
#line 568
      return ((ikptr )(1L << tmp));
    } else
#line 570
    if ((s.st_mode & 61440U) == 16384U) {
#line 571
      if ((int )sizeof(ikptr ) == 4) {
#line 571
        tmp___0 = 2;
      } else {
#line 571
        tmp___0 = 3;
      }
#line 571
      return ((ikptr )(2L << tmp___0));
    } else
#line 573
    if ((s.st_mode & 61440U) == 40960U) {
#line 574
      if ((int )sizeof(ikptr ) == 4) {
#line 574
        tmp___1 = 2;
      } else {
#line 574
        tmp___1 = 3;
      }
#line 574
      return ((ikptr )(3L << tmp___1));
    } else {
#line 577
      if ((int )sizeof(ikptr ) == 4) {
#line 577
        tmp___2 = 2;
      } else {
#line 577
        tmp___2 = 3;
      }
#line 577
      return ((ikptr )0L);
    }
  }
  {
#line 580
  tmp___3 = ik_errno_to_code();
  }
#line 580
  return (tmp___3);
}
}
#line 586 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_file_exists(ikptr filename ) 
{ 
  ikptr tmp ;

  {
  {
#line 588
  tmp = ikrt_stat(filename, (ikptr )63);
  }
  {
#line 592
  if (tmp == (ikptr )(3L << 3)) {
#line 592
    goto case_exp;
  }
#line 592
  if (tmp == (ikptr )(2L << 3)) {
#line 592
    goto case_exp;
  }
#line 592
  if (tmp == (ikptr )(1L << 3)) {
#line 592
    goto case_exp;
  }
#line 592
  if (tmp == 0UL) {
#line 592
    goto case_exp;
  }
#line 594
  goto switch_default;
  case_exp: /* CIL Label */ 
  case_exp___0: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 593
  return ((ikptr )63);
  switch_default: /* CIL Label */ 
#line 595
  return ((ikptr )47);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_delete_file(ikptr filename ) 
{ 
  char *str ;
  int err ;
  int tmp ;
  ikptr tmp___0 ;

  {
#line 602
  if (((int )filename & 7) == 2) {
#line 603
    str = (char *)((long )(filename + 6UL));
  } else {
    {
#line 605
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bug in ikrt_delete_file\n");
#line 606
    exit(-1);
    }
  }
  {
#line 608
  tmp = unlink((char const   *)str);
#line 608
  err = tmp;
  }
#line 609
  if (err == 0) {
#line 610
    return ((ikptr )63);
  }
  {
#line 612
  tmp___0 = ik_errno_to_code();
  }
#line 612
  return (tmp___0);
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_directory_list(ikptr filename , ikpcb *pcb ) 
{ 
  DIR *dir ;
  struct dirent *de ;
  ikptr tmp ;
  ikptr ac ;
  int *tmp___0 ;
  ikptr retval ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;
  int *tmp___4 ;
  int len ;
  size_t tmp___5 ;
  ikptr bv ;
  int tmp___6 ;
  int tmp___7 ;
  ikptr tmp___8 ;
  int tmp___9 ;
  ikptr p ;
  ikptr tmp___10 ;

  {
  {
#line 619
  dir = opendir((char const   *)((char *)(filename + 6UL)));
  }
#line 619
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 620
    tmp = ik_errno_to_code();
    }
#line 620
    return (tmp);
  }
#line 622
  ac = (ikptr )79;
#line 623
  pcb->root0 = & ac;
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 625
    tmp___0 = __errno_location();
#line 625
    *tmp___0 = 0;
#line 626
    de = readdir(dir);
    }
#line 627
    if ((unsigned long )de == (unsigned long )((void *)0)) {
      {
#line 628
      pcb->root0 = (ikptr *)0;
#line 629
      tmp___4 = __errno_location();
      }
#line 629
      if (*tmp___4) {
        {
#line 629
        tmp___2 = ik_errno_to_code();
#line 629
        tmp___3 = tmp___2;
        }
      } else {
#line 629
        tmp___3 = ac;
      }
      {
#line 629
      retval = tmp___3;
#line 630
      closedir(dir);
      }
#line 631
      return (retval);
    }
    {
#line 633
    tmp___5 = strlen((char const   *)(de->d_name));
#line 633
    len = (int )tmp___5;
    }
#line 634
    if ((int )sizeof(ikptr ) == 4) {
#line 634
      tmp___6 = 2;
    } else {
#line 634
      tmp___6 = 3;
    }
#line 634
    if ((int )sizeof(ikptr ) == 4) {
#line 634
      tmp___7 = 2;
    } else {
#line 634
      tmp___7 = 3;
    }
    {
#line 634
    tmp___8 = ik_safe_alloc(pcb, (((((8 + len) + 1) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___6 + 1)) << (tmp___7 + 1));
#line 634
    bv = tmp___8 + 2UL;
    }
#line 636
    if ((int )sizeof(ikptr ) == 4) {
#line 636
      tmp___9 = 2;
    } else {
#line 636
      tmp___9 = 3;
    }
    {
#line 636
    *((ikptr *)((long )bv + -2L) + 0) = (ikptr )((long )len << tmp___9);
#line 637
    memcpy((void */* __restrict  */)((char *)(bv + 6UL)), (void const   */* __restrict  */)(de->d_name),
           (size_t )(len + 1));
#line 638
    pcb->root1 = & bv;
#line 639
    tmp___10 = ik_safe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 639
    p = tmp___10 + 1UL;
#line 640
    pcb->root1 = (ikptr *)0;
#line 641
    *((ikptr *)((long )p + -1L) + 0) = bv;
#line 642
    *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0) = ac;
#line 643
    ac = p;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_mkdir(ikptr path , ikptr mode ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
#line 649
  if ((int )sizeof(ikptr ) == 4) {
#line 649
    tmp = 2;
  } else {
#line 649
    tmp = 3;
  }
  {
#line 649
  tmp___0 = mkdir((char const   *)((char *)(path + 6UL)), (__mode_t )((long )mode >> tmp));
#line 649
  r = tmp___0;
  }
#line 650
  if (r == 0) {
#line 651
    return ((ikptr )63);
  }
  {
#line 653
  tmp___1 = ik_errno_to_code();
  }
#line 653
  return (tmp___1);
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_rmdir(ikptr path ) 
{ 
  int r ;
  int tmp ;
  ikptr tmp___0 ;

  {
  {
#line 658
  tmp = rmdir((char const   *)((char *)(path + 6UL)));
#line 658
  r = tmp;
  }
#line 659
  if (r == 0) {
#line 660
    return ((ikptr )63);
  }
  {
#line 662
  tmp___0 = ik_errno_to_code();
  }
#line 662
  return (tmp___0);
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_chmod(ikptr path , ikptr mode ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
#line 667
  if ((int )sizeof(ikptr ) == 4) {
#line 667
    tmp = 2;
  } else {
#line 667
    tmp = 3;
  }
  {
#line 667
  tmp___0 = chmod((char const   *)((char *)(path + 6UL)), (mode_t )((long )mode >> tmp));
#line 667
  r = tmp___0;
  }
#line 668
  if (r == 0) {
#line 669
    return ((ikptr )63);
  }
  {
#line 671
  tmp___1 = ik_errno_to_code();
  }
#line 671
  return (tmp___1);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_symlink(ikptr to , ikptr path ) 
{ 
  int r ;
  int tmp ;
  ikptr tmp___0 ;

  {
  {
#line 676
  tmp = symlink((char const   *)((char *)(to + 6UL)), (char const   *)((char *)(path + 6UL)));
#line 676
  r = tmp;
  }
#line 677
  if (r == 0) {
#line 678
    return ((ikptr )63);
  }
  {
#line 680
  tmp___0 = ik_errno_to_code();
  }
#line 680
  return (tmp___0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_link(ikptr to , ikptr path ) 
{ 
  int r ;
  int tmp ;
  ikptr tmp___0 ;

  {
  {
#line 685
  tmp = link((char const   *)((char *)(to + 6UL)), (char const   *)((char *)(path + 6UL)));
#line 685
  r = tmp;
  }
#line 686
  if (r == 0) {
#line 687
    return ((ikptr )63);
  }
  {
#line 689
  tmp___0 = ik_errno_to_code();
  }
#line 689
  return (tmp___0);
}
}
#line 692 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_realpath(ikptr bv , ikpcb *pcb ) 
{ 
  char buff[4096] ;
  char *p ;
  char *tmp ;
  ikptr tmp___0 ;
  int n ;
  size_t tmp___1 ;
  ikptr r ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  int tmp___5 ;

  {
  {
#line 695
  tmp = realpath((char const   */* __restrict  */)((char *)(bv + 6UL)), (char */* __restrict  */)(buff));
#line 695
  p = tmp;
  }
#line 696
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 697
    tmp___0 = ik_errno_to_code();
    }
#line 697
    return (tmp___0);
  }
  {
#line 699
  tmp___1 = strlen((char const   *)p);
#line 699
  n = (int )tmp___1;
  }
#line 700
  if ((int )sizeof(ikptr ) == 4) {
#line 700
    tmp___2 = 2;
  } else {
#line 700
    tmp___2 = 3;
  }
#line 700
  if ((int )sizeof(ikptr ) == 4) {
#line 700
    tmp___3 = 2;
  } else {
#line 700
    tmp___3 = 3;
  }
  {
#line 700
  tmp___4 = ik_safe_alloc(pcb, (((((8 + n) + 1) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___2 + 1)) << (tmp___3 + 1));
#line 700
  r = tmp___4;
  }
#line 701
  if ((int )sizeof(ikptr ) == 4) {
#line 701
    tmp___5 = 2;
  } else {
#line 701
    tmp___5 = 3;
  }
  {
#line 701
  *((ikptr *)((long )r) + 0) = (ikptr )((long )n << tmp___5);
#line 702
  memcpy((void */* __restrict  */)((char *)(r + 8UL)), (void const   */* __restrict  */)p,
         (size_t )(n + 1));
  }
#line 703
  return (r + 2UL);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_system(ikptr str ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
#line 708
  if (((int )str & 7) == 2) {
    {
#line 709
    tmp = system((char const   *)((char *)((long )(str + 6UL))));
#line 709
    r = tmp;
    }
#line 710
    if (r >= 0) {
#line 711
      if ((int )sizeof(ikptr ) == 4) {
#line 711
        tmp___0 = 2;
      } else {
#line 711
        tmp___0 = 3;
      }
#line 711
      return ((ikptr )((long )r << tmp___0));
    } else {
      {
#line 713
      tmp___1 = ik_errno_to_code();
      }
#line 713
      return (tmp___1);
    }
  } else {
    {
#line 716
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bug in ik_system\n");
#line 717
    exit(-1);
    }
  }
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static char *mtname(unsigned int n ) 
{ 


  {
#line 723
  if (n == 256U) {
#line 723
    return ((char *)"HEAP_T");
  }
#line 724
  if (n == 512U) {
#line 724
    return ((char *)"STAK_T");
  }
#line 725
  if (n == 768U) {
#line 725
    return ((char *)"PTER_T");
  }
#line 726
  if (n == 1024U) {
#line 726
    return ((char *)"DATA_T");
  }
#line 727
  if (n == 1280U) {
#line 727
    return ((char *)"CODE_T");
  }
#line 728
  if (n == 0U) {
#line 728
    return ((char *)"      ");
  }
#line 729
  return ((char *)"WHAT_T");
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_dump_metatable(ikpcb *pcb ) 
{ 
  unsigned int *s ;
  ikptr p ;
  ikptr hi ;
  unsigned int t ;
  ikptr start ;
  char *tmp ;

  {
#line 734
  s = pcb->segment_vector_base;
#line 735
  p = pcb->memory_base;
#line 736
  hi = pcb->memory_end;
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    if (! (p < hi)) {
#line 737
      goto while_break;
    }
#line 738
    t = *s & 3840U;
#line 739
    start = p;
#line 740
    p += 4096UL;
#line 741
    s ++;
    {
#line 742
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 742
      if (p < hi) {
#line 742
        if (! ((*s & 3840U) == t)) {
#line 742
          goto while_break___0;
        }
      } else {
#line 742
        goto while_break___0;
      }
#line 743
      p += 4096UL;
#line 744
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 746
    tmp = mtname(t);
#line 746
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"0x%016lx + %5ld pages = %s\n",
            (long )start, ((long )p - (long )start) / 4096L, tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  return ((ikptr )127);
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ik_dump_dirty_vector(ikpcb *pcb ) 
{ 
  unsigned int *s ;
  ikptr p ;
  ikptr hi ;
  unsigned int t ;
  ikptr start ;

  {
#line 756
  s = pcb->dirty_vector_base;
#line 757
  p = pcb->memory_base;
#line 758
  hi = pcb->memory_end;
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 759
    if (! (p < hi)) {
#line 759
      goto while_break;
    }
#line 760
    t = *s;
#line 761
    start = p;
#line 762
    p += 4096UL;
#line 763
    s ++;
    {
#line 764
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 764
      if (p < hi) {
#line 764
        if (! (*s == t)) {
#line 764
          goto while_break___0;
        }
      } else {
#line 764
        goto while_break___0;
      }
#line 765
      p += 4096UL;
#line 766
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 768
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"0x%016lx + %5ld pages = 0x%08x\n",
            (long )start, ((long )p - (long )start) / 4096L, t);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  return ((ikptr )127);
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_make_code(ikptr codesizeptr , ikptr freevars , ikptr rvec , ikpcb *pcb ) 
{ 
  long code_size ;
  int tmp ;
  long memreq ;
  ikptr mem ;
  ikptr tmp___0 ;

  {
#line 779
  if ((int )sizeof(ikptr ) == 4) {
#line 779
    tmp = 2;
  } else {
#line 779
    tmp = 3;
  }
  {
#line 779
  code_size = (long )codesizeptr >> tmp;
#line 780
  memreq = (long )(((4095UL + (unsigned long )(code_size + (long )(6 * (int )sizeof(ikptr )))) >> 12) << 12);
#line 781
  tmp___0 = ik_mmap_code((unsigned long )memreq, 0, pcb);
#line 781
  mem = tmp___0;
#line 782
  bzero((void *)((char *)((long )mem)), (size_t )memreq);
#line 783
  *((ikptr *)((long )mem) + 0) = (ikptr )47;
#line 784
  *((ikptr *)((long )mem + (long )((int )sizeof(ikptr ))) + 0) = codesizeptr;
#line 785
  *((ikptr *)((long )mem + (long )(3 * (int )sizeof(ikptr ))) + 0) = freevars;
#line 786
  *((ikptr *)((long )mem + (long )(2 * (int )sizeof(ikptr ))) + 0) = rvec;
#line 787
  *((ikptr *)((long )mem + (long )(4 * (int )sizeof(ikptr ))) + 0) = (ikptr )47;
#line 788
  ik_relocate_code(mem);
  }
#line 789
  return (mem + 5UL);
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_set_code_reloc_vector(ikptr code , ikptr vec , ikpcb *pcb ) 
{ 


  {
  {
#line 794
  *((ikptr *)((long )code + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = vec;
#line 795
  ik_relocate_code(code - 5UL);
#line 796
  *((unsigned int *)((long )pcb->dirty_vector) + (code >> 12)) = 4294967295U;
  }
#line 797
  return ((ikptr )127);
}
}
#line 800 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_set_code_annotation(ikptr code , ikptr annot , ikpcb *pcb ) 
{ 


  {
#line 802
  *((ikptr *)((long )code + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0) = annot;
#line 803
  *((unsigned int *)((long )pcb->dirty_vector) + (code >> 12)) = 4294967295U;
#line 804
  return ((ikptr )127);
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_bvftime(ikptr outbv , ikptr fmtbv ) 
{ 
  time_t t ;
  struct tm *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int rv ;
  int tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 813
  t = time((time_t *)((void *)0));
#line 814
  tmp = localtime((time_t const   *)(& t));
  }
#line 815
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 816
    tmp___0 = __errno_location();
#line 816
    tmp___1 = strerror(*tmp___0);
#line 816
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in time: %s\n",
            tmp___1);
    }
  }
#line 818
  if ((int )sizeof(ikptr ) == 4) {
#line 818
    tmp___2 = 2;
  } else {
#line 818
    tmp___2 = 3;
  }
  {
#line 818
  tmp___3 = strftime((char */* __restrict  */)((char *)((long )(outbv + 6UL))), (size_t )(((long )*((ikptr *)((long )outbv + -2L) + 0) >> tmp___2) + 1L),
                     (char const   */* __restrict  */)((char *)((long )(fmtbv + 6UL))),
                     (struct tm  const  */* __restrict  */)tmp);
#line 818
  rv = (int )tmp___3;
  }
#line 823
  if (rv == 0) {
    {
#line 824
    tmp___4 = __errno_location();
#line 824
    tmp___5 = strerror(*tmp___4);
#line 824
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in strftime: %s\n",
            tmp___5);
    }
  }
#line 826
  if ((int )sizeof(ikptr ) == 4) {
#line 826
    tmp___6 = 2;
  } else {
#line 826
    tmp___6 = 3;
  }
#line 826
  return ((ikptr )((long )rv << tmp___6));
}
}
#line 829 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_register_guardian_pair(ikptr p0 , ikpcb *pcb ) 
{ 
  ik_ptr_page *x ;
  ik_ptr_page *y ;
  ikptr tmp ;
  long tmp___0 ;

  {
#line 831
  x = pcb->protected_list[0];
#line 832
  if ((unsigned long )x == (unsigned long )((void *)0)) {
#line 832
    goto _L;
  } else
#line 832
  if ((unsigned long )x->count == ((4096UL - sizeof(long )) - sizeof(struct ik_ptr_page *)) / sizeof(ikptr )) {
    _L: /* CIL Label */ 
    {
#line 834
    tmp = ik_mmap(4096UL);
#line 834
    y = (ik_ptr_page *)((long )tmp);
#line 835
    y->count = 0L;
#line 836
    y->next = x;
#line 837
    pcb->protected_list[0] = y;
#line 838
    x = y;
    }
  }
#line 840
  tmp___0 = x->count;
#line 840
  (x->count) ++;
#line 840
  x->ptr[tmp___0] = p0;
#line 841
  return ((ikptr )127);
}
}
#line 844 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_register_guardian(ikptr tc , ikptr obj , ikpcb *pcb ) 
{ 
  ikptr p0 ;
  ikptr tmp ;
  ikptr tmp___0 ;

  {
  {
#line 846
  tmp = ik_unsafe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 846
  p0 = tmp + 1UL;
#line 847
  *((ikptr *)((long )p0 + -1L) + 0) = tc;
#line 848
  *((ikptr *)((long )p0 + (long )((int )sizeof(ikptr ) - 1)) + 0) = obj;
#line 849
  tmp___0 = ikrt_register_guardian_pair(p0, pcb);
  }
#line 849
  return (tmp___0);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_stats_now(ikptr t , ikpcb *pcb ) 
{ 
  struct rusage r ;
  struct timeval s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long bytes_in_heap ;
  long bytes ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 857
  gettimeofday((struct timeval */* __restrict  */)(& s), (__timezone_ptr_t )0);
#line 858
  getrusage(0, & r);
  }
#line 859
  if ((int )sizeof(ikptr ) == 4) {
#line 859
    tmp = 2;
  } else {
#line 859
    tmp = 3;
  }
#line 859
  *((ikptr *)((long )t + (long )((int )sizeof(ikptr ) - 5)) + 0) = (ikptr )(r.ru_utime.tv_sec << tmp);
#line 860
  if ((int )sizeof(ikptr ) == 4) {
#line 860
    tmp___0 = 2;
  } else {
#line 860
    tmp___0 = 3;
  }
#line 860
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + (int )sizeof(ikptr ))) + 0) = (ikptr )(r.ru_utime.tv_usec << tmp___0);
#line 861
  if ((int )sizeof(ikptr ) == 4) {
#line 861
    tmp___1 = 2;
  } else {
#line 861
    tmp___1 = 3;
  }
#line 861
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 2 * (int )sizeof(ikptr ))) + 0) = (ikptr )(r.ru_stime.tv_sec << tmp___1);
#line 862
  if ((int )sizeof(ikptr ) == 4) {
#line 862
    tmp___2 = 2;
  } else {
#line 862
    tmp___2 = 3;
  }
#line 862
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 3 * (int )sizeof(ikptr ))) + 0) = (ikptr )(r.ru_stime.tv_usec << tmp___2);
#line 863
  if ((int )sizeof(ikptr ) == 4) {
#line 863
    tmp___3 = 2;
  } else {
#line 863
    tmp___3 = 3;
  }
#line 863
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 4 * (int )sizeof(ikptr ))) + 0) = (ikptr )(s.tv_sec << tmp___3);
#line 864
  if ((int )sizeof(ikptr ) == 4) {
#line 864
    tmp___4 = 2;
  } else {
#line 864
    tmp___4 = 3;
  }
#line 864
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 5 * (int )sizeof(ikptr ))) + 0) = (ikptr )(s.tv_usec << tmp___4);
#line 865
  if ((int )sizeof(ikptr ) == 4) {
#line 865
    tmp___5 = 2;
  } else {
#line 865
    tmp___5 = 3;
  }
#line 865
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 6 * (int )sizeof(ikptr ))) + 0) = (ikptr )((long )pcb->collection_id << tmp___5);
#line 866
  if ((int )sizeof(ikptr ) == 4) {
#line 866
    tmp___6 = 2;
  } else {
#line 866
    tmp___6 = 3;
  }
#line 866
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 7 * (int )sizeof(ikptr ))) + 0) = (ikptr )(pcb->collect_utime.tv_sec << tmp___6);
#line 867
  if ((int )sizeof(ikptr ) == 4) {
#line 867
    tmp___7 = 2;
  } else {
#line 867
    tmp___7 = 3;
  }
#line 867
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 8 * (int )sizeof(ikptr ))) + 0) = (ikptr )(pcb->collect_utime.tv_usec << tmp___7);
#line 868
  if ((int )sizeof(ikptr ) == 4) {
#line 868
    tmp___8 = 2;
  } else {
#line 868
    tmp___8 = 3;
  }
#line 868
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 9 * (int )sizeof(ikptr ))) + 0) = (ikptr )(pcb->collect_stime.tv_sec << tmp___8);
#line 869
  if ((int )sizeof(ikptr ) == 4) {
#line 869
    tmp___9 = 2;
  } else {
#line 869
    tmp___9 = 3;
  }
#line 869
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 10 * (int )sizeof(ikptr ))) + 0) = (ikptr )(pcb->collect_stime.tv_usec << tmp___9);
#line 870
  if ((int )sizeof(ikptr ) == 4) {
#line 870
    tmp___10 = 2;
  } else {
#line 870
    tmp___10 = 3;
  }
#line 870
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 11 * (int )sizeof(ikptr ))) + 0) = (ikptr )(pcb->collect_rtime.tv_sec << tmp___10);
#line 871
  if ((int )sizeof(ikptr ) == 4) {
#line 871
    tmp___11 = 2;
  } else {
#line 871
    tmp___11 = 3;
  }
#line 871
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 12 * (int )sizeof(ikptr ))) + 0) = (ikptr )(pcb->collect_rtime.tv_usec << tmp___11);
#line 874
  bytes_in_heap = (long )pcb->allocation_pointer - (long )pcb->heap_base;
#line 876
  bytes = bytes_in_heap + (long )pcb->allocation_count_minor;
#line 877
  if ((int )sizeof(ikptr ) == 4) {
#line 877
    tmp___12 = 2;
  } else {
#line 877
    tmp___12 = 3;
  }
#line 877
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 13 * (int )sizeof(ikptr ))) + 0) = (ikptr )(bytes << tmp___12);
#line 880
  if ((int )sizeof(ikptr ) == 4) {
#line 880
    tmp___13 = 2;
  } else {
#line 880
    tmp___13 = 3;
  }
#line 880
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 14 * (int )sizeof(ikptr ))) + 0) = (ikptr )((long )pcb->allocation_count_major << tmp___13);
#line 881
  return ((ikptr )127);
}
}
#line 884 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_current_time(ikptr t ) 
{ 
  struct timeval s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 887
  gettimeofday((struct timeval */* __restrict  */)(& s), (__timezone_ptr_t )0);
  }
#line 889
  if ((int )sizeof(ikptr ) == 4) {
#line 889
    tmp = 2;
  } else {
#line 889
    tmp = 3;
  }
#line 889
  *((ikptr *)((long )t + (long )((int )sizeof(ikptr ) - 5)) + 0) = (ikptr )(s.tv_sec / 1000000L << tmp);
#line 890
  if ((int )sizeof(ikptr ) == 4) {
#line 890
    tmp___0 = 2;
  } else {
#line 890
    tmp___0 = 3;
  }
#line 890
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + (int )sizeof(ikptr ))) + 0) = (ikptr )(s.tv_sec % 1000000L << tmp___0);
#line 891
  if ((int )sizeof(ikptr ) == 4) {
#line 891
    tmp___1 = 2;
  } else {
#line 891
    tmp___1 = 3;
  }
#line 891
  *((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + 2 * (int )sizeof(ikptr ))) + 0) = (ikptr )(s.tv_usec << tmp___1);
#line 892
  return (t);
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_gmt_offset(ikptr t ) 
{ 
  time_t clock___0 ;
  int tmp ;
  int tmp___0 ;
  struct tm *m ;
  struct tm *tmp___1 ;
  time_t gmtclock ;
  time_t tmp___2 ;
  int tmp___3 ;

  {
#line 897
  if ((int )sizeof(ikptr ) == 4) {
#line 897
    tmp = 2;
  } else {
#line 897
    tmp = 3;
  }
#line 897
  if ((int )sizeof(ikptr ) == 4) {
#line 897
    tmp___0 = 2;
  } else {
#line 897
    tmp___0 = 3;
  }
  {
#line 897
  clock___0 = ((long )*((ikptr *)((long )t + (long )((int )sizeof(ikptr ) - 5)) + 0) >> tmp) * 1000000L + ((long )*((ikptr *)((long )t + (long )(((int )sizeof(ikptr ) - 5) + (int )sizeof(ikptr ))) + 0) >> tmp___0);
#line 900
  tmp___1 = gmtime((time_t const   *)(& clock___0));
#line 900
  m = tmp___1;
#line 901
  tmp___2 = mktime(m);
#line 901
  gmtclock = tmp___2;
  }
#line 902
  if ((int )sizeof(ikptr ) == 4) {
#line 902
    tmp___3 = 2;
  } else {
#line 902
    tmp___3 = 3;
  }
#line 902
  return ((ikptr )((clock___0 - gmtclock) << tmp___3));
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_fork(void) 
{ 
  int pid ;
  __pid_t tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
  {
#line 912
  tmp = fork();
#line 912
  pid = tmp;
  }
#line 913
  if (pid >= 0) {
#line 914
    if ((int )sizeof(ikptr ) == 4) {
#line 914
      tmp___0 = 2;
    } else {
#line 914
      tmp___0 = 3;
    }
#line 914
    return ((ikptr )((long )pid << tmp___0));
  } else {
    {
#line 916
    tmp___1 = ik_errno_to_code();
    }
#line 916
    return (tmp___1);
  }
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_getenv(ikptr bv , ikpcb *pcb ) 
{ 
  char *v ;
  char *tmp ;
  long n ;
  size_t tmp___0 ;
  ikptr s ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;
  int tmp___4 ;

  {
  {
#line 924
  tmp = getenv((char const   *)((char *)((long )(bv + 6UL))));
#line 924
  v = tmp;
  }
#line 925
  if (v) {
    {
#line 926
    tmp___0 = strlen((char const   *)v);
#line 926
    n = (long )tmp___0;
    }
#line 927
    if ((int )sizeof(ikptr ) == 4) {
#line 927
      tmp___1 = 2;
    } else {
#line 927
      tmp___1 = 3;
    }
#line 927
    if ((int )sizeof(ikptr ) == 4) {
#line 927
      tmp___2 = 2;
    } else {
#line 927
      tmp___2 = 3;
    }
    {
#line 927
    tmp___3 = ik_safe_alloc(pcb, (int )((((((n + 8L) + 1L) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___1 + 1)) << (tmp___2 + 1)));
#line 927
    s = tmp___3 + 2UL;
    }
#line 929
    if ((int )sizeof(ikptr ) == 4) {
#line 929
      tmp___4 = 2;
    } else {
#line 929
      tmp___4 = 3;
    }
    {
#line 929
    *((ikptr *)((long )s + -2L) + 0) = (ikptr )(n << tmp___4);
#line 930
    memcpy((void */* __restrict  */)((char *)((long )(s + 6UL))), (void const   */* __restrict  */)v,
           (size_t )(n + 1L));
    }
#line 931
    return (s);
  } else {
#line 934
    return ((ikptr )47);
  }
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_make_vector1(ikptr len , ikpcb *pcb ) 
{ 
  int intlen ;
  ikptr s ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
#line 940
  intlen = (int )len;
#line 941
  if ((len & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 941
    if (intlen >= 0) {
#line 942
      if ((int )sizeof(ikptr ) == 4) {
#line 942
        tmp = 2;
      } else {
#line 942
        tmp = 3;
      }
#line 942
      if ((int )sizeof(ikptr ) == 4) {
#line 942
        tmp___0 = 2;
      } else {
#line 942
        tmp___0 = 3;
      }
      {
#line 942
      tmp___1 = ik_safe_alloc(pcb, (int )(((((len + (ikptr )((int )sizeof(ikptr ))) + (ikptr )(2 * (int )sizeof(ikptr ))) - 1UL) >> (tmp + 1)) << (tmp___0 + 1)));
#line 942
      s = tmp___1;
#line 943
      *((ikptr *)((long )s) + 0) = len;
#line 944
      memset((void *)((char *)((long )(s + (ikptr )((int )sizeof(ikptr ))))), 0, len);
      }
#line 945
      return (s + 5UL);
    } else {
#line 947
      return ((ikptr )0);
    }
  } else {
#line 947
    return ((ikptr )0);
  }
}
}
#line 968 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_setenv(ikptr key , ikptr val , ikptr overwrite ) 
{ 
  int err ;
  int tmp ;

  {
  {
#line 970
  tmp = setenv((char const   *)((char *)(key + 6UL)), (char const   *)((char *)(val + 6UL)),
               overwrite != 47UL);
#line 970
  err = tmp;
  }
#line 973
  if (err) {
#line 974
    return ((ikptr )47);
  } else {
#line 976
    return ((ikptr )63);
  }
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_unsetenv(ikptr key ) 
{ 


  {
  {
#line 982
  unsetenv((char const   *)((char *)(key + 6UL)));
  }
#line 983
  return ((ikptr )127);
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_environ(ikpcb *pcb ) 
{ 
  char **es ;
  int i ;
  char *e ;
  ikptr ac ;
  long n ;
  size_t tmp ;
  ikptr s ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;
  int tmp___3 ;
  ikptr p ;
  ikptr tmp___4 ;

  {
#line 990
  es = environ;
#line 992
  ac = (ikptr )79;
#line 993
  pcb->root0 = & ac;
#line 994
  i = 0;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    e = *(es + i);
#line 994
    if (! e) {
#line 994
      goto while_break;
    }
    {
#line 995
    tmp = strlen((char const   *)e);
#line 995
    n = (long )tmp;
    }
#line 996
    if ((int )sizeof(ikptr ) == 4) {
#line 996
      tmp___0 = 2;
    } else {
#line 996
      tmp___0 = 3;
    }
#line 996
    if ((int )sizeof(ikptr ) == 4) {
#line 996
      tmp___1 = 2;
    } else {
#line 996
      tmp___1 = 3;
    }
    {
#line 996
    tmp___2 = ik_safe_alloc(pcb, (int )((((((n + 8L) + 1L) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1)));
#line 996
    s = tmp___2 + 2UL;
    }
#line 998
    if ((int )sizeof(ikptr ) == 4) {
#line 998
      tmp___3 = 2;
    } else {
#line 998
      tmp___3 = 3;
    }
    {
#line 998
    *((ikptr *)((long )s + -2L) + 0) = (ikptr )(n << tmp___3);
#line 999
    memcpy((void */* __restrict  */)((char *)((long )(s + 6UL))), (void const   */* __restrict  */)e,
           (size_t )(n + 1L));
#line 1000
    pcb->root1 = & s;
#line 1001
    tmp___4 = ik_safe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 1001
    p = tmp___4 + 1UL;
#line 1002
    pcb->root1 = (ikptr *)0;
#line 1003
    *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0) = ac;
#line 1004
    *((ikptr *)((long )p + -1L) + 0) = s;
#line 1005
    ac = p;
#line 994
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1007
  pcb->root0 = (ikptr *)0;
#line 1008
  return (ac);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_exit(ikptr status , ikpcb *pcb ) 
{ 
  int tmp ;

  {
  {
#line 1013
  ik_delete_pcb(pcb);
  }
#line 1015
  if ((status & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 1016
    if ((int )sizeof(ikptr ) == 4) {
#line 1016
      tmp = 2;
    } else {
#line 1016
      tmp = 3;
    }
    {
#line 1016
    exit((int )((long )status >> tmp));
    }
  } else {
    {
#line 1018
    exit(1);
    }
  }
}
}
#line 1022 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_nanosleep(ikptr secs , ikptr nsecs ) 
{ 
  struct timespec t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1025
  if ((secs & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 1025
    if ((int )sizeof(ikptr ) == 4) {
#line 1025
      tmp = 2;
    } else {
#line 1025
      tmp = 3;
    }
#line 1025
    t.tv_sec = (__time_t )((unsigned long )((long )secs >> tmp));
  } else {
#line 1025
    t.tv_sec = (__time_t )*((ikptr *)((long )secs + (long )((int )sizeof(ikptr ) - 5)) + 0);
  }
#line 1029
  if ((nsecs & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 1029
    if ((int )sizeof(ikptr ) == 4) {
#line 1029
      tmp___0 = 2;
    } else {
#line 1029
      tmp___0 = 3;
    }
#line 1029
    t.tv_nsec = (__syscall_slong_t )((unsigned long )((long )nsecs >> tmp___0));
  } else {
#line 1029
    t.tv_nsec = (__syscall_slong_t )*((ikptr *)((long )nsecs + (long )((int )sizeof(ikptr ) - 5)) + 0);
  }
  {
#line 1033
  tmp___1 = nanosleep((struct timespec  const  *)(& t), (struct timespec *)((void *)0));
  }
#line 1033
  if ((int )sizeof(ikptr ) == 4) {
#line 1033
    tmp___2 = 2;
  } else {
#line 1033
    tmp___2 = 3;
  }
#line 1033
  return ((ikptr )((long )tmp___1 << tmp___2));
}
}
#line 1036 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_chdir(ikptr pathbv ) 
{ 
  int err ;
  int tmp ;
  ikptr tmp___0 ;

  {
  {
#line 1038
  tmp = chdir((char const   *)((char *)pathbv + 6));
#line 1038
  err = tmp;
  }
#line 1039
  if (err == 0) {
#line 1040
    return ((ikptr )63);
  }
  {
#line 1042
  tmp___0 = ik_errno_to_code();
  }
#line 1042
  return (tmp___0);
}
}
#line 1045 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_getcwd(ikpcb *pcb ) 
{ 
  char buff[4097] ;
  char *path ;
  char *tmp ;
  ikptr tmp___0 ;
  int len ;
  size_t tmp___1 ;
  ikptr bv ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1048
  tmp = getcwd(buff, (size_t )4096);
#line 1048
  path = tmp;
  }
#line 1049
  if (! path) {
    {
#line 1050
    tmp___0 = ik_errno_to_code();
    }
#line 1050
    return (tmp___0);
  }
  {
#line 1052
  tmp___1 = strlen((char const   *)path);
#line 1052
  len = (int )tmp___1;
  }
#line 1053
  if ((int )sizeof(ikptr ) == 4) {
#line 1053
    tmp___2 = 2;
  } else {
#line 1053
    tmp___2 = 3;
  }
#line 1053
  if ((int )sizeof(ikptr ) == 4) {
#line 1053
    tmp___3 = 2;
  } else {
#line 1053
    tmp___3 = 3;
  }
  {
#line 1053
  tmp___4 = ik_safe_alloc(pcb, (((((8 + len) + 1) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___2 + 1)) << (tmp___3 + 1));
#line 1053
  bv = tmp___4;
  }
#line 1054
  if ((int )sizeof(ikptr ) == 4) {
#line 1054
    tmp___5 = 2;
  } else {
#line 1054
    tmp___5 = 3;
  }
  {
#line 1054
  *((ikptr *)((long )bv) + 0) = (ikptr )((long )len << tmp___5);
#line 1055
  memcpy((void */* __restrict  */)((char *)bv + 8), (void const   */* __restrict  */)path,
         (size_t )(len + 1));
  }
#line 1056
  return (bv + 2UL);
}
}
#line 1061 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_debug(ikptr x ) 
{ 


  {
  {
#line 1063
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG 0x%016lx\n",
          (long )x);
  }
#line 1064
  return ((ikptr )0);
}
}
#line 1067 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_access(ikptr filename , ikptr how ) 
{ 
  char *fn ;
  int r ;
  int ik_how ;
  int c_how ;
  int tmp ;
  ikptr tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 1069
  fn = (char *)(filename + 6UL);
#line 1074
  if ((int )sizeof(ikptr ) == 4) {
#line 1074
    tmp = 2;
  } else {
#line 1074
    tmp = 3;
  }
#line 1074
  ik_how = (int )((long )how >> tmp);
#line 1075
  if (ik_how == 0) {
#line 1076
    c_how = 0;
  } else {
#line 1078
    c_how = 0;
#line 1079
    if (ik_how & 1) {
#line 1079
      c_how |= 4;
    }
#line 1080
    if (ik_how & 2) {
#line 1080
      c_how |= 2;
    }
#line 1081
    if (ik_how & 4) {
#line 1081
      c_how |= 1;
    }
  }
  {
#line 1084
  r = access((char const   *)fn, c_how);
  }
#line 1085
  if (r == 0) {
#line 1086
    return ((ikptr )63);
  } else {
    {
#line 1087
    tmp___1 = __errno_location();
    }
#line 1087
    if (*tmp___1 == 13) {
#line 1090
      return ((ikptr )47);
    } else {
      {
#line 1087
      tmp___2 = __errno_location();
      }
#line 1087
      if (*tmp___2 == 30) {
#line 1090
        return ((ikptr )47);
      } else {
        {
#line 1087
        tmp___3 = __errno_location();
        }
#line 1087
        if (*tmp___3 == 26) {
#line 1090
          return ((ikptr )47);
        } else {
          {
#line 1092
          tmp___0 = ik_errno_to_code();
          }
#line 1092
          return (tmp___0);
        }
      }
    }
  }
}
}
#line 1096 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_file_size(ikptr filename , ikpcb *pcb ) 
{ 
  char *fn ;
  struct stat s ;
  int r ;
  int tmp ;
  ikptr tmp___0 ;
  ikptr tmp___1 ;
  ikptr tmp___2 ;

  {
  {
#line 1098
  fn = (char *)(filename + 6UL);
#line 1100
  tmp = stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& s));
#line 1100
  r = tmp;
  }
#line 1101
  if (r == 0) {
#line 1102
    if (sizeof(off_t ) == sizeof(long )) {
      {
#line 1103
      tmp___0 = u_to_number((unsigned long )s.st_size, pcb);
      }
#line 1103
      return (tmp___0);
    } else
#line 1104
    if (sizeof(off_t ) == sizeof(long long )) {
      {
#line 1105
      tmp___1 = ull_to_number((unsigned long long )s.st_size, pcb);
      }
#line 1105
      return (tmp___1);
    } else {
      {
#line 1107
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"internal error in ikarus: invalid off_t size\n");
#line 1108
      exit(-1);
      }
    }
  } else {
    {
#line 1111
    tmp___2 = ik_errno_to_code();
    }
#line 1111
    return (tmp___2);
  }
}
}
#line 1115 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_rename_file(ikptr src , ikptr dst ) 
{ 
  int err ;
  int tmp ;
  ikptr tmp___0 ;

  {
  {
#line 1117
  tmp = rename((char const   *)((char *)(src + 6UL)), (char const   *)((char *)(dst + 6UL)));
#line 1117
  err = tmp;
  }
#line 1119
  if (err == 0) {
#line 1120
    return ((ikptr )63);
  } else {
    {
#line 1122
    tmp___0 = ik_errno_to_code();
    }
#line 1122
    return (tmp___0);
  }
}
}
#line 1126 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
ikptr ikrt_last_errno(ikpcb *pcb ) 
{ 
  ikptr tmp ;

  {
  {
#line 1128
  tmp = s_to_number((long )pcb->last_errno, pcb);
  }
#line 1128
  return (tmp);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-main.h"
int ikarus_main(int argc , char **argv , char *boot_file ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/scheme-script.c"
void ikarus_usage_short(void) 
{ 


  {
  {
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"scheme-script <script-name> arguments ...\n");
  }
#line 29
  return;
}
}
#line 32
void ikarus_usage(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/scheme-script.c"
static char *helpstring  =    (char *)"Usage: \n  scheme-script <script-name> arguments ...\n  \n  Runs the file <script-name> as a Scheme script, passing\n  arguments ... as (command-line)\n  \n  Consult the Ikarus Scheme User\'s Guide for more details.\n\n";
#line 31 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/scheme-script.c"
void ikarus_usage(void) 
{ 


  {
  {
#line 40
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          helpstring);
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/scheme-script.c"
int main(int argc , char **argv ) 
{ 
  char *boot_file ;
  char **args ;
  void *tmp ;
  int i ;
  int tmp___0 ;

  {
#line 44
  if (argc < 2) {
    {
#line 45
    ikarus_usage();
#line 46
    exit(-1);
    }
  }
  {
#line 48
  boot_file = (char *)"/usr/local/lib/ikarus/ikarus.boot";
#line 49
  tmp = calloc(sizeof(char *), (size_t )(argc + 1));
#line 49
  args = (char **)tmp;
#line 50
  *(args + 0) = *(argv + 0);
#line 51
  *(args + 1) = (char *)"--r6rs-script";
#line 53
  i = 1;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i < argc)) {
#line 53
      goto while_break;
    }
#line 54
    *(args + (i + 1)) = *(argv + i);
#line 53
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  tmp___0 = ikarus_main(argc + 1, args, boot_file);
  }
#line 56
  return (tmp___0);
}
}
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
#line 56
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) asin)(double __x ) ;
#line 58
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 60
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 67
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tan)(double __x ) ;
#line 72
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cosh)(double __x ) ;
#line 74
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sinh)(double __x ) ;
#line 76
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tanh)(double __x ) ;
#line 88
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acosh)(double __x ) ;
#line 90
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) asinh)(double __x ) ;
#line 92
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atanh)(double __x ) ;
#line 100
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 309
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) round)(double __x )  __attribute__((__const__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_round(ikptr x , ikptr y ) 
{ 


  {
  {
#line 37
  *((double *)((char *)((long )y) + 3)) = round(*((double *)((char *)((long )x) + 3)));
  }
#line 38
  return (y);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_exp(ikptr x , ikptr y ) 
{ 


  {
  {
#line 43
  *((double *)((char *)((long )y) + 3)) = exp(*((double *)((char *)((long )x) + 3)));
  }
#line 44
  return (y);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_flfl_expt(ikptr a , ikptr b , ikptr z ) 
{ 
  double tmp ;

  {
  {
#line 49
  tmp = log(*((double *)((char *)((long )a) + 3)));
#line 49
  *((double *)((char *)((long )z) + 3)) = exp(*((double *)((char *)((long )b) + 3)) * tmp);
  }
#line 50
  return (z);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_bytevector_to_flonum(ikptr x , ikpcb *pcb ) 
{ 
  double v ;
  double tmp ;
  ikptr r ;
  ikptr tmp___0 ;

  {
  {
#line 55
  tmp = strtod((char const   */* __restrict  */)((char *)((long )x) + 6), (char **/* __restrict  */)((void *)0));
#line 55
  v = tmp;
#line 56
  tmp___0 = ik_unsafe_alloc(pcb, 16);
#line 56
  r = tmp___0 + 5UL;
#line 57
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 58
  *((double *)((char *)((long )r) + 3)) = v;
  }
#line 59
  return (r);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_plus(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 64
  tmp = ik_unsafe_alloc(pcb, 16);
#line 64
  r = tmp + 5UL;
#line 65
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 66
  *((double *)((char *)((long )r) + 3)) = *((double *)((char *)((long )x) + 3)) + *((double *)((char *)((long )y) + 3));
  }
#line 67
  return (r);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_minus(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 72
  tmp = ik_unsafe_alloc(pcb, 16);
#line 72
  r = tmp + 5UL;
#line 73
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 74
  *((double *)((char *)((long )r) + 3)) = *((double *)((char *)((long )x) + 3)) - *((double *)((char *)((long )y) + 3));
  }
#line 75
  return (r);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_times(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 80
  tmp = ik_unsafe_alloc(pcb, 16);
#line 80
  r = tmp + 5UL;
#line 81
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 82
  *((double *)((char *)((long )r) + 3)) = *((double *)((char *)((long )x) + 3)) * *((double *)((char *)((long )y) + 3));
  }
#line 83
  return (r);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_div(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 88
  tmp = ik_unsafe_alloc(pcb, 16);
#line 88
  r = tmp + 5UL;
#line 89
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 90
  *((double *)((char *)((long )r) + 3)) = *((double *)((char *)((long )x) + 3)) / *((double *)((char *)((long )y) + 3));
  }
#line 91
  return (r);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_invert(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 96
  tmp = ik_unsafe_alloc(pcb, 16);
#line 96
  r = tmp + 5UL;
#line 97
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 98
  *((double *)((char *)((long )r) + 3)) = 1.0 / *((double *)((char *)((long )x) + 3));
  }
#line 99
  return (r);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_sin(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 104
  tmp = ik_unsafe_alloc(pcb, 16);
#line 104
  r = tmp + 5UL;
#line 105
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 106
  *((double *)((char *)((long )r) + 3)) = sin(*((double *)((char *)((long )x) + 3)));
  }
#line 107
  return (r);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_cos(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 112
  tmp = ik_unsafe_alloc(pcb, 16);
#line 112
  r = tmp + 5UL;
#line 113
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 114
  *((double *)((char *)((long )r) + 3)) = cos(*((double *)((char *)((long )x) + 3)));
  }
#line 115
  return (r);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_tan(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 120
  tmp = ik_unsafe_alloc(pcb, 16);
#line 120
  r = tmp + 5UL;
#line 121
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 122
  *((double *)((char *)((long )r) + 3)) = tan(*((double *)((char *)((long )x) + 3)));
  }
#line 123
  return (r);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_asin(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 128
  tmp = ik_unsafe_alloc(pcb, 16);
#line 128
  r = tmp + 5UL;
#line 129
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 130
  *((double *)((char *)((long )r) + 3)) = asin(*((double *)((char *)((long )x) + 3)));
  }
#line 131
  return (r);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_acos(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 136
  tmp = ik_unsafe_alloc(pcb, 16);
#line 136
  r = tmp + 5UL;
#line 137
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 138
  *((double *)((char *)((long )r) + 3)) = acos(*((double *)((char *)((long )x) + 3)));
  }
#line 139
  return (r);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_atan(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 144
  tmp = ik_unsafe_alloc(pcb, 16);
#line 144
  r = tmp + 5UL;
#line 145
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 146
  *((double *)((char *)((long )r) + 3)) = atan(*((double *)((char *)((long )x) + 3)));
  }
#line 147
  return (r);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_atan2(ikptr y , ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 152
  tmp = ik_unsafe_alloc(pcb, 16);
#line 152
  r = tmp + 5UL;
#line 153
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 154
  *((double *)((char *)((long )r) + 3)) = atan2(*((double *)((char *)((long )y) + 3)),
                                                *((double *)((char *)((long )x) + 3)));
  }
#line 155
  return (r);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_sqrt(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 160
  tmp = ik_unsafe_alloc(pcb, 16);
#line 160
  r = tmp + 5UL;
#line 161
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 162
  *((double *)((char *)((long )r) + 3)) = sqrt(*((double *)((char *)((long )x) + 3)));
  }
#line 163
  return (r);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_log(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 168
  tmp = ik_unsafe_alloc(pcb, 16);
#line 168
  r = tmp + 5UL;
#line 169
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 170
  *((double *)((char *)((long )r) + 3)) = log(*((double *)((char *)((long )x) + 3)));
  }
#line 171
  return (r);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fx_sin(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 176
  tmp = ik_unsafe_alloc(pcb, 16);
#line 176
  r = tmp + 5UL;
#line 177
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
  }
#line 178
  if ((int )sizeof(ikptr ) == 4) {
#line 178
    tmp___0 = 2;
  } else {
#line 178
    tmp___0 = 3;
  }
  {
#line 178
  *((double *)((char *)((long )r) + 3)) = sin((double )((long )x >> tmp___0));
  }
#line 179
  return (r);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fx_cos(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 184
  tmp = ik_unsafe_alloc(pcb, 16);
#line 184
  r = tmp + 5UL;
#line 185
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
  }
#line 186
  if ((int )sizeof(ikptr ) == 4) {
#line 186
    tmp___0 = 2;
  } else {
#line 186
    tmp___0 = 3;
  }
  {
#line 186
  *((double *)((char *)((long )r) + 3)) = cos((double )((long )x >> tmp___0));
  }
#line 187
  return (r);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fx_tan(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 192
  tmp = ik_unsafe_alloc(pcb, 16);
#line 192
  r = tmp + 5UL;
#line 193
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
  }
#line 194
  if ((int )sizeof(ikptr ) == 4) {
#line 194
    tmp___0 = 2;
  } else {
#line 194
    tmp___0 = 3;
  }
  {
#line 194
  *((double *)((char *)((long )r) + 3)) = tan((double )((long )x >> tmp___0));
  }
#line 195
  return (r);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fx_asin(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 200
  tmp = ik_unsafe_alloc(pcb, 16);
#line 200
  r = tmp + 5UL;
#line 201
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
  }
#line 202
  if ((int )sizeof(ikptr ) == 4) {
#line 202
    tmp___0 = 2;
  } else {
#line 202
    tmp___0 = 3;
  }
  {
#line 202
  *((double *)((char *)((long )r) + 3)) = asin((double )((long )x >> tmp___0));
  }
#line 203
  return (r);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fx_acos(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 208
  tmp = ik_unsafe_alloc(pcb, 16);
#line 208
  r = tmp + 5UL;
#line 209
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
  }
#line 210
  if ((int )sizeof(ikptr ) == 4) {
#line 210
    tmp___0 = 2;
  } else {
#line 210
    tmp___0 = 3;
  }
  {
#line 210
  *((double *)((char *)((long )r) + 3)) = acos((double )((long )x >> tmp___0));
  }
#line 211
  return (r);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fx_atan(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 216
  tmp = ik_unsafe_alloc(pcb, 16);
#line 216
  r = tmp + 5UL;
#line 217
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
  }
#line 218
  if ((int )sizeof(ikptr ) == 4) {
#line 218
    tmp___0 = 2;
  } else {
#line 218
    tmp___0 = 3;
  }
  {
#line 218
  *((double *)((char *)((long )r) + 3)) = atan((double )((long )x >> tmp___0));
  }
#line 219
  return (r);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_sinh(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 224
  tmp = ik_unsafe_alloc(pcb, 16);
#line 224
  r = tmp + 5UL;
#line 225
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 226
  *((double *)((char *)((long )r) + 3)) = sinh(*((double *)((char *)((long )x) + 3)));
  }
#line 227
  return (r);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_cosh(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 232
  tmp = ik_unsafe_alloc(pcb, 16);
#line 232
  r = tmp + 5UL;
#line 233
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 234
  *((double *)((char *)((long )r) + 3)) = cosh(*((double *)((char *)((long )x) + 3)));
  }
#line 235
  return (r);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_tanh(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 240
  tmp = ik_unsafe_alloc(pcb, 16);
#line 240
  r = tmp + 5UL;
#line 241
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 242
  *((double *)((char *)((long )r) + 3)) = tanh(*((double *)((char *)((long )x) + 3)));
  }
#line 243
  return (r);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_asinh(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 248
  tmp = ik_unsafe_alloc(pcb, 16);
#line 248
  r = tmp + 5UL;
#line 249
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 250
  *((double *)((char *)((long )r) + 3)) = asinh(*((double *)((char *)((long )x) + 3)));
  }
#line 251
  return (r);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_acosh(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 256
  tmp = ik_unsafe_alloc(pcb, 16);
#line 256
  r = tmp + 5UL;
#line 257
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 258
  *((double *)((char *)((long )r) + 3)) = acosh(*((double *)((char *)((long )x) + 3)));
  }
#line 259
  return (r);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_atanh(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 264
  tmp = ik_unsafe_alloc(pcb, 16);
#line 264
  r = tmp + 5UL;
#line 265
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 266
  *((double *)((char *)((long )r) + 3)) = atanh(*((double *)((char *)((long )x) + 3)));
  }
#line 267
  return (r);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fx_sqrt(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 274
  tmp = ik_unsafe_alloc(pcb, 16);
#line 274
  r = tmp + 5UL;
#line 275
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
  }
#line 276
  if ((int )sizeof(ikptr ) == 4) {
#line 276
    tmp___0 = 2;
  } else {
#line 276
    tmp___0 = 3;
  }
  {
#line 276
  *((double *)((char *)((long )r) + 3)) = sqrt((double )((long )x >> tmp___0));
  }
#line 277
  return (r);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fx_log(ikptr x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 282
  tmp = ik_unsafe_alloc(pcb, 16);
#line 282
  r = tmp + 5UL;
#line 283
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
  }
#line 284
  if ((int )sizeof(ikptr ) == 4) {
#line 284
    tmp___0 = 2;
  } else {
#line 284
    tmp___0 = 3;
  }
  {
#line 284
  *((double *)((char *)((long )r) + 3)) = log((double )((long )x >> tmp___0));
  }
#line 285
  return (r);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fixnum_to_flonum(ikptr x , ikptr r , ikpcb *pcb ) 
{ 
  int tmp ;

  {
#line 290
  if ((int )sizeof(ikptr ) == 4) {
#line 290
    tmp = 2;
  } else {
#line 290
    tmp = 3;
  }
#line 290
  *((double *)((char *)((long )r) + 3)) = (double )((long )x >> tmp);
#line 291
  return (r);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_equal(ikptr x , ikptr y ) 
{ 


  {
#line 296
  if (*((double *)((char *)((long )x) + 3)) == *((double *)((char *)((long )y) + 3))) {
#line 297
    return ((ikptr )63);
  } else {
#line 299
    return ((ikptr )47);
  }
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_less_or_equal(ikptr x , ikptr y ) 
{ 


  {
#line 305
  if (*((double *)((char *)((long )x) + 3)) <= *((double *)((char *)((long )y) + 3))) {
#line 306
    return ((ikptr )63);
  } else {
#line 308
    return ((ikptr )47);
  }
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-flonums.c"
ikptr ikrt_fl_less(ikptr x , ikptr y ) 
{ 


  {
#line 314
  if (*((double *)((char *)((long )x) + 3)) < *((double *)((char *)((long )y) + 3))) {
#line 315
    return ((ikptr )63);
  } else {
#line 317
    return ((ikptr )47);
  }
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 212 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
ikptr normalize_bignum(long limbs , int sign , ikptr r ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 776
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) labs)(long __x )  __attribute__((__const__)) ;
#line 491 "/usr/include/x86_64-linux-gnu/gmp.h"
extern int const   __gmp_bits_per_limb ;
#line 629
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 805
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 810
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 815
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 841
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 846
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 948
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 969
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 974
__inline extern mp_bitcnt_t __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1020
extern void __gmpz_set(mpz_ptr  , mpz_srcptr  ) ;
#line 1030
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1047
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1081
extern void __gmpz_tdiv_q(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 1125
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1192
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1201
extern void __gmpq_set(mpq_ptr  , mpq_srcptr  ) ;
#line 1447
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1452
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1456
extern mp_limb_t __gmpn_add_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1463
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 1479
extern mp_limb_t __gmpn_divrem_1(mp_ptr  , mp_size_t  , mp_srcptr  , mp_size_t  ,
                                 mp_limb_t  ) ;
#line 1500
extern size_t __gmpn_get_str(unsigned char * , int  , mp_ptr  , mp_size_t  ) ;
#line 1509
extern mp_limb_t __gmpn_mod_1(mp_srcptr  , mp_size_t  , mp_limb_t  )  __attribute__((__pure__)) ;
#line 1512
extern mp_limb_t __gmpn_mul(mp_ptr  , mp_srcptr  , mp_size_t  , mp_srcptr  , mp_size_t  ) ;
#line 1515
extern mp_limb_t __gmpn_mul_1(mp_ptr  , mp_srcptr  , mp_size_t  , mp_limb_t  ) ;
#line 1525
__inline extern mp_limb_t __gmpn_neg(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) ;
#line 1534
extern int __gmpn_perfect_square_p(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1540
extern mp_bitcnt_t __gmpn_popcount(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1568
extern mp_size_t __gmpn_sqrtrem(mp_ptr  , mp_ptr  , mp_srcptr  , mp_size_t  ) ;
#line 1572
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1577
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1581
extern mp_limb_t __gmpn_sub_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1587
extern void __gmpn_tdiv_qr(mp_ptr  , mp_ptr  , mp_size_t  , mp_srcptr  , mp_size_t  ,
                           mp_srcptr  , mp_size_t  ) ;
#line 1630 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1633
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1634
    __gmpz_set(__gmp_w, __gmp_u);
    }
  }
#line 1635
  if (__gmp_w->_mp_size >= 0) {
#line 1635
    __gmp_w->_mp_size = __gmp_w->_mp_size;
  } else {
#line 1635
    __gmp_w->_mp_size = - __gmp_w->_mp_size;
  }
#line 1636
  return;
}
}
#line 1654
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1654 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1659
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1659
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1659
  if (__gmp_n == 0L) {
#line 1659
    tmp = 1;
  } else
#line 1659
  if (__gmp_n == 1L) {
#line 1659
    if (*(__gmp_p + 0) <= 4294967295UL) {
#line 1659
      tmp = 1;
    } else {
#line 1659
      tmp = 0;
    }
  } else {
#line 1659
    tmp = 0;
  }
#line 1659
  return (tmp);
}
}
#line 1665
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1665 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1670
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1670
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1670
  if (__gmp_n == 0L) {
#line 1670
    tmp = 1;
  } else
#line 1670
  if (__gmp_n == 1L) {
#line 1670
    if (*(__gmp_p + 0) <= 0xffffffffffffffffUL) {
#line 1670
      tmp = 1;
    } else {
#line 1670
      tmp = 0;
    }
  } else {
#line 1670
    tmp = 0;
  }
#line 1670
  return (tmp);
}
}
#line 1676
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1676 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
#line 1681
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1681
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1681
  if (__gmp_n == 0L) {
#line 1681
    tmp = 1;
  } else
#line 1681
  if (__gmp_n == 1L) {
#line 1681
    if (*(__gmp_p + 0) <= 65535UL) {
#line 1681
      tmp = 1;
    } else {
#line 1681
      tmp = 0;
    }
  } else {
#line 1681
    tmp = 0;
  }
#line 1681
  return (tmp);
}
}
#line 1687
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1687 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z ) 
{ 
  mp_ptr __gmp_p ;
  mp_size_t __gmp_n ;
  mp_limb_t __gmp_l ;
  mp_limb_t tmp ;

  {
#line 1692
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1693
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1694
  __gmp_l = *(__gmp_p + 0);
#line 1701
  if (__gmp_n != 0L) {
#line 1701
    tmp = __gmp_l;
  } else {
#line 1701
    tmp = (mp_limb_t )0;
  }
#line 1701
  return (tmp);
}
}
#line 1715
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 1715 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_result ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1720
  __gmp_result = (mp_limb_t )0;
#line 1721
  if (__gmp_n >= 0L) {
#line 1721
    if (__gmp_z->_mp_size >= 0) {
#line 1721
      tmp = __gmp_z->_mp_size;
    } else {
#line 1721
      tmp = - __gmp_z->_mp_size;
    }
#line 1721
    if (__gmp_n < (mp_size_t )tmp) {
#line 1721
      tmp___0 = 1;
    } else {
#line 1721
      tmp___0 = 0;
    }
  } else {
#line 1721
    tmp___0 = 0;
  }
  {
#line 1721
  tmp___1 = __builtin_expect((long )(tmp___0 != 0), 1L);
  }
#line 1721
  if (tmp___1) {
#line 1722
    __gmp_result = *(__gmp_z->_mp_d + __gmp_n);
  }
#line 1723
  return (__gmp_result);
}
}
#line 1728 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1731
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1732
    __gmpz_set(__gmp_w, __gmp_u);
    }
  }
#line 1733
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
#line 1734
  return;
}
}
#line 1739
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 1739 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a ) 
{ 
  mp_size_t __gmp_asize ;
  int __gmp_result ;
  long tmp ;

  {
  {
#line 1747
  __gmp_asize = (mp_size_t )__gmp_a->_mp_size;
#line 1748
  __gmp_result = __gmp_asize >= 0L;
#line 1749
  tmp = __builtin_expect((long )((__gmp_asize > 0L) != 0), 1L);
  }
#line 1749
  if (tmp) {
    {
#line 1750
    __gmp_result = __gmpn_perfect_square_p((mp_srcptr )__gmp_a->_mp_d, __gmp_asize);
    }
  }
#line 1751
  return (__gmp_result);
}
}
#line 1757
__inline extern mp_bitcnt_t __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1757 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_bitcnt_t __gmpz_popcount(mpz_srcptr __gmp_u ) 
{ 
  mp_size_t __gmp_usize ;
  mp_bitcnt_t __gmp_result ;
  long tmp ;

  {
#line 1765
  __gmp_usize = (mp_size_t )__gmp_u->_mp_size;
#line 1766
  if (__gmp_usize < 0L) {
#line 1766
    __gmp_result = ~ 0UL;
  } else {
#line 1766
    __gmp_result = (mp_bitcnt_t )0;
  }
  {
#line 1767
  tmp = __builtin_expect((long )((__gmp_usize > 0L) != 0), 1L);
  }
#line 1767
  if (tmp) {
    {
#line 1768
    __gmp_result = __gmpn_popcount((mp_srcptr )__gmp_u->_mp_d, __gmp_usize);
    }
  }
#line 1769
  return (__gmp_result);
}
}
#line 1775 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
  {
#line 1780
  __gmpz_tdiv_q(__gmp_w, & __gmp_u->_mp_num, & __gmp_u->_mp_den);
  }
#line 1781
  return;
}
}
#line 1786
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1786 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z ) 
{ 
  int tmp ;

  {
#line 1791
  if (__gmp_z->_mp_size >= 0) {
#line 1791
    tmp = __gmp_z->_mp_size;
  } else {
#line 1791
    tmp = - __gmp_z->_mp_size;
  }
#line 1791
  return ((size_t )tmp);
}
}
#line 1799 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1802
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1803
    __gmpq_set(__gmp_w, __gmp_u);
    }
  }
#line 1804
  if (__gmp_w->_mp_num._mp_size >= 0) {
#line 1804
    __gmp_w->_mp_num._mp_size = __gmp_w->_mp_num._mp_size;
  } else {
#line 1804
    __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
  }
#line 1805
  return;
}
}
#line 1809 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1812
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1813
    __gmpq_set(__gmp_w, __gmp_u);
    }
  }
#line 1814
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
#line 1815
  return;
}
}
#line 2052 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_limb_t tmp___1 ;
  mp_size_t __gmp_j ;

  {
  {
#line 2058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2058
    __gmp_i = __gmp_ysize;
#line 2058
    if (__gmp_i != 0L) {
      {
#line 2058
      tmp___1 = __gmpn_add_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
#line 2058
      if (tmp___1) {
        {
#line 2058
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2058
          if (__gmp_i >= __gmp_xsize) {
#line 2058
            __gmp_c = (mp_limb_t )1;
#line 2058
            goto __gmp_done;
          }
#line 2058
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2058
          tmp = __gmp_i;
#line 2058
          __gmp_i ++;
#line 2058
          tmp___0 = (__gmp_x + 1UL) & 0xffffffffffffffffUL;
#line 2058
          *(__gmp_wp + tmp) = tmp___0;
#line 2058
          if (! (tmp___0 == 0UL)) {
#line 2058
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 2058
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
#line 2058
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2058
        __gmp_j = __gmp_i;
        {
#line 2058
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2058
          if (! (__gmp_j < __gmp_xsize)) {
#line 2058
            goto while_break___2;
          }
#line 2058
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2058
          __gmp_j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2058
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2058
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2058
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2059
  return (__gmp_c);
}
}
#line 2065 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
#line 2071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2071
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2071
    __gmp_r = __gmp_x + __gmp_n;
#line 2071
    *(__gmp_dst + 0) = __gmp_r;
#line 2071
    if (__gmp_r < __gmp_n) {
#line 2071
      __gmp_c = (mp_limb_t )1;
#line 2071
      __gmp_i = (mp_size_t )1;
      {
#line 2071
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2071
        if (! (__gmp_i < __gmp_size)) {
#line 2071
          goto while_break___0;
        }
#line 2071
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2071
        __gmp_r = __gmp_x + 1UL;
#line 2071
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2071
        __gmp_i ++;
#line 2071
        if (! (__gmp_r < 1UL)) {
#line 2071
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
#line 2071
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2071
              __gmp_j = __gmp_i;
              {
#line 2071
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 2071
                if (! (__gmp_j < __gmp_size)) {
#line 2071
                  goto while_break___2;
                }
#line 2071
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2071
                __gmp_j ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2071
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 2071
          __gmp_c = (mp_limb_t )0;
#line 2071
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2071
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
#line 2071
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2071
          __gmp_j___0 = (mp_size_t )1;
          {
#line 2071
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2071
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2071
              goto while_break___4;
            }
#line 2071
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2071
            __gmp_j___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2071
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2071
      __gmp_c = (mp_limb_t )0;
    }
#line 2071
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2072
  return (__gmp_c);
}
}
#line 2078
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 2078 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size ) 
{ 
  int __gmp_result ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_y ;

  {
  {
#line 2084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2084
    __gmp_result = 0;
#line 2084
    __gmp_i = __gmp_size;
    {
#line 2084
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2084
      __gmp_i --;
#line 2084
      if (! (__gmp_i >= 0L)) {
#line 2084
        goto while_break___0;
      }
#line 2084
      __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2084
      __gmp_y = (mp_limb_t )*(__gmp_yp + __gmp_i);
#line 2084
      if (__gmp_x != __gmp_y) {
#line 2084
        if (__gmp_x > __gmp_y) {
#line 2084
          __gmp_result = 1;
        } else {
#line 2084
          __gmp_result = -1;
        }
#line 2084
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2084
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2085
  return (__gmp_result);
}
}
#line 2091 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_size_t __gmp_j ;

  {
  {
#line 2097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2097
    __gmp_i = __gmp_ysize;
#line 2097
    if (__gmp_i != 0L) {
      {
#line 2097
      tmp___0 = __gmpn_sub_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
#line 2097
      if (tmp___0) {
        {
#line 2097
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2097
          if (__gmp_i >= __gmp_xsize) {
#line 2097
            __gmp_c = (mp_limb_t )1;
#line 2097
            goto __gmp_done;
          }
#line 2097
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2097
          tmp = __gmp_i;
#line 2097
          __gmp_i ++;
#line 2097
          *(__gmp_wp + tmp) = (__gmp_x - 1UL) & 0xffffffffffffffffUL;
#line 2097
          if (! (__gmp_x == 0UL)) {
#line 2097
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 2097
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
#line 2097
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2097
        __gmp_j = __gmp_i;
        {
#line 2097
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2097
          if (! (__gmp_j < __gmp_xsize)) {
#line 2097
            goto while_break___2;
          }
#line 2097
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2097
          __gmp_j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2097
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2097
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2097
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2098
  return (__gmp_c);
}
}
#line 2104 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
#line 2110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2110
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2110
    __gmp_r = __gmp_x - __gmp_n;
#line 2110
    *(__gmp_dst + 0) = __gmp_r;
#line 2110
    if (__gmp_x < __gmp_n) {
#line 2110
      __gmp_c = (mp_limb_t )1;
#line 2110
      __gmp_i = (mp_size_t )1;
      {
#line 2110
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2110
        if (! (__gmp_i < __gmp_size)) {
#line 2110
          goto while_break___0;
        }
#line 2110
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2110
        __gmp_r = __gmp_x - 1UL;
#line 2110
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2110
        __gmp_i ++;
#line 2110
        if (! (__gmp_x < 1UL)) {
#line 2110
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
#line 2110
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2110
              __gmp_j = __gmp_i;
              {
#line 2110
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 2110
                if (! (__gmp_j < __gmp_size)) {
#line 2110
                  goto while_break___2;
                }
#line 2110
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2110
                __gmp_j ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2110
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 2110
          __gmp_c = (mp_limb_t )0;
#line 2110
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2110
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
#line 2110
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2110
          __gmp_j___0 = (mp_size_t )1;
          {
#line 2110
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2110
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2110
              goto while_break___4;
            }
#line 2110
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2110
            __gmp_j___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2110
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2110
      __gmp_c = (mp_limb_t )0;
    }
#line 2110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2111
  return (__gmp_c);
}
}
#line 2117 "/usr/include/x86_64-linux-gnu/gmp.h"
__inline extern mp_limb_t __gmpn_neg(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_ul ;
  mp_limb_t __gmp_cy ;
  mp_srcptr tmp ;
  mp_ptr tmp___0 ;

  {
#line 2123
  __gmp_cy = (mp_limb_t )0;
  {
#line 2124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2125
    tmp = __gmp_up;
#line 2125
    __gmp_up ++;
#line 2125
    __gmp_ul = (mp_limb_t )*tmp;
#line 2126
    tmp___0 = __gmp_rp;
#line 2126
    __gmp_rp ++;
#line 2126
    *tmp___0 = - __gmp_ul - __gmp_cy;
#line 2127
    __gmp_cy |= (unsigned long )(__gmp_ul != 0UL);
#line 2124
    __gmp_n --;
#line 2124
    if (! (__gmp_n != 0L)) {
#line 2124
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2129
  return (__gmp_cy);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_positive_bn(ikptr x ) 
{ 
  ikptr fst ;

  {
#line 109
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 110
  if (fst & 8UL) {
#line 111
    return ((ikptr )47);
  } else {
#line 113
    return ((ikptr )63);
  }
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_even_bn(ikptr x ) 
{ 
  long fst ;

  {
#line 119
  fst = (long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 120
  if (fst & 1L) {
#line 121
    return ((ikptr )47);
  } else {
#line 123
    return ((ikptr )63);
  }
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fxfxplus(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  long n1 ;
  int tmp ;
  long n2 ;
  int tmp___0 ;
  long r ;
  ikptr q ;
  int tmp___1 ;
  ikptr bn ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  int tmp___5 ;

  {
#line 131
  if ((int )sizeof(ikptr ) == 4) {
#line 131
    tmp = 2;
  } else {
#line 131
    tmp = 3;
  }
#line 131
  n1 = (long )x >> tmp;
#line 132
  if ((int )sizeof(ikptr ) == 4) {
#line 132
    tmp___0 = 2;
  } else {
#line 132
    tmp___0 = 3;
  }
#line 132
  n2 = (long )y >> tmp___0;
#line 133
  r = n1 + n2;
#line 134
  if ((int )sizeof(ikptr ) == 4) {
#line 134
    tmp___1 = 2;
  } else {
#line 134
    tmp___1 = 3;
  }
#line 134
  q = (ikptr )(r << tmp___1);
#line 135
  if ((int )sizeof(ikptr ) == 4) {
#line 135
    tmp___5 = 2;
  } else {
#line 135
    tmp___5 = 3;
  }
#line 135
  if (r == (long )q >> tmp___5) {
#line 136
    return (q);
  } else {
#line 139
    if ((int )sizeof(ikptr ) == 4) {
#line 139
      tmp___2 = 2;
    } else {
#line 139
      tmp___2 = 3;
    }
#line 139
    if ((int )sizeof(ikptr ) == 4) {
#line 139
      tmp___3 = 2;
    } else {
#line 139
      tmp___3 = 3;
    }
    {
#line 139
    tmp___4 = ik_safe_alloc(pcb, (((((int )sizeof(ikptr ) + (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___2 + 1)) << (tmp___3 + 1));
#line 139
    bn = tmp___4;
    }
#line 140
    if (r > 0L) {
#line 141
      *((ikptr *)((long )bn) + 0) = (ikptr )(3 | (1 << 4));
#line 142
      *((ikptr *)((long )bn + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )r;
    } else {
#line 145
      *((ikptr *)((long )bn) + 0) = (ikptr )((3 | (1 << 4)) | (1 << 3));
#line 149
      *((ikptr *)((long )bn + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )(- r);
    }
#line 151
    return (bn + 5UL);
  }
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fxbnplus(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr fst ;
  long limb_count ;
  long intx ;
  int tmp ;
  ikptr r ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;
  mp_limb_t carry ;
  mp_limb_t tmp___3 ;
  ikptr r___0 ;
  int tmp___4 ;
  int tmp___5 ;
  ikptr tmp___6 ;
  mp_limb_t borrow ;
  mp_limb_t tmp___7 ;
  long result_size ;
  long tmp___8 ;
  mp_limb_t last ;
  int tmp___9 ;
  int tmp___10 ;
  ikptr r___1 ;
  int tmp___11 ;
  int tmp___12 ;
  ikptr tmp___13 ;
  mp_limb_t borrow___0 ;
  mp_limb_t tmp___14 ;
  long result_size___0 ;
  long tmp___15 ;
  mp_limb_t last___0 ;
  int tmp___16 ;
  int tmp___17 ;
  ikptr r___2 ;
  int tmp___18 ;
  int tmp___19 ;
  ikptr tmp___20 ;
  mp_limb_t carry___0 ;
  mp_limb_t tmp___21 ;

  {
#line 157
  if (x == 0UL) {
#line 157
    return (y);
  }
#line 158
  fst = *((ikptr *)((long )y + -5L) + 0);
#line 159
  limb_count = (long )(fst >> 4);
#line 160
  if ((int )sizeof(ikptr ) == 4) {
#line 160
    tmp = 2;
  } else {
#line 160
    tmp = 3;
  }
#line 160
  intx = (long )x >> tmp;
#line 161
  if (intx > 0L) {
#line 162
    if (! (fst & 8UL)) {
#line 164
      pcb->root0 = & y;
#line 165
      if ((int )sizeof(ikptr ) == 4) {
#line 165
        tmp___0 = 2;
      } else {
#line 165
        tmp___0 = 3;
      }
#line 165
      if ((int )sizeof(ikptr ) == 4) {
#line 165
        tmp___1 = 2;
      } else {
#line 165
        tmp___1 = 3;
      }
      {
#line 165
      tmp___2 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (limb_count + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1)));
#line 165
      r = tmp___2;
#line 166
      pcb->root0 = (ikptr *)0;
#line 167
      tmp___3 = __gmpn_add_1((mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr )))),
                             (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                             limb_count, (mp_limb_t )intx);
#line 167
      carry = tmp___3;
      }
#line 172
      if (carry) {
#line 173
        *((ikptr *)((long )r + ((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr )))) + 0) = (ikptr )1;
#line 174
        *((ikptr *)((long )r) + 0) = (ikptr )(((limb_count + 1L) << 4) | 3L);
#line 178
        return (r + 5UL);
      } else {
#line 180
        *((ikptr *)((long )r) + 0) = (ikptr )((limb_count << 4) | 3L);
#line 184
        return (r + 5UL);
      }
    } else {
#line 189
      pcb->root0 = & y;
#line 190
      if ((int )sizeof(ikptr ) == 4) {
#line 190
        tmp___4 = 2;
      } else {
#line 190
        tmp___4 = 3;
      }
#line 190
      if ((int )sizeof(ikptr ) == 4) {
#line 190
        tmp___5 = 2;
      } else {
#line 190
        tmp___5 = 3;
      }
      {
#line 190
      tmp___6 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___4 + 1)) << (tmp___5 + 1)));
#line 190
      r___0 = tmp___6;
#line 191
      pcb->root0 = (ikptr *)0;
#line 192
      tmp___7 = __gmpn_sub_1((mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr )))),
                             (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                             limb_count, (mp_limb_t )intx);
#line 192
      borrow = tmp___7;
      }
#line 197
      if (borrow) {
        {
#line 198
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: BUG in borrow1 %ld\n",
                borrow);
#line 199
        exit(-1);
        }
      }
#line 201
      if (*((ikptr *)((long )r___0 + ((long )((int )sizeof(ikptr )) + (limb_count - 1L) * (long )((int )sizeof(ikptr )))) + 0)) {
#line 201
        tmp___8 = limb_count;
      } else {
#line 201
        tmp___8 = limb_count - 1L;
      }
#line 201
      result_size = tmp___8;
#line 205
      if (result_size == 0L) {
#line 206
        return ((ikptr )0);
      }
#line 208
      if (result_size == 1L) {
#line 209
        last = *((ikptr *)((long )r___0 + ((long )((int )sizeof(ikptr )) + (result_size - 1L) * (long )((int )sizeof(ikptr )))) + 0);
#line 211
        if ((int )sizeof(ikptr ) == 4) {
#line 211
          tmp___10 = 2;
        } else {
#line 211
          tmp___10 = 3;
        }
#line 211
        if (last <= (0xffffffffffffffffUL >> (tmp___10 + 1)) + 1UL) {
#line 212
          if ((int )sizeof(ikptr ) == 4) {
#line 212
            tmp___9 = 2;
          } else {
#line 212
            tmp___9 = 3;
          }
#line 212
          return ((ikptr )(- ((long )last) << tmp___9));
        }
      }
#line 215
      *((ikptr *)((long )r___0) + 0) = (ikptr )(((result_size << 4) | (long )(1 << 3)) | 3L);
#line 219
      return (r___0 + 5UL);
    }
  } else
#line 223
  if (! (fst & 8UL)) {
#line 225
    pcb->root0 = & y;
#line 226
    if ((int )sizeof(ikptr ) == 4) {
#line 226
      tmp___11 = 2;
    } else {
#line 226
      tmp___11 = 3;
    }
#line 226
    if ((int )sizeof(ikptr ) == 4) {
#line 226
      tmp___12 = 2;
    } else {
#line 226
      tmp___12 = 3;
    }
    {
#line 226
    tmp___13 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___11 + 1)) << (tmp___12 + 1)));
#line 226
    r___1 = tmp___13;
#line 227
    pcb->root0 = (ikptr *)0;
#line 228
    tmp___14 = __gmpn_sub_1((mp_limb_t *)((long )(r___1 + (ikptr )((int )sizeof(ikptr )))),
                            (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                            limb_count, (mp_limb_t )(- intx));
#line 228
    borrow___0 = tmp___14;
    }
#line 233
    if (borrow___0) {
      {
#line 234
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: BUG in borrow2\n");
#line 235
      exit(-1);
      }
    }
#line 237
    if (*((ikptr *)((long )r___1 + ((long )((int )sizeof(ikptr )) + (limb_count - 1L) * (long )((int )sizeof(ikptr )))) + 0) == 0UL) {
#line 237
      tmp___15 = limb_count - 1L;
    } else {
#line 237
      tmp___15 = limb_count;
    }
#line 237
    result_size___0 = tmp___15;
#line 241
    if (result_size___0 == 0L) {
#line 242
      return ((ikptr )0);
    }
#line 244
    if (result_size___0 == 1L) {
#line 245
      last___0 = *((ikptr *)((long )r___1 + ((long )((int )sizeof(ikptr )) + (result_size___0 - 1L) * (long )((int )sizeof(ikptr )))) + 0);
#line 247
      if ((int )sizeof(ikptr ) == 4) {
#line 247
        tmp___17 = 2;
      } else {
#line 247
        tmp___17 = 3;
      }
#line 247
      if (last___0 <= 0xffffffffffffffffUL >> (tmp___17 + 1)) {
#line 248
        if ((int )sizeof(ikptr ) == 4) {
#line 248
          tmp___16 = 2;
        } else {
#line 248
          tmp___16 = 3;
        }
#line 248
        return ((ikptr )((long )last___0 << tmp___16));
      }
    }
#line 251
    *((ikptr *)((long )r___1) + 0) = (ikptr )((result_size___0 << 4) | 3L);
#line 255
    return (r___1 + 5UL);
  } else {
#line 258
    pcb->root0 = & y;
#line 259
    if ((int )sizeof(ikptr ) == 4) {
#line 259
      tmp___18 = 2;
    } else {
#line 259
      tmp___18 = 3;
    }
#line 259
    if ((int )sizeof(ikptr ) == 4) {
#line 259
      tmp___19 = 2;
    } else {
#line 259
      tmp___19 = 3;
    }
    {
#line 259
    tmp___20 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (limb_count + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___18 + 1)) << (tmp___19 + 1)));
#line 259
    r___2 = tmp___20;
#line 260
    pcb->root0 = (ikptr *)0;
#line 261
    tmp___21 = __gmpn_add_1((mp_limb_t *)((long )(r___2 + (ikptr )((int )sizeof(ikptr )))),
                            (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                            limb_count, (mp_limb_t )(- intx));
#line 261
    carry___0 = tmp___21;
    }
#line 266
    if (carry___0) {
#line 267
      *((ikptr *)((long )r___2 + ((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr )))) + 0) = (ikptr )1;
#line 268
      *((ikptr *)((long )r___2) + 0) = (ikptr )((((limb_count + 1L) << 4) | (long )(1 << 3)) | 3L);
#line 272
      return (r___2 + 5UL);
    } else {
#line 274
      *((ikptr *)((long )r___2) + 0) = (ikptr )(((limb_count << 4) | (long )(1 << 3)) | 3L);
#line 278
      return (r___2 + 5UL);
    }
  }
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnbnplus(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  unsigned long xfst ;
  unsigned long yfst ;
  long xsign ;
  long ysign ;
  long xlimbs ;
  long ylimbs ;
  long n1 ;
  long n2 ;
  ikptr s1 ;
  ikptr s2 ;
  ikptr res ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  mp_limb_t carry ;
  mp_limb_t tmp___2 ;
  ikptr s1___0 ;
  ikptr s2___0 ;
  long n1___0 ;
  long n2___0 ;
  long result_sign ;
  ikptr res___0 ;
  int tmp___3 ;
  int tmp___4 ;
  ikptr tmp___5 ;
  mp_limb_t burrow ;
  mp_limb_t tmp___6 ;
  long len ;
  mp_limb_t fst_limb ;
  int tmp___7 ;
  int tmp___8 ;
  mp_limb_t fst_limb___0 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 289
  xfst = *((ikptr *)((long )x + -5L) + 0);
#line 290
  yfst = *((ikptr *)((long )y + -5L) + 0);
#line 291
  xsign = (long )(xfst & 8UL);
#line 292
  ysign = (long )(yfst & 8UL);
#line 293
  xlimbs = (long )(xfst >> 4);
#line 294
  ylimbs = (long )(yfst >> 4);
#line 295
  if (xsign == ysign) {
#line 298
    if (xlimbs > ylimbs) {
#line 299
      n1 = xlimbs;
#line 299
      n2 = ylimbs;
#line 299
      s1 = x;
#line 299
      s2 = y;
    } else {
#line 301
      n1 = ylimbs;
#line 301
      n2 = xlimbs;
#line 301
      s1 = y;
#line 301
      s2 = x;
    }
#line 303
    pcb->root0 = & s1;
#line 304
    pcb->root1 = & s2;
#line 305
    if ((int )sizeof(ikptr ) == 4) {
#line 305
      tmp = 2;
    } else {
#line 305
      tmp = 3;
    }
#line 305
    if ((int )sizeof(ikptr ) == 4) {
#line 305
      tmp___0 = 2;
    } else {
#line 305
      tmp___0 = 3;
    }
    {
#line 305
    tmp___1 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (n1 + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp + 1)) << (tmp___0 + 1)));
#line 305
    res = tmp___1;
#line 306
    pcb->root0 = (ikptr *)0;
#line 307
    pcb->root1 = (ikptr *)0;
#line 308
    tmp___2 = __gmpn_add((mp_limb_t *)((long )(res + (ikptr )((int )sizeof(ikptr )))),
                         (mp_srcptr )((mp_limb_t *)((long )((s1 - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                         n1, (mp_srcptr )((mp_limb_t *)((long )((s2 - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                         n2);
#line 308
    carry = tmp___2;
    }
#line 314
    if (carry) {
#line 315
      *((ikptr *)((long )res + ((long )((int )sizeof(ikptr )) + xlimbs * (long )((int )sizeof(ikptr )))) + 0) = (ikptr )1;
#line 316
      *((ikptr *)((long )res) + 0) = (ikptr )((((n1 + 1L) << 4) | xsign) | 3L);
#line 320
      return (res + 5UL);
    } else {
#line 322
      *((ikptr *)((long )res) + 0) = (ikptr )(((n1 << 4) | xsign) | 3L);
#line 326
      return (res + 5UL);
    }
  } else {
#line 330
    s1___0 = x;
#line 330
    s2___0 = y;
#line 331
    n1___0 = xlimbs;
#line 331
    n2___0 = ylimbs;
#line 332
    result_sign = xsign;
    {
#line 333
    while (1) {
      while_continue: /* CIL Label */ ;
#line 333
      if (xlimbs == ylimbs) {
#line 333
        if (! (*((ikptr *)((long )x + ((long )(-5 + (int )sizeof(ikptr )) + (xlimbs - 1L) * (long )((int )sizeof(ikptr )))) + 0) == *((ikptr *)((long )y + ((long )(-5 + (int )sizeof(ikptr )) + (xlimbs - 1L) * (long )((int )sizeof(ikptr )))) + 0))) {
#line 333
          goto while_break;
        }
      } else {
#line 333
        goto while_break;
      }
#line 336
      xlimbs --;
#line 337
      ylimbs --;
#line 338
      if (xlimbs == 0L) {
#line 338
        return ((ikptr )0);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 341
    if (xlimbs <= ylimbs) {
#line 342
      if (xlimbs == ylimbs) {
#line 343
        if (*((ikptr *)((long )y + ((long )(-5 + (int )sizeof(ikptr )) + (xlimbs - 1L) * (long )((int )sizeof(ikptr )))) + 0) > *((ikptr *)((long )x + ((long )(-5 + (int )sizeof(ikptr )) + (xlimbs - 1L) * (long )((int )sizeof(ikptr )))) + 0)) {
#line 345
          s1___0 = y;
#line 345
          n1___0 = ylimbs;
#line 346
          s2___0 = x;
#line 346
          n2___0 = xlimbs;
#line 347
          result_sign = ysign;
        }
      } else {
#line 350
        s1___0 = y;
#line 350
        n1___0 = ylimbs;
#line 351
        s2___0 = x;
#line 351
        n2___0 = xlimbs;
#line 352
        result_sign = ysign;
      }
    }
#line 356
    pcb->root0 = & s1___0;
#line 357
    pcb->root1 = & s2___0;
#line 358
    if ((int )sizeof(ikptr ) == 4) {
#line 358
      tmp___3 = 2;
    } else {
#line 358
      tmp___3 = 3;
    }
#line 358
    if ((int )sizeof(ikptr ) == 4) {
#line 358
      tmp___4 = 2;
    } else {
#line 358
      tmp___4 = 3;
    }
    {
#line 358
    tmp___5 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + n1___0 * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___3 + 1)) << (tmp___4 + 1)));
#line 358
    res___0 = tmp___5;
#line 359
    pcb->root0 = (ikptr *)0;
#line 360
    pcb->root1 = (ikptr *)0;
#line 361
    tmp___6 = __gmpn_sub((mp_limb_t *)((long )(res___0 + (ikptr )((int )sizeof(ikptr )))),
                         (mp_srcptr )((mp_limb_t *)((long )((s1___0 - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                         n1___0, (mp_srcptr )((mp_limb_t *)((long )((s2___0 - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                         n2___0);
#line 361
    burrow = tmp___6;
    }
#line 367
    if (burrow) {
      {
#line 368
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Burrow error in bnbn+\n");
#line 369
      exit(-1);
      }
    }
#line 371
    len = n1___0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! (*((ikptr *)((long )res___0 + ((long )((int )sizeof(ikptr )) + (len - 1L) * (long )((int )sizeof(ikptr )))) + 0) == 0UL)) {
#line 372
        goto while_break___0;
      }
#line 373
      len --;
#line 374
      if (len == 0L) {
#line 375
        return ((ikptr )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 378
    if (result_sign == 0L) {
#line 380
      if (len == 1L) {
#line 381
        fst_limb = *((ikptr *)((long )res___0 + (long )((int )sizeof(ikptr ))) + 0);
#line 382
        if ((int )sizeof(ikptr ) == 4) {
#line 382
          tmp___8 = 2;
        } else {
#line 382
          tmp___8 = 3;
        }
#line 382
        if (fst_limb <= 0xffffffffffffffffUL >> (tmp___8 + 1)) {
#line 383
          if ((int )sizeof(ikptr ) == 4) {
#line 383
            tmp___7 = 2;
          } else {
#line 383
            tmp___7 = 3;
          }
#line 383
          return ((ikptr )((long )fst_limb << tmp___7));
        }
      }
#line 386
      *((ikptr *)((long )res___0) + 0) = (ikptr )(((len << 4) | result_sign) | 3L);
#line 390
      return (res___0 + 5UL);
    } else {
#line 393
      if (len == 1L) {
#line 394
        fst_limb___0 = *((ikptr *)((long )res___0 + (long )((int )sizeof(ikptr ))) + 0);
#line 395
        if ((int )sizeof(ikptr ) == 4) {
#line 395
          tmp___10 = 2;
        } else {
#line 395
          tmp___10 = 3;
        }
#line 395
        if (fst_limb___0 <= (0xffffffffffffffffUL >> (tmp___10 + 1)) + 1UL) {
#line 396
          if ((int )sizeof(ikptr ) == 4) {
#line 396
            tmp___9 = 2;
          } else {
#line 396
            tmp___9 = 3;
          }
#line 396
          return ((ikptr )(- ((long )fst_limb___0) << tmp___9));
        }
      }
#line 399
      *((ikptr *)((long )res___0) + 0) = (ikptr )(((len << 4) | result_sign) | 3L);
#line 403
      return (res___0 + 5UL);
    }
  }
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fxfxminus(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  long n1 ;
  int tmp ;
  long n2 ;
  int tmp___0 ;
  long r ;
  int tmp___1 ;
  ikptr bn ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  int tmp___5 ;
  ikptr fxr ;
  int tmp___6 ;
  ikptr bn___0 ;
  int tmp___7 ;
  int tmp___8 ;
  ikptr tmp___9 ;
  int tmp___10 ;

  {
#line 413
  if ((int )sizeof(ikptr ) == 4) {
#line 413
    tmp = 2;
  } else {
#line 413
    tmp = 3;
  }
#line 413
  n1 = (long )x >> tmp;
#line 414
  if ((int )sizeof(ikptr ) == 4) {
#line 414
    tmp___0 = 2;
  } else {
#line 414
    tmp___0 = 3;
  }
#line 414
  n2 = (long )y >> tmp___0;
#line 415
  r = n1 - n2;
#line 416
  if (r >= 0L) {
#line 417
    if ((int )sizeof(ikptr ) == 4) {
#line 417
      tmp___5 = 2;
    } else {
#line 417
      tmp___5 = 3;
    }
#line 417
    if ((unsigned long )r <= 0xffffffffffffffffUL >> (tmp___5 + 1)) {
#line 418
      if ((int )sizeof(ikptr ) == 4) {
#line 418
        tmp___1 = 2;
      } else {
#line 418
        tmp___1 = 3;
      }
#line 418
      return ((ikptr )(r << tmp___1));
    } else {
#line 420
      if ((int )sizeof(ikptr ) == 4) {
#line 420
        tmp___2 = 2;
      } else {
#line 420
        tmp___2 = 3;
      }
#line 420
      if ((int )sizeof(ikptr ) == 4) {
#line 420
        tmp___3 = 2;
      } else {
#line 420
        tmp___3 = 3;
      }
      {
#line 420
      tmp___4 = ik_safe_alloc(pcb, (((((int )sizeof(ikptr ) + (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___2 + 1)) << (tmp___3 + 1));
#line 420
      bn = tmp___4;
#line 421
      *((ikptr *)((long )bn) + 0) = (ikptr )(3 | (1 << 4));
#line 422
      *((ikptr *)((long )bn + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )r;
      }
#line 423
      return (bn + 5UL);
    }
  } else {
#line 426
    if ((int )sizeof(ikptr ) == 4) {
#line 426
      tmp___6 = 2;
    } else {
#line 426
      tmp___6 = 3;
    }
#line 426
    fxr = (ikptr )(r << tmp___6);
#line 427
    if ((int )sizeof(ikptr ) == 4) {
#line 427
      tmp___10 = 2;
    } else {
#line 427
      tmp___10 = 3;
    }
#line 427
    if ((long )fxr >> tmp___10 == r) {
#line 428
      return (fxr);
    } else {
#line 430
      if ((int )sizeof(ikptr ) == 4) {
#line 430
        tmp___7 = 2;
      } else {
#line 430
        tmp___7 = 3;
      }
#line 430
      if ((int )sizeof(ikptr ) == 4) {
#line 430
        tmp___8 = 2;
      } else {
#line 430
        tmp___8 = 3;
      }
      {
#line 430
      tmp___9 = ik_safe_alloc(pcb, (((((int )sizeof(ikptr ) + (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___7 + 1)) << (tmp___8 + 1));
#line 430
      bn___0 = tmp___9;
#line 431
      *((ikptr *)((long )bn___0) + 0) = (ikptr )((3 | (1 << 3)) | (1 << 4));
#line 435
      *((ikptr *)((long )bn___0 + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )(- r);
      }
#line 436
      return (bn___0 + 5UL);
    }
  }
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnnegate(ikptr x , ikpcb *pcb ) 
{ 
  ikptr fst ;
  long limb_count ;
  mp_limb_t limb ;
  int tmp ;
  int tmp___0 ;
  ikptr bn ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;

  {
#line 444
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 445
  limb_count = (long )(fst >> 4);
#line 446
  if (limb_count == 1L) {
#line 447
    if (! (fst & 8UL)) {
#line 449
      limb = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 451
      if ((int )sizeof(ikptr ) == 4) {
#line 451
        tmp___0 = 2;
      } else {
#line 451
        tmp___0 = 3;
      }
#line 451
      if (limb == (0xffffffffffffffffUL >> (tmp___0 + 1)) + 1UL) {
#line 452
        if ((int )sizeof(ikptr ) == 4) {
#line 452
          tmp = 2;
        } else {
#line 452
          tmp = 3;
        }
#line 452
        return ((ikptr )(- ((long )limb) << tmp));
      }
    }
  }
#line 456
  pcb->root0 = & x;
#line 457
  if ((int )sizeof(ikptr ) == 4) {
#line 457
    tmp___1 = 2;
  } else {
#line 457
    tmp___1 = 3;
  }
#line 457
  if ((int )sizeof(ikptr ) == 4) {
#line 457
    tmp___2 = 2;
  } else {
#line 457
    tmp___2 = 3;
  }
  {
#line 457
  tmp___3 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___1 + 1)) << (tmp___2 + 1)));
#line 457
  bn = tmp___3;
#line 458
  pcb->root0 = (ikptr *)0;
#line 459
  memcpy((void */* __restrict  */)((char *)((long )bn) + (int )sizeof(ikptr )), (void const   */* __restrict  */)(((char *)((long )x) - 5) + (int )sizeof(ikptr )),
         (size_t )(limb_count * (long )((int )sizeof(ikptr ))));
#line 462
  *((ikptr *)((long )bn) + 0) = (ikptr )((3L | ((long )(1 << 3) - (8L & (long )fst))) | (limb_count << 4));
  }
#line 466
  return (bn + 5UL);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fxbnminus(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr tmp ;
  ikptr fst ;
  long limb_count ;
  long intx ;
  int tmp___0 ;
  ikptr r ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;
  long carry ;
  mp_limb_t tmp___4 ;
  ikptr r___0 ;
  int tmp___5 ;
  int tmp___6 ;
  ikptr tmp___7 ;
  long borrow ;
  mp_limb_t tmp___8 ;
  long result_size ;
  long tmp___9 ;
  unsigned long last ;
  int tmp___10 ;
  int tmp___11 ;
  ikptr r___1 ;
  int tmp___12 ;
  int tmp___13 ;
  ikptr tmp___14 ;
  long borrow___0 ;
  mp_limb_t tmp___15 ;
  long result_size___0 ;
  long tmp___16 ;
  unsigned long last___0 ;
  int tmp___17 ;
  int tmp___18 ;
  ikptr r___2 ;
  int tmp___19 ;
  int tmp___20 ;
  ikptr tmp___21 ;
  long carry___0 ;
  mp_limb_t tmp___22 ;

  {
#line 471
  if (x == 0UL) {
    {
#line 471
    tmp = ikrt_bnnegate(y, pcb);
    }
#line 471
    return (tmp);
  }
#line 472
  fst = *((ikptr *)((long )y + -5L) + 0);
#line 473
  limb_count = (long )(fst >> 4);
#line 474
  if ((int )sizeof(ikptr ) == 4) {
#line 474
    tmp___0 = 2;
  } else {
#line 474
    tmp___0 = 3;
  }
#line 474
  intx = (long )x >> tmp___0;
#line 475
  if (intx > 0L) {
#line 476
    if (fst & 8UL) {
#line 478
      pcb->root0 = & y;
#line 479
      if ((int )sizeof(ikptr ) == 4) {
#line 479
        tmp___1 = 2;
      } else {
#line 479
        tmp___1 = 3;
      }
#line 479
      if ((int )sizeof(ikptr ) == 4) {
#line 479
        tmp___2 = 2;
      } else {
#line 479
        tmp___2 = 3;
      }
      {
#line 479
      tmp___3 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (limb_count + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___1 + 1)) << (tmp___2 + 1)));
#line 479
      r = tmp___3;
#line 480
      pcb->root0 = (ikptr *)0;
#line 481
      tmp___4 = __gmpn_add_1((mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr )))),
                             (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                             limb_count, (mp_limb_t )intx);
#line 481
      carry = (long )tmp___4;
      }
#line 486
      if (carry) {
#line 487
        *((ikptr *)((long )r + ((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr )))) + 0) = (ikptr )1;
#line 488
        *((ikptr *)((long )r) + 0) = (ikptr )(((limb_count + 1L) << 4) | 3L);
#line 492
        return (r + 5UL);
      } else {
#line 494
        *((ikptr *)((long )r) + 0) = (ikptr )((limb_count << 4) | 3L);
#line 498
        return (r + 5UL);
      }
    } else {
#line 503
      pcb->root0 = & y;
#line 504
      if ((int )sizeof(ikptr ) == 4) {
#line 504
        tmp___5 = 2;
      } else {
#line 504
        tmp___5 = 3;
      }
#line 504
      if ((int )sizeof(ikptr ) == 4) {
#line 504
        tmp___6 = 2;
      } else {
#line 504
        tmp___6 = 3;
      }
      {
#line 504
      tmp___7 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___5 + 1)) << (tmp___6 + 1)));
#line 504
      r___0 = tmp___7;
#line 505
      pcb->root0 = (ikptr *)0;
#line 506
      tmp___8 = __gmpn_sub_1((mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr )))),
                             (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                             limb_count, (mp_limb_t )intx);
#line 506
      borrow = (long )tmp___8;
      }
#line 511
      if (borrow) {
        {
#line 512
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: BUG in borrow3\n");
#line 513
        exit(-1);
        }
      }
#line 515
      if (*((ikptr *)((long )r___0 + ((long )((int )sizeof(ikptr )) + (limb_count - 1L) * (long )((int )sizeof(ikptr )))) + 0)) {
#line 515
        tmp___9 = limb_count;
      } else {
#line 515
        tmp___9 = limb_count - 1L;
      }
#line 515
      result_size = tmp___9;
#line 519
      if (result_size == 0L) {
#line 520
        return ((ikptr )0);
      }
#line 522
      if (result_size == 1L) {
#line 523
        last = *((ikptr *)((long )r___0 + ((long )((int )sizeof(ikptr )) + (result_size - 1L) * (long )((int )sizeof(ikptr )))) + 0);
#line 525
        if ((int )sizeof(ikptr ) == 4) {
#line 525
          tmp___11 = 2;
        } else {
#line 525
          tmp___11 = 3;
        }
#line 525
        if (last <= (0xffffffffffffffffUL >> (tmp___11 + 1)) + 1UL) {
#line 526
          if ((int )sizeof(ikptr ) == 4) {
#line 526
            tmp___10 = 2;
          } else {
#line 526
            tmp___10 = 3;
          }
#line 526
          return ((ikptr )(- ((long )last) << tmp___10));
        }
      }
#line 529
      *((ikptr *)((long )r___0) + 0) = (ikptr )(((result_size << 4) | (long )(1 << 3)) | 3L);
#line 533
      return (r___0 + 5UL);
    }
  } else
#line 537
  if (fst & 8UL) {
#line 539
    pcb->root0 = & y;
#line 540
    if ((int )sizeof(ikptr ) == 4) {
#line 540
      tmp___12 = 2;
    } else {
#line 540
      tmp___12 = 3;
    }
#line 540
    if ((int )sizeof(ikptr ) == 4) {
#line 540
      tmp___13 = 2;
    } else {
#line 540
      tmp___13 = 3;
    }
    {
#line 540
    tmp___14 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___12 + 1)) << (tmp___13 + 1)));
#line 540
    r___1 = tmp___14;
#line 541
    pcb->root0 = (ikptr *)0;
#line 542
    tmp___15 = __gmpn_sub_1((mp_limb_t *)((long )(r___1 + (ikptr )((int )sizeof(ikptr )))),
                            (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                            limb_count, (mp_limb_t )(- intx));
#line 542
    borrow___0 = (long )tmp___15;
    }
#line 547
    if (borrow___0) {
      {
#line 548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: BUG in borrow4\n");
#line 549
      exit(-1);
      }
    }
#line 551
    if (*((ikptr *)((long )r___1 + ((long )((int )sizeof(ikptr )) + (limb_count - 1L) * (long )((int )sizeof(ikptr )))) + 0) == 0UL) {
#line 551
      tmp___16 = limb_count - 1L;
    } else {
#line 551
      tmp___16 = limb_count;
    }
#line 551
    result_size___0 = tmp___16;
#line 555
    if (result_size___0 == 0L) {
#line 556
      return ((ikptr )0);
    }
#line 558
    if (result_size___0 == 1L) {
#line 559
      last___0 = *((ikptr *)((long )r___1 + ((long )((int )sizeof(ikptr )) + (result_size___0 - 1L) * (long )((int )sizeof(ikptr )))) + 0);
#line 561
      if ((int )sizeof(ikptr ) == 4) {
#line 561
        tmp___18 = 2;
      } else {
#line 561
        tmp___18 = 3;
      }
#line 561
      if (last___0 <= 0xffffffffffffffffUL >> (tmp___18 + 1)) {
#line 562
        if ((int )sizeof(ikptr ) == 4) {
#line 562
          tmp___17 = 2;
        } else {
#line 562
          tmp___17 = 3;
        }
#line 562
        return ((ikptr )((long )last___0 << tmp___17));
      }
    }
#line 565
    *((ikptr *)((long )r___1) + 0) = (ikptr )((result_size___0 << 4) | 3L);
#line 569
    return (r___1 + 5UL);
  } else {
#line 572
    pcb->root0 = & y;
#line 573
    if ((int )sizeof(ikptr ) == 4) {
#line 573
      tmp___19 = 2;
    } else {
#line 573
      tmp___19 = 3;
    }
#line 573
    if ((int )sizeof(ikptr ) == 4) {
#line 573
      tmp___20 = 2;
    } else {
#line 573
      tmp___20 = 3;
    }
    {
#line 573
    tmp___21 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (limb_count + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___19 + 1)) << (tmp___20 + 1)));
#line 573
    r___2 = tmp___21;
#line 574
    pcb->root0 = (ikptr *)0;
#line 575
    tmp___22 = __gmpn_add_1((mp_limb_t *)((long )(r___2 + (ikptr )((int )sizeof(ikptr )))),
                            (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                            limb_count, (mp_limb_t )(- intx));
#line 575
    carry___0 = (long )tmp___22;
    }
#line 580
    if (carry___0) {
#line 581
      *((ikptr *)((long )r___2 + ((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr )))) + 0) = (ikptr )1;
#line 582
      *((ikptr *)((long )r___2) + 0) = (ikptr )((((limb_count + 1L) << 4) | (long )(1 << 3)) | 3L);
#line 586
      return (r___2 + 5UL);
    } else {
#line 588
      *((ikptr *)((long )r___2) + 0) = (ikptr )(((limb_count << 4) | (long )(1 << 3)) | 3L);
#line 592
      return (r___2 + 5UL);
    }
  }
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnfxminus(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr fst ;
  long limb_count ;
  long inty ;
  int tmp ;
  ikptr r ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;
  long carry ;
  mp_limb_t tmp___3 ;
  ikptr r___0 ;
  int tmp___4 ;
  int tmp___5 ;
  ikptr tmp___6 ;
  long borrow ;
  mp_limb_t tmp___7 ;
  long result_size ;
  long tmp___8 ;
  unsigned long last ;
  int tmp___9 ;
  int tmp___10 ;
  ikptr r___1 ;
  int tmp___11 ;
  int tmp___12 ;
  ikptr tmp___13 ;
  long borrow___0 ;
  mp_limb_t tmp___14 ;
  long result_size___0 ;
  long tmp___15 ;
  unsigned long last___0 ;
  int tmp___16 ;
  int tmp___17 ;
  ikptr r___2 ;
  int tmp___18 ;
  int tmp___19 ;
  ikptr tmp___20 ;
  long carry___0 ;
  mp_limb_t tmp___21 ;

  {
#line 600
  if (y == 0UL) {
#line 600
    return (x);
  }
#line 601
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 602
  limb_count = (long )(fst >> 4);
#line 603
  if ((int )sizeof(ikptr ) == 4) {
#line 603
    tmp = 2;
  } else {
#line 603
    tmp = 3;
  }
#line 603
  inty = (long )y >> tmp;
#line 604
  if (inty < 0L) {
#line 605
    if (! (fst & 8UL)) {
#line 607
      pcb->root0 = & x;
#line 608
      if ((int )sizeof(ikptr ) == 4) {
#line 608
        tmp___0 = 2;
      } else {
#line 608
        tmp___0 = 3;
      }
#line 608
      if ((int )sizeof(ikptr ) == 4) {
#line 608
        tmp___1 = 2;
      } else {
#line 608
        tmp___1 = 3;
      }
      {
#line 608
      tmp___2 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (limb_count + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1)));
#line 608
      r = tmp___2;
#line 609
      pcb->root0 = (ikptr *)0;
#line 610
      tmp___3 = __gmpn_add_1((mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr )))),
                             (mp_srcptr )((mp_limb_t *)((long )((x - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                             limb_count, (mp_limb_t )(- inty));
#line 610
      carry = (long )tmp___3;
      }
#line 615
      if (carry) {
#line 616
        *((ikptr *)((long )r + ((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr )))) + 0) = (ikptr )1;
#line 617
        *((ikptr *)((long )r) + 0) = (ikptr )(((limb_count + 1L) << 4) | 3L);
#line 621
        return (r + 5UL);
      } else {
#line 623
        *((ikptr *)((long )r) + 0) = (ikptr )((limb_count << 4) | 3L);
#line 627
        return (r + 5UL);
      }
    } else {
#line 632
      pcb->root0 = & x;
#line 633
      if ((int )sizeof(ikptr ) == 4) {
#line 633
        tmp___4 = 2;
      } else {
#line 633
        tmp___4 = 3;
      }
#line 633
      if ((int )sizeof(ikptr ) == 4) {
#line 633
        tmp___5 = 2;
      } else {
#line 633
        tmp___5 = 3;
      }
      {
#line 633
      tmp___6 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___4 + 1)) << (tmp___5 + 1)));
#line 633
      r___0 = tmp___6;
#line 634
      pcb->root0 = (ikptr *)0;
#line 635
      tmp___7 = __gmpn_sub_1((mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr )))),
                             (mp_srcptr )((mp_limb_t *)((long )((x - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                             limb_count, (mp_limb_t )(- inty));
#line 635
      borrow = (long )tmp___7;
      }
#line 640
      if (borrow) {
        {
#line 641
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: BUG in borrow5\n");
#line 642
        exit(-1);
        }
      }
#line 644
      if (*((ikptr *)((long )r___0 + ((long )((int )sizeof(ikptr )) + (limb_count - 1L) * (long )((int )sizeof(ikptr )))) + 0)) {
#line 644
        tmp___8 = limb_count;
      } else {
#line 644
        tmp___8 = limb_count - 1L;
      }
#line 644
      result_size = tmp___8;
#line 648
      if (result_size == 0L) {
#line 649
        return ((ikptr )0);
      }
#line 651
      if (result_size == 1L) {
#line 652
        last = *((ikptr *)((long )r___0 + ((long )((int )sizeof(ikptr )) + (result_size - 1L) * (long )((int )sizeof(ikptr )))) + 0);
#line 654
        if ((int )sizeof(ikptr ) == 4) {
#line 654
          tmp___10 = 2;
        } else {
#line 654
          tmp___10 = 3;
        }
#line 654
        if (last <= (0xffffffffffffffffUL >> (tmp___10 + 1)) + 1UL) {
#line 655
          if ((int )sizeof(ikptr ) == 4) {
#line 655
            tmp___9 = 2;
          } else {
#line 655
            tmp___9 = 3;
          }
#line 655
          return ((ikptr )(- ((long )last) << tmp___9));
        }
      }
#line 658
      *((ikptr *)((long )r___0) + 0) = (ikptr )(((result_size << 4) | (long )(1 << 3)) | 3L);
#line 662
      return (r___0 + 5UL);
    }
  } else
#line 666
  if ((8L & (long )fst) == 0L) {
#line 668
    pcb->root0 = & x;
#line 669
    if ((int )sizeof(ikptr ) == 4) {
#line 669
      tmp___11 = 2;
    } else {
#line 669
      tmp___11 = 3;
    }
#line 669
    if ((int )sizeof(ikptr ) == 4) {
#line 669
      tmp___12 = 2;
    } else {
#line 669
      tmp___12 = 3;
    }
    {
#line 669
    tmp___13 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___11 + 1)) << (tmp___12 + 1)));
#line 669
    r___1 = tmp___13;
#line 670
    pcb->root0 = (ikptr *)0;
#line 671
    tmp___14 = __gmpn_sub_1((mp_limb_t *)((long )(r___1 + (ikptr )((int )sizeof(ikptr )))),
                            (mp_srcptr )((mp_limb_t *)((long )((x - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                            limb_count, (mp_limb_t )inty);
#line 671
    borrow___0 = (long )tmp___14;
    }
#line 676
    if (borrow___0) {
      {
#line 677
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: BUG in borrow6\n");
#line 678
      exit(-1);
      }
    }
#line 680
    if (*((ikptr *)((long )r___1 + ((long )((int )sizeof(ikptr )) + (limb_count - 1L) * (long )((int )sizeof(ikptr )))) + 0) == 0UL) {
#line 680
      tmp___15 = limb_count - 1L;
    } else {
#line 680
      tmp___15 = limb_count;
    }
#line 680
    result_size___0 = tmp___15;
#line 684
    if (result_size___0 == 0L) {
#line 685
      return ((ikptr )0);
    }
#line 687
    if (result_size___0 == 1L) {
#line 688
      last___0 = *((ikptr *)((long )r___1 + ((long )((int )sizeof(ikptr )) + (result_size___0 - 1L) * (long )((int )sizeof(ikptr )))) + 0);
#line 690
      if ((int )sizeof(ikptr ) == 4) {
#line 690
        tmp___17 = 2;
      } else {
#line 690
        tmp___17 = 3;
      }
#line 690
      if (last___0 <= 0xffffffffffffffffUL >> (tmp___17 + 1)) {
#line 691
        if ((int )sizeof(ikptr ) == 4) {
#line 691
          tmp___16 = 2;
        } else {
#line 691
          tmp___16 = 3;
        }
#line 691
        return ((ikptr )((long )last___0 << tmp___16));
      }
    }
#line 694
    *((ikptr *)((long )r___1) + 0) = (ikptr )((result_size___0 << 4) | 3L);
#line 698
    return (r___1 + 5UL);
  } else {
#line 701
    pcb->root0 = & x;
#line 702
    if ((int )sizeof(ikptr ) == 4) {
#line 702
      tmp___18 = 2;
    } else {
#line 702
      tmp___18 = 3;
    }
#line 702
    if ((int )sizeof(ikptr ) == 4) {
#line 702
      tmp___19 = 2;
    } else {
#line 702
      tmp___19 = 3;
    }
    {
#line 702
    tmp___20 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (limb_count + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___18 + 1)) << (tmp___19 + 1)));
#line 702
    r___2 = tmp___20;
#line 703
    pcb->root0 = (ikptr *)0;
#line 704
    tmp___21 = __gmpn_add_1((mp_limb_t *)((long )(r___2 + (ikptr )((int )sizeof(ikptr )))),
                            (mp_srcptr )((mp_limb_t *)((long )((x - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                            limb_count, (mp_limb_t )inty);
#line 704
    carry___0 = (long )tmp___21;
    }
#line 709
    if (carry___0) {
#line 710
      *((ikptr *)((long )r___2 + ((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr )))) + 0) = (ikptr )1;
#line 711
      *((ikptr *)((long )r___2) + 0) = (ikptr )((((limb_count + 1L) << 4) | (long )(1 << 3)) | 3L);
#line 715
      return (r___2 + 5UL);
    } else {
#line 717
      *((ikptr *)((long )r___2) + 0) = (ikptr )(((limb_count << 4) | (long )(1 << 3)) | 3L);
#line 721
      return (r___2 + 5UL);
    }
  }
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnbnminus(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  unsigned long xfst ;
  unsigned long yfst ;
  long xsign ;
  long ysign ;
  long xlimbs ;
  long ylimbs ;
  long n1 ;
  long n2 ;
  ikptr s1 ;
  ikptr s2 ;
  ikptr res ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  mp_limb_t carry ;
  mp_limb_t tmp___2 ;
  ikptr s1___0 ;
  ikptr s2___0 ;
  long n1___0 ;
  long n2___0 ;
  long result_sign ;
  ikptr res___0 ;
  int tmp___3 ;
  int tmp___4 ;
  ikptr tmp___5 ;
  long burrow ;
  mp_limb_t tmp___6 ;
  long len ;
  unsigned long fst_limb ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long fst_limb___0 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 731
  if (x == y) {
#line 731
    return ((ikptr )0);
  }
#line 732
  xfst = *((ikptr *)((long )x + -5L) + 0);
#line 733
  yfst = *((ikptr *)((long )y + -5L) + 0);
#line 734
  xsign = (long )(xfst & 8UL);
#line 735
  ysign = (long )(yfst & 8UL);
#line 736
  xlimbs = (long )(xfst >> 4);
#line 737
  ylimbs = (long )(yfst >> 4);
#line 738
  if (xsign != ysign) {
#line 741
    if (xlimbs >= ylimbs) {
#line 742
      n1 = xlimbs;
#line 742
      n2 = ylimbs;
#line 742
      s1 = x;
#line 742
      s2 = y;
    } else {
#line 744
      n1 = ylimbs;
#line 744
      n2 = xlimbs;
#line 744
      s1 = y;
#line 744
      s2 = x;
    }
#line 746
    pcb->root0 = & s1;
#line 747
    pcb->root1 = & s2;
#line 748
    if ((int )sizeof(ikptr ) == 4) {
#line 748
      tmp = 2;
    } else {
#line 748
      tmp = 3;
    }
#line 748
    if ((int )sizeof(ikptr ) == 4) {
#line 748
      tmp___0 = 2;
    } else {
#line 748
      tmp___0 = 3;
    }
    {
#line 748
    tmp___1 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (n1 + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp + 1)) << (tmp___0 + 1)));
#line 748
    res = tmp___1;
#line 749
    pcb->root0 = (ikptr *)0;
#line 750
    pcb->root1 = (ikptr *)0;
#line 751
    tmp___2 = __gmpn_add((mp_limb_t *)((long )(res + (ikptr )((int )sizeof(ikptr )))),
                         (mp_srcptr )((mp_limb_t *)((long )((s1 - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                         n1, (mp_srcptr )((mp_limb_t *)((long )((s2 - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                         n2);
#line 751
    carry = tmp___2;
    }
#line 757
    if (carry) {
#line 758
      *((ikptr *)((long )res + ((long )((int )sizeof(ikptr )) + xlimbs * (long )((int )sizeof(ikptr )))) + 0) = (ikptr )1;
#line 759
      *((ikptr *)((long )res) + 0) = (ikptr )((((n1 + 1L) << 4) | xsign) | 3L);
#line 763
      return (res + 5UL);
    } else {
#line 765
      *((ikptr *)((long )res) + 0) = (ikptr )(((n1 << 4) | xsign) | 3L);
#line 769
      return (res + 5UL);
    }
  } else {
#line 774
    if (xlimbs == ylimbs) {
      {
#line 775
      while (1) {
        while_continue: /* CIL Label */ ;
#line 775
        if (! (*((ikptr *)((long )x + ((long )(-5 + (int )sizeof(ikptr )) + (xlimbs - 1L) * (long )((int )sizeof(ikptr )))) + 0) == *((ikptr *)((long )y + ((long )(-5 + (int )sizeof(ikptr )) + (xlimbs - 1L) * (long )((int )sizeof(ikptr )))) + 0))) {
#line 775
          goto while_break;
        }
#line 777
        xlimbs --;
#line 778
        if (xlimbs == 0L) {
#line 778
          return ((ikptr )0);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 780
      ylimbs = xlimbs;
    }
#line 782
    s1___0 = x;
#line 782
    s2___0 = y;
#line 783
    n1___0 = xlimbs;
#line 783
    n2___0 = ylimbs;
#line 784
    result_sign = xsign;
#line 786
    if (xlimbs <= ylimbs) {
#line 787
      if (xlimbs == ylimbs) {
#line 788
        if (*((ikptr *)((long )y + ((long )(-5 + (int )sizeof(ikptr )) + (xlimbs - 1L) * (long )((int )sizeof(ikptr )))) + 0) > *((ikptr *)((long )x + ((long )(-5 + (int )sizeof(ikptr )) + (xlimbs - 1L) * (long )((int )sizeof(ikptr )))) + 0)) {
#line 790
          s1___0 = y;
#line 790
          n1___0 = ylimbs;
#line 791
          s2___0 = x;
#line 791
          n2___0 = xlimbs;
#line 792
          result_sign = (long )(1 << 3) - ysign;
        }
      } else {
#line 795
        s1___0 = y;
#line 795
        n1___0 = ylimbs;
#line 796
        s2___0 = x;
#line 796
        n2___0 = xlimbs;
#line 797
        result_sign = (long )(1 << 3) - ysign;
      }
    }
#line 801
    pcb->root0 = & s1___0;
#line 802
    pcb->root1 = & s2___0;
#line 803
    if ((int )sizeof(ikptr ) == 4) {
#line 803
      tmp___3 = 2;
    } else {
#line 803
      tmp___3 = 3;
    }
#line 803
    if ((int )sizeof(ikptr ) == 4) {
#line 803
      tmp___4 = 2;
    } else {
#line 803
      tmp___4 = 3;
    }
    {
#line 803
    tmp___5 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + n1___0 * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___3 + 1)) << (tmp___4 + 1)));
#line 803
    res___0 = tmp___5;
#line 804
    bzero((void *)(res___0 + (ikptr )((int )sizeof(ikptr ))), (size_t )(n1___0 * (long )((int )sizeof(ikptr ))));
#line 805
    pcb->root0 = (ikptr *)0;
#line 806
    pcb->root1 = (ikptr *)0;
#line 807
    tmp___6 = __gmpn_sub((mp_limb_t *)((long )(res___0 + (ikptr )((int )sizeof(ikptr )))),
                         (mp_srcptr )((mp_limb_t *)((long )((s1___0 - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                         n1___0, (mp_srcptr )((mp_limb_t *)((long )((s2___0 - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                         n2___0);
#line 807
    burrow = (long )tmp___6;
    }
#line 813
    if (burrow) {
      {
#line 814
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: Burrow error in bnbn-\n");
#line 815
      exit(-1);
      }
    }
#line 817
    len = n1___0;
    {
#line 818
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 818
      if (! (*((ikptr *)((long )res___0 + ((long )((int )sizeof(ikptr )) + (len - 1L) * (long )((int )sizeof(ikptr )))) + 0) == 0UL)) {
#line 818
        goto while_break___0;
      }
#line 819
      len --;
#line 820
      if (len == 0L) {
#line 821
        return ((ikptr )0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 824
    if (result_sign == 0L) {
#line 826
      if (len == 1L) {
#line 827
        fst_limb = *((ikptr *)((long )res___0 + (long )((int )sizeof(ikptr ))) + 0);
#line 829
        if ((int )sizeof(ikptr ) == 4) {
#line 829
          tmp___8 = 2;
        } else {
#line 829
          tmp___8 = 3;
        }
#line 829
        if (fst_limb <= 0xffffffffffffffffUL >> (tmp___8 + 1)) {
#line 830
          if ((int )sizeof(ikptr ) == 4) {
#line 830
            tmp___7 = 2;
          } else {
#line 830
            tmp___7 = 3;
          }
#line 830
          return ((ikptr )((long )fst_limb << tmp___7));
        }
      }
#line 833
      *((ikptr *)((long )res___0) + 0) = (ikptr )(((len << 4) | result_sign) | 3L);
#line 837
      return (res___0 + 5UL);
    } else {
#line 840
      if (len == 1L) {
#line 841
        fst_limb___0 = *((ikptr *)((long )res___0 + (long )((int )sizeof(ikptr ))) + 0);
#line 843
        if ((int )sizeof(ikptr ) == 4) {
#line 843
          tmp___10 = 2;
        } else {
#line 843
          tmp___10 = 3;
        }
#line 843
        if (fst_limb___0 <= (0xffffffffffffffffUL >> (tmp___10 + 1)) + 1UL) {
#line 844
          if ((int )sizeof(ikptr ) == 4) {
#line 844
            tmp___9 = 2;
          } else {
#line 844
            tmp___9 = 3;
          }
#line 844
          return ((ikptr )(- ((long )fst_limb___0) << tmp___9));
        }
      }
#line 847
      *((ikptr *)((long )res___0) + 0) = (ikptr )(((len << 4) | result_sign) | 3L);
#line 851
      return (res___0 + 5UL);
    }
  }
}
}
#line 857 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fxfxmult(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  long n1 ;
  int tmp ;
  long n2 ;
  int tmp___0 ;
  mp_limb_t lo ;
  mp_limb_t s1 ;
  mp_limb_t s2 ;
  long sign ;
  mp_limb_t hi ;
  mp_limb_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ikptr r ;
  ikptr tmp___6 ;
  ikptr r___0 ;
  int tmp___7 ;
  int tmp___8 ;
  ikptr tmp___9 ;

  {
#line 859
  if ((int )sizeof(ikptr ) == 4) {
#line 859
    tmp = 2;
  } else {
#line 859
    tmp = 3;
  }
#line 859
  n1 = (long )x >> tmp;
#line 860
  if ((int )sizeof(ikptr ) == 4) {
#line 860
    tmp___0 = 2;
  } else {
#line 860
    tmp___0 = 3;
  }
#line 860
  n2 = (long )y >> tmp___0;
#line 861
  lo = (mp_limb_t )0;
#line 862
  s1 = (mp_limb_t )n1;
#line 863
  s2 = (mp_limb_t )n2;
#line 864
  sign = 0L;
#line 865
  if (n1 < 0L) {
#line 866
    s1 = (mp_limb_t )(- n1);
#line 867
    sign = 1L - sign;
  }
#line 869
  if (n2 < 0L) {
#line 870
    s2 = (mp_limb_t )(- n2);
#line 871
    sign = 1L - sign;
  }
  {
#line 873
  tmp___1 = __gmpn_mul_1(& lo, (mp_srcptr )(& s1), (mp_size_t )1, s2);
#line 873
  hi = tmp___1;
  }
#line 874
  if (hi == 0UL) {
#line 875
    if (sign) {
#line 876
      if ((int )sizeof(ikptr ) == 4) {
#line 876
        tmp___3 = 2;
      } else {
#line 876
        tmp___3 = 3;
      }
#line 876
      if (lo <= (0xffffffffffffffffUL >> (tmp___3 + 1)) + 1UL) {
#line 877
        if ((int )sizeof(ikptr ) == 4) {
#line 877
          tmp___2 = 2;
        } else {
#line 877
          tmp___2 = 3;
        }
#line 877
        return ((ikptr )(- ((long )lo) << tmp___2));
      }
    } else {
#line 880
      if ((int )sizeof(ikptr ) == 4) {
#line 880
        tmp___5 = 2;
      } else {
#line 880
        tmp___5 = 3;
      }
#line 880
      if (lo <= 0xffffffffffffffffUL >> (tmp___5 + 1)) {
#line 881
        if ((int )sizeof(ikptr ) == 4) {
#line 881
          tmp___4 = 2;
        } else {
#line 881
          tmp___4 = 3;
        }
#line 881
        return ((ikptr )((long )lo << tmp___4));
      }
    }
    {
#line 884
    tmp___6 = ik_safe_alloc(pcb, (int )sizeof(ikptr ) + (int )sizeof(ikptr ));
#line 884
    r = tmp___6;
#line 885
    *((ikptr *)((long )r) + 0) = (ikptr )((3L | (sign << 3)) | (long )(1 << 4));
#line 889
    *((ikptr *)((long )r + (long )((int )sizeof(ikptr ))) + 0) = lo;
    }
#line 890
    return (r + 5UL);
  } else {
#line 892
    if ((int )sizeof(ikptr ) == 4) {
#line 892
      tmp___7 = 2;
    } else {
#line 892
      tmp___7 = 3;
    }
#line 892
    if ((int )sizeof(ikptr ) == 4) {
#line 892
      tmp___8 = 2;
    } else {
#line 892
      tmp___8 = 3;
    }
    {
#line 892
    tmp___9 = ik_safe_alloc(pcb, (((((int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___7 + 1)) << (tmp___8 + 1));
#line 892
    r___0 = tmp___9;
#line 893
    *((ikptr *)((long )r___0) + 0) = (ikptr )((3L | (sign << 3)) | (long )(2 << 4));
#line 897
    *((ikptr *)((long )r___0 + (long )((int )sizeof(ikptr ))) + 0) = lo;
#line 898
    *((ikptr *)((long )r___0 + (long )((int )sizeof(ikptr ) + (int )sizeof(ikptr ))) + 0) = hi;
    }
#line 899
    return (r___0 + 5UL);
  }
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr normalize_bignum(long limbs , int sign , ikptr r ) 
{ 
  mp_limb_t last ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
#line 905
    if (! (*((ikptr *)((long )r + ((long )((int )sizeof(ikptr )) + (limbs - 1L) * (long )((int )sizeof(ikptr )))) + 0) == 0UL)) {
#line 905
      goto while_break;
    }
#line 906
    limbs --;
#line 907
    if (limbs == 0L) {
#line 907
      return ((ikptr )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  if (limbs == 1L) {
#line 910
    last = *((ikptr *)((long )r + (long )((int )sizeof(ikptr ))) + 0);
#line 911
    if (sign == 0) {
#line 912
      if ((int )sizeof(ikptr ) == 4) {
#line 912
        tmp___0 = 2;
      } else {
#line 912
        tmp___0 = 3;
      }
#line 912
      if (last <= 0xffffffffffffffffUL >> (tmp___0 + 1)) {
#line 913
        if ((int )sizeof(ikptr ) == 4) {
#line 913
          tmp = 2;
        } else {
#line 913
          tmp = 3;
        }
#line 913
        return ((ikptr )((long )last << tmp));
      }
    } else {
#line 916
      if ((int )sizeof(ikptr ) == 4) {
#line 916
        tmp___2 = 2;
      } else {
#line 916
        tmp___2 = 3;
      }
#line 916
      if (last <= (0xffffffffffffffffUL >> (tmp___2 + 1)) + 1UL) {
#line 917
        if ((int )sizeof(ikptr ) == 4) {
#line 917
          tmp___1 = 2;
        } else {
#line 917
          tmp___1 = 3;
        }
#line 917
        return ((ikptr )((long )(- last) << tmp___1));
      }
    }
  }
#line 921
  *((ikptr *)((long )r) + 0) = (ikptr )((long )(3 | sign) | (limbs << 4));
#line 922
  return (r + 5UL);
}
}
#line 926 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fxbnmult(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  long n2 ;
  int tmp ;
  mp_limb_t s2 ;
  long tmp___0 ;
  ikptr fst ;
  long limb_count ;
  ikptr r ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;
  mp_limb_t hi ;
  mp_limb_t tmp___4 ;
  long sign ;
  long tmp___5 ;
  ikptr tmp___6 ;

  {
#line 928
  if ((int )sizeof(ikptr ) == 4) {
#line 928
    tmp = 2;
  } else {
#line 928
    tmp = 3;
  }
#line 928
  n2 = (long )x >> tmp;
#line 929
  if (n2 == 0L) {
#line 929
    return ((ikptr )0);
  }
#line 930
  if (n2 > 0L) {
#line 930
    tmp___0 = n2;
  } else {
#line 930
    tmp___0 = - n2;
  }
#line 930
  s2 = (mp_limb_t )tmp___0;
#line 931
  fst = *((ikptr *)((long )y + -5L) + 0);
#line 932
  limb_count = (long )(fst >> 4);
#line 933
  pcb->root0 = & y;
#line 934
  if ((int )sizeof(ikptr ) == 4) {
#line 934
    tmp___1 = 2;
  } else {
#line 934
    tmp___1 = 3;
  }
#line 934
  if ((int )sizeof(ikptr ) == 4) {
#line 934
    tmp___2 = 2;
  } else {
#line 934
    tmp___2 = 3;
  }
  {
#line 934
  tmp___3 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (limb_count + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___1 + 1)) << (tmp___2 + 1)));
#line 934
  r = tmp___3;
#line 935
  pcb->root0 = (ikptr *)0;
#line 936
  tmp___4 = __gmpn_mul_1((mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr )))),
                         (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                         limb_count, s2);
#line 936
  hi = tmp___4;
#line 940
  *((ikptr *)((long )r + ((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr )))) + 0) = hi;
  }
#line 941
  if (n2 > 0L) {
#line 941
    tmp___5 = 8L & (long )fst;
  } else {
#line 941
    tmp___5 = (long )(1 << 3) - (8L & (long )fst);
  }
  {
#line 941
  sign = tmp___5;
#line 945
  tmp___6 = normalize_bignum(limb_count + 1L, (int )sign, r);
  }
#line 945
  return (tmp___6);
}
}
#line 948 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnbnmult(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  long f1 ;
  long f2 ;
  long n1 ;
  long n2 ;
  long nr ;
  ikptr bn ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  mp_limb_t r ;
  long sign ;
  long tmp___2 ;
  ikptr tmp___3 ;

  {
#line 950
  f1 = (long )*((ikptr *)((long )x + -5L) + 0);
#line 951
  f2 = (long )*((ikptr *)((long )y + -5L) + 0);
#line 952
  n1 = (long )((unsigned long )f1 >> 4);
#line 953
  n2 = (long )((unsigned long )f2 >> 4);
#line 954
  nr = n1 + n2;
#line 955
  pcb->root0 = & x;
#line 956
  pcb->root1 = & y;
#line 957
  if ((int )sizeof(ikptr ) == 4) {
#line 957
    tmp = 2;
  } else {
#line 957
    tmp = 3;
  }
#line 957
  if ((int )sizeof(ikptr ) == 4) {
#line 957
    tmp___0 = 2;
  } else {
#line 957
    tmp___0 = 3;
  }
  {
#line 957
  tmp___1 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + nr * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp + 1)) << (tmp___0 + 1)));
#line 957
  bn = tmp___1;
#line 958
  pcb->root0 = (ikptr *)0;
#line 959
  pcb->root1 = (ikptr *)0;
  }
#line 961
  if (n1 >= n2) {
    {
#line 962
    r = __gmpn_mul((mp_limb_t *)((long )(bn + (ikptr )((int )sizeof(ikptr )))), (mp_srcptr )((mp_limb_t *)((long )((x - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                   n1, (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                   n2);
    }
  } else {
    {
#line 968
    r = __gmpn_mul((mp_limb_t *)((long )(bn + (ikptr )((int )sizeof(ikptr )))), (mp_srcptr )((mp_limb_t *)((long )((y - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                   n2, (mp_srcptr )((mp_limb_t *)((long )((x - 5UL) + (ikptr )((int )sizeof(ikptr ))))),
                   n1);
    }
  }
#line 974
  if (8L & f1) {
#line 974
    tmp___2 = (long )(1 << 3) - (8L & f2);
  } else {
#line 974
    tmp___2 = 8L & f2;
  }
  {
#line 974
  sign = tmp___2;
#line 978
  tmp___3 = normalize_bignum(nr, (int )sign, bn);
  }
#line 978
  return (tmp___3);
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnbncomp(ikptr bn1 , ikptr bn2 ) 
{ 
  ikptr f1 ;
  ikptr f2 ;
  long n1 ;
  long n2 ;
  int tmp ;
  int tmp___0 ;
  long i ;
  mp_limb_t t1 ;
  mp_limb_t t2 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long n1___0 ;
  long n2___0 ;
  int tmp___5 ;
  int tmp___6 ;
  long i___0 ;
  mp_limb_t t1___0 ;
  mp_limb_t t2___0 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 986
  f1 = *((ikptr *)((long )bn1 + -5L) + 0);
#line 987
  f2 = *((ikptr *)((long )bn2 + -5L) + 0);
#line 988
  if (f1 & 8UL) {
#line 989
    if (f2 & 8UL) {
#line 991
      n1 = (long )(f1 >> 4);
#line 992
      n2 = (long )(f2 >> 4);
#line 993
      if (n1 < n2) {
#line 994
        if ((int )sizeof(ikptr ) == 4) {
#line 994
          tmp = 2;
        } else {
#line 994
          tmp = 3;
        }
#line 994
        return ((ikptr )(1L << tmp));
      } else
#line 995
      if (n1 > n2) {
#line 996
        if ((int )sizeof(ikptr ) == 4) {
#line 996
          tmp___0 = 2;
        } else {
#line 996
          tmp___0 = 3;
        }
#line 996
        return ((ikptr )(-1L << tmp___0));
      } else {
#line 999
        i = n1 - 1L;
        {
#line 999
        while (1) {
          while_continue: /* CIL Label */ ;
#line 999
          if (! (i >= 0L)) {
#line 999
            goto while_break;
          }
#line 1000
          t1 = *((ikptr *)((long )bn1 + ((long )((int )sizeof(ikptr ) - 5) + i * (long )((int )sizeof(ikptr )))) + 0);
#line 1002
          t2 = *((ikptr *)((long )bn2 + ((long )((int )sizeof(ikptr ) - 5) + i * (long )((int )sizeof(ikptr )))) + 0);
#line 1004
          if (t1 < t2) {
#line 1005
            if ((int )sizeof(ikptr ) == 4) {
#line 1005
              tmp___1 = 2;
            } else {
#line 1005
              tmp___1 = 3;
            }
#line 1005
            return ((ikptr )(1L << tmp___1));
          } else
#line 1006
          if (t1 > t2) {
#line 1007
            if ((int )sizeof(ikptr ) == 4) {
#line 1007
              tmp___2 = 2;
            } else {
#line 1007
              tmp___2 = 3;
            }
#line 1007
            return ((ikptr )(-1L << tmp___2));
          }
#line 999
          i --;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 1011
      return ((ikptr )0);
    } else {
#line 1014
      if ((int )sizeof(ikptr ) == 4) {
#line 1014
        tmp___3 = 2;
      } else {
#line 1014
        tmp___3 = 3;
      }
#line 1014
      return ((ikptr )(-1L << tmp___3));
    }
  } else
#line 1017
  if (f2 & 8UL) {
#line 1019
    if ((int )sizeof(ikptr ) == 4) {
#line 1019
      tmp___4 = 2;
    } else {
#line 1019
      tmp___4 = 3;
    }
#line 1019
    return ((ikptr )(1L << tmp___4));
  } else {
#line 1022
    n1___0 = (long )(f1 >> 4);
#line 1023
    n2___0 = (long )(f2 >> 4);
#line 1024
    if (n1___0 < n2___0) {
#line 1025
      if ((int )sizeof(ikptr ) == 4) {
#line 1025
        tmp___5 = 2;
      } else {
#line 1025
        tmp___5 = 3;
      }
#line 1025
      return ((ikptr )(-1L << tmp___5));
    } else
#line 1026
    if (n1___0 > n2___0) {
#line 1027
      if ((int )sizeof(ikptr ) == 4) {
#line 1027
        tmp___6 = 2;
      } else {
#line 1027
        tmp___6 = 3;
      }
#line 1027
      return ((ikptr )(1L << tmp___6));
    } else {
#line 1030
      i___0 = n1___0 - 1L;
      {
#line 1030
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1030
        if (! (i___0 >= 0L)) {
#line 1030
          goto while_break___0;
        }
#line 1031
        t1___0 = *((ikptr *)((long )bn1 + ((long )((int )sizeof(ikptr ) - 5) + i___0 * (long )((int )sizeof(ikptr )))) + 0);
#line 1033
        t2___0 = *((ikptr *)((long )bn2 + ((long )((int )sizeof(ikptr ) - 5) + i___0 * (long )((int )sizeof(ikptr )))) + 0);
#line 1035
        if (t1___0 < t2___0) {
#line 1036
          if ((int )sizeof(ikptr ) == 4) {
#line 1036
            tmp___7 = 2;
          } else {
#line 1036
            tmp___7 = 3;
          }
#line 1036
          return ((ikptr )(-1L << tmp___7));
        } else
#line 1037
        if (t1___0 > t2___0) {
#line 1038
          if ((int )sizeof(ikptr ) == 4) {
#line 1038
            tmp___8 = 2;
          } else {
#line 1038
            tmp___8 = 3;
          }
#line 1038
          return ((ikptr )(1L << tmp___8));
        }
#line 1030
        i___0 --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1042
    return ((ikptr )0);
  }
}
}
#line 1060 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void copy_limbs(mp_limb_t *src , mp_limb_t *dst , int n1 , int n2 ) 
{ 


  {
  {
#line 1062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1062
    if (! (n1 < n2)) {
#line 1062
      goto while_break;
    }
#line 1063
    *(dst + n1) = *(src + n1);
#line 1064
    n1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1066
  return;
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void bits_compliment(mp_limb_t *src , mp_limb_t *dst , long n ) 
{ 
  mp_limb_t carry ;
  long i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1070
  carry = (mp_limb_t )1;
#line 1072
  i = 0L;
  {
#line 1072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1072
    if (! (i < n)) {
#line 1072
      goto while_break;
    }
#line 1073
    d = *(src + i);
#line 1074
    c = carry + ~ d;
#line 1075
    *(dst + i) = c;
#line 1076
    if (carry) {
#line 1076
      if (! d) {
#line 1076
        tmp = 1;
      } else {
#line 1076
        tmp = 0;
      }
    } else {
#line 1076
      tmp = 0;
    }
#line 1076
    carry = (mp_limb_t )tmp;
#line 1072
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1078
  return;
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void bits_compliment2(mp_limb_t *src , mp_limb_t *dst , int n1 , int n2 ) 
{ 
  mp_limb_t carry ;
  int i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;
  mp_limb_t d___0 ;
  mp_limb_t c___0 ;
  int tmp___0 ;

  {
#line 1082
  carry = (mp_limb_t )1;
#line 1084
  i = 0;
  {
#line 1084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1084
    if (! (i < n1)) {
#line 1084
      goto while_break;
    }
#line 1085
    d = *(src + i);
#line 1086
    c = carry + ~ d;
#line 1087
    *(dst + i) = c;
#line 1088
    if (carry) {
#line 1088
      if (! d) {
#line 1088
        tmp = 1;
      } else {
#line 1088
        tmp = 0;
      }
    } else {
#line 1088
      tmp = 0;
    }
#line 1088
    carry = (mp_limb_t )tmp;
#line 1084
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1090
  i = n1;
  {
#line 1090
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1090
    if (! (i < n2)) {
#line 1090
      goto while_break___0;
    }
#line 1091
    d___0 = (mp_limb_t )0;
#line 1092
    c___0 = carry + ~ d___0;
#line 1093
    *(dst + i) = c___0;
#line 1094
    if (carry) {
#line 1094
      if (! d___0) {
#line 1094
        tmp___0 = 1;
      } else {
#line 1094
        tmp___0 = 0;
      }
    } else {
#line 1094
      tmp___0 = 0;
    }
#line 1094
    carry = (mp_limb_t )tmp___0;
#line 1090
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1096
  return;
}
}
#line 1098 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int bits_compliment_carry(mp_limb_t *src , mp_limb_t *dst , int n1 , int n2 ,
                                 mp_limb_t carry ) 
{ 
  int i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1101
  i = n1;
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1101
    if (! (i < n2)) {
#line 1101
      goto while_break;
    }
#line 1102
    d = *(src + i);
#line 1103
    c = carry + ~ d;
#line 1104
    *(dst + i) = c;
#line 1105
    if (carry) {
#line 1105
      if (! d) {
#line 1105
        tmp = 1;
      } else {
#line 1105
        tmp = 0;
      }
    } else {
#line 1105
      tmp = 0;
    }
#line 1105
    carry = (mp_limb_t )tmp;
#line 1101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1107
  return ((int )carry);
}
}
#line 1113 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void bits_compliment_with_carry(mp_limb_t *src , mp_limb_t *dst , long n ,
                                       long carry ) 
{ 
  long i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1116
  i = 0L;
  {
#line 1116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1116
    if (! (i < n)) {
#line 1116
      goto while_break;
    }
#line 1117
    d = *(src + i);
#line 1118
    c = (mp_limb_t )carry + ~ d;
#line 1119
    *(dst + i) = c;
#line 1120
    if (carry) {
#line 1120
      if (! d) {
#line 1120
        tmp = 1;
      } else {
#line 1120
        tmp = 0;
      }
    } else {
#line 1120
      tmp = 0;
    }
#line 1120
    carry = (long )tmp;
#line 1116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1122
  return;
}
}
#line 1124 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void bits_compliment_logand(mp_limb_t *s1 , mp_limb_t *s2 , mp_limb_t *dst ,
                                   int n ) 
{ 
  int carry ;
  int i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1126
  carry = 1;
#line 1128
  i = 0;
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if (! (i < n)) {
#line 1128
      goto while_break;
    }
#line 1129
    d = *(s1 + i);
#line 1130
    c = (mp_limb_t )carry + ~ d;
#line 1131
    *(dst + i) = c & *(s2 + i);
#line 1132
    if (carry) {
#line 1132
      if (! d) {
#line 1132
        tmp = 1;
      } else {
#line 1132
        tmp = 0;
      }
    } else {
#line 1132
      tmp = 0;
    }
#line 1132
    carry = tmp;
#line 1128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1134
  return;
}
}
#line 1138 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int bits_compliment_logor(mp_limb_t *s1 , mp_limb_t *s2 , mp_limb_t *dst ,
                                 int n ) 
{ 
  int carry ;
  int i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1140
  carry = 1;
#line 1142
  i = 0;
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1142
    if (! (i < n)) {
#line 1142
      goto while_break;
    }
#line 1143
    d = *(s1 + i);
#line 1144
    c = (mp_limb_t )carry + ~ d;
#line 1145
    *(dst + i) = c | *(s2 + i);
#line 1146
    if (carry) {
#line 1146
      if (! d) {
#line 1146
        tmp = 1;
      } else {
#line 1146
        tmp = 0;
      }
    } else {
#line 1146
      tmp = 0;
    }
#line 1146
    carry = tmp;
#line 1142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1148
  return (carry);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static long bits_carry(mp_limb_t *s , int n ) 
{ 
  int i ;

  {
#line 1164
  i = 0;
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1164
    if (! (i < n)) {
#line 1164
      goto while_break;
    }
#line 1165
    if (*(s + i) != 0UL) {
#line 1166
      return (0L);
    }
#line 1164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1169
  return (1L);
}
}
#line 1172 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnlognot(ikptr x , ikpcb *pcb ) 
{ 
  ikptr fst ;
  long n ;
  ikptr r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  mp_limb_t *s1 ;
  mp_limb_t *rd ;
  int i ;
  ikptr tmp___2 ;
  long i___0 ;
  mp_limb_t *s1___0 ;
  ikptr r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  ikptr tmp___5 ;
  ikptr r___1 ;
  int tmp___6 ;
  int tmp___7 ;
  ikptr tmp___8 ;
  mp_limb_t *s1___1 ;
  mp_limb_t *rd___0 ;
  int j ;

  {
#line 1174
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 1175
  n = (long )(fst >> 4);
#line 1176
  if (fst & 8UL) {
#line 1178
    pcb->root0 = & x;
#line 1179
    if ((int )sizeof(ikptr ) == 4) {
#line 1179
      tmp = 2;
    } else {
#line 1179
      tmp = 3;
    }
#line 1179
    if ((int )sizeof(ikptr ) == 4) {
#line 1179
      tmp___0 = 2;
    } else {
#line 1179
      tmp___0 = 3;
    }
    {
#line 1179
    tmp___1 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + n * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp + 1)) << (tmp___0 + 1)));
#line 1179
    r = tmp___1;
#line 1180
    pcb->root0 = (ikptr *)0;
#line 1181
    s1 = (mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1182
    rd = (mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr ))));
#line 1184
    i = 0;
    }
    {
#line 1184
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1184
      if ((long )i < n) {
#line 1184
        if (! (*(s1 + i) == 0UL)) {
#line 1184
          goto while_break;
        }
      } else {
#line 1184
        goto while_break;
      }
#line 1185
      *(rd + i) = (mp_limb_t )-1;
#line 1184
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1187
    *(rd + i) = *(s1 + i) - 1UL;
#line 1188
    i ++;
    {
#line 1188
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1188
      if (! ((long )i < n)) {
#line 1188
        goto while_break___0;
      }
#line 1189
      *(rd + i) = *(s1 + i);
#line 1188
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1191
    tmp___2 = normalize_bignum(n, 0, r);
    }
#line 1191
    return (tmp___2);
  } else {
#line 1195
    s1___0 = (mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1196
    i___0 = 0L;
    {
#line 1196
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1196
      if (i___0 < n) {
#line 1196
        if (! (*(s1___0 + i___0) == 0xffffffffffffffffUL)) {
#line 1196
          goto while_break___1;
        }
      } else {
#line 1196
        goto while_break___1;
      }
#line 1196
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1197
    if (i___0 == n) {
#line 1198
      pcb->root0 = & x;
#line 1199
      if ((int )sizeof(ikptr ) == 4) {
#line 1199
        tmp___3 = 2;
      } else {
#line 1199
        tmp___3 = 3;
      }
#line 1199
      if ((int )sizeof(ikptr ) == 4) {
#line 1199
        tmp___4 = 2;
      } else {
#line 1199
        tmp___4 = 3;
      }
      {
#line 1199
      tmp___5 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (n + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___3 + 1)) << (tmp___4 + 1)));
#line 1199
      r___0 = tmp___5;
#line 1200
      pcb->root0 = (ikptr *)0;
#line 1201
      bzero((void *)((char *)((long )r___0) + (int )sizeof(ikptr )), (size_t )(n * (long )((int )sizeof(ikptr ))));
#line 1202
      *((mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr )))) + n) = (mp_limb_t )1;
#line 1203
      *((ikptr *)((long )r___0) + 0) = (ikptr )((long )(3 | (1 << 3)) | ((n + 1L) << 4));
      }
#line 1205
      return (r___0 + 5UL);
    } else {
#line 1207
      pcb->root0 = & x;
#line 1208
      if ((int )sizeof(ikptr ) == 4) {
#line 1208
        tmp___6 = 2;
      } else {
#line 1208
        tmp___6 = 3;
      }
#line 1208
      if ((int )sizeof(ikptr ) == 4) {
#line 1208
        tmp___7 = 2;
      } else {
#line 1208
        tmp___7 = 3;
      }
      {
#line 1208
      tmp___8 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + n * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___6 + 1)) << (tmp___7 + 1)));
#line 1208
      r___1 = tmp___8;
#line 1209
      pcb->root0 = (ikptr *)0;
#line 1210
      s1___1 = (mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1211
      rd___0 = (mp_limb_t *)((long )(r___1 + (ikptr )((int )sizeof(ikptr ))));
#line 1213
      j = 0;
      }
      {
#line 1213
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1213
        if (! ((long )j < i___0)) {
#line 1213
          goto while_break___2;
        }
#line 1213
        *(rd___0 + j) = (mp_limb_t )0;
#line 1213
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1214
      *(rd___0 + i___0) = *(s1___1 + i___0) + 1UL;
#line 1215
      j = (int )(i___0 + 1L);
      {
#line 1215
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1215
        if (! ((long )j < n)) {
#line 1215
          goto while_break___3;
        }
#line 1215
        *(rd___0 + j) = *(s1___1 + j);
#line 1215
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1216
      *((ikptr *)((long )r___1) + 0) = (ikptr )((long )(3 | (1 << 3)) | (n << 4));
#line 1218
      return (r___1 + 5UL);
    }
  }
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fxbnlogand(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  long n1 ;
  int tmp ;
  ikptr fst ;
  int tmp___0 ;
  int tmp___1 ;
  long len ;
  ikptr r ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  mp_limb_t *s2 ;
  mp_limb_t *s ;
  ikptr tmp___5 ;
  long len___0 ;
  ikptr r___0 ;
  int tmp___6 ;
  int tmp___7 ;
  ikptr tmp___8 ;
  int i ;

  {
#line 1226
  if ((int )sizeof(ikptr ) == 4) {
#line 1226
    tmp = 2;
  } else {
#line 1226
    tmp = 3;
  }
#line 1226
  n1 = (long )x >> tmp;
#line 1227
  fst = *((ikptr *)((long )y + -5L) + 0);
#line 1228
  if (n1 >= 0L) {
#line 1230
    if (fst & 8UL) {
#line 1232
      if ((int )sizeof(ikptr ) == 4) {
#line 1232
        tmp___0 = 2;
      } else {
#line 1232
        tmp___0 = 3;
      }
#line 1232
      return ((ikptr )((n1 & (1L + ~ ((long )*((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 5)) + 0)))) << tmp___0));
    } else {
#line 1235
      if ((int )sizeof(ikptr ) == 4) {
#line 1235
        tmp___1 = 2;
      } else {
#line 1235
        tmp___1 = 3;
      }
#line 1235
      return ((ikptr )((n1 & (long )*((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 5)) + 0)) << tmp___1));
    }
  } else {
#line 1239
    if (n1 == -1L) {
#line 1239
      return (y);
    }
#line 1240
    if (fst & 8UL) {
#line 1242
      len = (long )(fst >> 4);
#line 1243
      pcb->root0 = & y;
#line 1244
      if ((int )sizeof(ikptr ) == 4) {
#line 1244
        tmp___2 = 2;
      } else {
#line 1244
        tmp___2 = 3;
      }
#line 1244
      if ((int )sizeof(ikptr ) == 4) {
#line 1244
        tmp___3 = 2;
      } else {
#line 1244
        tmp___3 = 3;
      }
      {
#line 1244
      tmp___4 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (len + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___2 + 1)) << (tmp___3 + 1)));
#line 1244
      r = tmp___4;
#line 1245
      pcb->root0 = (ikptr *)0;
#line 1246
      s2 = (mp_limb_t *)((long )((y + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1247
      s = (mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr ))));
#line 1248
      bits_compliment2(s2, s, (int )len, (int )(len + 1L));
#line 1249
      *(s + 0) &= (unsigned long )n1;
#line 1250
      bits_compliment2(s, s, (int )(len + 1L), (int )(len + 1L));
#line 1251
      tmp___5 = normalize_bignum(len + 1L, 1 << 3, r);
      }
#line 1251
      return (tmp___5);
    } else {
#line 1254
      len___0 = (long )(fst >> 4);
#line 1255
      pcb->root0 = & y;
#line 1256
      if ((int )sizeof(ikptr ) == 4) {
#line 1256
        tmp___6 = 2;
      } else {
#line 1256
        tmp___6 = 3;
      }
#line 1256
      if ((int )sizeof(ikptr ) == 4) {
#line 1256
        tmp___7 = 2;
      } else {
#line 1256
        tmp___7 = 3;
      }
      {
#line 1256
      tmp___8 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + len___0 * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___6 + 1)) << (tmp___7 + 1)));
#line 1256
      r___0 = tmp___8;
#line 1257
      pcb->root0 = (ikptr *)0;
#line 1258
      *((ikptr *)((long )r___0) + 0) = fst;
#line 1259
      *((ikptr *)((long )r___0 + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )((long )*((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 5)) + 0) & n1);
#line 1262
      i = 1;
      }
      {
#line 1262
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1262
        if (! ((long )i < len___0)) {
#line 1262
          goto while_break;
        }
#line 1263
        *((ikptr *)((long )r___0 + (long )((int )sizeof(ikptr ) + i * (int )sizeof(ikptr ))) + 0) = *((ikptr *)((long )y + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 1262
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1266
      return (r___0 + 5UL);
    }
  }
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnbnlogand(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr xfst ;
  ikptr yfst ;
  long n1 ;
  long n2 ;
  ikptr r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  mp_limb_t *s1 ;
  mp_limb_t *s2 ;
  mp_limb_t *s ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;
  ikptr tmp___4 ;
  ikptr r___0 ;
  int tmp___5 ;
  int tmp___6 ;
  ikptr tmp___7 ;
  mp_limb_t *s1___0 ;
  mp_limb_t *s2___0 ;
  mp_limb_t *s___0 ;
  ikptr tmp___8 ;
  int n ;
  long tmp___9 ;
  long i ;
  long l1 ;
  long l2 ;
  unsigned long last ;
  int tmp___10 ;
  int tmp___11 ;
  ikptr r___1 ;
  int tmp___12 ;
  int tmp___13 ;
  ikptr tmp___14 ;
  int j ;

  {
#line 1273
  xfst = *((ikptr *)((long )x + -5L) + 0);
#line 1274
  yfst = *((ikptr *)((long )y + -5L) + 0);
#line 1275
  n1 = (long )(xfst >> 4);
#line 1276
  n2 = (long )(yfst >> 4);
#line 1277
  if (xfst & 8UL) {
#line 1278
    if (yfst & 8UL) {
#line 1279
      if (n1 >= n2) {
#line 1280
        pcb->root0 = & x;
#line 1281
        pcb->root1 = & y;
#line 1282
        if ((int )sizeof(ikptr ) == 4) {
#line 1282
          tmp = 2;
        } else {
#line 1282
          tmp = 3;
        }
#line 1282
        if ((int )sizeof(ikptr ) == 4) {
#line 1282
          tmp___0 = 2;
        } else {
#line 1282
          tmp___0 = 3;
        }
        {
#line 1282
        tmp___1 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (n1 + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp + 1)) << (tmp___0 + 1)));
#line 1282
        r = tmp___1;
#line 1283
        pcb->root0 = (ikptr *)0;
#line 1284
        pcb->root1 = (ikptr *)0;
#line 1285
        s1 = (mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1286
        s2 = (mp_limb_t *)((long )((y + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1287
        s = (mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr ))));
#line 1288
        bits_compliment2(s1, s, (int )n1, (int )(n1 + 1L));
#line 1289
        bits_compliment_logand(s2, s, s, (int )n2);
#line 1290
        bits_compliment2(s, s, (int )(n1 + 1L), (int )(n1 + 1L));
#line 1291
        tmp___2 = normalize_bignum(n1 + 1L, 1 << 3, r);
        }
#line 1291
        return (tmp___2);
      } else {
        {
#line 1293
        tmp___3 = ikrt_bnbnlogand(y, x, pcb);
        }
#line 1293
        return (tmp___3);
      }
    } else {
      {
#line 1296
      tmp___4 = ikrt_bnbnlogand(y, x, pcb);
      }
#line 1296
      return (tmp___4);
    }
  } else
#line 1299
  if (yfst & 8UL) {
#line 1302
    pcb->root0 = & x;
#line 1303
    pcb->root1 = & y;
#line 1304
    if ((int )sizeof(ikptr ) == 4) {
#line 1304
      tmp___5 = 2;
    } else {
#line 1304
      tmp___5 = 3;
    }
#line 1304
    if ((int )sizeof(ikptr ) == 4) {
#line 1304
      tmp___6 = 2;
    } else {
#line 1304
      tmp___6 = 3;
    }
    {
#line 1304
    tmp___7 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + n1 * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___5 + 1)) << (tmp___6 + 1)));
#line 1304
    r___0 = tmp___7;
#line 1305
    pcb->root0 = (ikptr *)0;
#line 1306
    pcb->root1 = (ikptr *)0;
#line 1307
    s1___0 = (mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1308
    s2___0 = (mp_limb_t *)((long )((y + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1309
    s___0 = (mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr ))));
    }
#line 1310
    if (n1 <= n2) {
      {
#line 1311
      bits_compliment_logand(s2___0, s1___0, s___0, (int )n1);
      }
    } else {
      {
#line 1313
      bits_compliment_logand(s2___0, s1___0, s___0, (int )n2);
#line 1314
      copy_limbs(s1___0, s___0, (int )n2, (int )n1);
      }
    }
    {
#line 1316
    tmp___8 = normalize_bignum(n1, 0, r___0);
    }
#line 1316
    return (tmp___8);
  } else {
#line 1319
    if (n1 < n2) {
#line 1319
      tmp___9 = n1;
    } else {
#line 1319
      tmp___9 = n2;
    }
#line 1319
    n = (int )tmp___9;
#line 1321
    i = (long )(n - 1);
    {
#line 1321
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1321
      if (! (i >= 0L)) {
#line 1321
        goto while_break;
      }
#line 1322
      l1 = (long )*((ikptr *)((long )x + ((long )((int )sizeof(ikptr ) - 5) + i * (long )((int )sizeof(ikptr )))) + 0);
#line 1324
      l2 = (long )*((ikptr *)((long )y + ((long )((int )sizeof(ikptr ) - 5) + i * (long )((int )sizeof(ikptr )))) + 0);
#line 1326
      last = (unsigned long )(l1 & l2);
#line 1327
      if (last) {
#line 1328
        if (i == 0L) {
#line 1328
          if ((int )sizeof(ikptr ) == 4) {
#line 1328
            tmp___11 = 2;
          } else {
#line 1328
            tmp___11 = 3;
          }
#line 1328
          if (last < 0xffffffffffffffffUL >> (tmp___11 + 1)) {
#line 1329
            if ((int )sizeof(ikptr ) == 4) {
#line 1329
              tmp___10 = 2;
            } else {
#line 1329
              tmp___10 = 3;
            }
#line 1329
            return ((ikptr )((long )last << tmp___10));
          }
        }
#line 1331
        pcb->root0 = & x;
#line 1332
        pcb->root1 = & y;
#line 1333
        if ((int )sizeof(ikptr ) == 4) {
#line 1333
          tmp___12 = 2;
        } else {
#line 1333
          tmp___12 = 3;
        }
#line 1333
        if ((int )sizeof(ikptr ) == 4) {
#line 1333
          tmp___13 = 2;
        } else {
#line 1333
          tmp___13 = 3;
        }
        {
#line 1333
        tmp___14 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (i + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___12 + 1)) << (tmp___13 + 1)));
#line 1333
        r___1 = tmp___14;
#line 1334
        pcb->root0 = (ikptr *)0;
#line 1335
        pcb->root1 = (ikptr *)0;
#line 1336
        *((ikptr *)((long )r___1) + 0) = (ikptr )(3L | ((i + 1L) << 4));
#line 1337
        *((ikptr *)((long )r___1 + ((long )((int )sizeof(ikptr )) + i * (long )((int )sizeof(ikptr )))) + 0) = last;
#line 1339
        j = 0;
        }
        {
#line 1339
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1339
          if (! ((long )j < i)) {
#line 1339
            goto while_break___0;
          }
#line 1340
          *((ikptr *)((long )r___1 + (long )((int )sizeof(ikptr ) + j * (int )sizeof(ikptr ))) + 0) = (ikptr )((long )*((ikptr *)((long )x + (long )(((int )sizeof(ikptr ) - 5) + j * (int )sizeof(ikptr ))) + 0) & (long )*((ikptr *)((long )y + (long )(((int )sizeof(ikptr ) - 5) + j * (int )sizeof(ikptr ))) + 0));
#line 1339
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1345
        return (r___1 + 5UL);
      }
#line 1321
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1348
    return ((ikptr )0);
  }
}
}
#line 1354 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fxbnlogor(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  long n1 ;
  int tmp ;
  ikptr fst ;
  int tmp___0 ;
  int tmp___1 ;
  long len ;
  ikptr r ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  mp_limb_t *s2 ;
  mp_limb_t *s ;
  ikptr tmp___5 ;
  long len___0 ;
  ikptr r___0 ;
  int tmp___6 ;
  int tmp___7 ;
  ikptr tmp___8 ;
  int i ;

  {
#line 1356
  if ((int )sizeof(ikptr ) == 4) {
#line 1356
    tmp = 2;
  } else {
#line 1356
    tmp = 3;
  }
#line 1356
  n1 = (long )x >> tmp;
#line 1357
  fst = *((ikptr *)((long )y + -5L) + 0);
#line 1358
  if (n1 < 0L) {
#line 1360
    if (fst & 8UL) {
#line 1362
      if ((int )sizeof(ikptr ) == 4) {
#line 1362
        tmp___0 = 2;
      } else {
#line 1362
        tmp___0 = 3;
      }
#line 1362
      return ((ikptr )((n1 | (1L + ~ ((long )*((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 5)) + 0)))) << tmp___0));
    } else {
#line 1365
      if ((int )sizeof(ikptr ) == 4) {
#line 1365
        tmp___1 = 2;
      } else {
#line 1365
        tmp___1 = 3;
      }
#line 1365
      return ((ikptr )((n1 | (long )*((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 5)) + 0)) << tmp___1));
    }
  } else {
#line 1369
    if (n1 == 0L) {
#line 1369
      return (y);
    }
#line 1371
    if (fst & 8UL) {
#line 1373
      len = (long )(fst >> 4);
#line 1374
      pcb->root0 = & y;
#line 1375
      if ((int )sizeof(ikptr ) == 4) {
#line 1375
        tmp___2 = 2;
      } else {
#line 1375
        tmp___2 = 3;
      }
#line 1375
      if ((int )sizeof(ikptr ) == 4) {
#line 1375
        tmp___3 = 2;
      } else {
#line 1375
        tmp___3 = 3;
      }
      {
#line 1375
      tmp___4 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + (len + 1L) * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___2 + 1)) << (tmp___3 + 1)));
#line 1375
      r = tmp___4;
#line 1376
      pcb->root0 = (ikptr *)0;
#line 1377
      s2 = (mp_limb_t *)((long )((y + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1378
      s = (mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr ))));
#line 1379
      bits_compliment2(s2, s, (int )len, (int )(len + 1L));
#line 1380
      *(s + 0) |= (unsigned long )n1;
#line 1381
      bits_compliment2(s, s, (int )(len + 1L), (int )(len + 1L));
#line 1382
      tmp___5 = normalize_bignum(len + 1L, 1 << 3, r);
      }
#line 1382
      return (tmp___5);
    } else {
#line 1385
      len___0 = (long )(fst >> 4);
#line 1386
      pcb->root0 = & y;
#line 1387
      if ((int )sizeof(ikptr ) == 4) {
#line 1387
        tmp___6 = 2;
      } else {
#line 1387
        tmp___6 = 3;
      }
#line 1387
      if ((int )sizeof(ikptr ) == 4) {
#line 1387
        tmp___7 = 2;
      } else {
#line 1387
        tmp___7 = 3;
      }
      {
#line 1387
      tmp___8 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + len___0 * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___6 + 1)) << (tmp___7 + 1)));
#line 1387
      r___0 = tmp___8;
#line 1388
      pcb->root0 = (ikptr *)0;
#line 1389
      *((ikptr *)((long )r___0) + 0) = fst;
#line 1390
      *((ikptr *)((long )r___0 + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )((long )*((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 5)) + 0) | n1);
#line 1393
      i = 1;
      }
      {
#line 1393
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1393
        if (! ((long )i < len___0)) {
#line 1393
          goto while_break;
        }
#line 1394
        *((ikptr *)((long )r___0 + (long )((int )sizeof(ikptr ) + i * (int )sizeof(ikptr ))) + 0) = *((ikptr *)((long )y + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 1393
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1397
      return (r___0 + 5UL);
    }
  }
}
}
#line 1402 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnbnlogor(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr xfst ;
  ikptr yfst ;
  long n1 ;
  long n2 ;
  ikptr r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  mp_limb_t *s1 ;
  mp_limb_t *s2 ;
  mp_limb_t *s ;
  int carry ;
  int tmp___2 ;
  ikptr tmp___3 ;
  ikptr tmp___4 ;
  ikptr tmp___5 ;
  ikptr r___0 ;
  int tmp___6 ;
  int tmp___7 ;
  ikptr tmp___8 ;
  mp_limb_t *s1___0 ;
  mp_limb_t *s2___0 ;
  mp_limb_t *s___0 ;
  int carry___0 ;
  int tmp___9 ;
  ikptr tmp___10 ;
  int n ;
  long tmp___11 ;
  ikptr r___1 ;
  int tmp___12 ;
  int tmp___13 ;
  ikptr tmp___14 ;
  mp_limb_t *s___1 ;
  mp_limb_t *s1___1 ;
  mp_limb_t *s2___1 ;
  long i ;
  ikptr tmp___15 ;

  {
#line 1404
  xfst = *((ikptr *)((long )x + -5L) + 0);
#line 1405
  yfst = *((ikptr *)((long )y + -5L) + 0);
#line 1406
  n1 = (long )(xfst >> 4);
#line 1407
  n2 = (long )(yfst >> 4);
#line 1408
  if (xfst & 8UL) {
#line 1409
    if (yfst & 8UL) {
#line 1410
      if (n1 >= n2) {
#line 1411
        pcb->root0 = & x;
#line 1412
        pcb->root1 = & y;
#line 1413
        if ((int )sizeof(ikptr ) == 4) {
#line 1413
          tmp = 2;
        } else {
#line 1413
          tmp = 3;
        }
#line 1413
        if ((int )sizeof(ikptr ) == 4) {
#line 1413
          tmp___0 = 2;
        } else {
#line 1413
          tmp___0 = 3;
        }
        {
#line 1413
        tmp___1 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + n1 * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp + 1)) << (tmp___0 + 1)));
#line 1413
        r = tmp___1;
#line 1414
        pcb->root0 = (ikptr *)0;
#line 1415
        pcb->root1 = (ikptr *)0;
#line 1416
        s1 = (mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1417
        s2 = (mp_limb_t *)((long )((y + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1418
        s = (mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr ))));
#line 1419
        bits_compliment2(s2, s, (int )n2, (int )n1);
#line 1420
        tmp___2 = bits_compliment_logor(s1, s, s, (int )n1);
#line 1420
        carry = tmp___2;
#line 1421
        bits_compliment_carry(s, s, (int )n1, (int )n1, (mp_limb_t )carry);
#line 1422
        bits_compliment2(s, s, (int )n1, (int )n1);
#line 1423
        tmp___3 = normalize_bignum(n1, 1 << 3, r);
        }
#line 1423
        return (tmp___3);
      } else {
        {
#line 1425
        tmp___4 = ikrt_bnbnlogor(y, x, pcb);
        }
#line 1425
        return (tmp___4);
      }
    } else {
      {
#line 1428
      tmp___5 = ikrt_bnbnlogor(y, x, pcb);
      }
#line 1428
      return (tmp___5);
    }
  } else
#line 1431
  if (yfst & 8UL) {
#line 1434
    pcb->root0 = & x;
#line 1435
    pcb->root1 = & y;
#line 1436
    if ((int )sizeof(ikptr ) == 4) {
#line 1436
      tmp___6 = 2;
    } else {
#line 1436
      tmp___6 = 3;
    }
#line 1436
    if ((int )sizeof(ikptr ) == 4) {
#line 1436
      tmp___7 = 2;
    } else {
#line 1436
      tmp___7 = 3;
    }
    {
#line 1436
    tmp___8 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + n2 * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___6 + 1)) << (tmp___7 + 1)));
#line 1436
    r___0 = tmp___8;
#line 1437
    pcb->root0 = (ikptr *)0;
#line 1438
    pcb->root1 = (ikptr *)0;
#line 1439
    s1___0 = (mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1440
    s2___0 = (mp_limb_t *)((long )((y + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1441
    s___0 = (mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr ))));
    }
#line 1442
    if (n2 <= n1) {
      {
#line 1443
      bits_compliment_logor(s2___0, s1___0, s___0, (int )n2);
#line 1444
      bits_compliment2(s___0, s___0, (int )n2, (int )n2);
      }
    } else {
      {
#line 1446
      tmp___9 = bits_compliment_logor(s2___0, s1___0, s___0, (int )n1);
#line 1446
      carry___0 = tmp___9;
#line 1447
      bits_compliment_carry(s2___0, s___0, (int )n1, (int )n2, (mp_limb_t )carry___0);
#line 1448
      bits_compliment_carry(s___0, s___0, 0, (int )n2, (mp_limb_t )1);
      }
    }
    {
#line 1450
    tmp___10 = normalize_bignum(n2, 1 << 3, r___0);
    }
#line 1450
    return (tmp___10);
  } else {
#line 1453
    if (n1 > n2) {
#line 1453
      tmp___11 = n1;
    } else {
#line 1453
      tmp___11 = n2;
    }
#line 1453
    n = (int )tmp___11;
#line 1454
    pcb->root0 = & x;
#line 1455
    pcb->root1 = & y;
#line 1456
    if ((int )sizeof(ikptr ) == 4) {
#line 1456
      tmp___12 = 2;
    } else {
#line 1456
      tmp___12 = 3;
    }
#line 1456
    if ((int )sizeof(ikptr ) == 4) {
#line 1456
      tmp___13 = 2;
    } else {
#line 1456
      tmp___13 = 3;
    }
    {
#line 1456
    tmp___14 = ik_safe_alloc(pcb, (((((int )sizeof(ikptr ) + n * (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___12 + 1)) << (tmp___13 + 1));
#line 1456
    r___1 = tmp___14;
#line 1457
    s___1 = (mp_limb_t *)((long )(r___1 + (ikptr )((int )sizeof(ikptr ))));
#line 1458
    s1___1 = (mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1459
    s2___1 = (mp_limb_t *)((long )((y + (ikptr )((int )sizeof(ikptr ))) - 5UL));
#line 1460
    pcb->root0 = (ikptr *)0;
#line 1461
    pcb->root1 = (ikptr *)0;
    }
#line 1463
    if ((long )n == n1) {
#line 1464
      i = 0L;
      {
#line 1464
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1464
        if (! (i < n2)) {
#line 1464
          goto while_break;
        }
#line 1465
        *(s___1 + i) = *(s1___1 + i) | *(s2___1 + i);
#line 1464
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1467
      i = n2;
      {
#line 1467
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1467
        if (! (i < n1)) {
#line 1467
          goto while_break___0;
        }
#line 1468
        *(s___1 + i) = *(s1___1 + i);
#line 1467
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1471
      i = 0L;
      {
#line 1471
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1471
        if (! (i < n1)) {
#line 1471
          goto while_break___1;
        }
#line 1472
        *(s___1 + i) = *(s1___1 + i) | *(s2___1 + i);
#line 1471
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1474
      i = n1;
      {
#line 1474
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1474
        if (! (i < n2)) {
#line 1474
          goto while_break___2;
        }
#line 1475
        *(s___1 + i) = *(s2___1 + i);
#line 1474
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 1478
    tmp___15 = normalize_bignum((long )n, 0, r___1);
    }
#line 1478
    return (tmp___15);
  }
}
}
#line 1483 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void copy_bits_shifting_right(mp_limb_t *src , mp_limb_t *dst , int n , int m ) 
{ 
  mp_limb_t carry ;
  int i ;
  mp_limb_t b ;

  {
#line 1485
  carry = *(src + 0) >> m;
#line 1487
  i = 1;
  {
#line 1487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1487
    if (! (i < n)) {
#line 1487
      goto while_break;
    }
#line 1488
    b = *(src + i);
#line 1489
    *(dst + (i - 1)) = (b << (__gmp_bits_per_limb - (int const   )m)) | carry;
#line 1490
    carry = b >> m;
#line 1487
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1492
  *(dst + (n - 1)) = carry;
#line 1493
  return;
}
}
#line 1495 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void copy_bits_shifting_left(mp_limb_t *src , mp_limb_t *dst , int n , int m ) 
{ 
  mp_limb_t carry ;
  int i ;
  mp_limb_t b ;

  {
#line 1497
  carry = (mp_limb_t )0;
#line 1499
  i = 0;
  {
#line 1499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1499
    if (! (i < n)) {
#line 1499
      goto while_break;
    }
#line 1500
    b = *(src + i);
#line 1501
    *(dst + i) = (b << m) | carry;
#line 1502
    carry = b >> (__gmp_bits_per_limb - (int const   )m);
#line 1499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1504
  *(dst + n) = carry;
#line 1505
  return;
}
}
#line 1511 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bignum_shift_right(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  int limb_shift ;
  int tmp ;
  long m ;
  int tmp___0 ;
  ikptr fst ;
  long n ;
  long whole_limb_shift ;
  long bit_shift ;
  long new_limb_count ;
  int tmp___1 ;
  ikptr r ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  long tmp___5 ;
  ikptr tmp___6 ;
  ikptr r___0 ;
  int tmp___7 ;
  int tmp___8 ;
  ikptr tmp___9 ;
  long tmp___10 ;
  ikptr tmp___11 ;
  ikptr r___1 ;
  int tmp___12 ;
  int tmp___13 ;
  ikptr tmp___14 ;
  ikptr tmp___15 ;
  ikptr tmp___16 ;

  {
#line 1513
  if ((int )sizeof(ikptr ) == 4) {
#line 1513
    tmp = 5;
  } else {
#line 1513
    tmp = 6;
  }
#line 1513
  limb_shift = tmp;
#line 1514
  if ((int )sizeof(ikptr ) == 4) {
#line 1514
    tmp___0 = 2;
  } else {
#line 1514
    tmp___0 = 3;
  }
#line 1514
  m = (long )y >> tmp___0;
#line 1515
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 1516
  n = (long )(fst >> 4);
#line 1517
  whole_limb_shift = m >> limb_shift;
#line 1518
  bit_shift = m & (long )(__gmp_bits_per_limb - 1);
#line 1519
  new_limb_count = n - whole_limb_shift;
#line 1520
  if (fst & 8UL) {
#line 1521
    if (new_limb_count <= 0L) {
#line 1522
      if ((int )sizeof(ikptr ) == 4) {
#line 1522
        tmp___1 = 2;
      } else {
#line 1522
        tmp___1 = 3;
      }
#line 1522
      return ((ikptr )(-1L << tmp___1));
    }
#line 1524
    if (bit_shift == 0L) {
#line 1525
      pcb->root0 = & x;
#line 1526
      if ((int )sizeof(ikptr ) == 4) {
#line 1526
        tmp___2 = 2;
      } else {
#line 1526
        tmp___2 = 3;
      }
#line 1526
      if ((int )sizeof(ikptr ) == 4) {
#line 1526
        tmp___3 = 2;
      } else {
#line 1526
        tmp___3 = 3;
      }
      {
#line 1526
      tmp___4 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + new_limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___2 + 1)) << (tmp___3 + 1)));
#line 1526
      r = tmp___4;
#line 1527
      pcb->root0 = (ikptr *)0;
#line 1528
      tmp___5 = bits_carry((mp_limb_t *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5))),
                           (int )whole_limb_shift);
#line 1528
      bits_compliment_with_carry((mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ) - 5)) + (ikptr )(whole_limb_shift * (long )((int )sizeof(ikptr ))))),
                                 (mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr )))),
                                 new_limb_count, tmp___5);
#line 1533
      bits_compliment((mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr )))),
                      (mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr )))),
                      new_limb_count);
#line 1537
      tmp___6 = normalize_bignum(new_limb_count, 1 << 3, r);
      }
#line 1537
      return (tmp___6);
    } else {
#line 1539
      pcb->root0 = & x;
#line 1540
      if ((int )sizeof(ikptr ) == 4) {
#line 1540
        tmp___7 = 2;
      } else {
#line 1540
        tmp___7 = 3;
      }
#line 1540
      if ((int )sizeof(ikptr ) == 4) {
#line 1540
        tmp___8 = 2;
      } else {
#line 1540
        tmp___8 = 3;
      }
      {
#line 1540
      tmp___9 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + new_limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___7 + 1)) << (tmp___8 + 1)));
#line 1540
      r___0 = tmp___9;
#line 1541
      pcb->root0 = (ikptr *)0;
#line 1542
      tmp___10 = bits_carry((mp_limb_t *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5))),
                            (int )whole_limb_shift);
#line 1542
      bits_compliment_with_carry((mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ) - 5)) + (ikptr )(whole_limb_shift * (long )((int )sizeof(ikptr ))))),
                                 (mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr )))),
                                 new_limb_count, tmp___10);
#line 1547
      copy_bits_shifting_right((mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr )))),
                               (mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr )))),
                               (int )new_limb_count, (int )bit_shift);
#line 1552
      *((mp_limb_t *)((r___0 + (ikptr )((int )sizeof(ikptr ))) + (ikptr )((new_limb_count - 1L) * (long )((int )sizeof(ikptr ))))) |= (unsigned long )(-1L << ((long )__gmp_bits_per_limb - bit_shift));
#line 1554
      bits_compliment((mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr )))),
                      (mp_limb_t *)((long )(r___0 + (ikptr )((int )sizeof(ikptr )))),
                      new_limb_count);
#line 1558
      tmp___11 = normalize_bignum(new_limb_count, 1 << 3, r___0);
      }
#line 1558
      return (tmp___11);
      {
#line 1559
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not yet for negative bignum_shift\n");
#line 1560
      exit(-1);
      }
    }
  } else {
#line 1563
    if (new_limb_count <= 0L) {
#line 1564
      return ((ikptr )0);
    }
#line 1566
    pcb->root0 = & x;
#line 1567
    if ((int )sizeof(ikptr ) == 4) {
#line 1567
      tmp___12 = 2;
    } else {
#line 1567
      tmp___12 = 3;
    }
#line 1567
    if ((int )sizeof(ikptr ) == 4) {
#line 1567
      tmp___13 = 2;
    } else {
#line 1567
      tmp___13 = 3;
    }
    {
#line 1567
    tmp___14 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + new_limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___12 + 1)) << (tmp___13 + 1)));
#line 1567
    r___1 = tmp___14;
#line 1568
    pcb->root0 = (ikptr *)0;
    }
#line 1569
    if (bit_shift == 0L) {
      {
#line 1570
      memcpy((void */* __restrict  */)((char *)((long )r___1) + (int )sizeof(ikptr )),
             (void const   */* __restrict  */)(((char *)((long )x) + ((int )sizeof(ikptr ) - 5)) + whole_limb_shift * (long )((int )sizeof(ikptr ))),
             (size_t )(new_limb_count * (long )((int )sizeof(ikptr ))));
#line 1573
      tmp___15 = normalize_bignum(new_limb_count, 0, r___1);
      }
#line 1573
      return (tmp___15);
    } else {
      {
#line 1575
      copy_bits_shifting_right((mp_limb_t *)((long )((x + (ikptr )((int )sizeof(ikptr ) - 5)) + (ikptr )(whole_limb_shift * (long )((int )sizeof(ikptr ))))),
                               (mp_limb_t *)((long )(r___1 + (ikptr )((int )sizeof(ikptr )))),
                               (int )new_limb_count, (int )bit_shift);
#line 1580
      tmp___16 = normalize_bignum(new_limb_count, 0, r___1);
      }
#line 1580
      return (tmp___16);
    }
  }
}
}
#line 1586 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fixnum_shift_left(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  int limb_shift ;
  int tmp ;
  long m ;
  int tmp___0 ;
  long n ;
  int tmp___1 ;
  long limb_count ;
  long bit_shift ;
  ikptr r ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  unsigned long *s ;
  int tmp___5 ;
  ikptr tmp___6 ;

  {
#line 1588
  if ((int )sizeof(ikptr ) == 4) {
#line 1588
    tmp = 5;
  } else {
#line 1588
    tmp = 6;
  }
#line 1588
  limb_shift = tmp;
#line 1589
  if ((int )sizeof(ikptr ) == 4) {
#line 1589
    tmp___0 = 2;
  } else {
#line 1589
    tmp___0 = 3;
  }
#line 1589
  m = (long )y >> tmp___0;
#line 1590
  if ((int )sizeof(ikptr ) == 4) {
#line 1590
    tmp___1 = 2;
  } else {
#line 1590
    tmp___1 = 3;
  }
#line 1590
  n = (long )x >> tmp___1;
#line 1591
  limb_count = (m >> limb_shift) + 2L;
#line 1592
  bit_shift = m & (long )(__gmp_bits_per_limb - 1);
#line 1593
  if ((int )sizeof(ikptr ) == 4) {
#line 1593
    tmp___2 = 2;
  } else {
#line 1593
    tmp___2 = 3;
  }
#line 1593
  if ((int )sizeof(ikptr ) == 4) {
#line 1593
    tmp___3 = 2;
  } else {
#line 1593
    tmp___3 = 3;
  }
  {
#line 1593
  tmp___4 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___2 + 1)) << (tmp___3 + 1)));
#line 1593
  r = tmp___4;
#line 1594
  s = (unsigned long *)((long )(r + (ikptr )((int )sizeof(ikptr ))));
#line 1595
  bzero((void *)s, (size_t )(limb_count * (long )((int )sizeof(ikptr ))));
  }
#line 1596
  if (n >= 0L) {
#line 1597
    if (bit_shift) {
#line 1598
      *(s + (limb_count - 1L)) = (unsigned long )(n >> ((long )__gmp_bits_per_limb - bit_shift));
    }
#line 1600
    *(s + (limb_count - 2L)) = (unsigned long )(n << bit_shift);
  } else {
#line 1602
    if (bit_shift) {
#line 1603
      *(s + (limb_count - 1L)) = (unsigned long )(- n >> ((long )__gmp_bits_per_limb - bit_shift));
    }
#line 1605
    *(s + (limb_count - 2L)) = (unsigned long )(- n << bit_shift);
  }
#line 1607
  if (n >= 0L) {
#line 1607
    tmp___5 = 0;
  } else {
#line 1607
    tmp___5 = 1 << 3;
  }
  {
#line 1607
  tmp___6 = normalize_bignum(limb_count, tmp___5, r);
  }
#line 1607
  return (tmp___6);
}
}
#line 1611 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bignum_shift_left(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  int limb_shift ;
  int tmp ;
  long m ;
  int tmp___0 ;
  ikptr fst ;
  long n ;
  long whole_limb_shift ;
  long bit_shift ;
  long limb_count ;
  ikptr r ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;
  unsigned int *s ;
  ikptr tmp___4 ;
  int limb_count___0 ;
  ikptr r___0 ;
  int tmp___5 ;
  int tmp___6 ;
  ikptr tmp___7 ;
  mp_limb_t *s___0 ;
  ikptr tmp___8 ;

  {
#line 1613
  if ((int )sizeof(ikptr ) == 4) {
#line 1613
    tmp = 5;
  } else {
#line 1613
    tmp = 6;
  }
#line 1613
  limb_shift = tmp;
#line 1614
  if ((int )sizeof(ikptr ) == 4) {
#line 1614
    tmp___0 = 2;
  } else {
#line 1614
    tmp___0 = 3;
  }
#line 1614
  m = (long )y >> tmp___0;
#line 1615
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 1616
  n = (long )(fst >> 4);
#line 1617
  whole_limb_shift = m >> limb_shift;
#line 1618
  bit_shift = m & (long )(__gmp_bits_per_limb - 1);
#line 1619
  if (bit_shift == 0L) {
#line 1620
    limb_count = n + whole_limb_shift;
#line 1621
    pcb->root0 = & x;
#line 1622
    if ((int )sizeof(ikptr ) == 4) {
#line 1622
      tmp___1 = 2;
    } else {
#line 1622
      tmp___1 = 3;
    }
#line 1622
    if ((int )sizeof(ikptr ) == 4) {
#line 1622
      tmp___2 = 2;
    } else {
#line 1622
      tmp___2 = 3;
    }
    {
#line 1622
    tmp___3 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___1 + 1)) << (tmp___2 + 1)));
#line 1622
    r = tmp___3;
#line 1623
    pcb->root0 = (ikptr *)0;
#line 1624
    s = (unsigned int *)((long )(r + (ikptr )((int )sizeof(ikptr ))));
#line 1625
    bzero((void *)s, (size_t )(whole_limb_shift * (long )((int )sizeof(ikptr ))));
#line 1626
    memcpy((void */* __restrict  */)((char *)s + whole_limb_shift * (long )((int )sizeof(ikptr ))),
           (void const   */* __restrict  */)((char *)x + ((int )sizeof(ikptr ) - 5)),
           (size_t )(n * (long )((int )sizeof(ikptr ))));
#line 1629
    tmp___4 = normalize_bignum(limb_count, (int )(fst & 8UL), r);
    }
#line 1629
    return (tmp___4);
  } else {
#line 1631
    limb_count___0 = (int )((n + whole_limb_shift) + 1L);
#line 1632
    pcb->root0 = & x;
#line 1633
    if ((int )sizeof(ikptr ) == 4) {
#line 1633
      tmp___5 = 2;
    } else {
#line 1633
      tmp___5 = 3;
    }
#line 1633
    if ((int )sizeof(ikptr ) == 4) {
#line 1633
      tmp___6 = 2;
    } else {
#line 1633
      tmp___6 = 3;
    }
    {
#line 1633
    tmp___7 = ik_safe_alloc(pcb, (((((int )sizeof(ikptr ) + limb_count___0 * (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___5 + 1)) << (tmp___6 + 1));
#line 1633
    r___0 = tmp___7;
#line 1634
    pcb->root0 = (ikptr *)0;
#line 1635
    s___0 = (mp_limb_t *)(r___0 + (ikptr )((int )sizeof(ikptr )));
#line 1636
    bzero((void *)s___0, (size_t )(whole_limb_shift * (long )((int )sizeof(ikptr ))));
#line 1637
    copy_bits_shifting_left((mp_limb_t *)(x + (ikptr )((int )sizeof(ikptr ) - 5)),
                            s___0 + whole_limb_shift, (int )n, (int )bit_shift);
#line 1642
    tmp___8 = normalize_bignum((long )limb_count___0, (int )(fst & 8UL), r___0);
    }
#line 1642
    return (tmp___8);
  }
}
}
#line 1667 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnbndivrem(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  ikptr xfst ;
  ikptr yfst ;
  mp_size_t xn ;
  mp_size_t yn ;
  ikptr rv ;
  ikptr tmp ;
  mp_size_t qn ;
  mp_size_t rn ;
  ikptr q ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  ikptr r ;
  int tmp___5 ;
  int tmp___6 ;
  long sign ;
  long sign___0 ;
  ikptr rv___0 ;
  ikptr tmp___7 ;

  {
#line 1669
  xfst = *((ikptr *)((long )x + -5L) + 0);
#line 1670
  yfst = *((ikptr *)((long )y + -5L) + 0);
#line 1671
  xn = (mp_size_t )(xfst >> 4);
#line 1672
  yn = (mp_size_t )(yfst >> 4);
#line 1673
  if (xn < yn) {
    {
#line 1675
    pcb->root0 = & x;
#line 1676
    pcb->root1 = & y;
#line 1677
    tmp = ik_safe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 1677
    rv = tmp;
#line 1678
    pcb->root0 = (ikptr *)0;
#line 1679
    pcb->root1 = (ikptr *)0;
#line 1680
    *((ikptr *)((long )rv) + 0) = (ikptr )0;
#line 1681
    *((ikptr *)((long )rv + (long )((int )sizeof(ikptr ))) + 0) = x;
    }
#line 1682
    return (rv + 1UL);
  }
#line 1684
  qn = (xn - yn) + 1L;
#line 1685
  rn = yn;
#line 1690
  pcb->root0 = & x;
#line 1691
  pcb->root1 = & y;
#line 1692
  if ((int )sizeof(ikptr ) == 4) {
#line 1692
    tmp___0 = 2;
  } else {
#line 1692
    tmp___0 = 3;
  }
#line 1692
  if ((int )sizeof(ikptr ) == 4) {
#line 1692
    tmp___1 = 2;
  } else {
#line 1692
    tmp___1 = 3;
  }
#line 1692
  if ((int )sizeof(ikptr ) == 4) {
#line 1692
    tmp___2 = 2;
  } else {
#line 1692
    tmp___2 = 3;
  }
#line 1692
  if ((int )sizeof(ikptr ) == 4) {
#line 1692
    tmp___3 = 2;
  } else {
#line 1692
    tmp___3 = 3;
  }
  {
#line 1692
  tmp___4 = ik_safe_alloc(pcb, (int )(((((((mp_size_t )((int )sizeof(ikptr )) + qn * (mp_size_t )((int )sizeof(ikptr ))) + (mp_size_t )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1)) + ((((((mp_size_t )((int )sizeof(ikptr )) + rn * (mp_size_t )((int )sizeof(ikptr ))) + (mp_size_t )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___2 + 1)) << (tmp___3 + 1))));
#line 1692
  q = tmp___4;
  }
#line 1695
  if ((int )sizeof(ikptr ) == 4) {
#line 1695
    tmp___5 = 2;
  } else {
#line 1695
    tmp___5 = 3;
  }
#line 1695
  if ((int )sizeof(ikptr ) == 4) {
#line 1695
    tmp___6 = 2;
  } else {
#line 1695
    tmp___6 = 3;
  }
  {
#line 1695
  r = q + (ikptr )((((((mp_size_t )((int )sizeof(ikptr )) + qn * (mp_size_t )((int )sizeof(ikptr ))) + (mp_size_t )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___5 + 1)) << (tmp___6 + 1));
#line 1696
  pcb->root0 = (ikptr *)0;
#line 1697
  pcb->root1 = (ikptr *)0;
#line 1698
  __gmpn_tdiv_qr((mp_limb_t *)((long )(q + (ikptr )((int )sizeof(ikptr )))), (mp_limb_t *)((long )(r + (ikptr )((int )sizeof(ikptr )))),
                 (mp_size_t )0, (mp_srcptr )((mp_limb_t *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5)))),
                 xn, (mp_srcptr )((mp_limb_t *)((long )(y + (ikptr )((int )sizeof(ikptr ) - 5)))),
                 yn);
  }
#line 1707
  if (xfst & 8UL) {
    {
#line 1709
    r = normalize_bignum(rn, 1 << 3, r);
    }
  } else {
    {
#line 1711
    r = normalize_bignum(rn, 0, r);
    }
  }
#line 1714
  if (yfst & 8UL) {
    {
#line 1716
    sign = (long )(8UL - (xfst & 8UL));
#line 1717
    q = normalize_bignum(qn, (int )sign, q);
    }
  } else {
    {
#line 1720
    sign___0 = (long )(xfst & 8UL);
#line 1721
    q = normalize_bignum(qn, (int )sign___0, q);
    }
  }
  {
#line 1723
  pcb->root0 = & q;
#line 1724
  pcb->root1 = & r;
#line 1725
  tmp___7 = ik_safe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 1725
  rv___0 = tmp___7;
#line 1726
  pcb->root0 = (ikptr *)0;
#line 1727
  pcb->root1 = (ikptr *)0;
#line 1728
  *((ikptr *)((long )rv___0) + 0) = q;
#line 1729
  *((ikptr *)((long )rv___0 + (long )((int )sizeof(ikptr ))) + 0) = r;
  }
#line 1730
  return (rv___0 + 1UL);
}
}
#line 1752 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnfxdivrem(ikptr x , ikptr y , ikpcb *pcb ) 
{ 
  long yint ;
  int tmp ;
  ikptr fst ;
  mp_size_t s2n ;
  ikptr quot ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;
  mp_limb_t *s2p ;
  mp_limb_t rv ;
  long tmp___3 ;
  mp_limb_t tmp___4 ;
  ikptr rem ;
  long sign ;
  long sign___0 ;
  int tmp___5 ;
  int tmp___6 ;
  ikptr p ;
  ikptr tmp___7 ;

  {
#line 1754
  if ((int )sizeof(ikptr ) == 4) {
#line 1754
    tmp = 2;
  } else {
#line 1754
    tmp = 3;
  }
#line 1754
  yint = (long )y >> tmp;
#line 1755
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 1756
  s2n = (mp_size_t )(fst >> 4);
#line 1757
  pcb->root0 = & x;
#line 1758
  if ((int )sizeof(ikptr ) == 4) {
#line 1758
    tmp___0 = 2;
  } else {
#line 1758
    tmp___0 = 3;
  }
#line 1758
  if ((int )sizeof(ikptr ) == 4) {
#line 1758
    tmp___1 = 2;
  } else {
#line 1758
    tmp___1 = 3;
  }
  {
#line 1758
  tmp___2 = ik_safe_alloc(pcb, (int )(((((s2n * (mp_size_t )((int )sizeof(ikptr )) + (mp_size_t )((int )sizeof(ikptr ))) + (mp_size_t )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1)));
#line 1758
  quot = tmp___2;
#line 1759
  pcb->root0 = (ikptr *)0;
#line 1760
  s2p = (mp_limb_t *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5)));
#line 1761
  tmp___3 = labs(yint);
#line 1761
  tmp___4 = __gmpn_divrem_1((mp_limb_t *)((long )(quot + (ikptr )((int )sizeof(ikptr )))),
                            (mp_size_t )0, (mp_srcptr )s2p, s2n, (mp_limb_t )tmp___3);
#line 1761
  rv = tmp___4;
  }
#line 1770
  if (yint < 0L) {
    {
#line 1772
    sign = (long )(8UL - (fst & 8UL));
#line 1773
    quot = normalize_bignum(s2n, (int )sign, quot);
    }
  } else {
    {
#line 1776
    sign___0 = (long )(fst & 8UL);
#line 1777
    quot = normalize_bignum(s2n, (int )sign___0, quot);
    }
  }
#line 1783
  if (fst & 8UL) {
#line 1785
    if ((int )sizeof(ikptr ) == 4) {
#line 1785
      tmp___5 = 2;
    } else {
#line 1785
      tmp___5 = 3;
    }
#line 1785
    rem = - (rv << tmp___5);
  } else {
#line 1787
    if ((int )sizeof(ikptr ) == 4) {
#line 1787
      tmp___6 = 2;
    } else {
#line 1787
      tmp___6 = 3;
    }
#line 1787
    rem = (ikptr )((long )rv << tmp___6);
  }
  {
#line 1789
  pcb->root0 = & quot;
#line 1790
  pcb->root1 = & rem;
#line 1791
  tmp___7 = ik_safe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 1791
  p = tmp___7;
#line 1792
  pcb->root0 = (ikptr *)0;
#line 1793
  pcb->root1 = (ikptr *)0;
#line 1794
  *((ikptr *)((long )p) + 0) = quot;
#line 1795
  *((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) = rem;
  }
#line 1796
  return (p + 1UL);
}
}
#line 1799 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bnfx_modulo(ikptr x , ikptr y ) 
{ 
  long yint ;
  int tmp ;
  mp_limb_t *s2p ;
  ikptr fst ;
  mp_size_t s2n ;
  mp_limb_t m ;
  mp_limb_t tmp___0 ;
  int tmp___1 ;
  mp_limb_t m___0 ;
  mp_limb_t tmp___2 ;
  int tmp___3 ;
  mp_limb_t m___1 ;
  mp_limb_t tmp___4 ;
  int tmp___5 ;
  mp_limb_t m___2 ;
  mp_limb_t tmp___6 ;
  int tmp___7 ;

  {
#line 1801
  if ((int )sizeof(ikptr ) == 4) {
#line 1801
    tmp = 2;
  } else {
#line 1801
    tmp = 3;
  }
#line 1801
  yint = (long )y >> tmp;
#line 1802
  s2p = (mp_limb_t *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5)));
#line 1803
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 1804
  s2n = (mp_size_t )(fst >> 4);
#line 1805
  if (yint < 0L) {
#line 1806
    if (fst & 8UL) {
      {
#line 1808
      tmp___0 = __gmpn_mod_1((mp_srcptr )s2p, s2n, (mp_limb_t )(- yint));
#line 1808
      m = tmp___0;
      }
#line 1809
      if ((int )sizeof(ikptr ) == 4) {
#line 1809
        tmp___1 = 2;
      } else {
#line 1809
        tmp___1 = 3;
      }
#line 1809
      return ((ikptr )((long )(- m) << tmp___1));
    } else {
      {
#line 1812
      tmp___2 = __gmpn_mod_1((mp_srcptr )s2p, s2n, (mp_limb_t )(- yint));
#line 1812
      m___0 = tmp___2;
      }
#line 1813
      if ((int )sizeof(ikptr ) == 4) {
#line 1813
        tmp___3 = 2;
      } else {
#line 1813
        tmp___3 = 3;
      }
#line 1813
      return ((ikptr )((long )((mp_limb_t )yint + m___0) << tmp___3));
    }
  } else
#line 1816
  if (fst & 8UL) {
    {
#line 1818
    tmp___4 = __gmpn_mod_1((mp_srcptr )s2p, s2n, (mp_limb_t )yint);
#line 1818
    m___1 = tmp___4;
    }
#line 1819
    if ((int )sizeof(ikptr ) == 4) {
#line 1819
      tmp___5 = 2;
    } else {
#line 1819
      tmp___5 = 3;
    }
#line 1819
    return ((ikptr )((long )((mp_limb_t )yint - m___1) << tmp___5));
  } else {
    {
#line 1822
    tmp___6 = __gmpn_mod_1((mp_srcptr )s2p, s2n, (mp_limb_t )yint);
#line 1822
    m___2 = tmp___6;
    }
#line 1823
    if ((int )sizeof(ikptr ) == 4) {
#line 1823
      tmp___7 = 2;
    } else {
#line 1823
      tmp___7 = 3;
    }
#line 1823
    return ((ikptr )((long )m___2 << tmp___7));
  }
}
}
#line 1829 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int limb_length(unsigned long n ) 
{ 
  int i ;

  {
#line 1831
  i = 0;
  {
#line 1832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1832
    if (! (n != 0UL)) {
#line 1832
      goto while_break;
    }
#line 1833
    n >>= 1;
#line 1834
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1836
  return (i);
}
}
#line 1840 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bignum_length(ikptr x ) 
{ 
  ikptr fst ;
  mp_limb_t *sp ;
  mp_size_t sn ;
  mp_limb_t last ;
  int n0 ;
  int tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1842
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 1843
  sp = (mp_limb_t *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5)));
#line 1844
  sn = (mp_size_t )(fst >> 4);
#line 1845
  last = *(sp + (sn - 1L));
#line 1846
  tmp = limb_length(last);
#line 1846
  n0 = tmp;
  }
#line 1847
  if (fst & 8UL) {
#line 1849
    if (last == (mp_limb_t )(1L << (n0 - 1))) {
#line 1852
      i = 0;
      {
#line 1852
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1852
        if (! ((mp_size_t )i < sn - 1L)) {
#line 1852
          goto while_break;
        }
#line 1853
        if (*(sp + i) != 0UL) {
#line 1855
          if ((int )sizeof(ikptr ) == 4) {
#line 1855
            tmp___0 = 2;
          } else {
#line 1855
            tmp___0 = 3;
          }
#line 1855
          return ((ikptr )(((sn - 1L) * (mp_size_t )__gmp_bits_per_limb + (mp_size_t )n0) << tmp___0));
        }
#line 1852
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1861
      if ((int )sizeof(ikptr ) == 4) {
#line 1861
        tmp___1 = 2;
      } else {
#line 1861
        tmp___1 = 3;
      }
#line 1861
      return ((ikptr )((((sn - 1L) * (mp_size_t )__gmp_bits_per_limb + (mp_size_t )n0) - 1L) << tmp___1));
    } else {
#line 1863
      if ((int )sizeof(ikptr ) == 4) {
#line 1863
        tmp___2 = 2;
      } else {
#line 1863
        tmp___2 = 3;
      }
#line 1863
      return ((ikptr )(((sn - 1L) * (mp_size_t )__gmp_bits_per_limb + (mp_size_t )n0) << tmp___2));
    }
  } else {
#line 1866
    if ((int )sizeof(ikptr ) == 4) {
#line 1866
      tmp___3 = 2;
    } else {
#line 1866
      tmp___3 = 3;
    }
#line 1866
    return ((ikptr )(((sn - 1L) * (mp_size_t )__gmp_bits_per_limb + (mp_size_t )n0) << tmp___3));
  }
}
}
#line 1871 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bignum_to_bytevector(ikptr x , ikpcb *pcb ) 
{ 
  ikptr fst ;
  long limb_count ;
  long sign_bit ;
  long nbsize ;
  long strsize ;
  int tmp ;
  long mem_req ;
  unsigned char *mem ;
  void *tmp___0 ;
  mp_size_t bytes ;
  size_t tmp___1 ;
  unsigned char *string_start ;
  ikptr bv ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ikptr tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *dest ;
  long i ;

  {
#line 1876
  fst = *((ikptr *)((long )x + -5L) + 0);
#line 1877
  limb_count = (long )(fst >> 4);
#line 1878
  if (limb_count <= 0L) {
    {
#line 1879
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: nbtostring: invalid length %ld\n",
            limb_count);
#line 1880
    exit(-1);
    }
  }
#line 1882
  sign_bit = 8L & (long )fst;
#line 1883
  nbsize = (long )((unsigned long )limb_count * sizeof(mp_limb_t ));
#line 1884
  if ((int )sizeof(ikptr ) == 4) {
#line 1884
    tmp = 10;
  } else {
#line 1884
    tmp = 20;
  }
  {
#line 1884
  strsize = limb_count * (long )tmp;
#line 1885
  mem_req = (nbsize + strsize) + 1L;
#line 1886
  tmp___0 = malloc((size_t )mem_req);
#line 1886
  mem = (unsigned char *)tmp___0;
  }
#line 1887
  if (! mem) {
    {
#line 1888
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error allocating space for bignum\n");
#line 1889
    exit(-1);
    }
  }
  {
#line 1891
  memcpy((void */* __restrict  */)((char *)((long )mem)), (void const   */* __restrict  */)(((char *)((long )x) - 5) + (int )sizeof(ikptr )),
         (size_t )nbsize);
#line 1894
  tmp___1 = __gmpn_get_str(mem + nbsize, 10, (mp_limb_t *)mem, limb_count);
#line 1894
  bytes = (mp_size_t )tmp___1;
#line 1900
  string_start = mem + nbsize;
  }
  {
#line 1901
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1901
    if (! ((int )*string_start == 0)) {
#line 1901
      goto while_break;
    }
#line 1902
    string_start ++;
#line 1903
    bytes --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1905
  if (sign_bit) {
#line 1905
    tmp___2 = 1;
  } else {
#line 1905
    tmp___2 = 0;
  }
#line 1905
  if ((int )sizeof(ikptr ) == 4) {
#line 1905
    tmp___3 = 2;
  } else {
#line 1905
    tmp___3 = 3;
  }
#line 1905
  if ((int )sizeof(ikptr ) == 4) {
#line 1905
    tmp___4 = 2;
  } else {
#line 1905
    tmp___4 = 3;
  }
  {
#line 1905
  tmp___5 = ik_safe_alloc(pcb, (int )((((((bytes + 8L) + (mp_size_t )tmp___2) + (mp_size_t )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___3 + 1)) << (tmp___4 + 1)));
#line 1905
  bv = tmp___5;
  }
#line 1906
  if (sign_bit) {
#line 1906
    tmp___6 = 1;
  } else {
#line 1906
    tmp___6 = 0;
  }
#line 1906
  if ((int )sizeof(ikptr ) == 4) {
#line 1906
    tmp___7 = 2;
  } else {
#line 1906
    tmp___7 = 3;
  }
#line 1906
  *((ikptr *)((long )bv) + 0) = (ikptr )((bytes + (mp_size_t )tmp___6) << tmp___7);
#line 1907
  dest = (char *)((long )(bv + 8UL));
#line 1908
  if (sign_bit) {
#line 1909
    *dest = (char )'-';
#line 1910
    dest ++;
  }
#line 1913
  i = 0L;
  {
#line 1914
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1914
    if (! (i < bytes)) {
#line 1914
      goto while_break___0;
    }
#line 1915
    *(dest + i) = (char )((int )*(string_start + i) + 48);
#line 1916
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1918
  *(dest + bytes) = (char)0;
#line 1920
  free((void *)mem);
  }
#line 1921
  return (bv + 2UL);
}
}
#line 1925 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_fxrandom(ikptr x ) 
{ 
  long mask ;
  long n ;
  int tmp ;
  long r ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1927
  mask = 1L;
#line 1928
  if ((int )sizeof(ikptr ) == 4) {
#line 1928
    tmp = 2;
  } else {
#line 1928
    tmp = 3;
  }
#line 1928
  n = (long )x >> tmp;
  {
#line 1930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1930
    if (! (mask < n)) {
#line 1930
      goto while_break;
    }
#line 1931
    mask = (mask << 1) | 1L;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1934
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1935
    tmp___0 = rand();
#line 1935
    r = (long )tmp___0 & mask;
    }
#line 1936
    if (r < n) {
#line 1937
      if ((int )sizeof(ikptr ) == 4) {
#line 1937
        tmp___1 = 2;
      } else {
#line 1937
        tmp___1 = 3;
      }
#line 1937
      return ((ikptr )(r << tmp___1));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 1942 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int limb_size(mp_limb_t x ) 
{ 
  int i ;

  {
#line 1944
  i = 0;
  {
#line 1945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1945
    if (! x) {
#line 1945
      goto while_break;
    }
#line 1946
    i ++;
#line 1947
    x >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1949
  return (i);
}
}
#line 1952 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int all_zeros(mp_limb_t *start , mp_limb_t *end ) 
{ 


  {
  {
#line 1954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1954
    if (! ((unsigned long )start <= (unsigned long )end)) {
#line 1954
      goto while_break;
    }
#line 1955
    if (*end) {
#line 1955
      return (0);
    }
#line 1956
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1958
  return (1);
}
}
#line 1963 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static ikptr ikrt_bignum_to_flonum64(ikptr bn , ikptr more_bits , ikptr fl ) 
{ 
  ikptr fst ;
  long limb_count ;
  mp_limb_t *sp ;
  double pos_result ;
  mp_limb_t hi ;
  int bc ;
  int tmp ;
  mp_limb_t mi ;
  mp_limb_t mask ;
  int tmp___0 ;
  int bignum_bits ;
  int exponent ;

  {
#line 1965
  fst = *((ikptr *)((long )bn + -5L) + 0);
#line 1966
  limb_count = (long )(fst >> 4);
#line 1967
  sp = (mp_limb_t *)((long )(bn + (ikptr )((int )sizeof(ikptr ) - 5)));
#line 1969
  if (limb_count == 1L) {
#line 1970
    pos_result = (double )*(sp + 0);
  } else {
    {
#line 1972
    hi = *(sp + (limb_count - 1L));
#line 1973
    tmp = limb_size(hi);
#line 1973
    bc = tmp;
    }
#line 1974
    if (bc < 64) {
#line 1975
      mi = *(sp + (limb_count - 2L));
#line 1976
      hi = (hi << (64 - bc)) | (mi >> bc);
    }
#line 1979
    mask = (mp_limb_t )((1L << 11) - 1L);
#line 1980
    if ((hi & mask) == (mask + 1UL) >> 1) {
#line 1982
      if (*(sp + (limb_count - 2L)) << (64 - bc) == 0UL) {
        {
#line 1982
        tmp___0 = all_zeros(sp, (sp + limb_count) - 3);
        }
#line 1982
        if (tmp___0) {
#line 1982
          if (more_bits == 0UL) {
#line 1985
            if (hi & (unsigned long )(1L << 11)) {
#line 1987
              hi |= mask;
            }
          } else {
#line 1991
            hi |= mask;
          }
        } else {
#line 1991
          hi |= mask;
        }
      } else {
#line 1991
        hi |= mask;
      }
    } else
#line 1993
    if ((hi & mask) > (mask + 1UL) >> 1) {
#line 1995
      hi |= mask;
    }
#line 1999
    pos_result = (double )hi;
#line 2000
    bignum_bits = (int )((long )bc + (long )__gmp_bits_per_limb * (limb_count - 1L));
#line 2001
    exponent = bignum_bits - (int )__gmp_bits_per_limb;
    {
#line 2002
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2002
      if (! exponent) {
#line 2002
        goto while_break;
      }
#line 2003
      pos_result *= 2.0;
#line 2004
      exponent --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2007
  if (fst & 8UL) {
#line 2008
    *((double *)((char *)((long )fl) + 3)) = - pos_result;
  } else {
#line 2010
    *((double *)((char *)((long )fl) + 3)) = pos_result;
  }
#line 2012
  return (fl);
}
}
#line 2015 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bignum_to_flonum(ikptr bn , ikptr more_bits , ikptr fl ) 
{ 
  ikptr tmp ;
  ikptr fst ;
  long limb_count ;
  mp_limb_t *sp ;
  double pos_result ;
  mp_limb_t lo ;
  mp_limb_t hi ;
  mp_limb_t hi___0 ;
  mp_limb_t mi ;
  int bc ;
  int tmp___0 ;
  mp_limb_t lo___0 ;
  mp_limb_t mask ;
  int tmp___1 ;
  int bignum_bits ;
  int exponent ;

  {
#line 2017
  if (__gmp_bits_per_limb == 64) {
    {
#line 2018
    tmp = ikrt_bignum_to_flonum64(bn, more_bits, fl);
    }
#line 2018
    return (tmp);
  }
#line 2020
  fst = *((ikptr *)((long )bn + -5L) + 0);
#line 2021
  limb_count = (long )(fst >> 4);
#line 2022
  sp = (mp_limb_t *)((long )(bn + (ikptr )((int )sizeof(ikptr ) - 5)));
#line 2024
  if (limb_count == 1L) {
#line 2025
    pos_result = (double )*(sp + 0);
  } else
#line 2026
  if (limb_count == 2L) {
#line 2027
    lo = *(sp + 0);
#line 2028
    hi = *(sp + 1);
#line 2029
    pos_result = (double )hi;
#line 2030
    pos_result *= 4294967296.0;
#line 2031
    pos_result += (double )lo;
  } else {
    {
#line 2033
    hi___0 = *(sp + (limb_count - 1L));
#line 2034
    mi = *(sp + (limb_count - 2L));
#line 2035
    tmp___0 = limb_size(hi___0);
#line 2035
    bc = tmp___0;
    }
#line 2036
    if (bc < 32) {
#line 2037
      lo___0 = *(sp + (limb_count - 3L));
#line 2038
      hi___0 = (hi___0 << (32 - bc)) | (mi >> bc);
#line 2039
      mi = (mi << (32 - bc)) | (lo___0 >> bc);
    }
#line 2042
    mask = (mp_limb_t )((1 << 11) - 1);
#line 2043
    if ((mi & mask) == (mask + 1UL) >> 1) {
#line 2045
      if (*(sp + (limb_count - 3L)) << (32 - bc) == 0UL) {
        {
#line 2045
        tmp___1 = all_zeros(sp, (sp + limb_count) - 4);
        }
#line 2045
        if (tmp___1) {
#line 2045
          if (more_bits == 0UL) {
#line 2048
            if (mi & (unsigned long )(1 << 11)) {
#line 2050
              mi |= mask;
            }
          } else {
#line 2054
            mi |= mask;
          }
        } else {
#line 2054
          mi |= mask;
        }
      } else {
#line 2054
        mi |= mask;
      }
    } else
#line 2056
    if ((mi & mask) > (mask + 1UL) >> 1) {
#line 2058
      mi |= mask;
    }
#line 2062
    pos_result = (double )hi___0;
#line 2063
    pos_result *= 4294967296.0;
#line 2064
    pos_result += (double )mi;
#line 2065
    bignum_bits = (int )((long )bc + (long )__gmp_bits_per_limb * (limb_count - 1L));
#line 2066
    exponent = bignum_bits - 2 * (int )__gmp_bits_per_limb;
    {
#line 2067
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2067
      if (! exponent) {
#line 2067
        goto while_break;
      }
#line 2068
      pos_result *= 2.0;
#line 2069
      exponent --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2072
  if (fst & 8UL) {
#line 2073
    *((double *)((char *)((long )fl) + 3)) = - pos_result;
  } else {
#line 2075
    *((double *)((char *)((long )fl) + 3)) = pos_result;
  }
#line 2077
  return (fl);
}
}
#line 2080 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_exact_fixnum_sqrt(ikptr fx ) 
{ 
  mp_limb_t x ;
  int tmp ;
  mp_limb_t s ;
  mp_limb_t r ;
  int tmp___0 ;

  {
#line 2082
  if ((int )sizeof(ikptr ) == 4) {
#line 2082
    tmp = 2;
  } else {
#line 2082
    tmp = 3;
  }
  {
#line 2082
  x = (mp_limb_t )((long )fx >> tmp);
#line 2085
  __gmpn_sqrtrem(& s, & r, (mp_srcptr )(& x), (mp_size_t )1);
  }
#line 2086
  if ((int )sizeof(ikptr ) == 4) {
#line 2086
    tmp___0 = 2;
  } else {
#line 2086
    tmp___0 = 3;
  }
#line 2086
  return ((ikptr )((long )s << tmp___0));
}
}
#line 2089 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_exact_bignum_sqrt(ikptr bn , ikpcb *pcb ) 
{ 
  ikptr fst ;
  long limb_count ;
  long result_limb_count ;
  ikptr s ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  ikptr r ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  ikptr pair ;
  ikptr tmp___5 ;
  mp_size_t r_actual_limbs ;
  mp_size_t tmp___6 ;

  {
#line 2091
  fst = *((ikptr *)((long )bn + -5L) + 0);
#line 2092
  limb_count = (long )(fst >> 4);
#line 2093
  result_limb_count = (limb_count + 1L) / 2L;
#line 2094
  pcb->root0 = & bn;
#line 2095
  if ((int )sizeof(ikptr ) == 4) {
#line 2095
    tmp = 2;
  } else {
#line 2095
    tmp = 3;
  }
#line 2095
  if ((int )sizeof(ikptr ) == 4) {
#line 2095
    tmp___0 = 2;
  } else {
#line 2095
    tmp___0 = 3;
  }
  {
#line 2095
  tmp___1 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + result_limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp + 1)) << (tmp___0 + 1)));
#line 2095
  s = tmp___1 + 5UL;
#line 2098
  *((ikptr *)((long )s + -5L) + 0) = (ikptr )(3L | (result_limb_count << 4));
#line 2100
  pcb->root1 = & s;
  }
#line 2101
  if ((int )sizeof(ikptr ) == 4) {
#line 2101
    tmp___2 = 2;
  } else {
#line 2101
    tmp___2 = 3;
  }
#line 2101
  if ((int )sizeof(ikptr ) == 4) {
#line 2101
    tmp___3 = 2;
  } else {
#line 2101
    tmp___3 = 3;
  }
  {
#line 2101
  tmp___4 = ik_safe_alloc(pcb, (int )((((((long )((int )sizeof(ikptr )) + limb_count * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___2 + 1)) << (tmp___3 + 1)));
#line 2101
  r = tmp___4 + 5UL;
#line 2104
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )(3L | (limb_count << 4));
#line 2106
  pcb->root0 = & r;
#line 2107
  tmp___5 = ik_safe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 2107
  pair = tmp___5 + 1UL;
#line 2108
  pcb->root0 = (ikptr *)0;
#line 2109
  pcb->root1 = (ikptr *)0;
#line 2110
  tmp___6 = __gmpn_sqrtrem((mp_limb_t *)(s + (ikptr )((int )sizeof(ikptr ) - 5)),
                           (mp_limb_t *)(r + (ikptr )((int )sizeof(ikptr ) - 5)),
                           (mp_srcptr )((mp_limb_t *)(bn + (ikptr )((int )sizeof(ikptr ) - 5))),
                           limb_count);
#line 2110
  r_actual_limbs = tmp___6;
#line 2115
  *((ikptr *)((long )pair + -1L) + 0) = normalize_bignum(result_limb_count, 0, s - 5UL);
  }
#line 2116
  if (r_actual_limbs == 0L) {
#line 2118
    *((ikptr *)((long )pair + (long )((int )sizeof(ikptr ) - 1)) + 0) = (ikptr )0;
  } else {
    {
#line 2120
    *((ikptr *)((long )pair + (long )((int )sizeof(ikptr ) - 1)) + 0) = normalize_bignum(r_actual_limbs,
                                                                                         0,
                                                                                         r - 5UL);
    }
  }
#line 2122
  return (pair);
}
}
#line 2126 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_flonum_hash(ikptr x ) 
{ 
  short *buf ;
  int tmp ;

  {
#line 2128
  buf = (short *)(x + 3UL);
#line 2129
  if ((int )sizeof(ikptr ) == 4) {
#line 2129
    tmp = 2;
  } else {
#line 2129
    tmp = 3;
  }
#line 2129
  return ((ikptr )(((((long )*(buf + 0) ^ ((long )*(buf + 1) << 3)) ^ ((long )*(buf + 3) << 7)) ^ ((long )*(buf + 2) << 11)) << tmp));
}
}
#line 2134 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
ikptr ikrt_bignum_hash(ikptr bn ) 
{ 
  ikptr fst ;
  long limb_count ;
  long h ;
  mp_limb_t *dat ;
  long i ;
  int tmp ;

  {
#line 2136
  fst = *((ikptr *)((long )bn + -5L) + 0);
#line 2137
  limb_count = (long )(fst >> 4);
#line 2138
  h = (long )fst;
#line 2139
  dat = (mp_limb_t *)(bn + (ikptr )((int )sizeof(ikptr ) - 5));
#line 2141
  i = 0L;
  {
#line 2141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2141
    if (! (i < limb_count)) {
#line 2141
      goto while_break;
    }
#line 2142
    h = (long )(((unsigned long )h ^ *(dat + i)) << 3);
#line 2141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2144
  if ((int )sizeof(ikptr ) == 4) {
#line 2144
    tmp = 2;
  } else {
#line 2144
    tmp = 3;
  }
#line 2144
  return ((ikptr )(h << tmp));
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
ikptr ik_exec_code(ikpcb *pcb , ikptr code_ptr , ikptr argcount , ikptr cp ) ;
#line 204
extern ikptr ik_asm_enter(ikpcb * , ikptr code_object , ikptr arg , ikptr cp ) ;
#line 205
extern ikptr ik_asm_reenter(ikpcb * , ikptr code_object , ikptr val ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-exec.c"
ikptr ik_exec_code(ikpcb *pcb , ikptr code_ptr , ikptr argcount , ikptr cp ) 
{ 
  ikptr argc ;
  ikptr tmp ;
  ikptr next_k ;
  cont *k ;
  ikptr top ;
  ikptr rp ;
  long framesize ;
  int tmp___0 ;
  cont *nk ;
  ikptr tmp___1 ;
  unsigned long idx ;
  long offset ;
  int tmp___2 ;
  ikptr fbase ;
  ikptr new_fbase ;
  ikptr rv ;

  {
  {
#line 29
  tmp = ik_asm_enter(pcb, code_ptr + (ikptr )(6 * (int )sizeof(ikptr ) - 5), argcount,
                     cp);
#line 29
  argc = tmp;
#line 30
  next_k = pcb->next_k;
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! next_k) {
#line 31
      goto while_break;
    }
#line 32
    k = (cont *)((long )(next_k - 5UL));
#line 33
    if (k->tag == 287UL) {
#line 34
      goto while_break;
    }
#line 36
    top = k->top;
#line 37
    rp = *((ikptr *)((long )top) + 0);
#line 38
    if ((int )sizeof(ikptr ) == 4) {
#line 38
      tmp___0 = 5;
    } else {
#line 38
      tmp___0 = 10;
    }
#line 38
    framesize = (long )*((ikptr *)((long )rp + (long )(- (tmp___0 + 3 * (int )sizeof(ikptr )))) + 0);
#line 43
    if (framesize == 0L) {
#line 44
      framesize = (long )*((ikptr *)((long )top + (long )((int )sizeof(ikptr ))) + 0);
    }
#line 46
    if (framesize <= 0L) {
      {
#line 47
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid framesize %ld\n",
              framesize);
#line 48
      exit(-10);
      }
    }
#line 50
    if (framesize < k->size) {
      {
#line 51
      tmp___1 = ik_unsafe_alloc(pcb, (int )sizeof(cont ));
#line 51
      nk = (cont *)((long )tmp___1);
#line 52
      nk->tag = k->tag;
#line 53
      nk->next = k->next;
#line 54
      nk->top = top + (ikptr )framesize;
#line 55
      nk->size = k->size - framesize;
#line 56
      k->size = framesize;
#line 57
      k->next = 5UL + (ikptr )((long )nk);
#line 59
      idx = (unsigned long )(& k->next) >> 12;
#line 60
      *((unsigned int *)((long )pcb->dirty_vector) + idx) = 4294967295U;
      }
    } else
#line 61
    if (framesize > k->size) {
      {
#line 62
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ikarus internal error: invalid framesize %ld, expected %ld or less\n",
              framesize, k->size);
      }
#line 65
      if ((int )sizeof(ikptr ) == 4) {
#line 65
        tmp___2 = 5;
      } else {
#line 65
        tmp___2 = 10;
      }
      {
#line 65
      offset = (long )*((ikptr *)((long )rp + (long )(- (tmp___2 + 2 * (int )sizeof(ikptr )))) + 0);
#line 66
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rp = 0x%016lx\n",
              rp);
#line 67
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rp offset = %ld\n",
              offset);
#line 68
      exit(-10);
      }
    }
    {
#line 70
    pcb->next_k = k->next;
#line 71
    fbase = pcb->frame_base - (ikptr )((int )sizeof(ikptr ));
#line 72
    new_fbase = fbase - (ikptr )framesize;
#line 73
    memmove((void *)((char *)((long )new_fbase) + argc), (void const   *)((char *)((long )fbase) + argc),
            - argc);
#line 76
    memcpy((void */* __restrict  */)((char *)((long )new_fbase)), (void const   */* __restrict  */)((char *)((long )top)),
           (size_t )framesize);
#line 77
    argc = ik_asm_reenter(pcb, new_fbase, argc);
#line 78
    next_k = pcb->next_k;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  rv = *((ikptr *)((long )pcb->frame_base + (long )(-2 * (int )sizeof(ikptr ))) + 0);
#line 81
  return (rv);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static int extension_amount[6]  = {      4096,      4096,      4096,      4096, 
        4096,      4096};
#line 83 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static unsigned int meta_mt[6]  = {      70400U,      70912U,      66560U,      71168U, 
        70400U,      71424U};
#line 106
static void handle_guardians(gc_t *gc ) ;
#line 107
static void gc_finalize_guardians(gc_t *gc ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static unsigned int next_gen_tag[5]  = {      (unsigned int )(((4 << 4) | 1) | 8),      (unsigned int )(((2 << 4) | 2) | 8),      (unsigned int )(((1 << 4) | 3) | 8),      12U, 
        12U};
#line 118 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static ikptr meta_alloc_extending(long size , gc_t *gc , int meta_id ) 
{ 
  long mapsize ;
  meta_t *meta ;
  qupages_t *p ;
  void *tmp ;
  ikptr aq ;
  ikptr ap ;
  ikptr ep ;
  ikptr x ;
  ikptr mem ;
  ikptr tmp___0 ;

  {
#line 120
  mapsize = (long )(((4095UL + (unsigned long )size) >> 12) << 12);
#line 121
  if (mapsize < (long )extension_amount[meta_id]) {
#line 122
    mapsize = (long )extension_amount[meta_id];
  }
#line 124
  meta = & gc->meta[meta_id];
#line 125
  if (meta_id != 2) {
#line 125
    if (meta->base) {
      {
#line 126
      tmp = ik_malloc((int )sizeof(qupages_t ));
#line 126
      p = (qupages_t *)tmp;
#line 127
      aq = meta->aq;
#line 128
      ap = meta->ap;
#line 129
      ep = meta->ep;
#line 130
      p->p = aq;
#line 131
      p->q = ap;
#line 132
      p->next = gc->queues[meta_id];
#line 133
      gc->queues[meta_id] = p;
#line 134
      x = ap;
      }
      {
#line 135
      while (1) {
        while_continue: /* CIL Label */ ;
#line 135
        if (! (x < ep)) {
#line 135
          goto while_break;
        }
#line 136
        *((ikptr *)((long )x) + 0) = (ikptr )0;
#line 137
        x += (ikptr )((int )sizeof(ikptr ));
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 140
  tmp___0 = ik_mmap_typed((unsigned long )mapsize, meta_mt[meta_id] | (unsigned int )gc->collect_gen_tag,
                          gc->pcb);
#line 140
  mem = tmp___0;
#line 144
  gc->segment_vector = (gc->pcb)->segment_vector;
#line 145
  meta->ap = mem + (ikptr )size;
#line 146
  meta->aq = mem;
#line 147
  meta->ep = mem + (ikptr )mapsize;
#line 148
  meta->base = mem;
  }
#line 149
  return (mem);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr meta_alloc(long size , gc_t *gc , int meta_id ) 
{ 
  meta_t *meta ;
  ikptr ap ;
  ikptr ep ;
  ikptr nap ;
  ikptr tmp ;

  {
#line 158
  meta = & gc->meta[meta_id];
#line 159
  ap = meta->ap;
#line 160
  ep = meta->ep;
#line 161
  nap = ap + (ikptr )size;
#line 162
  if (nap > ep) {
    {
#line 163
    tmp = meta_alloc_extending(size, gc, meta_id);
    }
#line 163
    return (tmp);
  } else {
#line 165
    meta->ap = nap;
#line 166
    return (ap);
  }
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_ptr(int size , gc_t *gc ) 
{ 
  ikptr tmp ;

  {
  {
#line 173
  tmp = meta_alloc((long )size, gc, 0);
  }
#line 173
  return (tmp);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_large_ptr(int size , gc_t *gc ) 
{ 
  int memreq ;
  ikptr mem ;
  ikptr tmp ;
  qupages_t *p ;
  void *tmp___0 ;

  {
  {
#line 178
  memreq = (int )(((4095UL + (unsigned long )size) >> 12) << 12);
#line 179
  tmp = ik_mmap_typed((unsigned long )memreq, (unsigned int )(1118976 | gc->collect_gen_tag),
                      gc->pcb);
#line 179
  mem = tmp;
#line 183
  gc->segment_vector = (gc->pcb)->segment_vector;
#line 184
  tmp___0 = ik_malloc((int )sizeof(qupages_t ));
#line 184
  p = (qupages_t *)tmp___0;
#line 185
  p->p = mem;
#line 186
  p->q = mem + (ikptr )size;
#line 187
  bzero((void *)((char *)((long )(mem + (ikptr )size))), (size_t )(memreq - size));
#line 188
  p->next = gc->queues[0];
#line 189
  gc->queues[0] = p;
  }
#line 190
  return (mem);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static void enqueue_large_ptr(ikptr mem , int size , gc_t *gc ) 
{ 
  long i ;
  long j ;
  qupages_t *p ;
  void *tmp ;

  {
#line 196
  i = (long )(mem >> 12);
#line 197
  j = (long )(((mem + (ikptr )size) - 1UL) >> 12);
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i <= j)) {
#line 198
      goto while_break;
    }
#line 199
    *(gc->segment_vector + i) = (unsigned int )(1118976 | gc->collect_gen_tag);
#line 201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  tmp = ik_malloc((int )sizeof(qupages_t ));
#line 203
  p = (qupages_t *)tmp;
#line 204
  p->p = mem;
#line 205
  p->q = mem + (ikptr )size;
#line 206
  p->next = gc->queues[0];
#line 207
  gc->queues[0] = p;
  }
#line 208
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_symbol_record(gc_t *gc ) 
{ 
  ikptr tmp ;

  {
  {
#line 214
  tmp = meta_alloc((long )(6 * (int )sizeof(ikptr )), gc, 5);
  }
#line 214
  return (tmp);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_pair(gc_t *gc ) 
{ 
  ikptr tmp ;

  {
  {
#line 222
  tmp = meta_alloc((long )(2 * (int )sizeof(ikptr )), gc, 4);
  }
#line 222
  return (tmp);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_weak_pair(gc_t *gc ) 
{ 
  meta_t *meta ;
  ikptr ap ;
  ikptr ep ;
  ikptr nap ;
  ikptr mem ;
  ikptr tmp ;

  {
#line 229
  meta = & gc->meta[3];
#line 230
  ap = meta->ap;
#line 231
  ep = meta->ep;
#line 232
  nap = ap + (ikptr )(2 * (int )sizeof(ikptr ));
#line 233
  if (nap > ep) {
    {
#line 234
    tmp = ik_mmap_typed(4096UL, meta_mt[3] | (unsigned int )gc->collect_gen_tag, gc->pcb);
#line 234
    mem = tmp;
#line 238
    gc->segment_vector = (gc->pcb)->segment_vector;
#line 239
    meta->ap = mem + (ikptr )(2 * (int )sizeof(ikptr ));
#line 240
    meta->aq = mem;
#line 241
    meta->ep = mem + 4096UL;
#line 242
    meta->base = mem;
    }
#line 243
    return (mem);
  } else {
#line 245
    meta->ap = nap;
#line 246
    return (ap);
  }
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_data(int size , gc_t *gc ) 
{ 
  ikptr tmp ;

  {
  {
#line 253
  tmp = meta_alloc((long )size, gc, 2);
  }
#line 253
  return (tmp);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_code(long size , gc_t *gc ) 
{ 
  ikptr tmp ;
  long memreq ;
  ikptr mem ;
  ikptr tmp___0 ;
  qupages_t *p ;
  void *tmp___1 ;

  {
#line 259
  if (size < 4096L) {
    {
#line 260
    tmp = meta_alloc(size, gc, 1);
    }
#line 260
    return (tmp);
  } else {
    {
#line 262
    memreq = (long )(((4095UL + (unsigned long )size) >> 12) << 12);
#line 263
    tmp___0 = ik_mmap_code((unsigned long )memreq, gc->collect_gen, gc->pcb);
#line 263
    mem = tmp___0;
#line 264
    gc->segment_vector = (gc->pcb)->segment_vector;
#line 265
    tmp___1 = ik_malloc((int )sizeof(qupages_t ));
#line 265
    p = (qupages_t *)tmp___1;
#line 266
    p->p = mem;
#line 267
    p->q = mem + (ikptr )size;
#line 268
    bzero((void *)((char *)((long )(mem + (ikptr )size))), (size_t )(memreq - size));
#line 269
    p->next = gc->queues[1];
#line 270
    gc->queues[1] = p;
    }
#line 271
    return (mem);
  }
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void add_to_collect_count(ikpcb *pcb , int bytes ) 
{ 
  int minor ;

  {
#line 277
  minor = bytes + pcb->allocation_count_minor;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (minor >= 268435456)) {
#line 278
      goto while_break;
    }
#line 279
    minor -= 268435456;
#line 280
    (pcb->allocation_count_major) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  pcb->allocation_count_minor = minor;
#line 283
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void gc_tconc_push_extending(gc_t *gc , ikptr tcbucket ) 
{ 
  ikpages *p ;
  void *tmp ;
  ikptr ap ;
  ikptr tmp___0 ;
  ikptr nap ;

  {
#line 290
  if (gc->tconc_base) {
    {
#line 291
    tmp = ik_malloc((int )sizeof(ikpages ));
#line 291
    p = (ikpages *)tmp;
#line 292
    p->base = gc->tconc_base;
#line 293
    p->size = 4096;
#line 294
    p->next = gc->tconc_queue;
#line 295
    gc->tconc_queue = p;
    }
  }
  {
#line 297
  tmp___0 = ik_mmap_typed(4096UL, meta_mt[0] | (unsigned int )gc->collect_gen_tag,
                          gc->pcb);
#line 297
  ap = tmp___0;
#line 301
  add_to_collect_count(gc->pcb, 4096);
#line 302
  gc->segment_vector = (gc->pcb)->segment_vector;
#line 303
  bzero((void *)((char *)((long )ap)), (size_t )4096);
#line 304
  nap = ap + (ikptr )(2 * (int )sizeof(ikptr ));
#line 305
  gc->tconc_base = ap;
#line 306
  gc->tconc_ap = nap;
#line 307
  gc->tconc_ep = ap + 4096UL;
#line 308
  *((ikptr *)((long )ap) + 0) = tcbucket;
  }
#line 309
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static void gc_tconc_push(gc_t *gc , ikptr tcbucket ) 
{ 
  ikptr ap ;
  ikptr nap ;

  {
#line 314
  ap = gc->tconc_ap;
#line 315
  nap = ap + (ikptr )(2 * (int )sizeof(ikptr ));
#line 316
  if (nap > gc->tconc_ep) {
    {
#line 317
    gc_tconc_push_extending(gc, tcbucket);
    }
  } else {
#line 319
    gc->tconc_ap = nap;
#line 320
    *((ikptr *)((long )ap) + 0) = tcbucket;
  }
#line 322
  return;
}
}
#line 329
static ikptr add_object_proc(gc_t *gc , ikptr x ) ;
#line 333
static void collect_stack(gc_t *gc , ikptr top , ikptr end ) ;
#line 334
static void collect_locatives(gc_t *gc , callback_locative *loc ) ;
#line 335
static void collect_loop(gc_t *gc ) ;
#line 336
static void fix_weak_pointers(gc_t *gc ) ;
#line 337
static void gc_add_tconcs(gc_t *gc ) ;
#line 356 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
ikpcb *ik_collect_vararg(int req , ikpcb *pcb ) 
{ 
  ikpcb *tmp ;

  {
  {
#line 357
  tmp = ik_collect((unsigned long )req, pcb);
  }
#line 357
  return (tmp);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static int collection_id_to_gen(int id ) 
{ 


  {
#line 361
  if ((id & 255) == 255) {
#line 361
    return (4);
  }
#line 362
  if ((id & 63) == 63) {
#line 362
    return (3);
  }
#line 363
  if ((id & 15) == 15) {
#line 363
    return (2);
  }
#line 364
  if ((id & 3) == 3) {
#line 364
    return (1);
  }
#line 365
  return (0);
}
}
#line 370
static void scan_dirty_pages(gc_t *gc ) ;
#line 372
static void deallocate_unused_pages(gc_t *gc ) ;
#line 374
static void fix_new_pages(gc_t *gc ) ;
#line 378 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
ikptr ik_collect_check(unsigned long req , ikpcb *pcb ) 
{ 
  long bytes ;

  {
#line 379
  bytes = (long )pcb->allocation_redline - (long )pcb->allocation_pointer;
#line 381
  if ((unsigned long )bytes >= req) {
#line 382
    return ((ikptr )63);
  } else {
    {
#line 384
    ik_collect(req, pcb);
    }
#line 385
    return ((ikptr )47);
  }
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
ikpcb *ik_collect(unsigned long mem_req , ikpcb *pcb ) 
{ 
  long bytes ;
  struct rusage t0 ;
  struct rusage t1 ;
  struct timeval rt0 ;
  struct timeval rt1 ;
  gc_t gc ;
  ikpages *old_heap_pages ;
  ikpages *p ;
  ikpages *next ;
  unsigned long free_space ;
  long memsize ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  ikptr ptr ;
  ikptr tmp___3 ;
  int tmp___4 ;

  {
  {
#line 396
  bytes = (long )pcb->allocation_pointer - (long )pcb->heap_base;
#line 398
  add_to_collect_count(pcb, (int )bytes);
#line 403
  gettimeofday((struct timeval */* __restrict  */)(& rt0), (__timezone_ptr_t )0);
#line 404
  getrusage(0, & t0);
#line 406
  pcb->collect_key = (ikptr )47;
#line 408
  bzero((void *)(& gc), sizeof(gc_t ));
#line 409
  gc.pcb = pcb;
#line 410
  gc.segment_vector = pcb->segment_vector;
#line 412
  gc.collect_gen = collection_id_to_gen(pcb->collection_id);
#line 413
  gc.collect_gen_tag = (int )next_gen_tag[gc.collect_gen];
#line 414
  (pcb->collection_id) ++;
#line 423
  old_heap_pages = pcb->heap_pages;
#line 424
  pcb->heap_pages = (ikpages *)0;
#line 433
  scan_dirty_pages(& gc);
#line 435
  collect_stack(& gc, pcb->frame_pointer, pcb->frame_base - (ikptr )((int )sizeof(ikptr )));
#line 436
  collect_locatives(& gc, pcb->callbacks);
#line 437
  pcb->next_k = add_object_proc(& gc, pcb->next_k);
#line 438
  pcb->symbol_table = add_object_proc(& gc, pcb->symbol_table);
#line 439
  pcb->gensym_table = add_object_proc(& gc, pcb->gensym_table);
#line 440
  pcb->arg_list = add_object_proc(& gc, pcb->arg_list);
#line 441
  pcb->base_rtd = add_object_proc(& gc, pcb->base_rtd);
  }
#line 442
  if (pcb->root0) {
    {
#line 442
    *(pcb->root0) = add_object_proc(& gc, *(pcb->root0));
    }
  }
#line 443
  if (pcb->root1) {
    {
#line 443
    *(pcb->root1) = add_object_proc(& gc, *(pcb->root1));
    }
  }
  {
#line 446
  collect_loop(& gc);
#line 450
  handle_guardians(& gc);
#line 454
  collect_loop(& gc);
#line 457
  fix_weak_pointers(& gc);
#line 459
  deallocate_unused_pages(& gc);
#line 461
  fix_new_pages(& gc);
#line 462
  gc_finalize_guardians(& gc);
#line 464
  pcb->allocation_pointer = pcb->heap_base;
#line 466
  gc_add_tconcs(& gc);
#line 471
  pcb->weak_pairs_ap = (ikptr )0;
#line 472
  pcb->weak_pairs_ep = (ikptr )0;
  }
#line 501
  if (old_heap_pages) {
#line 502
    p = old_heap_pages;
    {
#line 503
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 504
      next = p->next;
#line 505
      ik_munmap_from_segment(p->base, (unsigned long )p->size, pcb);
#line 506
      ik_free((void *)p, (int )sizeof(ikpages ));
#line 507
      p = next;
      }
#line 503
      if (! p) {
#line 503
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 509
    old_heap_pages = (ikpages *)0;
  }
#line 512
  free_space = pcb->allocation_redline - pcb->allocation_pointer;
#line 515
  if (free_space <= mem_req) {
#line 515
    goto _L;
  } else {
#line 515
    if ((int )sizeof(ikptr ) == 4) {
#line 515
      tmp___4 = 1;
    } else {
#line 515
      tmp___4 = 2;
    }
#line 515
    if (pcb->heap_size < (unsigned long )((1024 * tmp___4) * 4096)) {
      _L: /* CIL Label */ 
#line 519
      if ((int )sizeof(ikptr ) == 4) {
#line 519
        tmp___2 = 1;
      } else {
#line 519
        tmp___2 = 2;
      }
#line 519
      if (mem_req > (unsigned long )((1024 * tmp___2) * 4096)) {
#line 519
        tmp___1 = mem_req;
      } else {
#line 519
        if ((int )sizeof(ikptr ) == 4) {
#line 519
          tmp___0 = 1;
        } else {
#line 519
          tmp___0 = 2;
        }
#line 519
        tmp___1 = (unsigned long )((1024 * tmp___0) * 4096);
      }
      {
#line 519
      memsize = (long )tmp___1;
#line 520
      memsize = (long )(((4095UL + (unsigned long )memsize) >> 12) << 12);
#line 521
      ik_munmap_from_segment(pcb->heap_base, pcb->heap_size, pcb);
#line 525
      tmp___3 = ik_mmap_mixed((unsigned long )(memsize + 8192L), pcb);
#line 525
      ptr = tmp___3;
#line 526
      pcb->allocation_pointer = ptr;
#line 527
      pcb->allocation_redline = ptr + (ikptr )memsize;
#line 528
      pcb->heap_base = ptr;
#line 529
      pcb->heap_size = (unsigned long )(memsize + 8192L);
      }
    }
  }
  {
#line 543
  getrusage(0, & t1);
#line 544
  gettimeofday((struct timeval */* __restrict  */)(& rt1), (__timezone_ptr_t )0);
#line 546
  pcb->collect_utime.tv_usec += t1.ru_utime.tv_usec - t0.ru_utime.tv_usec;
#line 547
  pcb->collect_utime.tv_sec += t1.ru_utime.tv_sec - t0.ru_utime.tv_sec;
  }
#line 548
  if (pcb->collect_utime.tv_usec >= 1000000L) {
#line 549
    pcb->collect_utime.tv_usec -= 1000000L;
#line 550
    (pcb->collect_utime.tv_sec) ++;
  } else
#line 552
  if (pcb->collect_utime.tv_usec < 0L) {
#line 553
    pcb->collect_utime.tv_usec += 1000000L;
#line 554
    (pcb->collect_utime.tv_sec) --;
  }
#line 557
  pcb->collect_stime.tv_usec += t1.ru_stime.tv_usec - t0.ru_stime.tv_usec;
#line 558
  pcb->collect_stime.tv_sec += t1.ru_stime.tv_sec - t0.ru_stime.tv_sec;
#line 559
  if (pcb->collect_stime.tv_usec >= 1000000L) {
#line 560
    pcb->collect_stime.tv_usec -= 1000000L;
#line 561
    (pcb->collect_stime.tv_sec) ++;
  } else
#line 563
  if (pcb->collect_stime.tv_usec < 0L) {
#line 564
    pcb->collect_stime.tv_usec += 1000000L;
#line 565
    (pcb->collect_stime.tv_sec) --;
  }
#line 568
  pcb->collect_rtime.tv_usec += rt1.tv_usec - rt0.tv_usec;
#line 569
  pcb->collect_rtime.tv_sec += rt1.tv_sec - rt0.tv_sec;
#line 570
  if (pcb->collect_rtime.tv_usec >= 1000000L) {
#line 571
    pcb->collect_rtime.tv_usec -= 1000000L;
#line 572
    (pcb->collect_rtime.tv_sec) ++;
  } else
#line 574
  if (pcb->collect_rtime.tv_usec < 0L) {
#line 575
    pcb->collect_rtime.tv_usec += 1000000L;
#line 576
    (pcb->collect_rtime.tv_sec) --;
  }
#line 578
  return (pcb);
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static int is_live(ikptr x , gc_t *gc ) 
{ 
  int tag ;
  unsigned int t ;
  int gen ;

  {
#line 583
  if ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 584
    return (1);
  }
#line 586
  tag = (int )x & 7;
#line 587
  if (tag == 7) {
#line 588
    return (1);
  }
#line 590
  if (*((ikptr *)((long )x + (long )(- tag)) + 0) == 0xffffffffffffffffUL) {
#line 591
    return (1);
  }
#line 593
  t = *(gc->segment_vector + (x >> 12));
#line 594
  gen = (int )(t & 15U);
#line 595
  if (gen > gc->collect_gen) {
#line 596
    return (1);
  }
#line 598
  return (0);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static int next_gen(int i ) 
{ 
  int tmp ;

  {
#line 603
  if (i == 4) {
#line 603
    tmp = i;
  } else {
#line 603
    tmp = i + 1;
  }
#line 603
  return (tmp);
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static ik_ptr_page *move_tconc(ikptr tc , ik_ptr_page *ls ) 
{ 
  ik_ptr_page *page ;
  ikptr tmp ;
  long tmp___0 ;

  {
#line 609
  if ((unsigned long )ls == (unsigned long )((void *)0)) {
    {
#line 610
    tmp = ik_mmap(4096UL);
#line 610
    page = (ik_ptr_page *)tmp;
#line 611
    page->count = 0L;
#line 612
    page->next = ls;
#line 613
    ls = page;
    }
  } else
#line 609
  if ((unsigned long )ls->count == ((4096UL - sizeof(long )) - sizeof(struct ik_ptr_page *)) / sizeof(ikptr )) {
    {
#line 610
    tmp = ik_mmap(4096UL);
#line 610
    page = (ik_ptr_page *)tmp;
#line 611
    page->count = 0L;
#line 612
    page->next = ls;
#line 613
    ls = page;
    }
  }
#line 615
  tmp___0 = ls->count;
#line 615
  (ls->count) ++;
#line 615
  ls->ptr[tmp___0] = tc;
#line 616
  return (ls);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void handle_guardians(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  ik_ptr_page *pend_hold_list ;
  ik_ptr_page *pend_final_list ;
  int gen ;
  ik_ptr_page *prot_list ;
  int i ;
  ikptr p ;
  ikptr tc ;
  ikptr obj ;
  ikptr np ;
  int tmp ;
  ik_ptr_page *next ;
  int done ;
  ik_ptr_page *final_list ;
  ik_ptr_page *ls ;
  int i___0 ;
  ikptr p___0 ;
  ikptr tc___0 ;
  ikptr np___0 ;
  int tmp___0 ;
  ik_ptr_page *next___0 ;
  int i___1 ;
  ikptr p___1 ;
  ikptr tmp___1 ;
  ik_ptr_page *next___1 ;
  ik_ptr_page *next___2 ;
  ik_ptr_page *target ;
  int tmp___2 ;
  int i___2 ;
  ikptr p___2 ;
  ikptr tc___1 ;
  ikptr np___1 ;
  ikptr tmp___3 ;
  int tmp___4 ;
  ik_ptr_page *next___3 ;
  int tmp___5 ;

  {
#line 621
  pcb = gc->pcb;
#line 622
  pend_hold_list = (ik_ptr_page *)0;
#line 623
  pend_final_list = (ik_ptr_page *)0;
#line 626
  gen = 0;
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    if (! (gen <= gc->collect_gen)) {
#line 626
      goto while_break;
    }
#line 627
    prot_list = pcb->protected_list[gen];
#line 628
    pcb->protected_list[gen] = (ik_ptr_page *)0;
    {
#line 629
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 629
      if (! prot_list) {
#line 629
        goto while_break___0;
      }
#line 631
      i = 0;
      {
#line 631
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 631
        if (! ((long )i < prot_list->count)) {
#line 631
          goto while_break___1;
        }
#line 632
        p = prot_list->ptr[i];
#line 633
        tc = *((ikptr *)((long )p + -1L) + 0);
#line 634
        obj = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 635
        if (tc == 0xffffffffffffffffUL) {
#line 636
          np = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 637
          tc = *((ikptr *)((long )np + -1L) + 0);
#line 638
          obj = *((ikptr *)((long )np + (long )((int )sizeof(ikptr ) - 1)) + 0);
        }
        {
#line 640
        tmp = is_live(obj, gc);
        }
#line 640
        if (tmp) {
          {
#line 641
          pend_hold_list = move_tconc(p, pend_hold_list);
          }
        } else {
          {
#line 643
          pend_final_list = move_tconc(p, pend_final_list);
          }
        }
#line 631
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 646
      next = prot_list->next;
#line 647
      ik_munmap((ikptr )prot_list, 4096UL);
#line 648
      prot_list = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 626
    gen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  gc->forward_list = (ik_ptr_page *)0;
#line 656
  done = 0;
  {
#line 657
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 657
    if (! (! done)) {
#line 657
      goto while_break___2;
    }
#line 658
    final_list = (ik_ptr_page *)0;
#line 659
    ls = pend_final_list;
#line 660
    pend_final_list = (ik_ptr_page *)0;
    {
#line 661
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 661
      if (! ls) {
#line 661
        goto while_break___3;
      }
#line 663
      i___0 = 0;
      {
#line 663
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 663
        if (! ((long )i___0 < ls->count)) {
#line 663
          goto while_break___4;
        }
#line 664
        p___0 = ls->ptr[i___0];
#line 665
        tc___0 = *((ikptr *)((long )p___0 + -1L) + 0);
#line 666
        if (tc___0 == 0xffffffffffffffffUL) {
#line 667
          np___0 = *((ikptr *)((long )p___0 + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 668
          tc___0 = *((ikptr *)((long )np___0 + -1L) + 0);
        }
        {
#line 670
        tmp___0 = is_live(tc___0, gc);
        }
#line 670
        if (tmp___0) {
          {
#line 671
          final_list = move_tconc(p___0, final_list);
          }
        } else {
          {
#line 673
          pend_final_list = move_tconc(p___0, pend_final_list);
          }
        }
#line 663
        i___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 676
      next___0 = ls->next;
#line 677
      ik_munmap((ikptr )ls, 4096UL);
#line 678
      ls = next___0;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 680
    if ((unsigned long )final_list == (unsigned long )((void *)0)) {
#line 681
      done = 1;
    } else {
#line 683
      ls = final_list;
      {
#line 684
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 684
        if (! ls) {
#line 684
          goto while_break___5;
        }
#line 686
        i___1 = 0;
        {
#line 686
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 686
          if (! ((long )i___1 < ls->count)) {
#line 686
            goto while_break___6;
          }
          {
#line 687
          p___1 = ls->ptr[i___1];
#line 688
          tmp___1 = add_object_proc(gc, p___1);
#line 688
          gc->forward_list = move_tconc(tmp___1, gc->forward_list);
#line 686
          i___1 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 692
        next___1 = ls->next;
#line 693
        ik_munmap((ikptr )ls, 4096UL);
#line 694
        ls = next___1;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 696
      collect_loop(gc);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 701
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 701
    if (! pend_final_list) {
#line 701
      goto while_break___7;
    }
    {
#line 702
    next___2 = pend_final_list->next;
#line 703
    ik_munmap((ikptr )pend_final_list, 4096UL);
#line 704
    pend_final_list = next___2;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 708
  tmp___2 = next_gen(gc->collect_gen);
#line 708
  target = pcb->protected_list[tmp___2];
  }
  {
#line 709
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 709
    if (! pend_hold_list) {
#line 709
      goto while_break___8;
    }
#line 711
    i___2 = 0;
    {
#line 711
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 711
      if (! ((long )i___2 < pend_hold_list->count)) {
#line 711
        goto while_break___9;
      }
#line 712
      p___2 = pend_hold_list->ptr[i___2];
#line 713
      tc___1 = *((ikptr *)((long )p___2 + -1L) + 0);
#line 714
      if (tc___1 == 0xffffffffffffffffUL) {
#line 715
        np___1 = *((ikptr *)((long )p___2 + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 716
        tc___1 = *((ikptr *)((long )np___1 + -1L) + 0);
      }
      {
#line 718
      tmp___4 = is_live(tc___1, gc);
      }
#line 718
      if (tmp___4) {
        {
#line 719
        tmp___3 = add_object_proc(gc, p___2);
#line 719
        target = move_tconc(tmp___3, target);
        }
      }
#line 711
      i___2 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 722
    next___3 = pend_hold_list->next;
#line 723
    ik_munmap((ikptr )pend_hold_list, 4096UL);
#line 724
    pend_hold_list = next___3;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 726
  collect_loop(gc);
#line 727
  tmp___5 = next_gen(gc->collect_gen);
#line 727
  pcb->protected_list[tmp___5] = target;
  }
#line 728
  return;
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void gc_finalize_guardians(gc_t *gc ) 
{ 
  ik_ptr_page *ls ;
  int tconc_count ;
  unsigned int *dirty_vec ;
  int i ;
  ikptr p ;
  ikptr tc ;
  ikptr obj ;
  ikptr last_pair ;
  ik_ptr_page *next ;

  {
#line 732
  ls = gc->forward_list;
#line 733
  tconc_count = 0;
#line 734
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! ls) {
#line 735
      goto while_break;
    }
#line 737
    i = 0;
    {
#line 737
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 737
      if (! ((long )i < ls->count)) {
#line 737
        goto while_break___0;
      }
#line 738
      tconc_count ++;
#line 739
      p = ls->ptr[i];
#line 740
      tc = *((ikptr *)((long )p + -1L) + 0);
#line 741
      obj = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 742
      last_pair = *((ikptr *)((long )tc + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 743
      *((ikptr *)((long )last_pair + -1L) + 0) = obj;
#line 744
      *((ikptr *)((long )last_pair + (long )((int )sizeof(ikptr ) - 1)) + 0) = p;
#line 745
      *((ikptr *)((long )p + -1L) + 0) = (ikptr )47;
#line 746
      *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0) = (ikptr )47;
#line 747
      *((ikptr *)((long )tc + (long )((int )sizeof(ikptr ) - 1)) + 0) = p;
#line 748
      *(dirty_vec + (tc >> 12)) = 4294967295U;
#line 749
      *(dirty_vec + (last_pair >> 12)) = 4294967295U;
#line 737
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 751
    next = ls->next;
#line 752
    ik_munmap((ikptr )ls, 4096UL);
#line 753
    ls = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 755
  return;
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static int alloc_code_count  =    0;
#line 761 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static ikptr add_code_entry(gc_t *gc , ikptr entry ) 
{ 
  ikptr x ;
  long idx ;
  unsigned int t ;
  int gen ;
  long code_size ;
  int tmp ;
  ikptr reloc_vec ;
  ikptr freevars ;
  ikptr annotation ;
  long required_mem ;
  int tmp___0 ;
  int tmp___1 ;
  int new_tag ;
  long idx___0 ;
  long i ;
  qupages_t *p ;
  void *tmp___2 ;
  ikptr y ;
  ikptr tmp___3 ;
  int tmp___4 ;

  {
#line 763
  x = entry - (ikptr )(6 * (int )sizeof(ikptr ));
#line 764
  if (*((ikptr *)((long )x) + 0) == 0xffffffffffffffffUL) {
#line 765
    return (*((ikptr *)((long )x + (long )((int )sizeof(ikptr ))) + 0) + (ikptr )(6 * (int )sizeof(ikptr ) - 5));
  }
#line 767
  idx = (long )(x >> 12);
#line 768
  t = *(gc->segment_vector + idx);
#line 769
  gen = (int )(t & 15U);
#line 770
  if (gen > gc->collect_gen) {
#line 771
    return (entry);
  }
#line 773
  if ((int )sizeof(ikptr ) == 4) {
#line 773
    tmp = 2;
  } else {
#line 773
    tmp = 3;
  }
#line 773
  code_size = (long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ))) + 0) >> tmp;
#line 774
  reloc_vec = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 775
  freevars = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ))) + 0);
#line 776
  annotation = *((ikptr *)((long )x + (long )(4 * (int )sizeof(ikptr ))) + 0);
#line 777
  if ((int )sizeof(ikptr ) == 4) {
#line 777
    tmp___0 = 2;
  } else {
#line 777
    tmp___0 = 3;
  }
#line 777
  if ((int )sizeof(ikptr ) == 4) {
#line 777
    tmp___1 = 2;
  } else {
#line 777
    tmp___1 = 3;
  }
#line 777
  required_mem = (((((long )(6 * (int )sizeof(ikptr )) + code_size) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1);
#line 778
  if (required_mem >= 4096L) {
#line 779
    new_tag = gc->collect_gen_tag;
#line 780
    idx___0 = (long )(x >> 12);
#line 781
    *(gc->segment_vector + idx___0) = (unsigned int )(new_tag | 70912);
#line 783
    i = 4096L;
#line 783
    idx___0 ++;
    {
#line 783
    while (1) {
      while_continue: /* CIL Label */ ;
#line 783
      if (! (i < required_mem)) {
#line 783
        goto while_break;
      }
#line 784
      *(gc->segment_vector + idx___0) = (unsigned int )(new_tag | 66560);
#line 783
      i += 4096L;
#line 783
      idx___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 786
    tmp___2 = ik_malloc((int )sizeof(qupages_t ));
#line 786
    p = (qupages_t *)tmp___2;
#line 787
    p->p = x;
#line 788
    p->q = x + (ikptr )required_mem;
#line 789
    p->next = gc->queues[1];
#line 790
    gc->queues[1] = p;
    }
#line 791
    return (entry);
  } else {
    {
#line 793
    tmp___3 = gc_alloc_new_code(required_mem, gc);
#line 793
    y = tmp___3;
#line 794
    *((ikptr *)((long )y) + 0) = (ikptr )47;
    }
#line 795
    if ((int )sizeof(ikptr ) == 4) {
#line 795
      tmp___4 = 2;
    } else {
#line 795
      tmp___4 = 3;
    }
    {
#line 795
    *((ikptr *)((long )y + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )(code_size << tmp___4);
#line 796
    *((ikptr *)((long )y + (long )(2 * (int )sizeof(ikptr ))) + 0) = reloc_vec;
#line 797
    *((ikptr *)((long )y + (long )(3 * (int )sizeof(ikptr ))) + 0) = freevars;
#line 798
    *((ikptr *)((long )y + (long )(4 * (int )sizeof(ikptr ))) + 0) = annotation;
#line 799
    memcpy((void */* __restrict  */)((char *)((long )(y + (ikptr )(6 * (int )sizeof(ikptr ))))),
           (void const   */* __restrict  */)((char *)((long )(x + (ikptr )(6 * (int )sizeof(ikptr ))))),
           (size_t )code_size);
#line 802
    *((ikptr *)((long )x) + 0) = (ikptr )-1;
#line 803
    *((ikptr *)((long )x + (long )((int )sizeof(ikptr ))) + 0) = y + 5UL;
    }
#line 804
    return (y + (ikptr )(6 * (int )sizeof(ikptr )));
  }
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void collect_locatives(gc_t *gc , callback_locative *loc ) 
{ 


  {
  {
#line 810
  while (1) {
    while_continue: /* CIL Label */ ;
#line 810
    if (! loc) {
#line 810
      goto while_break;
    }
    {
#line 811
    loc->data = add_object_proc(gc, loc->data);
#line 812
    loc = loc->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  return;
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void collect_stack(gc_t *gc , ikptr top , ikptr end ) 
{ 
  ikptr rp ;
  long rp_offset ;
  int tmp ;
  int tmp___0 ;
  long code_offset ;
  int tmp___1 ;
  ikptr code_entry ;
  ikptr new_code_entry ;
  ikptr tmp___2 ;
  ikptr new_rp ;
  long framesize ;
  int tmp___3 ;
  ikptr base ;
  ikptr new_obj ;
  ikptr tmp___4 ;
  long frame_cells ;
  int tmp___5 ;
  long bytes_in_mask ;
  char *mask ;
  int tmp___6 ;
  ikptr *fp ;
  long i ;
  unsigned char m ;

  {
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (! (top < end)) {
#line 823
      goto while_break;
    }
#line 827
    rp = *((ikptr *)((long )top) + 0);
#line 828
    if ((int )sizeof(ikptr ) == 4) {
#line 828
      tmp = 5;
    } else {
#line 828
      tmp = 10;
    }
#line 828
    if ((int )sizeof(ikptr ) == 4) {
#line 828
      tmp___0 = 2;
    } else {
#line 828
      tmp___0 = 3;
    }
#line 828
    rp_offset = (long )*((ikptr *)((long )rp + (long )(- (tmp + 2 * (int )sizeof(ikptr )))) + 0) >> tmp___0;
#line 833
    if (rp_offset <= 0L) {
      {
#line 834
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid rp_offset %ld\n",
              rp_offset);
#line 835
      exit(-1);
      }
    }
#line 841
    if ((int )sizeof(ikptr ) == 4) {
#line 841
      tmp___1 = 5;
    } else {
#line 841
      tmp___1 = 10;
    }
    {
#line 841
    code_offset = rp_offset - (long )(- (tmp___1 + 2 * (int )sizeof(ikptr )));
#line 842
    code_entry = rp - (ikptr )code_offset;
#line 843
    tmp___2 = add_code_entry(gc, code_entry);
#line 843
    new_code_entry = tmp___2;
#line 844
    new_rp = new_code_entry + (ikptr )code_offset;
#line 845
    *((ikptr *)((long )top) + 0) = new_rp;
    }
#line 881
    if ((int )sizeof(ikptr ) == 4) {
#line 881
      tmp___3 = 5;
    } else {
#line 881
      tmp___3 = 10;
    }
#line 881
    framesize = (long )*((ikptr *)((long )rp + (long )(- (tmp___3 + 3 * (int )sizeof(ikptr )))) + 0);
#line 885
    if (framesize < 0L) {
      {
#line 886
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid frame size %ld\n",
              framesize);
#line 887
      exit(-1);
      }
    } else
#line 889
    if (framesize == 0L) {
#line 890
      framesize = (long )*((ikptr *)((long )top + (long )((int )sizeof(ikptr ))) + 0);
#line 891
      if (framesize <= 0L) {
        {
#line 892
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid redirected framesize=%ld\n",
                framesize);
#line 893
        exit(-1);
        }
      }
#line 895
      base = (top + (ikptr )framesize) - (ikptr )((int )sizeof(ikptr ));
      {
#line 896
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 896
        if (! (base > top)) {
#line 896
          goto while_break___0;
        }
        {
#line 897
        tmp___4 = add_object_proc(gc, *((ikptr *)((long )base) + 0));
#line 897
        new_obj = tmp___4;
#line 898
        *((ikptr *)((long )base) + 0) = new_obj;
#line 899
        base -= (ikptr )((int )sizeof(ikptr ));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 902
      if ((int )sizeof(ikptr ) == 4) {
#line 902
        tmp___5 = 2;
      } else {
#line 902
        tmp___5 = 3;
      }
#line 902
      frame_cells = framesize >> tmp___5;
#line 903
      bytes_in_mask = (frame_cells + 7L) >> 3;
#line 904
      if ((int )sizeof(ikptr ) == 4) {
#line 904
        tmp___6 = 5;
      } else {
#line 904
        tmp___6 = 10;
      }
#line 904
      mask = (char *)((long )((rp + (ikptr )(- (tmp___6 + 3 * (int )sizeof(ikptr )))) - (ikptr )bytes_in_mask));
#line 906
      fp = (ikptr *)((long )(top + (ikptr )framesize));
#line 908
      i = 0L;
      {
#line 908
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 908
        if (! (i < bytes_in_mask)) {
#line 908
          goto while_break___1;
        }
#line 909
        m = (unsigned char )*(mask + i);
#line 913
        if ((int )m & 1) {
          {
#line 913
          *(fp + 0) = add_object_proc(gc, *(fp + 0));
          }
        }
#line 914
        if ((int )m & 2) {
          {
#line 914
          *(fp + -1) = add_object_proc(gc, *(fp + -1));
          }
        }
#line 915
        if ((int )m & 4) {
          {
#line 915
          *(fp + -2) = add_object_proc(gc, *(fp + -2));
          }
        }
#line 916
        if ((int )m & 8) {
          {
#line 916
          *(fp + -3) = add_object_proc(gc, *(fp + -3));
          }
        }
#line 917
        if ((int )m & 16) {
          {
#line 917
          *(fp + -4) = add_object_proc(gc, *(fp + -4));
          }
        }
#line 918
        if ((int )m & 32) {
          {
#line 918
          *(fp + -5) = add_object_proc(gc, *(fp + -5));
          }
        }
#line 919
        if ((int )m & 64) {
          {
#line 919
          *(fp + -6) = add_object_proc(gc, *(fp + -6));
          }
        }
#line 920
        if ((int )m & 128) {
          {
#line 920
          *(fp + -7) = add_object_proc(gc, *(fp + -7));
          }
        }
#line 908
        i ++;
#line 908
        fp -= 8;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 923
    top += (ikptr )framesize;
  }
  while_break: /* CIL Label */ ;
  }
#line 925
  if (top != end) {
    {
#line 926
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"frames did not match up 0x%016lx .. 0x%016lx\n",
            (long )top, (long )end);
#line 928
    exit(-1);
    }
  }
#line 933
  return;
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void add_list(gc_t *gc , unsigned int t , ikptr x , ikptr *loc ) 
{ 
  int collect_gen ;
  ikptr fst ;
  ikptr snd ;
  ikptr y ;
  ikptr tmp ;
  ikptr tmp___0 ;
  int stag ;
  int gen ;
  int tmp___1 ;

  {
#line 938
  collect_gen = gc->collect_gen;
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 940
    fst = *((ikptr *)((long )x + -1L) + 0);
#line 941
    snd = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 943
    if ((t & 3840U) != 1536U) {
      {
#line 944
      tmp = gc_alloc_new_pair(gc);
#line 944
      y = tmp + 1UL;
      }
    } else {
      {
#line 946
      tmp___0 = gc_alloc_new_weak_pair(gc);
#line 946
      y = tmp___0 + 1UL;
      }
    }
#line 948
    *loc = y;
#line 949
    *((ikptr *)((long )x + -1L) + 0) = (ikptr )-1;
#line 950
    *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0) = y;
#line 951
    *((ikptr *)((long )y + -1L) + 0) = fst;
#line 952
    stag = (int )snd & 7;
#line 953
    if (stag == 1) {
#line 954
      if (*((ikptr *)((long )snd + -1L) + 0) == 0xffffffffffffffffUL) {
#line 955
        *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = *((ikptr *)((long )snd + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 956
        return;
      } else {
#line 959
        t = *(gc->segment_vector + (snd >> 12));
#line 960
        gen = (int )(t & 15U);
#line 961
        if (gen > collect_gen) {
#line 962
          *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = snd;
#line 963
          return;
        } else {
#line 965
          x = snd;
#line 966
          loc = (ikptr *)((long )(y + (ikptr )((int )sizeof(ikptr ) - 1)));
        }
      }
    } else
#line 971
    if (stag == 7) {
#line 974
      *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = snd;
#line 975
      return;
    } else
#line 971
    if (stag == 0) {
#line 974
      *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = snd;
#line 975
      return;
    } else {
#line 971
      if ((int )sizeof(ikptr ) == 4) {
#line 971
        tmp___1 = 2;
      } else {
#line 971
        tmp___1 = 3;
      }
#line 971
      if (stag == 1 << tmp___1) {
#line 974
        *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = snd;
#line 975
        return;
      } else
#line 977
      if (*((ikptr *)((long )snd + (long )(- stag)) + 0) == 0xffffffffffffffffUL) {
#line 978
        *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = *((ikptr *)((long )snd + (long )((int )sizeof(ikptr ) - stag)) + 0);
#line 979
        return;
      } else {
        {
#line 982
        *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = add_object_proc(gc,
                                                                                         snd);
        }
#line 983
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static ikptr add_object_proc(gc_t *gc , ikptr x ) 
{ 
  int tag ;
  ikptr fst ;
  unsigned int t ;
  int gen ;
  ikptr y ;
  ikptr size ;
  ikptr asize ;
  int tmp ;
  int tmp___0 ;
  ikptr y___0 ;
  ikptr tmp___1 ;
  ikptr size___0 ;
  ikptr memreq ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr y___1 ;
  ikptr tmp___4 ;
  ikptr y___2 ;
  ikptr tmp___5 ;
  ikptr y___3 ;
  ikptr tmp___6 ;
  ikptr size___1 ;
  ikptr y___4 ;
  ikptr tmp___7 ;
  ikptr i ;
  ikptr p ;
  ikptr q ;
  ikptr y___5 ;
  ikptr tmp___8 ;
  ikptr i___0 ;
  ikptr p___0 ;
  ikptr q___0 ;
  int tmp___9 ;
  ikptr entry ;
  ikptr new_entry ;
  ikptr tmp___10 ;
  ikptr top ;
  ikptr size___2 ;
  ikptr next ;
  ikptr y___6 ;
  ikptr tmp___11 ;
  ikptr new_top ;
  int tmp___12 ;
  int tmp___13 ;
  ikptr tmp___14 ;
  ikptr y___7 ;
  ikptr tmp___15 ;
  ikptr top___0 ;
  ikptr next___0 ;
  ikptr y___8 ;
  ikptr tmp___16 ;
  ikptr key ;
  int gen___0 ;
  ikptr y___9 ;
  ikptr tmp___17 ;
  long i___1 ;
  ikptr new ;
  ikptr tmp___18 ;
  long len ;
  long memreq___0 ;
  int tmp___19 ;
  int tmp___20 ;
  ikptr new___0 ;
  ikptr tmp___21 ;
  ikptr y___10 ;
  ikptr tmp___22 ;
  ikptr num ;
  ikptr den ;
  ikptr y___11 ;
  ikptr tmp___23 ;
  ikptr rl ;
  ikptr im ;
  ikptr y___12 ;
  ikptr tmp___24 ;
  ikptr rl___0 ;
  ikptr im___0 ;
  ikptr y___13 ;
  ikptr tmp___25 ;
  long strlen___0 ;
  int tmp___26 ;
  long memreq___1 ;
  int tmp___27 ;
  int tmp___28 ;
  ikptr new_str ;
  ikptr tmp___29 ;
  long len___0 ;
  int tmp___30 ;
  long memreq___2 ;
  int tmp___31 ;
  int tmp___32 ;
  ikptr new_bv ;
  ikptr tmp___33 ;

  {
#line 996
  if ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 997
    return (x);
  }
#line 1000
  tag = (int )x & 7;
#line 1001
  if (tag == 7) {
#line 1002
    return (x);
  }
#line 1004
  fst = *((ikptr *)((long )x + (long )(- tag)) + 0);
#line 1005
  if (fst == 0xffffffffffffffffUL) {
#line 1007
    return (*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - tag)) + 0));
  }
#line 1009
  t = *(gc->segment_vector + (x >> 12));
#line 1010
  gen = (int )(t & 15U);
#line 1011
  if (gen > gc->collect_gen) {
#line 1012
    return (x);
  }
#line 1014
  if (tag == 1) {
    {
#line 1016
    add_list(gc, t, x, & y);
    }
#line 1017
    return (y);
  } else
#line 1039
  if (tag == 3) {
#line 1040
    size = (ikptr )((int )sizeof(ikptr )) + *((ikptr *)((long )fst + (long )(3 * (int )sizeof(ikptr ) - 6 * (int )sizeof(ikptr ))) + 0);
#line 1043
    if (size > 1024UL) {
      {
#line 1044
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"large closure size=0x%016lx\n",
              (long )size);
      }
    }
#line 1046
    if ((int )sizeof(ikptr ) == 4) {
#line 1046
      tmp = 2;
    } else {
#line 1046
      tmp = 3;
    }
#line 1046
    if ((int )sizeof(ikptr ) == 4) {
#line 1046
      tmp___0 = 2;
    } else {
#line 1046
      tmp___0 = 3;
    }
    {
#line 1046
    asize = (((size + (ikptr )(2 * (int )sizeof(ikptr ))) - 1UL) >> (tmp + 1)) << (tmp___0 + 1);
#line 1047
    tmp___1 = gc_alloc_new_ptr((int )asize, gc);
#line 1047
    y___0 = tmp___1 + 3UL;
#line 1048
    *((ikptr *)((long )y___0 + (long )((asize - 3UL) - (ikptr )((int )sizeof(ikptr )))) + 0) = (ikptr )0;
#line 1049
    memcpy((void */* __restrict  */)((char *)((long )(y___0 - 3UL))), (void const   */* __restrict  */)((char *)((long )(x - 3UL))),
           size);
#line 1052
    *((ikptr *)((long )y___0 + -3L) + 0) = add_code_entry(gc, *((ikptr *)((long )y___0 + -3L) + 0));
#line 1053
    *((ikptr *)((long )x + -3L) + 0) = (ikptr )-1;
#line 1054
    *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 3)) + 0) = y___0;
    }
#line 1058
    return (y___0);
  } else
#line 1060
  if (tag == 5) {
#line 1061
    if ((fst & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 1064
      size___0 = fst;
#line 1066
      if ((int )sizeof(ikptr ) == 4) {
#line 1066
        tmp___2 = 2;
      } else {
#line 1066
        tmp___2 = 3;
      }
#line 1066
      if ((int )sizeof(ikptr ) == 4) {
#line 1066
        tmp___3 = 2;
      } else {
#line 1066
        tmp___3 = 3;
      }
#line 1066
      memreq = ((((size___0 + (ikptr )((int )sizeof(ikptr ))) + (ikptr )(2 * (int )sizeof(ikptr ))) - 1UL) >> (tmp___2 + 1)) << (tmp___3 + 1);
#line 1067
      if (memreq >= 4096UL) {
#line 1068
        if ((t & 1048576U) == 1048576U) {
          {
#line 1069
          enqueue_large_ptr(x - 5UL, (int )(size___0 + (ikptr )((int )sizeof(ikptr ))),
                            gc);
          }
#line 1070
          return (x);
        } else {
          {
#line 1072
          tmp___4 = gc_alloc_new_large_ptr((int )(size___0 + (ikptr )((int )sizeof(ikptr ))),
                                           gc);
#line 1072
          y___1 = tmp___4 + 5UL;
#line 1074
          *((ikptr *)((long )y___1 + -5L) + 0) = fst;
#line 1075
          *((ikptr *)((long )y___1 + (long )((memreq - 5UL) - (ikptr )((int )sizeof(ikptr )))) + 0) = (ikptr )0;
#line 1076
          memcpy((void */* __restrict  */)((char *)((long )(y___1 + (ikptr )((int )sizeof(ikptr ) - 5)))),
                 (void const   */* __restrict  */)((char *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5)))),
                 size___0);
#line 1079
          *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1080
          *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___1;
          }
#line 1081
          return (y___1);
        }
      } else {
        {
#line 1084
        tmp___5 = gc_alloc_new_ptr((int )memreq, gc);
#line 1084
        y___2 = tmp___5 + 5UL;
#line 1085
        *((ikptr *)((long )y___2 + -5L) + 0) = fst;
#line 1086
        *((ikptr *)((long )y___2 + (long )((memreq - 5UL) - (ikptr )((int )sizeof(ikptr )))) + 0) = (ikptr )0;
#line 1087
        memcpy((void */* __restrict  */)((char *)((long )(y___2 + (ikptr )((int )sizeof(ikptr ) - 5)))),
               (void const   */* __restrict  */)((char *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5)))),
               size___0);
#line 1090
        *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1091
        *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___2;
        }
#line 1092
        return (y___2);
      }
    } else
#line 1098
    if (fst == 95UL) {
      {
#line 1099
      tmp___6 = gc_alloc_new_symbol_record(gc);
#line 1099
      y___3 = tmp___6 + 5UL;
#line 1100
      *((ikptr *)((long )y___3 + -5L) + 0) = (ikptr )95;
#line 1101
      *((ikptr *)((long )y___3 + (long )((int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1102
      *((ikptr *)((long )y___3 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1103
      *((ikptr *)((long )y___3 + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1104
      *((ikptr *)((long )y___3 + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1105
      *((ikptr *)((long )y___3 + (long )(5 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(5 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1106
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1107
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___3;
      }
#line 1108
      return (y___3);
    } else
#line 1110
    if (((int )fst & 7) == 5) {
#line 1112
      size___1 = *((ikptr *)((long )fst + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1113
      if ((int )sizeof(ikptr ) == 4) {
#line 1113
        tmp___9 = 2;
      } else {
#line 1113
        tmp___9 = 3;
      }
#line 1113
      if (size___1 & (unsigned long )((1 << (tmp___9 + 1)) - 1)) {
        {
#line 1117
        tmp___7 = gc_alloc_new_ptr((int )(size___1 + (ikptr )((int )sizeof(ikptr ))),
                                   gc);
#line 1117
        y___4 = tmp___7 + 5UL;
#line 1118
        *((ikptr *)((long )y___4 + -5L) + 0) = fst;
#line 1121
        p = (y___4 + (ikptr )((int )sizeof(ikptr ))) - 5UL;
#line 1122
        q = (x + (ikptr )((int )sizeof(ikptr ))) - 5UL;
#line 1123
        *((ikptr *)((long )p) + 0) = *((ikptr *)((long )q) + 0);
#line 1124
        i = (ikptr )((int )sizeof(ikptr ));
        }
        {
#line 1124
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1124
          if (! (i < size___1)) {
#line 1124
            goto while_break;
          }
#line 1125
          *((ikptr *)((long )p + (long )i) + 0) = *((ikptr *)((long )q + (long )i) + 0);
#line 1126
          *((ikptr *)((long )p + (long )(i + (ikptr )((int )sizeof(ikptr )))) + 0) = *((ikptr *)((long )q + (long )(i + (ikptr )((int )sizeof(ikptr )))) + 0);
#line 1124
          i += (ikptr )(2 * (int )sizeof(ikptr ));
        }
        while_break: /* CIL Label */ ;
        }
#line 1129
        *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1130
        *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___4;
#line 1131
        return (y___4);
      } else {
        {
#line 1135
        tmp___8 = gc_alloc_new_ptr((int )(size___1 + (ikptr )(2 * (int )sizeof(ikptr ))),
                                   gc);
#line 1135
        y___5 = tmp___8 + 5UL;
#line 1136
        *((ikptr *)((long )y___5 + -5L) + 0) = fst;
#line 1139
        p___0 = (y___5 + (ikptr )((int )sizeof(ikptr ))) - 5UL;
#line 1140
        q___0 = (x + (ikptr )((int )sizeof(ikptr ))) - 5UL;
#line 1141
        i___0 = (ikptr )0;
        }
        {
#line 1141
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1141
          if (! (i___0 < size___1)) {
#line 1141
            goto while_break___0;
          }
#line 1142
          *((ikptr *)((long )p___0 + (long )i___0) + 0) = *((ikptr *)((long )q___0 + (long )i___0) + 0);
#line 1143
          *((ikptr *)((long )p___0 + (long )(i___0 + (ikptr )((int )sizeof(ikptr )))) + 0) = *((ikptr *)((long )q___0 + (long )(i___0 + (ikptr )((int )sizeof(ikptr )))) + 0);
#line 1141
          i___0 += (ikptr )(2 * (int )sizeof(ikptr ));
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1146
        *((ikptr *)((long )y___5 + (long )((size___1 + (ikptr )((int )sizeof(ikptr ))) - 5UL)) + 0) = (ikptr )0;
#line 1147
        *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1148
        *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___5;
#line 1149
        return (y___5);
      }
    } else
#line 1152
    if (fst == 47UL) {
      {
#line 1153
      entry = x + (ikptr )(6 * (int )sizeof(ikptr ) - 5);
#line 1154
      tmp___10 = add_code_entry(gc, entry);
#line 1154
      new_entry = tmp___10;
      }
#line 1155
      return (new_entry - (ikptr )(6 * (int )sizeof(ikptr ) - 5));
    } else
#line 1157
    if (fst == 31UL) {
      {
#line 1158
      top = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1159
      size___2 = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1165
      next = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1166
      tmp___11 = gc_alloc_new_ptr(4 * (int )sizeof(ikptr ), gc);
#line 1166
      y___6 = tmp___11 + 5UL;
#line 1167
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1168
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___6;
      }
#line 1169
      if ((int )sizeof(ikptr ) == 4) {
#line 1169
        tmp___12 = 2;
      } else {
#line 1169
        tmp___12 = 3;
      }
#line 1169
      if ((int )sizeof(ikptr ) == 4) {
#line 1169
        tmp___13 = 2;
      } else {
#line 1169
        tmp___13 = 3;
      }
      {
#line 1169
      tmp___14 = gc_alloc_new_data((int )((((size___2 + (ikptr )(2 * (int )sizeof(ikptr ))) - 1UL) >> (tmp___12 + 1)) << (tmp___13 + 1)),
                                   gc);
#line 1169
      new_top = tmp___14;
#line 1170
      memcpy((void */* __restrict  */)((char *)((long )new_top)), (void const   */* __restrict  */)((char *)((long )top)),
             size___2);
#line 1173
      collect_stack(gc, new_top, new_top + size___2);
#line 1174
      *((ikptr *)((long )y___6 + -5L) + 0) = (ikptr )31;
#line 1175
      *((ikptr *)((long )y___6 + (long )((int )sizeof(ikptr ) - 5)) + 0) = new_top;
#line 1176
      *((ikptr *)((long )y___6 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = size___2;
#line 1177
      *((ikptr *)((long )y___6 + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = next;
      }
#line 1181
      return (y___6);
    } else
#line 1183
    if (fst == 287UL) {
      {
#line 1184
      tmp___15 = gc_alloc_new_data(4 * (int )sizeof(ikptr ), gc);
#line 1184
      y___7 = tmp___15 + 5UL;
#line 1185
      top___0 = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1186
      next___0 = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1187
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1188
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___7;
#line 1189
      *((ikptr *)((long )y___7 + -5L) + 0) = fst;
#line 1190
      *((ikptr *)((long )y___7 + (long )((int )sizeof(ikptr ) - 5)) + 0) = top___0;
#line 1191
      *((ikptr *)((long )y___7 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = add_object_proc(gc,
                                                                                               next___0);
      }
#line 1193
      return (y___7);
    } else
#line 1195
    if (((int )fst & 7) == 1) {
      {
#line 1197
      tmp___16 = gc_alloc_new_ptr(4 * (int )sizeof(ikptr ), gc);
#line 1197
      y___8 = tmp___16 + 5UL;
#line 1198
      *((ikptr *)((long )y___8 + -5L) + 0) = fst;
#line 1199
      key = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1200
      *((ikptr *)((long )y___8 + (long )((int )sizeof(ikptr ) - 5)) + 0) = key;
#line 1201
      *((ikptr *)((long )y___8 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1202
      *((ikptr *)((long )y___8 + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0);
      }
#line 1203
      if (! ((key & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
#line 1203
        if (((int )key & 7) != 7) {
#line 1204
          gen___0 = (int )(*(gc->segment_vector + (key >> 12)) & 15U);
#line 1205
          if (gen___0 <= gc->collect_gen) {
            {
#line 1207
            gc_tconc_push(gc, y___8);
            }
          }
        }
      }
#line 1210
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1211
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___8;
#line 1212
      return (y___8);
    } else
#line 1214
    if (((long )fst & 63L) == 63L) {
      {
#line 1215
      tmp___17 = gc_alloc_new_ptr(14 * (int )sizeof(ikptr ), gc);
#line 1215
      y___9 = tmp___17 + 5UL;
#line 1216
      *((ikptr *)((long )y___9 + -5L) + 0) = fst;
#line 1218
      i___1 = (long )((int )sizeof(ikptr ));
      }
      {
#line 1218
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1218
        if (! (i___1 < (long )(14 * (int )sizeof(ikptr )))) {
#line 1218
          goto while_break___1;
        }
#line 1219
        *((ikptr *)((long )y___9 + (i___1 - 5L)) + 0) = *((ikptr *)((long )x + (i___1 - 5L)) + 0);
#line 1218
        i___1 += (long )((int )sizeof(ikptr ));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1221
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1222
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___9;
#line 1223
      return (y___9);
    } else
#line 1225
    if (fst == 23UL) {
      {
#line 1226
      tmp___18 = gc_alloc_new_data(16, gc);
#line 1226
      new = tmp___18 + 5UL;
#line 1227
      *((ikptr *)((long )new + -5L) + 0) = (ikptr )23;
#line 1228
      *((double *)((char *)((long )new) + 3)) = *((double *)((char *)((long )x) + 3));
#line 1229
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1230
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = new;
      }
#line 1231
      return (new);
    } else
#line 1233
    if ((fst & 7UL) == 3UL) {
#line 1234
      len = (long )(fst >> 4);
#line 1235
      if ((int )sizeof(ikptr ) == 4) {
#line 1235
        tmp___19 = 2;
      } else {
#line 1235
        tmp___19 = 3;
      }
#line 1235
      if ((int )sizeof(ikptr ) == 4) {
#line 1235
        tmp___20 = 2;
      } else {
#line 1235
        tmp___20 = 3;
      }
      {
#line 1235
      memreq___0 = (((((long )((int )sizeof(ikptr )) + len * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___19 + 1)) << (tmp___20 + 1);
#line 1236
      tmp___21 = gc_alloc_new_data((int )memreq___0, gc);
#line 1236
      new___0 = tmp___21 + 5UL;
#line 1237
      memcpy((void */* __restrict  */)((char *)((long )(new___0 - 5UL))), (void const   */* __restrict  */)((char *)((long )(x - 5UL))),
             (size_t )memreq___0);
#line 1240
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1241
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = new___0;
      }
#line 1242
      return (new___0);
    } else
#line 1244
    if (fst == 39UL) {
      {
#line 1245
      tmp___22 = gc_alloc_new_data(4 * (int )sizeof(ikptr ), gc);
#line 1245
      y___10 = tmp___22 + 5UL;
#line 1246
      num = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1247
      den = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1248
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1249
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___10;
#line 1250
      *((ikptr *)((long )y___10 + -5L) + 0) = fst;
#line 1251
      *((ikptr *)((long )y___10 + (long )((int )sizeof(ikptr ) - 5)) + 0) = add_object_proc(gc,
                                                                                            num);
#line 1252
      *((ikptr *)((long )y___10 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = add_object_proc(gc,
                                                                                                den);
      }
#line 1253
      return (y___10);
    } else
#line 1255
    if (fst == 55UL) {
      {
#line 1256
      tmp___23 = gc_alloc_new_data(4 * (int )sizeof(ikptr ), gc);
#line 1256
      y___11 = tmp___23 + 5UL;
#line 1257
      rl = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1258
      im = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1259
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1260
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___11;
#line 1261
      *((ikptr *)((long )y___11 + -5L) + 0) = fst;
#line 1262
      *((ikptr *)((long )y___11 + (long )((int )sizeof(ikptr ) - 5)) + 0) = add_object_proc(gc,
                                                                                            rl);
#line 1263
      *((ikptr *)((long )y___11 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = add_object_proc(gc,
                                                                                                im);
      }
#line 1264
      return (y___11);
    } else
#line 1266
    if (fst == 71UL) {
      {
#line 1267
      tmp___24 = gc_alloc_new_data(4 * (int )sizeof(ikptr ), gc);
#line 1267
      y___12 = tmp___24 + 5UL;
#line 1268
      rl___0 = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1269
      im___0 = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1270
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1271
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___12;
#line 1272
      *((ikptr *)((long )y___12 + -5L) + 0) = fst;
#line 1273
      *((ikptr *)((long )y___12 + (long )((int )sizeof(ikptr ) - 5)) + 0) = add_object_proc(gc,
                                                                                            rl___0);
#line 1274
      *((ikptr *)((long )y___12 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = add_object_proc(gc,
                                                                                                im___0);
      }
#line 1275
      return (y___12);
    } else
#line 1277
    if (fst == 263UL) {
      {
#line 1278
      tmp___25 = gc_alloc_new_data(2 * (int )sizeof(ikptr ), gc);
#line 1278
      y___13 = tmp___25 + 5UL;
#line 1279
      *((ikptr *)((long )y___13 + -5L) + 0) = (ikptr )263;
#line 1280
      *((ikptr *)((long )y___13 + (long )((int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1281
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1282
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___13;
      }
#line 1283
      return (y___13);
    } else {
      {
#line 1286
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unhandled vector with fst=0x%016lx\n",
              (long )fst);
#line 1289
      exit(-1);
      }
    }
  } else
#line 1292
  if (tag == 6) {
#line 1293
    if ((fst & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 1294
      if ((int )sizeof(ikptr ) == 4) {
#line 1294
        tmp___26 = 2;
      } else {
#line 1294
        tmp___26 = 3;
      }
#line 1294
      strlen___0 = (long )fst >> tmp___26;
#line 1295
      if ((int )sizeof(ikptr ) == 4) {
#line 1295
        tmp___27 = 2;
      } else {
#line 1295
        tmp___27 = 3;
      }
#line 1295
      if ((int )sizeof(ikptr ) == 4) {
#line 1295
        tmp___28 = 2;
      } else {
#line 1295
        tmp___28 = 3;
      }
      {
#line 1295
      memreq___1 = ((((strlen___0 * 4L + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___27 + 1)) << (tmp___28 + 1);
#line 1296
      tmp___29 = gc_alloc_new_data((int )memreq___1, gc);
#line 1296
      new_str = tmp___29 + 6UL;
#line 1297
      *((ikptr *)((long )new_str + -6L) + 0) = fst;
#line 1298
      memcpy((void */* __restrict  */)((char *)((long )(new_str + (ikptr )((int )sizeof(ikptr ) - 6)))),
             (void const   */* __restrict  */)((char *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 6)))),
             (size_t )(strlen___0 * 4L));
#line 1301
      *((ikptr *)((long )x + -6L) + 0) = (ikptr )-1;
#line 1302
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 6)) + 0) = new_str;
      }
#line 1306
      return (new_str);
    } else {
      {
#line 1309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unhandled string 0x%016lx with fst=0x%016lx\n",
              (long )x, (long )fst);
#line 1311
      exit(-1);
      }
    }
  } else
#line 1314
  if (tag == 2) {
#line 1315
    if ((int )sizeof(ikptr ) == 4) {
#line 1315
      tmp___30 = 2;
    } else {
#line 1315
      tmp___30 = 3;
    }
#line 1315
    len___0 = (long )fst >> tmp___30;
#line 1316
    if ((int )sizeof(ikptr ) == 4) {
#line 1316
      tmp___31 = 2;
    } else {
#line 1316
      tmp___31 = 3;
    }
#line 1316
    if ((int )sizeof(ikptr ) == 4) {
#line 1316
      tmp___32 = 2;
    } else {
#line 1316
      tmp___32 = 3;
    }
    {
#line 1316
    memreq___2 = (((((len___0 + 8L) + 1L) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___31 + 1)) << (tmp___32 + 1);
#line 1317
    tmp___33 = gc_alloc_new_data((int )memreq___2, gc);
#line 1317
    new_bv = tmp___33 + 2UL;
#line 1318
    *((ikptr *)((long )new_bv + -2L) + 0) = fst;
#line 1319
    memcpy((void */* __restrict  */)((char *)((long )(new_bv + 6UL))), (void const   */* __restrict  */)((char *)((long )(x + 6UL))),
           (size_t )(len___0 + 1L));
#line 1322
    *((ikptr *)((long )x + -2L) + 0) = (ikptr )-1;
#line 1323
    *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 2)) + 0) = new_bv;
    }
#line 1324
    return (new_bv);
  }
  {
#line 1326
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unhandled tag: %d\n",
          tag);
#line 1327
  exit(-1);
  }
}
}
#line 1330 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void relocate_new_code(ikptr x , gc_t *gc ) 
{ 
  ikptr relocvector ;
  ikptr relocsize ;
  ikptr p ;
  ikptr q ;
  ikptr code ;
  long r ;
  int tmp ;
  long tag ;
  long code_off ;
  ikptr old_object ;
  ikptr new_object ;
  ikptr tmp___0 ;
  long obj_off ;
  int tmp___1 ;
  ikptr old_object___0 ;
  ikptr new_object___0 ;
  ikptr tmp___2 ;
  long obj_off___0 ;
  int tmp___3 ;
  ikptr obj ;
  ikptr displaced_object ;
  long next_word ;
  ikptr relative_distance ;

  {
  {
#line 1332
  relocvector = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 1333
  relocvector = add_object_proc(gc, relocvector);
#line 1334
  *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ))) + 0) = relocvector;
#line 1335
  *((ikptr *)((long )x + (long )(4 * (int )sizeof(ikptr ))) + 0) = add_object_proc(gc,
                                                                                   *((ikptr *)((long )x + (long )(4 * (int )sizeof(ikptr ))) + 0));
#line 1337
  relocsize = *((ikptr *)((long )relocvector + -5L) + 0);
#line 1338
  p = relocvector + (ikptr )((int )sizeof(ikptr ) - 5);
#line 1339
  q = p + relocsize;
#line 1340
  code = x + (ikptr )(6 * (int )sizeof(ikptr ));
  }
  {
#line 1341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1341
    if (! (p < q)) {
#line 1341
      goto while_break;
    }
#line 1342
    if ((int )sizeof(ikptr ) == 4) {
#line 1342
      tmp = 2;
    } else {
#line 1342
      tmp = 3;
    }
#line 1342
    r = (long )*((ikptr *)((long )p) + 0) >> tmp;
#line 1343
    tag = r & 3L;
#line 1344
    code_off = r >> 2;
#line 1345
    if (tag == 0L) {
      {
#line 1351
      old_object = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0);
#line 1352
      tmp___0 = add_object_proc(gc, old_object);
#line 1352
      new_object = tmp___0;
#line 1353
      *((ikptr *)((long )code + code_off) + 0) = new_object;
#line 1354
      p += (ikptr )(2 * (int )sizeof(ikptr ));
      }
    } else
#line 1356
    if (tag == 2L) {
#line 1358
      if ((int )sizeof(ikptr ) == 4) {
#line 1358
        tmp___1 = 2;
      } else {
#line 1358
        tmp___1 = 3;
      }
      {
#line 1358
      obj_off = (long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp___1;
#line 1359
      old_object___0 = *((ikptr *)((long )p + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 1360
      tmp___2 = add_object_proc(gc, old_object___0);
#line 1360
      new_object___0 = tmp___2;
#line 1361
      *((ikptr *)((long )code + code_off) + 0) = new_object___0 + (ikptr )obj_off;
#line 1362
      p += (ikptr )(3 * (int )sizeof(ikptr ));
      }
    } else
#line 1364
    if (tag == 3L) {
#line 1366
      if ((int )sizeof(ikptr ) == 4) {
#line 1366
        tmp___3 = 2;
      } else {
#line 1366
        tmp___3 = 3;
      }
      {
#line 1366
      obj_off___0 = (long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp___3;
#line 1367
      obj = *((ikptr *)((long )p + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 1372
      obj = add_object_proc(gc, obj);
#line 1373
      displaced_object = obj + (ikptr )obj_off___0;
#line 1374
      next_word = (long )((code + (ikptr )code_off) + 4UL);
#line 1375
      relative_distance = displaced_object - (ikptr )next_word;
      }
#line 1376
      if ((long )relative_distance != (long )((int )relative_distance)) {
        {
#line 1377
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"relocation error with relative=0x%016lx\n",
                relative_distance);
#line 1379
        exit(-1);
        }
      }
#line 1381
      *((int *)(code + (ikptr )code_off)) = (int )relative_distance;
#line 1382
      p += (ikptr )(3 * (int )sizeof(ikptr ));
    } else
#line 1384
    if (tag == 1L) {
#line 1386
      p += (ikptr )(2 * (int )sizeof(ikptr ));
    } else {
      {
#line 1389
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid rtag %ld in 0x%016lx\n",
              tag, r);
#line 1390
      exit(-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1393
  return;
}
}
#line 1397 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void collect_loop(gc_t *gc ) 
{ 
  int done ;
  qupages_t *qu ;
  ikptr p ;
  ikptr q ;
  qupages_t *next ;
  qupages_t *qu___0 ;
  ikptr p___0 ;
  ikptr q___0 ;
  qupages_t *next___0 ;
  qupages_t *qu___1 ;
  ikptr p___1 ;
  ikptr q___1 ;
  qupages_t *next___1 ;
  qupages_t *codes ;
  ikptr p___2 ;
  ikptr q___2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  qupages_t *next___2 ;
  meta_t *meta ;
  ikptr p___3 ;
  ikptr q___3 ;
  meta_t *meta___0 ;
  ikptr p___4 ;
  ikptr q___4 ;
  meta_t *meta___1 ;
  ikptr p___5 ;
  ikptr q___5 ;
  meta_t *meta___2 ;
  ikptr p___6 ;
  ikptr q___6 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  meta_t *meta___3 ;
  ikptr p___7 ;
  ikptr q___7 ;
  meta_t *meta___4 ;
  ikptr p___8 ;
  ikptr q___8 ;
  meta_t *meta___5 ;
  ikptr p___9 ;
  ikptr q___9 ;
  meta_t *meta___6 ;
  ikptr p___10 ;
  ikptr q___10 ;
  meta_t *meta___7 ;
  ikptr p___11 ;
  ikptr q___11 ;

  {
  {
#line 1400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    done = 1;
#line 1403
    qu = gc->queues[4];
#line 1404
    if (qu) {
#line 1405
      done = 0;
#line 1406
      gc->queues[4] = (qupages_t *)0;
      {
#line 1407
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1408
        p = qu->p;
#line 1409
        q = qu->q;
        {
#line 1410
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1410
          if (! (p < q)) {
#line 1410
            goto while_break___1;
          }
          {
#line 1411
          *((ikptr *)((long )p) + 0) = add_object_proc(gc, *((ikptr *)((long )p) + 0));
#line 1412
          p += (ikptr )(2 * (int )sizeof(ikptr ));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1414
        next = qu->next;
#line 1415
        ik_free((void *)qu, (int )sizeof(qupages_t ));
#line 1416
        qu = next;
        }
#line 1407
        if (! qu) {
#line 1407
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1422
    qu___0 = gc->queues[0];
#line 1423
    if (qu___0) {
#line 1424
      done = 0;
#line 1425
      gc->queues[0] = (qupages_t *)0;
      {
#line 1426
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1427
        p___0 = qu___0->p;
#line 1428
        q___0 = qu___0->q;
        {
#line 1429
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1429
          if (! (p___0 < q___0)) {
#line 1429
            goto while_break___3;
          }
          {
#line 1430
          *((ikptr *)((long )p___0) + 0) = add_object_proc(gc, *((ikptr *)((long )p___0) + 0));
#line 1431
          p___0 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1433
        next___0 = qu___0->next;
#line 1434
        ik_free((void *)qu___0, (int )sizeof(qupages_t ));
#line 1435
        qu___0 = next___0;
        }
#line 1426
        if (! qu___0) {
#line 1426
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1441
    qu___1 = gc->queues[5];
#line 1442
    if (qu___1) {
#line 1443
      done = 0;
#line 1444
      gc->queues[5] = (qupages_t *)0;
      {
#line 1445
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1446
        p___1 = qu___1->p;
#line 1447
        q___1 = qu___1->q;
        {
#line 1448
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1448
          if (! (p___1 < q___1)) {
#line 1448
            goto while_break___5;
          }
          {
#line 1449
          *((ikptr *)((long )p___1) + 0) = add_object_proc(gc, *((ikptr *)((long )p___1) + 0));
#line 1450
          p___1 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 1452
        next___1 = qu___1->next;
#line 1453
        ik_free((void *)qu___1, (int )sizeof(qupages_t ));
#line 1454
        qu___1 = next___1;
        }
#line 1445
        if (! qu___1) {
#line 1445
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 1460
    codes = gc->queues[1];
#line 1461
    if (codes) {
#line 1462
      gc->queues[1] = (qupages_t *)0;
#line 1463
      done = 0;
      {
#line 1464
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1465
        p___2 = codes->p;
#line 1466
        q___2 = codes->q;
        {
#line 1467
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1467
          if (! (p___2 < q___2)) {
#line 1467
            goto while_break___7;
          }
          {
#line 1468
          relocate_new_code(p___2, gc);
#line 1469
          alloc_code_count --;
          }
#line 1470
          if ((int )sizeof(ikptr ) == 4) {
#line 1470
            tmp = 2;
          } else {
#line 1470
            tmp = 3;
          }
#line 1470
          if ((int )sizeof(ikptr ) == 4) {
#line 1470
            tmp___0 = 2;
          } else {
#line 1470
            tmp___0 = 3;
          }
#line 1470
          if ((int )sizeof(ikptr ) == 4) {
#line 1470
            tmp___1 = 2;
          } else {
#line 1470
            tmp___1 = 3;
          }
#line 1470
          p___2 += (ikptr )((((((long )(6 * (int )sizeof(ikptr )) + ((long )*((ikptr *)((long )p___2 + (long )((int )sizeof(ikptr ))) + 0) >> tmp)) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1));
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1472
        next___2 = codes->next;
#line 1473
        ik_free((void *)codes, (int )sizeof(qupages_t ));
#line 1474
        codes = next___2;
        }
#line 1464
        if (! codes) {
#line 1464
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1480
    meta = & gc->meta[4];
#line 1481
    p___3 = meta->aq;
#line 1482
    q___3 = meta->ap;
#line 1483
    if (p___3 < q___3) {
#line 1484
      done = 0;
      {
#line 1485
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1486
        meta->aq = q___3;
        {
#line 1487
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1487
          if (! (p___3 < q___3)) {
#line 1487
            goto while_break___9;
          }
          {
#line 1488
          *((ikptr *)((long )p___3) + 0) = add_object_proc(gc, *((ikptr *)((long )p___3) + 0));
#line 1489
          p___3 += (ikptr )(2 * (int )sizeof(ikptr ));
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1491
        p___3 = meta->aq;
#line 1492
        q___3 = meta->ap;
#line 1485
        if (! (p___3 < q___3)) {
#line 1485
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 1497
    meta___0 = & gc->meta[5];
#line 1498
    p___4 = meta___0->aq;
#line 1499
    q___4 = meta___0->ap;
#line 1500
    if (p___4 < q___4) {
#line 1501
      done = 0;
      {
#line 1502
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1503
        meta___0->aq = q___4;
        {
#line 1504
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1504
          if (! (p___4 < q___4)) {
#line 1504
            goto while_break___11;
          }
          {
#line 1505
          *((ikptr *)((long )p___4) + 0) = add_object_proc(gc, *((ikptr *)((long )p___4) + 0));
#line 1506
          p___4 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1508
        p___4 = meta___0->aq;
#line 1509
        q___4 = meta___0->ap;
#line 1502
        if (! (p___4 < q___4)) {
#line 1502
          goto while_break___10;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 1514
    meta___1 = & gc->meta[0];
#line 1515
    p___5 = meta___1->aq;
#line 1516
    q___5 = meta___1->ap;
#line 1517
    if (p___5 < q___5) {
#line 1518
      done = 0;
      {
#line 1519
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1520
        meta___1->aq = q___5;
        {
#line 1521
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1521
          if (! (p___5 < q___5)) {
#line 1521
            goto while_break___13;
          }
          {
#line 1522
          *((ikptr *)((long )p___5) + 0) = add_object_proc(gc, *((ikptr *)((long )p___5) + 0));
#line 1523
          p___5 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 1525
        p___5 = meta___1->aq;
#line 1526
        q___5 = meta___1->ap;
#line 1519
        if (! (p___5 < q___5)) {
#line 1519
          goto while_break___12;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1531
    meta___2 = & gc->meta[1];
#line 1532
    p___6 = meta___2->aq;
#line 1533
    q___6 = meta___2->ap;
#line 1534
    if (p___6 < q___6) {
#line 1535
      done = 0;
      {
#line 1536
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1537
        meta___2->aq = q___6;
        {
#line 1538
        while (1) {
          while_continue___15: /* CIL Label */ ;
          {
#line 1539
          alloc_code_count --;
#line 1540
          relocate_new_code(p___6, gc);
          }
#line 1541
          if ((int )sizeof(ikptr ) == 4) {
#line 1541
            tmp___2 = 2;
          } else {
#line 1541
            tmp___2 = 3;
          }
#line 1541
          if ((int )sizeof(ikptr ) == 4) {
#line 1541
            tmp___3 = 2;
          } else {
#line 1541
            tmp___3 = 3;
          }
#line 1541
          if ((int )sizeof(ikptr ) == 4) {
#line 1541
            tmp___4 = 2;
          } else {
#line 1541
            tmp___4 = 3;
          }
#line 1541
          p___6 += (ikptr )((((((long )(6 * (int )sizeof(ikptr )) + ((long )*((ikptr *)((long )p___6 + (long )((int )sizeof(ikptr ))) + 0) >> tmp___2)) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___3 + 1)) << (tmp___4 + 1));
#line 1538
          if (! (p___6 < q___6)) {
#line 1538
            goto while_break___15;
          }
        }
        while_break___15: /* CIL Label */ ;
        }
#line 1543
        p___6 = meta___2->aq;
#line 1544
        q___6 = meta___2->ap;
#line 1536
        if (! (p___6 < q___6)) {
#line 1536
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 1400
    if (! (! done)) {
#line 1400
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1555
  meta___3 = & gc->meta[4];
#line 1556
  p___7 = meta___3->ap;
#line 1557
  q___7 = meta___3->ep;
  {
#line 1558
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1558
    if (! (p___7 < q___7)) {
#line 1558
      goto while_break___16;
    }
#line 1559
    *((ikptr *)((long )p___7) + 0) = (ikptr )0;
#line 1560
    p___7 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1564
  meta___4 = & gc->meta[5];
#line 1565
  p___8 = meta___4->ap;
#line 1566
  q___8 = meta___4->ep;
  {
#line 1567
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 1567
    if (! (p___8 < q___8)) {
#line 1567
      goto while_break___17;
    }
#line 1568
    *((ikptr *)((long )p___8) + 0) = (ikptr )0;
#line 1569
    p___8 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___17: /* CIL Label */ ;
  }
#line 1573
  meta___5 = & gc->meta[0];
#line 1574
  p___9 = meta___5->ap;
#line 1575
  q___9 = meta___5->ep;
  {
#line 1576
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 1576
    if (! (p___9 < q___9)) {
#line 1576
      goto while_break___18;
    }
#line 1577
    *((ikptr *)((long )p___9) + 0) = (ikptr )0;
#line 1578
    p___9 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___18: /* CIL Label */ ;
  }
#line 1582
  meta___6 = & gc->meta[3];
#line 1583
  p___10 = meta___6->ap;
#line 1584
  q___10 = meta___6->ep;
  {
#line 1585
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 1585
    if (! (p___10 < q___10)) {
#line 1585
      goto while_break___19;
    }
#line 1586
    *((ikptr *)((long )p___10) + 0) = (ikptr )0;
#line 1587
    p___10 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___19: /* CIL Label */ ;
  }
#line 1591
  meta___7 = & gc->meta[1];
#line 1592
  p___11 = meta___7->ap;
#line 1593
  q___11 = meta___7->ep;
  {
#line 1594
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 1594
    if (! (p___11 < q___11)) {
#line 1594
      goto while_break___20;
    }
#line 1595
    *((ikptr *)((long )p___11) + 0) = (ikptr )0;
#line 1596
    p___11 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___20: /* CIL Label */ ;
  }
#line 1600
  return;
}
}
#line 1602 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void fix_weak_pointers(gc_t *gc ) 
{ 
  unsigned int *segment_vec ;
  ikpcb *pcb ;
  long lo_idx ;
  long hi_idx ;
  long i ;
  int collect_gen ;
  unsigned int t ;
  ikptr p ;
  ikptr q ;
  ikptr x ;
  int tag ;
  ikptr fst ;
  int x_gen ;

  {
#line 1604
  segment_vec = gc->segment_vector;
#line 1605
  pcb = gc->pcb;
#line 1606
  lo_idx = (long )(pcb->memory_base >> 12);
#line 1607
  hi_idx = (long )(pcb->memory_end >> 12);
#line 1608
  i = lo_idx;
#line 1609
  collect_gen = gc->collect_gen;
  {
#line 1610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1610
    if (! (i < hi_idx)) {
#line 1610
      goto while_break;
    }
#line 1611
    t = *(segment_vec + i);
#line 1612
    if ((t & 3848U) == 1544U) {
#line 1616
      p = (ikptr )(i << 12);
#line 1617
      q = p + 4096UL;
      {
#line 1618
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1618
        if (! (p < q)) {
#line 1618
          goto while_break___0;
        }
#line 1619
        x = *((ikptr *)((long )p) + 0);
#line 1620
        if (! ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
#line 1621
          tag = (int )x & 7;
#line 1622
          if (tag != 7) {
#line 1623
            fst = *((ikptr *)((long )x + (long )(- tag)) + 0);
#line 1624
            if (fst == 0xffffffffffffffffUL) {
#line 1625
              *((ikptr *)((long )p) + 0) = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - tag)) + 0);
            } else {
#line 1627
              x_gen = (int )(*(segment_vec + (x >> 12)) & 15U);
#line 1628
              if (x_gen <= collect_gen) {
#line 1629
                *((ikptr *)((long )p) + 0) = (ikptr )143;
              }
            }
          }
        }
#line 1634
        p += (ikptr )(2 * (int )sizeof(ikptr ));
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1638
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1640
  return;
}
}
#line 1642 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static unsigned int dirty_mask[5]  = {      2290649224U,      3435973836U,      4008636142U,      4294967295U, 
        0U};
#line 1651 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static unsigned int cleanup_mask[5]  = {      0U,      2290649224U,      3435973836U,      4008636142U, 
        4294967295U};
#line 1661 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void scan_dirty_pointers_page(gc_t *gc , long page_idx___1 , int mask ) 
{ 
  unsigned int *segment_vec ;
  unsigned int *dirty_vec ;
  unsigned int t ;
  unsigned int d ;
  unsigned int masked_d ;
  ikptr p ;
  int j ;
  unsigned int new_d ;
  ikptr q ;
  unsigned int card_d ;
  ikptr x ;
  ikptr y ;
  ikptr tmp ;

  {
#line 1663
  segment_vec = (unsigned int *)((long )gc->segment_vector);
#line 1664
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
#line 1665
  t = *(segment_vec + page_idx___1);
#line 1666
  d = *(dirty_vec + page_idx___1);
#line 1667
  masked_d = d & (unsigned int )mask;
#line 1668
  p = (ikptr )(page_idx___1 << 12);
#line 1670
  new_d = 0U;
#line 1671
  j = 0;
  {
#line 1671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1671
    if (! (j < 8)) {
#line 1671
      goto while_break;
    }
#line 1672
    if (masked_d & (unsigned int )(15 << j * 4)) {
#line 1674
      q = p + 512UL;
#line 1675
      card_d = 0U;
      {
#line 1676
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1676
        if (! (p < q)) {
#line 1676
          goto while_break___0;
        }
#line 1677
        x = *((ikptr *)((long )p) + 0);
#line 1678
        if (! ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
#line 1678
          if (! (((int )x & 7) == 7)) {
            {
#line 1681
            tmp = add_object_proc(gc, x);
#line 1681
            y = tmp;
#line 1682
            segment_vec = gc->segment_vector;
#line 1683
            *((ikptr *)((long )p) + 0) = y;
#line 1684
            card_d |= *(segment_vec + (y >> 12));
            }
          }
        }
#line 1686
        p += (ikptr )((int )sizeof(ikptr ));
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1688
      card_d = (card_d & 240U) >> 4;
#line 1689
      new_d |= card_d << j * 4;
    } else {
#line 1691
      p += 512UL;
#line 1692
      new_d |= d & (unsigned int )(15 << j * 4);
    }
#line 1671
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1695
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
#line 1696
  new_d &= cleanup_mask[t & 15U];
#line 1697
  *(dirty_vec + page_idx___1) = new_d;
#line 1698
  return;
}
}
#line 1700 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void scan_dirty_code_page(gc_t *gc , long page_idx___1 ) 
{ 
  ikptr p ;
  ikptr start ;
  ikptr q ;
  unsigned int *segment_vec ;
  unsigned int *dirty_vec ;
  unsigned int t ;
  unsigned int new_d ;
  long j ;
  long code_size ;
  int tmp ;
  ikptr rvec ;
  ikptr len ;
  unsigned long i ;
  unsigned long code_d ;
  ikptr r ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1702
  p = (ikptr )(page_idx___1 << 12);
#line 1703
  start = p;
#line 1704
  q = p + 4096UL;
#line 1705
  segment_vec = (unsigned int *)((long )gc->segment_vector);
#line 1706
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
#line 1708
  t = *(segment_vec + page_idx___1);
#line 1710
  new_d = 0U;
  {
#line 1711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1711
    if (! (p < q)) {
#line 1711
      goto while_break;
    }
#line 1712
    if (*((ikptr *)((long )p) + 0) != 47UL) {
#line 1713
      p = q;
    } else {
#line 1716
      j = ((long )p - (long )start) / 512L;
#line 1717
      if ((int )sizeof(ikptr ) == 4) {
#line 1717
        tmp = 2;
      } else {
#line 1717
        tmp = 3;
      }
      {
#line 1717
      code_size = (long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp;
#line 1718
      relocate_new_code(p, gc);
#line 1719
      segment_vec = gc->segment_vector;
#line 1720
      rvec = *((ikptr *)((long )p + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 1721
      len = *((ikptr *)((long )rvec + -5L) + 0);
#line 1724
      code_d = (unsigned long )*(segment_vec + (rvec >> 12));
#line 1725
      i = 0UL;
      }
      {
#line 1725
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1725
        if (! (i < len)) {
#line 1725
          goto while_break___0;
        }
#line 1726
        r = *((ikptr *)((long )rvec + (long )(i + (unsigned long )((int )sizeof(ikptr ) - 5))) + 0);
#line 1727
        if (! ((r & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
#line 1727
          if (! (((int )r & 7) == 7)) {
            {
#line 1730
            r = add_object_proc(gc, r);
#line 1731
            segment_vec = gc->segment_vector;
#line 1732
            code_d |= (unsigned long )*(segment_vec + (r >> 12));
            }
          }
        }
#line 1725
        i += (unsigned long )((int )sizeof(ikptr ));
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1735
      new_d = (unsigned int )((unsigned long )new_d | (code_d << j * 4L));
#line 1736
      if ((int )sizeof(ikptr ) == 4) {
#line 1736
        tmp___0 = 2;
      } else {
#line 1736
        tmp___0 = 3;
      }
#line 1736
      if ((int )sizeof(ikptr ) == 4) {
#line 1736
        tmp___1 = 2;
      } else {
#line 1736
        tmp___1 = 3;
      }
#line 1736
      p += (ikptr )(((((code_size + (long )(6 * (int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1739
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
#line 1740
  new_d &= cleanup_mask[t & 15U];
#line 1741
  *(dirty_vec + page_idx___1) = new_d;
#line 1742
  return;
}
}
#line 1748 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void scan_dirty_pages(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  long lo_idx ;
  long hi_idx ;
  unsigned int *dirty_vec ;
  unsigned int *segment_vec ;
  int collect_gen ;
  unsigned int mask ;
  long i ;
  unsigned int d ;
  unsigned int t ;
  int tgen ;
  int type ;

  {
#line 1750
  pcb = gc->pcb;
#line 1751
  lo_idx = (long )(pcb->memory_base >> 12);
#line 1752
  hi_idx = (long )(pcb->memory_end >> 12);
#line 1753
  dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1754
  segment_vec = (unsigned int *)((long )pcb->segment_vector);
#line 1755
  collect_gen = gc->collect_gen;
#line 1756
  mask = dirty_mask[collect_gen];
#line 1757
  i = lo_idx;
  {
#line 1758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1758
    if (! (i < hi_idx)) {
#line 1758
      goto while_break;
    }
#line 1759
    d = *(dirty_vec + i);
#line 1760
    if (d & mask) {
#line 1761
      t = *(segment_vec + i);
#line 1762
      tgen = (int )(t & 15U);
#line 1763
      if (tgen > collect_gen) {
#line 1764
        type = (int )(t & 3840U);
#line 1765
        if (type == 768) {
          {
#line 1766
          scan_dirty_pointers_page(gc, i, (int )mask);
#line 1767
          dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1768
          segment_vec = (unsigned int *)((long )pcb->segment_vector);
          }
        } else
#line 1770
        if (type == 1792) {
          {
#line 1771
          scan_dirty_pointers_page(gc, i, (int )mask);
#line 1772
          dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1773
          segment_vec = (unsigned int *)((long )pcb->segment_vector);
          }
        } else
#line 1775
        if (type == 1536) {
          {
#line 1776
          scan_dirty_pointers_page(gc, i, (int )mask);
#line 1777
          dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1778
          segment_vec = (unsigned int *)((long )pcb->segment_vector);
          }
        } else
#line 1780
        if (type == 1280) {
          {
#line 1781
          scan_dirty_code_page(gc, i);
#line 1782
          dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1783
          segment_vec = (unsigned int *)((long )pcb->segment_vector);
          }
        } else
#line 1785
        if (t & 61440U) {
          {
#line 1786
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: unhandled scan of type 0x%08x\n",
                  t);
#line 1787
          exit(-1);
          }
        }
      }
    }
#line 1791
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1793
  return;
}
}
#line 1798 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void deallocate_unused_pages(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  int collect_gen ;
  unsigned int *segment_vec ;
  ikptr memory_base ;
  ikptr memory_end ;
  ikptr lo_idx ;
  ikptr hi_idx ;
  ikptr i ;
  unsigned int t ;
  int gen ;

  {
#line 1800
  pcb = gc->pcb;
#line 1801
  collect_gen = gc->collect_gen;
#line 1802
  segment_vec = pcb->segment_vector;
#line 1803
  memory_base = pcb->memory_base;
#line 1804
  memory_end = pcb->memory_end;
#line 1805
  lo_idx = memory_base >> 12;
#line 1806
  hi_idx = memory_end >> 12;
#line 1807
  i = lo_idx;
  {
#line 1808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1808
    if (! (i < hi_idx)) {
#line 1808
      goto while_break;
    }
#line 1809
    t = *(segment_vec + i);
#line 1810
    if (t & 983040U) {
#line 1811
      gen = (int )(t & 7U);
#line 1812
      if (gen <= collect_gen) {
#line 1814
        if (! (t & 8U)) {
          {
#line 1817
          ik_munmap_from_segment(i << 12, 4096UL, pcb);
          }
        }
      }
    }
#line 1821
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1823
  return;
}
}
#line 1826 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void fix_new_pages(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  unsigned int *segment_vec ;
  ikptr memory_base ;
  ikptr memory_end ;
  ikptr lo_idx ;
  ikptr hi_idx ;
  ikptr i ;

  {
#line 1828
  pcb = gc->pcb;
#line 1829
  segment_vec = pcb->segment_vector;
#line 1830
  memory_base = pcb->memory_base;
#line 1831
  memory_end = pcb->memory_end;
#line 1832
  lo_idx = memory_base >> 12;
#line 1833
  hi_idx = memory_end >> 12;
#line 1834
  i = lo_idx;
  {
#line 1835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1835
    if (! (i < hi_idx)) {
#line 1835
      goto while_break;
    }
#line 1836
    *(segment_vec + i) &= 4294967287U;
#line 1843
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1845
  return;
}
}
#line 1847 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void add_one_tconc(ikpcb *pcb , ikptr p ) 
{ 
  ikptr tcbucket ;
  ikptr tc ;
  ikptr d ;
  ikptr new_pair ;

  {
#line 1849
  tcbucket = *((ikptr *)((long )p) + 0);
#line 1850
  tc = *((ikptr *)((long )tcbucket + -5L) + 0);
#line 1852
  d = *((ikptr *)((long )tc + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 1854
  new_pair = p + 1UL;
#line 1855
  *((ikptr *)((long )d + -1L) + 0) = tcbucket;
#line 1856
  *((ikptr *)((long )d + (long )((int )sizeof(ikptr ) - 1)) + 0) = new_pair;
#line 1857
  *((ikptr *)((long )new_pair + -1L) + 0) = (ikptr )47;
#line 1858
  *((ikptr *)((long )new_pair + (long )((int )sizeof(ikptr ) - 1)) + 0) = (ikptr )47;
#line 1859
  *((ikptr *)((long )tc + (long )((int )sizeof(ikptr ) - 1)) + 0) = new_pair;
#line 1860
  *((ikptr *)((long )tcbucket + -5L) + 0) = (ikptr )(4 * (int )sizeof(ikptr ) - (int )sizeof(ikptr ));
#line 1861
  *((int *)((long )pcb->dirty_vector) + (tc >> 12)) = -1;
#line 1862
  *((int *)((long )pcb->dirty_vector) + (d >> 12)) = -1;
#line 1863
  return;
}
}
#line 1865 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void gc_add_tconcs(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  ikptr p ;
  ikptr q ;
  ikpages *qu ;
  ikptr p___0 ;
  ikptr q___0 ;
  ikpages *next ;

  {
#line 1867
  if (gc->tconc_base == 0UL) {
#line 1868
    return;
  }
#line 1870
  pcb = gc->pcb;
#line 1872
  p = gc->tconc_base;
#line 1873
  q = gc->tconc_ap;
  {
#line 1874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1874
    if (! (p < q)) {
#line 1874
      goto while_break;
    }
    {
#line 1875
    add_one_tconc(pcb, p);
#line 1876
    p += (ikptr )(2 * (int )sizeof(ikptr ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1879
  qu = gc->tconc_queue;
  {
#line 1880
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1880
    if (! qu) {
#line 1880
      goto while_break___0;
    }
#line 1881
    p___0 = qu->base;
#line 1882
    q___0 = p___0 + (ikptr )qu->size;
    {
#line 1883
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1883
      if (! (p___0 < q___0)) {
#line 1883
        goto while_break___1;
      }
      {
#line 1884
      add_one_tconc(pcb, p___0);
#line 1885
      p___0 += (ikptr )(2 * (int )sizeof(ikptr ));
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1887
    next = qu->next;
#line 1888
    ik_free((void *)qu, (int )sizeof(ikpages ));
#line 1889
    qu = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1891
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
ikptr d_to_number(double n , ikpcb *pcb ) ;
#line 215
ikptr make_pointer(long x , ikpcb *pcb ) ;
#line 216
long long extract_num_longlong(ikptr x ) ;
#line 184 "/usr/include/x86_64-linux-gnu/ffi.h"
extern ffi_type ffi_type_void ;
#line 185
extern ffi_type ffi_type_uint8 ;
#line 186
extern ffi_type ffi_type_sint8 ;
#line 187
extern ffi_type ffi_type_uint16 ;
#line 188
extern ffi_type ffi_type_sint16 ;
#line 189
extern ffi_type ffi_type_uint32 ;
#line 190
extern ffi_type ffi_type_sint32 ;
#line 191
extern ffi_type ffi_type_uint64 ;
#line 192
extern ffi_type ffi_type_sint64 ;
#line 193
extern ffi_type ffi_type_float ;
#line 194
extern ffi_type ffi_type_double ;
#line 195
extern ffi_type ffi_type_pointer ;
#line 323
extern void *ffi_closure_alloc(size_t size , void **code ) ;
#line 332
extern ffi_status ffi_prep_closure_loc(ffi_closure * , ffi_cif * , void (*fun)(ffi_cif * ,
                                                                               void * ,
                                                                               void ** ,
                                                                               void * ) ,
                                       void *user_data , void *codeloc ) ;
#line 423
extern ffi_status ffi_prep_cif(ffi_cif *cif , ffi_abi abi , unsigned int nargs , ffi_type *rtype ,
                               ffi_type **atypes ) ;
#line 436
extern void ffi_call(ffi_cif *cif , void (*fn)(void) , void *rvalue , void **avalue ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void *alloc(size_t n , int m ) 
{ 
  void *x ;
  void *tmp ;

  {
  {
#line 19
  tmp = calloc(n, (size_t )m);
#line 19
  x = tmp;
  }
#line 20
  if ((unsigned long )x == (unsigned long )((void *)0)) {
    {
#line 21
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR (ikarus): calloc failed!\n");
#line 22
    exit(-1);
    }
  }
#line 24
  return (x);
}
}
#line 27
static ffi_type *scheme_to_ffi_type_cast(ikptr nptr ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static ffi_type *scheme_to_ffi_record_type_cast(ikptr vec ) 
{ 
  ikptr lenptr ;
  long n ;
  int tmp ;
  ffi_type *t ;
  void *tmp___0 ;
  ffi_type **ts ;
  void *tmp___1 ;
  long i ;

  {
#line 31
  lenptr = *((ikptr *)((long )vec + -5L) + 0);
#line 32
  if (! ((lenptr & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
    {
#line 33
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NOT A VECTOR 0x%016lx\n",
            vec);
#line 34
    exit(-1);
    }
  }
#line 36
  if ((int )sizeof(ikptr ) == 4) {
#line 36
    tmp = 2;
  } else {
#line 36
    tmp = 3;
  }
  {
#line 36
  n = (long )lenptr >> tmp;
#line 37
  tmp___0 = alloc(sizeof(ffi_type ), 1);
#line 37
  t = (ffi_type *)tmp___0;
#line 38
  tmp___1 = alloc(sizeof(ffi_type *), (int )(n + 1L));
#line 38
  ts = (ffi_type **)tmp___1;
#line 39
  t->size = (size_t )0;
#line 40
  t->alignment = (unsigned short)0;
#line 41
  t->type = (unsigned short)13;
#line 42
  t->elements = ts;
#line 44
  i = 0L;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < n)) {
#line 44
      goto while_break;
    }
    {
#line 45
    *(ts + i) = scheme_to_ffi_type_cast(*((ikptr *)((long )vec + ((long )((int )sizeof(ikptr ) - 5) + i * (long )((int )sizeof(ikptr )))) + 0));
#line 44
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  *(ts + n) = (ffi_type *)0;
#line 48
  return (t);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static ffi_type *scheme_to_ffi_type_cast(ikptr nptr ) 
{ 
  ffi_type *tmp ;
  long n ;
  int tmp___0 ;
  ffi_type *tmp___1 ;
  ffi_type *tmp___2 ;

  {
#line 53
  if (((int )nptr & 7) == 5) {
    {
#line 54
    tmp = scheme_to_ffi_record_type_cast(nptr);
    }
#line 54
    return (tmp);
  } else
#line 55
  if ((nptr & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 56
    if ((int )sizeof(ikptr ) == 4) {
#line 56
      tmp___0 = 2;
    } else {
#line 56
      tmp___0 = 3;
    }
#line 56
    n = (long )nptr >> tmp___0;
    {
#line 58
    if ((n & 15L) == 1L) {
#line 58
      goto case_1;
    }
#line 59
    if ((n & 15L) == 2L) {
#line 59
      goto case_2;
    }
#line 60
    if ((n & 15L) == 3L) {
#line 60
      goto case_3;
    }
#line 61
    if ((n & 15L) == 4L) {
#line 61
      goto case_4;
    }
#line 62
    if ((n & 15L) == 5L) {
#line 62
      goto case_5;
    }
#line 63
    if ((n & 15L) == 6L) {
#line 63
      goto case_6;
    }
#line 64
    if ((n & 15L) == 7L) {
#line 64
      goto case_7;
    }
#line 65
    if ((n & 15L) == 8L) {
#line 65
      goto case_8;
    }
#line 66
    if ((n & 15L) == 9L) {
#line 66
      goto case_9;
    }
#line 67
    if ((n & 15L) == 10L) {
#line 67
      goto case_10;
    }
#line 68
    if ((n & 15L) == 11L) {
#line 68
      goto case_11;
    }
#line 69
    if ((n & 15L) == 12L) {
#line 69
      goto case_12;
    }
#line 70
    if ((n & 15L) == 13L) {
#line 70
      goto case_13;
    }
#line 71
    if ((n & 15L) == 14L) {
#line 71
      goto case_14;
    }
#line 72
    goto switch_default;
    case_1: /* CIL Label */ 
#line 58
    return (& ffi_type_void);
    case_2: /* CIL Label */ 
#line 59
    return (& ffi_type_uint8);
    case_3: /* CIL Label */ 
#line 60
    return (& ffi_type_sint8);
    case_4: /* CIL Label */ 
#line 61
    return (& ffi_type_uint16);
    case_5: /* CIL Label */ 
#line 62
    return (& ffi_type_sint16);
    case_6: /* CIL Label */ 
#line 63
    return (& ffi_type_uint32);
    case_7: /* CIL Label */ 
#line 64
    return (& ffi_type_sint32);
    case_8: /* CIL Label */ 
#line 65
    if (sizeof(long ) == 4UL) {
#line 65
      tmp___1 = & ffi_type_uint32;
    } else {
#line 65
      tmp___1 = & ffi_type_uint64;
    }
#line 65
    return (tmp___1);
    case_9: /* CIL Label */ 
#line 66
    if (sizeof(long ) == 4UL) {
#line 66
      tmp___2 = & ffi_type_sint32;
    } else {
#line 66
      tmp___2 = & ffi_type_sint64;
    }
#line 66
    return (tmp___2);
    case_10: /* CIL Label */ 
#line 67
    return (& ffi_type_uint64);
    case_11: /* CIL Label */ 
#line 68
    return (& ffi_type_sint64);
    case_12: /* CIL Label */ 
#line 69
    return (& ffi_type_float);
    case_13: /* CIL Label */ 
#line 70
    return (& ffi_type_double);
    case_14: /* CIL Label */ 
#line 71
    return (& ffi_type_pointer);
    switch_default: /* CIL Label */ 
    {
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID ARG %ld",
            n);
#line 74
    exit(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID ARG %ld",
            nptr);
#line 78
    exit(-1);
    }
  }
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void *alloc_room_for_type(ffi_type *t ) 
{ 
  void *tmp ;

  {
  {
#line 84
  tmp = alloc(t->size, 1);
  }
#line 84
  return (tmp);
}
}
#line 87
long extract_num(ikptr x ) ;
#line 89
ikptr sll_to_number(long long n , ikpcb *pcb ) ;
#line 92
static void scheme_to_ffi_value_cast(ffi_type *t , ikptr nptr , ikptr p , void *r ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void scheme_to_ffi_record_value_cast(ffi_type *t , ikptr nptr , ikptr p , void *r ) 
{ 
  ffi_type **ts ;
  char *buf ;
  ikptr lenptr ;
  int n ;
  int tmp ;
  int i ;
  ffi_type *at ;
  ikptr argt ;
  ikptr arg ;

  {
#line 96
  if ((int )t->type != 13) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a struct type\n");
#line 98
    exit(-1);
    }
  }
#line 100
  ts = t->elements;
#line 101
  buf = (char *)r;
#line 102
  lenptr = *((ikptr *)((long )nptr + -5L) + 0);
#line 103
  if ((int )sizeof(ikptr ) == 4) {
#line 103
    tmp = 2;
  } else {
#line 103
    tmp = 3;
  }
#line 103
  n = (int )((long )lenptr >> tmp);
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < n)) {
#line 105
      goto while_break;
    }
    {
#line 106
    at = *(ts + i);
#line 107
    argt = *((ikptr *)((long )nptr + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 108
    arg = *((ikptr *)((long )p + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 109
    scheme_to_ffi_value_cast(at, argt, arg, (void *)buf);
#line 110
    buf += at->size;
#line 105
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void scheme_to_ffi_value_cast(ffi_type *t , ikptr nptr , ikptr p , void *r ) 
{ 
  long n ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 116
  if (((int )nptr & 7) == 5) {
    {
#line 117
    scheme_to_ffi_record_value_cast(t, nptr, p, r);
    }
  } else
#line 118
  if ((nptr & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 119
    if ((int )sizeof(ikptr ) == 4) {
#line 119
      tmp = 2;
    } else {
#line 119
      tmp = 3;
    }
#line 119
    n = (long )nptr >> tmp;
    {
#line 121
    if ((n & 15L) == 1L) {
#line 121
      goto case_1;
    }
#line 123
    if ((n & 15L) == 3L) {
#line 123
      goto case_3;
    }
#line 123
    if ((n & 15L) == 2L) {
#line 123
      goto case_3;
    }
#line 126
    if ((n & 15L) == 5L) {
#line 126
      goto case_5;
    }
#line 126
    if ((n & 15L) == 4L) {
#line 126
      goto case_5;
    }
#line 129
    if ((n & 15L) == 7L) {
#line 129
      goto case_7;
    }
#line 129
    if ((n & 15L) == 6L) {
#line 129
      goto case_7;
    }
#line 132
    if ((n & 15L) == 9L) {
#line 132
      goto case_9;
    }
#line 132
    if ((n & 15L) == 8L) {
#line 132
      goto case_9;
    }
#line 135
    if ((n & 15L) == 11L) {
#line 135
      goto case_11;
    }
#line 135
    if ((n & 15L) == 10L) {
#line 135
      goto case_11;
    }
#line 137
    if ((n & 15L) == 12L) {
#line 137
      goto case_12;
    }
#line 139
    if ((n & 15L) == 13L) {
#line 139
      goto case_13;
    }
#line 141
    if ((n & 15L) == 14L) {
#line 141
      goto case_14;
    }
#line 143
    goto switch_default;
    case_1: /* CIL Label */ 
#line 121
    return;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 124
    tmp___0 = extract_num(p);
#line 124
    *((char *)r) = (char )tmp___0;
    }
#line 124
    return;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 127
    tmp___1 = extract_num(p);
#line 127
    *((short *)r) = (short )tmp___1;
    }
#line 127
    return;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 130
    tmp___2 = extract_num(p);
#line 130
    *((int *)r) = (int )tmp___2;
    }
#line 130
    return;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    {
#line 133
    *((long *)r) = extract_num(p);
    }
#line 133
    return;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 136
    *((long long *)r) = extract_num_longlong(p);
    }
#line 136
    return;
    case_12: /* CIL Label */ 
#line 138
    *((float *)r) = (float )*((double *)((char *)((long )p) + 3));
#line 138
    return;
    case_13: /* CIL Label */ 
#line 140
    *((double *)r) = *((double *)((char *)((long )p) + 3));
#line 140
    return;
    case_14: /* CIL Label */ 
#line 142
    *((void **)r) = (void *)*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 142
    return;
    switch_default: /* CIL Label */ 
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID ARG %ld",
            n);
#line 145
    exit(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID TYPE  0x%016lx\n",
            nptr);
#line 149
    exit(-1);
    }
  }
#line 151
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static ikptr ffi_to_scheme_value_cast(int n , void *p , ikpcb *pcb ) 
{ 
  ikptr tmp ;
  ikptr tmp___0 ;
  ikptr tmp___1 ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;
  ikptr tmp___4 ;
  ikptr tmp___5 ;
  ikptr tmp___6 ;
  ikptr tmp___7 ;
  ikptr tmp___8 ;
  ikptr tmp___9 ;
  ikptr tmp___10 ;
  ikptr tmp___11 ;

  {
  {
#line 157
  if ((n & 15) == 1) {
#line 157
    goto case_1;
  }
#line 158
  if ((n & 15) == 2) {
#line 158
    goto case_2;
  }
#line 159
  if ((n & 15) == 3) {
#line 159
    goto case_3;
  }
#line 160
  if ((n & 15) == 4) {
#line 160
    goto case_4;
  }
#line 161
  if ((n & 15) == 5) {
#line 161
    goto case_5;
  }
#line 162
  if ((n & 15) == 6) {
#line 162
    goto case_6;
  }
#line 163
  if ((n & 15) == 7) {
#line 163
    goto case_7;
  }
#line 164
  if ((n & 15) == 8) {
#line 164
    goto case_8;
  }
#line 165
  if ((n & 15) == 9) {
#line 165
    goto case_9;
  }
#line 166
  if ((n & 15) == 10) {
#line 166
    goto case_10;
  }
#line 167
  if ((n & 15) == 11) {
#line 167
    goto case_11;
  }
#line 168
  if ((n & 15) == 12) {
#line 168
    goto case_12;
  }
#line 169
  if ((n & 15) == 13) {
#line 169
    goto case_13;
  }
#line 170
  if ((n & 15) == 14) {
#line 170
    goto case_14;
  }
#line 171
  goto switch_default;
  case_1: /* CIL Label */ 
#line 157
  return ((ikptr )127);
  case_2: /* CIL Label */ 
  {
#line 158
  tmp = u_to_number((unsigned long )*((unsigned char *)p), pcb);
  }
#line 158
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 159
  tmp___0 = s_to_number((long )*((signed char *)p), pcb);
  }
#line 159
  return (tmp___0);
  case_4: /* CIL Label */ 
  {
#line 160
  tmp___1 = u_to_number((unsigned long )*((unsigned short *)p), pcb);
  }
#line 160
  return (tmp___1);
  case_5: /* CIL Label */ 
  {
#line 161
  tmp___2 = s_to_number((long )*((short *)p), pcb);
  }
#line 161
  return (tmp___2);
  case_6: /* CIL Label */ 
  {
#line 162
  tmp___3 = u_to_number((unsigned long )*((unsigned int *)p), pcb);
  }
#line 162
  return (tmp___3);
  case_7: /* CIL Label */ 
  {
#line 163
  tmp___4 = s_to_number((long )*((int *)p), pcb);
  }
#line 163
  return (tmp___4);
  case_8: /* CIL Label */ 
  {
#line 164
  tmp___5 = u_to_number(*((unsigned long *)p), pcb);
  }
#line 164
  return (tmp___5);
  case_9: /* CIL Label */ 
  {
#line 165
  tmp___6 = s_to_number(*((long *)p), pcb);
  }
#line 165
  return (tmp___6);
  case_10: /* CIL Label */ 
  {
#line 166
  tmp___7 = ull_to_number(*((unsigned long long *)p), pcb);
  }
#line 166
  return (tmp___7);
  case_11: /* CIL Label */ 
  {
#line 167
  tmp___8 = sll_to_number(*((long long *)p), pcb);
  }
#line 167
  return (tmp___8);
  case_12: /* CIL Label */ 
  {
#line 168
  tmp___9 = d_to_number((double )*((float *)p), pcb);
  }
#line 168
  return (tmp___9);
  case_13: /* CIL Label */ 
  {
#line 169
  tmp___10 = d_to_number(*((double *)p), pcb);
  }
#line 169
  return (tmp___10);
  case_14: /* CIL Label */ 
  {
#line 170
  tmp___11 = make_pointer((long )*((void **)p), pcb);
  }
#line 170
  return (tmp___11);
  switch_default: /* CIL Label */ 
  {
#line 172
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID ARG %d",
          n);
#line 173
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
ikptr ikrt_ffi_prep_cif(ikptr rtptr , ikptr argstptr , ikpcb *pcb ) 
{ 
  ffi_cif *cif ;
  void *tmp ;
  ffi_abi abi ;
  int nargs ;
  int tmp___0 ;
  ffi_type **argtypes ;
  void *tmp___1 ;
  int i ;
  ikptr argt ;
  ffi_type *rtype ;
  ffi_type *tmp___2 ;
  ffi_status s ;
  ffi_status tmp___3 ;
  ikptr r ;
  ikptr tmp___4 ;

  {
  {
#line 179
  tmp = alloc(sizeof(ffi_cif ), 1);
#line 179
  cif = (ffi_cif *)tmp;
#line 180
  abi = (ffi_abi )2;
  }
#line 181
  if ((int )sizeof(ikptr ) == 4) {
#line 181
    tmp___0 = 2;
  } else {
#line 181
    tmp___0 = 3;
  }
  {
#line 181
  nargs = (int )((long )*((ikptr *)((long )argstptr + -5L) + 0) >> tmp___0);
#line 182
  tmp___1 = alloc(sizeof(ffi_type *), nargs + 1);
#line 182
  argtypes = (ffi_type **)tmp___1;
#line 184
  i = 0;
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i < nargs)) {
#line 184
      goto while_break;
    }
    {
#line 185
    argt = *((ikptr *)((long )argstptr + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 186
    *(argtypes + i) = scheme_to_ffi_type_cast(argt);
#line 184
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  *(argtypes + nargs) = (ffi_type *)((void *)0);
#line 189
  tmp___2 = scheme_to_ffi_type_cast(rtptr);
#line 189
  rtype = tmp___2;
#line 190
  tmp___3 = ffi_prep_cif(cif, abi, (unsigned int )nargs, rtype, argtypes);
#line 190
  s = tmp___3;
  }
#line 191
  if ((unsigned int )s == 0U) {
    {
#line 192
    tmp___4 = ik_safe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 192
    r = tmp___4;
#line 193
    *((ikptr *)((long )r) + 0) = (ikptr )263;
#line 194
    *((ikptr *)((long )r + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )cif;
    }
#line 195
    return (r + 5UL);
  } else {
#line 197
    return ((ikptr )47);
  }
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
ikptr ikrt_seal_scheme_stack(ikpcb *pcb ) 
{ 
  ikptr frame_base ;
  ikptr frame_pointer ;
  ikptr underflow_handler ;
  cont *k ;
  cont *nk ;
  ikptr tmp ;

  {
#line 239
  frame_base = pcb->frame_base;
#line 240
  frame_pointer = pcb->frame_pointer;
#line 246
  if (frame_base - (ikptr )((int )sizeof(ikptr )) != frame_pointer) {
    {
#line 247
    underflow_handler = *((ikptr *)((long )frame_base + (long )(- ((int )sizeof(ikptr )))) + 0);
#line 248
    k = (cont *)pcb->next_k;
#line 249
    tmp = ik_unsafe_alloc(pcb, (int )sizeof(cont ));
#line 249
    nk = (cont *)tmp;
#line 250
    nk->tag = (ikptr )31;
#line 251
    nk->next = (ikptr )k;
#line 252
    nk->top = frame_pointer;
#line 257
    nk->size = (long )((frame_base - frame_pointer) - (ikptr )((int )sizeof(ikptr )));
#line 261
    pcb->next_k = 5UL + (ikptr )nk;
#line 262
    pcb->frame_base = frame_pointer;
#line 263
    pcb->frame_pointer = pcb->frame_base - (ikptr )((int )sizeof(ikptr ));
#line 269
    *((ikptr *)((long )pcb->frame_pointer) + 0) = underflow_handler;
    }
  }
#line 278
  return ((ikptr )127);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
ikptr ikrt_call_back(ikptr proc , ikpcb *pcb ) 
{ 
  ikptr sk ;
  ikptr tmp ;
  ikptr entry_point ;
  ikptr code_ptr ;
  ikptr rv ;
  ikptr tmp___0 ;

  {
  {
#line 283
  ikrt_seal_scheme_stack(pcb);
#line 285
  tmp = ik_unsafe_alloc(pcb, 4 * (int )sizeof(ikptr ));
#line 285
  sk = tmp;
#line 286
  *((ikptr *)((long )sk) + 0) = (ikptr )287;
#line 287
  *((ikptr *)((long )sk + (long )((int )sizeof(ikptr ))) + 0) = pcb->system_stack;
#line 288
  *((ikptr *)((long )sk + (long )(2 * (int )sizeof(ikptr ))) + 0) = pcb->next_k;
#line 289
  pcb->next_k = sk + 5UL;
#line 290
  entry_point = *((ikptr *)((long )proc + -3L) + 0);
#line 294
  code_ptr = entry_point - (ikptr )(6 * (int )sizeof(ikptr ) - 5);
#line 295
  pcb->frame_pointer = pcb->frame_base;
#line 296
  tmp___0 = ik_exec_code(pcb, code_ptr, (ikptr )0, proc);
#line 296
  rv = tmp___0;
#line 303
  sk = pcb->next_k - 5UL;
  }
#line 304
  if (*((ikptr *)((long )sk) + 0) != 287UL) {
    {
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ikarus internal error: invalid system cont\n");
#line 306
    exit(-1);
    }
  }
#line 308
  pcb->next_k = *((ikptr *)((long )sk + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 309
  *((ikptr *)((long )sk + (long )(2 * (int )sizeof(ikptr ))) + 0) = pcb->next_k;
#line 310
  pcb->system_stack = *((ikptr *)((long )sk + (long )((int )sizeof(ikptr ))) + 0);
#line 311
  pcb->frame_pointer = pcb->frame_base - (ikptr )((int )sizeof(ikptr ));
#line 315
  return (rv);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
ikptr ikrt_ffi_call(ikptr data , ikptr argsvec , ikpcb *pcb ) 
{ 
  ikptr sk ;
  ikptr tmp ;
  ikptr cifptr ;
  ikptr funptr ;
  ikptr typevec ;
  ikptr rtype ;
  ffi_cif *cif ;
  void (*fn)() ;
  int n ;
  int tmp___0 ;
  void **avalues ;
  void *tmp___1 ;
  int i ;
  ffi_type *t ;
  ikptr at ;
  ikptr v ;
  void *p ;
  void *tmp___2 ;
  void *rvalue ;
  void *tmp___3 ;
  int *tmp___4 ;
  ikptr val ;
  int tmp___5 ;
  ikptr tmp___6 ;

  {
  {
#line 323
  ikrt_seal_scheme_stack(pcb);
#line 324
  tmp = ik_unsafe_alloc(pcb, 4 * (int )sizeof(ikptr ));
#line 324
  sk = tmp;
#line 325
  *((ikptr *)((long )sk) + 0) = (ikptr )287;
#line 326
  *((ikptr *)((long )sk + (long )((int )sizeof(ikptr ))) + 0) = pcb->system_stack;
#line 327
  *((ikptr *)((long )sk + (long )(2 * (int )sizeof(ikptr ))) + 0) = pcb->next_k;
#line 328
  pcb->next_k = sk + 5UL;
#line 331
  cifptr = *((ikptr *)((long )data + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 332
  funptr = *((ikptr *)((long )data + (long )(((int )sizeof(ikptr ) - 5) + (int )sizeof(ikptr ))) + 0);
#line 333
  typevec = *((ikptr *)((long )data + (long )(((int )sizeof(ikptr ) - 5) + 2 * (int )sizeof(ikptr ))) + 0);
#line 334
  rtype = *((ikptr *)((long )data + (long )(((int )sizeof(ikptr ) - 5) + 3 * (int )sizeof(ikptr ))) + 0);
#line 335
  cif = (ffi_cif *)*((ikptr *)((long )cifptr + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 336
  fn = (void (*)())*((ikptr *)((long )funptr + (long )((int )sizeof(ikptr ) - 5)) + 0);
  }
#line 337
  if ((int )sizeof(ikptr ) == 4) {
#line 337
    tmp___0 = 2;
  } else {
#line 337
    tmp___0 = 3;
  }
  {
#line 337
  n = (int )((long )*((ikptr *)((long )argsvec + -5L) + 0) >> tmp___0);
#line 338
  tmp___1 = alloc(sizeof(void *), n + 1);
#line 338
  avalues = (void **)tmp___1;
#line 340
  i = 0;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! (i < n)) {
#line 340
      goto while_break;
    }
    {
#line 341
    t = *(cif->arg_types + i);
#line 342
    at = *((ikptr *)((long )typevec + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 343
    v = *((ikptr *)((long )argsvec + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 344
    tmp___2 = alloc_room_for_type(t);
#line 344
    p = tmp___2;
#line 345
    *(avalues + i) = p;
#line 346
    scheme_to_ffi_value_cast(t, at, v, p);
#line 340
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  *(avalues + n) = (void *)0;
#line 349
  tmp___3 = alloc_room_for_type(cif->rtype);
#line 349
  rvalue = tmp___3;
#line 350
  ffi_call(cif, fn, rvalue, avalues);
#line 351
  tmp___4 = __errno_location();
#line 351
  pcb->last_errno = *tmp___4;
  }
#line 352
  if ((int )sizeof(ikptr ) == 4) {
#line 352
    tmp___5 = 2;
  } else {
#line 352
    tmp___5 = 3;
  }
  {
#line 352
  tmp___6 = ffi_to_scheme_value_cast((int )((long )rtype >> tmp___5), rvalue, pcb);
#line 352
  val = tmp___6;
#line 353
  i = 0;
  }
  {
#line 353
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 353
    if (! (i < n)) {
#line 353
      goto while_break___0;
    }
    {
#line 354
    free(*(avalues + i));
#line 353
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 359
  free((void *)avalues);
#line 360
  free(rvalue);
#line 362
  pcb->frame_pointer = pcb->frame_base - (ikptr )((int )sizeof(ikptr ));
#line 364
  sk = pcb->next_k - 5UL;
  }
#line 365
  if (*((ikptr *)((long )sk) + 0) != 287UL) {
    {
#line 366
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ikarus internal error: invalid system cont\n");
#line 367
    exit(-1);
    }
  }
#line 369
  pcb->next_k = *((ikptr *)((long )sk + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 370
  pcb->system_stack = *((ikptr *)((long )sk + (long )((int )sizeof(ikptr ))) + 0);
#line 372
  return (val);
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
ikptr ikrt_has_ffi(void) 
{ 


  {
#line 377
  return ((ikptr )63);
}
}
#line 402
ikpcb *the_pcb ;
#line 403 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void generic_callback(ffi_cif *cif , void *ret , void **args , void *user_data ) 
{ 
  ikptr data ;
  ikptr proc ;
  ikptr argtypes_conv ;
  ikptr rtype_conv ;
  int n ;
  int tmp ;
  ikpcb *pcb ;
  ikptr code_entry ;
  ikptr code_ptr ;
  int i ;
  ikptr argt ;
  void *argp ;
  int tmp___0 ;
  ikptr rv ;
  int tmp___1 ;
  ikptr tmp___2 ;

  {
#line 410
  data = ((callback_locative *)user_data)->data;
#line 411
  proc = *((ikptr *)((long )data + (long )(((int )sizeof(ikptr ) - 5) + (int )sizeof(ikptr ))) + 0);
#line 412
  argtypes_conv = *((ikptr *)((long )data + (long )(((int )sizeof(ikptr ) - 5) + 2 * (int )sizeof(ikptr ))) + 0);
#line 413
  rtype_conv = *((ikptr *)((long )data + (long )(((int )sizeof(ikptr ) - 5) + 3 * (int )sizeof(ikptr ))) + 0);
#line 414
  if ((int )sizeof(ikptr ) == 4) {
#line 414
    tmp = 2;
  } else {
#line 414
    tmp = 3;
  }
#line 414
  n = (int )((long )*((ikptr *)((long )argtypes_conv + -5L) + 0) >> tmp);
#line 416
  pcb = the_pcb;
#line 417
  code_entry = *((ikptr *)((long )proc + -3L) + 0);
#line 418
  code_ptr = code_entry - (ikptr )(6 * (int )sizeof(ikptr ) - 5);
#line 420
  pcb->frame_pointer = pcb->frame_base;
#line 422
  i = 0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (i < n)) {
#line 422
      goto while_break;
    }
#line 423
    argt = *((ikptr *)((long )argtypes_conv + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 424
    argp = *(args + i);
#line 425
    if ((int )sizeof(ikptr ) == 4) {
#line 425
      tmp___0 = 2;
    } else {
#line 425
      tmp___0 = 3;
    }
    {
#line 425
    *((ikptr *)((long )pcb->frame_pointer + (long )(-2 * (int )sizeof(ikptr ) - i * (int )sizeof(ikptr ))) + 0) = ffi_to_scheme_value_cast((int )((long )argt >> tmp___0),
                                                                                                                                           argp,
                                                                                                                                           pcb);
#line 422
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  if ((int )sizeof(ikptr ) == 4) {
#line 428
    tmp___1 = 2;
  } else {
#line 428
    tmp___1 = 3;
  }
  {
#line 428
  tmp___2 = ik_exec_code(pcb, code_ptr, (ikptr )((long )(- n) << tmp___1), proc);
#line 428
  rv = tmp___2;
#line 432
  scheme_to_ffi_value_cast(cif->rtype, rtype_conv, rv, ret);
  }
#line 433
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
ikptr ikrt_prepare_callback(ikptr data , ikpcb *pcb ) 
{ 
  ikptr cifptr ;
  void *codeloc ;
  ffi_closure *closure ;
  void *tmp ;
  ffi_cif *cif ;
  callback_locative *loc ;
  void *tmp___0 ;
  ffi_status st ;
  ffi_status tmp___1 ;
  ikptr p ;
  ikptr tmp___2 ;

  {
  {
#line 439
  cifptr = *((ikptr *)((long )data + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 441
  tmp = ffi_closure_alloc(sizeof(ffi_closure ), & codeloc);
#line 441
  closure = (ffi_closure *)tmp;
#line 456
  cif = (ffi_cif *)*((ikptr *)((long )cifptr + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 458
  tmp___0 = malloc(sizeof(callback_locative ));
#line 458
  loc = (callback_locative *)tmp___0;
  }
#line 459
  if (! loc) {
    {
#line 460
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: ikarus malloc error\n");
#line 461
    exit(-1);
    }
  }
  {
#line 464
  tmp___1 = ffi_prep_closure_loc(closure, cif, & generic_callback, (void *)loc, codeloc);
#line 464
  st = tmp___1;
  }
#line 467
  if ((unsigned int )st != 0U) {
    {
#line 468
    free((void *)loc);
    }
#line 469
    return ((ikptr )47);
  }
  {
#line 472
  loc->data = data;
#line 473
  loc->next = pcb->callbacks;
#line 474
  pcb->callbacks = loc;
#line 476
  tmp___2 = ik_safe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 476
  p = tmp___2;
#line 477
  *((ikptr *)((long )p) + 0) = (ikptr )263;
#line 478
  *((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )codeloc;
  }
#line 479
  return (p + 5UL);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
int ho(int (*f)(int  ) , int n ) 
{ 
  int n0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 487
  tmp = (*f)(n);
#line 487
  n0 = tmp;
#line 489
  tmp___0 = (*f)(n);
  }
#line 489
  return (n0 + tmp___0);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
int ho2(ikptr fptr , ikptr nptr ) 
{ 
  int (*f)(int  ) ;
  int n ;
  int tmp ;
  int n0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 494
  f = (int (*)(int  ))*((ikptr *)((long )fptr + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 495
  if ((int )sizeof(ikptr ) == 4) {
#line 495
    tmp = 2;
  } else {
#line 495
    tmp = 3;
  }
  {
#line 495
  n = (int )((long )nptr >> tmp);
#line 497
  tmp___0 = (*f)(n);
#line 497
  n0 = tmp___0;
#line 499
  tmp___1 = (*f)(n);
  }
#line 499
  return (n0 + tmp___1);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
int test_I_I(int (*f)(int  ) , int n0 ) 
{ 
  int tmp ;

  {
  {
#line 504
  tmp = (*f)(n0);
  }
#line 504
  return (tmp);
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
int test_I_II(int (*f)(int  , int  ) , int n0 , int n1 ) 
{ 
  int tmp ;

  {
  {
#line 508
  tmp = (*f)(n0, n1);
  }
#line 508
  return (tmp);
}
}
#line 511 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
int test_I_III(int (*f)(int  , int  , int  ) , int n0 , int n1 , int n2 ) 
{ 
  int tmp ;

  {
  {
#line 512
  tmp = (*f)(n0, n1, n2);
  }
#line 512
  return (tmp);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
int add_I_I(int n0 ) 
{ 


  {
#line 516
  return (n0);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
int add_I_II(int n0 , int n1 ) 
{ 


  {
#line 519
  return (n0 + n1);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
int add_I_III(int n0 , int n1 , int n2 ) 
{ 


  {
#line 522
  return ((n0 + n1) + n2);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
float test_area_F_R(struct Rect r ) 
{ 
  float dx ;
  float dy ;

  {
#line 538
  dx = r.br.x - r.tl.x;
#line 539
  dy = r.br.y - r.tl.y;
#line 540
  return (dx * dy);
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
double test_D_D(double (*f)(double  ) , double n0 ) 
{ 
  double tmp ;

  {
  {
#line 544
  tmp = (*f)(n0);
  }
#line 544
  return (tmp);
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
double test_D_DD(double (*f)(double  , double  ) , double n0 , double n1 ) 
{ 
  double tmp ;

  {
  {
#line 548
  tmp = (*f)(n0, n1);
  }
#line 548
  return (tmp);
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
double test_D_DDD(double (*f)(double  , double  , double  ) , double n0 , double n1 ,
                  double n2 ) 
{ 
  double tmp ;

  {
  {
#line 552
  tmp = (*f)(n0, n1, n2);
  }
#line 552
  return (tmp);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
double add_D_D(double n0 ) 
{ 


  {
#line 556
  return (n0);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
double add_D_DD(double n0 , double n1 ) 
{ 


  {
#line 559
  return (n0 + n1);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
double add_D_DDD(double n0 , double n1 , double n2 ) 
{ 


  {
#line 562
  return ((n0 + n1) + n2);
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
int cadd1(int n ) 
{ 


  {
#line 570
  return (n + 1);
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
void hello_world(int n ) 
{ 


  {
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! (n > 0)) {
#line 574
      goto while_break;
    }
    {
#line 575
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hello World\n");
#line 576
    n --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  return;
}
}
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 455 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                                               void *__dest ,
                                                                                               size_t __n ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_isapointer(ikptr x , ikpcb *pcb ) 
{ 


  {
#line 10
  if (((int )x & 7) == 5) {
#line 10
    if (*((ikptr *)((long )x + -5L) + 0) == 263UL) {
#line 11
      return ((ikptr )63);
    } else {
#line 13
      return ((ikptr )47);
    }
  } else {
#line 13
    return ((ikptr )47);
  }
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_pointer_to_int(ikptr x , ikpcb *pcb ) 
{ 
  long p ;
  ikptr pfx ;
  int tmp ;
  ikptr bn ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;
  int tmp___3 ;

  {
#line 19
  p = (long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 20
  if ((int )sizeof(ikptr ) == 4) {
#line 20
    tmp = 2;
  } else {
#line 20
    tmp = 3;
  }
#line 20
  pfx = (ikptr )(p << tmp);
#line 21
  if ((int )sizeof(ikptr ) == 4) {
#line 21
    tmp___3 = 2;
  } else {
#line 21
    tmp___3 = 3;
  }
#line 21
  if ((long )pfx >> tmp___3 == p) {
#line 22
    return (pfx);
  } else {
#line 24
    if ((int )sizeof(ikptr ) == 4) {
#line 24
      tmp___0 = 2;
    } else {
#line 24
      tmp___0 = 3;
    }
#line 24
    if ((int )sizeof(ikptr ) == 4) {
#line 24
      tmp___1 = 2;
    } else {
#line 24
      tmp___1 = 3;
    }
    {
#line 24
    tmp___2 = ik_safe_alloc(pcb, (((((int )sizeof(ikptr ) + (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___0 + 1)) << (tmp___1 + 1));
#line 24
    bn = tmp___2;
    }
#line 25
    if (p > 0L) {
#line 26
      *((ikptr *)((long )bn) + 0) = (ikptr )(3 | (1 << 4));
#line 27
      *((ikptr *)((long )bn + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )p;
    } else {
#line 29
      *((ikptr *)((long )bn) + 0) = (ikptr )((3 | (1 << 4)) | (1 << 3));
#line 33
      *((ikptr *)((long )bn + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )(- p);
    }
#line 35
    return (bn + 5UL);
  }
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr make_pointer(long x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 41
  tmp = ik_safe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 41
  r = tmp;
#line 42
  *((ikptr *)((long )r) + 0) = (ikptr )263;
#line 43
  *((ikptr *)((long )r + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )x;
  }
#line 44
  return (r + 5UL);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
static long integer_to_long(ikptr x ) 
{ 
  int tmp ;

  {
#line 51
  if ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 52
    if ((int )sizeof(ikptr ) == 4) {
#line 52
      tmp = 2;
    } else {
#line 52
      tmp = 3;
    }
#line 52
    return ((long )x >> tmp);
  } else
#line 54
  if (*((ikptr *)((long )x + -5L) + 0) & 8UL) {
#line 55
    return (- ((long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0)));
  } else {
#line 57
    return ((long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0));
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_fx_to_pointer(ikptr x , ikpcb *pcb ) 
{ 
  int tmp ;
  ikptr tmp___0 ;

  {
#line 64
  if ((int )sizeof(ikptr ) == 4) {
#line 64
    tmp = 2;
  } else {
#line 64
    tmp = 3;
  }
  {
#line 64
  tmp___0 = make_pointer((long )x >> tmp, pcb);
  }
#line 64
  return (tmp___0);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_bn_to_pointer(ikptr x , ikpcb *pcb ) 
{ 
  ikptr tmp ;
  ikptr tmp___0 ;

  {
#line 69
  if (*((ikptr *)((long )x + -5L) + 0) & 8UL) {
    {
#line 70
    tmp = make_pointer((long )(- *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0)),
                       pcb);
    }
#line 70
    return (tmp);
  } else {
    {
#line 72
    tmp___0 = make_pointer((long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0),
                           pcb);
    }
#line 72
    return (tmp___0);
  }
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_dlerror(ikpcb *pcb ) 
{ 
  char *str ;
  char *tmp ;
  int len ;
  size_t tmp___0 ;
  ikptr bv ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;
  int tmp___4 ;

  {
  {
#line 85
  tmp = dlerror();
#line 85
  str = tmp;
  }
#line 86
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 87
    return ((ikptr )47);
  }
  {
#line 89
  tmp___0 = strlen((char const   *)str);
#line 89
  len = (int )tmp___0;
  }
#line 90
  if ((int )sizeof(ikptr ) == 4) {
#line 90
    tmp___1 = 2;
  } else {
#line 90
    tmp___1 = 3;
  }
#line 90
  if ((int )sizeof(ikptr ) == 4) {
#line 90
    tmp___2 = 2;
  } else {
#line 90
    tmp___2 = 3;
  }
  {
#line 90
  tmp___3 = ik_safe_alloc(pcb, (((((8 + len) + 1) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___1 + 1)) << (tmp___2 + 1));
#line 90
  bv = tmp___3;
  }
#line 91
  if ((int )sizeof(ikptr ) == 4) {
#line 91
    tmp___4 = 2;
  } else {
#line 91
    tmp___4 = 3;
  }
  {
#line 91
  *((ikptr *)((long )bv) + 0) = (ikptr )((long )len << tmp___4);
#line 92
  memcpy((void */* __restrict  */)((void *)(bv + 8UL)), (void const   */* __restrict  */)str,
         (size_t )(len + 1));
  }
#line 93
  return (bv + 2UL);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_dlopen(ikptr x , ikptr load_lazy , ikptr load_global , ikpcb *pcb ) 
{ 
  int flags ;
  int tmp ;
  int tmp___0 ;
  char *name ;
  char *tmp___1 ;
  void *p ;
  void *tmp___2 ;
  ikptr tmp___3 ;

  {
#line 102
  if (load_lazy == 47UL) {
#line 102
    tmp = 2;
  } else {
#line 102
    tmp = 1;
  }
#line 102
  if (load_global == 47UL) {
#line 102
    tmp___0 = 0;
  } else {
#line 102
    tmp___0 = 256;
  }
#line 102
  flags = tmp | tmp___0;
#line 105
  if (x == 47UL) {
#line 105
    tmp___1 = (char *)((void *)0);
  } else {
#line 105
    tmp___1 = (char *)(x + 6UL);
  }
  {
#line 105
  name = tmp___1;
#line 109
  tmp___2 = dlopen((char const   *)name, flags);
#line 109
  p = tmp___2;
  }
#line 110
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 111
    return ((ikptr )47);
  } else {
    {
#line 113
    tmp___3 = make_pointer((long )p, pcb);
    }
#line 113
    return (tmp___3);
  }
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_dlclose(ikptr x ) 
{ 
  int r ;
  int tmp ;
  ikptr tmp___0 ;

  {
  {
#line 119
  tmp = dlclose((void *)*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0));
#line 119
  r = tmp;
  }
#line 120
  if (r == 0) {
#line 120
    tmp___0 = (ikptr )63;
  } else {
#line 120
    tmp___0 = (ikptr )47;
  }
#line 120
  return (tmp___0);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_dlsym(ikptr handle , ikptr sym , ikpcb *pcb ) 
{ 
  void *p ;
  void *tmp ;
  ikptr tmp___0 ;

  {
  {
#line 126
  tmp = dlsym((void */* __restrict  */)((void *)*((ikptr *)((long )handle + (long )((int )sizeof(ikptr ) - 5)) + 0)),
              (char const   */* __restrict  */)((char *)sym + 6));
#line 126
  p = tmp;
  }
#line 128
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 129
    return ((ikptr )47);
  } else {
    {
#line 131
    tmp___0 = make_pointer((long )p, pcb);
    }
#line 131
    return (tmp___0);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_malloc(ikptr len , ikpcb *pcb ) 
{ 
  void *p ;
  int tmp ;
  void *tmp___0 ;
  ikptr tmp___1 ;

  {
#line 138
  if ((int )sizeof(ikptr ) == 4) {
#line 138
    tmp = 2;
  } else {
#line 138
    tmp = 3;
  }
  {
#line 138
  tmp___0 = malloc((size_t )((long )len >> tmp));
#line 138
  p = tmp___0;
  }
#line 139
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 140
    return ((ikptr )47);
  } else {
    {
#line 142
    tmp___1 = make_pointer((long )p, pcb);
    }
#line 142
    return (tmp___1);
  }
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_free(ikptr x ) 
{ 


  {
  {
#line 148
  free((void *)*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0));
  }
#line 149
  return ((ikptr )127);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_memcpy_to_bv(ikptr dst , ikptr dst_off , ikptr src , ikptr count ) 
{ 
  void *src_ptr ;
  void *dst_ptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 157
  src_ptr = (void *)*((ikptr *)((long )src + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 158
  if ((int )sizeof(ikptr ) == 4) {
#line 158
    tmp = 2;
  } else {
#line 158
    tmp = 3;
  }
#line 158
  dst_ptr = (void *)((dst + 6UL) + (ikptr )((long )dst_off >> tmp));
#line 159
  if ((int )sizeof(ikptr ) == 4) {
#line 159
    tmp___0 = 2;
  } else {
#line 159
    tmp___0 = 3;
  }
  {
#line 159
  memcpy((void */* __restrict  */)dst_ptr, (void const   */* __restrict  */)src_ptr,
         (size_t )((long )count >> tmp___0));
  }
#line 160
  return ((ikptr )127);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_memcpy_from_bv(ikptr dst , ikptr src , ikptr src_off , ikptr count ) 
{ 
  void *src_ptr ;
  void *dst_ptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 168
  if ((int )sizeof(ikptr ) == 4) {
#line 168
    tmp = 2;
  } else {
#line 168
    tmp = 3;
  }
#line 168
  src_ptr = (void *)((src + 6UL) + (ikptr )((long )src_off >> tmp));
#line 169
  dst_ptr = (void *)*((ikptr *)((long )dst + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 170
  if ((int )sizeof(ikptr ) == 4) {
#line 170
    tmp___0 = 2;
  } else {
#line 170
    tmp___0 = 3;
  }
  {
#line 170
  memcpy((void */* __restrict  */)dst_ptr, (void const   */* __restrict  */)src_ptr,
         (size_t )((long )count >> tmp___0));
  }
#line 171
  return ((ikptr )127);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_char(ikptr p , ikptr off ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 176
  if ((int )sizeof(ikptr ) == 4) {
#line 176
    tmp = 2;
  } else {
#line 176
    tmp = 3;
  }
#line 176
  if ((int )sizeof(ikptr ) == 4) {
#line 176
    tmp___0 = 2;
  } else {
#line 176
    tmp___0 = 3;
  }
#line 176
  return ((ikptr )((long )*((signed char *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp))) << tmp___0));
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_uchar(ikptr p , ikptr off ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 181
  if ((int )sizeof(ikptr ) == 4) {
#line 181
    tmp = 2;
  } else {
#line 181
    tmp = 3;
  }
#line 181
  if ((int )sizeof(ikptr ) == 4) {
#line 181
    tmp___0 = 2;
  } else {
#line 181
    tmp___0 = 3;
  }
#line 181
  return ((ikptr )((long )*((unsigned char *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp))) << tmp___0));
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_short(ikptr p , ikptr off ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 186
  if ((int )sizeof(ikptr ) == 4) {
#line 186
    tmp = 2;
  } else {
#line 186
    tmp = 3;
  }
#line 186
  if ((int )sizeof(ikptr ) == 4) {
#line 186
    tmp___0 = 2;
  } else {
#line 186
    tmp___0 = 3;
  }
#line 186
  return ((ikptr )((long )*((short *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp))) << tmp___0));
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_ushort(ikptr p , ikptr off ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 191
  if ((int )sizeof(ikptr ) == 4) {
#line 191
    tmp = 2;
  } else {
#line 191
    tmp = 3;
  }
#line 191
  if ((int )sizeof(ikptr ) == 4) {
#line 191
    tmp___0 = 2;
  } else {
#line 191
    tmp___0 = 3;
  }
#line 191
  return ((ikptr )((long )*((unsigned short *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp))) << tmp___0));
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_pointer(ikptr p , ikptr off , ikpcb *pcb ) 
{ 
  long idx ;
  long tmp ;
  void *ptr ;
  ikptr tmp___0 ;

  {
  {
#line 196
  tmp = integer_to_long(off);
#line 196
  idx = tmp;
#line 197
  ptr = (void *)*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 198
  tmp___0 = make_pointer((long )*((ikptr *)((long )ptr + idx) + 0), pcb);
  }
#line 198
  return (tmp___0);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_set_pointer(ikptr p , ikptr off , ikptr v ) 
{ 
  long idx ;
  long tmp ;
  void *ptr ;

  {
  {
#line 203
  tmp = integer_to_long(off);
#line 203
  idx = tmp;
#line 204
  ptr = (void *)*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 205
  *((ikptr *)((long )ptr + idx) + 0) = *((ikptr *)((long )v + (long )((int )sizeof(ikptr ) - 5)) + 0);
  }
#line 206
  return ((ikptr )127);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
static ikptr double_to_flonum(double x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 211
  tmp = ik_safe_alloc(pcb, 16);
#line 211
  r = tmp + 5UL;
#line 212
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 213
  *((double *)((char *)((long )r) + 3)) = x;
  }
#line 214
  return (r);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_set_float(ikptr p , ikptr off , ikptr v ) 
{ 
  long idx ;
  long tmp ;
  ikptr ptr ;

  {
  {
#line 219
  tmp = integer_to_long(off);
#line 219
  idx = tmp;
#line 220
  ptr = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 221
  *((float *)(ptr + (ikptr )idx)) = (float )*((double *)((char *)((long )v) + 3));
  }
#line 222
  return ((ikptr )127);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_float(ikptr p , ikptr off , ikpcb *pcb ) 
{ 
  long idx ;
  long tmp ;
  ikptr ptr ;
  double v ;
  ikptr tmp___0 ;

  {
  {
#line 227
  tmp = integer_to_long(off);
#line 227
  idx = tmp;
#line 228
  ptr = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 229
  v = (double )*((float *)(ptr + (ikptr )idx));
#line 230
  tmp___0 = double_to_flonum(v, pcb);
  }
#line 230
  return (tmp___0);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_set_double(ikptr p , ikptr off , ikptr v ) 
{ 
  long idx ;
  long tmp ;
  ikptr ptr ;

  {
  {
#line 236
  tmp = integer_to_long(off);
#line 236
  idx = tmp;
#line 237
  ptr = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 238
  *((double *)(ptr + (ikptr )idx)) = *((double *)((char *)((long )v) + 3));
  }
#line 239
  return ((ikptr )127);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_double(ikptr p , ikptr off , ikpcb *pcb ) 
{ 
  long idx ;
  long tmp ;
  ikptr ptr ;
  double v ;
  ikptr tmp___0 ;

  {
  {
#line 244
  tmp = integer_to_long(off);
#line 244
  idx = tmp;
#line 245
  ptr = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 246
  v = *((double *)(ptr + (ikptr )idx));
#line 247
  tmp___0 = double_to_flonum(v, pcb);
  }
#line 247
  return (tmp___0);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr s_to_number(long n , ikpcb *pcb ) 
{ 
  ikptr fx ;
  int tmp ;
  int tmp___0 ;
  ikptr bn ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;

  {
#line 257
  if ((int )sizeof(ikptr ) == 4) {
#line 257
    tmp = 2;
  } else {
#line 257
    tmp = 3;
  }
#line 257
  fx = (ikptr )(n << tmp);
#line 258
  if ((int )sizeof(ikptr ) == 4) {
#line 258
    tmp___0 = 2;
  } else {
#line 258
    tmp___0 = 3;
  }
#line 258
  if ((long )fx >> tmp___0 == n) {
#line 259
    return (fx);
  }
#line 261
  if ((int )sizeof(ikptr ) == 4) {
#line 261
    tmp___1 = 2;
  } else {
#line 261
    tmp___1 = 3;
  }
#line 261
  if ((int )sizeof(ikptr ) == 4) {
#line 261
    tmp___2 = 2;
  } else {
#line 261
    tmp___2 = 3;
  }
  {
#line 261
  tmp___3 = ik_safe_alloc(pcb, (((((int )sizeof(ikptr ) + (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___1 + 1)) << (tmp___2 + 1));
#line 261
  bn = tmp___3;
  }
#line 262
  if (n > 0L) {
#line 263
    *((ikptr *)((long )bn) + 0) = (ikptr )(3 | (1 << 4));
#line 264
    *((ikptr *)((long )bn + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )n;
  } else {
#line 266
    *((ikptr *)((long )bn) + 0) = (ikptr )((3 | (1 << 4)) | (1 << 3));
#line 270
    *((ikptr *)((long )bn + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )(- n);
  }
#line 272
  return (bn + 5UL);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr sll_to_number(long long n , ikpcb *pcb ) 
{ 
  ikptr tmp ;
  int len ;
  ikptr bn ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;

  {
#line 277
  if ((long long )((long )n) == n) {
    {
#line 278
    tmp = s_to_number((long )n, pcb);
    }
#line 278
    return (tmp);
  }
#line 280
  len = (int )(sizeof(long long ) / sizeof(mp_limb_t ));
#line 281
  if ((int )sizeof(ikptr ) == 4) {
#line 281
    tmp___0 = 2;
  } else {
#line 281
    tmp___0 = 3;
  }
#line 281
  if ((int )sizeof(ikptr ) == 4) {
#line 281
    tmp___1 = 2;
  } else {
#line 281
    tmp___1 = 3;
  }
  {
#line 281
  tmp___2 = ik_safe_alloc(pcb, (int )(((((sizeof(long long ) + (unsigned long )((int )sizeof(ikptr ))) + (unsigned long )(2 * (int )sizeof(ikptr ))) - 1UL) >> (tmp___0 + 1)) << (tmp___1 + 1)));
#line 281
  bn = tmp___2;
  }
#line 282
  if (n > 0LL) {
#line 283
    *((ikptr *)((long )bn) + 0) = (ikptr )(3 | (len << 4));
#line 284
    *((long long *)(bn + (ikptr )((int )sizeof(ikptr )))) = n;
  } else {
#line 286
    *((ikptr *)((long )bn) + 0) = (ikptr )((3 | (len << 4)) | (1 << 3));
#line 290
    *((long long *)(bn + (ikptr )((int )sizeof(ikptr )))) = - n;
  }
#line 292
  return (bn + 5UL);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr u_to_number(unsigned long n , ikpcb *pcb ) 
{ 
  unsigned long mxn ;
  int tmp ;
  int tmp___0 ;
  ikptr bn ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;

  {
#line 298
  if ((int )sizeof(ikptr ) == 4) {
#line 298
    tmp = 2;
  } else {
#line 298
    tmp = 3;
  }
#line 298
  mxn = 0xffffffffffffffffUL >> (tmp + 1);
#line 299
  if (n <= mxn) {
#line 300
    if ((int )sizeof(ikptr ) == 4) {
#line 300
      tmp___0 = 2;
    } else {
#line 300
      tmp___0 = 3;
    }
#line 300
    return ((ikptr )((long )n << tmp___0));
  }
#line 302
  if ((int )sizeof(ikptr ) == 4) {
#line 302
    tmp___1 = 2;
  } else {
#line 302
    tmp___1 = 3;
  }
#line 302
  if ((int )sizeof(ikptr ) == 4) {
#line 302
    tmp___2 = 2;
  } else {
#line 302
    tmp___2 = 3;
  }
  {
#line 302
  tmp___3 = ik_safe_alloc(pcb, (((((int )sizeof(ikptr ) + (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___1 + 1)) << (tmp___2 + 1));
#line 302
  bn = tmp___3;
#line 303
  *((ikptr *)((long )bn) + 0) = (ikptr )(3 | (1 << 4));
#line 304
  *((ikptr *)((long )bn + (long )((int )sizeof(ikptr ))) + 0) = n;
  }
#line 305
  return (bn + 5UL);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ull_to_number(unsigned long long n , ikpcb *pcb ) 
{ 
  ikptr tmp ;
  ikptr bn ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;

  {
#line 311
  if ((unsigned long long )((unsigned long )n) == n) {
    {
#line 312
    tmp = u_to_number((unsigned long )n, pcb);
    }
#line 312
    return (tmp);
  }
#line 314
  if ((int )sizeof(ikptr ) == 4) {
#line 314
    tmp___0 = 2;
  } else {
#line 314
    tmp___0 = 3;
  }
#line 314
  if ((int )sizeof(ikptr ) == 4) {
#line 314
    tmp___1 = 2;
  } else {
#line 314
    tmp___1 = 3;
  }
  {
#line 314
  tmp___2 = ik_safe_alloc(pcb, (int )((((((unsigned long )((int )sizeof(ikptr )) + sizeof(long long )) + (unsigned long )(2 * (int )sizeof(ikptr ))) - 1UL) >> (tmp___0 + 1)) << (tmp___1 + 1)));
#line 314
  bn = tmp___2;
#line 315
  bcopy((void const   *)((char *)(& n)), (void *)((char *)(bn + (ikptr )((int )sizeof(ikptr )))),
        sizeof(long long ));
#line 316
  tmp___3 = normalize_bignum((long )(sizeof(long long ) / sizeof(mp_limb_t )), 0,
                             bn);
  }
#line 316
  return (tmp___3);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr d_to_number(double n , ikpcb *pcb ) 
{ 
  ikptr x ;
  ikptr tmp ;

  {
  {
#line 321
  tmp = ik_safe_alloc(pcb, 16);
#line 321
  x = tmp + 5UL;
#line 322
  *((ikptr *)((long )x + -5L) + 0) = (ikptr )23;
#line 323
  *((double *)((char *)((long )x) + 3)) = n;
  }
#line 324
  return (x);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_int(ikptr p , ikptr off , ikpcb *pcb ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
#line 329
  if ((int )sizeof(ikptr ) == 4) {
#line 329
    tmp = 2;
  } else {
#line 329
    tmp = 3;
  }
#line 329
  r = *((int *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp)));
#line 331
  if ((int )sizeof(ikptr ) == 8) {
#line 332
    if ((int )sizeof(ikptr ) == 4) {
#line 332
      tmp___0 = 2;
    } else {
#line 332
      tmp___0 = 3;
    }
#line 332
    return ((ikptr )((long )r << tmp___0));
  } else {
    {
#line 334
    tmp___1 = s_to_number((long )r, pcb);
    }
#line 334
    return (tmp___1);
  }
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_uint(ikptr p , ikptr off , ikpcb *pcb ) 
{ 
  unsigned int r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
#line 340
  if ((int )sizeof(ikptr ) == 4) {
#line 340
    tmp = 2;
  } else {
#line 340
    tmp = 3;
  }
#line 340
  r = *((unsigned int *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp)));
#line 342
  if ((int )sizeof(ikptr ) == 8) {
#line 343
    if ((int )sizeof(ikptr ) == 4) {
#line 343
      tmp___0 = 2;
    } else {
#line 343
      tmp___0 = 3;
    }
#line 343
    return ((ikptr )((long )r << tmp___0));
  } else {
    {
#line 345
    tmp___1 = u_to_number((unsigned long )r, pcb);
    }
#line 345
    return (tmp___1);
  }
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_long(ikptr p , ikptr off , ikpcb *pcb ) 
{ 
  long r ;
  int tmp ;
  ikptr tmp___0 ;

  {
#line 351
  if ((int )sizeof(ikptr ) == 4) {
#line 351
    tmp = 2;
  } else {
#line 351
    tmp = 3;
  }
  {
#line 351
  r = *((long *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp)));
#line 353
  tmp___0 = s_to_number(r, pcb);
  }
#line 353
  return (tmp___0);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_ulong(ikptr p , ikptr off , ikpcb *pcb ) 
{ 
  unsigned long r ;
  int tmp ;
  ikptr tmp___0 ;

  {
#line 358
  if ((int )sizeof(ikptr ) == 4) {
#line 358
    tmp = 2;
  } else {
#line 358
    tmp = 3;
  }
  {
#line 358
  r = *((unsigned long *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp)));
#line 360
  tmp___0 = u_to_number(r, pcb);
  }
#line 360
  return (tmp___0);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_longlong(ikptr p , ikptr off , ikpcb *pcb ) 
{ 
  long long r ;
  int tmp ;
  ikptr tmp___0 ;

  {
#line 365
  if ((int )sizeof(ikptr ) == 4) {
#line 365
    tmp = 2;
  } else {
#line 365
    tmp = 3;
  }
  {
#line 365
  r = *((long long *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp)));
#line 367
  tmp___0 = sll_to_number(r, pcb);
  }
#line 367
  return (tmp___0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_ref_ulonglong(ikptr p , ikptr off , ikpcb *pcb ) 
{ 
  unsigned long long r ;
  int tmp ;
  ikptr tmp___0 ;

  {
#line 372
  if ((int )sizeof(ikptr ) == 4) {
#line 372
    tmp = 2;
  } else {
#line 372
    tmp = 3;
  }
  {
#line 372
  r = *((unsigned long long *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp)));
#line 374
  tmp___0 = ull_to_number(r, pcb);
  }
#line 374
  return (tmp___0);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
long extract_num(ikptr x ) 
{ 
  int tmp ;

  {
#line 379
  if ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 380
    if ((int )sizeof(ikptr ) == 4) {
#line 380
      tmp = 2;
    } else {
#line 380
      tmp = 3;
    }
#line 380
    return ((long )x >> tmp);
  } else
#line 381
  if (x == 127UL) {
#line 382
    return (0L);
  } else
#line 384
  if (*((ikptr *)((long )x + -5L) + 0) & 8UL) {
#line 385
    return ((long )(- *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0)));
  } else {
#line 387
    return ((long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0));
  }
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
long long extract_num_longlong(ikptr x ) 
{ 
  int tmp ;
  ikptr fst ;
  ikptr pos_one_limb_tag ;
  ikptr neg_one_limb_tag ;

  {
#line 394
  if ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 395
    if ((int )sizeof(ikptr ) == 4) {
#line 395
      tmp = 2;
    } else {
#line 395
      tmp = 3;
    }
#line 395
    return ((long long )((long )x >> tmp));
  } else
#line 396
  if (x == 127UL) {
#line 397
    return (0LL);
  } else {
#line 399
    fst = *((ikptr *)((long )x + -5L) + 0);
#line 400
    pos_one_limb_tag = (ikptr )(3 | (1 << 4));
#line 402
    neg_one_limb_tag = pos_one_limb_tag | (unsigned long )(1 << 3);
#line 404
    if (fst == pos_one_limb_tag) {
#line 405
      return ((long long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0));
    } else
#line 406
    if (fst == neg_one_limb_tag) {
#line 407
      return ((long long )(- ((long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0))));
    } else
#line 408
    if (fst & 8UL) {
#line 409
      return (- *((long long *)((x + (ikptr )((int )sizeof(ikptr ))) - 5UL)));
    } else {
#line 411
      return (*((long long *)((x + (ikptr )((int )sizeof(ikptr ))) - 5UL)));
    }
  }
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_set_char(ikptr p , ikptr off , ikptr v ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 420
  if ((int )sizeof(ikptr ) == 4) {
#line 420
    tmp = 2;
  } else {
#line 420
    tmp = 3;
  }
  {
#line 420
  tmp___0 = extract_num(v);
#line 420
  *((char *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp))) = (char )tmp___0;
  }
#line 422
  return ((ikptr )127);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_set_short(ikptr p , ikptr off , ikptr v ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 427
  if ((int )sizeof(ikptr ) == 4) {
#line 427
    tmp = 2;
  } else {
#line 427
    tmp = 3;
  }
  {
#line 427
  tmp___0 = extract_num(v);
#line 427
  *((short *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp))) = (short )tmp___0;
  }
#line 429
  return ((ikptr )127);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_set_int(ikptr p , ikptr off , ikptr v ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 434
  if ((int )sizeof(ikptr ) == 4) {
#line 434
    tmp = 2;
  } else {
#line 434
    tmp = 3;
  }
  {
#line 434
  tmp___0 = extract_num(v);
#line 434
  *((int *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp))) = (int )tmp___0;
  }
#line 436
  return ((ikptr )127);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_set_long(ikptr p , ikptr off , ikptr v ) 
{ 
  int tmp ;

  {
#line 441
  if ((int )sizeof(ikptr ) == 4) {
#line 441
    tmp = 2;
  } else {
#line 441
    tmp = 3;
  }
  {
#line 441
  *((long *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp))) = extract_num(v);
  }
#line 443
  return ((ikptr )127);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
ikptr ikrt_set_longlong(ikptr p , ikptr off , ikptr v ) 
{ 
  int tmp ;

  {
#line 448
  if ((int )sizeof(ikptr ) == 4) {
#line 448
    tmp = 2;
  } else {
#line 448
    tmp = 3;
  }
  {
#line 448
  *((long long *)((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0) + ((long )off >> tmp))) = extract_num_longlong(v);
  }
#line 450
  return ((ikptr )127);
}
}
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_close_fd(ikptr fd___1 ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
#line 37
  if ((int )sizeof(ikptr ) == 4) {
#line 37
    tmp = 2;
  } else {
#line 37
    tmp = 3;
  }
  {
#line 37
  tmp___0 = close((int )((long )fd___1 >> tmp));
#line 37
  err = tmp___0;
  }
#line 38
  if (err == -1) {
    {
#line 39
    tmp___1 = ik_errno_to_code();
    }
#line 39
    return (tmp___1);
  } else {
#line 41
    return ((ikptr )47);
  }
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_set_position(ikptr fd___1 , ikptr pos ) 
{ 
  off_t offset ;
  long long tmp ;
  off_t err ;
  int tmp___0 ;
  __off_t tmp___1 ;
  ikptr tmp___2 ;

  {
  {
#line 47
  tmp = extract_num_longlong(pos);
#line 47
  offset = (off_t )tmp;
  }
#line 48
  if ((int )sizeof(ikptr ) == 4) {
#line 48
    tmp___0 = 2;
  } else {
#line 48
    tmp___0 = 3;
  }
  {
#line 48
  tmp___1 = lseek((int )((long )fd___1 >> tmp___0), offset, 0);
#line 48
  err = tmp___1;
  }
#line 49
  if (err == -1L) {
    {
#line 50
    tmp___2 = ik_errno_to_code();
    }
#line 50
    return (tmp___2);
  } else {
#line 52
    return ((ikptr )47);
  }
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_open_input_fd(ikptr fn ) 
{ 
  int fh ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
  {
#line 59
  tmp = open((char const   *)((char *)((long )(fn + 6UL))), 0, 0);
#line 59
  fh = tmp;
  }
#line 60
  if (fh >= 0) {
#line 61
    if ((int )sizeof(ikptr ) == 4) {
#line 61
      tmp___0 = 2;
    } else {
#line 61
      tmp___0 = 3;
    }
#line 61
    return ((ikptr )((long )fh << tmp___0));
  } else {
    {
#line 63
    tmp___1 = ik_errno_to_code();
    }
#line 63
    return (tmp___1);
  }
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_open_output_fd(ikptr fn , ikptr ikopts ) 
{ 
  int opts ;
  int tmp ;
  int mode ;
  int fh ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;

  {
#line 69
  if ((int )sizeof(ikptr ) == 4) {
#line 69
    tmp = 2;
  } else {
#line 69
    tmp = 3;
  }
#line 69
  opts = (int )((long )ikopts >> tmp);
#line 70
  mode = 0;
  {
#line 73
  if (opts == 0) {
#line 73
    goto case_0;
  }
#line 75
  if (opts == 1) {
#line 75
    goto case_1;
  }
#line 77
  if (opts == 2) {
#line 77
    goto case_2;
  }
#line 79
  if (opts == 3) {
#line 79
    goto case_3;
  }
#line 80
  if (opts == 4) {
#line 80
    goto case_4;
  }
#line 81
  if (opts == 5) {
#line 81
    goto case_5;
  }
#line 82
  if (opts == 6) {
#line 82
    goto case_6;
  }
#line 83
  if (opts == 7) {
#line 83
    goto case_7;
  }
#line 71
  goto switch_break;
  case_0: /* CIL Label */ 
#line 73
  mode = 193;
#line 73
  goto switch_break;
  case_1: /* CIL Label */ 
#line 75
  mode = 513;
#line 75
  goto switch_break;
  case_2: /* CIL Label */ 
#line 77
  mode = 577;
#line 77
  goto switch_break;
  case_3: /* CIL Label */ 
#line 79
  mode = 513;
#line 79
  goto switch_break;
  case_4: /* CIL Label */ 
#line 80
  mode = 193;
#line 80
  goto switch_break;
  case_5: /* CIL Label */ 
#line 81
  mode = 65;
#line 81
  goto switch_break;
  case_6: /* CIL Label */ 
#line 82
  mode = 65;
#line 82
  goto switch_break;
  case_7: /* CIL Label */ 
#line 83
  mode = 1;
#line 83
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 85
  tmp___0 = open((char const   *)((char *)((long )(fn + 6UL))), mode, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
#line 85
  fh = tmp___0;
  }
#line 88
  if (fh >= 0) {
#line 89
    if ((int )sizeof(ikptr ) == 4) {
#line 89
      tmp___1 = 2;
    } else {
#line 89
      tmp___1 = 3;
    }
#line 89
    return ((ikptr )((long )fh << tmp___1));
  } else {
    {
#line 91
    tmp___2 = ik_errno_to_code();
    }
#line 91
    return (tmp___2);
  }
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_read_fd(ikptr fd___1 , ikptr bv , ikptr off , ikptr cnt ) 
{ 
  ssize_t bytes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;

  {
#line 101
  if ((int )sizeof(ikptr ) == 4) {
#line 101
    tmp = 2;
  } else {
#line 101
    tmp = 3;
  }
#line 101
  if ((int )sizeof(ikptr ) == 4) {
#line 101
    tmp___0 = 2;
  } else {
#line 101
    tmp___0 = 3;
  }
#line 101
  if ((int )sizeof(ikptr ) == 4) {
#line 101
    tmp___1 = 2;
  } else {
#line 101
    tmp___1 = 3;
  }
  {
#line 101
  tmp___2 = read((int )((long )fd___1 >> tmp___1), (void *)((char *)((long )((bv + 6UL) + (ikptr )((long )off >> tmp___0)))),
                 (size_t )((long )cnt >> tmp));
#line 101
  bytes = tmp___2;
  }
#line 108
  if (bytes >= 0L) {
#line 109
    if ((int )sizeof(ikptr ) == 4) {
#line 109
      tmp___3 = 2;
    } else {
#line 109
      tmp___3 = 3;
    }
#line 109
    return ((ikptr )(bytes << tmp___3));
  } else {
    {
#line 111
    tmp___4 = ik_errno_to_code();
    }
#line 111
    return (tmp___4);
  }
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_write_fd(ikptr fd___1 , ikptr bv , ikptr off , ikptr cnt ) 
{ 
  ssize_t bytes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;

  {
#line 133
  if ((int )sizeof(ikptr ) == 4) {
#line 133
    tmp = 2;
  } else {
#line 133
    tmp = 3;
  }
#line 133
  if ((int )sizeof(ikptr ) == 4) {
#line 133
    tmp___0 = 2;
  } else {
#line 133
    tmp___0 = 3;
  }
#line 133
  if ((int )sizeof(ikptr ) == 4) {
#line 133
    tmp___1 = 2;
  } else {
#line 133
    tmp___1 = 3;
  }
  {
#line 133
  tmp___2 = write((int )((long )fd___1 >> tmp___1), (void const   *)((char *)((long )((bv + 6UL) + (ikptr )((long )off >> tmp___0)))),
                  (size_t )((long )cnt >> tmp));
#line 133
  bytes = tmp___2;
  }
#line 137
  if (bytes >= 0L) {
#line 138
    if ((int )sizeof(ikptr ) == 4) {
#line 138
      tmp___3 = 2;
    } else {
#line 138
      tmp___3 = 3;
    }
#line 138
    return ((ikptr )(bytes << tmp___3));
  } else {
    {
#line 140
    tmp___4 = ik_errno_to_code();
    }
#line 140
    return (tmp___4);
  }
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
static ikptr do_connect(ikptr host , ikptr srvc , int socket_type ) 
{ 
  struct addrinfo *info ;
  int err ;
  int tmp ;
  ikptr tmp___0 ;
  struct addrinfo *i ;
  ikptr sock ;
  int s ;
  int tmp___1 ;
  int err___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 149
  tmp = getaddrinfo((char const   */* __restrict  */)((char *)((long )(host + 6UL))),
                    (char const   */* __restrict  */)((char *)((long )(srvc + 6UL))),
                    (struct addrinfo  const  */* __restrict  */)0, (struct addrinfo **/* __restrict  */)(& info));
#line 149
  err = tmp;
  }
#line 153
  if (err) {
    {
#line 155
    if (err == -11) {
#line 155
      goto case_neg_11;
    }
#line 156
    goto switch_default;
    case_neg_11: /* CIL Label */ 
    {
#line 155
    tmp___0 = ik_errno_to_code();
    }
#line 155
    return (tmp___0);
    switch_default: /* CIL Label */ 
#line 156
    return ((ikptr )47);
    switch_break: /* CIL Label */ ;
    }
  }
#line 159
  i = info;
#line 160
  sock = (ikptr )47;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! i) {
#line 161
      goto while_break;
    }
#line 162
    if (i->ai_socktype != socket_type) {
#line 163
      i = i->ai_next;
    } else {
      {
#line 165
      tmp___1 = socket(i->ai_family, i->ai_socktype, i->ai_protocol);
#line 165
      s = tmp___1;
      }
#line 166
      if (s < 0) {
        {
#line 167
        sock = ik_errno_to_code();
#line 168
        i = i->ai_next;
        }
      } else {
        {
#line 170
        tmp___2 = connect(s, (struct sockaddr  const  *)i->ai_addr, i->ai_addrlen);
#line 170
        err___0 = tmp___2;
        }
#line 171
        if (err___0 < 0) {
          {
#line 172
          sock = ik_errno_to_code();
#line 173
          i = i->ai_next;
          }
        } else {
#line 175
          if ((int )sizeof(ikptr ) == 4) {
#line 175
            tmp___3 = 2;
          } else {
#line 175
            tmp___3 = 3;
          }
#line 175
          sock = (ikptr )((long )s << tmp___3);
#line 176
          i = (struct addrinfo *)0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  freeaddrinfo(info);
  }
#line 182
  return (sock);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_tcp_connect(ikptr host , ikptr srvc ) 
{ 
  ikptr tmp ;

  {
  {
#line 187
  tmp = do_connect(host, srvc, 1);
  }
#line 187
  return (tmp);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_udp_connect(ikptr host , ikptr srvc ) 
{ 
  ikptr tmp ;

  {
  {
#line 192
  tmp = do_connect(host, srvc, 2);
  }
#line 192
  return (tmp);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_make_fd_nonblocking(ikptr fdptr ) 
{ 
  int fd___1 ;
  int tmp ;
  int err ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
#line 197
  if ((int )sizeof(ikptr ) == 4) {
#line 197
    tmp = 2;
  } else {
#line 197
    tmp = 3;
  }
  {
#line 197
  fd___1 = (int )((long )fdptr >> tmp);
#line 198
  tmp___0 = fcntl(fd___1, 4, 2048);
#line 198
  err = tmp___0;
  }
#line 199
  if (err == -1) {
    {
#line 200
    tmp___1 = ik_errno_to_code();
    }
#line 200
    return (tmp___1);
  }
#line 202
  return ((ikptr )0);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_select(ikptr fds , ikptr rfds , ikptr wfds , ikptr xfds ) 
{ 
  int rv ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  int tmp___2 ;

  {
#line 207
  if ((int )sizeof(ikptr ) == 4) {
#line 207
    tmp = 2;
  } else {
#line 207
    tmp = 3;
  }
  {
#line 207
  tmp___0 = select((int )((long )fds >> tmp), (fd_set */* __restrict  */)((fd_set *)(rfds + 6UL)),
                   (fd_set */* __restrict  */)((fd_set *)(wfds + 6UL)), (fd_set */* __restrict  */)((fd_set *)(xfds + 6UL)),
                   (struct timeval */* __restrict  */)((void *)0));
#line 207
  rv = tmp___0;
  }
#line 212
  if (rv < 0) {
    {
#line 213
    tmp___1 = ik_errno_to_code();
    }
#line 213
    return (tmp___1);
  }
#line 215
  if ((int )sizeof(ikptr ) == 4) {
#line 215
    tmp___2 = 2;
  } else {
#line 215
    tmp___2 = 3;
  }
#line 215
  return ((ikptr )((long )rv << tmp___2));
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_listen(ikptr port ) 
{ 
  int sock ;
  int tmp ;
  ikptr tmp___0 ;
  struct sockaddr_in servaddr ;
  int tmp___1 ;
  int err ;
  int reuse ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;
  ikptr tmp___4 ;
  int tmp___5 ;

  {
  {
#line 221
  tmp = socket(2, 1, 0);
#line 221
  sock = tmp;
  }
#line 222
  if (sock < 0) {
    {
#line 223
    tmp___0 = ik_errno_to_code();
    }
#line 223
    return (tmp___0);
  }
  {
#line 227
  memset((void *)(& servaddr), 0, sizeof(struct sockaddr_in ));
#line 228
  servaddr.sin_family = (sa_family_t )2;
#line 229
  servaddr.sin_addr.s_addr = htonl((in_addr_t )0);
  }
#line 230
  if ((int )sizeof(ikptr ) == 4) {
#line 230
    tmp___1 = 2;
  } else {
#line 230
    tmp___1 = 3;
  }
  {
#line 230
  servaddr.sin_port = htons((uint16_t )((long )port >> tmp___1));
#line 234
  reuse = 1;
#line 235
  err = setsockopt(sock, 1, 2, (void const   *)(& reuse), (socklen_t )sizeof(int ));
  }
#line 236
  if (err < 0) {
    {
#line 237
    tmp___2 = ik_errno_to_code();
    }
#line 237
    return (tmp___2);
  }
  {
#line 241
  err = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& servaddr)), (socklen_t )sizeof(servaddr));
  }
#line 242
  if (err < 0) {
    {
#line 243
    tmp___3 = ik_errno_to_code();
    }
#line 243
    return (tmp___3);
  }
  {
#line 246
  err = listen(sock, 1024);
  }
#line 247
  if (err < 0) {
    {
#line 248
    tmp___4 = ik_errno_to_code();
    }
#line 248
    return (tmp___4);
  }
#line 250
  if ((int )sizeof(ikptr ) == 4) {
#line 250
    tmp___5 = 2;
  } else {
#line 250
    tmp___5 = 3;
  }
#line 250
  return ((ikptr )((long )sock << tmp___5));
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_accept(ikptr s , ikptr bv ) 
{ 
  socklen_t addrlen ;
  int tmp ;
  int sock ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 276
  if ((int )sizeof(ikptr ) == 4) {
#line 276
    tmp = 2;
  } else {
#line 276
    tmp = 3;
  }
#line 276
  addrlen = (socklen_t )((long )*((ikptr *)((long )bv + -2L) + 0) >> tmp);
#line 277
  if ((int )sizeof(ikptr ) == 4) {
#line 277
    tmp___0 = 2;
  } else {
#line 277
    tmp___0 = 3;
  }
  {
#line 277
  tmp___1 = accept((int )((long )s >> tmp___0), (struct sockaddr */* __restrict  */)((struct sockaddr *)(bv + 6UL)),
                   (socklen_t */* __restrict  */)(& addrlen));
#line 277
  sock = tmp___1;
  }
#line 280
  if (sock < 0) {
    {
#line 281
    tmp___2 = ik_errno_to_code();
    }
#line 281
    return (tmp___2);
  }
#line 283
  if ((int )sizeof(ikptr ) == 4) {
#line 283
    tmp___3 = 2;
  } else {
#line 283
    tmp___3 = 3;
  }
#line 283
  *((ikptr *)((long )bv + -2L) + 0) = (ikptr )((long )addrlen << tmp___3);
#line 284
  if ((int )sizeof(ikptr ) == 4) {
#line 284
    tmp___4 = 2;
  } else {
#line 284
    tmp___4 = 3;
  }
#line 284
  return ((ikptr )((long )sock << tmp___4));
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_shutdown(ikptr s ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;

  {
#line 292
  if ((int )sizeof(ikptr ) == 4) {
#line 292
    tmp = 2;
  } else {
#line 292
    tmp = 3;
  }
  {
#line 292
  tmp___0 = shutdown((int )((long )s >> tmp), 2);
#line 292
  err = tmp___0;
  }
#line 294
  if (err < 0) {
    {
#line 295
    tmp___1 = ik_errno_to_code();
    }
#line 295
    return (tmp___1);
  }
#line 297
  return ((ikptr )0);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
static ikptr timespec_bytevector(struct timespec *s , ikpcb *pcb ) 
{ 
  int len ;
  ikptr r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  int tmp___2 ;

  {
#line 303
  len = (int )sizeof(struct timespec );
#line 304
  if ((int )sizeof(ikptr ) == 4) {
#line 304
    tmp = 2;
  } else {
#line 304
    tmp = 3;
  }
#line 304
  if ((int )sizeof(ikptr ) == 4) {
#line 304
    tmp___0 = 2;
  } else {
#line 304
    tmp___0 = 3;
  }
  {
#line 304
  tmp___1 = ik_safe_alloc(pcb, (((((8 + len) + 3) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp + 1)) << (tmp___0 + 1));
#line 304
  r = tmp___1;
  }
#line 305
  if ((int )sizeof(ikptr ) == 4) {
#line 305
    tmp___2 = 2;
  } else {
#line 305
    tmp___2 = 3;
  }
  {
#line 305
  *((ikptr *)((long )r) + 0) = (ikptr )((long )(len + 2) << tmp___2);
#line 306
  *((char *)(r + 8UL)) = (char )sizeof(s->tv_sec);
#line 307
  *((char *)((r + 8UL) + 1UL)) = (char )sizeof(s->tv_nsec);
#line 308
  memcpy((void */* __restrict  */)((char *)((r + 8UL) + 2UL)), (void const   */* __restrict  */)s,
         (size_t )len);
#line 309
  *((char *)(((r + 8UL) + (ikptr )len) + 2UL)) = (char)0;
  }
#line 310
  return (r + 2UL);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_file_ctime2(ikptr filename , ikpcb *pcb ) 
{ 
  struct stat s ;
  int err ;
  int tmp ;
  ikptr tmp___0 ;
  ikptr tmp___1 ;

  {
  {
#line 317
  tmp = stat((char const   */* __restrict  */)((char *)(filename + 6UL)), (struct stat */* __restrict  */)(& s));
#line 317
  err = tmp;
  }
#line 318
  if (err) {
    {
#line 319
    tmp___0 = ik_errno_to_code();
    }
#line 319
    return (tmp___0);
  }
  {
#line 324
  tmp___1 = timespec_bytevector(& s.st_ctim, pcb);
  }
#line 324
  return (tmp___1);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_file_mtime2(ikptr filename , ikpcb *pcb ) 
{ 
  struct stat s ;
  int err ;
  int tmp ;
  ikptr tmp___0 ;
  ikptr tmp___1 ;

  {
  {
#line 336
  tmp = stat((char const   */* __restrict  */)((char *)(filename + 6UL)), (struct stat */* __restrict  */)(& s));
#line 336
  err = tmp;
  }
#line 337
  if (err) {
    {
#line 338
    tmp___0 = ik_errno_to_code();
    }
#line 338
    return (tmp___0);
  }
  {
#line 343
  tmp___1 = timespec_bytevector(& s.st_mtim, pcb);
  }
#line 343
  return (tmp___1);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_file_ctime(ikptr filename , ikptr res ) 
{ 
  struct stat s ;
  int err ;
  int tmp ;
  ikptr tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 358
  tmp = stat((char const   */* __restrict  */)((char *)(filename + 6UL)), (struct stat */* __restrict  */)(& s));
#line 358
  err = tmp;
  }
#line 359
  if (err) {
    {
#line 360
    tmp___0 = ik_errno_to_code();
    }
#line 360
    return (tmp___0);
  }
#line 363
  if ((int )sizeof(ikptr ) == 4) {
#line 363
    tmp___1 = 2;
  } else {
#line 363
    tmp___1 = 3;
  }
#line 363
  *((ikptr *)((long )res + -1L) + 0) = (ikptr )(s.st_ctim.tv_sec << tmp___1);
#line 364
  *((ikptr *)((long )res + (long )((int )sizeof(ikptr ) - 1)) + 0) = (ikptr )0;
#line 365
  if ((int )sizeof(ikptr ) == 4) {
#line 365
    tmp___2 = 2;
  } else {
#line 365
    tmp___2 = 3;
  }
#line 365
  return ((ikptr )0L);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_file_mtime(ikptr filename , ikptr res ) 
{ 
  struct stat s ;
  int err ;
  int tmp ;
  ikptr tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 371
  tmp = stat((char const   */* __restrict  */)((char *)(filename + 6UL)), (struct stat */* __restrict  */)(& s));
#line 371
  err = tmp;
  }
#line 372
  if (err) {
    {
#line 373
    tmp___0 = ik_errno_to_code();
    }
#line 373
    return (tmp___0);
  }
#line 376
  if ((int )sizeof(ikptr ) == 4) {
#line 376
    tmp___1 = 2;
  } else {
#line 376
    tmp___1 = 3;
  }
#line 376
  *((ikptr *)((long )res + -1L) + 0) = (ikptr )(s.st_mtim.tv_sec << tmp___1);
#line 377
  *((ikptr *)((long )res + (long )((int )sizeof(ikptr ) - 1)) + 0) = (ikptr )0;
#line 378
  if ((int )sizeof(ikptr ) == 4) {
#line 378
    tmp___2 = 2;
  } else {
#line 378
    tmp___2 = 3;
  }
#line 378
  return ((ikptr )0L);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_opendir(ikptr dirname , ikpcb *pcb ) 
{ 
  DIR *d ;
  DIR *tmp ;
  ikptr tmp___0 ;
  ikptr tmp___1 ;

  {
  {
#line 384
  tmp = opendir((char const   *)((char *)(dirname + 6UL)));
#line 384
  d = tmp;
  }
#line 385
  if ((unsigned long )d == (unsigned long )((void *)0)) {
    {
#line 386
    tmp___0 = ik_errno_to_code();
    }
#line 386
    return (tmp___0);
  }
  {
#line 388
  tmp___1 = make_pointer((long )d, pcb);
  }
#line 388
  return (tmp___1);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_readdir(ikptr ptr , ikpcb *pcb ) 
{ 
  DIR *d ;
  int *tmp ;
  struct dirent *ent ;
  struct dirent *tmp___0 ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;
  int *tmp___4 ;
  int len ;
  size_t tmp___5 ;
  ikptr bv ;
  int tmp___6 ;
  int tmp___7 ;
  ikptr tmp___8 ;
  int tmp___9 ;

  {
  {
#line 393
  d = (DIR *)*((ikptr *)((long )ptr + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 394
  tmp = __errno_location();
#line 394
  *tmp = 0;
#line 395
  tmp___0 = readdir(d);
#line 395
  ent = tmp___0;
  }
#line 396
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    {
#line 397
    tmp___4 = __errno_location();
    }
#line 397
    if (*tmp___4) {
      {
#line 397
      tmp___2 = ik_errno_to_code();
#line 397
      tmp___3 = tmp___2;
      }
    } else {
#line 397
      tmp___3 = (ikptr )47;
    }
#line 397
    return (tmp___3);
  }
  {
#line 399
  tmp___5 = strlen((char const   *)(ent->d_name));
#line 399
  len = (int )tmp___5;
  }
#line 400
  if ((int )sizeof(ikptr ) == 4) {
#line 400
    tmp___6 = 2;
  } else {
#line 400
    tmp___6 = 3;
  }
#line 400
  if ((int )sizeof(ikptr ) == 4) {
#line 400
    tmp___7 = 2;
  } else {
#line 400
    tmp___7 = 3;
  }
  {
#line 400
  tmp___8 = ik_safe_alloc(pcb, (((((8 + len) + 1) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___6 + 1)) << (tmp___7 + 1));
#line 400
  bv = tmp___8 + 2UL;
  }
#line 402
  if ((int )sizeof(ikptr ) == 4) {
#line 402
    tmp___9 = 2;
  } else {
#line 402
    tmp___9 = 3;
  }
  {
#line 402
  *((ikptr *)((long )bv + -2L) + 0) = (ikptr )((long )len << tmp___9);
#line 403
  memcpy((void */* __restrict  */)((char *)(bv + 6UL)), (void const   */* __restrict  */)(ent->d_name),
         (size_t )(len + 1));
  }
#line 404
  return (bv);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
ikptr ikrt_closedir(ikptr ptr , ikpcb *pcb ) 
{ 
  DIR *d ;
  int rv ;
  int tmp ;
  ikptr tmp___0 ;

  {
  {
#line 409
  d = (DIR *)*((ikptr *)((long )ptr + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 410
  tmp = closedir(d);
#line 410
  rv = tmp;
  }
#line 411
  if (rv == -1) {
    {
#line 412
    tmp___0 = ik_errno_to_code();
    }
#line 412
    return (tmp___0);
  }
#line 414
  return ((ikptr )0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 192 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-data.h"
void ik_fasl_load(ikpcb *pcb , char *fasl_file ) ;
#line 196
void ik_print(ikptr x ) ;
#line 199
ikptr ikrt_string_to_symbol(ikptr str , ikpcb *pcb ) ;
#line 200
ikptr ikrt_strings_to_gensym(ikptr str , ikptr ustr , ikpcb *pcb ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static ikptr ik_fasl_read(ikpcb *pcb , fasl_port *p ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
void ik_fasl_load(ikpcb *pcb , char *fasl_file ) 
{ 
  int fd___1 ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int filesize ;
  struct stat buf ;
  int err ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int mapsize ;
  char *mem ;
  void *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  fasl_port p ;
  ikptr v ;
  ikptr tmp___8 ;
  int err___0 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  ikptr val ;
  ikptr tmp___12 ;

  {
  {
#line 54
  tmp = open((char const   *)fasl_file, 0);
#line 54
  fd___1 = tmp;
  }
#line 55
  if (fd___1 == -1) {
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    tmp___1 = strerror(*tmp___0);
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ikarus: failed to open boot file \"%s\": %s\n",
            fasl_file, tmp___1);
#line 60
    ikarus_usage_short();
#line 61
    exit(-1);
    }
  }
  {
#line 66
  tmp___2 = fstat(fd___1, & buf);
#line 66
  err = tmp___2;
  }
#line 67
  if (err != 0) {
    {
#line 68
    tmp___3 = __errno_location();
#line 68
    tmp___4 = strerror(*tmp___3);
#line 68
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ikarus: failed to stat \"%s\": %s\n",
            fasl_file, tmp___4);
#line 72
    exit(-1);
    }
  }
  {
#line 74
  filesize = (int )buf.st_size;
#line 76
  mapsize = (((filesize + 4096) - 1) / 4096) * 4096;
#line 77
  tmp___5 = mmap((void *)0, (size_t )mapsize, 1, 2, fd___1, (__off_t )0);
#line 77
  mem = (char *)tmp___5;
  }
#line 84
  if ((unsigned long )mem == (unsigned long )((void *)-1)) {
    {
#line 85
    tmp___6 = __errno_location();
#line 85
    tmp___7 = strerror(*tmp___6);
#line 85
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ikarus: mapping failed for %s: %s\n",
            fasl_file, tmp___7);
#line 89
    exit(-1);
    }
  }
#line 92
  p.membase = mem;
#line 93
  p.memp = mem;
#line 94
  p.memq = mem + filesize;
#line 95
  p.marks = (ikptr *)0;
#line 96
  p.marks_size = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! ((unsigned long )p.memp < (unsigned long )p.memq)) {
#line 97
      goto while_break;
    }
    {
#line 98
    p.code_ap = (ikptr )0;
#line 99
    p.code_ep = (ikptr )0;
#line 100
    tmp___8 = ik_fasl_read(pcb, & p);
#line 100
    v = tmp___8;
    }
#line 101
    if (p.marks_size) {
      {
#line 102
      ik_munmap((ikptr )((long )p.marks), (unsigned long )p.marks_size * sizeof(ikptr *));
#line 103
      p.marks = (ikptr *)0;
#line 104
      p.marks_size = 0;
      }
    }
#line 106
    if ((unsigned long )p.memp == (unsigned long )p.memq) {
      {
#line 107
      tmp___9 = munmap((void *)mem, (size_t )mapsize);
#line 107
      err___0 = tmp___9;
      }
#line 108
      if (err___0 != 0) {
        {
#line 109
        tmp___10 = __errno_location();
#line 109
        tmp___11 = strerror(*tmp___10);
#line 109
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to unmap fasl file: %s\n",
                tmp___11);
#line 110
        exit(-1);
        }
      }
      {
#line 112
      close(fd___1);
      }
    }
    {
#line 114
    tmp___12 = ik_exec_code(pcb, v, (ikptr )0, (ikptr )0);
#line 114
    val = tmp___12;
    }
#line 115
    if (val != 127UL) {
      {
#line 116
      ik_print(val);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if ((unsigned long )p.memp != (unsigned long )p.memq) {
    {
#line 120
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fasl-read did not reach eof!\n");
#line 121
    exit(-10);
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static ikptr alloc_code(long size , ikpcb *pcb , fasl_port *p ) 
{ 
  long asize ;
  int tmp ;
  int tmp___0 ;
  ikptr ap ;
  ikptr nap ;
  ikptr mem ;
  ikptr tmp___1 ;
  long bytes_remaining ;
  long previous_bytes ;
  long asize___0 ;
  ikptr mem___0 ;
  ikptr tmp___2 ;

  {
#line 127
  if ((int )sizeof(ikptr ) == 4) {
#line 127
    tmp = 2;
  } else {
#line 127
    tmp = 3;
  }
#line 127
  if ((int )sizeof(ikptr ) == 4) {
#line 127
    tmp___0 = 2;
  } else {
#line 127
    tmp___0 = 3;
  }
#line 127
  asize = (((size + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp + 1)) << (tmp___0 + 1);
#line 128
  ap = p->code_ap;
#line 129
  nap = ap + (ikptr )asize;
#line 130
  if (nap <= p->code_ep) {
#line 131
    p->code_ap = nap;
#line 132
    return (ap);
  } else
#line 133
  if (asize < 4096L) {
    {
#line 134
    tmp___1 = ik_mmap_code(4096UL, 0, pcb);
#line 134
    mem = tmp___1;
#line 135
    bytes_remaining = 4096L - asize;
#line 136
    previous_bytes = (long )(p->code_ep - ap);
    }
#line 138
    if (bytes_remaining <= previous_bytes) {
#line 139
      return (mem);
    } else {
#line 141
      p->code_ap = mem + (ikptr )asize;
#line 142
      p->code_ep = mem + 4096UL;
#line 143
      return (mem);
    }
  } else {
    {
#line 146
    asize___0 = (long )(((4095UL + (unsigned long )size) >> 12) << 12);
#line 147
    tmp___2 = ik_mmap_code((unsigned long )asize___0, 0, pcb);
#line 147
    mem___0 = tmp___2;
    }
#line 148
    return (mem___0);
  }
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
void ik_relocate_code(ikptr code ) 
{ 
  ikptr vec ;
  ikptr size ;
  ikptr data ;
  ikptr p ;
  ikptr q ;
  long r ;
  int tmp ;
  long tag ;
  long code_off ;
  long obj_off ;
  int tmp___0 ;
  ikptr obj ;
  long obj_off___0 ;
  int tmp___1 ;
  long obj___0 ;
  long displaced_object ;
  long next_word ;
  long relative_distance ;
  ikptr str ;
  char *name ;
  void *sym ;
  void *tmp___2 ;
  char *err ;
  char *tmp___3 ;

  {
#line 155
  vec = *((ikptr *)((long )code + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 156
  size = *((ikptr *)((long )vec + -5L) + 0);
#line 157
  data = code + (ikptr )(6 * (int )sizeof(ikptr ));
#line 158
  p = vec + (ikptr )((int )sizeof(ikptr ) - 5);
#line 159
  q = p + size;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (p < q)) {
#line 160
      goto while_break;
    }
#line 161
    if ((int )sizeof(ikptr ) == 4) {
#line 161
      tmp = 2;
    } else {
#line 161
      tmp = 3;
    }
#line 161
    r = (long )*((ikptr *)((long )p) + 0) >> tmp;
#line 162
    if (r == 0L) {
      {
#line 163
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unset reloc!\n");
#line 164
      exit(-1);
      }
    }
#line 166
    tag = r & 3L;
#line 167
    code_off = r >> 2;
#line 168
    if (tag == 0L) {
#line 170
      *((ikptr *)((long )data + code_off) + 0) = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0);
#line 171
      p += (ikptr )(2 * (int )sizeof(ikptr ));
    } else
#line 173
    if (tag == 2L) {
#line 175
      if ((int )sizeof(ikptr ) == 4) {
#line 175
        tmp___0 = 2;
      } else {
#line 175
        tmp___0 = 3;
      }
#line 175
      obj_off = (long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp___0;
#line 176
      obj = *((ikptr *)((long )p + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 177
      *((ikptr *)((long )data + code_off) + 0) = obj + (ikptr )obj_off;
#line 178
      p += (ikptr )(3 * (int )sizeof(ikptr ));
    } else
#line 180
    if (tag == 3L) {
#line 182
      if ((int )sizeof(ikptr ) == 4) {
#line 182
        tmp___1 = 2;
      } else {
#line 182
        tmp___1 = 3;
      }
#line 182
      obj_off___0 = (long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp___1;
#line 183
      obj___0 = (long )*((ikptr *)((long )p + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 184
      displaced_object = obj___0 + obj_off___0;
#line 185
      next_word = (long )((data + (ikptr )code_off) + 4UL);
#line 186
      relative_distance = displaced_object - next_word;
#line 192
      *((int *)(data + (ikptr )code_off)) = (int )relative_distance;
#line 194
      p += (ikptr )(3 * (int )sizeof(ikptr ));
    } else
#line 196
    if (tag == 1L) {
#line 198
      str = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0);
#line 200
      if (((int )str & 7) == 2) {
#line 201
        name = (char *)((long )str) + 6;
      } else {
        {
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"foreign name is not a bytevector\n");
#line 204
        exit(-1);
        }
      }
      {
#line 206
      dlerror();
#line 207
      tmp___2 = dlsym((void */* __restrict  */)0, (char const   */* __restrict  */)name);
#line 207
      sym = tmp___2;
#line 208
      tmp___3 = dlerror();
#line 208
      err = tmp___3;
      }
#line 209
      if (err) {
        {
#line 210
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to find foreign name %s: %s\n",
                name, err);
#line 211
        exit(-1);
        }
      }
#line 213
      *((ikptr *)((long )data + code_off) + 0) = (ikptr )sym;
#line 214
      p += (ikptr )(2 * (int )sizeof(ikptr ));
    } else {
      {
#line 217
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid reloc 0x%016lx (tag=%ld)\n",
              r, tag);
#line 218
      exit(-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static char fasl_read_byte(fasl_port *p ) 
{ 
  char c ;

  {
#line 225
  if ((unsigned long )p->memp < (unsigned long )p->memq) {
#line 226
    c = *(p->memp);
#line 227
    (p->memp) ++;
#line 228
    return (c);
  } else {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fasl_read_byte: read beyond eof\n");
#line 231
    exit(-1);
    }
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static void fasl_read_buf(fasl_port *p , void *buf , int n ) 
{ 


  {
#line 236
  if ((unsigned long )(p->memp + n) <= (unsigned long )p->memq) {
    {
#line 237
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)p->memp,
           (size_t )n);
#line 238
    p->memp += n;
    }
  } else {
    {
#line 240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fasl_read_buf: read beyond eof\n");
#line 241
    exit(-1);
    }
  }
#line 243
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static ikptr do_read(ikpcb *pcb , fasl_port *p ) 
{ 
  char c ;
  char tmp ;
  int put_mark_index ;
  int idx ;
  ikptr tmp___0 ;
  long code_size ;
  ikptr freevars ;
  ikptr annotation ;
  ikptr tmp___1 ;
  ikptr code ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  int tmp___5 ;
  ikptr pair ;
  ikptr tmp___6 ;
  ikptr str ;
  ikptr tmp___7 ;
  ikptr sym ;
  ikptr tmp___8 ;
  long len ;
  long size ;
  int tmp___9 ;
  int tmp___10 ;
  ikptr str___0 ;
  ikptr tmp___11 ;
  int tmp___12 ;
  unsigned char *pi ;
  ikchar *pj ;
  long i ;
  long len___0 ;
  long size___0 ;
  int tmp___13 ;
  int tmp___14 ;
  ikptr str___1 ;
  ikptr tmp___15 ;
  int tmp___16 ;
  long i___0 ;
  ikchar c___0 ;
  long len___1 ;
  long size___1 ;
  int tmp___17 ;
  int tmp___18 ;
  ikptr vec ;
  ikptr tmp___19 ;
  int tmp___20 ;
  long i___1 ;
  ikptr fixn ;
  unsigned char x ;
  char tmp___21 ;
  ikptr pretty ;
  ikptr tmp___22 ;
  ikptr unique ;
  ikptr tmp___23 ;
  ikptr sym___0 ;
  ikptr tmp___24 ;
  ikptr name ;
  ikptr tmp___25 ;
  ikptr symb ;
  ikptr tmp___26 ;
  long i___2 ;
  long n ;
  ikptr fields ;
  int tmp___27 ;
  int tmp___28 ;
  ikptr tmp___29 ;
  ikptr ptr ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  ikptr gensym_val ;
  ikptr rtd ;
  int tmp___34 ;
  int tmp___35 ;
  ikptr tmp___36 ;
  ikptr base_rtd ;
  int tmp___37 ;
  ikptr proc ;
  int tmp___38 ;
  int tmp___39 ;
  ikptr tmp___40 ;
  ikptr code___0 ;
  ikptr tmp___41 ;
  int idx___0 ;
  ikptr obj ;
  long len___2 ;
  long size___2 ;
  int tmp___42 ;
  int tmp___43 ;
  ikptr x___0 ;
  ikptr tmp___44 ;
  int tmp___45 ;
  int len___3 ;
  char tmp___46 ;
  ikptr pair___0 ;
  ikptr tmp___47 ;
  int i___3 ;
  ikptr pt ;
  long len___4 ;
  ikptr pair___1 ;
  ikptr tmp___48 ;
  long i___4 ;
  ikptr pt___0 ;
  ikptr x___1 ;
  ikptr tmp___49 ;
  int n___0 ;
  long len___5 ;
  long sign ;
  unsigned long tag ;
  ikptr x___2 ;
  int tmp___50 ;
  int tmp___51 ;
  ikptr tmp___52 ;
  ikptr real ;
  ikptr tmp___53 ;
  ikptr imag ;
  ikptr tmp___54 ;
  ikptr x___3 ;

  {
  {
#line 253
  tmp = fasl_read_byte(p);
#line 253
  c = tmp;
#line 254
  put_mark_index = 0;
  }
#line 255
  if ((int )c == 62) {
    {
#line 256
    idx = 0;
#line 257
    fasl_read_buf(p, (void *)(& idx), (int )sizeof(int ));
#line 258
    put_mark_index = idx;
#line 259
    c = fasl_read_byte(p);
    }
#line 260
    if (idx <= 0) {
      {
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fasl_read: invalid index %d\n",
              idx);
#line 262
      exit(-1);
      }
    }
#line 264
    if (p->marks) {
#line 265
      if (idx >= p->marks_size) {
        {
#line 266
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: mark too big: %d\n",
                idx);
#line 267
        exit(-1);
        }
      }
#line 269
      if (idx < p->marks_size) {
#line 270
        if (*(p->marks + idx) != 0UL) {
          {
#line 271
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mark %d already set\n",
                  idx);
#line 272
          ik_print(*(p->marks + idx));
#line 273
          exit(-1);
          }
        }
      }
    } else {
      {
#line 279
      tmp___0 = ik_mmap(8192UL * sizeof(ikptr *));
#line 279
      p->marks = (ikptr *)((long )tmp___0);
#line 280
      bzero((void *)p->marks, 8192UL * sizeof(ikptr *));
#line 281
      p->marks_size = 8192;
      }
    }
  }
#line 284
  if ((int )c == 120) {
    {
#line 287
    fasl_read_buf(p, (void *)(& code_size), (int )sizeof(long ));
#line 288
    fasl_read_buf(p, (void *)(& freevars), (int )sizeof(ikptr ));
#line 289
    tmp___1 = do_read(pcb, p);
#line 289
    annotation = tmp___1;
    }
#line 290
    if ((int )sizeof(ikptr ) == 4) {
#line 290
      tmp___2 = 2;
    } else {
#line 290
      tmp___2 = 3;
    }
#line 290
    if ((int )sizeof(ikptr ) == 4) {
#line 290
      tmp___3 = 2;
    } else {
#line 290
      tmp___3 = 3;
    }
    {
#line 290
    tmp___4 = alloc_code(((((code_size + (long )(6 * (int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___2 + 1)) << (tmp___3 + 1),
                         pcb, p);
#line 290
    code = tmp___4;
#line 291
    *((ikptr *)((long )code) + 0) = (ikptr )47;
    }
#line 292
    if ((int )sizeof(ikptr ) == 4) {
#line 292
      tmp___5 = 2;
    } else {
#line 292
      tmp___5 = 3;
    }
    {
#line 292
    *((ikptr *)((long )code + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )(code_size << tmp___5);
#line 293
    *((ikptr *)((long )code + (long )(3 * (int )sizeof(ikptr ))) + 0) = freevars;
#line 294
    *((ikptr *)((long )code + (long )(4 * (int )sizeof(ikptr ))) + 0) = annotation;
#line 295
    fasl_read_buf(p, (void *)((long )(6 * (int )sizeof(ikptr )) + (long )code), (int )code_size);
    }
#line 296
    if (put_mark_index) {
#line 297
      *(p->marks + put_mark_index) = code + 5UL;
    }
    {
#line 299
    *((ikptr *)((long )code + (long )(2 * (int )sizeof(ikptr ))) + 0) = do_read(pcb,
                                                                                p);
#line 300
    ik_relocate_code(code);
    }
#line 301
    return (code + 5UL);
  } else
#line 303
  if ((int )c == 80) {
    {
#line 304
    tmp___6 = ik_unsafe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 304
    pair = tmp___6 + 1UL;
    }
#line 305
    if (put_mark_index) {
#line 306
      *(p->marks + put_mark_index) = pair;
    }
    {
#line 308
    *((ikptr *)((long )pair + -1L) + 0) = do_read(pcb, p);
#line 309
    *((ikptr *)((long )pair + (long )((int )sizeof(ikptr ) - 1)) + 0) = do_read(pcb,
                                                                                p);
    }
#line 310
    return (pair);
  } else
#line 312
  if ((int )c == 77) {
    {
#line 314
    tmp___7 = do_read(pcb, p);
#line 314
    str = tmp___7;
#line 315
    tmp___8 = ikrt_string_to_symbol(str, pcb);
#line 315
    sym = tmp___8;
    }
#line 316
    if (put_mark_index) {
#line 317
      *(p->marks + put_mark_index) = sym;
    }
#line 319
    return (sym);
  } else
#line 321
  if ((int )c == 115) {
    {
#line 324
    fasl_read_buf(p, (void *)(& len), (int )sizeof(long ));
    }
#line 325
    if ((int )sizeof(ikptr ) == 4) {
#line 325
      tmp___9 = 2;
    } else {
#line 325
      tmp___9 = 3;
    }
#line 325
    if ((int )sizeof(ikptr ) == 4) {
#line 325
      tmp___10 = 2;
    } else {
#line 325
      tmp___10 = 3;
    }
    {
#line 325
    size = ((((len * 4L + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___9 + 1)) << (tmp___10 + 1);
#line 326
    tmp___11 = ik_unsafe_alloc(pcb, (int )size);
#line 326
    str___0 = tmp___11 + 6UL;
    }
#line 327
    if ((int )sizeof(ikptr ) == 4) {
#line 327
      tmp___12 = 2;
    } else {
#line 327
      tmp___12 = 3;
    }
    {
#line 327
    *((ikptr *)((long )str___0 + -6L) + 0) = (ikptr )(len << tmp___12);
#line 328
    fasl_read_buf(p, (void *)((char *)((long )str___0) + ((int )sizeof(ikptr ) - 6)),
                  (int )len);
#line 330
    pi = (unsigned char *)((long )(str___0 + (ikptr )((int )sizeof(ikptr ) - 6)));
#line 331
    pj = (ikchar *)((long )(str___0 + (ikptr )((int )sizeof(ikptr ) - 6)));
#line 332
    i = len - 1L;
#line 333
    i = len - 1L;
    }
    {
#line 333
    while (1) {
      while_continue: /* CIL Label */ ;
#line 333
      if (! (i >= 0L)) {
#line 333
        goto while_break;
      }
#line 334
      *(pj + i) = ((int )*(pi + i) << 8) + 15;
#line 333
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 338
    if (put_mark_index) {
#line 339
      *(p->marks + put_mark_index) = str___0;
    }
#line 341
    return (str___0);
  } else
#line 343
  if ((int )c == 83) {
    {
#line 346
    fasl_read_buf(p, (void *)(& len___0), (int )sizeof(long ));
    }
#line 347
    if ((int )sizeof(ikptr ) == 4) {
#line 347
      tmp___13 = 2;
    } else {
#line 347
      tmp___13 = 3;
    }
#line 347
    if ((int )sizeof(ikptr ) == 4) {
#line 347
      tmp___14 = 2;
    } else {
#line 347
      tmp___14 = 3;
    }
    {
#line 347
    size___0 = ((((len___0 * 4L + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___13 + 1)) << (tmp___14 + 1);
#line 348
    tmp___15 = ik_unsafe_alloc(pcb, (int )size___0);
#line 348
    str___1 = tmp___15 + 6UL;
    }
#line 349
    if ((int )sizeof(ikptr ) == 4) {
#line 349
      tmp___16 = 2;
    } else {
#line 349
      tmp___16 = 3;
    }
#line 349
    *((ikptr *)((long )str___1 + -6L) + 0) = (ikptr )(len___0 << tmp___16);
#line 351
    i___0 = 0L;
    {
#line 351
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 351
      if (! (i___0 < len___0)) {
#line 351
        goto while_break___0;
      }
      {
#line 353
      fasl_read_buf(p, (void *)(& c___0), (int )sizeof(ikchar ));
#line 354
      *((ikchar *)((long )str___1 + (long )((int )sizeof(ikptr ) - 6)) + i___0) = (c___0 << 8) + 15;
#line 351
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 357
    if (put_mark_index) {
#line 358
      *(p->marks + put_mark_index) = str___1;
    }
#line 360
    return (str___1);
  } else
#line 362
  if ((int )c == 86) {
    {
#line 364
    fasl_read_buf(p, (void *)(& len___1), (int )sizeof(long ));
    }
#line 365
    if ((int )sizeof(ikptr ) == 4) {
#line 365
      tmp___17 = 2;
    } else {
#line 365
      tmp___17 = 3;
    }
#line 365
    if ((int )sizeof(ikptr ) == 4) {
#line 365
      tmp___18 = 2;
    } else {
#line 365
      tmp___18 = 3;
    }
    {
#line 365
    size___1 = ((((len___1 * (long )((int )sizeof(ikptr )) + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___17 + 1)) << (tmp___18 + 1);
#line 366
    tmp___19 = ik_unsafe_alloc(pcb, (int )size___1);
#line 366
    vec = tmp___19 + 5UL;
    }
#line 367
    if (put_mark_index) {
#line 368
      *(p->marks + put_mark_index) = vec;
    }
#line 370
    if ((int )sizeof(ikptr ) == 4) {
#line 370
      tmp___20 = 2;
    } else {
#line 370
      tmp___20 = 3;
    }
#line 370
    *((ikptr *)((long )vec + -5L) + 0) = (ikptr )(len___1 << tmp___20);
#line 372
    i___1 = 0L;
    {
#line 372
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 372
      if (! (i___1 < len___1)) {
#line 372
        goto while_break___1;
      }
      {
#line 373
      *((ikptr *)((long )vec + ((long )((int )sizeof(ikptr ) - 5) + i___1 * (long )((int )sizeof(ikptr )))) + 0) = do_read(pcb,
                                                                                                                           p);
#line 372
      i___1 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 375
    return (vec);
  } else
#line 377
  if ((int )c == 73) {
    {
#line 379
    fasl_read_buf(p, (void *)(& fixn), (int )sizeof(ikptr ));
    }
#line 380
    return (fixn);
  } else
#line 382
  if ((int )c == 70) {
#line 383
    return ((ikptr )47);
  } else
#line 385
  if ((int )c == 84) {
#line 386
    return ((ikptr )63);
  } else
#line 388
  if ((int )c == 78) {
#line 389
    return ((ikptr )79);
  } else
#line 391
  if ((int )c == 99) {
    {
#line 393
    tmp___21 = fasl_read_byte(p);
#line 393
    x = (unsigned char )tmp___21;
    }
#line 394
    return (((unsigned long )x << 8) | 15UL);
  } else
#line 396
  if ((int )c == 71) {
    {
#line 398
    tmp___22 = do_read(pcb, p);
#line 398
    pretty = tmp___22;
#line 399
    tmp___23 = do_read(pcb, p);
#line 399
    unique = tmp___23;
#line 400
    tmp___24 = ikrt_strings_to_gensym(pretty, unique, pcb);
#line 400
    sym___0 = tmp___24;
    }
#line 401
    if (put_mark_index) {
#line 402
      *(p->marks + put_mark_index) = sym___0;
    }
#line 404
    return (sym___0);
  } else
#line 406
  if ((int )c == 82) {
    {
#line 407
    tmp___25 = do_read(pcb, p);
#line 407
    name = tmp___25;
#line 408
    tmp___26 = do_read(pcb, p);
#line 408
    symb = tmp___26;
#line 410
    fasl_read_buf(p, (void *)(& n), (int )sizeof(long ));
    }
#line 412
    if (n == 0L) {
#line 413
      fields = (ikptr )79;
    } else {
#line 415
      if ((int )sizeof(ikptr ) == 4) {
#line 415
        tmp___27 = 2;
      } else {
#line 415
        tmp___27 = 3;
      }
#line 415
      if ((int )sizeof(ikptr ) == 4) {
#line 415
        tmp___28 = 2;
      } else {
#line 415
        tmp___28 = 3;
      }
      {
#line 415
      tmp___29 = ik_unsafe_alloc(pcb, (int )(n * (long )((((2 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___27 + 1)) << (tmp___28 + 1))));
#line 415
      fields = tmp___29 + 1UL;
#line 416
      ptr = fields;
#line 417
      i___2 = 0L;
      }
      {
#line 417
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 417
        if (! (i___2 < n)) {
#line 417
          goto while_break___2;
        }
        {
#line 418
        *((ikptr *)((long )ptr + -1L) + 0) = do_read(pcb, p);
        }
#line 419
        if ((int )sizeof(ikptr ) == 4) {
#line 419
          tmp___30 = 2;
        } else {
#line 419
          tmp___30 = 3;
        }
#line 419
        if ((int )sizeof(ikptr ) == 4) {
#line 419
          tmp___31 = 2;
        } else {
#line 419
          tmp___31 = 3;
        }
#line 419
        *((ikptr *)((long )ptr + (long )((int )sizeof(ikptr ) - 1)) + 0) = ptr + (ikptr )((((2 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___30 + 1)) << (tmp___31 + 1));
#line 420
        if ((int )sizeof(ikptr ) == 4) {
#line 420
          tmp___32 = 2;
        } else {
#line 420
          tmp___32 = 3;
        }
#line 420
        if ((int )sizeof(ikptr ) == 4) {
#line 420
          tmp___33 = 2;
        } else {
#line 420
          tmp___33 = 3;
        }
#line 420
        ptr += (ikptr )((((2 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___32 + 1)) << (tmp___33 + 1));
#line 417
        i___2 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 422
      ptr -= (ikptr )(2 * (int )sizeof(ikptr ));
#line 423
      *((ikptr *)((long )ptr + (long )((int )sizeof(ikptr ) - 1)) + 0) = (ikptr )79;
    }
#line 425
    gensym_val = *((ikptr *)((long )symb + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0);
#line 427
    if (gensym_val == 111UL) {
#line 428
      if ((int )sizeof(ikptr ) == 4) {
#line 428
        tmp___34 = 2;
      } else {
#line 428
        tmp___34 = 3;
      }
#line 428
      if ((int )sizeof(ikptr ) == 4) {
#line 428
        tmp___35 = 2;
      } else {
#line 428
        tmp___35 = 3;
      }
      {
#line 428
      tmp___36 = ik_unsafe_alloc(pcb, (((6 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___34 + 1)) << (tmp___35 + 1));
#line 428
      rtd = tmp___36 + 5UL;
#line 429
      base_rtd = pcb->base_rtd;
#line 430
      *((ikptr *)((long )rtd + -5L) + 0) = base_rtd;
#line 431
      *((ikptr *)((long )rtd + (long )((int )sizeof(ikptr ) - 5)) + 0) = name;
      }
#line 432
      if ((int )sizeof(ikptr ) == 4) {
#line 432
        tmp___37 = 2;
      } else {
#line 432
        tmp___37 = 3;
      }
#line 432
      *((ikptr *)((long )rtd + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )(n << tmp___37);
#line 433
      *((ikptr *)((long )rtd + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = fields;
#line 434
      *((ikptr *)((long )rtd + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )47;
#line 435
      *((ikptr *)((long )rtd + (long )(5 * (int )sizeof(ikptr ) - 5)) + 0) = symb;
#line 436
      *((ikptr *)((long )symb + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = rtd;
#line 437
      *((unsigned int *)((long )pcb->dirty_vector) + ((symb + (ikptr )(3 * (int )sizeof(ikptr ) - 5)) >> 12)) = 4294967295U;
    } else {
#line 439
      rtd = gensym_val;
    }
#line 441
    if (put_mark_index) {
#line 442
      *(p->marks + put_mark_index) = rtd;
    }
#line 444
    return (rtd);
  } else
#line 446
  if ((int )c == 81) {
#line 447
    if ((int )sizeof(ikptr ) == 4) {
#line 447
      tmp___38 = 2;
    } else {
#line 447
      tmp___38 = 3;
    }
#line 447
    if ((int )sizeof(ikptr ) == 4) {
#line 447
      tmp___39 = 2;
    } else {
#line 447
      tmp___39 = 3;
    }
    {
#line 447
    tmp___40 = ik_unsafe_alloc(pcb, ((((int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___38 + 1)) << (tmp___39 + 1));
#line 447
    proc = tmp___40 + 3UL;
    }
#line 448
    if (put_mark_index) {
#line 449
      *(p->marks + put_mark_index) = proc;
    }
    {
#line 451
    tmp___41 = do_read(pcb, p);
#line 451
    code___0 = tmp___41;
#line 452
    *((ikptr *)((long )proc + -3L) + 0) = code___0 + (ikptr )(6 * (int )sizeof(ikptr ) - 5);
    }
#line 453
    return (proc);
  } else
#line 455
  if ((int )c == 60) {
    {
#line 457
    fasl_read_buf(p, (void *)(& idx___0), (int )sizeof(int ));
    }
#line 458
    if (idx___0 <= 0) {
      {
#line 459
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid index for ref %d\n",
              idx___0);
#line 460
      exit(-1);
      }
    }
#line 462
    if (idx___0 >= p->marks_size) {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid index for ref %d\n",
              idx___0);
#line 464
      exit(-1);
      }
    }
#line 466
    obj = *(p->marks + idx___0);
#line 467
    if (obj) {
#line 468
      return (obj);
    } else {
      {
#line 470
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reference to uninitialized mark %d\n",
              idx___0);
#line 471
      exit(-1);
      }
    }
  } else
#line 474
  if ((int )c == 118) {
    {
#line 477
    fasl_read_buf(p, (void *)(& len___2), (int )sizeof(long ));
    }
#line 478
    if ((int )sizeof(ikptr ) == 4) {
#line 478
      tmp___42 = 2;
    } else {
#line 478
      tmp___42 = 3;
    }
#line 478
    if ((int )sizeof(ikptr ) == 4) {
#line 478
      tmp___43 = 2;
    } else {
#line 478
      tmp___43 = 3;
    }
    {
#line 478
    size___2 = (((((len___2 + 8L) + 1L) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___42 + 1)) << (tmp___43 + 1);
#line 479
    tmp___44 = ik_unsafe_alloc(pcb, (int )size___2);
#line 479
    x___0 = tmp___44 + 2UL;
    }
#line 480
    if ((int )sizeof(ikptr ) == 4) {
#line 480
      tmp___45 = 2;
    } else {
#line 480
      tmp___45 = 3;
    }
    {
#line 480
    *((ikptr *)((long )x___0 + -2L) + 0) = (ikptr )(len___2 << tmp___45);
#line 481
    fasl_read_buf(p, (void *)((long )(x___0 + 6UL)), (int )len___2);
#line 482
    *((char *)((long )x___0) + (6L + len___2)) = (char)0;
    }
#line 483
    if (put_mark_index) {
#line 484
      *(p->marks + put_mark_index) = x___0;
    }
#line 486
    return (x___0);
  } else
#line 488
  if ((int )c == 108) {
    {
#line 489
    tmp___46 = fasl_read_byte(p);
#line 489
    len___3 = (int )((unsigned char )tmp___46);
#line 490
    tmp___47 = ik_unsafe_alloc(pcb, (2 * (int )sizeof(ikptr )) * (len___3 + 1));
#line 490
    pair___0 = tmp___47 + 1UL;
    }
#line 491
    if (put_mark_index) {
#line 492
      *(p->marks + put_mark_index) = pair___0;
    }
#line 494
    pt = pair___0;
#line 495
    i___3 = 0;
    {
#line 495
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 495
      if (! (i___3 < len___3)) {
#line 495
        goto while_break___3;
      }
      {
#line 496
      *((ikptr *)((long )pt + -1L) + 0) = do_read(pcb, p);
#line 497
      *((ikptr *)((long )pt + (long )((int )sizeof(ikptr ) - 1)) + 0) = pt + (ikptr )(2 * (int )sizeof(ikptr ));
#line 498
      pt += (ikptr )(2 * (int )sizeof(ikptr ));
#line 495
      i___3 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 500
    *((ikptr *)((long )pt + -1L) + 0) = do_read(pcb, p);
#line 501
    *((ikptr *)((long )pt + (long )((int )sizeof(ikptr ) - 1)) + 0) = do_read(pcb,
                                                                              p);
    }
#line 502
    return (pair___0);
  } else
#line 504
  if ((int )c == 76) {
    {
#line 506
    fasl_read_buf(p, (void *)(& len___4), (int )sizeof(long ));
    }
#line 507
    if (len___4 < 0L) {
      {
#line 508
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid len=%ld\n",
              len___4);
#line 509
      exit(-1);
      }
    }
    {
#line 511
    tmp___48 = ik_unsafe_alloc(pcb, (int )((long )(2 * (int )sizeof(ikptr )) * (len___4 + 1L)));
#line 511
    pair___1 = tmp___48 + 1UL;
    }
#line 512
    if (put_mark_index) {
#line 513
      *(p->marks + put_mark_index) = pair___1;
    }
#line 515
    pt___0 = pair___1;
#line 516
    i___4 = 0L;
    {
#line 516
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 516
      if (! (i___4 < len___4)) {
#line 516
        goto while_break___4;
      }
      {
#line 517
      *((ikptr *)((long )pt___0 + -1L) + 0) = do_read(pcb, p);
#line 518
      *((ikptr *)((long )pt___0 + (long )((int )sizeof(ikptr ) - 1)) + 0) = pt___0 + (ikptr )(2 * (int )sizeof(ikptr ));
#line 519
      pt___0 += (ikptr )(2 * (int )sizeof(ikptr ));
#line 516
      i___4 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 521
    *((ikptr *)((long )pt___0 + -1L) + 0) = do_read(pcb, p);
#line 522
    *((ikptr *)((long )pt___0 + (long )((int )sizeof(ikptr ) - 1)) + 0) = do_read(pcb,
                                                                                  p);
    }
#line 523
    return (pair___1);
  } else
#line 525
  if ((int )c == 102) {
    {
#line 526
    tmp___49 = ik_unsafe_alloc(pcb, 16);
#line 526
    x___1 = tmp___49 + 5UL;
#line 527
    *((ikptr *)((long )x___1 + -5L) + 0) = (ikptr )23;
#line 528
    fasl_read_buf(p, (void *)((long )((x___1 + 8UL) - 5UL)), 8);
    }
#line 529
    if (put_mark_index) {
#line 530
      *(p->marks + put_mark_index) = x___1;
    }
#line 532
    return (x___1);
  } else
#line 534
  if ((int )c == 67) {
    {
#line 536
    fasl_read_buf(p, (void *)(& n___0), (int )sizeof(int ));
    }
#line 537
    return (((unsigned long )n___0 << 8) | 15UL);
  } else
#line 539
  if ((int )c == 98) {
    {
#line 541
    sign = 0L;
#line 542
    fasl_read_buf(p, (void *)(& len___5), (int )sizeof(long ));
    }
#line 543
    if (len___5 < 0L) {
#line 544
      sign = 1L;
#line 545
      len___5 = - len___5;
    }
#line 547
    if (len___5 & 3L) {
      {
#line 548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in fasl-read: invalid bignum length %ld\n",
              len___5);
#line 549
      exit(-1);
      }
    }
#line 551
    tag = (unsigned long )((3L | (sign << 3)) | ((len___5 >> 2) << 4));
#line 553
    if ((int )sizeof(ikptr ) == 4) {
#line 553
      tmp___50 = 2;
    } else {
#line 553
      tmp___50 = 3;
    }
#line 553
    if ((int )sizeof(ikptr ) == 4) {
#line 553
      tmp___51 = 2;
    } else {
#line 553
      tmp___51 = 3;
    }
    {
#line 553
    tmp___52 = ik_unsafe_alloc(pcb, (int )(((((len___5 + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___50 + 1)) << (tmp___51 + 1)));
#line 553
    x___2 = tmp___52 + 5UL;
#line 554
    *((ikptr *)((long )x___2 + -5L) + 0) = tag;
#line 555
    fasl_read_buf(p, (void *)((long )(x___2 + (ikptr )((int )sizeof(ikptr ) - 5))),
                  (int )len___5);
    }
#line 556
    if (put_mark_index) {
#line 557
      *(p->marks + put_mark_index) = x___2;
    }
#line 559
    return (x___2);
  } else
#line 561
  if ((int )c == 105) {
    {
#line 562
    tmp___53 = do_read(pcb, p);
#line 562
    real = tmp___53;
#line 563
    tmp___54 = do_read(pcb, p);
#line 563
    imag = tmp___54;
    }
#line 565
    if (((int )real & 7) == 5) {
#line 565
      if (*((ikptr *)((long )real + -5L) + 0) == 23UL) {
        {
#line 567
        x___3 = ik_unsafe_alloc(pcb, 4 * (int )sizeof(ikptr ));
#line 568
        *((ikptr *)((long )x___3) + 0) = (ikptr )71;
#line 569
        *((ikptr *)((long )x___3 + (long )((int )sizeof(ikptr ))) + 0) = real;
#line 570
        *((ikptr *)((long )x___3 + (long )(2 * (int )sizeof(ikptr ))) + 0) = imag;
        }
      } else {
        {
#line 572
        x___3 = ik_unsafe_alloc(pcb, 4 * (int )sizeof(ikptr ));
#line 573
        *((ikptr *)((long )x___3) + 0) = (ikptr )55;
#line 574
        *((ikptr *)((long )x___3 + (long )((int )sizeof(ikptr ))) + 0) = real;
#line 575
        *((ikptr *)((long )x___3 + (long )(2 * (int )sizeof(ikptr ))) + 0) = imag;
        }
      }
    } else {
      {
#line 572
      x___3 = ik_unsafe_alloc(pcb, 4 * (int )sizeof(ikptr ));
#line 573
      *((ikptr *)((long )x___3) + 0) = (ikptr )55;
#line 574
      *((ikptr *)((long )x___3 + (long )((int )sizeof(ikptr ))) + 0) = real;
#line 575
      *((ikptr *)((long )x___3 + (long )(2 * (int )sizeof(ikptr ))) + 0) = imag;
      }
    }
#line 577
    x___3 += 5UL;
#line 578
    if (put_mark_index) {
#line 579
      *(p->marks + put_mark_index) = x___3;
    }
#line 581
    return (x___3);
  } else {
    {
#line 584
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid type \'%c\' (0x%02x) found in fasl file\n",
            (int )c, (int )c);
#line 585
    exit(-1);
    }
  }
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static ikptr ik_fasl_read(ikpcb *pcb , fasl_port *p ) 
{ 
  char const   *tmp ;
  size_t tmp___0 ;
  char *buf ;
  unsigned long __lengthofbuf ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  ikptr tmp___8 ;

  {
#line 592
  if (sizeof(ikptr ) == 4UL) {
#line 592
    tmp = "#@IK01";
  } else {
#line 592
    tmp = "#@IK02";
  }
  {
#line 592
  tmp___0 = strlen(tmp);
#line 592
  __lengthofbuf = tmp___0;
#line 592
  tmp___1 = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 592
  buf = (char *)tmp___1;
  }
#line 593
  if (sizeof(ikptr ) == 4UL) {
#line 593
    tmp___2 = "#@IK01";
  } else {
#line 593
    tmp___2 = "#@IK02";
  }
  {
#line 593
  tmp___3 = strlen(tmp___2);
#line 593
  fasl_read_buf(p, (void *)buf, (int )tmp___3);
  }
#line 594
  if (sizeof(ikptr ) == 4UL) {
#line 594
    tmp___4 = "#@IK01";
  } else {
#line 594
    tmp___4 = "#@IK02";
  }
  {
#line 594
  tmp___5 = strlen(tmp___4);
  }
#line 594
  if (sizeof(ikptr ) == 4UL) {
#line 594
    tmp___6 = "#@IK01";
  } else {
#line 594
    tmp___6 = "#@IK02";
  }
  {
#line 594
  tmp___7 = strncmp((char const   *)buf, tmp___6, tmp___5);
  }
#line 594
  if (tmp___7 != 0) {
    {
#line 595
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid fasl header\n");
#line 596
    exit(-1);
    }
  }
  {
#line 598
  tmp___8 = do_read(pcb, p);
  }
#line 598
  return (tmp___8);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-weak-pairs.c"
ikptr ikrt_weak_cons(ikptr a , ikptr d , ikpcb *pcb ) 
{ 
  ikptr ap ;
  ikptr nap ;
  ikptr p ;
  ikptr mem ;
  ikptr tmp ;

  {
#line 24
  ap = pcb->weak_pairs_ap;
#line 25
  nap = ap + (ikptr )(2 * (int )sizeof(ikptr ));
#line 27
  if (nap > pcb->weak_pairs_ep) {
    {
#line 28
    tmp = ik_mmap_typed(4096UL, 71168U, pcb);
#line 28
    mem = tmp;
#line 29
    pcb->weak_pairs_ap = mem + (ikptr )(2 * (int )sizeof(ikptr ));
#line 30
    pcb->weak_pairs_ep = mem + 4096UL;
#line 31
    p = mem + 1UL;
    }
  } else {
#line 34
    pcb->weak_pairs_ap = nap;
#line 35
    p = ap + 1UL;
  }
#line 37
  *((ikptr *)((long )p + -1L) + 0) = a;
#line 38
  *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0) = d;
#line 39
  return (p);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-weak-pairs.c"
ikptr ikrt_is_weak_pair(ikptr x , ikpcb *pcb ) 
{ 
  unsigned int t ;

  {
#line 44
  if (((int )x & 7) != 1) {
#line 45
    return ((ikptr )47);
  }
#line 47
  t = *(pcb->segment_vector + (x >> 12));
#line 48
  if ((t & 3840U) == 1536U) {
#line 49
    return ((ikptr )63);
  } else {
#line 51
    return ((ikptr )47);
  }
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
static errno_info errno_table[79]  = 
#line 50 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
  {      {7, (char *)"E2BIG", (ikptr )(-1L << 3)}, 
        {13, (char *)"EACCES", (ikptr )(-2L << 3)}, 
        {98, (char *)"EADDRINUSE", (ikptr )(-3L << 3)}, 
        {99, (char *)"EADDRNOTAVAIL", (ikptr )(-4L << 3)}, 
        {97, (char *)"EAFNOSUPPORT", (ikptr )(-5L << 3)}, 
        {11, (char *)"EAGAIN", (ikptr )(-6L << 3)}, 
        {114, (char *)"EALREADY", (ikptr )(-7L << 3)}, 
        {9, (char *)"EBADF", (ikptr )(-8L << 3)}, 
        {74, (char *)"EBADMSG", (ikptr )(-9L << 3)}, 
        {16, (char *)"EBUSY", (ikptr )(-10L << 3)}, 
        {125, (char *)"ECANCELED", (ikptr )(-11L << 3)}, 
        {10, (char *)"ECHILD", (ikptr )(-12L << 3)}, 
        {103, (char *)"ECONNABORTED", (ikptr )(-13L << 3)}, 
        {111, (char *)"ECONNREFUSED", (ikptr )(-14L << 3)}, 
        {104, (char *)"ECONNRESET", (ikptr )(-15L << 3)}, 
        {35, (char *)"EDEADLK", (ikptr )(-16L << 3)}, 
        {89, (char *)"EDESTADDRREQ", (ikptr )(-17L << 3)}, 
        {33, (char *)"EDOM", (ikptr )(-18L << 3)}, 
        {122, (char *)"EDQUOT", (ikptr )(-19L << 3)}, 
        {17, (char *)"EEXIST", (ikptr )(-20L << 3)}, 
        {14, (char *)"EFAULT", (ikptr )(-21L << 3)}, 
        {27, (char *)"EFBIG", (ikptr )(-22L << 3)}, 
        {113, (char *)"EHOSTUNREACH", (ikptr )(-23L << 3)}, 
        {43, (char *)"EIDRM", (ikptr )(-24L << 3)}, 
        {84, (char *)"EILSEQ", (ikptr )(-25L << 3)}, 
        {115, (char *)"EINPROGRESS", (ikptr )(-26L << 3)}, 
        {4, (char *)"EINTR", (ikptr )(-27L << 3)}, 
        {22, (char *)"EINVAL", (ikptr )(-28L << 3)}, 
        {5, (char *)"EIO", (ikptr )(-29L << 3)}, 
        {106, (char *)"EISCONN", (ikptr )(-30L << 3)}, 
        {21, (char *)"EISDIR", (ikptr )(-31L << 3)}, 
        {40, (char *)"ELOOP", (ikptr )(-32L << 3)}, 
        {24, (char *)"EMFILE", (ikptr )(-33L << 3)}, 
        {31, (char *)"EMLINK", (ikptr )(-34L << 3)}, 
        {90, (char *)"EMSGSIZE", (ikptr )(-35L << 3)}, 
        {72, (char *)"EMULTIHOP", (ikptr )(-36L << 3)}, 
        {36, (char *)"ENAMETOOLONG", (ikptr )(-37L << 3)}, 
        {100, (char *)"ENETDOWN", (ikptr )(-38L << 3)}, 
        {102, (char *)"ENETRESET", (ikptr )(-39L << 3)}, 
        {101, (char *)"ENETUNREACH", (ikptr )(-40L << 3)}, 
        {23, (char *)"ENFILE", (ikptr )(-41L << 3)}, 
        {105, (char *)"ENOBUFS", (ikptr )(-42L << 3)}, 
        {61, (char *)"ENODATA", (ikptr )(-43L << 3)}, 
        {19, (char *)"ENODEV", (ikptr )(-44L << 3)}, 
        {2, (char *)"ENOENT", (ikptr )(-45L << 3)}, 
        {8, (char *)"ENOEXEC", (ikptr )(-46L << 3)}, 
        {37, (char *)"ENOLCK", (ikptr )(-47L << 3)}, 
        {67, (char *)"ENOLINK", (ikptr )(-48L << 3)}, 
        {12, (char *)"ENOMEM", (ikptr )(-49L << 3)}, 
        {42, (char *)"ENOMSG", (ikptr )(-50L << 3)}, 
        {92, (char *)"ENOPROTOOPT", (ikptr )(-51L << 3)}, 
        {28, (char *)"ENOSPC", (ikptr )(-52L << 3)}, 
        {63, (char *)"ENOSR", (ikptr )(-53L << 3)}, 
        {60, (char *)"ENOSTR", (ikptr )(-54L << 3)}, 
        {38, (char *)"ENOSYS", (ikptr )(-55L << 3)}, 
        {107, (char *)"ENOTCONN", (ikptr )(-56L << 3)}, 
        {20, (char *)"ENOTDIR", (ikptr )(-57L << 3)}, 
        {39, (char *)"ENOTEMPTY", (ikptr )(-58L << 3)}, 
        {88, (char *)"ENOTSOCK", (ikptr )(-59L << 3)}, 
        {95, (char *)"ENOTSUP", (ikptr )(-60L << 3)}, 
        {25, (char *)"ENOTTY", (ikptr )(-61L << 3)}, 
        {6, (char *)"ENXIO", (ikptr )(-62L << 3)}, 
        {95, (char *)"EOPNOTSUPP", (ikptr )(-63L << 3)}, 
        {75, (char *)"EOVERFLOW", (ikptr )(-64L << 3)}, 
        {1, (char *)"EPERM", (ikptr )(-65L << 3)}, 
        {32, (char *)"EPIPE", (ikptr )(-66L << 3)}, 
        {71, (char *)"EPROTO", (ikptr )(-67L << 3)}, 
        {93, (char *)"EPROTONOSUPPORT", (ikptr )(-68L << 3)}, 
        {91, (char *)"EPROTOTYPE", (ikptr )(-69L << 3)}, 
        {34, (char *)"ERANGE", (ikptr )(-70L << 3)}, 
        {30, (char *)"EROFS", (ikptr )(-71L << 3)}, 
        {29, (char *)"ESPIPE", (ikptr )(-72L << 3)}, 
        {3, (char *)"ESRCH", (ikptr )(-73L << 3)}, 
        {116, (char *)"ESTALE", (ikptr )(-74L << 3)}, 
        {62, (char *)"ETIME", (ikptr )(-75L << 3)}, 
        {110, (char *)"ETIMEDOUT", (ikptr )(-76L << 3)}, 
        {26, (char *)"ETXTBSY", (ikptr )(-77L << 3)}, 
        {11, (char *)"EWOULDBLOCK", (ikptr )(-78L << 3)}, 
        {18, (char *)"EXDEV", (ikptr )(-79L << 3)}};
#line 135 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
ikptr ik_errno_num_to_code(int en ) 
{ 
  errno_info *ei ;
  int i ;
  int tmp ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < 79)) {
#line 140
      goto while_break;
    }
#line 141
    ei = & errno_table[i];
#line 142
    if (ei->n == en) {
#line 143
      return (ei->c);
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n*** ikarus-errno.c: Don\'t know errno %d ***\n\n",
          en);
  }
#line 147
  if ((int )sizeof(ikptr ) == 4) {
#line 147
    tmp = 2;
  } else {
#line 147
    tmp = 3;
  }
#line 147
  return ((ikptr )(-99999L << tmp));
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
ikptr ik_errno_to_code(void) 
{ 
  int en ;
  int *tmp ;
  ikptr tmp___0 ;

  {
  {
#line 152
  tmp = __errno_location();
#line 152
  en = *tmp;
#line 153
  tmp___0 = ik_errno_num_to_code(en);
  }
#line 153
  return (tmp___0);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
ikptr ikrt_errno_code_to_name(ikptr ec , ikpcb *pcb ) 
{ 
  errno_info *ei ;
  int i ;
  int len ;
  size_t tmp ;
  ikptr bv ;
  int tmp___0 ;
  int tmp___1 ;
  ikptr tmp___2 ;
  int tmp___3 ;

  {
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < 79)) {
#line 162
      goto while_break;
    }
#line 163
    ei = & errno_table[i];
#line 164
    if (ei->c == ec) {
      {
#line 165
      tmp = strlen((char const   *)ei->s);
#line 165
      len = (int )tmp;
      }
#line 166
      if ((int )sizeof(ikptr ) == 4) {
#line 166
        tmp___0 = 2;
      } else {
#line 166
        tmp___0 = 3;
      }
#line 166
      if ((int )sizeof(ikptr ) == 4) {
#line 166
        tmp___1 = 2;
      } else {
#line 166
        tmp___1 = 3;
      }
      {
#line 166
      tmp___2 = ik_safe_alloc(pcb, (((((8 + len) + 1) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___0 + 1)) << (tmp___1 + 1));
#line 166
      bv = tmp___2 + 2UL;
      }
#line 168
      if ((int )sizeof(ikptr ) == 4) {
#line 168
        tmp___3 = 2;
      } else {
#line 168
        tmp___3 = 3;
      }
      {
#line 168
      *((ikptr *)((long )bv + -2L) + 0) = (ikptr )((long )len << tmp___3);
#line 169
      memcpy((void */* __restrict  */)((char *)(bv + 6UL)), (void const   */* __restrict  */)ei->s,
             (size_t )(len + 1));
      }
#line 170
      return (bv);
    }
#line 162
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return ((ikptr )47);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
ikptr ikrt_strerror(ikptr ec , ikpcb *pcb ) 
{ 
  errno_info *ei ;
  int i ;
  int *tmp ;
  char *es ;
  char *tmp___0 ;
  int *tmp___1 ;
  int len ;
  size_t tmp___2 ;
  ikptr bv ;
  int tmp___3 ;
  int tmp___4 ;
  ikptr tmp___5 ;
  int tmp___6 ;

  {
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < 79)) {
#line 182
      goto while_break;
    }
#line 183
    ei = & errno_table[i];
#line 184
    if (ei->c == ec) {
      {
#line 185
      tmp = __errno_location();
#line 185
      *tmp = 0;
#line 186
      tmp___0 = strerror(ei->n);
#line 186
      es = tmp___0;
#line 187
      tmp___1 = __errno_location();
      }
#line 187
      if (*tmp___1) {
        {
#line 188
        perror("ikrt_strerror: strerror failed");
#line 189
        exit(1);
        }
      }
      {
#line 191
      tmp___2 = strlen((char const   *)es);
#line 191
      len = (int )tmp___2;
      }
#line 192
      if ((int )sizeof(ikptr ) == 4) {
#line 192
        tmp___3 = 2;
      } else {
#line 192
        tmp___3 = 3;
      }
#line 192
      if ((int )sizeof(ikptr ) == 4) {
#line 192
        tmp___4 = 2;
      } else {
#line 192
        tmp___4 = 3;
      }
      {
#line 192
      tmp___5 = ik_safe_alloc(pcb, (((((8 + len) + 1) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___3 + 1)) << (tmp___4 + 1));
#line 192
      bv = tmp___5 + 2UL;
      }
#line 194
      if ((int )sizeof(ikptr ) == 4) {
#line 194
        tmp___6 = 2;
      } else {
#line 194
        tmp___6 = 3;
      }
      {
#line 194
      *((ikptr *)((long )bv + -2L) + 0) = (ikptr )((long )len << tmp___6);
#line 195
      memcpy((void */* __restrict  */)((char *)(bv + 6UL)), (void const   */* __restrict  */)es,
             (size_t )(len + 1));
      }
#line 196
      return (bv);
    }
#line 182
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return ((ikptr )47);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static ikptr make_symbol_table(ikpcb *pcb ) 
{ 
  int size ;
  ikptr st ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 28
  size = (int )(((4095UL + (unsigned long )((int )sizeof(ikptr ) + 4096 * (int )sizeof(ikptr ))) >> 12) << 12);
#line 29
  tmp = ik_mmap_ptr((unsigned long )size, 0, pcb);
#line 29
  st = tmp + 5UL;
#line 30
  bzero((void *)((char *)((long )st) - 5), (size_t )size);
  }
#line 31
  if ((int )sizeof(ikptr ) == 4) {
#line 31
    tmp___0 = 2;
  } else {
#line 31
    tmp___0 = 3;
  }
#line 31
  *((ikptr *)((long )st + -5L) + 0) = (ikptr )(4096L << tmp___0);
#line 32
  return (st);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static long compute_hash(ikptr str ) 
{ 
  long len ;
  int tmp ;
  int *data ;
  int h ;
  int *last ;
  int c ;
  int tmp___0 ;

  {
#line 39
  if ((int )sizeof(ikptr ) == 4) {
#line 39
    tmp = 2;
  } else {
#line 39
    tmp = 3;
  }
#line 39
  len = (long )*((ikptr *)((long )str + -6L) + 0) >> tmp;
#line 40
  data = (int *)(str + (ikptr )((int )sizeof(ikptr ) - 6));
#line 41
  h = (int )len;
#line 42
  last = data + len;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned long )data < (unsigned long )last)) {
#line 45
      goto while_break;
    }
#line 46
    c = *data >> 8;
#line 47
    h += c;
#line 48
    h += h << 10;
#line 49
    h ^= h >> 6;
#line 50
    data ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  h += h << 3;
#line 53
  h ^= h >> 11;
#line 54
  h += h << 15;
#line 55
  if (h >= 0) {
#line 55
    tmp___0 = h;
  } else {
#line 55
    tmp___0 = 1 - h;
  }
#line 55
  return ((long )tmp___0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
ikptr ikrt_string_hash(ikptr str ) 
{ 
  long tmp ;

  {
  {
#line 60
  tmp = compute_hash(str);
  }
#line 60
  return ((ikptr )(tmp & (long )(~ ((int )sizeof(ikptr ) - 1))));
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static int strings_eqp(ikptr str1 , ikptr str2 ) 
{ 
  ikptr len ;
  int tmp ;
  int tmp___0 ;

  {
#line 64
  len = *((ikptr *)((long )str1 + -6L) + 0);
#line 65
  if (len == *((ikptr *)((long )str2 + -6L) + 0)) {
#line 66
    if ((int )sizeof(ikptr ) == 4) {
#line 66
      tmp = 2;
    } else {
#line 66
      tmp = 3;
    }
    {
#line 66
    tmp___0 = memcmp((void const   *)((char *)((long )str1) + ((int )sizeof(ikptr ) - 6)),
                     (void const   *)((char *)((long )str2) + ((int )sizeof(ikptr ) - 6)),
                     (size_t )(((long )len >> tmp) * 4L));
    }
#line 66
    return (tmp___0 == 0);
  }
#line 72
  return (0);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static ikptr ik_make_symbol(ikptr str , ikptr ustr , ikpcb *pcb ) 
{ 
  ikptr sym ;
  ikptr tmp ;

  {
  {
#line 77
  tmp = ik_unsafe_alloc(pcb, 6 * (int )sizeof(ikptr ));
#line 77
  sym = tmp + 5UL;
#line 78
  *((ikptr *)((long )sym + -5L) + 0) = (ikptr )95;
#line 79
  *((ikptr *)((long )sym + (long )((int )sizeof(ikptr ) - 5)) + 0) = str;
#line 80
  *((ikptr *)((long )sym + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = ustr;
#line 81
  *((ikptr *)((long )sym + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )111;
#line 82
  *((ikptr *)((long )sym + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0) = str;
#line 83
  *((ikptr *)((long )sym + (long )(5 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )79;
  }
#line 84
  return (sym);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static ikptr intern_string(ikptr str , ikptr st , ikpcb *pcb ) 
{ 
  int h ;
  long tmp ;
  int idx ;
  int tmp___0 ;
  ikptr bckt ;
  ikptr b ;
  ikptr sym ;
  ikptr sym_str ;
  int tmp___1 ;
  ikptr sym___0 ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;

  {
  {
#line 89
  tmp = compute_hash(str);
#line 89
  h = (int )tmp;
  }
#line 90
  if ((int )sizeof(ikptr ) == 4) {
#line 90
    tmp___0 = 2;
  } else {
#line 90
    tmp___0 = 3;
  }
#line 90
  idx = (int )((long )h & (((long )*((ikptr *)((long )st + -5L) + 0) >> tmp___0) - 1L));
#line 91
  bckt = *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0);
#line 92
  b = bckt;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! b) {
#line 93
      goto while_break;
    }
    {
#line 94
    sym = *((ikptr *)((long )b + -1L) + 0);
#line 95
    sym_str = *((ikptr *)((long )sym + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 96
    tmp___1 = strings_eqp(sym_str, str);
    }
#line 96
    if (tmp___1) {
#line 97
      return (sym);
    }
#line 99
    b = *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = ik_make_symbol(str, (ikptr )47, pcb);
#line 101
  sym___0 = tmp___2;
#line 102
  tmp___3 = ik_unsafe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 102
  b = tmp___3 + 1UL;
#line 103
  *((ikptr *)((long )b + -1L) + 0) = sym___0;
#line 104
  *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0) = bckt;
#line 105
  *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0) = b;
#line 106
  *((int *)((long )pcb->dirty_vector) + (((st + (ikptr )((int )sizeof(ikptr ) - 5)) + (ikptr )(idx * (int )sizeof(ikptr ))) >> 12)) = -1;
  }
#line 107
  return (sym___0);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static ikptr intern_unique_string(ikptr str , ikptr ustr , ikptr st , ikpcb *pcb ) 
{ 
  int h ;
  long tmp ;
  int idx ;
  int tmp___0 ;
  ikptr bckt ;
  ikptr b ;
  ikptr sym ;
  ikptr sym_ustr ;
  int tmp___1 ;
  ikptr sym___0 ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;

  {
  {
#line 112
  tmp = compute_hash(ustr);
#line 112
  h = (int )tmp;
  }
#line 113
  if ((int )sizeof(ikptr ) == 4) {
#line 113
    tmp___0 = 2;
  } else {
#line 113
    tmp___0 = 3;
  }
#line 113
  idx = (int )((long )h & (((long )*((ikptr *)((long )st + -5L) + 0) >> tmp___0) - 1L));
#line 114
  bckt = *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0);
#line 115
  b = bckt;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! b) {
#line 116
      goto while_break;
    }
    {
#line 117
    sym = *((ikptr *)((long )b + -1L) + 0);
#line 118
    sym_ustr = *((ikptr *)((long )sym + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 119
    tmp___1 = strings_eqp(sym_ustr, ustr);
    }
#line 119
    if (tmp___1) {
#line 120
      return (sym);
    }
#line 122
    b = *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  tmp___2 = ik_make_symbol(str, ustr, pcb);
#line 124
  sym___0 = tmp___2;
#line 125
  tmp___3 = ik_unsafe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 125
  b = tmp___3 + 1UL;
#line 126
  *((ikptr *)((long )b + -1L) + 0) = sym___0;
#line 127
  *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0) = bckt;
#line 128
  *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0) = b;
#line 129
  *((int *)((long )pcb->dirty_vector) + (((st + (ikptr )((int )sizeof(ikptr ) - 5)) + (ikptr )(idx * (int )sizeof(ikptr ))) >> 12)) = -1;
  }
#line 130
  return (sym___0);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
ikptr ikrt_intern_gensym(ikptr sym , ikpcb *pcb ) 
{ 
  ikptr st ;
  ikptr ustr ;
  int h ;
  long tmp ;
  int idx ;
  int tmp___0 ;
  ikptr bckt ;
  ikptr b ;
  ikptr sym___0 ;
  ikptr sym_ustr ;
  int tmp___1 ;
  ikptr tmp___2 ;

  {
#line 135
  st = pcb->gensym_table;
#line 136
  if (st == 0UL) {
    {
#line 137
    st = make_symbol_table(pcb);
#line 138
    pcb->gensym_table = st;
    }
  }
  {
#line 140
  ustr = *((ikptr *)((long )sym + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 141
  tmp = compute_hash(ustr);
#line 141
  h = (int )tmp;
  }
#line 142
  if ((int )sizeof(ikptr ) == 4) {
#line 142
    tmp___0 = 2;
  } else {
#line 142
    tmp___0 = 3;
  }
#line 142
  idx = (int )((long )h & (((long )*((ikptr *)((long )st + -5L) + 0) >> tmp___0) - 1L));
#line 143
  bckt = *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0);
#line 144
  b = bckt;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! b) {
#line 145
      goto while_break;
    }
    {
#line 146
    sym___0 = *((ikptr *)((long )b + -1L) + 0);
#line 147
    sym_ustr = *((ikptr *)((long )sym___0 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 148
    tmp___1 = strings_eqp(sym_ustr, ustr);
    }
#line 148
    if (tmp___1) {
#line 149
      return ((ikptr )47);
    }
#line 151
    b = *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  tmp___2 = ik_unsafe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 153
  b = tmp___2 + 1UL;
#line 154
  *((ikptr *)((long )b + -1L) + 0) = sym;
#line 155
  *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0) = bckt;
#line 156
  *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0) = b;
#line 157
  *((int *)((long )pcb->dirty_vector) + (((st + (ikptr )((int )sizeof(ikptr ) - 5)) + (ikptr )(idx * (int )sizeof(ikptr ))) >> 12)) = -1;
  }
#line 158
  return ((ikptr )63);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
ikptr ikrt_unintern_gensym(ikptr sym , ikpcb *pcb ) 
{ 
  ikptr st ;
  ikptr ustr ;
  int h ;
  long tmp ;
  int idx ;
  int tmp___0 ;
  ikptr loc ;
  ikptr bckt ;

  {
#line 164
  st = pcb->gensym_table;
#line 165
  if (st == 0UL) {
#line 167
    return ((ikptr )47);
  }
#line 169
  ustr = *((ikptr *)((long )sym + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 170
  if (((int )ustr & 7) != 6) {
#line 171
    return ((ikptr )47);
  }
  {
#line 173
  tmp = compute_hash(ustr);
#line 173
  h = (int )tmp;
  }
#line 174
  if ((int )sizeof(ikptr ) == 4) {
#line 174
    tmp___0 = 2;
  } else {
#line 174
    tmp___0 = 3;
  }
#line 174
  idx = (int )((long )h & (((long )*((ikptr *)((long )st + -5L) + 0) >> tmp___0) - 1L));
#line 175
  loc = (st + (ikptr )((int )sizeof(ikptr ) - 5)) + (ikptr )(idx * (int )sizeof(ikptr ));
#line 176
  bckt = *((ikptr *)((long )loc) + 0);
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! bckt) {
#line 177
      goto while_break;
    }
#line 178
    if (*((ikptr *)((long )bckt + -1L) + 0) == sym) {
#line 180
      *((ikptr *)((long )sym + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )63;
#line 181
      *((ikptr *)((long )loc) + 0) = *((ikptr *)((long )bckt + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 182
      return ((ikptr )63);
    } else {
#line 184
      loc = bckt + (ikptr )((int )sizeof(ikptr ) - 1);
#line 185
      bckt = *((ikptr *)((long )loc) + 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return ((ikptr )47);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
ikptr ikrt_get_symbol_table(ikpcb *pcb ) 
{ 
  ikptr st ;

  {
#line 193
  st = pcb->symbol_table;
#line 194
  pcb->symbol_table = (ikptr )47;
#line 195
  if (st == 47UL) {
    {
#line 196
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bug in ikarus, attempt to access dead symbol table\n");
#line 197
    exit(-1);
    }
  }
#line 199
  return (st);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
ikptr ikrt_string_to_symbol(ikptr str , ikpcb *pcb ) 
{ 
  ikptr st ;
  ikptr tmp ;

  {
#line 205
  st = pcb->symbol_table;
#line 206
  if (st == 47UL) {
    {
#line 207
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bug in ikarus, attempt to access dead symbol table\n");
#line 208
    exit(-1);
    }
  }
#line 210
  if (st == 0UL) {
    {
#line 211
    st = make_symbol_table(pcb);
#line 212
    pcb->symbol_table = st;
    }
  }
  {
#line 214
  tmp = intern_string(str, st, pcb);
  }
#line 214
  return (tmp);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
ikptr ik_intern_string(ikptr str , ikpcb *pcb ) 
{ 
  ikptr tmp ;

  {
  {
#line 219
  tmp = ikrt_string_to_symbol(str, pcb);
  }
#line 219
  return (tmp);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
ikptr ikrt_strings_to_gensym(ikptr str , ikptr ustr , ikpcb *pcb ) 
{ 
  ikptr st ;
  ikptr tmp ;

  {
#line 224
  st = pcb->gensym_table;
#line 225
  if (st == 0UL) {
    {
#line 226
    st = make_symbol_table(pcb);
#line 227
    pcb->gensym_table = st;
    }
  }
  {
#line 229
  tmp = intern_unique_string(str, ustr, st, pcb);
  }
#line 229
  return (tmp);
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 363
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaltstack)(struct sigaltstack  const  * __restrict  __ss ,
                                                                                  struct sigaltstack * __restrict  __oss ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-main.c"
void register_handlers(void) ;
#line 35
void register_alt_stack(void) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-main.c"
ikpcb *the_pcb  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-main.c"
int file_exists(char *filename ) 
{ 
  struct stat sb ;
  int s ;
  int tmp ;

  {
  {
#line 43
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& sb));
#line 43
  s = tmp;
  }
#line 44
  return (s == 0);
}
}
#line 47
extern int cpu_has_sse2() ;
#line 49 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-main.c"
int ikarus_main(int argc , char **argv , char *boot_file ) 
{ 
  int tmp ;
  ikpcb *pcb ;
  ikpcb *tmp___0 ;
  ikptr arg_list ;
  int i ;
  char *s ;
  int n ;
  size_t tmp___1 ;
  ikptr bv ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  int tmp___5 ;
  ikptr p ;
  ikptr tmp___6 ;

  {
  {
#line 50
  tmp = cpu_has_sse2();
  }
#line 50
  if (! tmp) {
    {
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ikarus Scheme cannot run on your computer because\n");
#line 52
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"your CPU does not support the SSE2 instruction set.\n");
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Refer to the Ikarus Scheme User\'s Guide for the\n");
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"minimum hardware requirements.\n");
#line 55
    exit(-1);
    }
  }
#line 57
  if (sizeof(mp_limb_t ) != sizeof(long )) {
    {
#line 58
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: limb size does not match\n");
#line 59
    exit(-1);
    }
  }
#line 61
  if ((unsigned long )__gmp_bits_per_limb != 8UL * sizeof(long )) {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: invalid bits_per_limb=%d\n",
            __gmp_bits_per_limb);
#line 63
    exit(-1);
    }
  }
  {
#line 65
  tmp___0 = ik_make_pcb();
#line 65
  pcb = tmp___0;
#line 66
  the_pcb = pcb;
#line 68
  arg_list = (ikptr )79;
#line 69
  i = argc - 1;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i > 0)) {
#line 70
      goto while_break;
    }
    {
#line 71
    s = *(argv + i);
#line 72
    tmp___1 = strlen((char const   *)s);
#line 72
    n = (int )tmp___1;
    }
#line 73
    if ((int )sizeof(ikptr ) == 4) {
#line 73
      tmp___2 = 2;
    } else {
#line 73
      tmp___2 = 3;
    }
#line 73
    if ((int )sizeof(ikptr ) == 4) {
#line 73
      tmp___3 = 2;
    } else {
#line 73
      tmp___3 = 3;
    }
    {
#line 73
    tmp___4 = ik_unsafe_alloc(pcb, (((((8 + n) + 1) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___2 + 1)) << (tmp___3 + 1));
#line 73
    bv = tmp___4 + 2UL;
    }
#line 75
    if ((int )sizeof(ikptr ) == 4) {
#line 75
      tmp___5 = 2;
    } else {
#line 75
      tmp___5 = 3;
    }
    {
#line 75
    *((ikptr *)((long )bv + -2L) + 0) = (ikptr )((long )n << tmp___5);
#line 76
    memcpy((void */* __restrict  */)((char *)(bv + 6UL)), (void const   */* __restrict  */)s,
           (size_t )(n + 1));
#line 77
    tmp___6 = ik_unsafe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 77
    p = tmp___6;
#line 78
    *((ikptr *)((long )p) + 0) = bv;
#line 79
    *((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) = arg_list;
#line 80
    arg_list = p + 1UL;
#line 81
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  pcb->arg_list = arg_list;
#line 85
  register_handlers();
#line 86
  register_alt_stack();
#line 87
  ik_fasl_load(pcb, boot_file);
#line 96
  ik_delete_pcb(pcb);
  }
#line 97
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-main.c"
void handler(int signo , siginfo_t *info , void *uap ) 
{ 
  int tmp ;

  {
#line 123
  signo = signo;
#line 123
  info = info;
#line 123
  uap = uap;
#line 124
  if ((int )sizeof(ikptr ) == 4) {
#line 124
    tmp = 2;
  } else {
#line 124
    tmp = 3;
  }
#line 124
  the_pcb->engine_counter = (ikptr )(-1L << tmp);
#line 125
  the_pcb->interrupted = (ikptr )1;
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-main.c"
void register_handlers(void) 
{ 
  struct sigaction sa ;
  int err ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  sigset_t set ;
  int err___0 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 131
  sa.__sigaction_handler.sa_sigaction = & handler;
#line 135
  sa.sa_flags = 134217732;
#line 137
  sigemptyset(& sa.sa_mask);
#line 138
  tmp = sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)0);
#line 138
  err = tmp;
  }
#line 139
  if (err) {
    {
#line 140
    tmp___0 = __errno_location();
#line 140
    tmp___1 = strerror(*tmp___0);
#line 140
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sigaction Failed: %s\n",
            tmp___1);
#line 141
    exit(-1);
    }
  }
  {
#line 147
  sigprocmask(0, (sigset_t const   */* __restrict  */)0, (sigset_t */* __restrict  */)(& set));
#line 148
  sigaddset(& set, 13);
#line 149
  tmp___2 = sigprocmask(2, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)(& set));
#line 149
  err___0 = tmp___2;
  }
#line 150
  if (err___0) {
    {
#line 151
    tmp___3 = __errno_location();
#line 151
    tmp___4 = strerror(*tmp___3);
#line 151
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sigprocmask Failed: %s\n",
            tmp___4);
#line 152
    exit(-1);
    }
  }
#line 155
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-main.c"
void register_alt_stack(void) 
{ 
  char *stk ;
  void *tmp ;
  stack_t sa ;
  int err ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 176
  tmp = mmap((void *)0, (size_t )8192, 7, 34, -1, (__off_t )0);
#line 176
  stk = (char *)tmp;
  }
#line 179
  if ((unsigned long )stk == (unsigned long )((char *)-1)) {
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot maloc an alt stack\n");
#line 181
    exit(-1);
    }
  }
  {
#line 185
  sa.ss_sp = (void *)stk;
#line 186
  sa.ss_size = (size_t )8192;
#line 187
  sa.ss_flags = 0;
#line 188
  tmp___0 = sigaltstack((struct sigaltstack  const  */* __restrict  */)(& sa), (struct sigaltstack */* __restrict  */)0);
#line 188
  err = tmp___0;
  }
#line 189
  if (err) {
    {
#line 190
    tmp___1 = __errno_location();
#line 190
    tmp___2 = strerror(*tmp___1);
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot set alt stack: %s\n",
            tmp___2);
#line 191
    exit(-1);
    }
  }
#line 194
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 25 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-print.c"
static void print(FILE *fh , ikptr x ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-print.c"
void ik_fprint(FILE *fh , ikptr x ) 
{ 


  {
  {
#line 28
  print(fh, x);
  }
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-print.c"
void ik_print(ikptr x ) 
{ 


  {
  {
#line 32
  print(stdout, x);
#line 33
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-print.c"
char *char_string[128]  = 
#line 36
  {      (char *)"#\\nul",      (char *)"#\\soh",      (char *)"#\\stx",      (char *)"#\\etx", 
        (char *)"#\\eot",      (char *)"#\\enq",      (char *)"#\\ack",      (char *)"#\\bel", 
        (char *)"#\\bs",      (char *)"#\\tab",      (char *)"#\\newline",      (char *)"#\\vt", 
        (char *)"#\\ff",      (char *)"#\\return",      (char *)"#\\so",      (char *)"#\\si", 
        (char *)"#\\dle",      (char *)"#\\dc1",      (char *)"#\\dc2",      (char *)"#\\dc3", 
        (char *)"#\\dc4",      (char *)"#\\nak",      (char *)"#\\syn",      (char *)"#\\etb", 
        (char *)"#\\can",      (char *)"#\\em",      (char *)"#\\sub",      (char *)"#\\esc", 
        (char *)"#\\fs",      (char *)"#\\gs",      (char *)"#\\rs",      (char *)"#\\us", 
        (char *)"#\\space",      (char *)"#\\!",      (char *)"#\\\"",      (char *)"#\\#", 
        (char *)"#\\$",      (char *)"#\\%",      (char *)"#\\&",      (char *)"#\\\'", 
        (char *)"#\\(",      (char *)"#\\)",      (char *)"#\\*",      (char *)"#\\+", 
        (char *)"#\\,",      (char *)"#\\-",      (char *)"#\\.",      (char *)"#\\/", 
        (char *)"#\\0",      (char *)"#\\1",      (char *)"#\\2",      (char *)"#\\3", 
        (char *)"#\\4",      (char *)"#\\5",      (char *)"#\\6",      (char *)"#\\7", 
        (char *)"#\\8",      (char *)"#\\9",      (char *)"#\\:",      (char *)"#\\;", 
        (char *)"#\\<",      (char *)"#\\=",      (char *)"#\\>",      (char *)"#\\?", 
        (char *)"#\\@",      (char *)"#\\A",      (char *)"#\\B",      (char *)"#\\C", 
        (char *)"#\\D",      (char *)"#\\E",      (char *)"#\\F",      (char *)"#\\G", 
        (char *)"#\\H",      (char *)"#\\I",      (char *)"#\\J",      (char *)"#\\K", 
        (char *)"#\\L",      (char *)"#\\M",      (char *)"#\\N",      (char *)"#\\O", 
        (char *)"#\\P",      (char *)"#\\Q",      (char *)"#\\R",      (char *)"#\\S", 
        (char *)"#\\T",      (char *)"#\\U",      (char *)"#\\V",      (char *)"#\\W", 
        (char *)"#\\X",      (char *)"#\\Y",      (char *)"#\\Z",      (char *)"#\\[", 
        (char *)"#\\\\",      (char *)"#\\]",      (char *)"#\\^",      (char *)"#\\_", 
        (char *)"#\\`",      (char *)"#\\a",      (char *)"#\\b",      (char *)"#\\c", 
        (char *)"#\\d",      (char *)"#\\e",      (char *)"#\\f",      (char *)"#\\g", 
        (char *)"#\\h",      (char *)"#\\i",      (char *)"#\\j",      (char *)"#\\k", 
        (char *)"#\\l",      (char *)"#\\m",      (char *)"#\\n",      (char *)"#\\o", 
        (char *)"#\\p",      (char *)"#\\q",      (char *)"#\\r",      (char *)"#\\s", 
        (char *)"#\\t",      (char *)"#\\u",      (char *)"#\\v",      (char *)"#\\w", 
        (char *)"#\\x",      (char *)"#\\y",      (char *)"#\\z",      (char *)"#\\{", 
        (char *)"#\\|",      (char *)"#\\}",      (char *)"#\\~",      (char *)"#\\del"};
#line 58 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-print.c"
static void print(FILE *fh , ikptr x ) 
{ 
  int tmp ;
  unsigned long i ;
  ikptr fst ;
  ikptr len ;
  ikptr data ;
  ikptr i___0 ;
  ikptr str ;
  ikptr fxlen ;
  int len___0 ;
  int tmp___0 ;
  int *data___0 ;
  int i___1 ;
  char c ;
  ikptr d ;
  ikptr fxlen___0 ;
  int len___1 ;
  int tmp___1 ;
  int *data___1 ;
  int i___2 ;
  char c___0 ;
  ikptr fxlen___1 ;
  int len___2 ;
  int tmp___2 ;
  unsigned char *data___2 ;
  int i___3 ;

  {
#line 60
  if ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 61
    if ((int )sizeof(ikptr ) == 4) {
#line 61
      tmp = 2;
    } else {
#line 61
      tmp = 3;
    }
    {
#line 61
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%ld", (long )x >> tmp);
    }
  } else
#line 63
  if (x == 47UL) {
    {
#line 64
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#f");
    }
  } else
#line 66
  if (x == 63UL) {
    {
#line 67
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#t");
    }
  } else
#line 69
  if (x == 79UL) {
    {
#line 70
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"()");
    }
  } else
#line 72
  if ((255 & (int )x) == 15) {
#line 73
    i = (unsigned long )((long )x >> 8);
#line 74
    if (i < 128UL) {
      {
#line 75
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%s",
              char_string[i]);
      }
    } else {
      {
#line 77
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#\\x%lx",
              i);
      }
    }
  } else
#line 86
  if (((int )x & 7) == 5) {
#line 87
    fst = *((ikptr *)((long )x + -5L) + 0);
#line 88
    if ((fst & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 89
      len = fst;
#line 90
      if (len == 0UL) {
        {
#line 91
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#()");
        }
      } else {
        {
#line 93
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#(");
#line 94
        data = x + (ikptr )((int )sizeof(ikptr ) - 5);
#line 95
        print(fh, *((ikptr *)((long )data) + 0));
#line 96
        i___0 = (ikptr )((int )sizeof(ikptr ));
        }
        {
#line 97
        while (1) {
          while_continue: /* CIL Label */ ;
#line 97
          if (! (i___0 < len)) {
#line 97
            goto while_break;
          }
          {
#line 98
          fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)" ");
#line 99
          print(fh, *((ikptr *)((long )data + (long )i___0) + 0));
#line 100
          i___0 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 102
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)")");
        }
      }
    } else
#line 104
    if (fst == 95UL) {
#line 105
      str = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 106
      fxlen = *((ikptr *)((long )str + -6L) + 0);
#line 107
      if ((int )sizeof(ikptr ) == 4) {
#line 107
        tmp___0 = 2;
      } else {
#line 107
        tmp___0 = 3;
      }
#line 107
      len___0 = (int )((long )fxlen >> tmp___0);
#line 108
      data___0 = (int *)(str + (ikptr )((int )sizeof(ikptr ) - 6));
#line 110
      i___1 = 0;
      {
#line 110
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 110
        if (! (i___1 < len___0)) {
#line 110
          goto while_break___0;
        }
        {
#line 111
        c = (char )(*(data___0 + i___1) >> 8);
#line 112
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%c",
                (int )c);
#line 110
        i___1 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 115
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#<unknown fst=0x%p>",
              (void *)fst);
      }
    }
  } else
#line 118
  if (((long )x & 7L) == 3L) {
    {
#line 119
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#<procedure>");
    }
  } else
#line 121
  if (((long )x & 7L) == 1L) {
    {
#line 122
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"(");
#line 123
    print(fh, *((ikptr *)((long )x + -1L) + 0));
#line 124
    d = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0);
    }
    {
#line 126
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 127
      if (((long )d & 7L) == 1L) {
        {
#line 128
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)" ");
#line 129
        print(fh, *((ikptr *)((long )d + -1L) + 0));
#line 130
        d = *((ikptr *)((long )d + (long )((int )sizeof(ikptr ) - 1)) + 0);
        }
      } else
#line 132
      if (d == 79UL) {
        {
#line 133
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)")");
        }
#line 134
        return;
      } else {
        {
#line 137
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)" . ");
#line 138
        print(fh, d);
#line 139
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)")");
        }
#line 140
        return;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 144
  if (((int )x & 7) == 6) {
#line 145
    fxlen___0 = *((ikptr *)((long )x + -6L) + 0);
#line 146
    if ((int )sizeof(ikptr ) == 4) {
#line 146
      tmp___1 = 2;
    } else {
#line 146
      tmp___1 = 3;
    }
    {
#line 146
    len___1 = (int )((long )fxlen___0 >> tmp___1);
#line 147
    data___1 = (int *)(x + (ikptr )((int )sizeof(ikptr ) - 6));
#line 148
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\"");
#line 150
    i___2 = 0;
    }
    {
#line 150
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 150
      if (! (i___2 < len___1)) {
#line 150
        goto while_break___2;
      }
#line 151
      c___0 = (char )(*(data___1 + i___2) >> 8);
#line 152
      if ((int )c___0 == 92) {
        {
#line 153
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\\");
        }
      } else
#line 152
      if ((int )c___0 == 34) {
        {
#line 153
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\\");
        }
      }
      {
#line 155
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%c",
              (int )c___0);
#line 150
      i___2 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 157
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\"");
    }
  } else
#line 159
  if (((int )x & 7) == 2) {
#line 160
    fxlen___1 = *((ikptr *)((long )x + -2L) + 0);
#line 161
    if ((int )sizeof(ikptr ) == 4) {
#line 161
      tmp___2 = 2;
    } else {
#line 161
      tmp___2 = 3;
    }
    {
#line 161
    len___2 = (int )((long )fxlen___1 >> tmp___2);
#line 162
    data___2 = (unsigned char *)(x + 6UL);
#line 163
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#vu8(");
#line 165
    i___3 = 0;
    }
    {
#line 165
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 165
      if (! (i___3 < len___2 - 1)) {
#line 165
        goto while_break___3;
      }
      {
#line 166
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%d ",
              (int )*(data___2 + i___3));
#line 165
      i___3 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 168
    if (i___3 < len___2) {
      {
#line 169
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%d",
              (int )*(data___2 + i___3));
      }
    }
    {
#line 171
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)")");
    }
  } else {
    {
#line 174
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#<unknown>");
    }
  }
#line 176
  return;
}
}
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
static int list_length(ikptr x ) 
{ 
  int n ;

  {
#line 33
  n = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (((int )x & 7) == 1)) {
#line 34
      goto while_break;
    }
#line 35
    n ++;
#line 36
    x = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0);
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (n);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
static char **list_to_vec(ikptr x ) 
{ 
  int n ;
  int tmp ;
  char **vec ;
  void *tmp___0 ;
  int i ;

  {
  {
#line 43
  tmp = list_length(x);
#line 43
  n = tmp;
#line 44
  tmp___0 = malloc((unsigned long )(n + 1) * sizeof(char *));
#line 44
  vec = (char **)tmp___0;
  }
#line 45
  if ((unsigned long )vec == (unsigned long )((void *)0)) {
    {
#line 45
    exit(-1);
    }
  }
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < n)) {
#line 47
      goto while_break;
    }
#line 48
    *(vec + i) = (char *)((long )*((ikptr *)((long )x + -1L) + 0)) + 6;
#line 49
    x = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  *(vec + n) = (char *)0;
#line 52
  return (vec);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
static int execvpe_(char const   *cmd , char * const  *argv , char * const  *envp ) 
{ 
  char *path ;
  char const   *searchpath ;
  char const   *sep ;
  size_t cmd_len ;
  char *tmp ;
  size_t prefix_len ;
  size_t path_len ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 57
  path = (char *)((void *)0);
#line 62
  if ((int const   )*(cmd + 0) == 47) {
    {
#line 63
    execve(cmd, argv, envp);
    }
  }
  {
#line 65
  tmp = getenv("PATH");
#line 65
  searchpath = (char const   *)tmp;
  }
#line 66
  if ((unsigned long )searchpath == (unsigned long )((void *)0)) {
#line 67
    searchpath = "/bin:/usr/bin";
  }
  {
#line 69
  cmd_len = strlen(cmd);
#line 71
  sep = (char const   *)((void *)0);
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    tmp___0 = strchr(searchpath, ':');
#line 75
    sep = (char const   *)tmp___0;
    }
#line 76
    if ((unsigned long )sep == (unsigned long )((void *)0)) {
      {
#line 77
      tmp___1 = strlen(searchpath);
#line 77
      sep = searchpath + tmp___1;
      }
    }
    {
#line 80
    prefix_len = (size_t )(sep - searchpath);
#line 81
    path_len = (prefix_len + cmd_len) + 2UL;
#line 82
    tmp___2 = realloc((void *)path, path_len);
#line 82
    path = (char *)tmp___2;
    }
#line 83
    if ((unsigned long )path == (unsigned long )((void *)0)) {
      {
#line 84
      tmp___3 = __errno_location();
#line 84
      *tmp___3 = 12;
      }
#line 85
      return (-1);
    }
    {
#line 87
    memcpy((void */* __restrict  */)path, (void const   */* __restrict  */)searchpath,
           prefix_len);
    }
#line 88
    if (prefix_len == 0UL) {
      {
#line 89
      memcpy((void */* __restrict  */)(path + prefix_len), (void const   */* __restrict  */)cmd,
             cmd_len + 1UL);
      }
    } else
#line 88
    if ((int const   )*(searchpath + (prefix_len - 1UL)) == 47) {
      {
#line 89
      memcpy((void */* __restrict  */)(path + prefix_len), (void const   */* __restrict  */)cmd,
             cmd_len + 1UL);
      }
    } else {
      {
#line 91
      *(path + prefix_len) = (char )'/';
#line 92
      memcpy((void */* __restrict  */)((path + prefix_len) + 1), (void const   */* __restrict  */)cmd,
             cmd_len + 1UL);
      }
    }
    {
#line 95
    execve((char const   *)path, argv, envp);
#line 96
    tmp___4 = __errno_location();
    }
    {
#line 100
    if (*tmp___4 == 26) {
#line 100
      goto case_26;
    }
#line 100
    if (*tmp___4 == 12) {
#line 100
      goto case_26;
    }
#line 100
    if (*tmp___4 == 8) {
#line 100
      goto case_26;
    }
#line 100
    if (*tmp___4 == 7) {
#line 100
      goto case_26;
    }
#line 96
    goto switch_break;
    case_26: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 101
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 104
    searchpath = sep + 1;
#line 72
    if (! ((int const   )*(sep + 0) != 0)) {
#line 72
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if (path) {
    {
#line 107
    free((void *)path);
    }
  }
#line 109
  return (-1);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
ikptr ikrt_process(ikptr rvec , ikptr env , ikptr cmd , ikptr argv ) 
{ 
  int infds[2] ;
  int outfds[2] ;
  int errfds[2] ;
  int search_p ;
  int stdin_fd ;
  int tmp ;
  int stdout_fd ;
  int tmp___0 ;
  int stderr_fd ;
  int tmp___1 ;
  ikptr tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  int tmp___5 ;
  ikptr tmp___6 ;
  int tmp___7 ;
  pid_t pid ;
  __pid_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *cmd_str ;
  char **env_strs ;
  char **tmp___18 ;
  char **tmp___19 ;
  char **argv_strs ;
  char **tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  ikptr tmp___27 ;

  {
#line 117
  search_p = *((ikptr *)((long )rvec + (long )((int )sizeof(ikptr ) - 5)) + 0) != 47UL;
#line 118
  if ((int )sizeof(ikptr ) == 4) {
#line 118
    tmp = 2;
  } else {
#line 118
    tmp = 3;
  }
#line 118
  stdin_fd = (int )((long )*((ikptr *)((long )rvec + (long )(((int )sizeof(ikptr ) - 5) + (int )sizeof(ikptr ))) + 0) >> tmp);
#line 119
  if ((int )sizeof(ikptr ) == 4) {
#line 119
    tmp___0 = 2;
  } else {
#line 119
    tmp___0 = 3;
  }
#line 119
  stdout_fd = (int )((long )*((ikptr *)((long )rvec + (long )(((int )sizeof(ikptr ) - 5) + 2 * (int )sizeof(ikptr ))) + 0) >> tmp___0);
#line 120
  if ((int )sizeof(ikptr ) == 4) {
#line 120
    tmp___1 = 2;
  } else {
#line 120
    tmp___1 = 3;
  }
#line 120
  stderr_fd = (int )((long )*((ikptr *)((long )rvec + (long )(((int )sizeof(ikptr ) - 5) + 3 * (int )sizeof(ikptr ))) + 0) >> tmp___1);
#line 122
  if (stdin_fd < 0) {
    {
#line 122
    tmp___3 = pipe((int *)(infds));
    }
#line 122
    if (tmp___3) {
      {
#line 122
      tmp___2 = ik_errno_to_code();
      }
#line 122
      return (tmp___2);
    }
  }
#line 123
  if (stdout_fd < 0) {
    {
#line 123
    tmp___5 = pipe((int *)(outfds));
    }
#line 123
    if (tmp___5) {
      {
#line 123
      tmp___4 = ik_errno_to_code();
      }
#line 123
      return (tmp___4);
    }
  }
#line 124
  if (stderr_fd < 0) {
    {
#line 124
    tmp___7 = pipe((int *)(errfds));
    }
#line 124
    if (tmp___7) {
      {
#line 124
      tmp___6 = ik_errno_to_code();
      }
#line 124
      return (tmp___6);
    }
  }
  {
#line 125
  tmp___8 = fork();
#line 125
  pid = tmp___8;
  }
#line 126
  if (pid == 0) {
#line 128
    if (stdin_fd < 0) {
      {
#line 129
      tmp___9 = close(infds[1]);
      }
#line 129
      if (tmp___9) {
        {
#line 129
        exit(1);
        }
      }
#line 130
      stdin_fd = infds[0];
    }
#line 132
    if (stdout_fd < 0) {
      {
#line 133
      tmp___10 = close(outfds[0]);
      }
#line 133
      if (tmp___10) {
        {
#line 133
        exit(1);
        }
      }
#line 134
      stdout_fd = outfds[1];
    }
#line 136
    if (stderr_fd < 0) {
      {
#line 137
      tmp___11 = close(errfds[0]);
      }
#line 137
      if (tmp___11) {
        {
#line 137
        exit(1);
        }
      }
#line 138
      stderr_fd = errfds[1];
    }
#line 140
    if (stdin_fd != 0) {
      {
#line 141
      tmp___12 = close(0);
      }
#line 141
      if (tmp___12) {
        {
#line 141
        exit(1);
        }
      }
      {
#line 142
      tmp___13 = dup(stdin_fd);
      }
#line 142
      if (tmp___13 == -1) {
        {
#line 142
        exit(1);
        }
      }
    }
#line 144
    if (stdout_fd != 1) {
      {
#line 145
      tmp___14 = close(1);
      }
#line 145
      if (tmp___14) {
        {
#line 145
        exit(1);
        }
      }
      {
#line 146
      tmp___15 = dup(stdout_fd);
      }
#line 146
      if (tmp___15 == -1) {
        {
#line 146
        exit(1);
        }
      }
    }
#line 148
    if (stderr_fd != 2) {
      {
#line 149
      tmp___16 = close(2);
      }
#line 149
      if (tmp___16) {
        {
#line 149
        exit(2);
        }
      }
      {
#line 150
      tmp___17 = dup(stderr_fd);
      }
#line 150
      if (tmp___17 == -1) {
        {
#line 150
        exit(1);
        }
      }
    }
#line 152
    cmd_str = (char *)((long )(cmd + 6UL));
#line 153
    if (env == 47UL) {
#line 153
      tmp___19 = (char **)0;
    } else {
      {
#line 153
      tmp___18 = list_to_vec(env);
#line 153
      tmp___19 = tmp___18;
      }
    }
    {
#line 153
    env_strs = tmp___19;
#line 154
    tmp___20 = list_to_vec(argv);
#line 154
    argv_strs = tmp___20;
    }
#line 155
    if (env_strs) {
#line 155
      if (search_p) {
        {
#line 156
        execvpe_((char const   *)cmd_str, (char * const  *)argv_strs, (char * const  *)env_strs);
        }
      } else {
#line 155
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 157
    if (env_strs) {
      {
#line 158
      execve((char const   *)cmd_str, (char * const  *)argv_strs, (char * const  *)env_strs);
      }
    } else
#line 159
    if (search_p) {
      {
#line 160
      execvp((char const   *)cmd_str, (char * const  *)argv_strs);
      }
    } else {
      {
#line 162
      execv((char const   *)cmd_str, (char * const  *)argv_strs);
      }
    }
    {
#line 163
    tmp___21 = __errno_location();
#line 163
    tmp___22 = strerror(*tmp___21);
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to exec %s: %s\n",
            (char *)((long )(cmd + 6UL)), tmp___22);
#line 166
    exit(-1);
    }
  } else
#line 167
  if (pid > 0) {
#line 169
    if ((int )sizeof(ikptr ) == 4) {
#line 169
      tmp___23 = 2;
    } else {
#line 169
      tmp___23 = 3;
    }
#line 169
    *((ikptr *)((long )rvec + (long )((int )sizeof(ikptr ) - 5)) + 0) = (ikptr )((long )pid << tmp___23);
#line 171
    if (stdin_fd < 0) {
      {
#line 172
      close(infds[0]);
      }
#line 173
      if ((int )sizeof(ikptr ) == 4) {
#line 173
        tmp___24 = 2;
      } else {
#line 173
        tmp___24 = 3;
      }
#line 173
      *((ikptr *)((long )rvec + (long )(((int )sizeof(ikptr ) - 5) + (int )sizeof(ikptr ))) + 0) = (ikptr )((long )infds[1] << tmp___24);
    }
#line 175
    if (stdout_fd < 0) {
      {
#line 176
      close(outfds[1]);
      }
#line 177
      if ((int )sizeof(ikptr ) == 4) {
#line 177
        tmp___25 = 2;
      } else {
#line 177
        tmp___25 = 3;
      }
#line 177
      *((ikptr *)((long )rvec + (long )(((int )sizeof(ikptr ) - 5) + 2 * (int )sizeof(ikptr ))) + 0) = (ikptr )((long )outfds[0] << tmp___25);
    }
#line 179
    if (stderr_fd < 0) {
      {
#line 180
      close(errfds[1]);
      }
#line 181
      if ((int )sizeof(ikptr ) == 4) {
#line 181
        tmp___26 = 2;
      } else {
#line 181
        tmp___26 = 3;
      }
#line 181
      *((ikptr *)((long )rvec + (long )(((int )sizeof(ikptr ) - 5) + 3 * (int )sizeof(ikptr ))) + 0) = (ikptr )((long )errfds[0] << tmp___26);
    }
#line 183
    return (rvec);
  } else {
    {
#line 185
    tmp___27 = ik_errno_to_code();
    }
#line 185
    return (tmp___27);
  }
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
static signal_info signal_info_table[28]  = 
#line 196
  {      {6, (ikptr )(1L << 3)}, 
        {14, (ikptr )(2L << 3)}, 
        {7, (ikptr )(3L << 3)}, 
        {17, (ikptr )(4L << 3)}, 
        {18, (ikptr )(5L << 3)}, 
        {8, (ikptr )(6L << 3)}, 
        {1, (ikptr )(7L << 3)}, 
        {4, (ikptr )(8L << 3)}, 
        {2, (ikptr )(9L << 3)}, 
        {9, (ikptr )(10L << 3)}, 
        {13, (ikptr )(11L << 3)}, 
        {3, (ikptr )(12L << 3)}, 
        {11, (ikptr )(13L << 3)}, 
        {19, (ikptr )(14L << 3)}, 
        {15, (ikptr )(15L << 3)}, 
        {20, (ikptr )(16L << 3)}, 
        {21, (ikptr )(17L << 3)}, 
        {22, (ikptr )(18L << 3)}, 
        {10, (ikptr )(19L << 3)}, 
        {12, (ikptr )(20L << 3)}, 
        {29, (ikptr )(21L << 3)}, 
        {27, (ikptr )(22L << 3)}, 
        {31, (ikptr )(23L << 3)}, 
        {5, (ikptr )(24L << 3)}, 
        {23, (ikptr )(25L << 3)}, 
        {26, (ikptr )(26L << 3)}, 
        {24, (ikptr )(27L << 3)}, 
        {25, (ikptr )(28L << 3)}};
#line 233 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
ikptr ik_signal_num_to_code(int signum ) 
{ 
  signal_info *si ;
  int i ;
  int tmp ;

  {
#line 237
  i = 0;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < 28)) {
#line 237
      goto while_break;
    }
#line 238
    si = & signal_info_table[i];
#line 239
    if (si->n == signum) {
#line 240
      return (si->c);
    }
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 243
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n*** ik_signal_num_to_code: Don\'t know signal %d ***\n\n",
          signum);
  }
#line 245
  if ((int )sizeof(ikptr ) == 4) {
#line 245
    tmp = 2;
  } else {
#line 245
    tmp = 3;
  }
#line 245
  return ((ikptr )(99999L << tmp));
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
int ik_signal_code_to_num(ikptr sigcode ) 
{ 
  signal_info *si ;
  int i ;
  int tmp ;

  {
#line 252
  i = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i < 28)) {
#line 252
      goto while_break;
    }
#line 253
    si = & signal_info_table[i];
#line 254
    if (si->c == sigcode) {
#line 255
      return (si->n);
    }
#line 252
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  if ((int )sizeof(ikptr ) == 4) {
#line 258
    tmp = 2;
  } else {
#line 258
    tmp = 3;
  }
  {
#line 258
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ik_signal_code_to_num: Don\'t know code %ld\n",
          (long )sigcode >> tmp);
#line 260
  exit(1);
  }
#line 261
  return (0);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
ikptr ikrt_kill(ikptr pid , ikptr sigcode ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ikptr tmp___3 ;

  {
  {
#line 266
  tmp = ik_signal_code_to_num(sigcode);
  }
#line 266
  if ((int )sizeof(ikptr ) == 4) {
#line 266
    tmp___0 = 2;
  } else {
#line 266
    tmp___0 = 3;
  }
  {
#line 266
  tmp___1 = kill((pid_t )((long )pid >> tmp___0), tmp);
#line 266
  r = tmp___1;
  }
#line 267
  if (r == 0) {
#line 268
    if ((int )sizeof(ikptr ) == 4) {
#line 268
      tmp___2 = 2;
    } else {
#line 268
      tmp___2 = 3;
    }
#line 268
    return ((ikptr )0L);
  }
  {
#line 270
  tmp___3 = ik_errno_to_code();
  }
#line 270
  return (tmp___3);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
ikptr ikrt_waitpid(ikptr rvec , ikptr pid , ikptr block ) 
{ 
  int status ;
  int options ;
  pid_t r ;
  int tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  union __anonunion_67 __constr_expr_0 ;
  int tmp___2 ;
  union __anonunion_68 __constr_expr_1 ;
  union __anonunion_69 __constr_expr_2 ;
  union __anonunion_70 __constr_expr_3 ;
  int tmp___3 ;
  ikptr tmp___4 ;

  {
#line 276
  options = 0;
#line 277
  if (block == 47UL) {
#line 278
    options = 1;
  }
#line 280
  if ((int )sizeof(ikptr ) == 4) {
#line 280
    tmp = 2;
  } else {
#line 280
    tmp = 3;
  }
  {
#line 280
  tmp___0 = waitpid((__pid_t )((long )pid >> tmp), & status, options);
#line 280
  r = tmp___0;
  }
#line 281
  if (r > 0) {
#line 282
    if ((int )sizeof(ikptr ) == 4) {
#line 282
      tmp___1 = 2;
    } else {
#line 282
      tmp___1 = 3;
    }
#line 282
    *((ikptr *)((long )rvec + (long )((int )sizeof(ikptr ) - 5)) + 0) = (ikptr )((long )r << tmp___1);
#line 283
    __constr_expr_1.__in = status;
#line 283
    if ((__constr_expr_1.__i & 127) == 0) {
#line 284
      __constr_expr_0.__in = status;
#line 284
      if ((int )sizeof(ikptr ) == 4) {
#line 284
        tmp___2 = 2;
      } else {
#line 284
        tmp___2 = 3;
      }
#line 284
      *((ikptr *)((long )rvec + (long )(((int )sizeof(ikptr ) - 5) + (int )sizeof(ikptr ))) + 0) = (ikptr )((long )((__constr_expr_0.__i & 65280) >> 8) << tmp___2);
    }
#line 286
    __constr_expr_3.__in = status;
#line 286
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
      {
#line 287
      __constr_expr_2.__in = status;
#line 287
      *((ikptr *)((long )rvec + (long )(((int )sizeof(ikptr ) - 5) + 2 * (int )sizeof(ikptr ))) + 0) = ik_signal_num_to_code(__constr_expr_2.__i & 127);
      }
    }
#line 290
    return (rvec);
  } else
#line 291
  if (r == 0) {
#line 292
    if ((int )sizeof(ikptr ) == 4) {
#line 292
      tmp___3 = 2;
    } else {
#line 292
      tmp___3 = 3;
    }
#line 292
    return ((ikptr )0L);
  } else {
    {
#line 294
    tmp___4 = ik_errno_to_code();
    }
#line 294
    return (tmp___4);
  }
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static long page_idx(void *x ) 
{ 
  unsigned long xi ;

  {
#line 26
  xi = (unsigned long )x;
#line 27
  return ((long )(xi >> 12));
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static void verify_code(char *x , char *base , unsigned int *svec , unsigned int *dvec ) 
{ 
  ikptr rvec ;
  ikptr codesize ;
  ikptr freevars ;
  unsigned int rs ;
  long tmp ;
  long tmp___0 ;
  unsigned int cs ;
  long tmp___1 ;
  long tmp___2 ;
  int cgen ;
  int rgen ;
  unsigned int d ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 51
  rvec = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 53
  codesize = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ))) + 0);
#line 54
  codesize = codesize;
#line 57
  freevars = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ))) + 0);
#line 58
  freevars = freevars;
#line 62
  tmp = page_idx((void *)((long )rvec));
#line 62
  tmp___0 = page_idx((void *)base);
#line 62
  rs = *(svec + (tmp - tmp___0));
#line 63
  tmp___1 = page_idx((void *)x);
#line 63
  tmp___2 = page_idx((void *)base);
#line 63
  cs = *(svec + (tmp___1 - tmp___2));
#line 64
  cgen = (int )(cs & 15U);
#line 65
  rgen = (int )(rs & 15U);
  }
#line 66
  if (rgen < cgen) {
    {
#line 67
    tmp___3 = page_idx((void *)x);
#line 67
    tmp___4 = page_idx((void *)base);
#line 67
    d = *(dvec + (tmp___3 - tmp___4));
#line 68
    d &= d;
    }
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static void verify_object(ikptr x , char *base , unsigned int *svec , unsigned int *dvec ) 
{ 


  {
#line 77
  x = x;
#line 77
  base = base;
#line 77
  svec = svec;
#line 77
  dvec = dvec;
#line 78
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_code_small(char *p , int s , unsigned int d , char *base , unsigned int *svec ,
                               unsigned int *dvec ) 
{ 
  char *q ;
  ikptr fst ;
  int code_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 84
  q = p + 4096;
#line 85
  s = s;
#line 85
  d = d;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! ((unsigned long )p < (unsigned long )q)) {
#line 86
      goto while_break;
    }
#line 87
    fst = *((ikptr *)((long )p) + 0);
#line 88
    if (fst == 47UL) {
#line 90
      if ((int )sizeof(ikptr ) == 4) {
#line 90
        tmp = 2;
      } else {
#line 90
        tmp = 3;
      }
      {
#line 90
      code_size = (int )((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp);
#line 92
      verify_code(p, base, svec, dvec);
      }
#line 93
      if ((int )sizeof(ikptr ) == 4) {
#line 93
        tmp___0 = 2;
      } else {
#line 93
        tmp___0 = 3;
      }
#line 93
      if ((int )sizeof(ikptr ) == 4) {
#line 93
        tmp___1 = 2;
      } else {
#line 93
        tmp___1 = 3;
      }
#line 93
      p += ((((code_size + 6 * (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___0 + 1)) << (tmp___1 + 1);
    } else {
#line 95
      p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if ((unsigned long )p != (unsigned long )q) {
    {
#line 99
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"code extended beyond a page in %p, %p\n",
            p, q);
    }
  }
#line 102
  return (q);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_code_large(char *p , unsigned int s , unsigned int d , char *base ,
                               unsigned int *svec , unsigned int *dvec ) 
{ 
  ikptr fst ;
  int code_size ;
  int tmp ;
  char *end ;

  {
#line 108
  s = s;
#line 108
  d = d;
#line 109
  fst = *((ikptr *)((long )p) + 0);
#line 110
  fst = fst;
#line 112
  if ((int )sizeof(ikptr ) == 4) {
#line 112
    tmp = 2;
  } else {
#line 112
    tmp = 3;
  }
  {
#line 112
  code_size = (int )((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp);
#line 114
  verify_code(p, base, svec, dvec);
#line 116
  end = (p + code_size) + 6 * (int )sizeof(ikptr );
  }
#line 117
  return ((char *)(((4095UL + (unsigned long )end) >> 12) << 12));
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_code_page(char *p , unsigned int s , unsigned int d , char *base ,
                              unsigned int *svec , unsigned int *dvec ) 
{ 
  ikptr fst ;
  int code_size ;
  int tmp ;
  int obj_size ;
  int tmp___0 ;
  int tmp___1 ;
  char *result ;

  {
#line 123
  fst = *((ikptr *)((long )p) + 0);
#line 124
  fst = fst;
#line 125
  if (fst != 47UL) {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"non code object with tag %p found\n",
            (void *)((long )fst));
#line 128
    exit(-1);
    }
  }
#line 130
  if ((int )sizeof(ikptr ) == 4) {
#line 130
    tmp = 2;
  } else {
#line 130
    tmp = 3;
  }
#line 130
  code_size = (int )((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp);
#line 132
  if ((int )sizeof(ikptr ) == 4) {
#line 132
    tmp___0 = 2;
  } else {
#line 132
    tmp___0 = 3;
  }
#line 132
  if ((int )sizeof(ikptr ) == 4) {
#line 132
    tmp___1 = 2;
  } else {
#line 132
    tmp___1 = 3;
  }
#line 132
  obj_size = ((((code_size + 6 * (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___0 + 1)) << (tmp___1 + 1);
#line 134
  if (obj_size <= 4096) {
    {
#line 135
    result = verify_code_small(p, (int )s, d, base, svec, dvec);
    }
  } else {
    {
#line 137
    result = verify_code_large(p, s, d, base, svec, dvec);
    }
  }
#line 140
  return (result);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_pointers_page(char *p , unsigned int s , unsigned int d , char *base ,
                                  unsigned int *svec , unsigned int *dvec ) 
{ 
  int i ;

  {
#line 149
  s = s;
#line 149
  d = d;
#line 151
  i = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < 4096)) {
#line 152
      goto while_break;
    }
    {
#line 153
    verify_object(*((ikptr *)((long )p + (long )i) + 0), base, svec, dvec);
#line 154
    i += (int )sizeof(ikptr );
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (p + 4096);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_page(char *p , char *base , unsigned int *svec , unsigned int *dvec ) 
{ 
  int idx ;
  long tmp ;
  long tmp___0 ;
  unsigned int s ;
  unsigned int d ;
  int type ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 163
  tmp = page_idx((void *)p);
#line 163
  tmp___0 = page_idx((void *)base);
#line 163
  idx = (int )(tmp - tmp___0);
#line 164
  s = *(svec + idx);
#line 165
  d = *(dvec + idx);
#line 169
  type = (int )(s & 3840U);
  }
#line 170
  if (type == 0) {
#line 171
    return (p + 4096);
  }
#line 174
  if (type == 1280) {
    {
#line 175
    tmp___1 = verify_code_page(p, s, d, base, svec, dvec);
    }
#line 175
    return (tmp___1);
  } else
#line 177
  if (type == 768) {
    {
#line 178
    tmp___2 = verify_pointers_page(p, s, d, base, svec, dvec);
    }
#line 178
    return (tmp___2);
  } else
#line 180
  if (type == 1536) {
    {
#line 181
    tmp___3 = verify_pointers_page(p, s, d, base, svec, dvec);
    }
#line 181
    return (tmp___3);
  } else
#line 183
  if (type == 1792) {
    {
#line 184
    tmp___4 = verify_pointers_page(p, s, d, base, svec, dvec);
    }
#line 184
    return (tmp___4);
  } else
#line 186
  if (type == 1024) {
#line 188
    return (p + 4096);
  } else
#line 190
  if (type == 256) {
#line 192
    return (p + 4096);
  } else
#line 194
  if (type == 512) {
#line 196
    return (p + 4096);
  }
  {
#line 198
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"type=0x%08x\n",
          type);
#line 199
  exit(-1);
  }
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
void verify_integrity(ikpcb *pcb , char *where ) 
{ 
  char *mem_base ;
  char *mem_end ;
  unsigned int *seg_vec ;
  unsigned int *dir_vec ;
  char *mem ;

  {
  {
#line 204
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verifying in %s...\n",
          where);
#line 205
  mem_base = (char *)((long )pcb->memory_base);
#line 206
  mem_end = (char *)((long )pcb->memory_end);
#line 207
  seg_vec = pcb->segment_vector_base;
#line 208
  dir_vec = pcb->dirty_vector_base;
#line 209
  mem = mem_base;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! ((unsigned long )mem < (unsigned long )mem_end)) {
#line 210
      goto while_break;
    }
    {
#line 211
    mem = verify_page(mem, mem_base, seg_vec, dir_vec);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 213
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"verify_ok in %s\n",
          where);
  }
#line 214
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static void extend_table_maybe___0(ikptr p , unsigned long size , ikpcb *pcb ) 
{ 
  ikptr q ;
  unsigned long new_lo ;
  unsigned long old_lo ;
  unsigned long hi ;
  unsigned long new_vec_size ;
  unsigned long old_vec_size ;
  ikptr v ;
  ikptr tmp ;
  ikptr s ;
  ikptr tmp___0 ;
  unsigned long lo ;
  unsigned long old_hi ;
  unsigned long new_hi ;
  unsigned long new_vec_size___0 ;
  unsigned long old_vec_size___0 ;
  ikptr v___0 ;
  ikptr tmp___1 ;
  ikptr s___0 ;
  ikptr tmp___2 ;

  {
#line 60
  q = p + size;
#line 61
  if (p < pcb->memory_base) {
    {
#line 62
    new_lo = p >> 22;
#line 63
    old_lo = pcb->memory_base >> 22;
#line 64
    hi = pcb->memory_end >> 22;
#line 65
    new_vec_size = (hi - new_lo) * 4096UL;
#line 66
    old_vec_size = (hi - old_lo) * 4096UL;
#line 67
    tmp = ik_mmap(new_vec_size);
#line 67
    v = tmp;
#line 68
    bzero((void *)((char *)((long )v)), new_vec_size - old_vec_size);
#line 69
    memcpy((void */* __restrict  */)((char *)((long )((v + new_vec_size) - old_vec_size))),
           (void const   */* __restrict  */)((char *)((long )pcb->dirty_vector_base)),
           old_vec_size);
#line 72
    ik_munmap((ikptr )((long )pcb->dirty_vector_base), old_vec_size);
#line 73
    pcb->dirty_vector_base = (unsigned int *)((long )v);
#line 74
    pcb->dirty_vector = v - new_lo * 4096UL;
#line 75
    tmp___0 = ik_mmap(new_vec_size);
#line 75
    s = tmp___0;
#line 76
    bzero((void *)((char *)((long )s)), new_vec_size - old_vec_size);
#line 77
    memcpy((void */* __restrict  */)((char *)((long )((s + new_vec_size) - old_vec_size))),
           (void const   */* __restrict  */)((char *)((long )pcb->segment_vector_base)),
           old_vec_size);
#line 80
    ik_munmap((ikptr )((long )pcb->segment_vector_base), old_vec_size);
#line 81
    pcb->segment_vector_base = (unsigned int *)((long )s);
#line 82
    pcb->segment_vector = (unsigned int *)((long )(s - new_lo * 4096UL));
#line 83
    pcb->memory_base = new_lo * 4194304UL;
    }
  } else
#line 85
  if (q >= pcb->memory_end) {
    {
#line 86
    lo = pcb->memory_base >> 22;
#line 87
    old_hi = pcb->memory_end >> 22;
#line 88
    new_hi = ((q + 4194304UL) - 1UL) >> 22;
#line 89
    new_vec_size___0 = (new_hi - lo) * 4096UL;
#line 90
    old_vec_size___0 = (old_hi - lo) * 4096UL;
#line 91
    tmp___1 = ik_mmap(new_vec_size___0);
#line 91
    v___0 = tmp___1;
#line 92
    memcpy((void */* __restrict  */)((char *)((long )v___0)), (void const   */* __restrict  */)((char *)((long )pcb->dirty_vector_base)),
           old_vec_size___0);
#line 95
    bzero((void *)((char *)((long )(v___0 + old_vec_size___0))), new_vec_size___0 - old_vec_size___0);
#line 96
    ik_munmap((ikptr )((long )pcb->dirty_vector_base), old_vec_size___0);
#line 97
    pcb->dirty_vector_base = (unsigned int *)((long )v___0);
#line 98
    pcb->dirty_vector = v___0 - lo * 4096UL;
#line 99
    tmp___2 = ik_mmap(new_vec_size___0);
#line 99
    s___0 = tmp___2;
#line 100
    memcpy((void */* __restrict  */)((char *)((long )s___0)), (void const   */* __restrict  */)pcb->segment_vector_base,
           old_vec_size___0);
#line 101
    bzero((void *)((char *)((long )(s___0 + old_vec_size___0))), new_vec_size___0 - old_vec_size___0);
#line 102
    ik_munmap((ikptr )((long )pcb->segment_vector_base), old_vec_size___0);
#line 103
    pcb->segment_vector_base = (unsigned int *)((long )s___0);
#line 104
    pcb->segment_vector = (unsigned int *)(s___0 - lo * 4096UL);
#line 105
    pcb->memory_end = new_hi * 4194304UL;
    }
  }
#line 107
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static void set_segment_type___0(ikptr base , unsigned long size , unsigned int type ,
                                 ikpcb *pcb ) 
{ 
  unsigned int *p ;
  unsigned int *q ;

  {
#line 115
  p = pcb->segment_vector + (base >> 12);
#line 116
  q = p + (size >> 12);
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )p < (unsigned long )q)) {
#line 117
      goto while_break;
    }
#line 118
    *p = type;
#line 119
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static char const   *uuid_chars___0  =    "!$%&/0123456789<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
#line 530 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static int uuid_strlen___0  =    1;
#line 532 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static int fd___0  =    -1;
#line 721 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-runtime.c"
static char *mtname___0(unsigned int n ) 
{ 


  {
#line 723
  if (n == 256U) {
#line 723
    return ((char *)"HEAP_T");
  }
#line 724
  if (n == 512U) {
#line 724
    return ((char *)"STAK_T");
  }
#line 725
  if (n == 768U) {
#line 725
    return ((char *)"PTER_T");
  }
#line 726
  if (n == 1024U) {
#line 726
    return ((char *)"DATA_T");
  }
#line 727
  if (n == 1280U) {
#line 727
    return ((char *)"CODE_T");
  }
#line 728
  if (n == 0U) {
#line 728
    return ((char *)"      ");
  }
#line 729
  return ((char *)"WHAT_T");
}
}
#line 1060 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void copy_limbs___0(mp_limb_t *src , mp_limb_t *dst , int n1 , int n2 ) 
{ 


  {
  {
#line 1062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1062
    if (! (n1 < n2)) {
#line 1062
      goto while_break;
    }
#line 1063
    *(dst + n1) = *(src + n1);
#line 1064
    n1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1066
  return;
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void bits_compliment___0(mp_limb_t *src , mp_limb_t *dst , long n ) 
{ 
  mp_limb_t carry ;
  long i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1070
  carry = (mp_limb_t )1;
#line 1072
  i = 0L;
  {
#line 1072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1072
    if (! (i < n)) {
#line 1072
      goto while_break;
    }
#line 1073
    d = *(src + i);
#line 1074
    c = carry + ~ d;
#line 1075
    *(dst + i) = c;
#line 1076
    if (carry) {
#line 1076
      if (! d) {
#line 1076
        tmp = 1;
      } else {
#line 1076
        tmp = 0;
      }
    } else {
#line 1076
      tmp = 0;
    }
#line 1076
    carry = (mp_limb_t )tmp;
#line 1072
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1078
  return;
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void bits_compliment2___0(mp_limb_t *src , mp_limb_t *dst , int n1 , int n2 ) 
{ 
  mp_limb_t carry ;
  int i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;
  mp_limb_t d___0 ;
  mp_limb_t c___0 ;
  int tmp___0 ;

  {
#line 1082
  carry = (mp_limb_t )1;
#line 1084
  i = 0;
  {
#line 1084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1084
    if (! (i < n1)) {
#line 1084
      goto while_break;
    }
#line 1085
    d = *(src + i);
#line 1086
    c = carry + ~ d;
#line 1087
    *(dst + i) = c;
#line 1088
    if (carry) {
#line 1088
      if (! d) {
#line 1088
        tmp = 1;
      } else {
#line 1088
        tmp = 0;
      }
    } else {
#line 1088
      tmp = 0;
    }
#line 1088
    carry = (mp_limb_t )tmp;
#line 1084
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1090
  i = n1;
  {
#line 1090
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1090
    if (! (i < n2)) {
#line 1090
      goto while_break___0;
    }
#line 1091
    d___0 = (mp_limb_t )0;
#line 1092
    c___0 = carry + ~ d___0;
#line 1093
    *(dst + i) = c___0;
#line 1094
    if (carry) {
#line 1094
      if (! d___0) {
#line 1094
        tmp___0 = 1;
      } else {
#line 1094
        tmp___0 = 0;
      }
    } else {
#line 1094
      tmp___0 = 0;
    }
#line 1094
    carry = (mp_limb_t )tmp___0;
#line 1090
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1096
  return;
}
}
#line 1098 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int bits_compliment_carry___0(mp_limb_t *src , mp_limb_t *dst , int n1 , int n2 ,
                                     mp_limb_t carry ) 
{ 
  int i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1101
  i = n1;
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1101
    if (! (i < n2)) {
#line 1101
      goto while_break;
    }
#line 1102
    d = *(src + i);
#line 1103
    c = carry + ~ d;
#line 1104
    *(dst + i) = c;
#line 1105
    if (carry) {
#line 1105
      if (! d) {
#line 1105
        tmp = 1;
      } else {
#line 1105
        tmp = 0;
      }
    } else {
#line 1105
      tmp = 0;
    }
#line 1105
    carry = (mp_limb_t )tmp;
#line 1101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1107
  return ((int )carry);
}
}
#line 1113 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void bits_compliment_with_carry___0(mp_limb_t *src , mp_limb_t *dst , long n ,
                                           long carry ) 
{ 
  long i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1116
  i = 0L;
  {
#line 1116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1116
    if (! (i < n)) {
#line 1116
      goto while_break;
    }
#line 1117
    d = *(src + i);
#line 1118
    c = (mp_limb_t )carry + ~ d;
#line 1119
    *(dst + i) = c;
#line 1120
    if (carry) {
#line 1120
      if (! d) {
#line 1120
        tmp = 1;
      } else {
#line 1120
        tmp = 0;
      }
    } else {
#line 1120
      tmp = 0;
    }
#line 1120
    carry = (long )tmp;
#line 1116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1122
  return;
}
}
#line 1124 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void bits_compliment_logand___0(mp_limb_t *s1 , mp_limb_t *s2 , mp_limb_t *dst ,
                                       int n ) 
{ 
  int carry ;
  int i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1126
  carry = 1;
#line 1128
  i = 0;
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if (! (i < n)) {
#line 1128
      goto while_break;
    }
#line 1129
    d = *(s1 + i);
#line 1130
    c = (mp_limb_t )carry + ~ d;
#line 1131
    *(dst + i) = c & *(s2 + i);
#line 1132
    if (carry) {
#line 1132
      if (! d) {
#line 1132
        tmp = 1;
      } else {
#line 1132
        tmp = 0;
      }
    } else {
#line 1132
      tmp = 0;
    }
#line 1132
    carry = tmp;
#line 1128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1134
  return;
}
}
#line 1138 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int bits_compliment_logor___0(mp_limb_t *s1 , mp_limb_t *s2 , mp_limb_t *dst ,
                                     int n ) 
{ 
  int carry ;
  int i ;
  mp_limb_t d ;
  mp_limb_t c ;
  int tmp ;

  {
#line 1140
  carry = 1;
#line 1142
  i = 0;
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1142
    if (! (i < n)) {
#line 1142
      goto while_break;
    }
#line 1143
    d = *(s1 + i);
#line 1144
    c = (mp_limb_t )carry + ~ d;
#line 1145
    *(dst + i) = c | *(s2 + i);
#line 1146
    if (carry) {
#line 1146
      if (! d) {
#line 1146
        tmp = 1;
      } else {
#line 1146
        tmp = 0;
      }
    } else {
#line 1146
      tmp = 0;
    }
#line 1146
    carry = tmp;
#line 1142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1148
  return (carry);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static long bits_carry___0(mp_limb_t *s , int n ) 
{ 
  int i ;

  {
#line 1164
  i = 0;
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1164
    if (! (i < n)) {
#line 1164
      goto while_break;
    }
#line 1165
    if (*(s + i) != 0UL) {
#line 1166
      return (0L);
    }
#line 1164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1169
  return (1L);
}
}
#line 1483 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void copy_bits_shifting_right___0(mp_limb_t *src , mp_limb_t *dst , int n ,
                                         int m ) 
{ 
  mp_limb_t carry ;
  int i ;
  mp_limb_t b ;

  {
#line 1485
  carry = *(src + 0) >> m;
#line 1487
  i = 1;
  {
#line 1487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1487
    if (! (i < n)) {
#line 1487
      goto while_break;
    }
#line 1488
    b = *(src + i);
#line 1489
    *(dst + (i - 1)) = (b << (__gmp_bits_per_limb - (int const   )m)) | carry;
#line 1490
    carry = b >> m;
#line 1487
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1492
  *(dst + (n - 1)) = carry;
#line 1493
  return;
}
}
#line 1495 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static void copy_bits_shifting_left___0(mp_limb_t *src , mp_limb_t *dst , int n ,
                                        int m ) 
{ 
  mp_limb_t carry ;
  int i ;
  mp_limb_t b ;

  {
#line 1497
  carry = (mp_limb_t )0;
#line 1499
  i = 0;
  {
#line 1499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1499
    if (! (i < n)) {
#line 1499
      goto while_break;
    }
#line 1500
    b = *(src + i);
#line 1501
    *(dst + i) = (b << m) | carry;
#line 1502
    carry = b >> (__gmp_bits_per_limb - (int const   )m);
#line 1499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1504
  *(dst + n) = carry;
#line 1505
  return;
}
}
#line 1829 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int limb_length___0(unsigned long n ) 
{ 
  int i ;

  {
#line 1831
  i = 0;
  {
#line 1832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1832
    if (! (n != 0UL)) {
#line 1832
      goto while_break;
    }
#line 1833
    n >>= 1;
#line 1834
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1836
  return (i);
}
}
#line 1942 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int limb_size___0(mp_limb_t x ) 
{ 
  int i ;

  {
#line 1944
  i = 0;
  {
#line 1945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1945
    if (! x) {
#line 1945
      goto while_break;
    }
#line 1946
    i ++;
#line 1947
    x >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1949
  return (i);
}
}
#line 1952 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static int all_zeros___0(mp_limb_t *start , mp_limb_t *end ) 
{ 


  {
  {
#line 1954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1954
    if (! ((unsigned long )start <= (unsigned long )end)) {
#line 1954
      goto while_break;
    }
#line 1955
    if (*end) {
#line 1955
      return (0);
    }
#line 1956
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1958
  return (1);
}
}
#line 1963 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-numerics.c"
static ikptr ikrt_bignum_to_flonum64___0(ikptr bn , ikptr more_bits , ikptr fl ) 
{ 
  ikptr fst ;
  long limb_count ;
  mp_limb_t *sp ;
  double pos_result ;
  mp_limb_t hi ;
  int bc ;
  int tmp ;
  mp_limb_t mi ;
  mp_limb_t mask ;
  int tmp___0 ;
  int bignum_bits ;
  int exponent ;

  {
#line 1965
  fst = *((ikptr *)((long )bn + -5L) + 0);
#line 1966
  limb_count = (long )(fst >> 4);
#line 1967
  sp = (mp_limb_t *)((long )(bn + (ikptr )((int )sizeof(ikptr ) - 5)));
#line 1969
  if (limb_count == 1L) {
#line 1970
    pos_result = (double )*(sp + 0);
  } else {
    {
#line 1972
    hi = *(sp + (limb_count - 1L));
#line 1973
    tmp = limb_size___0(hi);
#line 1973
    bc = tmp;
    }
#line 1974
    if (bc < 64) {
#line 1975
      mi = *(sp + (limb_count - 2L));
#line 1976
      hi = (hi << (64 - bc)) | (mi >> bc);
    }
#line 1979
    mask = (mp_limb_t )((1L << 11) - 1L);
#line 1980
    if ((hi & mask) == (mask + 1UL) >> 1) {
#line 1982
      if (*(sp + (limb_count - 2L)) << (64 - bc) == 0UL) {
        {
#line 1982
        tmp___0 = all_zeros___0(sp, (sp + limb_count) - 3);
        }
#line 1982
        if (tmp___0) {
#line 1982
          if (more_bits == 0UL) {
#line 1985
            if (hi & (unsigned long )(1L << 11)) {
#line 1987
              hi |= mask;
            }
          } else {
#line 1991
            hi |= mask;
          }
        } else {
#line 1991
          hi |= mask;
        }
      } else {
#line 1991
        hi |= mask;
      }
    } else
#line 1993
    if ((hi & mask) > (mask + 1UL) >> 1) {
#line 1995
      hi |= mask;
    }
#line 1999
    pos_result = (double )hi;
#line 2000
    bignum_bits = (int )((long )bc + (long )__gmp_bits_per_limb * (limb_count - 1L));
#line 2001
    exponent = bignum_bits - (int )__gmp_bits_per_limb;
    {
#line 2002
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2002
      if (! exponent) {
#line 2002
        goto while_break;
      }
#line 2003
      pos_result *= 2.0;
#line 2004
      exponent --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2007
  if (fst & 8UL) {
#line 2008
    *((double *)((char *)((long )fl) + 3)) = - pos_result;
  } else {
#line 2010
    *((double *)((char *)((long )fl) + 3)) = pos_result;
  }
#line 2012
  return (fl);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static int extension_amount___0[6]  = {      4096,      4096,      4096,      4096, 
        4096,      4096};
#line 83 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static unsigned int meta_mt___0[6]  = {      70400U,      70912U,      66560U,      71168U, 
        70400U,      71424U};
#line 106
static void handle_guardians___0(gc_t *gc ) ;
#line 107
static void gc_finalize_guardians___0(gc_t *gc ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static unsigned int next_gen_tag___0[5]  = {      (unsigned int )(((4 << 4) | 1) | 8),      (unsigned int )(((2 << 4) | 2) | 8),      (unsigned int )(((1 << 4) | 3) | 8),      12U, 
        12U};
#line 118 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static ikptr meta_alloc_extending___0(long size , gc_t *gc , int meta_id ) 
{ 
  long mapsize ;
  meta_t *meta ;
  qupages_t *p ;
  void *tmp ;
  ikptr aq ;
  ikptr ap ;
  ikptr ep ;
  ikptr x ;
  ikptr mem ;
  ikptr tmp___0 ;

  {
#line 120
  mapsize = (long )(((4095UL + (unsigned long )size) >> 12) << 12);
#line 121
  if (mapsize < (long )extension_amount___0[meta_id]) {
#line 122
    mapsize = (long )extension_amount___0[meta_id];
  }
#line 124
  meta = & gc->meta[meta_id];
#line 125
  if (meta_id != 2) {
#line 125
    if (meta->base) {
      {
#line 126
      tmp = ik_malloc((int )sizeof(qupages_t ));
#line 126
      p = (qupages_t *)tmp;
#line 127
      aq = meta->aq;
#line 128
      ap = meta->ap;
#line 129
      ep = meta->ep;
#line 130
      p->p = aq;
#line 131
      p->q = ap;
#line 132
      p->next = gc->queues[meta_id];
#line 133
      gc->queues[meta_id] = p;
#line 134
      x = ap;
      }
      {
#line 135
      while (1) {
        while_continue: /* CIL Label */ ;
#line 135
        if (! (x < ep)) {
#line 135
          goto while_break;
        }
#line 136
        *((ikptr *)((long )x) + 0) = (ikptr )0;
#line 137
        x += (ikptr )((int )sizeof(ikptr ));
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 140
  tmp___0 = ik_mmap_typed((unsigned long )mapsize, meta_mt___0[meta_id] | (unsigned int )gc->collect_gen_tag,
                          gc->pcb);
#line 140
  mem = tmp___0;
#line 144
  gc->segment_vector = (gc->pcb)->segment_vector;
#line 145
  meta->ap = mem + (ikptr )size;
#line 146
  meta->aq = mem;
#line 147
  meta->ep = mem + (ikptr )mapsize;
#line 148
  meta->base = mem;
  }
#line 149
  return (mem);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr meta_alloc___0(long size , gc_t *gc , int meta_id ) 
{ 
  meta_t *meta ;
  ikptr ap ;
  ikptr ep ;
  ikptr nap ;
  ikptr tmp ;

  {
#line 158
  meta = & gc->meta[meta_id];
#line 159
  ap = meta->ap;
#line 160
  ep = meta->ep;
#line 161
  nap = ap + (ikptr )size;
#line 162
  if (nap > ep) {
    {
#line 163
    tmp = meta_alloc_extending___0(size, gc, meta_id);
    }
#line 163
    return (tmp);
  } else {
#line 165
    meta->ap = nap;
#line 166
    return (ap);
  }
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_ptr___0(int size , gc_t *gc ) 
{ 
  ikptr tmp ;

  {
  {
#line 173
  tmp = meta_alloc___0((long )size, gc, 0);
  }
#line 173
  return (tmp);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_symbol_record___0(gc_t *gc ) 
{ 
  ikptr tmp ;

  {
  {
#line 214
  tmp = meta_alloc___0((long )(6 * (int )sizeof(ikptr )), gc, 5);
  }
#line 214
  return (tmp);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_pair___0(gc_t *gc ) 
{ 
  ikptr tmp ;

  {
  {
#line 222
  tmp = meta_alloc___0((long )(2 * (int )sizeof(ikptr )), gc, 4);
  }
#line 222
  return (tmp);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_weak_pair___0(gc_t *gc ) 
{ 
  meta_t *meta ;
  ikptr ap ;
  ikptr ep ;
  ikptr nap ;
  ikptr mem ;
  ikptr tmp ;

  {
#line 229
  meta = & gc->meta[3];
#line 230
  ap = meta->ap;
#line 231
  ep = meta->ep;
#line 232
  nap = ap + (ikptr )(2 * (int )sizeof(ikptr ));
#line 233
  if (nap > ep) {
    {
#line 234
    tmp = ik_mmap_typed(4096UL, meta_mt___0[3] | (unsigned int )gc->collect_gen_tag,
                        gc->pcb);
#line 234
    mem = tmp;
#line 238
    gc->segment_vector = (gc->pcb)->segment_vector;
#line 239
    meta->ap = mem + (ikptr )(2 * (int )sizeof(ikptr ));
#line 240
    meta->aq = mem;
#line 241
    meta->ep = mem + 4096UL;
#line 242
    meta->base = mem;
    }
#line 243
    return (mem);
  } else {
#line 245
    meta->ap = nap;
#line 246
    return (ap);
  }
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_data___0(int size , gc_t *gc ) 
{ 
  ikptr tmp ;

  {
  {
#line 253
  tmp = meta_alloc___0((long )size, gc, 2);
  }
#line 253
  return (tmp);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static ikptr gc_alloc_new_code___0(long size , gc_t *gc ) 
{ 
  ikptr tmp ;
  long memreq ;
  ikptr mem ;
  ikptr tmp___0 ;
  qupages_t *p ;
  void *tmp___1 ;

  {
#line 259
  if (size < 4096L) {
    {
#line 260
    tmp = meta_alloc___0(size, gc, 1);
    }
#line 260
    return (tmp);
  } else {
    {
#line 262
    memreq = (long )(((4095UL + (unsigned long )size) >> 12) << 12);
#line 263
    tmp___0 = ik_mmap_code((unsigned long )memreq, gc->collect_gen, gc->pcb);
#line 263
    mem = tmp___0;
#line 264
    gc->segment_vector = (gc->pcb)->segment_vector;
#line 265
    tmp___1 = ik_malloc((int )sizeof(qupages_t ));
#line 265
    p = (qupages_t *)tmp___1;
#line 266
    p->p = mem;
#line 267
    p->q = mem + (ikptr )size;
#line 268
    bzero((void *)((char *)((long )(mem + (ikptr )size))), (size_t )(memreq - size));
#line 269
    p->next = gc->queues[1];
#line 270
    gc->queues[1] = p;
    }
#line 271
    return (mem);
  }
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void add_to_collect_count___0(ikpcb *pcb , int bytes ) 
{ 
  int minor ;

  {
#line 277
  minor = bytes + pcb->allocation_count_minor;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (minor >= 268435456)) {
#line 278
      goto while_break;
    }
#line 279
    minor -= 268435456;
#line 280
    (pcb->allocation_count_major) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  pcb->allocation_count_minor = minor;
#line 283
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void gc_tconc_push_extending___0(gc_t *gc , ikptr tcbucket ) 
{ 
  ikpages *p ;
  void *tmp ;
  ikptr ap ;
  ikptr tmp___0 ;
  ikptr nap ;

  {
#line 290
  if (gc->tconc_base) {
    {
#line 291
    tmp = ik_malloc((int )sizeof(ikpages ));
#line 291
    p = (ikpages *)tmp;
#line 292
    p->base = gc->tconc_base;
#line 293
    p->size = 4096;
#line 294
    p->next = gc->tconc_queue;
#line 295
    gc->tconc_queue = p;
    }
  }
  {
#line 297
  tmp___0 = ik_mmap_typed(4096UL, meta_mt___0[0] | (unsigned int )gc->collect_gen_tag,
                          gc->pcb);
#line 297
  ap = tmp___0;
#line 301
  add_to_collect_count___0(gc->pcb, 4096);
#line 302
  gc->segment_vector = (gc->pcb)->segment_vector;
#line 303
  bzero((void *)((char *)((long )ap)), (size_t )4096);
#line 304
  nap = ap + (ikptr )(2 * (int )sizeof(ikptr ));
#line 305
  gc->tconc_base = ap;
#line 306
  gc->tconc_ap = nap;
#line 307
  gc->tconc_ep = ap + 4096UL;
#line 308
  *((ikptr *)((long )ap) + 0) = tcbucket;
  }
#line 309
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
__inline static void gc_tconc_push___0(gc_t *gc , ikptr tcbucket ) 
{ 
  ikptr ap ;
  ikptr nap ;

  {
#line 314
  ap = gc->tconc_ap;
#line 315
  nap = ap + (ikptr )(2 * (int )sizeof(ikptr ));
#line 316
  if (nap > gc->tconc_ep) {
    {
#line 317
    gc_tconc_push_extending___0(gc, tcbucket);
    }
  } else {
#line 319
    gc->tconc_ap = nap;
#line 320
    *((ikptr *)((long )ap) + 0) = tcbucket;
  }
#line 322
  return;
}
}
#line 329
static ikptr add_object_proc___0(gc_t *gc , ikptr x ) ;
#line 333
static void collect_stack___0(gc_t *gc , ikptr top , ikptr end ) ;
#line 334
static void collect_locatives___0(gc_t *gc , callback_locative *loc ) ;
#line 335
static void collect_loop___0(gc_t *gc ) ;
#line 336
static void fix_weak_pointers___0(gc_t *gc ) ;
#line 337
static void gc_add_tconcs___0(gc_t *gc ) ;
#line 360 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static int collection_id_to_gen___0(int id ) 
{ 


  {
#line 361
  if ((id & 255) == 255) {
#line 361
    return (4);
  }
#line 362
  if ((id & 63) == 63) {
#line 362
    return (3);
  }
#line 363
  if ((id & 15) == 15) {
#line 363
    return (2);
  }
#line 364
  if ((id & 3) == 3) {
#line 364
    return (1);
  }
#line 365
  return (0);
}
}
#line 370
static void scan_dirty_pages___0(gc_t *gc ) ;
#line 372
static void deallocate_unused_pages___0(gc_t *gc ) ;
#line 374
static void fix_new_pages___0(gc_t *gc ) ;
#line 607 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static ik_ptr_page *move_tconc___0(ikptr tc , ik_ptr_page *ls ) 
{ 
  ik_ptr_page *page ;
  ikptr tmp ;
  long tmp___0 ;

  {
#line 609
  if ((unsigned long )ls == (unsigned long )((void *)0)) {
    {
#line 610
    tmp = ik_mmap(4096UL);
#line 610
    page = (ik_ptr_page *)tmp;
#line 611
    page->count = 0L;
#line 612
    page->next = ls;
#line 613
    ls = page;
    }
  } else
#line 609
  if ((unsigned long )ls->count == ((4096UL - sizeof(long )) - sizeof(struct ik_ptr_page *)) / sizeof(ikptr )) {
    {
#line 610
    tmp = ik_mmap(4096UL);
#line 610
    page = (ik_ptr_page *)tmp;
#line 611
    page->count = 0L;
#line 612
    page->next = ls;
#line 613
    ls = page;
    }
  }
#line 615
  tmp___0 = ls->count;
#line 615
  (ls->count) ++;
#line 615
  ls->ptr[tmp___0] = tc;
#line 616
  return (ls);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void handle_guardians___0(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  ik_ptr_page *pend_hold_list ;
  ik_ptr_page *pend_final_list ;
  int gen ;
  ik_ptr_page *prot_list ;
  int i ;
  ikptr p ;
  ikptr tc ;
  ikptr obj ;
  ikptr np ;
  int tmp ;
  ik_ptr_page *next ;
  int done ;
  ik_ptr_page *final_list ;
  ik_ptr_page *ls ;
  int i___0 ;
  ikptr p___0 ;
  ikptr tc___0 ;
  ikptr np___0 ;
  int tmp___0 ;
  ik_ptr_page *next___0 ;
  int i___1 ;
  ikptr p___1 ;
  ikptr tmp___1 ;
  ik_ptr_page *next___1 ;
  ik_ptr_page *next___2 ;
  ik_ptr_page *target ;
  int tmp___2 ;
  int i___2 ;
  ikptr p___2 ;
  ikptr tc___1 ;
  ikptr np___1 ;
  ikptr tmp___3 ;
  int tmp___4 ;
  ik_ptr_page *next___3 ;
  int tmp___5 ;

  {
#line 621
  pcb = gc->pcb;
#line 622
  pend_hold_list = (ik_ptr_page *)0;
#line 623
  pend_final_list = (ik_ptr_page *)0;
#line 626
  gen = 0;
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    if (! (gen <= gc->collect_gen)) {
#line 626
      goto while_break;
    }
#line 627
    prot_list = pcb->protected_list[gen];
#line 628
    pcb->protected_list[gen] = (ik_ptr_page *)0;
    {
#line 629
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 629
      if (! prot_list) {
#line 629
        goto while_break___0;
      }
#line 631
      i = 0;
      {
#line 631
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 631
        if (! ((long )i < prot_list->count)) {
#line 631
          goto while_break___1;
        }
#line 632
        p = prot_list->ptr[i];
#line 633
        tc = *((ikptr *)((long )p + -1L) + 0);
#line 634
        obj = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 635
        if (tc == 0xffffffffffffffffUL) {
#line 636
          np = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 637
          tc = *((ikptr *)((long )np + -1L) + 0);
#line 638
          obj = *((ikptr *)((long )np + (long )((int )sizeof(ikptr ) - 1)) + 0);
        }
        {
#line 640
        tmp = is_live(obj, gc);
        }
#line 640
        if (tmp) {
          {
#line 641
          pend_hold_list = move_tconc___0(p, pend_hold_list);
          }
        } else {
          {
#line 643
          pend_final_list = move_tconc___0(p, pend_final_list);
          }
        }
#line 631
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 646
      next = prot_list->next;
#line 647
      ik_munmap((ikptr )prot_list, 4096UL);
#line 648
      prot_list = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 626
    gen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  gc->forward_list = (ik_ptr_page *)0;
#line 656
  done = 0;
  {
#line 657
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 657
    if (! (! done)) {
#line 657
      goto while_break___2;
    }
#line 658
    final_list = (ik_ptr_page *)0;
#line 659
    ls = pend_final_list;
#line 660
    pend_final_list = (ik_ptr_page *)0;
    {
#line 661
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 661
      if (! ls) {
#line 661
        goto while_break___3;
      }
#line 663
      i___0 = 0;
      {
#line 663
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 663
        if (! ((long )i___0 < ls->count)) {
#line 663
          goto while_break___4;
        }
#line 664
        p___0 = ls->ptr[i___0];
#line 665
        tc___0 = *((ikptr *)((long )p___0 + -1L) + 0);
#line 666
        if (tc___0 == 0xffffffffffffffffUL) {
#line 667
          np___0 = *((ikptr *)((long )p___0 + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 668
          tc___0 = *((ikptr *)((long )np___0 + -1L) + 0);
        }
        {
#line 670
        tmp___0 = is_live(tc___0, gc);
        }
#line 670
        if (tmp___0) {
          {
#line 671
          final_list = move_tconc___0(p___0, final_list);
          }
        } else {
          {
#line 673
          pend_final_list = move_tconc___0(p___0, pend_final_list);
          }
        }
#line 663
        i___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 676
      next___0 = ls->next;
#line 677
      ik_munmap((ikptr )ls, 4096UL);
#line 678
      ls = next___0;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 680
    if ((unsigned long )final_list == (unsigned long )((void *)0)) {
#line 681
      done = 1;
    } else {
#line 683
      ls = final_list;
      {
#line 684
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 684
        if (! ls) {
#line 684
          goto while_break___5;
        }
#line 686
        i___1 = 0;
        {
#line 686
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 686
          if (! ((long )i___1 < ls->count)) {
#line 686
            goto while_break___6;
          }
          {
#line 687
          p___1 = ls->ptr[i___1];
#line 688
          tmp___1 = add_object_proc___0(gc, p___1);
#line 688
          gc->forward_list = move_tconc___0(tmp___1, gc->forward_list);
#line 686
          i___1 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 692
        next___1 = ls->next;
#line 693
        ik_munmap((ikptr )ls, 4096UL);
#line 694
        ls = next___1;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 696
      collect_loop___0(gc);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 701
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 701
    if (! pend_final_list) {
#line 701
      goto while_break___7;
    }
    {
#line 702
    next___2 = pend_final_list->next;
#line 703
    ik_munmap((ikptr )pend_final_list, 4096UL);
#line 704
    pend_final_list = next___2;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 708
  tmp___2 = next_gen(gc->collect_gen);
#line 708
  target = pcb->protected_list[tmp___2];
  }
  {
#line 709
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 709
    if (! pend_hold_list) {
#line 709
      goto while_break___8;
    }
#line 711
    i___2 = 0;
    {
#line 711
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 711
      if (! ((long )i___2 < pend_hold_list->count)) {
#line 711
        goto while_break___9;
      }
#line 712
      p___2 = pend_hold_list->ptr[i___2];
#line 713
      tc___1 = *((ikptr *)((long )p___2 + -1L) + 0);
#line 714
      if (tc___1 == 0xffffffffffffffffUL) {
#line 715
        np___1 = *((ikptr *)((long )p___2 + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 716
        tc___1 = *((ikptr *)((long )np___1 + -1L) + 0);
      }
      {
#line 718
      tmp___4 = is_live(tc___1, gc);
      }
#line 718
      if (tmp___4) {
        {
#line 719
        tmp___3 = add_object_proc___0(gc, p___2);
#line 719
        target = move_tconc___0(tmp___3, target);
        }
      }
#line 711
      i___2 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 722
    next___3 = pend_hold_list->next;
#line 723
    ik_munmap((ikptr )pend_hold_list, 4096UL);
#line 724
    pend_hold_list = next___3;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 726
  collect_loop___0(gc);
#line 727
  tmp___5 = next_gen(gc->collect_gen);
#line 727
  pcb->protected_list[tmp___5] = target;
  }
#line 728
  return;
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void gc_finalize_guardians___0(gc_t *gc ) 
{ 
  ik_ptr_page *ls ;
  int tconc_count ;
  unsigned int *dirty_vec ;
  int i ;
  ikptr p ;
  ikptr tc ;
  ikptr obj ;
  ikptr last_pair ;
  ik_ptr_page *next ;

  {
#line 732
  ls = gc->forward_list;
#line 733
  tconc_count = 0;
#line 734
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! ls) {
#line 735
      goto while_break;
    }
#line 737
    i = 0;
    {
#line 737
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 737
      if (! ((long )i < ls->count)) {
#line 737
        goto while_break___0;
      }
#line 738
      tconc_count ++;
#line 739
      p = ls->ptr[i];
#line 740
      tc = *((ikptr *)((long )p + -1L) + 0);
#line 741
      obj = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 742
      last_pair = *((ikptr *)((long )tc + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 743
      *((ikptr *)((long )last_pair + -1L) + 0) = obj;
#line 744
      *((ikptr *)((long )last_pair + (long )((int )sizeof(ikptr ) - 1)) + 0) = p;
#line 745
      *((ikptr *)((long )p + -1L) + 0) = (ikptr )47;
#line 746
      *((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 1)) + 0) = (ikptr )47;
#line 747
      *((ikptr *)((long )tc + (long )((int )sizeof(ikptr ) - 1)) + 0) = p;
#line 748
      *(dirty_vec + (tc >> 12)) = 4294967295U;
#line 749
      *(dirty_vec + (last_pair >> 12)) = 4294967295U;
#line 737
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 751
    next = ls->next;
#line 752
    ik_munmap((ikptr )ls, 4096UL);
#line 753
    ls = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 755
  return;
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static int alloc_code_count___0  =    0;
#line 761 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static ikptr add_code_entry___0(gc_t *gc , ikptr entry ) 
{ 
  ikptr x ;
  long idx ;
  unsigned int t ;
  int gen ;
  long code_size ;
  int tmp ;
  ikptr reloc_vec ;
  ikptr freevars ;
  ikptr annotation ;
  long required_mem ;
  int tmp___0 ;
  int tmp___1 ;
  int new_tag ;
  long idx___0 ;
  long i ;
  qupages_t *p ;
  void *tmp___2 ;
  ikptr y ;
  ikptr tmp___3 ;
  int tmp___4 ;

  {
#line 763
  x = entry - (ikptr )(6 * (int )sizeof(ikptr ));
#line 764
  if (*((ikptr *)((long )x) + 0) == 0xffffffffffffffffUL) {
#line 765
    return (*((ikptr *)((long )x + (long )((int )sizeof(ikptr ))) + 0) + (ikptr )(6 * (int )sizeof(ikptr ) - 5));
  }
#line 767
  idx = (long )(x >> 12);
#line 768
  t = *(gc->segment_vector + idx);
#line 769
  gen = (int )(t & 15U);
#line 770
  if (gen > gc->collect_gen) {
#line 771
    return (entry);
  }
#line 773
  if ((int )sizeof(ikptr ) == 4) {
#line 773
    tmp = 2;
  } else {
#line 773
    tmp = 3;
  }
#line 773
  code_size = (long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ))) + 0) >> tmp;
#line 774
  reloc_vec = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 775
  freevars = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ))) + 0);
#line 776
  annotation = *((ikptr *)((long )x + (long )(4 * (int )sizeof(ikptr ))) + 0);
#line 777
  if ((int )sizeof(ikptr ) == 4) {
#line 777
    tmp___0 = 2;
  } else {
#line 777
    tmp___0 = 3;
  }
#line 777
  if ((int )sizeof(ikptr ) == 4) {
#line 777
    tmp___1 = 2;
  } else {
#line 777
    tmp___1 = 3;
  }
#line 777
  required_mem = (((((long )(6 * (int )sizeof(ikptr )) + code_size) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1);
#line 778
  if (required_mem >= 4096L) {
#line 779
    new_tag = gc->collect_gen_tag;
#line 780
    idx___0 = (long )(x >> 12);
#line 781
    *(gc->segment_vector + idx___0) = (unsigned int )(new_tag | 70912);
#line 783
    i = 4096L;
#line 783
    idx___0 ++;
    {
#line 783
    while (1) {
      while_continue: /* CIL Label */ ;
#line 783
      if (! (i < required_mem)) {
#line 783
        goto while_break;
      }
#line 784
      *(gc->segment_vector + idx___0) = (unsigned int )(new_tag | 66560);
#line 783
      i += 4096L;
#line 783
      idx___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 786
    tmp___2 = ik_malloc((int )sizeof(qupages_t ));
#line 786
    p = (qupages_t *)tmp___2;
#line 787
    p->p = x;
#line 788
    p->q = x + (ikptr )required_mem;
#line 789
    p->next = gc->queues[1];
#line 790
    gc->queues[1] = p;
    }
#line 791
    return (entry);
  } else {
    {
#line 793
    tmp___3 = gc_alloc_new_code___0(required_mem, gc);
#line 793
    y = tmp___3;
#line 794
    *((ikptr *)((long )y) + 0) = (ikptr )47;
    }
#line 795
    if ((int )sizeof(ikptr ) == 4) {
#line 795
      tmp___4 = 2;
    } else {
#line 795
      tmp___4 = 3;
    }
    {
#line 795
    *((ikptr *)((long )y + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )(code_size << tmp___4);
#line 796
    *((ikptr *)((long )y + (long )(2 * (int )sizeof(ikptr ))) + 0) = reloc_vec;
#line 797
    *((ikptr *)((long )y + (long )(3 * (int )sizeof(ikptr ))) + 0) = freevars;
#line 798
    *((ikptr *)((long )y + (long )(4 * (int )sizeof(ikptr ))) + 0) = annotation;
#line 799
    memcpy((void */* __restrict  */)((char *)((long )(y + (ikptr )(6 * (int )sizeof(ikptr ))))),
           (void const   */* __restrict  */)((char *)((long )(x + (ikptr )(6 * (int )sizeof(ikptr ))))),
           (size_t )code_size);
#line 802
    *((ikptr *)((long )x) + 0) = (ikptr )-1;
#line 803
    *((ikptr *)((long )x + (long )((int )sizeof(ikptr ))) + 0) = y + 5UL;
    }
#line 804
    return (y + (ikptr )(6 * (int )sizeof(ikptr )));
  }
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void collect_locatives___0(gc_t *gc , callback_locative *loc ) 
{ 


  {
  {
#line 810
  while (1) {
    while_continue: /* CIL Label */ ;
#line 810
    if (! loc) {
#line 810
      goto while_break;
    }
    {
#line 811
    loc->data = add_object_proc___0(gc, loc->data);
#line 812
    loc = loc->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  return;
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void collect_stack___0(gc_t *gc , ikptr top , ikptr end ) 
{ 
  ikptr rp ;
  long rp_offset ;
  int tmp ;
  int tmp___0 ;
  long code_offset ;
  int tmp___1 ;
  ikptr code_entry ;
  ikptr new_code_entry ;
  ikptr tmp___2 ;
  ikptr new_rp ;
  long framesize ;
  int tmp___3 ;
  ikptr base ;
  ikptr new_obj ;
  ikptr tmp___4 ;
  long frame_cells ;
  int tmp___5 ;
  long bytes_in_mask ;
  char *mask ;
  int tmp___6 ;
  ikptr *fp ;
  long i ;
  unsigned char m ;

  {
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (! (top < end)) {
#line 823
      goto while_break;
    }
#line 827
    rp = *((ikptr *)((long )top) + 0);
#line 828
    if ((int )sizeof(ikptr ) == 4) {
#line 828
      tmp = 5;
    } else {
#line 828
      tmp = 10;
    }
#line 828
    if ((int )sizeof(ikptr ) == 4) {
#line 828
      tmp___0 = 2;
    } else {
#line 828
      tmp___0 = 3;
    }
#line 828
    rp_offset = (long )*((ikptr *)((long )rp + (long )(- (tmp + 2 * (int )sizeof(ikptr )))) + 0) >> tmp___0;
#line 833
    if (rp_offset <= 0L) {
      {
#line 834
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid rp_offset %ld\n",
              rp_offset);
#line 835
      exit(-1);
      }
    }
#line 841
    if ((int )sizeof(ikptr ) == 4) {
#line 841
      tmp___1 = 5;
    } else {
#line 841
      tmp___1 = 10;
    }
    {
#line 841
    code_offset = rp_offset - (long )(- (tmp___1 + 2 * (int )sizeof(ikptr )));
#line 842
    code_entry = rp - (ikptr )code_offset;
#line 843
    tmp___2 = add_code_entry___0(gc, code_entry);
#line 843
    new_code_entry = tmp___2;
#line 844
    new_rp = new_code_entry + (ikptr )code_offset;
#line 845
    *((ikptr *)((long )top) + 0) = new_rp;
    }
#line 881
    if ((int )sizeof(ikptr ) == 4) {
#line 881
      tmp___3 = 5;
    } else {
#line 881
      tmp___3 = 10;
    }
#line 881
    framesize = (long )*((ikptr *)((long )rp + (long )(- (tmp___3 + 3 * (int )sizeof(ikptr )))) + 0);
#line 885
    if (framesize < 0L) {
      {
#line 886
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid frame size %ld\n",
              framesize);
#line 887
      exit(-1);
      }
    } else
#line 889
    if (framesize == 0L) {
#line 890
      framesize = (long )*((ikptr *)((long )top + (long )((int )sizeof(ikptr ))) + 0);
#line 891
      if (framesize <= 0L) {
        {
#line 892
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid redirected framesize=%ld\n",
                framesize);
#line 893
        exit(-1);
        }
      }
#line 895
      base = (top + (ikptr )framesize) - (ikptr )((int )sizeof(ikptr ));
      {
#line 896
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 896
        if (! (base > top)) {
#line 896
          goto while_break___0;
        }
        {
#line 897
        tmp___4 = add_object_proc___0(gc, *((ikptr *)((long )base) + 0));
#line 897
        new_obj = tmp___4;
#line 898
        *((ikptr *)((long )base) + 0) = new_obj;
#line 899
        base -= (ikptr )((int )sizeof(ikptr ));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 902
      if ((int )sizeof(ikptr ) == 4) {
#line 902
        tmp___5 = 2;
      } else {
#line 902
        tmp___5 = 3;
      }
#line 902
      frame_cells = framesize >> tmp___5;
#line 903
      bytes_in_mask = (frame_cells + 7L) >> 3;
#line 904
      if ((int )sizeof(ikptr ) == 4) {
#line 904
        tmp___6 = 5;
      } else {
#line 904
        tmp___6 = 10;
      }
#line 904
      mask = (char *)((long )((rp + (ikptr )(- (tmp___6 + 3 * (int )sizeof(ikptr )))) - (ikptr )bytes_in_mask));
#line 906
      fp = (ikptr *)((long )(top + (ikptr )framesize));
#line 908
      i = 0L;
      {
#line 908
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 908
        if (! (i < bytes_in_mask)) {
#line 908
          goto while_break___1;
        }
#line 909
        m = (unsigned char )*(mask + i);
#line 913
        if ((int )m & 1) {
          {
#line 913
          *(fp + 0) = add_object_proc___0(gc, *(fp + 0));
          }
        }
#line 914
        if ((int )m & 2) {
          {
#line 914
          *(fp + -1) = add_object_proc___0(gc, *(fp + -1));
          }
        }
#line 915
        if ((int )m & 4) {
          {
#line 915
          *(fp + -2) = add_object_proc___0(gc, *(fp + -2));
          }
        }
#line 916
        if ((int )m & 8) {
          {
#line 916
          *(fp + -3) = add_object_proc___0(gc, *(fp + -3));
          }
        }
#line 917
        if ((int )m & 16) {
          {
#line 917
          *(fp + -4) = add_object_proc___0(gc, *(fp + -4));
          }
        }
#line 918
        if ((int )m & 32) {
          {
#line 918
          *(fp + -5) = add_object_proc___0(gc, *(fp + -5));
          }
        }
#line 919
        if ((int )m & 64) {
          {
#line 919
          *(fp + -6) = add_object_proc___0(gc, *(fp + -6));
          }
        }
#line 920
        if ((int )m & 128) {
          {
#line 920
          *(fp + -7) = add_object_proc___0(gc, *(fp + -7));
          }
        }
#line 908
        i ++;
#line 908
        fp -= 8;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 923
    top += (ikptr )framesize;
  }
  while_break: /* CIL Label */ ;
  }
#line 925
  if (top != end) {
    {
#line 926
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"frames did not match up 0x%016lx .. 0x%016lx\n",
            (long )top, (long )end);
#line 928
    exit(-1);
    }
  }
#line 933
  return;
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void add_list___0(gc_t *gc , unsigned int t , ikptr x , ikptr *loc ) 
{ 
  int collect_gen ;
  ikptr fst ;
  ikptr snd ;
  ikptr y ;
  ikptr tmp ;
  ikptr tmp___0 ;
  int stag ;
  int gen ;
  int tmp___1 ;

  {
#line 938
  collect_gen = gc->collect_gen;
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 940
    fst = *((ikptr *)((long )x + -1L) + 0);
#line 941
    snd = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 943
    if ((t & 3840U) != 1536U) {
      {
#line 944
      tmp = gc_alloc_new_pair___0(gc);
#line 944
      y = tmp + 1UL;
      }
    } else {
      {
#line 946
      tmp___0 = gc_alloc_new_weak_pair___0(gc);
#line 946
      y = tmp___0 + 1UL;
      }
    }
#line 948
    *loc = y;
#line 949
    *((ikptr *)((long )x + -1L) + 0) = (ikptr )-1;
#line 950
    *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0) = y;
#line 951
    *((ikptr *)((long )y + -1L) + 0) = fst;
#line 952
    stag = (int )snd & 7;
#line 953
    if (stag == 1) {
#line 954
      if (*((ikptr *)((long )snd + -1L) + 0) == 0xffffffffffffffffUL) {
#line 955
        *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = *((ikptr *)((long )snd + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 956
        return;
      } else {
#line 959
        t = *(gc->segment_vector + (snd >> 12));
#line 960
        gen = (int )(t & 15U);
#line 961
        if (gen > collect_gen) {
#line 962
          *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = snd;
#line 963
          return;
        } else {
#line 965
          x = snd;
#line 966
          loc = (ikptr *)((long )(y + (ikptr )((int )sizeof(ikptr ) - 1)));
        }
      }
    } else
#line 971
    if (stag == 7) {
#line 974
      *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = snd;
#line 975
      return;
    } else
#line 971
    if (stag == 0) {
#line 974
      *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = snd;
#line 975
      return;
    } else {
#line 971
      if ((int )sizeof(ikptr ) == 4) {
#line 971
        tmp___1 = 2;
      } else {
#line 971
        tmp___1 = 3;
      }
#line 971
      if (stag == 1 << tmp___1) {
#line 974
        *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = snd;
#line 975
        return;
      } else
#line 977
      if (*((ikptr *)((long )snd + (long )(- stag)) + 0) == 0xffffffffffffffffUL) {
#line 978
        *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = *((ikptr *)((long )snd + (long )((int )sizeof(ikptr ) - stag)) + 0);
#line 979
        return;
      } else {
        {
#line 982
        *((ikptr *)((long )y + (long )((int )sizeof(ikptr ) - 1)) + 0) = add_object_proc___0(gc,
                                                                                             snd);
        }
#line 983
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static ikptr add_object_proc___0(gc_t *gc , ikptr x ) 
{ 
  int tag ;
  ikptr fst ;
  unsigned int t ;
  int gen ;
  ikptr y ;
  ikptr size ;
  ikptr asize ;
  int tmp ;
  int tmp___0 ;
  ikptr y___0 ;
  ikptr tmp___1 ;
  ikptr size___0 ;
  ikptr memreq ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr y___1 ;
  ikptr tmp___4 ;
  ikptr y___2 ;
  ikptr tmp___5 ;
  ikptr y___3 ;
  ikptr tmp___6 ;
  ikptr size___1 ;
  ikptr y___4 ;
  ikptr tmp___7 ;
  ikptr i ;
  ikptr p ;
  ikptr q ;
  ikptr y___5 ;
  ikptr tmp___8 ;
  ikptr i___0 ;
  ikptr p___0 ;
  ikptr q___0 ;
  int tmp___9 ;
  ikptr entry ;
  ikptr new_entry ;
  ikptr tmp___10 ;
  ikptr top ;
  ikptr size___2 ;
  ikptr next ;
  ikptr y___6 ;
  ikptr tmp___11 ;
  ikptr new_top ;
  int tmp___12 ;
  int tmp___13 ;
  ikptr tmp___14 ;
  ikptr y___7 ;
  ikptr tmp___15 ;
  ikptr top___0 ;
  ikptr next___0 ;
  ikptr y___8 ;
  ikptr tmp___16 ;
  ikptr key ;
  int gen___0 ;
  ikptr y___9 ;
  ikptr tmp___17 ;
  long i___1 ;
  ikptr new ;
  ikptr tmp___18 ;
  long len ;
  long memreq___0 ;
  int tmp___19 ;
  int tmp___20 ;
  ikptr new___0 ;
  ikptr tmp___21 ;
  ikptr y___10 ;
  ikptr tmp___22 ;
  ikptr num ;
  ikptr den ;
  ikptr y___11 ;
  ikptr tmp___23 ;
  ikptr rl ;
  ikptr im ;
  ikptr y___12 ;
  ikptr tmp___24 ;
  ikptr rl___0 ;
  ikptr im___0 ;
  ikptr y___13 ;
  ikptr tmp___25 ;
  long strlen___0 ;
  int tmp___26 ;
  long memreq___1 ;
  int tmp___27 ;
  int tmp___28 ;
  ikptr new_str ;
  ikptr tmp___29 ;
  long len___0 ;
  int tmp___30 ;
  long memreq___2 ;
  int tmp___31 ;
  int tmp___32 ;
  ikptr new_bv ;
  ikptr tmp___33 ;

  {
#line 996
  if ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 997
    return (x);
  }
#line 1000
  tag = (int )x & 7;
#line 1001
  if (tag == 7) {
#line 1002
    return (x);
  }
#line 1004
  fst = *((ikptr *)((long )x + (long )(- tag)) + 0);
#line 1005
  if (fst == 0xffffffffffffffffUL) {
#line 1007
    return (*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - tag)) + 0));
  }
#line 1009
  t = *(gc->segment_vector + (x >> 12));
#line 1010
  gen = (int )(t & 15U);
#line 1011
  if (gen > gc->collect_gen) {
#line 1012
    return (x);
  }
#line 1014
  if (tag == 1) {
    {
#line 1016
    add_list___0(gc, t, x, & y);
    }
#line 1017
    return (y);
  } else
#line 1039
  if (tag == 3) {
#line 1040
    size = (ikptr )((int )sizeof(ikptr )) + *((ikptr *)((long )fst + (long )(3 * (int )sizeof(ikptr ) - 6 * (int )sizeof(ikptr ))) + 0);
#line 1043
    if (size > 1024UL) {
      {
#line 1044
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"large closure size=0x%016lx\n",
              (long )size);
      }
    }
#line 1046
    if ((int )sizeof(ikptr ) == 4) {
#line 1046
      tmp = 2;
    } else {
#line 1046
      tmp = 3;
    }
#line 1046
    if ((int )sizeof(ikptr ) == 4) {
#line 1046
      tmp___0 = 2;
    } else {
#line 1046
      tmp___0 = 3;
    }
    {
#line 1046
    asize = (((size + (ikptr )(2 * (int )sizeof(ikptr ))) - 1UL) >> (tmp + 1)) << (tmp___0 + 1);
#line 1047
    tmp___1 = gc_alloc_new_ptr___0((int )asize, gc);
#line 1047
    y___0 = tmp___1 + 3UL;
#line 1048
    *((ikptr *)((long )y___0 + (long )((asize - 3UL) - (ikptr )((int )sizeof(ikptr )))) + 0) = (ikptr )0;
#line 1049
    memcpy((void */* __restrict  */)((char *)((long )(y___0 - 3UL))), (void const   */* __restrict  */)((char *)((long )(x - 3UL))),
           size);
#line 1052
    *((ikptr *)((long )y___0 + -3L) + 0) = add_code_entry___0(gc, *((ikptr *)((long )y___0 + -3L) + 0));
#line 1053
    *((ikptr *)((long )x + -3L) + 0) = (ikptr )-1;
#line 1054
    *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 3)) + 0) = y___0;
    }
#line 1058
    return (y___0);
  } else
#line 1060
  if (tag == 5) {
#line 1061
    if ((fst & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 1064
      size___0 = fst;
#line 1066
      if ((int )sizeof(ikptr ) == 4) {
#line 1066
        tmp___2 = 2;
      } else {
#line 1066
        tmp___2 = 3;
      }
#line 1066
      if ((int )sizeof(ikptr ) == 4) {
#line 1066
        tmp___3 = 2;
      } else {
#line 1066
        tmp___3 = 3;
      }
#line 1066
      memreq = ((((size___0 + (ikptr )((int )sizeof(ikptr ))) + (ikptr )(2 * (int )sizeof(ikptr ))) - 1UL) >> (tmp___2 + 1)) << (tmp___3 + 1);
#line 1067
      if (memreq >= 4096UL) {
#line 1068
        if ((t & 1048576U) == 1048576U) {
          {
#line 1069
          enqueue_large_ptr(x - 5UL, (int )(size___0 + (ikptr )((int )sizeof(ikptr ))),
                            gc);
          }
#line 1070
          return (x);
        } else {
          {
#line 1072
          tmp___4 = gc_alloc_new_large_ptr((int )(size___0 + (ikptr )((int )sizeof(ikptr ))),
                                           gc);
#line 1072
          y___1 = tmp___4 + 5UL;
#line 1074
          *((ikptr *)((long )y___1 + -5L) + 0) = fst;
#line 1075
          *((ikptr *)((long )y___1 + (long )((memreq - 5UL) - (ikptr )((int )sizeof(ikptr )))) + 0) = (ikptr )0;
#line 1076
          memcpy((void */* __restrict  */)((char *)((long )(y___1 + (ikptr )((int )sizeof(ikptr ) - 5)))),
                 (void const   */* __restrict  */)((char *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5)))),
                 size___0);
#line 1079
          *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1080
          *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___1;
          }
#line 1081
          return (y___1);
        }
      } else {
        {
#line 1084
        tmp___5 = gc_alloc_new_ptr___0((int )memreq, gc);
#line 1084
        y___2 = tmp___5 + 5UL;
#line 1085
        *((ikptr *)((long )y___2 + -5L) + 0) = fst;
#line 1086
        *((ikptr *)((long )y___2 + (long )((memreq - 5UL) - (ikptr )((int )sizeof(ikptr )))) + 0) = (ikptr )0;
#line 1087
        memcpy((void */* __restrict  */)((char *)((long )(y___2 + (ikptr )((int )sizeof(ikptr ) - 5)))),
               (void const   */* __restrict  */)((char *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 5)))),
               size___0);
#line 1090
        *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1091
        *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___2;
        }
#line 1092
        return (y___2);
      }
    } else
#line 1098
    if (fst == 95UL) {
      {
#line 1099
      tmp___6 = gc_alloc_new_symbol_record___0(gc);
#line 1099
      y___3 = tmp___6 + 5UL;
#line 1100
      *((ikptr *)((long )y___3 + -5L) + 0) = (ikptr )95;
#line 1101
      *((ikptr *)((long )y___3 + (long )((int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1102
      *((ikptr *)((long )y___3 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1103
      *((ikptr *)((long )y___3 + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1104
      *((ikptr *)((long )y___3 + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1105
      *((ikptr *)((long )y___3 + (long )(5 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(5 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1106
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1107
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___3;
      }
#line 1108
      return (y___3);
    } else
#line 1110
    if (((int )fst & 7) == 5) {
#line 1112
      size___1 = *((ikptr *)((long )fst + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1113
      if ((int )sizeof(ikptr ) == 4) {
#line 1113
        tmp___9 = 2;
      } else {
#line 1113
        tmp___9 = 3;
      }
#line 1113
      if (size___1 & (unsigned long )((1 << (tmp___9 + 1)) - 1)) {
        {
#line 1117
        tmp___7 = gc_alloc_new_ptr___0((int )(size___1 + (ikptr )((int )sizeof(ikptr ))),
                                       gc);
#line 1117
        y___4 = tmp___7 + 5UL;
#line 1118
        *((ikptr *)((long )y___4 + -5L) + 0) = fst;
#line 1121
        p = (y___4 + (ikptr )((int )sizeof(ikptr ))) - 5UL;
#line 1122
        q = (x + (ikptr )((int )sizeof(ikptr ))) - 5UL;
#line 1123
        *((ikptr *)((long )p) + 0) = *((ikptr *)((long )q) + 0);
#line 1124
        i = (ikptr )((int )sizeof(ikptr ));
        }
        {
#line 1124
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1124
          if (! (i < size___1)) {
#line 1124
            goto while_break;
          }
#line 1125
          *((ikptr *)((long )p + (long )i) + 0) = *((ikptr *)((long )q + (long )i) + 0);
#line 1126
          *((ikptr *)((long )p + (long )(i + (ikptr )((int )sizeof(ikptr )))) + 0) = *((ikptr *)((long )q + (long )(i + (ikptr )((int )sizeof(ikptr )))) + 0);
#line 1124
          i += (ikptr )(2 * (int )sizeof(ikptr ));
        }
        while_break: /* CIL Label */ ;
        }
#line 1129
        *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1130
        *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___4;
#line 1131
        return (y___4);
      } else {
        {
#line 1135
        tmp___8 = gc_alloc_new_ptr___0((int )(size___1 + (ikptr )(2 * (int )sizeof(ikptr ))),
                                       gc);
#line 1135
        y___5 = tmp___8 + 5UL;
#line 1136
        *((ikptr *)((long )y___5 + -5L) + 0) = fst;
#line 1139
        p___0 = (y___5 + (ikptr )((int )sizeof(ikptr ))) - 5UL;
#line 1140
        q___0 = (x + (ikptr )((int )sizeof(ikptr ))) - 5UL;
#line 1141
        i___0 = (ikptr )0;
        }
        {
#line 1141
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1141
          if (! (i___0 < size___1)) {
#line 1141
            goto while_break___0;
          }
#line 1142
          *((ikptr *)((long )p___0 + (long )i___0) + 0) = *((ikptr *)((long )q___0 + (long )i___0) + 0);
#line 1143
          *((ikptr *)((long )p___0 + (long )(i___0 + (ikptr )((int )sizeof(ikptr )))) + 0) = *((ikptr *)((long )q___0 + (long )(i___0 + (ikptr )((int )sizeof(ikptr )))) + 0);
#line 1141
          i___0 += (ikptr )(2 * (int )sizeof(ikptr ));
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1146
        *((ikptr *)((long )y___5 + (long )((size___1 + (ikptr )((int )sizeof(ikptr ))) - 5UL)) + 0) = (ikptr )0;
#line 1147
        *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1148
        *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___5;
#line 1149
        return (y___5);
      }
    } else
#line 1152
    if (fst == 47UL) {
      {
#line 1153
      entry = x + (ikptr )(6 * (int )sizeof(ikptr ) - 5);
#line 1154
      tmp___10 = add_code_entry___0(gc, entry);
#line 1154
      new_entry = tmp___10;
      }
#line 1155
      return (new_entry - (ikptr )(6 * (int )sizeof(ikptr ) - 5));
    } else
#line 1157
    if (fst == 31UL) {
      {
#line 1158
      top = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1159
      size___2 = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1165
      next = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1166
      tmp___11 = gc_alloc_new_ptr___0(4 * (int )sizeof(ikptr ), gc);
#line 1166
      y___6 = tmp___11 + 5UL;
#line 1167
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1168
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___6;
      }
#line 1169
      if ((int )sizeof(ikptr ) == 4) {
#line 1169
        tmp___12 = 2;
      } else {
#line 1169
        tmp___12 = 3;
      }
#line 1169
      if ((int )sizeof(ikptr ) == 4) {
#line 1169
        tmp___13 = 2;
      } else {
#line 1169
        tmp___13 = 3;
      }
      {
#line 1169
      tmp___14 = gc_alloc_new_data___0((int )((((size___2 + (ikptr )(2 * (int )sizeof(ikptr ))) - 1UL) >> (tmp___12 + 1)) << (tmp___13 + 1)),
                                       gc);
#line 1169
      new_top = tmp___14;
#line 1170
      memcpy((void */* __restrict  */)((char *)((long )new_top)), (void const   */* __restrict  */)((char *)((long )top)),
             size___2);
#line 1173
      collect_stack___0(gc, new_top, new_top + size___2);
#line 1174
      *((ikptr *)((long )y___6 + -5L) + 0) = (ikptr )31;
#line 1175
      *((ikptr *)((long )y___6 + (long )((int )sizeof(ikptr ) - 5)) + 0) = new_top;
#line 1176
      *((ikptr *)((long )y___6 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = size___2;
#line 1177
      *((ikptr *)((long )y___6 + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = next;
      }
#line 1181
      return (y___6);
    } else
#line 1183
    if (fst == 287UL) {
      {
#line 1184
      tmp___15 = gc_alloc_new_data___0(4 * (int )sizeof(ikptr ), gc);
#line 1184
      y___7 = tmp___15 + 5UL;
#line 1185
      top___0 = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1186
      next___0 = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1187
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1188
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___7;
#line 1189
      *((ikptr *)((long )y___7 + -5L) + 0) = fst;
#line 1190
      *((ikptr *)((long )y___7 + (long )((int )sizeof(ikptr ) - 5)) + 0) = top___0;
#line 1191
      *((ikptr *)((long )y___7 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = add_object_proc___0(gc,
                                                                                                   next___0);
      }
#line 1193
      return (y___7);
    } else
#line 1195
    if (((int )fst & 7) == 1) {
      {
#line 1197
      tmp___16 = gc_alloc_new_ptr___0(4 * (int )sizeof(ikptr ), gc);
#line 1197
      y___8 = tmp___16 + 5UL;
#line 1198
      *((ikptr *)((long )y___8 + -5L) + 0) = fst;
#line 1199
      key = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1200
      *((ikptr *)((long )y___8 + (long )((int )sizeof(ikptr ) - 5)) + 0) = key;
#line 1201
      *((ikptr *)((long )y___8 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1202
      *((ikptr *)((long )y___8 + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0);
      }
#line 1203
      if (! ((key & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
#line 1203
        if (((int )key & 7) != 7) {
#line 1204
          gen___0 = (int )(*(gc->segment_vector + (key >> 12)) & 15U);
#line 1205
          if (gen___0 <= gc->collect_gen) {
            {
#line 1207
            gc_tconc_push___0(gc, y___8);
            }
          }
        }
      }
#line 1210
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1211
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___8;
#line 1212
      return (y___8);
    } else
#line 1214
    if (((long )fst & 63L) == 63L) {
      {
#line 1215
      tmp___17 = gc_alloc_new_ptr___0(14 * (int )sizeof(ikptr ), gc);
#line 1215
      y___9 = tmp___17 + 5UL;
#line 1216
      *((ikptr *)((long )y___9 + -5L) + 0) = fst;
#line 1218
      i___1 = (long )((int )sizeof(ikptr ));
      }
      {
#line 1218
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1218
        if (! (i___1 < (long )(14 * (int )sizeof(ikptr )))) {
#line 1218
          goto while_break___1;
        }
#line 1219
        *((ikptr *)((long )y___9 + (i___1 - 5L)) + 0) = *((ikptr *)((long )x + (i___1 - 5L)) + 0);
#line 1218
        i___1 += (long )((int )sizeof(ikptr ));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1221
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1222
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___9;
#line 1223
      return (y___9);
    } else
#line 1225
    if (fst == 23UL) {
      {
#line 1226
      tmp___18 = gc_alloc_new_data___0(16, gc);
#line 1226
      new = tmp___18 + 5UL;
#line 1227
      *((ikptr *)((long )new + -5L) + 0) = (ikptr )23;
#line 1228
      *((double *)((char *)((long )new) + 3)) = *((double *)((char *)((long )x) + 3));
#line 1229
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1230
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = new;
      }
#line 1231
      return (new);
    } else
#line 1233
    if ((fst & 7UL) == 3UL) {
#line 1234
      len = (long )(fst >> 4);
#line 1235
      if ((int )sizeof(ikptr ) == 4) {
#line 1235
        tmp___19 = 2;
      } else {
#line 1235
        tmp___19 = 3;
      }
#line 1235
      if ((int )sizeof(ikptr ) == 4) {
#line 1235
        tmp___20 = 2;
      } else {
#line 1235
        tmp___20 = 3;
      }
      {
#line 1235
      memreq___0 = (((((long )((int )sizeof(ikptr )) + len * (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___19 + 1)) << (tmp___20 + 1);
#line 1236
      tmp___21 = gc_alloc_new_data___0((int )memreq___0, gc);
#line 1236
      new___0 = tmp___21 + 5UL;
#line 1237
      memcpy((void */* __restrict  */)((char *)((long )(new___0 - 5UL))), (void const   */* __restrict  */)((char *)((long )(x - 5UL))),
             (size_t )memreq___0);
#line 1240
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1241
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = new___0;
      }
#line 1242
      return (new___0);
    } else
#line 1244
    if (fst == 39UL) {
      {
#line 1245
      tmp___22 = gc_alloc_new_data___0(4 * (int )sizeof(ikptr ), gc);
#line 1245
      y___10 = tmp___22 + 5UL;
#line 1246
      num = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1247
      den = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1248
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1249
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___10;
#line 1250
      *((ikptr *)((long )y___10 + -5L) + 0) = fst;
#line 1251
      *((ikptr *)((long )y___10 + (long )((int )sizeof(ikptr ) - 5)) + 0) = add_object_proc___0(gc,
                                                                                                num);
#line 1252
      *((ikptr *)((long )y___10 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = add_object_proc___0(gc,
                                                                                                    den);
      }
#line 1253
      return (y___10);
    } else
#line 1255
    if (fst == 55UL) {
      {
#line 1256
      tmp___23 = gc_alloc_new_data___0(4 * (int )sizeof(ikptr ), gc);
#line 1256
      y___11 = tmp___23 + 5UL;
#line 1257
      rl = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1258
      im = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1259
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1260
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___11;
#line 1261
      *((ikptr *)((long )y___11 + -5L) + 0) = fst;
#line 1262
      *((ikptr *)((long )y___11 + (long )((int )sizeof(ikptr ) - 5)) + 0) = add_object_proc___0(gc,
                                                                                                rl);
#line 1263
      *((ikptr *)((long )y___11 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = add_object_proc___0(gc,
                                                                                                    im);
      }
#line 1264
      return (y___11);
    } else
#line 1266
    if (fst == 71UL) {
      {
#line 1267
      tmp___24 = gc_alloc_new_data___0(4 * (int )sizeof(ikptr ), gc);
#line 1267
      y___12 = tmp___24 + 5UL;
#line 1268
      rl___0 = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1269
      im___0 = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 1270
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1271
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___12;
#line 1272
      *((ikptr *)((long )y___12 + -5L) + 0) = fst;
#line 1273
      *((ikptr *)((long )y___12 + (long )((int )sizeof(ikptr ) - 5)) + 0) = add_object_proc___0(gc,
                                                                                                rl___0);
#line 1274
      *((ikptr *)((long )y___12 + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = add_object_proc___0(gc,
                                                                                                    im___0);
      }
#line 1275
      return (y___12);
    } else
#line 1277
    if (fst == 263UL) {
      {
#line 1278
      tmp___25 = gc_alloc_new_data___0(2 * (int )sizeof(ikptr ), gc);
#line 1278
      y___13 = tmp___25 + 5UL;
#line 1279
      *((ikptr *)((long )y___13 + -5L) + 0) = (ikptr )263;
#line 1280
      *((ikptr *)((long )y___13 + (long )((int )sizeof(ikptr ) - 5)) + 0) = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 1281
      *((ikptr *)((long )x + -5L) + 0) = (ikptr )-1;
#line 1282
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0) = y___13;
      }
#line 1283
      return (y___13);
    } else {
      {
#line 1286
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unhandled vector with fst=0x%016lx\n",
              (long )fst);
#line 1289
      exit(-1);
      }
    }
  } else
#line 1292
  if (tag == 6) {
#line 1293
    if ((fst & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 1294
      if ((int )sizeof(ikptr ) == 4) {
#line 1294
        tmp___26 = 2;
      } else {
#line 1294
        tmp___26 = 3;
      }
#line 1294
      strlen___0 = (long )fst >> tmp___26;
#line 1295
      if ((int )sizeof(ikptr ) == 4) {
#line 1295
        tmp___27 = 2;
      } else {
#line 1295
        tmp___27 = 3;
      }
#line 1295
      if ((int )sizeof(ikptr ) == 4) {
#line 1295
        tmp___28 = 2;
      } else {
#line 1295
        tmp___28 = 3;
      }
      {
#line 1295
      memreq___1 = ((((strlen___0 * 4L + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___27 + 1)) << (tmp___28 + 1);
#line 1296
      tmp___29 = gc_alloc_new_data___0((int )memreq___1, gc);
#line 1296
      new_str = tmp___29 + 6UL;
#line 1297
      *((ikptr *)((long )new_str + -6L) + 0) = fst;
#line 1298
      memcpy((void */* __restrict  */)((char *)((long )(new_str + (ikptr )((int )sizeof(ikptr ) - 6)))),
             (void const   */* __restrict  */)((char *)((long )(x + (ikptr )((int )sizeof(ikptr ) - 6)))),
             (size_t )(strlen___0 * 4L));
#line 1301
      *((ikptr *)((long )x + -6L) + 0) = (ikptr )-1;
#line 1302
      *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 6)) + 0) = new_str;
      }
#line 1306
      return (new_str);
    } else {
      {
#line 1309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unhandled string 0x%016lx with fst=0x%016lx\n",
              (long )x, (long )fst);
#line 1311
      exit(-1);
      }
    }
  } else
#line 1314
  if (tag == 2) {
#line 1315
    if ((int )sizeof(ikptr ) == 4) {
#line 1315
      tmp___30 = 2;
    } else {
#line 1315
      tmp___30 = 3;
    }
#line 1315
    len___0 = (long )fst >> tmp___30;
#line 1316
    if ((int )sizeof(ikptr ) == 4) {
#line 1316
      tmp___31 = 2;
    } else {
#line 1316
      tmp___31 = 3;
    }
#line 1316
    if ((int )sizeof(ikptr ) == 4) {
#line 1316
      tmp___32 = 2;
    } else {
#line 1316
      tmp___32 = 3;
    }
    {
#line 1316
    memreq___2 = (((((len___0 + 8L) + 1L) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___31 + 1)) << (tmp___32 + 1);
#line 1317
    tmp___33 = gc_alloc_new_data___0((int )memreq___2, gc);
#line 1317
    new_bv = tmp___33 + 2UL;
#line 1318
    *((ikptr *)((long )new_bv + -2L) + 0) = fst;
#line 1319
    memcpy((void */* __restrict  */)((char *)((long )(new_bv + 6UL))), (void const   */* __restrict  */)((char *)((long )(x + 6UL))),
           (size_t )(len___0 + 1L));
#line 1322
    *((ikptr *)((long )x + -2L) + 0) = (ikptr )-1;
#line 1323
    *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 2)) + 0) = new_bv;
    }
#line 1324
    return (new_bv);
  }
  {
#line 1326
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unhandled tag: %d\n",
          tag);
#line 1327
  exit(-1);
  }
}
}
#line 1330 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void relocate_new_code___0(ikptr x , gc_t *gc ) 
{ 
  ikptr relocvector ;
  ikptr relocsize ;
  ikptr p ;
  ikptr q ;
  ikptr code ;
  long r ;
  int tmp ;
  long tag ;
  long code_off ;
  ikptr old_object ;
  ikptr new_object ;
  ikptr tmp___0 ;
  long obj_off ;
  int tmp___1 ;
  ikptr old_object___0 ;
  ikptr new_object___0 ;
  ikptr tmp___2 ;
  long obj_off___0 ;
  int tmp___3 ;
  ikptr obj ;
  ikptr displaced_object ;
  long next_word ;
  ikptr relative_distance ;

  {
  {
#line 1332
  relocvector = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 1333
  relocvector = add_object_proc___0(gc, relocvector);
#line 1334
  *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ))) + 0) = relocvector;
#line 1335
  *((ikptr *)((long )x + (long )(4 * (int )sizeof(ikptr ))) + 0) = add_object_proc___0(gc,
                                                                                       *((ikptr *)((long )x + (long )(4 * (int )sizeof(ikptr ))) + 0));
#line 1337
  relocsize = *((ikptr *)((long )relocvector + -5L) + 0);
#line 1338
  p = relocvector + (ikptr )((int )sizeof(ikptr ) - 5);
#line 1339
  q = p + relocsize;
#line 1340
  code = x + (ikptr )(6 * (int )sizeof(ikptr ));
  }
  {
#line 1341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1341
    if (! (p < q)) {
#line 1341
      goto while_break;
    }
#line 1342
    if ((int )sizeof(ikptr ) == 4) {
#line 1342
      tmp = 2;
    } else {
#line 1342
      tmp = 3;
    }
#line 1342
    r = (long )*((ikptr *)((long )p) + 0) >> tmp;
#line 1343
    tag = r & 3L;
#line 1344
    code_off = r >> 2;
#line 1345
    if (tag == 0L) {
      {
#line 1351
      old_object = *((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0);
#line 1352
      tmp___0 = add_object_proc___0(gc, old_object);
#line 1352
      new_object = tmp___0;
#line 1353
      *((ikptr *)((long )code + code_off) + 0) = new_object;
#line 1354
      p += (ikptr )(2 * (int )sizeof(ikptr ));
      }
    } else
#line 1356
    if (tag == 2L) {
#line 1358
      if ((int )sizeof(ikptr ) == 4) {
#line 1358
        tmp___1 = 2;
      } else {
#line 1358
        tmp___1 = 3;
      }
      {
#line 1358
      obj_off = (long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp___1;
#line 1359
      old_object___0 = *((ikptr *)((long )p + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 1360
      tmp___2 = add_object_proc___0(gc, old_object___0);
#line 1360
      new_object___0 = tmp___2;
#line 1361
      *((ikptr *)((long )code + code_off) + 0) = new_object___0 + (ikptr )obj_off;
#line 1362
      p += (ikptr )(3 * (int )sizeof(ikptr ));
      }
    } else
#line 1364
    if (tag == 3L) {
#line 1366
      if ((int )sizeof(ikptr ) == 4) {
#line 1366
        tmp___3 = 2;
      } else {
#line 1366
        tmp___3 = 3;
      }
      {
#line 1366
      obj_off___0 = (long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp___3;
#line 1367
      obj = *((ikptr *)((long )p + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 1372
      obj = add_object_proc___0(gc, obj);
#line 1373
      displaced_object = obj + (ikptr )obj_off___0;
#line 1374
      next_word = (long )((code + (ikptr )code_off) + 4UL);
#line 1375
      relative_distance = displaced_object - (ikptr )next_word;
      }
#line 1376
      if ((long )relative_distance != (long )((int )relative_distance)) {
        {
#line 1377
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"relocation error with relative=0x%016lx\n",
                relative_distance);
#line 1379
        exit(-1);
        }
      }
#line 1381
      *((int *)(code + (ikptr )code_off)) = (int )relative_distance;
#line 1382
      p += (ikptr )(3 * (int )sizeof(ikptr ));
    } else
#line 1384
    if (tag == 1L) {
#line 1386
      p += (ikptr )(2 * (int )sizeof(ikptr ));
    } else {
      {
#line 1389
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid rtag %ld in 0x%016lx\n",
              tag, r);
#line 1390
      exit(-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1393
  return;
}
}
#line 1397 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void collect_loop___0(gc_t *gc ) 
{ 
  int done ;
  qupages_t *qu ;
  ikptr p ;
  ikptr q ;
  qupages_t *next ;
  qupages_t *qu___0 ;
  ikptr p___0 ;
  ikptr q___0 ;
  qupages_t *next___0 ;
  qupages_t *qu___1 ;
  ikptr p___1 ;
  ikptr q___1 ;
  qupages_t *next___1 ;
  qupages_t *codes ;
  ikptr p___2 ;
  ikptr q___2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  qupages_t *next___2 ;
  meta_t *meta ;
  ikptr p___3 ;
  ikptr q___3 ;
  meta_t *meta___0 ;
  ikptr p___4 ;
  ikptr q___4 ;
  meta_t *meta___1 ;
  ikptr p___5 ;
  ikptr q___5 ;
  meta_t *meta___2 ;
  ikptr p___6 ;
  ikptr q___6 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  meta_t *meta___3 ;
  ikptr p___7 ;
  ikptr q___7 ;
  meta_t *meta___4 ;
  ikptr p___8 ;
  ikptr q___8 ;
  meta_t *meta___5 ;
  ikptr p___9 ;
  ikptr q___9 ;
  meta_t *meta___6 ;
  ikptr p___10 ;
  ikptr q___10 ;
  meta_t *meta___7 ;
  ikptr p___11 ;
  ikptr q___11 ;

  {
  {
#line 1400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    done = 1;
#line 1403
    qu = gc->queues[4];
#line 1404
    if (qu) {
#line 1405
      done = 0;
#line 1406
      gc->queues[4] = (qupages_t *)0;
      {
#line 1407
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1408
        p = qu->p;
#line 1409
        q = qu->q;
        {
#line 1410
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1410
          if (! (p < q)) {
#line 1410
            goto while_break___1;
          }
          {
#line 1411
          *((ikptr *)((long )p) + 0) = add_object_proc___0(gc, *((ikptr *)((long )p) + 0));
#line 1412
          p += (ikptr )(2 * (int )sizeof(ikptr ));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1414
        next = qu->next;
#line 1415
        ik_free((void *)qu, (int )sizeof(qupages_t ));
#line 1416
        qu = next;
        }
#line 1407
        if (! qu) {
#line 1407
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1422
    qu___0 = gc->queues[0];
#line 1423
    if (qu___0) {
#line 1424
      done = 0;
#line 1425
      gc->queues[0] = (qupages_t *)0;
      {
#line 1426
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1427
        p___0 = qu___0->p;
#line 1428
        q___0 = qu___0->q;
        {
#line 1429
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1429
          if (! (p___0 < q___0)) {
#line 1429
            goto while_break___3;
          }
          {
#line 1430
          *((ikptr *)((long )p___0) + 0) = add_object_proc___0(gc, *((ikptr *)((long )p___0) + 0));
#line 1431
          p___0 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1433
        next___0 = qu___0->next;
#line 1434
        ik_free((void *)qu___0, (int )sizeof(qupages_t ));
#line 1435
        qu___0 = next___0;
        }
#line 1426
        if (! qu___0) {
#line 1426
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1441
    qu___1 = gc->queues[5];
#line 1442
    if (qu___1) {
#line 1443
      done = 0;
#line 1444
      gc->queues[5] = (qupages_t *)0;
      {
#line 1445
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1446
        p___1 = qu___1->p;
#line 1447
        q___1 = qu___1->q;
        {
#line 1448
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1448
          if (! (p___1 < q___1)) {
#line 1448
            goto while_break___5;
          }
          {
#line 1449
          *((ikptr *)((long )p___1) + 0) = add_object_proc___0(gc, *((ikptr *)((long )p___1) + 0));
#line 1450
          p___1 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 1452
        next___1 = qu___1->next;
#line 1453
        ik_free((void *)qu___1, (int )sizeof(qupages_t ));
#line 1454
        qu___1 = next___1;
        }
#line 1445
        if (! qu___1) {
#line 1445
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 1460
    codes = gc->queues[1];
#line 1461
    if (codes) {
#line 1462
      gc->queues[1] = (qupages_t *)0;
#line 1463
      done = 0;
      {
#line 1464
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1465
        p___2 = codes->p;
#line 1466
        q___2 = codes->q;
        {
#line 1467
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1467
          if (! (p___2 < q___2)) {
#line 1467
            goto while_break___7;
          }
          {
#line 1468
          relocate_new_code___0(p___2, gc);
#line 1469
          alloc_code_count___0 --;
          }
#line 1470
          if ((int )sizeof(ikptr ) == 4) {
#line 1470
            tmp = 2;
          } else {
#line 1470
            tmp = 3;
          }
#line 1470
          if ((int )sizeof(ikptr ) == 4) {
#line 1470
            tmp___0 = 2;
          } else {
#line 1470
            tmp___0 = 3;
          }
#line 1470
          if ((int )sizeof(ikptr ) == 4) {
#line 1470
            tmp___1 = 2;
          } else {
#line 1470
            tmp___1 = 3;
          }
#line 1470
          p___2 += (ikptr )((((((long )(6 * (int )sizeof(ikptr )) + ((long )*((ikptr *)((long )p___2 + (long )((int )sizeof(ikptr ))) + 0) >> tmp)) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1));
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1472
        next___2 = codes->next;
#line 1473
        ik_free((void *)codes, (int )sizeof(qupages_t ));
#line 1474
        codes = next___2;
        }
#line 1464
        if (! codes) {
#line 1464
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1480
    meta = & gc->meta[4];
#line 1481
    p___3 = meta->aq;
#line 1482
    q___3 = meta->ap;
#line 1483
    if (p___3 < q___3) {
#line 1484
      done = 0;
      {
#line 1485
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1486
        meta->aq = q___3;
        {
#line 1487
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1487
          if (! (p___3 < q___3)) {
#line 1487
            goto while_break___9;
          }
          {
#line 1488
          *((ikptr *)((long )p___3) + 0) = add_object_proc___0(gc, *((ikptr *)((long )p___3) + 0));
#line 1489
          p___3 += (ikptr )(2 * (int )sizeof(ikptr ));
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1491
        p___3 = meta->aq;
#line 1492
        q___3 = meta->ap;
#line 1485
        if (! (p___3 < q___3)) {
#line 1485
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 1497
    meta___0 = & gc->meta[5];
#line 1498
    p___4 = meta___0->aq;
#line 1499
    q___4 = meta___0->ap;
#line 1500
    if (p___4 < q___4) {
#line 1501
      done = 0;
      {
#line 1502
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1503
        meta___0->aq = q___4;
        {
#line 1504
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1504
          if (! (p___4 < q___4)) {
#line 1504
            goto while_break___11;
          }
          {
#line 1505
          *((ikptr *)((long )p___4) + 0) = add_object_proc___0(gc, *((ikptr *)((long )p___4) + 0));
#line 1506
          p___4 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1508
        p___4 = meta___0->aq;
#line 1509
        q___4 = meta___0->ap;
#line 1502
        if (! (p___4 < q___4)) {
#line 1502
          goto while_break___10;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 1514
    meta___1 = & gc->meta[0];
#line 1515
    p___5 = meta___1->aq;
#line 1516
    q___5 = meta___1->ap;
#line 1517
    if (p___5 < q___5) {
#line 1518
      done = 0;
      {
#line 1519
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1520
        meta___1->aq = q___5;
        {
#line 1521
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1521
          if (! (p___5 < q___5)) {
#line 1521
            goto while_break___13;
          }
          {
#line 1522
          *((ikptr *)((long )p___5) + 0) = add_object_proc___0(gc, *((ikptr *)((long )p___5) + 0));
#line 1523
          p___5 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 1525
        p___5 = meta___1->aq;
#line 1526
        q___5 = meta___1->ap;
#line 1519
        if (! (p___5 < q___5)) {
#line 1519
          goto while_break___12;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1531
    meta___2 = & gc->meta[1];
#line 1532
    p___6 = meta___2->aq;
#line 1533
    q___6 = meta___2->ap;
#line 1534
    if (p___6 < q___6) {
#line 1535
      done = 0;
      {
#line 1536
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1537
        meta___2->aq = q___6;
        {
#line 1538
        while (1) {
          while_continue___15: /* CIL Label */ ;
          {
#line 1539
          alloc_code_count___0 --;
#line 1540
          relocate_new_code___0(p___6, gc);
          }
#line 1541
          if ((int )sizeof(ikptr ) == 4) {
#line 1541
            tmp___2 = 2;
          } else {
#line 1541
            tmp___2 = 3;
          }
#line 1541
          if ((int )sizeof(ikptr ) == 4) {
#line 1541
            tmp___3 = 2;
          } else {
#line 1541
            tmp___3 = 3;
          }
#line 1541
          if ((int )sizeof(ikptr ) == 4) {
#line 1541
            tmp___4 = 2;
          } else {
#line 1541
            tmp___4 = 3;
          }
#line 1541
          p___6 += (ikptr )((((((long )(6 * (int )sizeof(ikptr )) + ((long )*((ikptr *)((long )p___6 + (long )((int )sizeof(ikptr ))) + 0) >> tmp___2)) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___3 + 1)) << (tmp___4 + 1));
#line 1538
          if (! (p___6 < q___6)) {
#line 1538
            goto while_break___15;
          }
        }
        while_break___15: /* CIL Label */ ;
        }
#line 1543
        p___6 = meta___2->aq;
#line 1544
        q___6 = meta___2->ap;
#line 1536
        if (! (p___6 < q___6)) {
#line 1536
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 1400
    if (! (! done)) {
#line 1400
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1555
  meta___3 = & gc->meta[4];
#line 1556
  p___7 = meta___3->ap;
#line 1557
  q___7 = meta___3->ep;
  {
#line 1558
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1558
    if (! (p___7 < q___7)) {
#line 1558
      goto while_break___16;
    }
#line 1559
    *((ikptr *)((long )p___7) + 0) = (ikptr )0;
#line 1560
    p___7 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1564
  meta___4 = & gc->meta[5];
#line 1565
  p___8 = meta___4->ap;
#line 1566
  q___8 = meta___4->ep;
  {
#line 1567
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 1567
    if (! (p___8 < q___8)) {
#line 1567
      goto while_break___17;
    }
#line 1568
    *((ikptr *)((long )p___8) + 0) = (ikptr )0;
#line 1569
    p___8 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___17: /* CIL Label */ ;
  }
#line 1573
  meta___5 = & gc->meta[0];
#line 1574
  p___9 = meta___5->ap;
#line 1575
  q___9 = meta___5->ep;
  {
#line 1576
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 1576
    if (! (p___9 < q___9)) {
#line 1576
      goto while_break___18;
    }
#line 1577
    *((ikptr *)((long )p___9) + 0) = (ikptr )0;
#line 1578
    p___9 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___18: /* CIL Label */ ;
  }
#line 1582
  meta___6 = & gc->meta[3];
#line 1583
  p___10 = meta___6->ap;
#line 1584
  q___10 = meta___6->ep;
  {
#line 1585
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 1585
    if (! (p___10 < q___10)) {
#line 1585
      goto while_break___19;
    }
#line 1586
    *((ikptr *)((long )p___10) + 0) = (ikptr )0;
#line 1587
    p___10 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___19: /* CIL Label */ ;
  }
#line 1591
  meta___7 = & gc->meta[1];
#line 1592
  p___11 = meta___7->ap;
#line 1593
  q___11 = meta___7->ep;
  {
#line 1594
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 1594
    if (! (p___11 < q___11)) {
#line 1594
      goto while_break___20;
    }
#line 1595
    *((ikptr *)((long )p___11) + 0) = (ikptr )0;
#line 1596
    p___11 += (ikptr )((int )sizeof(ikptr ));
  }
  while_break___20: /* CIL Label */ ;
  }
#line 1600
  return;
}
}
#line 1602 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void fix_weak_pointers___0(gc_t *gc ) 
{ 
  unsigned int *segment_vec ;
  ikpcb *pcb ;
  long lo_idx ;
  long hi_idx ;
  long i ;
  int collect_gen ;
  unsigned int t ;
  ikptr p ;
  ikptr q ;
  ikptr x ;
  int tag ;
  ikptr fst ;
  int x_gen ;

  {
#line 1604
  segment_vec = gc->segment_vector;
#line 1605
  pcb = gc->pcb;
#line 1606
  lo_idx = (long )(pcb->memory_base >> 12);
#line 1607
  hi_idx = (long )(pcb->memory_end >> 12);
#line 1608
  i = lo_idx;
#line 1609
  collect_gen = gc->collect_gen;
  {
#line 1610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1610
    if (! (i < hi_idx)) {
#line 1610
      goto while_break;
    }
#line 1611
    t = *(segment_vec + i);
#line 1612
    if ((t & 3848U) == 1544U) {
#line 1616
      p = (ikptr )(i << 12);
#line 1617
      q = p + 4096UL;
      {
#line 1618
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1618
        if (! (p < q)) {
#line 1618
          goto while_break___0;
        }
#line 1619
        x = *((ikptr *)((long )p) + 0);
#line 1620
        if (! ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
#line 1621
          tag = (int )x & 7;
#line 1622
          if (tag != 7) {
#line 1623
            fst = *((ikptr *)((long )x + (long )(- tag)) + 0);
#line 1624
            if (fst == 0xffffffffffffffffUL) {
#line 1625
              *((ikptr *)((long )p) + 0) = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - tag)) + 0);
            } else {
#line 1627
              x_gen = (int )(*(segment_vec + (x >> 12)) & 15U);
#line 1628
              if (x_gen <= collect_gen) {
#line 1629
                *((ikptr *)((long )p) + 0) = (ikptr )143;
              }
            }
          }
        }
#line 1634
        p += (ikptr )(2 * (int )sizeof(ikptr ));
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1638
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1640
  return;
}
}
#line 1642 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static unsigned int dirty_mask___0[5]  = {      2290649224U,      3435973836U,      4008636142U,      4294967295U, 
        0U};
#line 1651 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static unsigned int cleanup_mask___0[5]  = {      0U,      2290649224U,      3435973836U,      4008636142U, 
        4294967295U};
#line 1661 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void scan_dirty_pointers_page___0(gc_t *gc , long page_idx___1 , int mask ) 
{ 
  unsigned int *segment_vec ;
  unsigned int *dirty_vec ;
  unsigned int t ;
  unsigned int d ;
  unsigned int masked_d ;
  ikptr p ;
  int j ;
  unsigned int new_d ;
  ikptr q ;
  unsigned int card_d ;
  ikptr x ;
  ikptr y ;
  ikptr tmp ;

  {
#line 1663
  segment_vec = (unsigned int *)((long )gc->segment_vector);
#line 1664
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
#line 1665
  t = *(segment_vec + page_idx___1);
#line 1666
  d = *(dirty_vec + page_idx___1);
#line 1667
  masked_d = d & (unsigned int )mask;
#line 1668
  p = (ikptr )(page_idx___1 << 12);
#line 1670
  new_d = 0U;
#line 1671
  j = 0;
  {
#line 1671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1671
    if (! (j < 8)) {
#line 1671
      goto while_break;
    }
#line 1672
    if (masked_d & (unsigned int )(15 << j * 4)) {
#line 1674
      q = p + 512UL;
#line 1675
      card_d = 0U;
      {
#line 1676
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1676
        if (! (p < q)) {
#line 1676
          goto while_break___0;
        }
#line 1677
        x = *((ikptr *)((long )p) + 0);
#line 1678
        if (! ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
#line 1678
          if (! (((int )x & 7) == 7)) {
            {
#line 1681
            tmp = add_object_proc___0(gc, x);
#line 1681
            y = tmp;
#line 1682
            segment_vec = gc->segment_vector;
#line 1683
            *((ikptr *)((long )p) + 0) = y;
#line 1684
            card_d |= *(segment_vec + (y >> 12));
            }
          }
        }
#line 1686
        p += (ikptr )((int )sizeof(ikptr ));
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1688
      card_d = (card_d & 240U) >> 4;
#line 1689
      new_d |= card_d << j * 4;
    } else {
#line 1691
      p += 512UL;
#line 1692
      new_d |= d & (unsigned int )(15 << j * 4);
    }
#line 1671
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1695
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
#line 1696
  new_d &= cleanup_mask___0[t & 15U];
#line 1697
  *(dirty_vec + page_idx___1) = new_d;
#line 1698
  return;
}
}
#line 1700 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void scan_dirty_code_page___0(gc_t *gc , long page_idx___1 ) 
{ 
  ikptr p ;
  ikptr start ;
  ikptr q ;
  unsigned int *segment_vec ;
  unsigned int *dirty_vec ;
  unsigned int t ;
  unsigned int new_d ;
  long j ;
  long code_size ;
  int tmp ;
  ikptr rvec ;
  ikptr len ;
  unsigned long i ;
  unsigned long code_d ;
  ikptr r ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1702
  p = (ikptr )(page_idx___1 << 12);
#line 1703
  start = p;
#line 1704
  q = p + 4096UL;
#line 1705
  segment_vec = (unsigned int *)((long )gc->segment_vector);
#line 1706
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
#line 1708
  t = *(segment_vec + page_idx___1);
#line 1710
  new_d = 0U;
  {
#line 1711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1711
    if (! (p < q)) {
#line 1711
      goto while_break;
    }
#line 1712
    if (*((ikptr *)((long )p) + 0) != 47UL) {
#line 1713
      p = q;
    } else {
#line 1716
      j = ((long )p - (long )start) / 512L;
#line 1717
      if ((int )sizeof(ikptr ) == 4) {
#line 1717
        tmp = 2;
      } else {
#line 1717
        tmp = 3;
      }
      {
#line 1717
      code_size = (long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp;
#line 1718
      relocate_new_code___0(p, gc);
#line 1719
      segment_vec = gc->segment_vector;
#line 1720
      rvec = *((ikptr *)((long )p + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 1721
      len = *((ikptr *)((long )rvec + -5L) + 0);
#line 1724
      code_d = (unsigned long )*(segment_vec + (rvec >> 12));
#line 1725
      i = 0UL;
      }
      {
#line 1725
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1725
        if (! (i < len)) {
#line 1725
          goto while_break___0;
        }
#line 1726
        r = *((ikptr *)((long )rvec + (long )(i + (unsigned long )((int )sizeof(ikptr ) - 5))) + 0);
#line 1727
        if (! ((r & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
#line 1727
          if (! (((int )r & 7) == 7)) {
            {
#line 1730
            r = add_object_proc___0(gc, r);
#line 1731
            segment_vec = gc->segment_vector;
#line 1732
            code_d |= (unsigned long )*(segment_vec + (r >> 12));
            }
          }
        }
#line 1725
        i += (unsigned long )((int )sizeof(ikptr ));
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1735
      new_d = (unsigned int )((unsigned long )new_d | (code_d << j * 4L));
#line 1736
      if ((int )sizeof(ikptr ) == 4) {
#line 1736
        tmp___0 = 2;
      } else {
#line 1736
        tmp___0 = 3;
      }
#line 1736
      if ((int )sizeof(ikptr ) == 4) {
#line 1736
        tmp___1 = 2;
      } else {
#line 1736
        tmp___1 = 3;
      }
#line 1736
      p += (ikptr )(((((code_size + (long )(6 * (int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___0 + 1)) << (tmp___1 + 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1739
  dirty_vec = (unsigned int *)((long )(gc->pcb)->dirty_vector);
#line 1740
  new_d &= cleanup_mask___0[t & 15U];
#line 1741
  *(dirty_vec + page_idx___1) = new_d;
#line 1742
  return;
}
}
#line 1748 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void scan_dirty_pages___0(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  long lo_idx ;
  long hi_idx ;
  unsigned int *dirty_vec ;
  unsigned int *segment_vec ;
  int collect_gen ;
  unsigned int mask ;
  long i ;
  unsigned int d ;
  unsigned int t ;
  int tgen ;
  int type ;

  {
#line 1750
  pcb = gc->pcb;
#line 1751
  lo_idx = (long )(pcb->memory_base >> 12);
#line 1752
  hi_idx = (long )(pcb->memory_end >> 12);
#line 1753
  dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1754
  segment_vec = (unsigned int *)((long )pcb->segment_vector);
#line 1755
  collect_gen = gc->collect_gen;
#line 1756
  mask = dirty_mask___0[collect_gen];
#line 1757
  i = lo_idx;
  {
#line 1758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1758
    if (! (i < hi_idx)) {
#line 1758
      goto while_break;
    }
#line 1759
    d = *(dirty_vec + i);
#line 1760
    if (d & mask) {
#line 1761
      t = *(segment_vec + i);
#line 1762
      tgen = (int )(t & 15U);
#line 1763
      if (tgen > collect_gen) {
#line 1764
        type = (int )(t & 3840U);
#line 1765
        if (type == 768) {
          {
#line 1766
          scan_dirty_pointers_page___0(gc, i, (int )mask);
#line 1767
          dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1768
          segment_vec = (unsigned int *)((long )pcb->segment_vector);
          }
        } else
#line 1770
        if (type == 1792) {
          {
#line 1771
          scan_dirty_pointers_page___0(gc, i, (int )mask);
#line 1772
          dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1773
          segment_vec = (unsigned int *)((long )pcb->segment_vector);
          }
        } else
#line 1775
        if (type == 1536) {
          {
#line 1776
          scan_dirty_pointers_page___0(gc, i, (int )mask);
#line 1777
          dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1778
          segment_vec = (unsigned int *)((long )pcb->segment_vector);
          }
        } else
#line 1780
        if (type == 1280) {
          {
#line 1781
          scan_dirty_code_page___0(gc, i);
#line 1782
          dirty_vec = (unsigned int *)((long )pcb->dirty_vector);
#line 1783
          segment_vec = (unsigned int *)((long )pcb->segment_vector);
          }
        } else
#line 1785
        if (t & 61440U) {
          {
#line 1786
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: unhandled scan of type 0x%08x\n",
                  t);
#line 1787
          exit(-1);
          }
        }
      }
    }
#line 1791
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1793
  return;
}
}
#line 1798 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void deallocate_unused_pages___0(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  int collect_gen ;
  unsigned int *segment_vec ;
  ikptr memory_base ;
  ikptr memory_end ;
  ikptr lo_idx ;
  ikptr hi_idx ;
  ikptr i ;
  unsigned int t ;
  int gen ;

  {
#line 1800
  pcb = gc->pcb;
#line 1801
  collect_gen = gc->collect_gen;
#line 1802
  segment_vec = pcb->segment_vector;
#line 1803
  memory_base = pcb->memory_base;
#line 1804
  memory_end = pcb->memory_end;
#line 1805
  lo_idx = memory_base >> 12;
#line 1806
  hi_idx = memory_end >> 12;
#line 1807
  i = lo_idx;
  {
#line 1808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1808
    if (! (i < hi_idx)) {
#line 1808
      goto while_break;
    }
#line 1809
    t = *(segment_vec + i);
#line 1810
    if (t & 983040U) {
#line 1811
      gen = (int )(t & 7U);
#line 1812
      if (gen <= collect_gen) {
#line 1814
        if (! (t & 8U)) {
          {
#line 1817
          ik_munmap_from_segment(i << 12, 4096UL, pcb);
          }
        }
      }
    }
#line 1821
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1823
  return;
}
}
#line 1826 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void fix_new_pages___0(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  unsigned int *segment_vec ;
  ikptr memory_base ;
  ikptr memory_end ;
  ikptr lo_idx ;
  ikptr hi_idx ;
  ikptr i ;

  {
#line 1828
  pcb = gc->pcb;
#line 1829
  segment_vec = pcb->segment_vector;
#line 1830
  memory_base = pcb->memory_base;
#line 1831
  memory_end = pcb->memory_end;
#line 1832
  lo_idx = memory_base >> 12;
#line 1833
  hi_idx = memory_end >> 12;
#line 1834
  i = lo_idx;
  {
#line 1835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1835
    if (! (i < hi_idx)) {
#line 1835
      goto while_break;
    }
#line 1836
    *(segment_vec + i) &= 4294967287U;
#line 1843
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1845
  return;
}
}
#line 1847 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void add_one_tconc___0(ikpcb *pcb , ikptr p ) 
{ 
  ikptr tcbucket ;
  ikptr tc ;
  ikptr d ;
  ikptr new_pair ;

  {
#line 1849
  tcbucket = *((ikptr *)((long )p) + 0);
#line 1850
  tc = *((ikptr *)((long )tcbucket + -5L) + 0);
#line 1852
  d = *((ikptr *)((long )tc + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 1854
  new_pair = p + 1UL;
#line 1855
  *((ikptr *)((long )d + -1L) + 0) = tcbucket;
#line 1856
  *((ikptr *)((long )d + (long )((int )sizeof(ikptr ) - 1)) + 0) = new_pair;
#line 1857
  *((ikptr *)((long )new_pair + -1L) + 0) = (ikptr )47;
#line 1858
  *((ikptr *)((long )new_pair + (long )((int )sizeof(ikptr ) - 1)) + 0) = (ikptr )47;
#line 1859
  *((ikptr *)((long )tc + (long )((int )sizeof(ikptr ) - 1)) + 0) = new_pair;
#line 1860
  *((ikptr *)((long )tcbucket + -5L) + 0) = (ikptr )(4 * (int )sizeof(ikptr ) - (int )sizeof(ikptr ));
#line 1861
  *((int *)((long )pcb->dirty_vector) + (tc >> 12)) = -1;
#line 1862
  *((int *)((long )pcb->dirty_vector) + (d >> 12)) = -1;
#line 1863
  return;
}
}
#line 1865 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-collect.c"
static void gc_add_tconcs___0(gc_t *gc ) 
{ 
  ikpcb *pcb ;
  ikptr p ;
  ikptr q ;
  ikpages *qu ;
  ikptr p___0 ;
  ikptr q___0 ;
  ikpages *next ;

  {
#line 1867
  if (gc->tconc_base == 0UL) {
#line 1868
    return;
  }
#line 1870
  pcb = gc->pcb;
#line 1872
  p = gc->tconc_base;
#line 1873
  q = gc->tconc_ap;
  {
#line 1874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1874
    if (! (p < q)) {
#line 1874
      goto while_break;
    }
    {
#line 1875
    add_one_tconc___0(pcb, p);
#line 1876
    p += (ikptr )(2 * (int )sizeof(ikptr ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1879
  qu = gc->tconc_queue;
  {
#line 1880
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1880
    if (! qu) {
#line 1880
      goto while_break___0;
    }
#line 1881
    p___0 = qu->base;
#line 1882
    q___0 = p___0 + (ikptr )qu->size;
    {
#line 1883
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1883
      if (! (p___0 < q___0)) {
#line 1883
        goto while_break___1;
      }
      {
#line 1884
      add_one_tconc___0(pcb, p___0);
#line 1885
      p___0 += (ikptr )(2 * (int )sizeof(ikptr ));
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1887
    next = qu->next;
#line 1888
    ik_free((void *)qu, (int )sizeof(ikpages ));
#line 1889
    qu = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1891
  return;
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void *alloc___0(size_t n , int m ) 
{ 
  void *x ;
  void *tmp ;

  {
  {
#line 19
  tmp = calloc(n, (size_t )m);
#line 19
  x = tmp;
  }
#line 20
  if ((unsigned long )x == (unsigned long )((void *)0)) {
    {
#line 21
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR (ikarus): calloc failed!\n");
#line 22
    exit(-1);
    }
  }
#line 24
  return (x);
}
}
#line 27
static ffi_type *scheme_to_ffi_type_cast___0(ikptr nptr ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static ffi_type *scheme_to_ffi_record_type_cast___0(ikptr vec ) 
{ 
  ikptr lenptr ;
  long n ;
  int tmp ;
  ffi_type *t ;
  void *tmp___0 ;
  ffi_type **ts ;
  void *tmp___1 ;
  long i ;

  {
#line 31
  lenptr = *((ikptr *)((long )vec + -5L) + 0);
#line 32
  if (! ((lenptr & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL)) {
    {
#line 33
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NOT A VECTOR 0x%016lx\n",
            vec);
#line 34
    exit(-1);
    }
  }
#line 36
  if ((int )sizeof(ikptr ) == 4) {
#line 36
    tmp = 2;
  } else {
#line 36
    tmp = 3;
  }
  {
#line 36
  n = (long )lenptr >> tmp;
#line 37
  tmp___0 = alloc___0(sizeof(ffi_type ), 1);
#line 37
  t = (ffi_type *)tmp___0;
#line 38
  tmp___1 = alloc___0(sizeof(ffi_type *), (int )(n + 1L));
#line 38
  ts = (ffi_type **)tmp___1;
#line 39
  t->size = (size_t )0;
#line 40
  t->alignment = (unsigned short)0;
#line 41
  t->type = (unsigned short)13;
#line 42
  t->elements = ts;
#line 44
  i = 0L;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < n)) {
#line 44
      goto while_break;
    }
    {
#line 45
    *(ts + i) = scheme_to_ffi_type_cast___0(*((ikptr *)((long )vec + ((long )((int )sizeof(ikptr ) - 5) + i * (long )((int )sizeof(ikptr )))) + 0));
#line 44
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  *(ts + n) = (ffi_type *)0;
#line 48
  return (t);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static ffi_type *scheme_to_ffi_type_cast___0(ikptr nptr ) 
{ 
  ffi_type *tmp ;
  long n ;
  int tmp___0 ;
  ffi_type *tmp___1 ;
  ffi_type *tmp___2 ;

  {
#line 53
  if (((int )nptr & 7) == 5) {
    {
#line 54
    tmp = scheme_to_ffi_record_type_cast___0(nptr);
    }
#line 54
    return (tmp);
  } else
#line 55
  if ((nptr & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 56
    if ((int )sizeof(ikptr ) == 4) {
#line 56
      tmp___0 = 2;
    } else {
#line 56
      tmp___0 = 3;
    }
#line 56
    n = (long )nptr >> tmp___0;
    {
#line 58
    if ((n & 15L) == 1L) {
#line 58
      goto case_1;
    }
#line 59
    if ((n & 15L) == 2L) {
#line 59
      goto case_2;
    }
#line 60
    if ((n & 15L) == 3L) {
#line 60
      goto case_3;
    }
#line 61
    if ((n & 15L) == 4L) {
#line 61
      goto case_4;
    }
#line 62
    if ((n & 15L) == 5L) {
#line 62
      goto case_5;
    }
#line 63
    if ((n & 15L) == 6L) {
#line 63
      goto case_6;
    }
#line 64
    if ((n & 15L) == 7L) {
#line 64
      goto case_7;
    }
#line 65
    if ((n & 15L) == 8L) {
#line 65
      goto case_8;
    }
#line 66
    if ((n & 15L) == 9L) {
#line 66
      goto case_9;
    }
#line 67
    if ((n & 15L) == 10L) {
#line 67
      goto case_10;
    }
#line 68
    if ((n & 15L) == 11L) {
#line 68
      goto case_11;
    }
#line 69
    if ((n & 15L) == 12L) {
#line 69
      goto case_12;
    }
#line 70
    if ((n & 15L) == 13L) {
#line 70
      goto case_13;
    }
#line 71
    if ((n & 15L) == 14L) {
#line 71
      goto case_14;
    }
#line 72
    goto switch_default;
    case_1: /* CIL Label */ 
#line 58
    return (& ffi_type_void);
    case_2: /* CIL Label */ 
#line 59
    return (& ffi_type_uint8);
    case_3: /* CIL Label */ 
#line 60
    return (& ffi_type_sint8);
    case_4: /* CIL Label */ 
#line 61
    return (& ffi_type_uint16);
    case_5: /* CIL Label */ 
#line 62
    return (& ffi_type_sint16);
    case_6: /* CIL Label */ 
#line 63
    return (& ffi_type_uint32);
    case_7: /* CIL Label */ 
#line 64
    return (& ffi_type_sint32);
    case_8: /* CIL Label */ 
#line 65
    if (sizeof(long ) == 4UL) {
#line 65
      tmp___1 = & ffi_type_uint32;
    } else {
#line 65
      tmp___1 = & ffi_type_uint64;
    }
#line 65
    return (tmp___1);
    case_9: /* CIL Label */ 
#line 66
    if (sizeof(long ) == 4UL) {
#line 66
      tmp___2 = & ffi_type_sint32;
    } else {
#line 66
      tmp___2 = & ffi_type_sint64;
    }
#line 66
    return (tmp___2);
    case_10: /* CIL Label */ 
#line 67
    return (& ffi_type_uint64);
    case_11: /* CIL Label */ 
#line 68
    return (& ffi_type_sint64);
    case_12: /* CIL Label */ 
#line 69
    return (& ffi_type_float);
    case_13: /* CIL Label */ 
#line 70
    return (& ffi_type_double);
    case_14: /* CIL Label */ 
#line 71
    return (& ffi_type_pointer);
    switch_default: /* CIL Label */ 
    {
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID ARG %ld",
            n);
#line 74
    exit(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID ARG %ld",
            nptr);
#line 78
    exit(-1);
    }
  }
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void *alloc_room_for_type___0(ffi_type *t ) 
{ 
  void *tmp ;

  {
  {
#line 84
  tmp = alloc___0(t->size, 1);
  }
#line 84
  return (tmp);
}
}
#line 92
static void scheme_to_ffi_value_cast___0(ffi_type *t , ikptr nptr , ikptr p , void *r ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void scheme_to_ffi_record_value_cast___0(ffi_type *t , ikptr nptr , ikptr p ,
                                                void *r ) 
{ 
  ffi_type **ts ;
  char *buf ;
  ikptr lenptr ;
  int n ;
  int tmp ;
  int i ;
  ffi_type *at ;
  ikptr argt ;
  ikptr arg ;

  {
#line 96
  if ((int )t->type != 13) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a struct type\n");
#line 98
    exit(-1);
    }
  }
#line 100
  ts = t->elements;
#line 101
  buf = (char *)r;
#line 102
  lenptr = *((ikptr *)((long )nptr + -5L) + 0);
#line 103
  if ((int )sizeof(ikptr ) == 4) {
#line 103
    tmp = 2;
  } else {
#line 103
    tmp = 3;
  }
#line 103
  n = (int )((long )lenptr >> tmp);
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < n)) {
#line 105
      goto while_break;
    }
    {
#line 106
    at = *(ts + i);
#line 107
    argt = *((ikptr *)((long )nptr + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 108
    arg = *((ikptr *)((long )p + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 109
    scheme_to_ffi_value_cast___0(at, argt, arg, (void *)buf);
#line 110
    buf += at->size;
#line 105
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void scheme_to_ffi_value_cast___0(ffi_type *t , ikptr nptr , ikptr p , void *r ) 
{ 
  long n ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 116
  if (((int )nptr & 7) == 5) {
    {
#line 117
    scheme_to_ffi_record_value_cast___0(t, nptr, p, r);
    }
  } else
#line 118
  if ((nptr & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 119
    if ((int )sizeof(ikptr ) == 4) {
#line 119
      tmp = 2;
    } else {
#line 119
      tmp = 3;
    }
#line 119
    n = (long )nptr >> tmp;
    {
#line 121
    if ((n & 15L) == 1L) {
#line 121
      goto case_1;
    }
#line 123
    if ((n & 15L) == 3L) {
#line 123
      goto case_3;
    }
#line 123
    if ((n & 15L) == 2L) {
#line 123
      goto case_3;
    }
#line 126
    if ((n & 15L) == 5L) {
#line 126
      goto case_5;
    }
#line 126
    if ((n & 15L) == 4L) {
#line 126
      goto case_5;
    }
#line 129
    if ((n & 15L) == 7L) {
#line 129
      goto case_7;
    }
#line 129
    if ((n & 15L) == 6L) {
#line 129
      goto case_7;
    }
#line 132
    if ((n & 15L) == 9L) {
#line 132
      goto case_9;
    }
#line 132
    if ((n & 15L) == 8L) {
#line 132
      goto case_9;
    }
#line 135
    if ((n & 15L) == 11L) {
#line 135
      goto case_11;
    }
#line 135
    if ((n & 15L) == 10L) {
#line 135
      goto case_11;
    }
#line 137
    if ((n & 15L) == 12L) {
#line 137
      goto case_12;
    }
#line 139
    if ((n & 15L) == 13L) {
#line 139
      goto case_13;
    }
#line 141
    if ((n & 15L) == 14L) {
#line 141
      goto case_14;
    }
#line 143
    goto switch_default;
    case_1: /* CIL Label */ 
#line 121
    return;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 124
    tmp___0 = extract_num(p);
#line 124
    *((char *)r) = (char )tmp___0;
    }
#line 124
    return;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 127
    tmp___1 = extract_num(p);
#line 127
    *((short *)r) = (short )tmp___1;
    }
#line 127
    return;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 130
    tmp___2 = extract_num(p);
#line 130
    *((int *)r) = (int )tmp___2;
    }
#line 130
    return;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    {
#line 133
    *((long *)r) = extract_num(p);
    }
#line 133
    return;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 136
    *((long long *)r) = extract_num_longlong(p);
    }
#line 136
    return;
    case_12: /* CIL Label */ 
#line 138
    *((float *)r) = (float )*((double *)((char *)((long )p) + 3));
#line 138
    return;
    case_13: /* CIL Label */ 
#line 140
    *((double *)r) = *((double *)((char *)((long )p) + 3));
#line 140
    return;
    case_14: /* CIL Label */ 
#line 142
    *((void **)r) = (void *)*((ikptr *)((long )p + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 142
    return;
    switch_default: /* CIL Label */ 
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID ARG %ld",
            n);
#line 145
    exit(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID TYPE  0x%016lx\n",
            nptr);
#line 149
    exit(-1);
    }
  }
#line 151
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static ikptr ffi_to_scheme_value_cast___0(int n , void *p , ikpcb *pcb ) 
{ 
  ikptr tmp ;
  ikptr tmp___0 ;
  ikptr tmp___1 ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;
  ikptr tmp___4 ;
  ikptr tmp___5 ;
  ikptr tmp___6 ;
  ikptr tmp___7 ;
  ikptr tmp___8 ;
  ikptr tmp___9 ;
  ikptr tmp___10 ;
  ikptr tmp___11 ;

  {
  {
#line 157
  if ((n & 15) == 1) {
#line 157
    goto case_1;
  }
#line 158
  if ((n & 15) == 2) {
#line 158
    goto case_2;
  }
#line 159
  if ((n & 15) == 3) {
#line 159
    goto case_3;
  }
#line 160
  if ((n & 15) == 4) {
#line 160
    goto case_4;
  }
#line 161
  if ((n & 15) == 5) {
#line 161
    goto case_5;
  }
#line 162
  if ((n & 15) == 6) {
#line 162
    goto case_6;
  }
#line 163
  if ((n & 15) == 7) {
#line 163
    goto case_7;
  }
#line 164
  if ((n & 15) == 8) {
#line 164
    goto case_8;
  }
#line 165
  if ((n & 15) == 9) {
#line 165
    goto case_9;
  }
#line 166
  if ((n & 15) == 10) {
#line 166
    goto case_10;
  }
#line 167
  if ((n & 15) == 11) {
#line 167
    goto case_11;
  }
#line 168
  if ((n & 15) == 12) {
#line 168
    goto case_12;
  }
#line 169
  if ((n & 15) == 13) {
#line 169
    goto case_13;
  }
#line 170
  if ((n & 15) == 14) {
#line 170
    goto case_14;
  }
#line 171
  goto switch_default;
  case_1: /* CIL Label */ 
#line 157
  return ((ikptr )127);
  case_2: /* CIL Label */ 
  {
#line 158
  tmp = u_to_number((unsigned long )*((unsigned char *)p), pcb);
  }
#line 158
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 159
  tmp___0 = s_to_number((long )*((signed char *)p), pcb);
  }
#line 159
  return (tmp___0);
  case_4: /* CIL Label */ 
  {
#line 160
  tmp___1 = u_to_number((unsigned long )*((unsigned short *)p), pcb);
  }
#line 160
  return (tmp___1);
  case_5: /* CIL Label */ 
  {
#line 161
  tmp___2 = s_to_number((long )*((short *)p), pcb);
  }
#line 161
  return (tmp___2);
  case_6: /* CIL Label */ 
  {
#line 162
  tmp___3 = u_to_number((unsigned long )*((unsigned int *)p), pcb);
  }
#line 162
  return (tmp___3);
  case_7: /* CIL Label */ 
  {
#line 163
  tmp___4 = s_to_number((long )*((int *)p), pcb);
  }
#line 163
  return (tmp___4);
  case_8: /* CIL Label */ 
  {
#line 164
  tmp___5 = u_to_number(*((unsigned long *)p), pcb);
  }
#line 164
  return (tmp___5);
  case_9: /* CIL Label */ 
  {
#line 165
  tmp___6 = s_to_number(*((long *)p), pcb);
  }
#line 165
  return (tmp___6);
  case_10: /* CIL Label */ 
  {
#line 166
  tmp___7 = ull_to_number(*((unsigned long long *)p), pcb);
  }
#line 166
  return (tmp___7);
  case_11: /* CIL Label */ 
  {
#line 167
  tmp___8 = sll_to_number(*((long long *)p), pcb);
  }
#line 167
  return (tmp___8);
  case_12: /* CIL Label */ 
  {
#line 168
  tmp___9 = d_to_number((double )*((float *)p), pcb);
  }
#line 168
  return (tmp___9);
  case_13: /* CIL Label */ 
  {
#line 169
  tmp___10 = d_to_number(*((double *)p), pcb);
  }
#line 169
  return (tmp___10);
  case_14: /* CIL Label */ 
  {
#line 170
  tmp___11 = make_pointer((long )*((void **)p), pcb);
  }
#line 170
  return (tmp___11);
  switch_default: /* CIL Label */ 
  {
#line 172
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INVALID ARG %d",
          n);
#line 173
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-ffi.c"
static void generic_callback___0(ffi_cif *cif , void *ret , void **args , void *user_data ) 
{ 
  ikptr data ;
  ikptr proc ;
  ikptr argtypes_conv ;
  ikptr rtype_conv ;
  int n ;
  int tmp ;
  ikpcb *pcb ;
  ikptr code_entry ;
  ikptr code_ptr ;
  int i ;
  ikptr argt ;
  void *argp ;
  int tmp___0 ;
  ikptr rv ;
  int tmp___1 ;
  ikptr tmp___2 ;

  {
#line 410
  data = ((callback_locative *)user_data)->data;
#line 411
  proc = *((ikptr *)((long )data + (long )(((int )sizeof(ikptr ) - 5) + (int )sizeof(ikptr ))) + 0);
#line 412
  argtypes_conv = *((ikptr *)((long )data + (long )(((int )sizeof(ikptr ) - 5) + 2 * (int )sizeof(ikptr ))) + 0);
#line 413
  rtype_conv = *((ikptr *)((long )data + (long )(((int )sizeof(ikptr ) - 5) + 3 * (int )sizeof(ikptr ))) + 0);
#line 414
  if ((int )sizeof(ikptr ) == 4) {
#line 414
    tmp = 2;
  } else {
#line 414
    tmp = 3;
  }
#line 414
  n = (int )((long )*((ikptr *)((long )argtypes_conv + -5L) + 0) >> tmp);
#line 416
  pcb = the_pcb;
#line 417
  code_entry = *((ikptr *)((long )proc + -3L) + 0);
#line 418
  code_ptr = code_entry - (ikptr )(6 * (int )sizeof(ikptr ) - 5);
#line 420
  pcb->frame_pointer = pcb->frame_base;
#line 422
  i = 0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (i < n)) {
#line 422
      goto while_break;
    }
#line 423
    argt = *((ikptr *)((long )argtypes_conv + (long )(((int )sizeof(ikptr ) - 5) + i * (int )sizeof(ikptr ))) + 0);
#line 424
    argp = *(args + i);
#line 425
    if ((int )sizeof(ikptr ) == 4) {
#line 425
      tmp___0 = 2;
    } else {
#line 425
      tmp___0 = 3;
    }
    {
#line 425
    *((ikptr *)((long )pcb->frame_pointer + (long )(-2 * (int )sizeof(ikptr ) - i * (int )sizeof(ikptr ))) + 0) = ffi_to_scheme_value_cast___0((int )((long )argt >> tmp___0),
                                                                                                                                               argp,
                                                                                                                                               pcb);
#line 422
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  if ((int )sizeof(ikptr ) == 4) {
#line 428
    tmp___1 = 2;
  } else {
#line 428
    tmp___1 = 3;
  }
  {
#line 428
  tmp___2 = ik_exec_code(pcb, code_ptr, (ikptr )((long )(- n) << tmp___1), proc);
#line 428
  rv = tmp___2;
#line 432
  scheme_to_ffi_value_cast___0(cif->rtype, rtype_conv, rv, ret);
  }
#line 433
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
static long integer_to_long___0(ikptr x ) 
{ 
  int tmp ;

  {
#line 51
  if ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 52
    if ((int )sizeof(ikptr ) == 4) {
#line 52
      tmp = 2;
    } else {
#line 52
      tmp = 3;
    }
#line 52
    return ((long )x >> tmp);
  } else
#line 54
  if (*((ikptr *)((long )x + -5L) + 0) & 8UL) {
#line 55
    return (- ((long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0)));
  } else {
#line 57
    return ((long )*((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0));
  }
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-pointers.c"
static ikptr double_to_flonum___0(double x , ikpcb *pcb ) 
{ 
  ikptr r ;
  ikptr tmp ;

  {
  {
#line 211
  tmp = ik_safe_alloc(pcb, 16);
#line 211
  r = tmp + 5UL;
#line 212
  *((ikptr *)((long )r + -5L) + 0) = (ikptr )23;
#line 213
  *((double *)((char *)((long )r) + 3)) = x;
  }
#line 214
  return (r);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
static ikptr do_connect___0(ikptr host , ikptr srvc , int socket_type ) 
{ 
  struct addrinfo *info ;
  int err ;
  int tmp ;
  ikptr tmp___0 ;
  struct addrinfo *i ;
  ikptr sock ;
  int s ;
  int tmp___1 ;
  int err___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 149
  tmp = getaddrinfo((char const   */* __restrict  */)((char *)((long )(host + 6UL))),
                    (char const   */* __restrict  */)((char *)((long )(srvc + 6UL))),
                    (struct addrinfo  const  */* __restrict  */)0, (struct addrinfo **/* __restrict  */)(& info));
#line 149
  err = tmp;
  }
#line 153
  if (err) {
    {
#line 155
    if (err == -11) {
#line 155
      goto case_neg_11;
    }
#line 156
    goto switch_default;
    case_neg_11: /* CIL Label */ 
    {
#line 155
    tmp___0 = ik_errno_to_code();
    }
#line 155
    return (tmp___0);
    switch_default: /* CIL Label */ 
#line 156
    return ((ikptr )47);
    switch_break: /* CIL Label */ ;
    }
  }
#line 159
  i = info;
#line 160
  sock = (ikptr )47;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! i) {
#line 161
      goto while_break;
    }
#line 162
    if (i->ai_socktype != socket_type) {
#line 163
      i = i->ai_next;
    } else {
      {
#line 165
      tmp___1 = socket(i->ai_family, i->ai_socktype, i->ai_protocol);
#line 165
      s = tmp___1;
      }
#line 166
      if (s < 0) {
        {
#line 167
        sock = ik_errno_to_code();
#line 168
        i = i->ai_next;
        }
      } else {
        {
#line 170
        tmp___2 = connect(s, (struct sockaddr  const  *)i->ai_addr, i->ai_addrlen);
#line 170
        err___0 = tmp___2;
        }
#line 171
        if (err___0 < 0) {
          {
#line 172
          sock = ik_errno_to_code();
#line 173
          i = i->ai_next;
          }
        } else {
#line 175
          if ((int )sizeof(ikptr ) == 4) {
#line 175
            tmp___3 = 2;
          } else {
#line 175
            tmp___3 = 3;
          }
#line 175
          sock = (ikptr )((long )s << tmp___3);
#line 176
          i = (struct addrinfo *)0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  freeaddrinfo(info);
  }
#line 182
  return (sock);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-io.c"
static ikptr timespec_bytevector___0(struct timespec *s , ikpcb *pcb ) 
{ 
  int len ;
  ikptr r ;
  int tmp ;
  int tmp___0 ;
  ikptr tmp___1 ;
  int tmp___2 ;

  {
#line 303
  len = (int )sizeof(struct timespec );
#line 304
  if ((int )sizeof(ikptr ) == 4) {
#line 304
    tmp = 2;
  } else {
#line 304
    tmp = 3;
  }
#line 304
  if ((int )sizeof(ikptr ) == 4) {
#line 304
    tmp___0 = 2;
  } else {
#line 304
    tmp___0 = 3;
  }
  {
#line 304
  tmp___1 = ik_safe_alloc(pcb, (((((8 + len) + 3) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp + 1)) << (tmp___0 + 1));
#line 304
  r = tmp___1;
  }
#line 305
  if ((int )sizeof(ikptr ) == 4) {
#line 305
    tmp___2 = 2;
  } else {
#line 305
    tmp___2 = 3;
  }
  {
#line 305
  *((ikptr *)((long )r) + 0) = (ikptr )((long )(len + 2) << tmp___2);
#line 306
  *((char *)(r + 8UL)) = (char )sizeof(s->tv_sec);
#line 307
  *((char *)((r + 8UL) + 1UL)) = (char )sizeof(s->tv_nsec);
#line 308
  memcpy((void */* __restrict  */)((char *)((r + 8UL) + 2UL)), (void const   */* __restrict  */)s,
         (size_t )len);
#line 309
  *((char *)(((r + 8UL) + (ikptr )len) + 2UL)) = (char)0;
  }
#line 310
  return (r + 2UL);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static ikptr ik_fasl_read___0(ikpcb *pcb , fasl_port *p ) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static ikptr alloc_code___0(long size , ikpcb *pcb , fasl_port *p ) 
{ 
  long asize ;
  int tmp ;
  int tmp___0 ;
  ikptr ap ;
  ikptr nap ;
  ikptr mem ;
  ikptr tmp___1 ;
  long bytes_remaining ;
  long previous_bytes ;
  long asize___0 ;
  ikptr mem___0 ;
  ikptr tmp___2 ;

  {
#line 127
  if ((int )sizeof(ikptr ) == 4) {
#line 127
    tmp = 2;
  } else {
#line 127
    tmp = 3;
  }
#line 127
  if ((int )sizeof(ikptr ) == 4) {
#line 127
    tmp___0 = 2;
  } else {
#line 127
    tmp___0 = 3;
  }
#line 127
  asize = (((size + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp + 1)) << (tmp___0 + 1);
#line 128
  ap = p->code_ap;
#line 129
  nap = ap + (ikptr )asize;
#line 130
  if (nap <= p->code_ep) {
#line 131
    p->code_ap = nap;
#line 132
    return (ap);
  } else
#line 133
  if (asize < 4096L) {
    {
#line 134
    tmp___1 = ik_mmap_code(4096UL, 0, pcb);
#line 134
    mem = tmp___1;
#line 135
    bytes_remaining = 4096L - asize;
#line 136
    previous_bytes = (long )(p->code_ep - ap);
    }
#line 138
    if (bytes_remaining <= previous_bytes) {
#line 139
      return (mem);
    } else {
#line 141
      p->code_ap = mem + (ikptr )asize;
#line 142
      p->code_ep = mem + 4096UL;
#line 143
      return (mem);
    }
  } else {
    {
#line 146
    asize___0 = (long )(((4095UL + (unsigned long )size) >> 12) << 12);
#line 147
    tmp___2 = ik_mmap_code((unsigned long )asize___0, 0, pcb);
#line 147
    mem___0 = tmp___2;
    }
#line 148
    return (mem___0);
  }
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static char fasl_read_byte___0(fasl_port *p ) 
{ 
  char c ;

  {
#line 225
  if ((unsigned long )p->memp < (unsigned long )p->memq) {
#line 226
    c = *(p->memp);
#line 227
    (p->memp) ++;
#line 228
    return (c);
  } else {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fasl_read_byte: read beyond eof\n");
#line 231
    exit(-1);
    }
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static void fasl_read_buf___0(fasl_port *p , void *buf , int n ) 
{ 


  {
#line 236
  if ((unsigned long )(p->memp + n) <= (unsigned long )p->memq) {
    {
#line 237
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)p->memp,
           (size_t )n);
#line 238
    p->memp += n;
    }
  } else {
    {
#line 240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fasl_read_buf: read beyond eof\n");
#line 241
    exit(-1);
    }
  }
#line 243
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static ikptr do_read___0(ikpcb *pcb , fasl_port *p ) 
{ 
  char c ;
  char tmp ;
  int put_mark_index ;
  int idx ;
  ikptr tmp___0 ;
  long code_size ;
  ikptr freevars ;
  ikptr annotation ;
  ikptr tmp___1 ;
  ikptr code ;
  int tmp___2 ;
  int tmp___3 ;
  ikptr tmp___4 ;
  int tmp___5 ;
  ikptr pair ;
  ikptr tmp___6 ;
  ikptr str ;
  ikptr tmp___7 ;
  ikptr sym ;
  ikptr tmp___8 ;
  long len ;
  long size ;
  int tmp___9 ;
  int tmp___10 ;
  ikptr str___0 ;
  ikptr tmp___11 ;
  int tmp___12 ;
  unsigned char *pi ;
  ikchar *pj ;
  long i ;
  long len___0 ;
  long size___0 ;
  int tmp___13 ;
  int tmp___14 ;
  ikptr str___1 ;
  ikptr tmp___15 ;
  int tmp___16 ;
  long i___0 ;
  ikchar c___0 ;
  long len___1 ;
  long size___1 ;
  int tmp___17 ;
  int tmp___18 ;
  ikptr vec ;
  ikptr tmp___19 ;
  int tmp___20 ;
  long i___1 ;
  ikptr fixn ;
  unsigned char x ;
  char tmp___21 ;
  ikptr pretty ;
  ikptr tmp___22 ;
  ikptr unique ;
  ikptr tmp___23 ;
  ikptr sym___0 ;
  ikptr tmp___24 ;
  ikptr name ;
  ikptr tmp___25 ;
  ikptr symb ;
  ikptr tmp___26 ;
  long i___2 ;
  long n ;
  ikptr fields ;
  int tmp___27 ;
  int tmp___28 ;
  ikptr tmp___29 ;
  ikptr ptr ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  ikptr gensym_val ;
  ikptr rtd ;
  int tmp___34 ;
  int tmp___35 ;
  ikptr tmp___36 ;
  ikptr base_rtd ;
  int tmp___37 ;
  ikptr proc ;
  int tmp___38 ;
  int tmp___39 ;
  ikptr tmp___40 ;
  ikptr code___0 ;
  ikptr tmp___41 ;
  int idx___0 ;
  ikptr obj ;
  long len___2 ;
  long size___2 ;
  int tmp___42 ;
  int tmp___43 ;
  ikptr x___0 ;
  ikptr tmp___44 ;
  int tmp___45 ;
  int len___3 ;
  char tmp___46 ;
  ikptr pair___0 ;
  ikptr tmp___47 ;
  int i___3 ;
  ikptr pt ;
  long len___4 ;
  ikptr pair___1 ;
  ikptr tmp___48 ;
  long i___4 ;
  ikptr pt___0 ;
  ikptr x___1 ;
  ikptr tmp___49 ;
  int n___0 ;
  long len___5 ;
  long sign ;
  unsigned long tag ;
  ikptr x___2 ;
  int tmp___50 ;
  int tmp___51 ;
  ikptr tmp___52 ;
  ikptr real ;
  ikptr tmp___53 ;
  ikptr imag ;
  ikptr tmp___54 ;
  ikptr x___3 ;

  {
  {
#line 253
  tmp = fasl_read_byte___0(p);
#line 253
  c = tmp;
#line 254
  put_mark_index = 0;
  }
#line 255
  if ((int )c == 62) {
    {
#line 256
    idx = 0;
#line 257
    fasl_read_buf___0(p, (void *)(& idx), (int )sizeof(int ));
#line 258
    put_mark_index = idx;
#line 259
    c = fasl_read_byte___0(p);
    }
#line 260
    if (idx <= 0) {
      {
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fasl_read: invalid index %d\n",
              idx);
#line 262
      exit(-1);
      }
    }
#line 264
    if (p->marks) {
#line 265
      if (idx >= p->marks_size) {
        {
#line 266
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG: mark too big: %d\n",
                idx);
#line 267
        exit(-1);
        }
      }
#line 269
      if (idx < p->marks_size) {
#line 270
        if (*(p->marks + idx) != 0UL) {
          {
#line 271
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mark %d already set\n",
                  idx);
#line 272
          ik_print(*(p->marks + idx));
#line 273
          exit(-1);
          }
        }
      }
    } else {
      {
#line 279
      tmp___0 = ik_mmap(8192UL * sizeof(ikptr *));
#line 279
      p->marks = (ikptr *)((long )tmp___0);
#line 280
      bzero((void *)p->marks, 8192UL * sizeof(ikptr *));
#line 281
      p->marks_size = 8192;
      }
    }
  }
#line 284
  if ((int )c == 120) {
    {
#line 287
    fasl_read_buf___0(p, (void *)(& code_size), (int )sizeof(long ));
#line 288
    fasl_read_buf___0(p, (void *)(& freevars), (int )sizeof(ikptr ));
#line 289
    tmp___1 = do_read___0(pcb, p);
#line 289
    annotation = tmp___1;
    }
#line 290
    if ((int )sizeof(ikptr ) == 4) {
#line 290
      tmp___2 = 2;
    } else {
#line 290
      tmp___2 = 3;
    }
#line 290
    if ((int )sizeof(ikptr ) == 4) {
#line 290
      tmp___3 = 2;
    } else {
#line 290
      tmp___3 = 3;
    }
    {
#line 290
    tmp___4 = alloc_code___0(((((code_size + (long )(6 * (int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___2 + 1)) << (tmp___3 + 1),
                             pcb, p);
#line 290
    code = tmp___4;
#line 291
    *((ikptr *)((long )code) + 0) = (ikptr )47;
    }
#line 292
    if ((int )sizeof(ikptr ) == 4) {
#line 292
      tmp___5 = 2;
    } else {
#line 292
      tmp___5 = 3;
    }
    {
#line 292
    *((ikptr *)((long )code + (long )((int )sizeof(ikptr ))) + 0) = (ikptr )(code_size << tmp___5);
#line 293
    *((ikptr *)((long )code + (long )(3 * (int )sizeof(ikptr ))) + 0) = freevars;
#line 294
    *((ikptr *)((long )code + (long )(4 * (int )sizeof(ikptr ))) + 0) = annotation;
#line 295
    fasl_read_buf___0(p, (void *)((long )(6 * (int )sizeof(ikptr )) + (long )code),
                      (int )code_size);
    }
#line 296
    if (put_mark_index) {
#line 297
      *(p->marks + put_mark_index) = code + 5UL;
    }
    {
#line 299
    *((ikptr *)((long )code + (long )(2 * (int )sizeof(ikptr ))) + 0) = do_read___0(pcb,
                                                                                    p);
#line 300
    ik_relocate_code(code);
    }
#line 301
    return (code + 5UL);
  } else
#line 303
  if ((int )c == 80) {
    {
#line 304
    tmp___6 = ik_unsafe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 304
    pair = tmp___6 + 1UL;
    }
#line 305
    if (put_mark_index) {
#line 306
      *(p->marks + put_mark_index) = pair;
    }
    {
#line 308
    *((ikptr *)((long )pair + -1L) + 0) = do_read___0(pcb, p);
#line 309
    *((ikptr *)((long )pair + (long )((int )sizeof(ikptr ) - 1)) + 0) = do_read___0(pcb,
                                                                                    p);
    }
#line 310
    return (pair);
  } else
#line 312
  if ((int )c == 77) {
    {
#line 314
    tmp___7 = do_read___0(pcb, p);
#line 314
    str = tmp___7;
#line 315
    tmp___8 = ikrt_string_to_symbol(str, pcb);
#line 315
    sym = tmp___8;
    }
#line 316
    if (put_mark_index) {
#line 317
      *(p->marks + put_mark_index) = sym;
    }
#line 319
    return (sym);
  } else
#line 321
  if ((int )c == 115) {
    {
#line 324
    fasl_read_buf___0(p, (void *)(& len), (int )sizeof(long ));
    }
#line 325
    if ((int )sizeof(ikptr ) == 4) {
#line 325
      tmp___9 = 2;
    } else {
#line 325
      tmp___9 = 3;
    }
#line 325
    if ((int )sizeof(ikptr ) == 4) {
#line 325
      tmp___10 = 2;
    } else {
#line 325
      tmp___10 = 3;
    }
    {
#line 325
    size = ((((len * 4L + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___9 + 1)) << (tmp___10 + 1);
#line 326
    tmp___11 = ik_unsafe_alloc(pcb, (int )size);
#line 326
    str___0 = tmp___11 + 6UL;
    }
#line 327
    if ((int )sizeof(ikptr ) == 4) {
#line 327
      tmp___12 = 2;
    } else {
#line 327
      tmp___12 = 3;
    }
    {
#line 327
    *((ikptr *)((long )str___0 + -6L) + 0) = (ikptr )(len << tmp___12);
#line 328
    fasl_read_buf___0(p, (void *)((char *)((long )str___0) + ((int )sizeof(ikptr ) - 6)),
                      (int )len);
#line 330
    pi = (unsigned char *)((long )(str___0 + (ikptr )((int )sizeof(ikptr ) - 6)));
#line 331
    pj = (ikchar *)((long )(str___0 + (ikptr )((int )sizeof(ikptr ) - 6)));
#line 332
    i = len - 1L;
#line 333
    i = len - 1L;
    }
    {
#line 333
    while (1) {
      while_continue: /* CIL Label */ ;
#line 333
      if (! (i >= 0L)) {
#line 333
        goto while_break;
      }
#line 334
      *(pj + i) = ((int )*(pi + i) << 8) + 15;
#line 333
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 338
    if (put_mark_index) {
#line 339
      *(p->marks + put_mark_index) = str___0;
    }
#line 341
    return (str___0);
  } else
#line 343
  if ((int )c == 83) {
    {
#line 346
    fasl_read_buf___0(p, (void *)(& len___0), (int )sizeof(long ));
    }
#line 347
    if ((int )sizeof(ikptr ) == 4) {
#line 347
      tmp___13 = 2;
    } else {
#line 347
      tmp___13 = 3;
    }
#line 347
    if ((int )sizeof(ikptr ) == 4) {
#line 347
      tmp___14 = 2;
    } else {
#line 347
      tmp___14 = 3;
    }
    {
#line 347
    size___0 = ((((len___0 * 4L + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___13 + 1)) << (tmp___14 + 1);
#line 348
    tmp___15 = ik_unsafe_alloc(pcb, (int )size___0);
#line 348
    str___1 = tmp___15 + 6UL;
    }
#line 349
    if ((int )sizeof(ikptr ) == 4) {
#line 349
      tmp___16 = 2;
    } else {
#line 349
      tmp___16 = 3;
    }
#line 349
    *((ikptr *)((long )str___1 + -6L) + 0) = (ikptr )(len___0 << tmp___16);
#line 351
    i___0 = 0L;
    {
#line 351
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 351
      if (! (i___0 < len___0)) {
#line 351
        goto while_break___0;
      }
      {
#line 353
      fasl_read_buf___0(p, (void *)(& c___0), (int )sizeof(ikchar ));
#line 354
      *((ikchar *)((long )str___1 + (long )((int )sizeof(ikptr ) - 6)) + i___0) = (c___0 << 8) + 15;
#line 351
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 357
    if (put_mark_index) {
#line 358
      *(p->marks + put_mark_index) = str___1;
    }
#line 360
    return (str___1);
  } else
#line 362
  if ((int )c == 86) {
    {
#line 364
    fasl_read_buf___0(p, (void *)(& len___1), (int )sizeof(long ));
    }
#line 365
    if ((int )sizeof(ikptr ) == 4) {
#line 365
      tmp___17 = 2;
    } else {
#line 365
      tmp___17 = 3;
    }
#line 365
    if ((int )sizeof(ikptr ) == 4) {
#line 365
      tmp___18 = 2;
    } else {
#line 365
      tmp___18 = 3;
    }
    {
#line 365
    size___1 = ((((len___1 * (long )((int )sizeof(ikptr )) + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___17 + 1)) << (tmp___18 + 1);
#line 366
    tmp___19 = ik_unsafe_alloc(pcb, (int )size___1);
#line 366
    vec = tmp___19 + 5UL;
    }
#line 367
    if (put_mark_index) {
#line 368
      *(p->marks + put_mark_index) = vec;
    }
#line 370
    if ((int )sizeof(ikptr ) == 4) {
#line 370
      tmp___20 = 2;
    } else {
#line 370
      tmp___20 = 3;
    }
#line 370
    *((ikptr *)((long )vec + -5L) + 0) = (ikptr )(len___1 << tmp___20);
#line 372
    i___1 = 0L;
    {
#line 372
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 372
      if (! (i___1 < len___1)) {
#line 372
        goto while_break___1;
      }
      {
#line 373
      *((ikptr *)((long )vec + ((long )((int )sizeof(ikptr ) - 5) + i___1 * (long )((int )sizeof(ikptr )))) + 0) = do_read___0(pcb,
                                                                                                                               p);
#line 372
      i___1 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 375
    return (vec);
  } else
#line 377
  if ((int )c == 73) {
    {
#line 379
    fasl_read_buf___0(p, (void *)(& fixn), (int )sizeof(ikptr ));
    }
#line 380
    return (fixn);
  } else
#line 382
  if ((int )c == 70) {
#line 383
    return ((ikptr )47);
  } else
#line 385
  if ((int )c == 84) {
#line 386
    return ((ikptr )63);
  } else
#line 388
  if ((int )c == 78) {
#line 389
    return ((ikptr )79);
  } else
#line 391
  if ((int )c == 99) {
    {
#line 393
    tmp___21 = fasl_read_byte___0(p);
#line 393
    x = (unsigned char )tmp___21;
    }
#line 394
    return (((unsigned long )x << 8) | 15UL);
  } else
#line 396
  if ((int )c == 71) {
    {
#line 398
    tmp___22 = do_read___0(pcb, p);
#line 398
    pretty = tmp___22;
#line 399
    tmp___23 = do_read___0(pcb, p);
#line 399
    unique = tmp___23;
#line 400
    tmp___24 = ikrt_strings_to_gensym(pretty, unique, pcb);
#line 400
    sym___0 = tmp___24;
    }
#line 401
    if (put_mark_index) {
#line 402
      *(p->marks + put_mark_index) = sym___0;
    }
#line 404
    return (sym___0);
  } else
#line 406
  if ((int )c == 82) {
    {
#line 407
    tmp___25 = do_read___0(pcb, p);
#line 407
    name = tmp___25;
#line 408
    tmp___26 = do_read___0(pcb, p);
#line 408
    symb = tmp___26;
#line 410
    fasl_read_buf___0(p, (void *)(& n), (int )sizeof(long ));
    }
#line 412
    if (n == 0L) {
#line 413
      fields = (ikptr )79;
    } else {
#line 415
      if ((int )sizeof(ikptr ) == 4) {
#line 415
        tmp___27 = 2;
      } else {
#line 415
        tmp___27 = 3;
      }
#line 415
      if ((int )sizeof(ikptr ) == 4) {
#line 415
        tmp___28 = 2;
      } else {
#line 415
        tmp___28 = 3;
      }
      {
#line 415
      tmp___29 = ik_unsafe_alloc(pcb, (int )(n * (long )((((2 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___27 + 1)) << (tmp___28 + 1))));
#line 415
      fields = tmp___29 + 1UL;
#line 416
      ptr = fields;
#line 417
      i___2 = 0L;
      }
      {
#line 417
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 417
        if (! (i___2 < n)) {
#line 417
          goto while_break___2;
        }
        {
#line 418
        *((ikptr *)((long )ptr + -1L) + 0) = do_read___0(pcb, p);
        }
#line 419
        if ((int )sizeof(ikptr ) == 4) {
#line 419
          tmp___30 = 2;
        } else {
#line 419
          tmp___30 = 3;
        }
#line 419
        if ((int )sizeof(ikptr ) == 4) {
#line 419
          tmp___31 = 2;
        } else {
#line 419
          tmp___31 = 3;
        }
#line 419
        *((ikptr *)((long )ptr + (long )((int )sizeof(ikptr ) - 1)) + 0) = ptr + (ikptr )((((2 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___30 + 1)) << (tmp___31 + 1));
#line 420
        if ((int )sizeof(ikptr ) == 4) {
#line 420
          tmp___32 = 2;
        } else {
#line 420
          tmp___32 = 3;
        }
#line 420
        if ((int )sizeof(ikptr ) == 4) {
#line 420
          tmp___33 = 2;
        } else {
#line 420
          tmp___33 = 3;
        }
#line 420
        ptr += (ikptr )((((2 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___32 + 1)) << (tmp___33 + 1));
#line 417
        i___2 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 422
      ptr -= (ikptr )(2 * (int )sizeof(ikptr ));
#line 423
      *((ikptr *)((long )ptr + (long )((int )sizeof(ikptr ) - 1)) + 0) = (ikptr )79;
    }
#line 425
    gensym_val = *((ikptr *)((long )symb + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0);
#line 427
    if (gensym_val == 111UL) {
#line 428
      if ((int )sizeof(ikptr ) == 4) {
#line 428
        tmp___34 = 2;
      } else {
#line 428
        tmp___34 = 3;
      }
#line 428
      if ((int )sizeof(ikptr ) == 4) {
#line 428
        tmp___35 = 2;
      } else {
#line 428
        tmp___35 = 3;
      }
      {
#line 428
      tmp___36 = ik_unsafe_alloc(pcb, (((6 * (int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___34 + 1)) << (tmp___35 + 1));
#line 428
      rtd = tmp___36 + 5UL;
#line 429
      base_rtd = pcb->base_rtd;
#line 430
      *((ikptr *)((long )rtd + -5L) + 0) = base_rtd;
#line 431
      *((ikptr *)((long )rtd + (long )((int )sizeof(ikptr ) - 5)) + 0) = name;
      }
#line 432
      if ((int )sizeof(ikptr ) == 4) {
#line 432
        tmp___37 = 2;
      } else {
#line 432
        tmp___37 = 3;
      }
#line 432
      *((ikptr *)((long )rtd + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )(n << tmp___37);
#line 433
      *((ikptr *)((long )rtd + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = fields;
#line 434
      *((ikptr *)((long )rtd + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )47;
#line 435
      *((ikptr *)((long )rtd + (long )(5 * (int )sizeof(ikptr ) - 5)) + 0) = symb;
#line 436
      *((ikptr *)((long )symb + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = rtd;
#line 437
      *((unsigned int *)((long )pcb->dirty_vector) + ((symb + (ikptr )(3 * (int )sizeof(ikptr ) - 5)) >> 12)) = 4294967295U;
    } else {
#line 439
      rtd = gensym_val;
    }
#line 441
    if (put_mark_index) {
#line 442
      *(p->marks + put_mark_index) = rtd;
    }
#line 444
    return (rtd);
  } else
#line 446
  if ((int )c == 81) {
#line 447
    if ((int )sizeof(ikptr ) == 4) {
#line 447
      tmp___38 = 2;
    } else {
#line 447
      tmp___38 = 3;
    }
#line 447
    if ((int )sizeof(ikptr ) == 4) {
#line 447
      tmp___39 = 2;
    } else {
#line 447
      tmp___39 = 3;
    }
    {
#line 447
    tmp___40 = ik_unsafe_alloc(pcb, ((((int )sizeof(ikptr ) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___38 + 1)) << (tmp___39 + 1));
#line 447
    proc = tmp___40 + 3UL;
    }
#line 448
    if (put_mark_index) {
#line 449
      *(p->marks + put_mark_index) = proc;
    }
    {
#line 451
    tmp___41 = do_read___0(pcb, p);
#line 451
    code___0 = tmp___41;
#line 452
    *((ikptr *)((long )proc + -3L) + 0) = code___0 + (ikptr )(6 * (int )sizeof(ikptr ) - 5);
    }
#line 453
    return (proc);
  } else
#line 455
  if ((int )c == 60) {
    {
#line 457
    fasl_read_buf___0(p, (void *)(& idx___0), (int )sizeof(int ));
    }
#line 458
    if (idx___0 <= 0) {
      {
#line 459
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid index for ref %d\n",
              idx___0);
#line 460
      exit(-1);
      }
    }
#line 462
    if (idx___0 >= p->marks_size) {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid index for ref %d\n",
              idx___0);
#line 464
      exit(-1);
      }
    }
#line 466
    obj = *(p->marks + idx___0);
#line 467
    if (obj) {
#line 468
      return (obj);
    } else {
      {
#line 470
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reference to uninitialized mark %d\n",
              idx___0);
#line 471
      exit(-1);
      }
    }
  } else
#line 474
  if ((int )c == 118) {
    {
#line 477
    fasl_read_buf___0(p, (void *)(& len___2), (int )sizeof(long ));
    }
#line 478
    if ((int )sizeof(ikptr ) == 4) {
#line 478
      tmp___42 = 2;
    } else {
#line 478
      tmp___42 = 3;
    }
#line 478
    if ((int )sizeof(ikptr ) == 4) {
#line 478
      tmp___43 = 2;
    } else {
#line 478
      tmp___43 = 3;
    }
    {
#line 478
    size___2 = (((((len___2 + 8L) + 1L) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___42 + 1)) << (tmp___43 + 1);
#line 479
    tmp___44 = ik_unsafe_alloc(pcb, (int )size___2);
#line 479
    x___0 = tmp___44 + 2UL;
    }
#line 480
    if ((int )sizeof(ikptr ) == 4) {
#line 480
      tmp___45 = 2;
    } else {
#line 480
      tmp___45 = 3;
    }
    {
#line 480
    *((ikptr *)((long )x___0 + -2L) + 0) = (ikptr )(len___2 << tmp___45);
#line 481
    fasl_read_buf___0(p, (void *)((long )(x___0 + 6UL)), (int )len___2);
#line 482
    *((char *)((long )x___0) + (6L + len___2)) = (char)0;
    }
#line 483
    if (put_mark_index) {
#line 484
      *(p->marks + put_mark_index) = x___0;
    }
#line 486
    return (x___0);
  } else
#line 488
  if ((int )c == 108) {
    {
#line 489
    tmp___46 = fasl_read_byte___0(p);
#line 489
    len___3 = (int )((unsigned char )tmp___46);
#line 490
    tmp___47 = ik_unsafe_alloc(pcb, (2 * (int )sizeof(ikptr )) * (len___3 + 1));
#line 490
    pair___0 = tmp___47 + 1UL;
    }
#line 491
    if (put_mark_index) {
#line 492
      *(p->marks + put_mark_index) = pair___0;
    }
#line 494
    pt = pair___0;
#line 495
    i___3 = 0;
    {
#line 495
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 495
      if (! (i___3 < len___3)) {
#line 495
        goto while_break___3;
      }
      {
#line 496
      *((ikptr *)((long )pt + -1L) + 0) = do_read___0(pcb, p);
#line 497
      *((ikptr *)((long )pt + (long )((int )sizeof(ikptr ) - 1)) + 0) = pt + (ikptr )(2 * (int )sizeof(ikptr ));
#line 498
      pt += (ikptr )(2 * (int )sizeof(ikptr ));
#line 495
      i___3 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 500
    *((ikptr *)((long )pt + -1L) + 0) = do_read___0(pcb, p);
#line 501
    *((ikptr *)((long )pt + (long )((int )sizeof(ikptr ) - 1)) + 0) = do_read___0(pcb,
                                                                                  p);
    }
#line 502
    return (pair___0);
  } else
#line 504
  if ((int )c == 76) {
    {
#line 506
    fasl_read_buf___0(p, (void *)(& len___4), (int )sizeof(long ));
    }
#line 507
    if (len___4 < 0L) {
      {
#line 508
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid len=%ld\n",
              len___4);
#line 509
      exit(-1);
      }
    }
    {
#line 511
    tmp___48 = ik_unsafe_alloc(pcb, (int )((long )(2 * (int )sizeof(ikptr )) * (len___4 + 1L)));
#line 511
    pair___1 = tmp___48 + 1UL;
    }
#line 512
    if (put_mark_index) {
#line 513
      *(p->marks + put_mark_index) = pair___1;
    }
#line 515
    pt___0 = pair___1;
#line 516
    i___4 = 0L;
    {
#line 516
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 516
      if (! (i___4 < len___4)) {
#line 516
        goto while_break___4;
      }
      {
#line 517
      *((ikptr *)((long )pt___0 + -1L) + 0) = do_read___0(pcb, p);
#line 518
      *((ikptr *)((long )pt___0 + (long )((int )sizeof(ikptr ) - 1)) + 0) = pt___0 + (ikptr )(2 * (int )sizeof(ikptr ));
#line 519
      pt___0 += (ikptr )(2 * (int )sizeof(ikptr ));
#line 516
      i___4 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 521
    *((ikptr *)((long )pt___0 + -1L) + 0) = do_read___0(pcb, p);
#line 522
    *((ikptr *)((long )pt___0 + (long )((int )sizeof(ikptr ) - 1)) + 0) = do_read___0(pcb,
                                                                                      p);
    }
#line 523
    return (pair___1);
  } else
#line 525
  if ((int )c == 102) {
    {
#line 526
    tmp___49 = ik_unsafe_alloc(pcb, 16);
#line 526
    x___1 = tmp___49 + 5UL;
#line 527
    *((ikptr *)((long )x___1 + -5L) + 0) = (ikptr )23;
#line 528
    fasl_read_buf___0(p, (void *)((long )((x___1 + 8UL) - 5UL)), 8);
    }
#line 529
    if (put_mark_index) {
#line 530
      *(p->marks + put_mark_index) = x___1;
    }
#line 532
    return (x___1);
  } else
#line 534
  if ((int )c == 67) {
    {
#line 536
    fasl_read_buf___0(p, (void *)(& n___0), (int )sizeof(int ));
    }
#line 537
    return (((unsigned long )n___0 << 8) | 15UL);
  } else
#line 539
  if ((int )c == 98) {
    {
#line 541
    sign = 0L;
#line 542
    fasl_read_buf___0(p, (void *)(& len___5), (int )sizeof(long ));
    }
#line 543
    if (len___5 < 0L) {
#line 544
      sign = 1L;
#line 545
      len___5 = - len___5;
    }
#line 547
    if (len___5 & 3L) {
      {
#line 548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in fasl-read: invalid bignum length %ld\n",
              len___5);
#line 549
      exit(-1);
      }
    }
#line 551
    tag = (unsigned long )((3L | (sign << 3)) | ((len___5 >> 2) << 4));
#line 553
    if ((int )sizeof(ikptr ) == 4) {
#line 553
      tmp___50 = 2;
    } else {
#line 553
      tmp___50 = 3;
    }
#line 553
    if ((int )sizeof(ikptr ) == 4) {
#line 553
      tmp___51 = 2;
    } else {
#line 553
      tmp___51 = 3;
    }
    {
#line 553
    tmp___52 = ik_unsafe_alloc(pcb, (int )(((((len___5 + (long )((int )sizeof(ikptr ))) + (long )(2 * (int )sizeof(ikptr ))) - 1L) >> (tmp___50 + 1)) << (tmp___51 + 1)));
#line 553
    x___2 = tmp___52 + 5UL;
#line 554
    *((ikptr *)((long )x___2 + -5L) + 0) = tag;
#line 555
    fasl_read_buf___0(p, (void *)((long )(x___2 + (ikptr )((int )sizeof(ikptr ) - 5))),
                      (int )len___5);
    }
#line 556
    if (put_mark_index) {
#line 557
      *(p->marks + put_mark_index) = x___2;
    }
#line 559
    return (x___2);
  } else
#line 561
  if ((int )c == 105) {
    {
#line 562
    tmp___53 = do_read___0(pcb, p);
#line 562
    real = tmp___53;
#line 563
    tmp___54 = do_read___0(pcb, p);
#line 563
    imag = tmp___54;
    }
#line 565
    if (((int )real & 7) == 5) {
#line 565
      if (*((ikptr *)((long )real + -5L) + 0) == 23UL) {
        {
#line 567
        x___3 = ik_unsafe_alloc(pcb, 4 * (int )sizeof(ikptr ));
#line 568
        *((ikptr *)((long )x___3) + 0) = (ikptr )71;
#line 569
        *((ikptr *)((long )x___3 + (long )((int )sizeof(ikptr ))) + 0) = real;
#line 570
        *((ikptr *)((long )x___3 + (long )(2 * (int )sizeof(ikptr ))) + 0) = imag;
        }
      } else {
        {
#line 572
        x___3 = ik_unsafe_alloc(pcb, 4 * (int )sizeof(ikptr ));
#line 573
        *((ikptr *)((long )x___3) + 0) = (ikptr )55;
#line 574
        *((ikptr *)((long )x___3 + (long )((int )sizeof(ikptr ))) + 0) = real;
#line 575
        *((ikptr *)((long )x___3 + (long )(2 * (int )sizeof(ikptr ))) + 0) = imag;
        }
      }
    } else {
      {
#line 572
      x___3 = ik_unsafe_alloc(pcb, 4 * (int )sizeof(ikptr ));
#line 573
      *((ikptr *)((long )x___3) + 0) = (ikptr )55;
#line 574
      *((ikptr *)((long )x___3 + (long )((int )sizeof(ikptr ))) + 0) = real;
#line 575
      *((ikptr *)((long )x___3 + (long )(2 * (int )sizeof(ikptr ))) + 0) = imag;
      }
    }
#line 577
    x___3 += 5UL;
#line 578
    if (put_mark_index) {
#line 579
      *(p->marks + put_mark_index) = x___3;
    }
#line 581
    return (x___3);
  } else {
    {
#line 584
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid type \'%c\' (0x%02x) found in fasl file\n",
            (int )c, (int )c);
#line 585
    exit(-1);
    }
  }
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-fasl.c"
static ikptr ik_fasl_read___0(ikpcb *pcb , fasl_port *p ) 
{ 
  char const   *tmp ;
  size_t tmp___0 ;
  char *buf ;
  unsigned long __lengthofbuf ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  ikptr tmp___8 ;

  {
#line 592
  if (sizeof(ikptr ) == 4UL) {
#line 592
    tmp = "#@IK01";
  } else {
#line 592
    tmp = "#@IK02";
  }
  {
#line 592
  tmp___0 = strlen(tmp);
#line 592
  __lengthofbuf = tmp___0;
#line 592
  tmp___1 = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 592
  buf = (char *)tmp___1;
  }
#line 593
  if (sizeof(ikptr ) == 4UL) {
#line 593
    tmp___2 = "#@IK01";
  } else {
#line 593
    tmp___2 = "#@IK02";
  }
  {
#line 593
  tmp___3 = strlen(tmp___2);
#line 593
  fasl_read_buf___0(p, (void *)buf, (int )tmp___3);
  }
#line 594
  if (sizeof(ikptr ) == 4UL) {
#line 594
    tmp___4 = "#@IK01";
  } else {
#line 594
    tmp___4 = "#@IK02";
  }
  {
#line 594
  tmp___5 = strlen(tmp___4);
  }
#line 594
  if (sizeof(ikptr ) == 4UL) {
#line 594
    tmp___6 = "#@IK01";
  } else {
#line 594
    tmp___6 = "#@IK02";
  }
  {
#line 594
  tmp___7 = strncmp((char const   *)buf, tmp___6, tmp___5);
  }
#line 594
  if (tmp___7 != 0) {
    {
#line 595
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid fasl header\n");
#line 596
    exit(-1);
    }
  }
  {
#line 598
  tmp___8 = do_read___0(pcb, p);
  }
#line 598
  return (tmp___8);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus.c"
static char *helpstring___0  =    (char *)"\nOptions for running ikarus scheme:\n\n  ikarus -h\n    Prints this help message then exits.\n\n  ikarus [-b <bootfile>] --r6rs-script <scriptfile> opts ...\n    Starts ikarus in r6rs-script mode.  The script file is treated\n    as an R6RS-script.  The options opts ... can be obtained using\n    the \"command-line\" procedure in the (rnrs programs) library.\n\n  ikarus [-b <bootfile>] <file> ... [-- opts ...]\n    Starts ikarus in interactive mode.  Each of the files is first\n    loaded into the interaction environment before the interactive\n    repl is started.  The options opts can be obtained using the\n    \"command-line\" procedure.\n  \n  If the option [-b <bootfile>] is provided, the bootfile is used\n  as the system\'s initial boot file from which the environment is\n  initialized.  If the -b option is not supplied, the default boot\n  file is used.  The current default boot file location is\n  \"%s\".\n  Consult the Ikarus Scheme User\'s Guide for more details.\n\n";
#line 50 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
static errno_info errno_table___0[79]  = 
#line 50 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-errno.c"
  {      {7, (char *)"E2BIG", (ikptr )(-1L << 3)}, 
        {13, (char *)"EACCES", (ikptr )(-2L << 3)}, 
        {98, (char *)"EADDRINUSE", (ikptr )(-3L << 3)}, 
        {99, (char *)"EADDRNOTAVAIL", (ikptr )(-4L << 3)}, 
        {97, (char *)"EAFNOSUPPORT", (ikptr )(-5L << 3)}, 
        {11, (char *)"EAGAIN", (ikptr )(-6L << 3)}, 
        {114, (char *)"EALREADY", (ikptr )(-7L << 3)}, 
        {9, (char *)"EBADF", (ikptr )(-8L << 3)}, 
        {74, (char *)"EBADMSG", (ikptr )(-9L << 3)}, 
        {16, (char *)"EBUSY", (ikptr )(-10L << 3)}, 
        {125, (char *)"ECANCELED", (ikptr )(-11L << 3)}, 
        {10, (char *)"ECHILD", (ikptr )(-12L << 3)}, 
        {103, (char *)"ECONNABORTED", (ikptr )(-13L << 3)}, 
        {111, (char *)"ECONNREFUSED", (ikptr )(-14L << 3)}, 
        {104, (char *)"ECONNRESET", (ikptr )(-15L << 3)}, 
        {35, (char *)"EDEADLK", (ikptr )(-16L << 3)}, 
        {89, (char *)"EDESTADDRREQ", (ikptr )(-17L << 3)}, 
        {33, (char *)"EDOM", (ikptr )(-18L << 3)}, 
        {122, (char *)"EDQUOT", (ikptr )(-19L << 3)}, 
        {17, (char *)"EEXIST", (ikptr )(-20L << 3)}, 
        {14, (char *)"EFAULT", (ikptr )(-21L << 3)}, 
        {27, (char *)"EFBIG", (ikptr )(-22L << 3)}, 
        {113, (char *)"EHOSTUNREACH", (ikptr )(-23L << 3)}, 
        {43, (char *)"EIDRM", (ikptr )(-24L << 3)}, 
        {84, (char *)"EILSEQ", (ikptr )(-25L << 3)}, 
        {115, (char *)"EINPROGRESS", (ikptr )(-26L << 3)}, 
        {4, (char *)"EINTR", (ikptr )(-27L << 3)}, 
        {22, (char *)"EINVAL", (ikptr )(-28L << 3)}, 
        {5, (char *)"EIO", (ikptr )(-29L << 3)}, 
        {106, (char *)"EISCONN", (ikptr )(-30L << 3)}, 
        {21, (char *)"EISDIR", (ikptr )(-31L << 3)}, 
        {40, (char *)"ELOOP", (ikptr )(-32L << 3)}, 
        {24, (char *)"EMFILE", (ikptr )(-33L << 3)}, 
        {31, (char *)"EMLINK", (ikptr )(-34L << 3)}, 
        {90, (char *)"EMSGSIZE", (ikptr )(-35L << 3)}, 
        {72, (char *)"EMULTIHOP", (ikptr )(-36L << 3)}, 
        {36, (char *)"ENAMETOOLONG", (ikptr )(-37L << 3)}, 
        {100, (char *)"ENETDOWN", (ikptr )(-38L << 3)}, 
        {102, (char *)"ENETRESET", (ikptr )(-39L << 3)}, 
        {101, (char *)"ENETUNREACH", (ikptr )(-40L << 3)}, 
        {23, (char *)"ENFILE", (ikptr )(-41L << 3)}, 
        {105, (char *)"ENOBUFS", (ikptr )(-42L << 3)}, 
        {61, (char *)"ENODATA", (ikptr )(-43L << 3)}, 
        {19, (char *)"ENODEV", (ikptr )(-44L << 3)}, 
        {2, (char *)"ENOENT", (ikptr )(-45L << 3)}, 
        {8, (char *)"ENOEXEC", (ikptr )(-46L << 3)}, 
        {37, (char *)"ENOLCK", (ikptr )(-47L << 3)}, 
        {67, (char *)"ENOLINK", (ikptr )(-48L << 3)}, 
        {12, (char *)"ENOMEM", (ikptr )(-49L << 3)}, 
        {42, (char *)"ENOMSG", (ikptr )(-50L << 3)}, 
        {92, (char *)"ENOPROTOOPT", (ikptr )(-51L << 3)}, 
        {28, (char *)"ENOSPC", (ikptr )(-52L << 3)}, 
        {63, (char *)"ENOSR", (ikptr )(-53L << 3)}, 
        {60, (char *)"ENOSTR", (ikptr )(-54L << 3)}, 
        {38, (char *)"ENOSYS", (ikptr )(-55L << 3)}, 
        {107, (char *)"ENOTCONN", (ikptr )(-56L << 3)}, 
        {20, (char *)"ENOTDIR", (ikptr )(-57L << 3)}, 
        {39, (char *)"ENOTEMPTY", (ikptr )(-58L << 3)}, 
        {88, (char *)"ENOTSOCK", (ikptr )(-59L << 3)}, 
        {95, (char *)"ENOTSUP", (ikptr )(-60L << 3)}, 
        {25, (char *)"ENOTTY", (ikptr )(-61L << 3)}, 
        {6, (char *)"ENXIO", (ikptr )(-62L << 3)}, 
        {95, (char *)"EOPNOTSUPP", (ikptr )(-63L << 3)}, 
        {75, (char *)"EOVERFLOW", (ikptr )(-64L << 3)}, 
        {1, (char *)"EPERM", (ikptr )(-65L << 3)}, 
        {32, (char *)"EPIPE", (ikptr )(-66L << 3)}, 
        {71, (char *)"EPROTO", (ikptr )(-67L << 3)}, 
        {93, (char *)"EPROTONOSUPPORT", (ikptr )(-68L << 3)}, 
        {91, (char *)"EPROTOTYPE", (ikptr )(-69L << 3)}, 
        {34, (char *)"ERANGE", (ikptr )(-70L << 3)}, 
        {30, (char *)"EROFS", (ikptr )(-71L << 3)}, 
        {29, (char *)"ESPIPE", (ikptr )(-72L << 3)}, 
        {3, (char *)"ESRCH", (ikptr )(-73L << 3)}, 
        {116, (char *)"ESTALE", (ikptr )(-74L << 3)}, 
        {62, (char *)"ETIME", (ikptr )(-75L << 3)}, 
        {110, (char *)"ETIMEDOUT", (ikptr )(-76L << 3)}, 
        {26, (char *)"ETXTBSY", (ikptr )(-77L << 3)}, 
        {11, (char *)"EWOULDBLOCK", (ikptr )(-78L << 3)}, 
        {18, (char *)"EXDEV", (ikptr )(-79L << 3)}};
#line 25 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static ikptr make_symbol_table___0(ikpcb *pcb ) 
{ 
  int size ;
  ikptr st ;
  ikptr tmp ;
  int tmp___0 ;

  {
  {
#line 28
  size = (int )(((4095UL + (unsigned long )((int )sizeof(ikptr ) + 4096 * (int )sizeof(ikptr ))) >> 12) << 12);
#line 29
  tmp = ik_mmap_ptr((unsigned long )size, 0, pcb);
#line 29
  st = tmp + 5UL;
#line 30
  bzero((void *)((char *)((long )st) - 5), (size_t )size);
  }
#line 31
  if ((int )sizeof(ikptr ) == 4) {
#line 31
    tmp___0 = 2;
  } else {
#line 31
    tmp___0 = 3;
  }
#line 31
  *((ikptr *)((long )st + -5L) + 0) = (ikptr )(4096L << tmp___0);
#line 32
  return (st);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static long compute_hash___0(ikptr str ) 
{ 
  long len ;
  int tmp ;
  int *data ;
  int h ;
  int *last ;
  int c ;
  int tmp___0 ;

  {
#line 39
  if ((int )sizeof(ikptr ) == 4) {
#line 39
    tmp = 2;
  } else {
#line 39
    tmp = 3;
  }
#line 39
  len = (long )*((ikptr *)((long )str + -6L) + 0) >> tmp;
#line 40
  data = (int *)(str + (ikptr )((int )sizeof(ikptr ) - 6));
#line 41
  h = (int )len;
#line 42
  last = data + len;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned long )data < (unsigned long )last)) {
#line 45
      goto while_break;
    }
#line 46
    c = *data >> 8;
#line 47
    h += c;
#line 48
    h += h << 10;
#line 49
    h ^= h >> 6;
#line 50
    data ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  h += h << 3;
#line 53
  h ^= h >> 11;
#line 54
  h += h << 15;
#line 55
  if (h >= 0) {
#line 55
    tmp___0 = h;
  } else {
#line 55
    tmp___0 = 1 - h;
  }
#line 55
  return ((long )tmp___0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static int strings_eqp___0(ikptr str1 , ikptr str2 ) 
{ 
  ikptr len ;
  int tmp ;
  int tmp___0 ;

  {
#line 64
  len = *((ikptr *)((long )str1 + -6L) + 0);
#line 65
  if (len == *((ikptr *)((long )str2 + -6L) + 0)) {
#line 66
    if ((int )sizeof(ikptr ) == 4) {
#line 66
      tmp = 2;
    } else {
#line 66
      tmp = 3;
    }
    {
#line 66
    tmp___0 = memcmp((void const   *)((char *)((long )str1) + ((int )sizeof(ikptr ) - 6)),
                     (void const   *)((char *)((long )str2) + ((int )sizeof(ikptr ) - 6)),
                     (size_t )(((long )len >> tmp) * 4L));
    }
#line 66
    return (tmp___0 == 0);
  }
#line 72
  return (0);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static ikptr ik_make_symbol___0(ikptr str , ikptr ustr , ikpcb *pcb ) 
{ 
  ikptr sym ;
  ikptr tmp ;

  {
  {
#line 77
  tmp = ik_unsafe_alloc(pcb, 6 * (int )sizeof(ikptr ));
#line 77
  sym = tmp + 5UL;
#line 78
  *((ikptr *)((long )sym + -5L) + 0) = (ikptr )95;
#line 79
  *((ikptr *)((long )sym + (long )((int )sizeof(ikptr ) - 5)) + 0) = str;
#line 80
  *((ikptr *)((long )sym + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0) = ustr;
#line 81
  *((ikptr *)((long )sym + (long )(3 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )111;
#line 82
  *((ikptr *)((long )sym + (long )(4 * (int )sizeof(ikptr ) - 5)) + 0) = str;
#line 83
  *((ikptr *)((long )sym + (long )(5 * (int )sizeof(ikptr ) - 5)) + 0) = (ikptr )79;
  }
#line 84
  return (sym);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static ikptr intern_string___0(ikptr str , ikptr st , ikpcb *pcb ) 
{ 
  int h ;
  long tmp ;
  int idx ;
  int tmp___0 ;
  ikptr bckt ;
  ikptr b ;
  ikptr sym ;
  ikptr sym_str ;
  int tmp___1 ;
  ikptr sym___0 ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;

  {
  {
#line 89
  tmp = compute_hash___0(str);
#line 89
  h = (int )tmp;
  }
#line 90
  if ((int )sizeof(ikptr ) == 4) {
#line 90
    tmp___0 = 2;
  } else {
#line 90
    tmp___0 = 3;
  }
#line 90
  idx = (int )((long )h & (((long )*((ikptr *)((long )st + -5L) + 0) >> tmp___0) - 1L));
#line 91
  bckt = *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0);
#line 92
  b = bckt;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! b) {
#line 93
      goto while_break;
    }
    {
#line 94
    sym = *((ikptr *)((long )b + -1L) + 0);
#line 95
    sym_str = *((ikptr *)((long )sym + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 96
    tmp___1 = strings_eqp___0(sym_str, str);
    }
#line 96
    if (tmp___1) {
#line 97
      return (sym);
    }
#line 99
    b = *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = ik_make_symbol___0(str, (ikptr )47, pcb);
#line 101
  sym___0 = tmp___2;
#line 102
  tmp___3 = ik_unsafe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 102
  b = tmp___3 + 1UL;
#line 103
  *((ikptr *)((long )b + -1L) + 0) = sym___0;
#line 104
  *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0) = bckt;
#line 105
  *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0) = b;
#line 106
  *((int *)((long )pcb->dirty_vector) + (((st + (ikptr )((int )sizeof(ikptr ) - 5)) + (ikptr )(idx * (int )sizeof(ikptr ))) >> 12)) = -1;
  }
#line 107
  return (sym___0);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-symbol-table.c"
static ikptr intern_unique_string___0(ikptr str , ikptr ustr , ikptr st , ikpcb *pcb ) 
{ 
  int h ;
  long tmp ;
  int idx ;
  int tmp___0 ;
  ikptr bckt ;
  ikptr b ;
  ikptr sym ;
  ikptr sym_ustr ;
  int tmp___1 ;
  ikptr sym___0 ;
  ikptr tmp___2 ;
  ikptr tmp___3 ;

  {
  {
#line 112
  tmp = compute_hash___0(ustr);
#line 112
  h = (int )tmp;
  }
#line 113
  if ((int )sizeof(ikptr ) == 4) {
#line 113
    tmp___0 = 2;
  } else {
#line 113
    tmp___0 = 3;
  }
#line 113
  idx = (int )((long )h & (((long )*((ikptr *)((long )st + -5L) + 0) >> tmp___0) - 1L));
#line 114
  bckt = *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0);
#line 115
  b = bckt;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! b) {
#line 116
      goto while_break;
    }
    {
#line 117
    sym = *((ikptr *)((long )b + -1L) + 0);
#line 118
    sym_ustr = *((ikptr *)((long )sym + (long )(2 * (int )sizeof(ikptr ) - 5)) + 0);
#line 119
    tmp___1 = strings_eqp___0(sym_ustr, ustr);
    }
#line 119
    if (tmp___1) {
#line 120
      return (sym);
    }
#line 122
    b = *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  tmp___2 = ik_make_symbol___0(str, ustr, pcb);
#line 124
  sym___0 = tmp___2;
#line 125
  tmp___3 = ik_unsafe_alloc(pcb, 2 * (int )sizeof(ikptr ));
#line 125
  b = tmp___3 + 1UL;
#line 126
  *((ikptr *)((long )b + -1L) + 0) = sym___0;
#line 127
  *((ikptr *)((long )b + (long )((int )sizeof(ikptr ) - 1)) + 0) = bckt;
#line 128
  *((ikptr *)((long )st + (long )(((int )sizeof(ikptr ) - 5) + idx * (int )sizeof(ikptr ))) + 0) = b;
#line 129
  *((int *)((long )pcb->dirty_vector) + (((st + (ikptr )((int )sizeof(ikptr ) - 5)) + (ikptr )(idx * (int )sizeof(ikptr ))) >> 12)) = -1;
  }
#line 130
  return (sym___0);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-print.c"
static void print___0(FILE *fh , ikptr x ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-print.c"
static void print___0(FILE *fh , ikptr x ) 
{ 
  int tmp ;
  unsigned long i ;
  ikptr fst ;
  ikptr len ;
  ikptr data ;
  ikptr i___0 ;
  ikptr str ;
  ikptr fxlen ;
  int len___0 ;
  int tmp___0 ;
  int *data___0 ;
  int i___1 ;
  char c ;
  ikptr d ;
  ikptr fxlen___0 ;
  int len___1 ;
  int tmp___1 ;
  int *data___1 ;
  int i___2 ;
  char c___0 ;
  ikptr fxlen___1 ;
  int len___2 ;
  int tmp___2 ;
  unsigned char *data___2 ;
  int i___3 ;

  {
#line 60
  if ((x & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 61
    if ((int )sizeof(ikptr ) == 4) {
#line 61
      tmp = 2;
    } else {
#line 61
      tmp = 3;
    }
    {
#line 61
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%ld", (long )x >> tmp);
    }
  } else
#line 63
  if (x == 47UL) {
    {
#line 64
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#f");
    }
  } else
#line 66
  if (x == 63UL) {
    {
#line 67
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#t");
    }
  } else
#line 69
  if (x == 79UL) {
    {
#line 70
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"()");
    }
  } else
#line 72
  if ((255 & (int )x) == 15) {
#line 73
    i = (unsigned long )((long )x >> 8);
#line 74
    if (i < 128UL) {
      {
#line 75
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%s",
              char_string[i]);
      }
    } else {
      {
#line 77
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#\\x%lx",
              i);
      }
    }
  } else
#line 86
  if (((int )x & 7) == 5) {
#line 87
    fst = *((ikptr *)((long )x + -5L) + 0);
#line 88
    if ((fst & (unsigned long )((int )sizeof(ikptr ) - 1)) == 0UL) {
#line 89
      len = fst;
#line 90
      if (len == 0UL) {
        {
#line 91
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#()");
        }
      } else {
        {
#line 93
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#(");
#line 94
        data = x + (ikptr )((int )sizeof(ikptr ) - 5);
#line 95
        print___0(fh, *((ikptr *)((long )data) + 0));
#line 96
        i___0 = (ikptr )((int )sizeof(ikptr ));
        }
        {
#line 97
        while (1) {
          while_continue: /* CIL Label */ ;
#line 97
          if (! (i___0 < len)) {
#line 97
            goto while_break;
          }
          {
#line 98
          fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)" ");
#line 99
          print___0(fh, *((ikptr *)((long )data + (long )i___0) + 0));
#line 100
          i___0 += (ikptr )((int )sizeof(ikptr ));
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 102
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)")");
        }
      }
    } else
#line 104
    if (fst == 95UL) {
#line 105
      str = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 5)) + 0);
#line 106
      fxlen = *((ikptr *)((long )str + -6L) + 0);
#line 107
      if ((int )sizeof(ikptr ) == 4) {
#line 107
        tmp___0 = 2;
      } else {
#line 107
        tmp___0 = 3;
      }
#line 107
      len___0 = (int )((long )fxlen >> tmp___0);
#line 108
      data___0 = (int *)(str + (ikptr )((int )sizeof(ikptr ) - 6));
#line 110
      i___1 = 0;
      {
#line 110
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 110
        if (! (i___1 < len___0)) {
#line 110
          goto while_break___0;
        }
        {
#line 111
        c = (char )(*(data___0 + i___1) >> 8);
#line 112
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%c",
                (int )c);
#line 110
        i___1 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 115
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#<unknown fst=0x%p>",
              (void *)fst);
      }
    }
  } else
#line 118
  if (((long )x & 7L) == 3L) {
    {
#line 119
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#<procedure>");
    }
  } else
#line 121
  if (((long )x & 7L) == 1L) {
    {
#line 122
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"(");
#line 123
    print___0(fh, *((ikptr *)((long )x + -1L) + 0));
#line 124
    d = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0);
    }
    {
#line 126
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 127
      if (((long )d & 7L) == 1L) {
        {
#line 128
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)" ");
#line 129
        print___0(fh, *((ikptr *)((long )d + -1L) + 0));
#line 130
        d = *((ikptr *)((long )d + (long )((int )sizeof(ikptr ) - 1)) + 0);
        }
      } else
#line 132
      if (d == 79UL) {
        {
#line 133
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)")");
        }
#line 134
        return;
      } else {
        {
#line 137
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)" . ");
#line 138
        print___0(fh, d);
#line 139
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)")");
        }
#line 140
        return;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 144
  if (((int )x & 7) == 6) {
#line 145
    fxlen___0 = *((ikptr *)((long )x + -6L) + 0);
#line 146
    if ((int )sizeof(ikptr ) == 4) {
#line 146
      tmp___1 = 2;
    } else {
#line 146
      tmp___1 = 3;
    }
    {
#line 146
    len___1 = (int )((long )fxlen___0 >> tmp___1);
#line 147
    data___1 = (int *)(x + (ikptr )((int )sizeof(ikptr ) - 6));
#line 148
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\"");
#line 150
    i___2 = 0;
    }
    {
#line 150
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 150
      if (! (i___2 < len___1)) {
#line 150
        goto while_break___2;
      }
#line 151
      c___0 = (char )(*(data___1 + i___2) >> 8);
#line 152
      if ((int )c___0 == 92) {
        {
#line 153
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\\");
        }
      } else
#line 152
      if ((int )c___0 == 34) {
        {
#line 153
        fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\\");
        }
      }
      {
#line 155
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%c",
              (int )c___0);
#line 150
      i___2 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 157
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\"");
    }
  } else
#line 159
  if (((int )x & 7) == 2) {
#line 160
    fxlen___1 = *((ikptr *)((long )x + -2L) + 0);
#line 161
    if ((int )sizeof(ikptr ) == 4) {
#line 161
      tmp___2 = 2;
    } else {
#line 161
      tmp___2 = 3;
    }
    {
#line 161
    len___2 = (int )((long )fxlen___1 >> tmp___2);
#line 162
    data___2 = (unsigned char *)(x + 6UL);
#line 163
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#vu8(");
#line 165
    i___3 = 0;
    }
    {
#line 165
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 165
      if (! (i___3 < len___2 - 1)) {
#line 165
        goto while_break___3;
      }
      {
#line 166
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%d ",
              (int )*(data___2 + i___3));
#line 165
      i___3 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 168
    if (i___3 < len___2) {
      {
#line 169
      fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%d",
              (int )*(data___2 + i___3));
      }
    }
    {
#line 171
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)")");
    }
  } else {
    {
#line 174
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"#<unknown>");
    }
  }
#line 176
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
static int list_length___0(ikptr x ) 
{ 
  int n ;

  {
#line 33
  n = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (((int )x & 7) == 1)) {
#line 34
      goto while_break;
    }
#line 35
    n ++;
#line 36
    x = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0);
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (n);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
static char **list_to_vec___0(ikptr x ) 
{ 
  int n ;
  int tmp ;
  char **vec ;
  void *tmp___0 ;
  int i ;

  {
  {
#line 43
  tmp = list_length___0(x);
#line 43
  n = tmp;
#line 44
  tmp___0 = malloc((unsigned long )(n + 1) * sizeof(char *));
#line 44
  vec = (char **)tmp___0;
  }
#line 45
  if ((unsigned long )vec == (unsigned long )((void *)0)) {
    {
#line 45
    exit(-1);
    }
  }
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < n)) {
#line 47
      goto while_break;
    }
#line 48
    *(vec + i) = (char *)((long )*((ikptr *)((long )x + -1L) + 0)) + 6;
#line 49
    x = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ) - 1)) + 0);
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  *(vec + n) = (char *)0;
#line 52
  return (vec);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
static int execvpe____0(char const   *cmd , char * const  *argv , char * const  *envp ) 
{ 
  char *path ;
  char const   *searchpath ;
  char const   *sep ;
  size_t cmd_len ;
  char *tmp ;
  size_t prefix_len ;
  size_t path_len ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 57
  path = (char *)((void *)0);
#line 62
  if ((int const   )*(cmd + 0) == 47) {
    {
#line 63
    execve(cmd, argv, envp);
    }
  }
  {
#line 65
  tmp = getenv("PATH");
#line 65
  searchpath = (char const   *)tmp;
  }
#line 66
  if ((unsigned long )searchpath == (unsigned long )((void *)0)) {
#line 67
    searchpath = "/bin:/usr/bin";
  }
  {
#line 69
  cmd_len = strlen(cmd);
#line 71
  sep = (char const   *)((void *)0);
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    tmp___0 = strchr(searchpath, ':');
#line 75
    sep = (char const   *)tmp___0;
    }
#line 76
    if ((unsigned long )sep == (unsigned long )((void *)0)) {
      {
#line 77
      tmp___1 = strlen(searchpath);
#line 77
      sep = searchpath + tmp___1;
      }
    }
    {
#line 80
    prefix_len = (size_t )(sep - searchpath);
#line 81
    path_len = (prefix_len + cmd_len) + 2UL;
#line 82
    tmp___2 = realloc((void *)path, path_len);
#line 82
    path = (char *)tmp___2;
    }
#line 83
    if ((unsigned long )path == (unsigned long )((void *)0)) {
      {
#line 84
      tmp___3 = __errno_location();
#line 84
      *tmp___3 = 12;
      }
#line 85
      return (-1);
    }
    {
#line 87
    memcpy((void */* __restrict  */)path, (void const   */* __restrict  */)searchpath,
           prefix_len);
    }
#line 88
    if (prefix_len == 0UL) {
      {
#line 89
      memcpy((void */* __restrict  */)(path + prefix_len), (void const   */* __restrict  */)cmd,
             cmd_len + 1UL);
      }
    } else
#line 88
    if ((int const   )*(searchpath + (prefix_len - 1UL)) == 47) {
      {
#line 89
      memcpy((void */* __restrict  */)(path + prefix_len), (void const   */* __restrict  */)cmd,
             cmd_len + 1UL);
      }
    } else {
      {
#line 91
      *(path + prefix_len) = (char )'/';
#line 92
      memcpy((void */* __restrict  */)((path + prefix_len) + 1), (void const   */* __restrict  */)cmd,
             cmd_len + 1UL);
      }
    }
    {
#line 95
    execve((char const   *)path, argv, envp);
#line 96
    tmp___4 = __errno_location();
    }
    {
#line 100
    if (*tmp___4 == 26) {
#line 100
      goto case_26;
    }
#line 100
    if (*tmp___4 == 12) {
#line 100
      goto case_26;
    }
#line 100
    if (*tmp___4 == 8) {
#line 100
      goto case_26;
    }
#line 100
    if (*tmp___4 == 7) {
#line 100
      goto case_26;
    }
#line 96
    goto switch_break;
    case_26: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 101
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 104
    searchpath = sep + 1;
#line 72
    if (! ((int const   )*(sep + 0) != 0)) {
#line 72
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if (path) {
    {
#line 107
    free((void *)path);
    }
  }
#line 109
  return (-1);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-process.c"
static signal_info signal_info_table___0[28]  = 
#line 196
  {      {6, (ikptr )(1L << 3)}, 
        {14, (ikptr )(2L << 3)}, 
        {7, (ikptr )(3L << 3)}, 
        {17, (ikptr )(4L << 3)}, 
        {18, (ikptr )(5L << 3)}, 
        {8, (ikptr )(6L << 3)}, 
        {1, (ikptr )(7L << 3)}, 
        {4, (ikptr )(8L << 3)}, 
        {2, (ikptr )(9L << 3)}, 
        {9, (ikptr )(10L << 3)}, 
        {13, (ikptr )(11L << 3)}, 
        {3, (ikptr )(12L << 3)}, 
        {11, (ikptr )(13L << 3)}, 
        {19, (ikptr )(14L << 3)}, 
        {15, (ikptr )(15L << 3)}, 
        {20, (ikptr )(16L << 3)}, 
        {21, (ikptr )(17L << 3)}, 
        {22, (ikptr )(18L << 3)}, 
        {10, (ikptr )(19L << 3)}, 
        {12, (ikptr )(20L << 3)}, 
        {29, (ikptr )(21L << 3)}, 
        {27, (ikptr )(22L << 3)}, 
        {31, (ikptr )(23L << 3)}, 
        {5, (ikptr )(24L << 3)}, 
        {23, (ikptr )(25L << 3)}, 
        {26, (ikptr )(26L << 3)}, 
        {24, (ikptr )(27L << 3)}, 
        {25, (ikptr )(28L << 3)}};
#line 24 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static long page_idx___0(void *x ) 
{ 
  unsigned long xi ;

  {
#line 26
  xi = (unsigned long )x;
#line 27
  return ((long )(xi >> 12));
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static void verify_code___0(char *x , char *base , unsigned int *svec , unsigned int *dvec ) 
{ 
  ikptr rvec ;
  ikptr codesize ;
  ikptr freevars ;
  unsigned int rs ;
  long tmp ;
  long tmp___0 ;
  unsigned int cs ;
  long tmp___1 ;
  long tmp___2 ;
  int cgen ;
  int rgen ;
  unsigned int d ;
  long tmp___3 ;
  long tmp___4 ;

  {
  {
#line 51
  rvec = *((ikptr *)((long )x + (long )(2 * (int )sizeof(ikptr ))) + 0);
#line 53
  codesize = *((ikptr *)((long )x + (long )((int )sizeof(ikptr ))) + 0);
#line 54
  codesize = codesize;
#line 57
  freevars = *((ikptr *)((long )x + (long )(3 * (int )sizeof(ikptr ))) + 0);
#line 58
  freevars = freevars;
#line 62
  tmp = page_idx___0((void *)((long )rvec));
#line 62
  tmp___0 = page_idx___0((void *)base);
#line 62
  rs = *(svec + (tmp - tmp___0));
#line 63
  tmp___1 = page_idx___0((void *)x);
#line 63
  tmp___2 = page_idx___0((void *)base);
#line 63
  cs = *(svec + (tmp___1 - tmp___2));
#line 64
  cgen = (int )(cs & 15U);
#line 65
  rgen = (int )(rs & 15U);
  }
#line 66
  if (rgen < cgen) {
    {
#line 67
    tmp___3 = page_idx___0((void *)x);
#line 67
    tmp___4 = page_idx___0((void *)base);
#line 67
    d = *(dvec + (tmp___3 - tmp___4));
#line 68
    d &= d;
    }
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static void verify_object___0(ikptr x , char *base , unsigned int *svec , unsigned int *dvec ) 
{ 


  {
#line 77
  x = x;
#line 77
  base = base;
#line 77
  svec = svec;
#line 77
  dvec = dvec;
#line 78
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_code_small___0(char *p , int s , unsigned int d , char *base ,
                                   unsigned int *svec , unsigned int *dvec ) 
{ 
  char *q ;
  ikptr fst ;
  int code_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 84
  q = p + 4096;
#line 85
  s = s;
#line 85
  d = d;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! ((unsigned long )p < (unsigned long )q)) {
#line 86
      goto while_break;
    }
#line 87
    fst = *((ikptr *)((long )p) + 0);
#line 88
    if (fst == 47UL) {
#line 90
      if ((int )sizeof(ikptr ) == 4) {
#line 90
        tmp = 2;
      } else {
#line 90
        tmp = 3;
      }
      {
#line 90
      code_size = (int )((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp);
#line 92
      verify_code___0(p, base, svec, dvec);
      }
#line 93
      if ((int )sizeof(ikptr ) == 4) {
#line 93
        tmp___0 = 2;
      } else {
#line 93
        tmp___0 = 3;
      }
#line 93
      if ((int )sizeof(ikptr ) == 4) {
#line 93
        tmp___1 = 2;
      } else {
#line 93
        tmp___1 = 3;
      }
#line 93
      p += ((((code_size + 6 * (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___0 + 1)) << (tmp___1 + 1);
    } else {
#line 95
      p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if ((unsigned long )p != (unsigned long )q) {
    {
#line 99
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"code extended beyond a page in %p, %p\n",
            p, q);
    }
  }
#line 102
  return (q);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_code_large___0(char *p , unsigned int s , unsigned int d , char *base ,
                                   unsigned int *svec , unsigned int *dvec ) 
{ 
  ikptr fst ;
  int code_size ;
  int tmp ;
  char *end ;

  {
#line 108
  s = s;
#line 108
  d = d;
#line 109
  fst = *((ikptr *)((long )p) + 0);
#line 110
  fst = fst;
#line 112
  if ((int )sizeof(ikptr ) == 4) {
#line 112
    tmp = 2;
  } else {
#line 112
    tmp = 3;
  }
  {
#line 112
  code_size = (int )((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp);
#line 114
  verify_code___0(p, base, svec, dvec);
#line 116
  end = (p + code_size) + 6 * (int )sizeof(ikptr );
  }
#line 117
  return ((char *)(((4095UL + (unsigned long )end) >> 12) << 12));
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_code_page___0(char *p , unsigned int s , unsigned int d , char *base ,
                                  unsigned int *svec , unsigned int *dvec ) 
{ 
  ikptr fst ;
  int code_size ;
  int tmp ;
  int obj_size ;
  int tmp___0 ;
  int tmp___1 ;
  char *result ;

  {
#line 123
  fst = *((ikptr *)((long )p) + 0);
#line 124
  fst = fst;
#line 125
  if (fst != 47UL) {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"non code object with tag %p found\n",
            (void *)((long )fst));
#line 128
    exit(-1);
    }
  }
#line 130
  if ((int )sizeof(ikptr ) == 4) {
#line 130
    tmp = 2;
  } else {
#line 130
    tmp = 3;
  }
#line 130
  code_size = (int )((long )*((ikptr *)((long )p + (long )((int )sizeof(ikptr ))) + 0) >> tmp);
#line 132
  if ((int )sizeof(ikptr ) == 4) {
#line 132
    tmp___0 = 2;
  } else {
#line 132
    tmp___0 = 3;
  }
#line 132
  if ((int )sizeof(ikptr ) == 4) {
#line 132
    tmp___1 = 2;
  } else {
#line 132
    tmp___1 = 3;
  }
#line 132
  obj_size = ((((code_size + 6 * (int )sizeof(ikptr )) + 2 * (int )sizeof(ikptr )) - 1) >> (tmp___0 + 1)) << (tmp___1 + 1);
#line 134
  if (obj_size <= 4096) {
    {
#line 135
    result = verify_code_small___0(p, (int )s, d, base, svec, dvec);
    }
  } else {
    {
#line 137
    result = verify_code_large___0(p, s, d, base, svec, dvec);
    }
  }
#line 140
  return (result);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_pointers_page___0(char *p , unsigned int s , unsigned int d ,
                                      char *base , unsigned int *svec , unsigned int *dvec ) 
{ 
  int i ;

  {
#line 149
  s = s;
#line 149
  d = d;
#line 151
  i = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < 4096)) {
#line 152
      goto while_break;
    }
    {
#line 153
    verify_object___0(*((ikptr *)((long )p + (long )i) + 0), base, svec, dvec);
#line 154
    i += (int )sizeof(ikptr );
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (p + 4096);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/ikarus-0.0.3+bzr.2010.01.26/src/ikarus-verify-integrity.c"
static char *verify_page___0(char *p , char *base , unsigned int *svec , unsigned int *dvec ) 
{ 
  int idx ;
  long tmp ;
  long tmp___0 ;
  unsigned int s ;
  unsigned int d ;
  int type ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 163
  tmp = page_idx___0((void *)p);
#line 163
  tmp___0 = page_idx___0((void *)base);
#line 163
  idx = (int )(tmp - tmp___0);
#line 164
  s = *(svec + idx);
#line 165
  d = *(dvec + idx);
#line 169
  type = (int )(s & 3840U);
  }
#line 170
  if (type == 0) {
#line 171
    return (p + 4096);
  }
#line 174
  if (type == 1280) {
    {
#line 175
    tmp___1 = verify_code_page___0(p, s, d, base, svec, dvec);
    }
#line 175
    return (tmp___1);
  } else
#line 177
  if (type == 768) {
    {
#line 178
    tmp___2 = verify_pointers_page___0(p, s, d, base, svec, dvec);
    }
#line 178
    return (tmp___2);
  } else
#line 180
  if (type == 1536) {
    {
#line 181
    tmp___3 = verify_pointers_page___0(p, s, d, base, svec, dvec);
    }
#line 181
    return (tmp___3);
  } else
#line 183
  if (type == 1792) {
    {
#line 184
    tmp___4 = verify_pointers_page___0(p, s, d, base, svec, dvec);
    }
#line 184
    return (tmp___4);
  } else
#line 186
  if (type == 1024) {
#line 188
    return (p + 4096);
  } else
#line 190
  if (type == 256) {
#line 192
    return (p + 4096);
  } else
#line 194
  if (type == 512) {
#line 196
    return (p + 4096);
  }
  {
#line 198
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"type=0x%08x\n",
          type);
#line 199
  exit(-1);
  }
}
}
