/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.h"
struct controller_info;
#line 25 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.h"
struct selector_s;
#line 26 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.h"
typedef struct selector_s selector_t;
#line 4 "./buffer.h"
struct sbuf {
   unsigned char *buf ;
   unsigned int maxsize ;
   unsigned int cursize ;
   unsigned int pos ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.h"
struct telnet_data_s;
#line 20 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.h"
typedef struct telnet_data_s telnet_data_t;
#line 22 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.h"
struct telnet_cmd {
   unsigned char option ;
   unsigned int i_will : 1 ;
   unsigned int i_do : 1 ;
   unsigned int sent_will : 1 ;
   unsigned int sent_do : 1 ;
   unsigned int rem_will : 1 ;
   unsigned int rem_do : 1 ;
   void (*option_handler)(void *cb_data , unsigned char *option , int len ) ;
   int (*will_handler)(void *cb_data ) ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.h"
struct telnet_data_s {
   unsigned char telnet_cmd[32] ;
   int telnet_cmd_pos ;
   int suboption_iac ;
   struct sbuf out_telnet_cmd ;
   unsigned char out_telnet_cmdbuf[256] ;
   int error ;
   void *cb_data ;
   void (*output_ready)(void *cb_data ) ;
   void (*cmd_handler)(void *cb_data , unsigned char cmd ) ;
   struct telnet_cmd *cmds ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
struct controller_info {
   int tcpfd ;
   struct sockaddr_storage remote ;
   unsigned char inbuf[256] ;
   int inbuf_count ;
   char *outbuf ;
   int outbufsize ;
   int outbuf_pos ;
   int outbuf_count ;
   void *monitor_port_id ;
   struct controller_info *next ;
   telnet_data_t tn_data ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
typedef struct controller_info controller_info_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 60 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.h"
struct sel_timer_s;
#line 61 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.h"
typedef struct sel_timer_s sel_timer_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_32 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
   struct __anonstruct__sigsys_32 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_24 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_24 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_44 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_44 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
struct fd_control_s {
   int in_use ;
   void *data ;
   void (*handle_read)(int fd , void *data ) ;
   void (*handle_write)(int fd , void *data ) ;
   void (*handle_except)(int fd , void *data ) ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
typedef struct fd_control_s fd_control_t;
#line 63 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
struct sel_timer_s {
   void (*handler)(selector_t *sel , sel_timer_t *timer , void *data ) ;
   void *user_data ;
   struct timeval timeout ;
   selector_t *sel ;
   int in_heap ;
   sel_timer_t *left ;
   sel_timer_t *right ;
   sel_timer_t *up ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
struct selector_s {
   fd_control_t fds[1024] ;
   fd_set read_set ;
   fd_set write_set ;
   fd_set except_set ;
   int maxfd ;
   sel_timer_t *timer_top ;
   sel_timer_t *timer_last ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.h"
enum str_type {
    BANNER = 0,
    OPENSTR = 1,
    CLOSESTR = 2,
    SIGNATURE = 3
} ;
#line 42 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
struct longstr_s {
   char *name ;
   char *str ;
   enum str_type type ;
   struct longstr_s *next ;
};
#line 199 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
struct tracefile_s {
   char *name ;
   char *str ;
   struct tracefile_s *next ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.h"
struct trace_info_s {
   int hexdump ;
   int timestamp ;
   char *file ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.h"
typedef struct trace_info_s trace_info_t;
#line 36 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.h"
struct dev_info {
   struct termios termctl ;
   int allow_2217 ;
   int disablebreak ;
   char *banner ;
   char *signature ;
   char *openstr ;
   char *closestr ;
   trace_info_t trace_read ;
   trace_info_t trace_write ;
   trace_info_t trace_both ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.h"
typedef struct dev_info dev_info_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_20 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_20 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
struct trace_s {
   int hexdump ;
   int timestamp ;
   int file ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
typedef struct trace_s trace_t;
#line 94 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
struct port_info {
   int enabled ;
   int timeout ;
   int timeout_left ;
   sel_timer_t *timer ;
   char *portname ;
   struct sockaddr_storage tcpport ;
   socklen_t tcpport_len ;
   int acceptfd ;
   int tcpfd ;
   struct sockaddr_storage remote ;
   unsigned int tcp_bytes_received ;
   unsigned int tcp_bytes_sent ;
   struct sbuf *banner ;
   char *devname ;
   int devfd ;
   unsigned int dev_bytes_received ;
   unsigned int dev_bytes_sent ;
   int tcp_to_dev_state ;
   struct sbuf tcp_to_dev ;
   unsigned char tcp_to_devbuf[64] ;
   struct controller_info *tcp_monitor ;
   struct sbuf *devstr ;
   char *closestr ;
   int dev_to_tcp_state ;
   struct sbuf dev_to_tcp ;
   unsigned char dev_to_tcpbuf[64] ;
   struct controller_info *dev_monitor ;
   struct port_info *next ;
   int config_num ;
   struct port_info *new_config ;
   telnet_data_t tn_data ;
   int is_2217 ;
   int break_set ;
   unsigned char linestate_mask ;
   unsigned char modemstate_mask ;
   unsigned char last_modemstate ;
   trace_t wt ;
   trace_t rt ;
   trace_t bt ;
   dev_info_t dinfo ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
typedef struct port_info port_info_t;
#line 314 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
union __anonunion_buf_65 {
   uint32_t ival ;
   char str[64] ;
};
#line 1331 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
struct bufop_data {
   unsigned int pos ;
   char *str ;
};
#line 2710 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
struct baud_rates_s {
   int real_rate ;
   int val ;
   int cisco_ios_val ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.h"
int controller_init(char *controller_port ) ;
#line 29
void controller_shutdown(void) ;
#line 35
void controller_output(struct controller_info *cntlr , char *data , int count ) ;
#line 38
void controller_write(struct controller_info *cntlr , char *data , int count ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.h"
void sel_set_fd_handlers(selector_t *sel , int fd , void *data , void (*read_handler)(int fd ,
                                                                                      void *data ) ,
                         void (*write_handler)(int fd , void *data ) , void (*except_handler)(int fd ,
                                                                                              void *data ) ) ;
#line 50
void sel_clear_fd_handlers(selector_t *sel , int fd ) ;
#line 56
void sel_set_fd_read_handler(selector_t *sel , int fd , int state ) ;
#line 57
void sel_set_fd_write_handler(selector_t *sel , int fd , int state ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.h"
void showports(struct controller_info *cntlr , char *portspec ) ;
#line 53
void showshortports(struct controller_info *cntlr , char *portspec ) ;
#line 58
void setporttimeout(struct controller_info *cntlr , char *portspec , char *timeout ) ;
#line 65
void setportdevcfg(struct controller_info *cntlr , char *portspec , char *devcfg ) ;
#line 70
void setportcontrol(struct controller_info *cntlr , char *portspec , char *controls ) ;
#line 77
void setportenable(struct controller_info *cntlr , char *portspec , char *enable ) ;
#line 85
void *data_monitor_start(struct controller_info *cntlr , char *type , char *portspec ) ;
#line 90
void data_monitor_stop(struct controller_info *cntlr , void *monitor_id ) ;
#line 94
void disconnect_port(struct controller_info *cntlr , char *portspec ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.h"
int scan_tcp_port(char *str , int domain , struct sockaddr_storage *addr , socklen_t *addr_len ) ;
#line 43
void check_ipv6_only(int family , struct sockaddr *addr , int fd ) ;
#line 51
void write_ignore_fail(int fd , char *data , size_t count ) ;
#line 11 "./buffer.h"
int buffer_write(int fd , struct sbuf *buf___1 , int *buferr ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.h"
int process_telnet_data(unsigned char *data , int len , telnet_data_t *td ) ;
#line 97
void telnet_init(telnet_data_t *td , void *cb_data , void (*output_ready)(void *cb_data ) ,
                 void (*cmd_handler)(void *cb_data , unsigned char cmd ) , struct telnet_cmd *cmds ,
                 unsigned char *init_seq , int init_seq_len ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
selector_t *ser2net_sel ;
#line 50 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static int acceptfd  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static int max_controller_ports  =    4;
#line 54 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static int num_controller_ports  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
char *prompt  =    (char *)"-> ";
#line 96 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
controller_info_t *controllers  =    (controller_info_t *)((void *)0);
#line 99 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static unsigned char telnet_init_seq[9]  = 
#line 99
  {      (unsigned char)255,      (unsigned char)251,      (unsigned char)3,      (unsigned char)255, 
        (unsigned char)251,      (unsigned char)1,      (unsigned char)255,      (unsigned char)254, 
        (unsigned char)1};
#line 105 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static struct telnet_cmd telnet_cmds[4]  = {      {(unsigned char)3, 0U, 1U, 1U, 0U, 0U, 0U, (void (*)(void *cb_data , unsigned char *option ,
                                                          int len ))0, (int (*)(void *cb_data ))0}, 
        {(unsigned char)1,
      0U, 1U, 1U, 1U, 0U, 0U, (void (*)(void *cb_data , unsigned char *option , int len ))0,
      (int (*)(void *cb_data ))0}, 
        {(unsigned char)0, 1U, 1U, 0U, 1U, 0U, 0U, (void (*)(void *cb_data , unsigned char *option ,
                                                          int len ))0, (int (*)(void *cb_data ))0}, 
        {(unsigned char)255,
      0U, 0U, 0U, 0U, 0U, 0U, (void (*)(void *cb_data , unsigned char *option , int len ))0,
      (int (*)(void *cb_data ))0}};
#line 116 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static void shutdown_controller(controller_info_t *cntlr ) 
{ 
  controller_info_t *prev ;
  controller_info_t *curr ;

  {
#line 122
  if ((unsigned long )cntlr->monitor_port_id != (unsigned long )((void *)0)) {
    {
#line 123
    data_monitor_stop(cntlr, cntlr->monitor_port_id);
#line 124
    cntlr->monitor_port_id = (void *)0;
    }
  }
  {
#line 127
  sel_clear_fd_handlers(ser2net_sel, cntlr->tcpfd);
#line 128
  close(cntlr->tcpfd);
  }
#line 129
  if ((unsigned long )cntlr->outbuf != (unsigned long )((void *)0)) {
    {
#line 130
    free((void *)cntlr->outbuf);
    }
  }
#line 132
  cntlr->outbuf = (char *)((void *)0);
#line 135
  prev = (controller_info_t *)((void *)0);
#line 136
  curr = controllers;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 137
      goto while_break;
    }
#line 138
    if ((unsigned long )cntlr == (unsigned long )curr) {
#line 139
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 140
        controllers = controllers->next;
      } else {
#line 142
        prev->next = curr->next;
      }
#line 144
      num_controller_ports --;
#line 145
      goto while_break;
    }
#line 148
    prev = curr;
#line 149
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  free((void *)cntlr);
  }
#line 153
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
void controller_output(struct controller_info *cntlr , char *data , int count ) 
{ 
  int new_size ;
  int i ;
  char *newbuf ;
  void *tmp ;
  char *newbuf___0 ;
  int new_size___0 ;
  void *tmp___0 ;

  {
#line 163
  if ((unsigned long )cntlr->outbuf != (unsigned long )((void *)0)) {
#line 165
    new_size = cntlr->outbuf_count + count;
#line 167
    if (new_size <= cntlr->outbufsize) {
#line 172
      if (cntlr->outbuf_pos > 0) {
#line 173
        i = 0;
        {
#line 173
        while (1) {
          while_continue: /* CIL Label */ ;
#line 173
          if (! (i < cntlr->outbuf_count)) {
#line 173
            goto while_break;
          }
#line 174
          *(cntlr->outbuf + i) = *(cntlr->outbuf + (cntlr->outbuf_pos + i));
#line 173
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 177
      memcpy((void */* __restrict  */)(cntlr->outbuf + cntlr->outbuf_count), (void const   */* __restrict  */)data,
             (size_t )count);
      }
    } else {
      {
#line 183
      new_size = (new_size / 1024) * 1024 + 1024;
#line 184
      tmp = malloc((size_t )new_size);
#line 184
      newbuf = (char *)tmp;
      }
#line 186
      if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
#line 188
        return;
      }
      {
#line 191
      cntlr->outbufsize = new_size;
#line 194
      memcpy((void */* __restrict  */)newbuf, (void const   */* __restrict  */)(cntlr->outbuf + cntlr->outbuf_pos),
             (size_t )cntlr->outbuf_count);
#line 197
      memcpy((void */* __restrict  */)(newbuf + cntlr->outbuf_count), (void const   */* __restrict  */)data,
             (size_t )count);
#line 198
      free((void *)cntlr->outbuf);
#line 199
      cntlr->outbuf = newbuf;
      }
    }
#line 201
    cntlr->outbuf_pos = 0;
#line 202
    cntlr->outbuf_count += count;
  } else {
    {
#line 206
    new_size___0 = (count / 1024) * 1024 + 1024;
#line 208
    tmp___0 = malloc((size_t )new_size___0);
#line 208
    newbuf___0 = (char *)tmp___0;
    }
#line 209
    if ((unsigned long )newbuf___0 == (unsigned long )((void *)0)) {
#line 211
      return;
    }
    {
#line 214
    cntlr->outbufsize = new_size___0;
#line 216
    memcpy((void */* __restrict  */)newbuf___0, (void const   */* __restrict  */)data,
           (size_t )count);
#line 217
    cntlr->outbuf = newbuf___0;
#line 218
    cntlr->outbuf_pos = 0;
#line 219
    cntlr->outbuf_count = count;
#line 220
    sel_set_fd_read_handler(ser2net_sel, cntlr->tcpfd, 1);
#line 222
    sel_set_fd_write_handler(ser2net_sel, cntlr->tcpfd, 0);
    }
  }
#line 225
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
void controller_write(struct controller_info *cntlr , char *data , int count ) 
{ 


  {
  {
#line 231
  write_ignore_fail(cntlr->tcpfd, data, (size_t )count);
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static void telnet_output_ready(void *cb_data ) 
{ 
  struct controller_info *cntlr ;

  {
  {
#line 237
  cntlr = (struct controller_info *)cb_data;
#line 239
  sel_set_fd_read_handler(ser2net_sel, cntlr->tcpfd, 1);
#line 241
  sel_set_fd_write_handler(ser2net_sel, cntlr->tcpfd, 0);
  }
#line 243
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
void telnet_cmd_handler(void *cb_data , unsigned char cmd ) 
{ 


  {
#line 250
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static char *help_str  =    (char *)"exit - leave the program.\n\rhelp - display this help.\n\rversion - display the version of this program.\n\rmonitor <type> <tcp port> - display all the input for a given port on\n\r       the calling control port.  Only one direction may be monitored\n\r       at a time.  The type field may be \'tcp\' or \'term\' and specifies\n\r       whether to monitor data from the TCP port or from the serial port\n\r       Note that data monitoring is best effort, if the controller port\n\r       cannot keep up the data will be silently dropped.  A controller\n\r       may only monitor one thing and a port may only be monitored by\n\r       one controller.\n\rmonitor stop - stop the current monitor.\n\rdisconnect <tcp port> - disconnect the tcp connection on the port.\n\rshowport [<tcp port>] - Show information about a port. If no port is\n\r       given, all ports are displayed.\n\rshowshortport [<tcp port>] - Show information about a port in a one-line\n\r       format. If no port is given, all ports are displayed.\n\rsetporttimeout <tcp port> <timeout> - Set the amount of time in seconds\n\r       before the port connection will be shut down if no activity\n\r       has been seen on the port.\n\rsetportconfig <tcp port> <config> - Set the port configuration as in\n\r       the device configuration in the ser2net.conf file.  Valid options\n\r       are: 300, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, \n\r       EVEN, ODD, NONE, 1STOPBIT, 2STOPBITS, 7DATABITS, 8DATABITS, \n\r       LOCAL (ignore modem control), [-]RTSCTS, [-]XONXOFF.\n\r       Note that these will not change until the port is disconnected\n\r       and connected again.\n\rsetportcontrol <tcp port> <controls>\n\r       Dynamically modify the characteristics of the port.  These are\n\r       immedaite and won\'t live between connections.  Valid controls are\n\r       DTRHI, DTRLO, RTSHI, and RTSLO.\n\rsetportenable <tcp port> <enable state> - Sets the port operation state.\n\r       Valid states are:\n\r         off - The TCP port is shut down\n\r         raw - The TCP port is up and all I/O is transferred\n\r         rawlp - The TCP port is up and the input is transferred to dev\n\r         telnet - The TCP port is up and the telnet negotiation protocol\n\r                  runs on the port.\n\r";
#line 294 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
void process_input_line(controller_info_t *cntlr ) 
{ 
  char *strtok_data ;
  char *tok ;
  char *str ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *err ;
  size_t tmp___2 ;
  char *err___0 ;
  size_t tmp___3 ;
  char *err___1 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *err___2 ;
  size_t tmp___6 ;
  char *err___3 ;
  size_t tmp___7 ;
  char *err___4 ;
  size_t tmp___8 ;
  char *err___5 ;
  size_t tmp___9 ;
  char *err___6 ;
  size_t tmp___10 ;
  char *err___7 ;
  size_t tmp___11 ;
  char *err___8 ;
  size_t tmp___12 ;
  char *err___9 ;
  size_t tmp___13 ;
  char *err___10 ;
  size_t tmp___14 ;
  char *err___11 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;

  {
  {
#line 301
  tok = strtok_r((char */* __restrict  */)((char *)(cntlr->inbuf)), (char const   */* __restrict  */)" \t",
                 (char **/* __restrict  */)(& strtok_data));
  }
#line 302
  if (! ((unsigned long )tok == (unsigned long )((void *)0))) {
    {
#line 304
    tmp___28 = strcmp((char const   *)tok, "exit");
    }
#line 304
    if (tmp___28 == 0) {
      {
#line 305
      shutdown_controller(cntlr);
      }
#line 306
      return;
    } else {
      {
#line 307
      tmp___27 = strcmp((char const   *)tok, "quit");
      }
#line 307
      if (tmp___27 == 0) {
        {
#line 308
        shutdown_controller(cntlr);
        }
#line 309
        return;
      } else {
        {
#line 310
        tmp___26 = strcmp((char const   *)tok, "help");
        }
#line 310
        if (tmp___26 == 0) {
          {
#line 311
          tmp = strlen((char const   *)help_str);
#line 311
          controller_output(cntlr, help_str, (int )tmp);
          }
        } else {
          {
#line 312
          tmp___25 = strcmp((char const   *)tok, "version");
          }
#line 312
          if (tmp___25 == 0) {
            {
#line 313
            str = (char *)"ser2net version ";
#line 314
            tmp___0 = strlen((char const   *)str);
#line 314
            controller_output(cntlr, str, (int )tmp___0);
#line 315
            str = (char *)"2.9.1";
#line 316
            tmp___1 = strlen((char const   *)str);
#line 316
            controller_output(cntlr, str, (int )tmp___1);
#line 317
            controller_output(cntlr, (char *)"\n\r", 2);
            }
          } else {
            {
#line 318
            tmp___24 = strcmp((char const   *)tok, "showport");
            }
#line 318
            if (tmp___24 == 0) {
              {
#line 319
              tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                             (char **/* __restrict  */)(& strtok_data));
#line 320
              showports(cntlr, tok);
              }
            } else {
              {
#line 321
              tmp___23 = strcmp((char const   *)tok, "showshortport");
              }
#line 321
              if (tmp___23 == 0) {
                {
#line 322
                tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                               (char **/* __restrict  */)(& strtok_data));
#line 323
                showshortports(cntlr, tok);
                }
              } else {
                {
#line 324
                tmp___22 = strcmp((char const   *)tok, "monitor");
                }
#line 324
                if (tmp___22 == 0) {
                  {
#line 325
                  tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                                 (char **/* __restrict  */)(& strtok_data));
                  }
#line 326
                  if ((unsigned long )tok == (unsigned long )((void *)0)) {
                    {
#line 327
                    err = (char *)"No monitor type given\n\r";
#line 328
                    tmp___2 = strlen((char const   *)err);
#line 328
                    controller_output(cntlr, err, (int )tmp___2);
                    }
#line 329
                    goto out;
                  }
                  {
#line 331
                  tmp___5 = strcmp((char const   *)tok, "stop");
                  }
#line 331
                  if (tmp___5 == 0) {
#line 332
                    if ((unsigned long )cntlr->monitor_port_id != (unsigned long )((void *)0)) {
                      {
#line 333
                      data_monitor_stop(cntlr, cntlr->monitor_port_id);
#line 334
                      cntlr->monitor_port_id = (void *)0;
                      }
                    }
                  } else {
#line 337
                    if ((unsigned long )cntlr->monitor_port_id != (unsigned long )((void *)0)) {
                      {
#line 338
                      err___0 = (char *)"Already monitoring a port\n\r";
#line 339
                      tmp___3 = strlen((char const   *)err___0);
#line 339
                      controller_output(cntlr, err___0, (int )tmp___3);
                      }
#line 340
                      goto out;
                    }
                    {
#line 343
                    str = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                                   (char **/* __restrict  */)(& strtok_data));
                    }
#line 344
                    if ((unsigned long )str == (unsigned long )((void *)0)) {
                      {
#line 345
                      err___1 = (char *)"No tcp port given\n\r";
#line 346
                      tmp___4 = strlen((char const   *)err___1);
#line 346
                      controller_output(cntlr, err___1, (int )tmp___4);
                      }
#line 347
                      goto out;
                    }
                    {
#line 349
                    cntlr->monitor_port_id = data_monitor_start(cntlr, tok, str);
                    }
                  }
                } else {
                  {
#line 351
                  tmp___21 = strcmp((char const   *)tok, "disconnect");
                  }
#line 351
                  if (tmp___21 == 0) {
                    {
#line 352
                    tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                                   (char **/* __restrict  */)(& strtok_data));
                    }
#line 353
                    if ((unsigned long )tok == (unsigned long )((void *)0)) {
                      {
#line 354
                      err___2 = (char *)"No port given\n\r";
#line 355
                      tmp___6 = strlen((char const   *)err___2);
#line 355
                      controller_output(cntlr, err___2, (int )tmp___6);
                      }
#line 356
                      goto out;
                    }
                    {
#line 358
                    disconnect_port(cntlr, tok);
                    }
                  } else {
                    {
#line 359
                    tmp___20 = strcmp((char const   *)tok, "setporttimeout");
                    }
#line 359
                    if (tmp___20 == 0) {
                      {
#line 360
                      tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                                     (char **/* __restrict  */)(& strtok_data));
                      }
#line 361
                      if ((unsigned long )tok == (unsigned long )((void *)0)) {
                        {
#line 362
                        err___3 = (char *)"No port given\n\r";
#line 363
                        tmp___7 = strlen((char const   *)err___3);
#line 363
                        controller_output(cntlr, err___3, (int )tmp___7);
                        }
#line 364
                        goto out;
                      }
                      {
#line 366
                      str = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                                     (char **/* __restrict  */)(& strtok_data));
                      }
#line 367
                      if ((unsigned long )str == (unsigned long )((void *)0)) {
                        {
#line 368
                        err___4 = (char *)"No timeout given\n\r";
#line 369
                        tmp___8 = strlen((char const   *)err___4);
#line 369
                        controller_output(cntlr, err___4, (int )tmp___8);
                        }
#line 370
                        goto out;
                      }
                      {
#line 372
                      setporttimeout(cntlr, tok, str);
                      }
                    } else {
                      {
#line 373
                      tmp___19 = strcmp((char const   *)tok, "setportenable");
                      }
#line 373
                      if (tmp___19 == 0) {
                        {
#line 374
                        tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                                       (char **/* __restrict  */)(& strtok_data));
                        }
#line 375
                        if ((unsigned long )tok == (unsigned long )((void *)0)) {
                          {
#line 376
                          err___5 = (char *)"No port given\n\r";
#line 377
                          tmp___9 = strlen((char const   *)err___5);
#line 377
                          controller_output(cntlr, err___5, (int )tmp___9);
                          }
#line 378
                          goto out;
                        }
                        {
#line 380
                        str = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                                       (char **/* __restrict  */)(& strtok_data));
                        }
#line 381
                        if ((unsigned long )str == (unsigned long )((void *)0)) {
                          {
#line 382
                          err___6 = (char *)"No timeout given\n\r";
#line 383
                          tmp___10 = strlen((char const   *)err___6);
#line 383
                          controller_output(cntlr, err___6, (int )tmp___10);
                          }
#line 384
                          goto out;
                        }
                        {
#line 386
                        setportenable(cntlr, tok, str);
                        }
                      } else {
                        {
#line 387
                        tmp___18 = strcmp((char const   *)tok, "setportconfig");
                        }
#line 387
                        if (tmp___18 == 0) {
                          {
#line 388
                          tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                                         (char **/* __restrict  */)(& strtok_data));
                          }
#line 389
                          if ((unsigned long )tok == (unsigned long )((void *)0)) {
                            {
#line 390
                            err___7 = (char *)"No port given\n\r";
#line 391
                            tmp___11 = strlen((char const   *)err___7);
#line 391
                            controller_output(cntlr, err___7, (int )tmp___11);
                            }
#line 392
                            goto out;
                          }
                          {
#line 395
                          str = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"",
                                         (char **/* __restrict  */)(& strtok_data));
                          }
#line 396
                          if ((unsigned long )str == (unsigned long )((void *)0)) {
                            {
#line 397
                            err___8 = (char *)"No device config\n\r";
#line 398
                            tmp___12 = strlen((char const   *)err___8);
#line 398
                            controller_output(cntlr, err___8, (int )tmp___12);
                            }
#line 399
                            goto out;
                          }
                          {
#line 401
                          setportdevcfg(cntlr, tok, str);
                          }
                        } else {
                          {
#line 402
                          tmp___17 = strcmp((char const   *)tok, "setportcontrol");
                          }
#line 402
                          if (tmp___17 == 0) {
                            {
#line 403
                            tok = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                                           (char **/* __restrict  */)(& strtok_data));
                            }
#line 404
                            if ((unsigned long )tok == (unsigned long )((void *)0)) {
                              {
#line 405
                              err___9 = (char *)"No port given\n\r";
#line 406
                              tmp___13 = strlen((char const   *)err___9);
#line 406
                              controller_output(cntlr, err___9, (int )tmp___13);
                              }
#line 407
                              goto out;
                            }
                            {
#line 410
                            str = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"",
                                           (char **/* __restrict  */)(& strtok_data));
                            }
#line 411
                            if ((unsigned long )str == (unsigned long )((void *)0)) {
                              {
#line 412
                              err___10 = (char *)"No device controls\n\r";
#line 413
                              tmp___14 = strlen((char const   *)err___10);
#line 413
                              controller_output(cntlr, err___10, (int )tmp___14);
                              }
#line 414
                              goto out;
                            }
                            {
#line 416
                            setportcontrol(cntlr, tok, str);
                            }
                          } else {
                            {
#line 418
                            err___11 = (char *)"Unknown command: ";
#line 419
                            tmp___15 = strlen((char const   *)err___11);
#line 419
                            controller_output(cntlr, err___11, (int )tmp___15);
#line 420
                            tmp___16 = strlen((char const   *)tok);
#line 420
                            controller_output(cntlr, tok, (int )tmp___16);
#line 421
                            controller_output(cntlr, (char *)"\n\r", 2);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  out: 
  {
#line 425
  tmp___29 = strlen((char const   *)prompt);
#line 425
  controller_output(cntlr, prompt, (int )tmp___29);
  }
#line 426
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static int remove_chars(controller_info_t *cntlr , int pos , int count ) 
{ 
  int j ;

  {
#line 436
  j = (pos - count) + 1;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! (j < cntlr->inbuf_count - count)) {
#line 436
      goto while_break;
    }
#line 437
    cntlr->inbuf[j] = cntlr->inbuf[j + count];
#line 436
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  cntlr->inbuf_count -= count;
#line 440
  pos -= count;
#line 442
  return (pos);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static void handle_tcp_fd_read(int fd , void *data ) 
{ 
  controller_info_t *cntlr ;
  int read_count ;
  int read_start ;
  int i ;
  char *err ;
  size_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int j ;

  {
#line 449
  cntlr = (controller_info_t *)data;
#line 454
  if (cntlr->inbuf_count == 255) {
    {
#line 455
    err = (char *)"Input line too long\n\r";
#line 456
    tmp = strlen((char const   *)err);
#line 456
    controller_output(cntlr, err, (int )tmp);
#line 457
    cntlr->inbuf_count = 0;
    }
#line 458
    return;
  }
  {
#line 461
  tmp___0 = read(fd, (void *)(& cntlr->inbuf[cntlr->inbuf_count]), (size_t )(255 - cntlr->inbuf_count));
#line 461
  read_count = (int )tmp___0;
  }
#line 465
  if (read_count < 0) {
    {
#line 466
    tmp___1 = __errno_location();
    }
#line 466
    if (*tmp___1 == 4) {
#line 468
      return;
    }
    {
#line 471
    tmp___2 = __errno_location();
    }
#line 471
    if (*tmp___2 == 11) {
#line 473
      return;
    }
    {
#line 477
    syslog(3, "read error for controller port: %m");
#line 478
    shutdown_controller(cntlr);
    }
#line 479
    return;
  } else
#line 480
  if (read_count == 0) {
    {
#line 482
    shutdown_controller(cntlr);
    }
#line 483
    return;
  }
  {
#line 485
  read_start = cntlr->inbuf_count;
#line 486
  read_count = process_telnet_data(cntlr->inbuf + read_start, read_count, & cntlr->tn_data);
  }
#line 488
  if (cntlr->tn_data.error) {
    {
#line 489
    shutdown_controller(cntlr);
    }
#line 490
    return;
  }
#line 492
  cntlr->inbuf_count += read_count;
#line 494
  i = read_start;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! (i < cntlr->inbuf_count)) {
#line 494
      goto while_break;
    }
#line 495
    if ((int )cntlr->inbuf[i] == 0) {
      {
#line 497
      i = remove_chars(cntlr, i, 1);
      }
    } else
#line 498
    if ((int )cntlr->inbuf[i] == 10) {
      {
#line 500
      i = remove_chars(cntlr, i, 1);
      }
    } else
#line 501
    if ((int )cntlr->inbuf[i] == 8) {
#line 501
      goto _L;
    } else
#line 501
    if ((int )cntlr->inbuf[i] == 127) {
      _L: /* CIL Label */ 
#line 504
      if (i == 0) {
        {
#line 506
        i = remove_chars(cntlr, i, 1);
        }
      } else {
        {
#line 508
        i = remove_chars(cntlr, i, 2);
#line 509
        controller_output(cntlr, (char *)"\b \b", 3);
        }
      }
    } else
#line 511
    if ((int )cntlr->inbuf[i] == 13) {
      {
#line 515
      controller_output(cntlr, (char *)"\n\r", 2);
#line 517
      cntlr->inbuf[i] = (unsigned char )'\000';
#line 518
      process_input_line(cntlr);
#line 523
      i ++;
#line 524
      cntlr->inbuf_count -= i;
#line 525
      j = 0;
      }
      {
#line 525
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 525
        if (! (j < cntlr->inbuf_count)) {
#line 525
          goto while_break___0;
        }
#line 526
        cntlr->inbuf[j] = cntlr->inbuf[i];
#line 525
        i ++;
#line 525
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 528
      i = -1;
    } else {
      {
#line 531
      controller_output(cntlr, (char *)(& cntlr->inbuf[i]), 1);
      }
    }
#line 494
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  return;
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static void handle_tcp_fd_write(int fd , void *data ) 
{ 
  controller_info_t *cntlr ;
  telnet_data_t *td ;
  int write_count ;
  int buferr ;
  int reterr ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 542
  cntlr = (controller_info_t *)data;
#line 543
  td = & cntlr->tn_data;
#line 546
  if (td->out_telnet_cmd.cursize > 0U) {
    {
#line 549
    reterr = buffer_write(cntlr->tcpfd, & td->out_telnet_cmd, & buferr);
    }
#line 550
    if (reterr == -1) {
#line 551
      if (buferr == 32) {
#line 552
        goto out_fail;
      } else {
        {
#line 555
        syslog(3, "The tcp write for controller had error: %m");
        }
#line 556
        goto out_fail;
      }
    }
#line 559
    if (td->out_telnet_cmd.cursize > 0U) {
#line 561
      goto out;
    }
  }
  {
#line 564
  tmp = write(cntlr->tcpfd, (void const   *)(cntlr->outbuf + cntlr->outbuf_pos), (size_t )cntlr->outbuf_count);
#line 564
  write_count = (int )tmp;
  }
#line 567
  if (write_count == -1) {
    {
#line 568
    tmp___1 = __errno_location();
    }
#line 568
    if (! (*tmp___1 == 11)) {
      {
#line 570
      tmp___0 = __errno_location();
      }
#line 570
      if (*tmp___0 == 32) {
#line 571
        goto out_fail;
      } else {
        {
#line 574
        syslog(3, "The tcp write for controller had error: %m");
        }
#line 575
        goto out_fail;
      }
    }
  } else {
#line 578
    cntlr->outbuf_count -= write_count;
#line 579
    if (cntlr->outbuf_count != 0) {
#line 581
      cntlr->outbuf_pos += write_count;
    } else {
      {
#line 584
      free((void *)cntlr->outbuf);
#line 585
      cntlr->outbuf = (char *)((void *)0);
#line 586
      sel_set_fd_read_handler(ser2net_sel, cntlr->tcpfd, 0);
#line 588
      sel_set_fd_write_handler(ser2net_sel, cntlr->tcpfd, 1);
      }
    }
  }
  out: 
#line 593
  return;
  out_fail: 
  {
#line 596
  shutdown_controller(cntlr);
  }
#line 597
  return;
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static void handle_tcp_fd_except(int fd , void *data ) 
{ 
  controller_info_t *cntlr ;

  {
  {
#line 603
  cntlr = (controller_info_t *)data;
#line 605
  syslog(3, "Select exception for controller port");
#line 606
  shutdown_controller(cntlr);
  }
#line 607
  return;
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
static void handle_accept_port_read(int fd , void *data ) 
{ 
  controller_info_t *cntlr ;
  socklen_t len ;
  char *err ;
  int optval ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  struct sockaddr_storage dummy_sockaddr ;
  socklen_t len___0 ;
  int new_fd ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 615
  err = (char *)((void *)0);
#line 618
  if (num_controller_ports >= max_controller_ports) {
#line 619
    err = (char *)"Too many controller ports\n\r";
#line 620
    goto errout2;
  } else {
    {
#line 622
    tmp = malloc(sizeof(*cntlr));
#line 622
    cntlr = (controller_info_t *)tmp;
    }
#line 623
    if ((unsigned long )cntlr == (unsigned long )((void *)0)) {
#line 624
      err = (char *)"Could not allocate controller port\n\r";
#line 625
      goto errout2;
    }
  }
  {
#line 631
  len = (socklen_t )sizeof(cntlr->remote);
#line 632
  cntlr->tcpfd = accept(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& cntlr->remote)),
                        (socklen_t */* __restrict  */)(& len));
  }
#line 633
  if (cntlr->tcpfd == -1) {
    {
#line 634
    syslog(3, "Could not accept on controller port: %m");
    }
#line 635
    goto errout;
  }
  {
#line 654
  tmp___0 = fcntl(cntlr->tcpfd, 4, 2048);
  }
#line 654
  if (tmp___0 == -1) {
    {
#line 655
    close(cntlr->tcpfd);
#line 656
    syslog(3, "Could not fcntl the tcp port: %m");
    }
#line 657
    goto errout;
  }
  {
#line 660
  optval = 1;
#line 661
  tmp___1 = setsockopt(cntlr->tcpfd, 1, 9, (void const   *)((void *)(& optval)), (socklen_t )sizeof(optval));
  }
#line 661
  if (tmp___1 == -1) {
    {
#line 663
    close(cntlr->tcpfd);
#line 664
    syslog(3, "Could not enable SO_KEEPALIVE on the tcp port: %m");
    }
#line 665
    goto errout;
  }
  {
#line 668
  cntlr->inbuf_count = 0;
#line 669
  cntlr->outbuf = (char *)((void *)0);
#line 670
  cntlr->monitor_port_id = (void *)0;
#line 672
  sel_set_fd_handlers(ser2net_sel, cntlr->tcpfd, (void *)cntlr, & handle_tcp_fd_read,
                      & handle_tcp_fd_write, & handle_tcp_fd_except);
#line 679
  cntlr->next = controllers;
#line 680
  controllers = cntlr;
#line 686
  telnet_init(& cntlr->tn_data, (void *)cntlr, & telnet_output_ready, & telnet_cmd_handler,
              telnet_cmds, telnet_init_seq, (int )sizeof(telnet_init_seq));
#line 690
  tmp___2 = strlen((char const   *)prompt);
#line 690
  controller_output(cntlr, prompt, (int )tmp___2);
#line 692
  num_controller_ports ++;
  }
#line 694
  return;
  errout: 
  {
#line 697
  free((void *)cntlr);
  }
#line 698
  return;
  errout2: 
  {
#line 704
  len___0 = (socklen_t )sizeof(dummy_sockaddr);
#line 705
  tmp___3 = accept(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dummy_sockaddr)),
                   (socklen_t */* __restrict  */)(& len___0));
#line 705
  new_fd = tmp___3;
  }
#line 707
  if (new_fd != -1) {
    {
#line 708
    tmp___4 = strlen((char const   *)err);
#line 708
    write_ignore_fail(new_fd, err, tmp___4);
#line 709
    close(new_fd);
    }
  }
#line 712
  return;
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
int controller_init(char *controller_port ) 
{ 
  struct sockaddr_storage sock ;
  socklen_t sock_len ;
  int optval ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 720
  optval = 1;
#line 722
  tmp = scan_tcp_port(controller_port, 0, & sock, & sock_len);
  }
#line 722
  if (tmp == -1) {
#line 723
    return (-1);
  }
  {
#line 725
  acceptfd = socket((int )sock.ss_family, 1, 0);
  }
#line 726
  if (acceptfd == -1) {
    {
#line 726
    tmp___1 = __errno_location();
    }
#line 726
    if (*tmp___1 == 97) {
      {
#line 728
      tmp___0 = scan_tcp_port(controller_port, 2, & sock, & sock_len);
      }
#line 728
      if (tmp___0 == -1) {
#line 729
        return (-1);
      }
      {
#line 730
      acceptfd = socket((int )sock.ss_family, 1, 0);
      }
    }
  }
#line 732
  if (acceptfd == -1) {
    {
#line 733
    syslog(3, "Unable to create TCP socket: %m");
    }
#line 734
    return (-2);
  }
  {
#line 737
  tmp___2 = fcntl(acceptfd, 4, 2048);
  }
#line 737
  if (tmp___2 == -1) {
    {
#line 738
    close(acceptfd);
#line 739
    acceptfd = -1;
#line 740
    syslog(3, "Could not fcntl the accept port: %m");
    }
#line 741
    return (-2);
  }
  {
#line 744
  tmp___3 = setsockopt(acceptfd, 1, 2, (void const   *)((void *)(& optval)), (socklen_t )sizeof(optval));
  }
#line 744
  if (tmp___3 == -1) {
    {
#line 749
    close(acceptfd);
#line 750
    acceptfd = -1;
#line 751
    syslog(3, "Unable to set reuseaddress on socket: %m");
    }
#line 752
    return (-2);
  }
  {
#line 755
  check_ipv6_only((int )sock.ss_family, (struct sockaddr *)(& sock), acceptfd);
#line 759
  tmp___4 = bind(acceptfd, (struct sockaddr  const  *)((struct sockaddr *)(& sock)),
                 sock_len);
  }
#line 759
  if (tmp___4 == -1) {
    {
#line 760
    close(acceptfd);
#line 761
    acceptfd = -1;
#line 762
    syslog(3, "Unable to bind TCP port: %m");
    }
#line 763
    return (-2);
  }
  {
#line 766
  tmp___5 = listen(acceptfd, 1);
  }
#line 766
  if (tmp___5 != 0) {
    {
#line 767
    close(acceptfd);
#line 768
    acceptfd = -1;
#line 769
    syslog(3, "Unable to listen to TCP port: %m");
    }
#line 770
    return (-2);
  }
  {
#line 773
  sel_set_fd_handlers(ser2net_sel, acceptfd, (void *)0, & handle_accept_port_read,
                      (void (*)(int fd , void *data ))((void *)0), (void (*)(int fd ,
                                                                             void *data ))((void *)0));
#line 779
  sel_set_fd_read_handler(ser2net_sel, acceptfd, 0);
  }
#line 780
  return (0);
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/controller.c"
void controller_shutdown(void) 
{ 


  {
#line 786
  if (acceptfd == -1) {
#line 787
    return;
  }
  {
#line 788
  sel_clear_fd_handlers(ser2net_sel, acceptfd);
#line 789
  close(acceptfd);
#line 790
  acceptfd = -1;
  }
#line 791
  return;
}
}
#line 13 "./buffer.h"
int buffer_output(struct sbuf *buf___1 , unsigned char *data , unsigned int len ) ;
#line 15
int buffer_outchar(struct sbuf *buf___1 , unsigned char data ) ;
#line 17
void buffer_init(struct sbuf *buf___1 , unsigned char *data , unsigned int datasize ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.h"
void telnet_cmd_send(telnet_data_t *td , unsigned char *cmd , int len ) ;
#line 94
void telnet_send_option(telnet_data_t *td , unsigned char *option , int len ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.c"
static struct telnet_cmd *find_cmd(struct telnet_cmd *array , unsigned char option ) 
{ 
  int i ;

  {
#line 12
  i = 0;
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! ((int )(array + i)->option != 255)) {
#line 12
      goto while_break;
    }
#line 13
    if ((int )(array + i)->option == (int )option) {
#line 14
      return (array + i);
    }
#line 12
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 16
  return ((struct telnet_cmd *)((void *)0));
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.c"
void telnet_cmd_send(telnet_data_t *td , unsigned char *cmd , int len ) 
{ 
  int tmp ;

  {
  {
#line 22
  tmp = buffer_output(& td->out_telnet_cmd, cmd, (unsigned int )len);
  }
#line 22
  if (tmp == -1) {
#line 25
    td->error = 1;
#line 26
    return;
  }
  {
#line 29
  (*(td->output_ready))(td->cb_data);
  }
#line 30
  return;
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.c"
static void send_i(telnet_data_t *td , unsigned char type , unsigned char option ) 
{ 
  unsigned char i[3] ;

  {
  {
#line 36
  i[0] = (unsigned char)255;
#line 37
  i[1] = type;
#line 38
  i[2] = option;
#line 39
  telnet_cmd_send(td, i, 3);
  }
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.c"
static void handle_telnet_cmd(telnet_data_t *td ) 
{ 
  int size ;
  unsigned char *cmd_str ;
  struct telnet_cmd *cmd ;
  int rv ;
  unsigned char option ;
  unsigned char option___0 ;
  unsigned char option___1 ;
  unsigned char option___2 ;

  {
#line 45
  size = td->telnet_cmd_pos;
#line 46
  cmd_str = td->telnet_cmd;
#line 50
  if (size < 2) {
#line 51
    return;
  }
#line 53
  if ((int )*(cmd_str + 1) < 250) {
    {
#line 54
    (*(td->cmd_handler))(td->cb_data, *(cmd_str + 1));
    }
  } else
#line 55
  if ((int )*(cmd_str + 1) == 250) {
    {
#line 56
    cmd = find_cmd(td->cmds, *(cmd_str + 2));
    }
#line 57
    if (! cmd) {
#line 58
      return;
    }
    {
#line 59
    (*(cmd->option_handler))(td->cb_data, cmd_str + 2, size - 2);
    }
  } else
#line 60
  if ((int )*(cmd_str + 1) == 251) {
    {
#line 61
    option = *(cmd_str + 2);
#line 62
    cmd = find_cmd(td->cmds, option);
    }
#line 63
    if (! cmd) {
#line 63
      goto _L;
    } else
#line 63
    if (! cmd->sent_do) {
      _L: /* CIL Label */ 
#line 64
      if (! cmd) {
        {
#line 65
        send_i(td, (unsigned char)254, option);
        }
      } else
#line 64
      if (! cmd->i_will) {
        {
#line 65
        send_i(td, (unsigned char)254, option);
        }
      } else {
#line 67
        rv = 1;
#line 68
        if (cmd->will_handler) {
          {
#line 69
          rv = (*(cmd->will_handler))(td->cb_data);
          }
        }
#line 70
        if (rv) {
          {
#line 71
          send_i(td, (unsigned char)253, option);
          }
        } else {
          {
#line 73
          send_i(td, (unsigned char)254, option);
          }
        }
      }
    } else
#line 75
    if (cmd) {
#line 76
      cmd->sent_do = 0U;
    }
#line 77
    if (cmd) {
#line 78
      cmd->rem_will = 1U;
    }
  } else
#line 80
  if ((int )*(cmd_str + 1) == 252) {
    {
#line 81
    option___0 = *(cmd_str + 2);
#line 82
    cmd = find_cmd(td->cmds, option___0);
    }
#line 83
    if (! cmd) {
      {
#line 84
      send_i(td, (unsigned char)254, option___0);
      }
    } else
#line 83
    if (! cmd->sent_do) {
      {
#line 84
      send_i(td, (unsigned char)254, option___0);
      }
    } else
#line 85
    if (cmd) {
#line 86
      cmd->sent_do = 0U;
    }
#line 87
    if (cmd) {
#line 88
      cmd->rem_will = 0U;
    }
  } else
#line 89
  if ((int )*(cmd_str + 1) == 253) {
    {
#line 90
    option___1 = *(cmd_str + 2);
#line 91
    cmd = find_cmd(td->cmds, option___1);
    }
#line 92
    if (! cmd) {
#line 92
      goto _L___0;
    } else
#line 92
    if (! cmd->sent_will) {
      _L___0: /* CIL Label */ 
#line 93
      if (! cmd) {
        {
#line 94
        send_i(td, (unsigned char)252, option___1);
        }
      } else
#line 93
      if (! cmd->i_do) {
        {
#line 94
        send_i(td, (unsigned char)252, option___1);
        }
      } else {
        {
#line 96
        send_i(td, (unsigned char)251, option___1);
        }
      }
    } else
#line 97
    if (cmd) {
#line 98
      cmd->sent_will = 0U;
    }
#line 99
    if (cmd) {
#line 100
      cmd->rem_do = 1U;
    }
  } else
#line 101
  if ((int )*(cmd_str + 1) == 254) {
    {
#line 102
    option___2 = *(cmd_str + 2);
#line 103
    cmd = find_cmd(td->cmds, option___2);
    }
#line 104
    if (! cmd) {
      {
#line 105
      send_i(td, (unsigned char)252, option___2);
      }
    } else
#line 104
    if (! cmd->sent_will) {
      {
#line 105
      send_i(td, (unsigned char)252, option___2);
      }
    } else
#line 106
    if (cmd) {
#line 107
      cmd->sent_will = 0U;
    }
#line 108
    if (cmd) {
#line 109
      cmd->rem_do = 0U;
    }
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.c"
void telnet_send_option(telnet_data_t *td , unsigned char *option , int len ) 
{ 
  unsigned int real_len ;
  unsigned int i ;

  {
#line 120
  real_len = 0U;
#line 120
  i = 0U;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < (unsigned int )len)) {
#line 120
      goto while_break;
    }
#line 121
    if ((int )*(option + i) == 255) {
#line 122
      real_len ++;
    }
#line 120
    i ++;
#line 120
    real_len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  real_len += 4U;
#line 127
  if (real_len > td->out_telnet_cmd.maxsize - td->out_telnet_cmd.cursize) {
#line 130
    td->error = 1;
#line 131
    return;
  }
  {
#line 134
  buffer_outchar(& td->out_telnet_cmd, (unsigned char)255);
#line 135
  buffer_outchar(& td->out_telnet_cmd, (unsigned char)250);
#line 136
  i = 0U;
  }
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! (i < (unsigned int )len)) {
#line 136
      goto while_break___0;
    }
    {
#line 137
    buffer_outchar(& td->out_telnet_cmd, *(option + i));
    }
#line 138
    if ((int )*(option + i) == 255) {
      {
#line 139
      buffer_outchar(& td->out_telnet_cmd, *(option + i));
      }
    }
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 141
  buffer_outchar(& td->out_telnet_cmd, (unsigned char)255);
#line 142
  buffer_outchar(& td->out_telnet_cmd, (unsigned char)240);
#line 144
  (*(td->output_ready))(td->cb_data);
  }
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.c"
static int delete_char(unsigned char *data , int pos , int len ) 
{ 
  int i ;

  {
#line 152
  i = pos;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < len - 1)) {
#line 152
      goto while_break;
    }
#line 153
    *(data + i) = *(data + (i + 1));
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return (len - 1);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.c"
int process_telnet_data(unsigned char *data , int len , telnet_data_t *td ) 
{ 
  int i ;
  unsigned char tn_byte ;

  {
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < len)) {
#line 164
      goto while_break;
    }
#line 165
    if (td->telnet_cmd_pos != 0) {
#line 168
      tn_byte = *(data + i);
#line 170
      if (td->telnet_cmd_pos == 1) {
#line 170
        if ((int )tn_byte == 255) {
#line 173
          i ++;
#line 174
          td->telnet_cmd_pos = 0;
#line 175
          goto __Cont;
        }
      }
      {
#line 178
      len = delete_char(data, i, len);
      }
#line 180
      if (td->telnet_cmd_pos == 1) {
#line 183
        td->telnet_cmd[td->telnet_cmd_pos] = tn_byte;
#line 184
        (td->telnet_cmd_pos) ++;
#line 185
        if ((int )tn_byte < 250) {
          {
#line 186
          handle_telnet_cmd(td);
#line 187
          td->telnet_cmd_pos = 0;
          }
        }
      } else
#line 189
      if (td->telnet_cmd_pos == 2) {
#line 190
        td->telnet_cmd[td->telnet_cmd_pos] = tn_byte;
#line 191
        (td->telnet_cmd_pos) ++;
#line 192
        if ((int )td->telnet_cmd[1] != 250) {
          {
#line 194
          handle_telnet_cmd(td);
#line 195
          td->telnet_cmd_pos = 0;
          }
        }
      } else
#line 199
      if (td->suboption_iac) {
#line 200
        if ((int )tn_byte == 240) {
          {
#line 202
          (td->telnet_cmd_pos) --;
#line 203
          handle_telnet_cmd(td);
#line 204
          td->telnet_cmd_pos = 0;
          }
        } else
#line 205
        if (! ((int )tn_byte == 255)) {
#line 211
          (td->telnet_cmd_pos) --;
        }
#line 213
        td->suboption_iac = 0;
      } else {
#line 215
        if (td->telnet_cmd_pos > 31) {
#line 221
          td->telnet_cmd_pos = 31;
        }
#line 223
        td->telnet_cmd[td->telnet_cmd_pos] = tn_byte;
#line 224
        (td->telnet_cmd_pos) ++;
#line 225
        if ((int )tn_byte == 255) {
#line 226
          td->suboption_iac = 1;
        }
      }
    } else
#line 229
    if ((int )*(data + i) == 255) {
      {
#line 230
      td->telnet_cmd[td->telnet_cmd_pos] = (unsigned char)255;
#line 231
      len = delete_char(data, i, len);
#line 232
      (td->telnet_cmd_pos) ++;
#line 233
      td->suboption_iac = 0;
      }
    } else {
#line 235
      i ++;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return (len);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/telnet.c"
void telnet_init(telnet_data_t *td , void *cb_data , void (*output_ready)(void *cb_data ) ,
                 void (*cmd_handler)(void *cb_data , unsigned char cmd ) , struct telnet_cmd *cmds ,
                 unsigned char *init_seq , int init_seq_len ) 
{ 


  {
  {
#line 251
  td->telnet_cmd_pos = 0;
#line 252
  buffer_init(& td->out_telnet_cmd, td->out_telnet_cmdbuf, (unsigned int )sizeof(td->out_telnet_cmdbuf));
#line 254
  td->error = 0;
#line 255
  td->cb_data = cb_data;
#line 256
  td->output_ready = output_ready;
#line 257
  td->cmd_handler = cmd_handler;
#line 258
  td->cmds = cmds;
#line 260
  telnet_cmd_send(td, init_seq, init_seq_len);
  }
#line 261
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.h"
int sel_alloc_selector(selector_t **new_selector ) ;
#line 32
int sel_free_selector(selector_t *sel ) ;
#line 58
void sel_set_fd_except_handler(selector_t *sel , int fd , int state ) ;
#line 67
int sel_alloc_timer(selector_t *sel , void (*handler)(selector_t *sel , sel_timer_t *timer ,
                                                      void *data ) , void *user_data ,
                    sel_timer_t **new_timer ) ;
#line 72
int sel_free_timer(sel_timer_t *timer ) ;
#line 74
int sel_start_timer(sel_timer_t *timer , struct timeval *timeout ) ;
#line 77
int sel_stop_timer(sel_timer_t *timer ) ;
#line 81
void set_signal_handler(int sig , void (*handler)(void) ) ;
#line 82
void setup_signals(void) ;
#line 85
void sel_select_once(selector_t *sel ) ;
#line 88
void sel_select_loop(selector_t *sel ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 105 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void (*user_sighup_handler)(void)  =    (void (*)(void))((void *)0);
#line 106 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void (*user_sigint_handler)(void)  =    (void (*)(void))((void *)0);
#line 107 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static int got_sighup  =    0;
#line 108 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static int got_sigint  =    0;
#line 111 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void init_fd(fd_control_t *fd ) 
{ 


  {
#line 114
  fd->in_use = 0;
#line 115
  fd->data = (void *)0;
#line 116
  fd->handle_read = (void (*)(int fd , void *data ))((void *)0);
#line 117
  fd->handle_write = (void (*)(int fd , void *data ))((void *)0);
#line 118
  fd->handle_except = (void (*)(int fd , void *data ))((void *)0);
#line 119
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
void sel_set_fd_handlers(selector_t *sel , int fd , void *data , void (*read_handler)(int fd ,
                                                                                      void *data ) ,
                         void (*write_handler)(int fd , void *data ) , void (*except_handler)(int fd ,
                                                                                              void *data ) ) 
{ 


  {
#line 130
  sel->fds[fd].in_use = 1;
#line 131
  sel->fds[fd].data = data;
#line 132
  sel->fds[fd].handle_read = read_handler;
#line 133
  sel->fds[fd].handle_write = write_handler;
#line 134
  sel->fds[fd].handle_except = except_handler;
#line 137
  if (fd > sel->maxfd) {
#line 138
    sel->maxfd = fd;
  }
#line 140
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
void sel_clear_fd_handlers(selector_t *sel , int fd ) 
{ 


  {
  {
#line 148
  init_fd(& sel->fds[fd]);
#line 149
  sel->read_set.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 150
  sel->write_set.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 151
  sel->except_set.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
  }
#line 154
  if (fd == sel->maxfd) {
    {
#line 155
    while (1) {
      while_continue: /* CIL Label */ ;
#line 155
      if (sel->maxfd >= 0) {
#line 155
        if (! (! sel->fds[sel->maxfd].in_use)) {
#line 155
          goto while_break;
        }
      } else {
#line 155
        goto while_break;
      }
#line 156
      (sel->maxfd) --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 159
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
void sel_set_fd_read_handler(selector_t *sel , int fd , int state ) 
{ 


  {
#line 166
  if (state == 0) {
#line 167
    sel->read_set.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  } else
#line 168
  if (state == 1) {
#line 169
    sel->read_set.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
  }
#line 172
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
void sel_set_fd_write_handler(selector_t *sel , int fd , int state ) 
{ 


  {
#line 179
  if (state == 0) {
#line 180
    sel->write_set.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  } else
#line 181
  if (state == 1) {
#line 182
    sel->write_set.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
  }
#line 185
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
void sel_set_fd_except_handler(selector_t *sel , int fd , int state ) 
{ 


  {
#line 192
  if (state == 0) {
#line 193
    sel->except_set.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  } else
#line 194
  if (state == 1) {
#line 195
    sel->except_set.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
  }
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static int cmp_timeval(struct timeval *tv1 , struct timeval *tv2 ) 
{ 


  {
#line 203
  if (tv1->tv_sec < tv2->tv_sec) {
#line 204
    return (-1);
  }
#line 206
  if (tv1->tv_sec > tv2->tv_sec) {
#line 207
    return (1);
  }
#line 209
  if (tv1->tv_usec < tv2->tv_usec) {
#line 210
    return (-1);
  }
#line 212
  if (tv1->tv_usec > tv2->tv_usec) {
#line 213
    return (1);
  }
#line 215
  return (0);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void diff_timeval(struct timeval *dest , struct timeval *left , struct timeval *right ) 
{ 


  {
#line 223
  if (left->tv_sec < right->tv_sec) {
#line 229
    dest->tv_sec = (__time_t )0;
#line 230
    dest->tv_usec = (__suseconds_t )0;
#line 231
    return;
  } else
#line 223
  if (left->tv_sec == right->tv_sec) {
#line 223
    if (left->tv_usec < right->tv_usec) {
#line 229
      dest->tv_sec = (__time_t )0;
#line 230
      dest->tv_usec = (__suseconds_t )0;
#line 231
      return;
    }
  }
#line 234
  dest->tv_sec = left->tv_sec - right->tv_sec;
#line 235
  dest->tv_usec = left->tv_usec - right->tv_usec;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (dest->tv_usec < 0L)) {
#line 236
      goto while_break;
    }
#line 237
    dest->tv_usec += 1000000L;
#line 238
    (dest->tv_sec) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void find_next_pos(sel_timer_t *curr , sel_timer_t ***next , sel_timer_t **parent ) 
{ 
  unsigned int upcount ;

  {
#line 368
  upcount = 0U;
#line 370
  if (curr->up) {
#line 370
    if ((unsigned long )(curr->up)->left == (unsigned long )curr) {
#line 372
      *next = & (curr->up)->right;
#line 373
      *parent = curr->up;
#line 374
      return;
    }
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (curr->up) {
#line 378
      if (! ((unsigned long )(curr->up)->right == (unsigned long )curr)) {
#line 378
        goto while_break;
      }
    } else {
#line 378
      goto while_break;
    }
#line 379
    upcount ++;
#line 380
    curr = curr->up;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  if (curr->up) {
#line 385
    curr = (curr->up)->right;
#line 386
    upcount --;
  }
  {
#line 388
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 388
    if (! upcount) {
#line 388
      goto while_break___0;
    }
#line 389
    curr = curr->left;
#line 390
    upcount --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 392
  *next = & curr->left;
#line 393
  *parent = curr;
#line 394
  return;
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void find_prev_elem(sel_timer_t *curr , sel_timer_t **prev ) 
{ 
  unsigned int upcount ;

  {
#line 399
  upcount = 0U;
#line 401
  if (curr->up) {
#line 401
    if ((unsigned long )(curr->up)->right == (unsigned long )curr) {
#line 403
      *prev = (curr->up)->left;
#line 404
      return;
    }
  }
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (curr->up) {
#line 408
      if (! ((unsigned long )(curr->up)->left == (unsigned long )curr)) {
#line 408
        goto while_break;
      }
    } else {
#line 408
      goto while_break;
    }
#line 409
    upcount ++;
#line 410
    curr = curr->up;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  if (curr->up) {
#line 415
    curr = (curr->up)->left;
  } else {
#line 418
    upcount --;
  }
  {
#line 420
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 420
    if (! upcount) {
#line 420
      goto while_break___0;
    }
#line 421
    curr = curr->right;
#line 422
    upcount --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 424
  *prev = curr;
#line 425
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void send_up(sel_timer_t *elem , sel_timer_t **top , sel_timer_t **last ) 
{ 
  sel_timer_t *tmp1 ;
  sel_timer_t *tmp2 ;
  sel_timer_t *parent ;
  int tmp ;

  {
#line 432
  parent = elem->up;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (parent) {
      {
#line 433
      tmp = cmp_timeval(& elem->timeout, & parent->timeout);
      }
#line 433
      if (! (tmp < 0)) {
#line 433
        goto while_break;
      }
    } else {
#line 433
      goto while_break;
    }
#line 434
    tmp1 = elem->left;
#line 435
    tmp2 = elem->right;
#line 436
    if ((unsigned long )parent->left == (unsigned long )elem) {
#line 437
      elem->left = parent;
#line 438
      elem->right = parent->right;
#line 439
      if (elem->right) {
#line 440
        (elem->right)->up = elem;
      }
    } else {
#line 442
      elem->right = parent;
#line 443
      elem->left = parent->left;
#line 444
      if (elem->left) {
#line 445
        (elem->left)->up = elem;
      }
    }
#line 447
    elem->up = parent->up;
#line 449
    if (parent->up) {
#line 450
      if ((unsigned long )(parent->up)->left == (unsigned long )parent) {
#line 451
        (parent->up)->left = elem;
      } else {
#line 453
        (parent->up)->right = elem;
      }
    } else {
#line 456
      *top = elem;
    }
#line 459
    parent->up = elem;
#line 460
    parent->left = tmp1;
#line 461
    if (parent->left) {
#line 462
      (parent->left)->up = parent;
    }
#line 463
    parent->right = tmp2;
#line 464
    if (parent->right) {
#line 465
      (parent->right)->up = parent;
    }
#line 467
    if ((unsigned long )*last == (unsigned long )elem) {
#line 468
      *last = parent;
    }
#line 470
    parent = elem->up;
  }
  while_break: /* CIL Label */ ;
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void send_down(sel_timer_t *elem , sel_timer_t **top , sel_timer_t **last ) 
{ 
  sel_timer_t *tmp1 ;
  sel_timer_t *tmp2 ;
  sel_timer_t *left ;
  sel_timer_t *right ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 479
  left = elem->left;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! left) {
#line 480
      goto while_break;
    }
#line 481
    right = elem->right;
#line 483
    if (right) {
      {
#line 483
      tmp___1 = cmp_timeval(& left->timeout, & right->timeout);
      }
#line 483
      if (tmp___1 > 0) {
        {
#line 485
        tmp = cmp_timeval(& elem->timeout, & right->timeout);
        }
#line 485
        if (tmp > 0) {
#line 487
          tmp1 = right->left;
#line 488
          tmp2 = right->right;
#line 489
          if (elem->up) {
#line 490
            if ((unsigned long )(elem->up)->left == (unsigned long )elem) {
#line 491
              (elem->up)->left = right;
            } else {
#line 493
              (elem->up)->right = right;
            }
          } else {
#line 496
            *top = right;
          }
#line 498
          right->up = elem->up;
#line 499
          elem->up = right;
#line 501
          right->left = elem->left;
#line 502
          right->right = elem;
#line 503
          elem->left = tmp1;
#line 504
          elem->right = tmp2;
#line 505
          if (right->left) {
#line 506
            (right->left)->up = right;
          }
#line 507
          if (elem->left) {
#line 508
            (elem->left)->up = elem;
          }
#line 509
          if (elem->right) {
#line 510
            (elem->right)->up = elem;
          }
#line 512
          if ((unsigned long )*last == (unsigned long )right) {
#line 513
            *last = elem;
          }
        } else {
#line 515
          goto done;
        }
      } else {
#line 483
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 518
      tmp___0 = cmp_timeval(& elem->timeout, & left->timeout);
      }
#line 518
      if (tmp___0 > 0) {
#line 520
        tmp1 = left->left;
#line 521
        tmp2 = left->right;
#line 522
        if (elem->up) {
#line 523
          if ((unsigned long )(elem->up)->left == (unsigned long )elem) {
#line 524
            (elem->up)->left = left;
          } else {
#line 526
            (elem->up)->right = left;
          }
        } else {
#line 529
          *top = left;
        }
#line 531
        left->up = elem->up;
#line 532
        elem->up = left;
#line 534
        left->left = elem;
#line 535
        left->right = elem->right;
#line 536
        elem->left = tmp1;
#line 537
        elem->right = tmp2;
#line 538
        if (left->right) {
#line 539
          (left->right)->up = left;
        }
#line 540
        if (elem->left) {
#line 541
          (elem->left)->up = elem;
        }
#line 542
        if (elem->right) {
#line 543
          (elem->right)->up = elem;
        }
#line 545
        if ((unsigned long )*last == (unsigned long )left) {
#line 546
          *last = elem;
        }
      } else {
#line 548
        goto done;
      }
    }
#line 550
    left = elem->left;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 553
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void add_to_heap(sel_timer_t **top , sel_timer_t **last , sel_timer_t *elem ) 
{ 
  sel_timer_t **next ;
  sel_timer_t *parent ;
  int tmp ;

  {
#line 568
  elem->left = (sel_timer_t *)((void *)0);
#line 569
  elem->right = (sel_timer_t *)((void *)0);
#line 570
  elem->up = (sel_timer_t *)((void *)0);
#line 572
  if ((unsigned long )*top == (unsigned long )((void *)0)) {
#line 573
    *top = elem;
#line 574
    *last = elem;
#line 575
    goto out;
  }
  {
#line 578
  find_next_pos(*last, & next, & parent);
#line 579
  *next = elem;
#line 580
  elem->up = parent;
#line 581
  *last = elem;
#line 582
  tmp = cmp_timeval(& elem->timeout, & parent->timeout);
  }
#line 582
  if (tmp < 0) {
    {
#line 583
    send_up(elem, top, last);
    }
  }
  out: 
#line 592
  return;
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void remove_from_heap(sel_timer_t **top , sel_timer_t **last , sel_timer_t *elem ) 
{ 
  sel_timer_t *to_insert ;
  int tmp ;

  {
#line 609
  to_insert = *last;
#line 610
  if (! to_insert->up) {
#line 612
    *top = (sel_timer_t *)((void *)0);
#line 613
    *last = (sel_timer_t *)((void *)0);
#line 614
    goto out;
  } else {
    {
#line 618
    find_prev_elem(to_insert, last);
    }
#line 619
    if ((unsigned long )(to_insert->up)->left == (unsigned long )to_insert) {
#line 620
      (to_insert->up)->left = (sel_timer_t *)((void *)0);
    } else {
#line 622
      (to_insert->up)->right = (sel_timer_t *)((void *)0);
    }
  }
#line 626
  if ((unsigned long )elem == (unsigned long )to_insert) {
#line 628
    goto out;
  }
#line 633
  if (elem->up) {
#line 634
    if ((unsigned long )(elem->up)->left == (unsigned long )elem) {
#line 635
      (elem->up)->left = to_insert;
    } else {
#line 637
      (elem->up)->right = to_insert;
    }
  } else {
#line 641
    *top = to_insert;
  }
#line 643
  to_insert->up = elem->up;
#line 644
  if (elem->left) {
#line 645
    (elem->left)->up = to_insert;
  }
#line 646
  if (elem->right) {
#line 647
    (elem->right)->up = to_insert;
  }
#line 648
  to_insert->left = elem->left;
#line 649
  to_insert->right = elem->right;
#line 651
  if ((unsigned long )*last == (unsigned long )elem) {
#line 652
    *last = to_insert;
  }
#line 654
  elem = to_insert;
#line 657
  if (elem->up) {
    {
#line 657
    tmp = cmp_timeval(& elem->timeout, & (elem->up)->timeout);
    }
#line 657
    if (tmp < 0) {
      {
#line 658
      send_up(elem, top, last);
      }
    } else {
      {
#line 660
      send_down(elem, top, last);
      }
    }
  } else {
    {
#line 660
    send_down(elem, top, last);
    }
  }
  out: 
#line 669
  return;
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
int sel_alloc_timer(selector_t *sel , void (*handler)(selector_t *sel , sel_timer_t *timer ,
                                                      void *data ) , void *user_data ,
                    sel_timer_t **new_timer ) 
{ 
  sel_timer_t *timer ;
  void *tmp ;

  {
  {
#line 680
  tmp = malloc(sizeof(*timer));
#line 680
  timer = (sel_timer_t *)tmp;
  }
#line 681
  if (! timer) {
#line 682
    return (12);
  }
#line 684
  timer->handler = handler;
#line 685
  timer->user_data = user_data;
#line 686
  timer->in_heap = 0;
#line 687
  timer->sel = sel;
#line 688
  *new_timer = timer;
#line 690
  return (0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
int sel_free_timer(sel_timer_t *timer ) 
{ 


  {
#line 696
  if (timer->in_heap) {
    {
#line 697
    sel_stop_timer(timer);
    }
  }
  {
#line 699
  free((void *)timer);
  }
#line 701
  return (0);
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
int sel_start_timer(sel_timer_t *timer , struct timeval *timeout ) 
{ 


  {
#line 708
  if (timer->in_heap) {
#line 709
    return (16);
  }
  {
#line 711
  timer->timeout = *timeout;
#line 712
  add_to_heap(& (timer->sel)->timer_top, & (timer->sel)->timer_last, timer);
#line 713
  timer->in_heap = 1;
  }
#line 714
  return (0);
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
int sel_stop_timer(sel_timer_t *timer ) 
{ 


  {
#line 720
  if (! timer->in_heap) {
#line 721
    return (110);
  }
  {
#line 723
  remove_from_heap(& (timer->sel)->timer_top, & (timer->sel)->timer_last, timer);
#line 726
  timer->in_heap = 0;
  }
#line 727
  return (0);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
void sel_select_once(selector_t *sel ) 
{ 
  fd_set tmp_read_set ;
  fd_set tmp_write_set ;
  fd_set tmp_except_set ;
  int i ;
  int err ;
  sel_timer_t *timer ;
  struct timeval timeout ;
  struct timeval *to_time ;
  struct timeval now ;
  int tmp ;
  int *tmp___0 ;

  {
#line 741
  if (sel->timer_top) {
    {
#line 745
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 746
    timer = sel->timer_top;
    }
    {
#line 747
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 747
      tmp = cmp_timeval(& now, & timer->timeout);
      }
#line 747
      if (! (tmp >= 0)) {
#line 747
        goto while_break;
      }
      {
#line 748
      remove_from_heap(& sel->timer_top, & sel->timer_last, timer);
#line 752
      timer->in_heap = 0;
#line 753
      (*(timer->handler))(sel, timer, timer->user_data);
#line 755
      timer = sel->timer_top;
#line 756
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
      }
#line 757
      if (! timer) {
#line 758
        goto no_timers;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 762
    diff_timeval(& timeout, & (sel->timer_top)->timeout, & now);
#line 763
    to_time = & timeout;
    }
  } else {
    no_timers: 
#line 766
    to_time = (struct timeval *)((void *)0);
  }
  {
#line 768
  memcpy((void */* __restrict  */)(& tmp_read_set), (void const   */* __restrict  */)(& sel->read_set),
         sizeof(tmp_read_set));
#line 769
  memcpy((void */* __restrict  */)(& tmp_write_set), (void const   */* __restrict  */)(& sel->write_set),
         sizeof(tmp_write_set));
#line 770
  memcpy((void */* __restrict  */)(& tmp_except_set), (void const   */* __restrict  */)(& sel->except_set),
         sizeof(tmp_except_set));
#line 771
  err = select(sel->maxfd + 1, (fd_set */* __restrict  */)(& tmp_read_set), (fd_set */* __restrict  */)(& tmp_write_set),
               (fd_set */* __restrict  */)(& tmp_except_set), (struct timeval */* __restrict  */)to_time);
  }
#line 776
  if (! (err == 0)) {
#line 778
    if (err < 0) {
      {
#line 780
      tmp___0 = __errno_location();
      }
#line 780
      if (*tmp___0 == 4) {
#line 782
        timeout.tv_sec = (__time_t )1;
#line 783
        timeout.tv_usec = (__suseconds_t )0;
      } else {
        {
#line 786
        syslog(3, "select_loop() - select: %m");
#line 787
        exit(1);
        }
      }
    } else {
#line 791
      i = 0;
      {
#line 791
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 791
        if (! (i <= sel->maxfd)) {
#line 791
          goto while_break___0;
        }
#line 792
        if ((tmp_read_set.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 793
          if ((unsigned long )sel->fds[i].handle_read == (unsigned long )((void *)0)) {
            {
#line 796
            sel_set_fd_read_handler(sel, i, 1);
            }
          } else {
            {
#line 798
            (*(sel->fds[i].handle_read))(i, sel->fds[i].data);
            }
          }
        }
#line 801
        if ((tmp_write_set.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 802
          if ((unsigned long )sel->fds[i].handle_write == (unsigned long )((void *)0)) {
            {
#line 805
            sel_set_fd_write_handler(sel, i, 1);
            }
          } else {
            {
#line 807
            (*(sel->fds[i].handle_write))(i, sel->fds[i].data);
            }
          }
        }
#line 810
        if ((tmp_except_set.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 811
          if ((unsigned long )sel->fds[i].handle_except == (unsigned long )((void *)0)) {
            {
#line 814
            sel_set_fd_except_handler(sel, i, 1);
            }
          } else {
            {
#line 816
            (*(sel->fds[i].handle_except))(i, sel->fds[i].data);
            }
          }
        }
#line 791
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 822
  if (got_sighup) {
#line 823
    got_sighup = 0;
#line 824
    if ((unsigned long )user_sighup_handler != (unsigned long )((void *)0)) {
      {
#line 825
      (*user_sighup_handler)();
      }
    }
  }
#line 828
  if (got_sigint) {
#line 829
    got_sigint = 0;
#line 830
    if ((unsigned long )user_sigint_handler != (unsigned long )((void *)0)) {
      {
#line 831
      (*user_sigint_handler)();
      }
    }
  }
#line 834
  return;
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
void sel_select_loop(selector_t *sel ) 
{ 


  {
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 843
    sel_select_once(sel);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
int sel_alloc_selector(selector_t **new_selector ) 
{ 
  selector_t *sel ;
  int i ;
  void *tmp ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;

  {
  {
#line 853
  tmp = malloc(sizeof(*sel));
#line 853
  sel = (selector_t *)tmp;
  }
#line 854
  if (! sel) {
#line 855
    return (12);
  }
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& sel->read_set.__fds_bits[0]): "memory");
#line 857
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 858
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 858
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& sel->write_set.__fds_bits[0]): "memory");
#line 858
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 859
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 859
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& sel->except_set.__fds_bits[0]): "memory");
#line 859
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 861
  i = 0;
  {
#line 861
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 861
    if (! (i < 1024)) {
#line 861
      goto while_break___2;
    }
    {
#line 862
    init_fd(& sel->fds[i]);
#line 861
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 865
  sel->maxfd = 0;
#line 866
  sel->timer_top = (sel_timer_t *)((void *)0);
#line 867
  sel->timer_last = (sel_timer_t *)((void *)0);
#line 869
  *new_selector = sel;
#line 871
  return (0);
}
}
#line 874 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void free_heap_element(sel_timer_t *elem ) 
{ 


  {
#line 877
  if (! elem) {
#line 878
    return;
  }
  {
#line 880
  free_heap_element(elem->left);
#line 881
  free_heap_element(elem->right);
#line 882
  free((void *)elem);
  }
#line 883
  return;
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
int sel_free_selector(selector_t *sel ) 
{ 
  sel_timer_t *heap ;

  {
  {
#line 890
  heap = sel->timer_top;
#line 892
  free((void *)sel);
#line 893
  free_heap_element(heap);
  }
#line 895
  return (0);
}
}
#line 898 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
void set_signal_handler(int sig , void (*handler)(void) ) 
{ 


  {
#line 901
  if (sig == 1) {
#line 902
    user_sighup_handler = handler;
  } else
#line 903
  if (sig == 2) {
#line 904
    user_sigint_handler = handler;
  }
#line 905
  return;
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void sighup_handler(int sig ) 
{ 


  {
#line 910
  got_sighup = 1;
#line 911
  return;
}
}
#line 913 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
static void sigint_handler(int sig ) 
{ 


  {
#line 915
  got_sigint = 1;
#line 916
  return;
}
}
#line 918 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/selector.c"
void setup_signals(void) 
{ 
  struct sigaction act ;
  int err ;

  {
  {
#line 924
  act.__sigaction_handler.sa_handler = & sighup_handler;
#line 925
  sigemptyset(& act.sa_mask);
#line 926
  act.sa_flags = 268435456;
#line 927
  err = sigaction(1, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 928
  if (err) {
    {
#line 929
    perror("sigaction");
    }
  }
  {
#line 932
  act.__sigaction_handler.sa_handler = & sigint_handler;
#line 934
  act.sa_flags = (int )((unsigned int )act.sa_flags | 2147483648U);
#line 935
  err = sigaction(2, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 936
  if (err) {
    {
#line 937
    perror("sigaction");
    }
  }
#line 939
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/buffer.c"
int buffer_write(int fd , struct sbuf *buf___1 , int *buferr ) 
{ 
  ssize_t write_count ;
  int towrite1 ;
  int towrite2 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 30
  towrite2 = 0;
#line 32
  if (buf___1->pos + buf___1->cursize > buf___1->maxsize) {
#line 33
    towrite1 = (int )(buf___1->maxsize - buf___1->pos);
#line 34
    towrite2 = (int )(buf___1->cursize - (unsigned int )towrite1);
  } else {
#line 36
    towrite1 = (int )buf___1->cursize;
  }
#line 38
  if (towrite1 > 0) {
    {
#line 39
    write_count = write(fd, (void const   *)(buf___1->buf + buf___1->pos), (size_t )towrite1);
    }
#line 40
    if (write_count == -1L) {
      {
#line 41
      tmp___1 = __errno_location();
      }
#line 41
      if (*tmp___1 == 4) {
#line 43
        return (0);
      } else {
        {
#line 44
        tmp___0 = __errno_location();
        }
#line 44
        if (*tmp___0 == 11) {
#line 46
          return (0);
        } else {
          {
#line 48
          tmp = __errno_location();
#line 48
          *buferr = *tmp;
          }
#line 49
          return (-1);
        }
      }
    }
#line 52
    buf___1->pos = (unsigned int )((ssize_t )buf___1->pos + write_count);
#line 53
    buf___1->cursize = (unsigned int )((ssize_t )buf___1->cursize - write_count);
  }
#line 56
  if (towrite2 > 0) {
    {
#line 58
    buf___1->pos = 0U;
#line 59
    write_count = write(fd, (void const   *)(buf___1->buf + buf___1->pos), (size_t )towrite2);
    }
#line 60
    if (write_count == -1L) {
      {
#line 61
      tmp___4 = __errno_location();
      }
#line 61
      if (*tmp___4 == 4) {
#line 63
        return (0);
      } else {
        {
#line 64
        tmp___3 = __errno_location();
        }
#line 64
        if (*tmp___3 == 11) {
#line 66
          return (0);
        } else {
          {
#line 68
          tmp___2 = __errno_location();
#line 68
          *buferr = *tmp___2;
          }
#line 69
          return (-1);
        }
      }
    }
#line 72
    buf___1->pos = (unsigned int )((ssize_t )buf___1->pos + write_count);
#line 73
    buf___1->cursize = (unsigned int )((ssize_t )buf___1->cursize - write_count);
  }
#line 76
  return (0);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/buffer.c"
int buffer_output(struct sbuf *buf___1 , unsigned char *data , unsigned int len ) 
{ 
  int end ;
  int availend ;

  {
#line 84
  if (buf___1->maxsize - buf___1->cursize < len) {
#line 85
    return (-1);
  }
#line 87
  end = (int )(buf___1->pos + buf___1->cursize);
#line 88
  if ((unsigned int )end > buf___1->maxsize) {
#line 89
    end = (int )((unsigned int )end - buf___1->maxsize);
  }
#line 90
  if ((unsigned int )end + len > buf___1->maxsize) {
    {
#line 91
    availend = (int )(buf___1->maxsize - (unsigned int )end);
#line 92
    memcpy((void */* __restrict  */)(buf___1->buf + end), (void const   */* __restrict  */)data,
           (size_t )availend);
#line 93
    buf___1->cursize += (unsigned int )availend;
#line 94
    end = 0;
#line 95
    len -= (unsigned int )availend;
#line 96
    data += availend;
    }
  }
  {
#line 98
  memcpy((void */* __restrict  */)(buf___1->buf + end), (void const   */* __restrict  */)data,
         (size_t )len);
#line 99
  buf___1->cursize += len;
  }
#line 100
  return (0);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/buffer.c"
int buffer_outchar(struct sbuf *buf___1 , unsigned char data ) 
{ 
  int end ;

  {
#line 108
  if (buf___1->maxsize - buf___1->cursize < 1U) {
#line 109
    return (-1);
  }
#line 111
  end = (int )(buf___1->pos + buf___1->cursize);
#line 112
  if ((unsigned int )end >= buf___1->maxsize) {
#line 113
    end = (int )((unsigned int )end - buf___1->maxsize);
  }
#line 114
  *(buf___1->buf + end) = data;
#line 115
  (buf___1->cursize) ++;
#line 116
  return (0);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/buffer.c"
void buffer_init(struct sbuf *buf___1 , unsigned char *data , unsigned int datasize ) 
{ 


  {
#line 122
  buf___1->buf = data;
#line 123
  buf___1->maxsize = datasize;
#line 124
  buf___1->cursize = 0U;
#line 125
  buf___1->pos = 0U;
#line 126
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.h"
char *portconfig(char *portnum , char *state , char *timeout , char *devname , char *devcfg ,
                 int config_num___0 ) ;
#line 42
void clear_old_port_config(int curr_config ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.h"
void handle_config_line(char *inbuf ) ;
#line 28
int readconfig(char *filename ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.h"
char *find_str(char *name , enum str_type *type ) ;
#line 41
char *find_tracefile(char *name ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
char *config_port ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static int config_num  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static int lineno  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static struct longstr_s *working_longstr  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static int working_longstr_continued  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static int working_longstr_len  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
struct longstr_s *longstrs  =    (struct longstr_s *)((void *)0);
#line 57 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static void finish_longstr(void) 
{ 


  {
#line 60
  if (! working_longstr) {
#line 62
    goto out;
  }
#line 65
  *(working_longstr->str + working_longstr_len) = (char )'\000';
#line 67
  working_longstr->next = longstrs;
#line 68
  longstrs = working_longstr;
#line 69
  working_longstr = (struct longstr_s *)((void *)0);
  out: 
#line 72
  working_longstr_len = 0;
#line 73
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static void handle_longstr(char *name , char *line , enum str_type type ) 
{ 
  int line_len ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 82
  if (! line) {
#line 83
    line = (char *)"";
  }
  {
#line 85
  tmp = strlen((char const   *)line);
#line 85
  line_len = (int )tmp;
  }
#line 87
  if (line_len > 0) {
#line 87
    if ((int )*(line + (line_len - 1)) == 92) {
#line 87
      tmp___0 = 1;
    } else {
#line 87
      tmp___0 = 0;
    }
  } else {
#line 87
    tmp___0 = 0;
  }
  {
#line 87
  working_longstr_continued = tmp___0;
#line 89
  tmp___1 = malloc(sizeof(*working_longstr));
#line 89
  working_longstr = (struct longstr_s *)tmp___1;
  }
#line 90
  if (! working_longstr) {
    {
#line 91
    syslog(3, "Out of memory handling string on %d", lineno);
    }
#line 92
    return;
  }
  {
#line 94
  working_longstr->type = type;
#line 96
  working_longstr->name = strdup((char const   *)name);
  }
#line 97
  if (! working_longstr->name) {
    {
#line 98
    free((void *)working_longstr);
#line 99
    working_longstr = (struct longstr_s *)((void *)0);
#line 100
    syslog(3, "Out of memory handling longstr on %d", lineno);
    }
#line 101
    return;
  }
#line 104
  if (working_longstr_continued) {
#line 105
    line_len --;
  }
  {
#line 108
  tmp___2 = malloc((size_t )(line_len + ! working_longstr_continued));
#line 108
  working_longstr->str = (char *)tmp___2;
  }
#line 109
  if (! working_longstr->str) {
    {
#line 110
    free((void *)working_longstr->name);
#line 111
    free((void *)working_longstr);
#line 112
    working_longstr = (struct longstr_s *)((void *)0);
#line 113
    syslog(3, "Out of memory handling longstr on %d", lineno);
    }
#line 114
    return;
  }
  {
#line 117
  memcpy((void */* __restrict  */)working_longstr->str, (void const   */* __restrict  */)line,
         (size_t )line_len);
#line 118
  working_longstr_len = line_len;
  }
#line 120
  if (! working_longstr_continued) {
    {
#line 121
    finish_longstr();
    }
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static void handle_continued_longstr(char *line ) 
{ 
  int line_len ;
  size_t tmp ;
  char *newstr ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 127
  tmp = strlen((char const   *)line);
#line 127
  line_len = (int )tmp;
  }
#line 130
  if (line_len > 0) {
#line 130
    if ((int )*(line + (line_len - 1)) == 92) {
#line 130
      tmp___0 = 1;
    } else {
#line 130
      tmp___0 = 0;
    }
  } else {
#line 130
    tmp___0 = 0;
  }
#line 130
  working_longstr_continued = tmp___0;
#line 132
  if (! working_longstr) {
#line 134
    goto out;
  }
#line 136
  if (working_longstr_continued) {
#line 137
    line_len --;
  }
  {
#line 140
  tmp___1 = realloc((void *)working_longstr->str, (size_t )((working_longstr_len + line_len) + ! working_longstr_continued));
#line 140
  newstr = (char *)tmp___1;
  }
#line 142
  if (! newstr) {
    {
#line 143
    free((void *)working_longstr->str);
#line 144
    free((void *)working_longstr->name);
#line 145
    free((void *)working_longstr);
#line 146
    working_longstr = (struct longstr_s *)((void *)0);
#line 147
    syslog(3, "Out of memory handling longstr on %d", lineno);
    }
#line 148
    goto out;
  }
  {
#line 150
  working_longstr->str = newstr;
#line 151
  memcpy((void */* __restrict  */)(working_longstr->str + working_longstr_len), (void const   */* __restrict  */)line,
         (size_t )line_len);
#line 152
  working_longstr_len += line_len;
  }
  out: 
#line 155
  if (! working_longstr_continued) {
    {
#line 156
    finish_longstr();
    }
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
char *find_str(char *name , enum str_type *type ) 
{ 
  struct longstr_s *longstr ;
  int tmp ;

  {
#line 162
  longstr = longstrs;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! longstr) {
#line 164
      goto while_break;
    }
    {
#line 165
    tmp = strcmp((char const   *)name, (char const   *)longstr->name);
    }
#line 165
    if (tmp == 0) {
#line 166
      *type = longstr->type;
#line 167
      return (longstr->str);
    }
#line 169
    longstr = longstr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return ((char *)((void *)0));
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static void free_longstrs(void) 
{ 
  struct longstr_s *longstr ;

  {
#line 179
  if (working_longstr) {
#line 180
    if (working_longstr->name) {
      {
#line 181
      free((void *)working_longstr->name);
      }
    }
#line 182
    if (working_longstr->str) {
      {
#line 183
      free((void *)working_longstr->str);
      }
    }
    {
#line 184
    free((void *)working_longstr);
#line 185
    working_longstr = (struct longstr_s *)((void *)0);
    }
  }
#line 187
  working_longstr_len = 0;
#line 188
  working_longstr_continued = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! longstrs) {
#line 190
      goto while_break;
    }
    {
#line 191
    longstr = longstrs;
#line 192
    longstrs = longstrs->next;
#line 193
    free((void *)longstr->name);
#line 194
    free((void *)longstr->str);
#line 195
    free((void *)longstr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
struct tracefile_s *tracefiles  =    (struct tracefile_s *)((void *)0);
#line 209 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static void handle_tracefile(char *name , char *fname ) 
{ 
  struct tracefile_s *new_tracefile ;
  void *tmp ;

  {
  {
#line 214
  tmp = malloc(sizeof(*new_tracefile));
#line 214
  new_tracefile = (struct tracefile_s *)tmp;
  }
#line 215
  if (! new_tracefile) {
    {
#line 216
    syslog(3, "Out of memory handling tracefile on %d", lineno);
    }
#line 217
    return;
  }
  {
#line 220
  new_tracefile->name = strdup((char const   *)name);
  }
#line 221
  if (! new_tracefile->name) {
    {
#line 222
    syslog(3, "Out of memory handling tracefile on %d", lineno);
#line 223
    free((void *)new_tracefile);
    }
#line 224
    return;
  }
  {
#line 227
  new_tracefile->str = strdup((char const   *)fname);
  }
#line 228
  if (! new_tracefile->str) {
    {
#line 229
    syslog(3, "Out of memory handling tracefile on %d", lineno);
#line 230
    free((void *)new_tracefile->name);
#line 231
    free((void *)new_tracefile);
    }
#line 232
    return;
  }
#line 235
  new_tracefile->next = tracefiles;
#line 236
  tracefiles = new_tracefile;
#line 237
  return;
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
char *find_tracefile(char *name ) 
{ 
  struct tracefile_s *tracefile ;
  int tmp ;

  {
#line 242
  tracefile = tracefiles;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! tracefile) {
#line 244
      goto while_break;
    }
    {
#line 245
    tmp = strcmp((char const   *)name, (char const   *)tracefile->name);
    }
#line 245
    if (tmp == 0) {
#line 246
      return (tracefile->str);
    }
#line 247
    tracefile = tracefile->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  syslog(3, "Tracefile %s not found, it will be ignored", name);
  }
#line 250
  return ((char *)((void *)0));
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
static void free_tracefiles(void) 
{ 
  struct tracefile_s *tracefile ;

  {
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! tracefiles) {
#line 258
      goto while_break;
    }
    {
#line 259
    tracefile = tracefiles;
#line 260
    tracefiles = tracefiles->next;
#line 261
    free((void *)tracefile->name);
#line 262
    free((void *)tracefile->str);
#line 263
    free((void *)tracefile);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
void handle_config_line(char *inbuf ) 
{ 
  char *portnum ;
  char *state ;
  char *timeout ;
  char *devname ;
  char *devcfg ;
  char *strtok_data ;
  char *errstr ;
  char *str ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *name ;
  char *tmp___2 ;
  char *str___0 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *name___0 ;
  char *tmp___5 ;
  char *str___1 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *name___1 ;
  char *tmp___8 ;
  char *str___2 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *name___2 ;
  char *tmp___11 ;
  char *str___3 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *name___3 ;
  char *tmp___14 ;
  char *str___4 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;

  {
#line 272
  strtok_data = (char *)((void *)0);
#line 275
  lineno ++;
#line 277
  if (working_longstr_continued) {
    {
#line 278
    tmp = strtok_r((char */* __restrict  */)inbuf, (char const   */* __restrict  */)"\n",
                   (char **/* __restrict  */)(& strtok_data));
#line 278
    str = tmp;
    }
#line 279
    if (! str) {
#line 280
      str = (char *)"";
    }
    {
#line 281
    handle_continued_longstr(str);
    }
#line 282
    return;
  }
#line 285
  if ((int )*(inbuf + 0) == 35) {
#line 287
    return;
  }
  {
#line 290
  portnum = strtok_r((char */* __restrict  */)inbuf, (char const   */* __restrict  */)":",
                     (char **/* __restrict  */)(& strtok_data));
  }
#line 291
  if ((unsigned long )portnum == (unsigned long )((void *)0)) {
#line 293
    return;
  }
  {
#line 296
  tmp___1 = strcmp((char const   *)portnum, "CONTROLPORT");
  }
#line 296
  if (tmp___1 == 0) {
#line 297
    if (config_port) {
#line 302
      return;
    }
    {
#line 303
    tmp___0 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n",
                       (char **/* __restrict  */)(& strtok_data));
#line 303
    config_port = strdup((char const   *)tmp___0);
    }
#line 304
    if (! config_port) {
      {
#line 305
      syslog(3, "Could not allocate memory for CONTROLPORT");
      }
#line 306
      return;
    }
#line 308
    return;
  }
  {
#line 311
  tmp___4 = strcmp((char const   *)portnum, "BANNER");
  }
#line 311
  if (tmp___4 == 0) {
    {
#line 312
    tmp___2 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                       (char **/* __restrict  */)(& strtok_data));
#line 312
    name = tmp___2;
#line 313
    tmp___3 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n",
                       (char **/* __restrict  */)(& strtok_data));
#line 313
    str___0 = tmp___3;
    }
#line 314
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 315
      syslog(3, "No banner name given on line %d", lineno);
      }
#line 316
      return;
    }
    {
#line 318
    handle_longstr(name, str___0, (enum str_type )0);
    }
#line 319
    return;
  }
  {
#line 322
  tmp___7 = strcmp((char const   *)portnum, "SIGNATURE");
  }
#line 322
  if (tmp___7 == 0) {
    {
#line 323
    tmp___5 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                       (char **/* __restrict  */)(& strtok_data));
#line 323
    name___0 = tmp___5;
#line 324
    tmp___6 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n",
                       (char **/* __restrict  */)(& strtok_data));
#line 324
    str___1 = tmp___6;
    }
#line 325
    if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
      {
#line 326
      syslog(3, "No signature given on line %d", lineno);
      }
#line 327
      return;
    }
    {
#line 329
    handle_longstr(name___0, str___1, (enum str_type )3);
    }
#line 330
    return;
  }
  {
#line 333
  tmp___10 = strcmp((char const   *)portnum, "OPENSTR");
  }
#line 333
  if (tmp___10 == 0) {
    {
#line 334
    tmp___8 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                       (char **/* __restrict  */)(& strtok_data));
#line 334
    name___1 = tmp___8;
#line 335
    tmp___9 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n",
                       (char **/* __restrict  */)(& strtok_data));
#line 335
    str___2 = tmp___9;
    }
#line 336
    if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
      {
#line 337
      syslog(3, "No open string name given on line %d", lineno);
      }
#line 338
      return;
    }
    {
#line 340
    handle_longstr(name___1, str___2, (enum str_type )1);
    }
#line 341
    return;
  }
  {
#line 344
  tmp___13 = strcmp((char const   *)portnum, "CLOSESTR");
  }
#line 344
  if (tmp___13 == 0) {
    {
#line 345
    tmp___11 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                        (char **/* __restrict  */)(& strtok_data));
#line 345
    name___2 = tmp___11;
#line 346
    tmp___12 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n",
                        (char **/* __restrict  */)(& strtok_data));
#line 346
    str___3 = tmp___12;
    }
#line 347
    if ((unsigned long )name___2 == (unsigned long )((void *)0)) {
      {
#line 348
      syslog(3, "No close string name given on line %d", lineno);
      }
#line 349
      return;
    }
    {
#line 351
    handle_longstr(name___2, str___3, (enum str_type )2);
    }
#line 352
    return;
  }
  {
#line 355
  tmp___17 = strcmp((char const   *)portnum, "TRACEFILE");
  }
#line 355
  if (tmp___17 == 0) {
    {
#line 356
    tmp___14 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                        (char **/* __restrict  */)(& strtok_data));
#line 356
    name___3 = tmp___14;
#line 357
    tmp___15 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n",
                        (char **/* __restrict  */)(& strtok_data));
#line 357
    str___4 = tmp___15;
    }
#line 358
    if ((unsigned long )name___3 == (unsigned long )((void *)0)) {
      {
#line 359
      syslog(3, "No tracefile name given on line %d", lineno);
      }
#line 360
      return;
    }
#line 362
    if ((unsigned long )str___4 == (unsigned long )((void *)0)) {
      {
#line 363
      syslog(3, "No tracefile given on line %d", lineno);
      }
#line 364
      return;
    } else {
      {
#line 362
      tmp___16 = strlen((char const   *)str___4);
      }
#line 362
      if (tmp___16 == 0UL) {
        {
#line 363
        syslog(3, "No tracefile given on line %d", lineno);
        }
#line 364
        return;
      }
    }
    {
#line 366
    handle_tracefile(name___3, str___4);
    }
#line 367
    return;
  }
  {
#line 370
  state = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                   (char **/* __restrict  */)(& strtok_data));
  }
#line 371
  if ((unsigned long )state == (unsigned long )((void *)0)) {
    {
#line 372
    syslog(3, "No state given on line %d", lineno);
    }
#line 373
    return;
  }
  {
#line 376
  timeout = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                     (char **/* __restrict  */)(& strtok_data));
  }
#line 377
  if ((unsigned long )timeout == (unsigned long )((void *)0)) {
    {
#line 378
    syslog(3, "No timeout given on line %d", lineno);
    }
#line 379
    return;
  }
  {
#line 382
  devname = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                     (char **/* __restrict  */)(& strtok_data));
  }
#line 383
  if ((unsigned long )devname == (unsigned long )((void *)0)) {
    {
#line 384
    syslog(3, "No device name given on line %d", lineno);
    }
#line 385
    return;
  }
  {
#line 388
  devcfg = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                    (char **/* __restrict  */)(& strtok_data));
  }
#line 389
  if ((unsigned long )devcfg == (unsigned long )((void *)0)) {
#line 391
    devcfg = (char *)"";
  }
  {
#line 394
  errstr = portconfig(portnum, state, timeout, devname, devcfg, config_num);
  }
#line 396
  if ((unsigned long )errstr != (unsigned long )((void *)0)) {
    {
#line 397
    syslog(3, "Error on line %d, %s", lineno, errstr);
    }
  }
#line 399
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/readconfig.c"
int readconfig(char *filename ) 
{ 
  FILE *instream ;
  char inbuf[256] ;
  int rv ;
  int len ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 408
  rv = 0;
#line 410
  lineno = 0;
#line 412
  instream = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 413
  if ((unsigned long )instream == (unsigned long )((void *)0)) {
    {
#line 414
    syslog(3, "Unable to open config file \'%s\': %m", filename);
    }
#line 415
    return (-1);
  }
  {
#line 418
  free_longstrs();
#line 419
  free_tracefiles();
#line 421
  config_num ++;
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 423
    tmp___0 = fgets((char */* __restrict  */)(inbuf), 256, (FILE */* __restrict  */)instream);
    }
#line 423
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 423
      goto while_break;
    }
    {
#line 424
    tmp = strlen((char const   *)(inbuf));
#line 424
    len = (int )tmp;
    }
#line 425
    if ((int )inbuf[len - 1] != 10) {
      {
#line 426
      lineno ++;
#line 427
      syslog(3, "line %d is too long in config file", lineno);
      }
#line 428
      goto while_continue;
    }
    {
#line 431
    inbuf[len - 1] = (char )'\000';
#line 432
    handle_config_line(inbuf);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 436
  clear_old_port_config(config_num);
#line 438
  fclose(instream);
  }
#line 439
  return (rv);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.h"
int uucp_locking_enabled ;
#line 38
void shutdown_ports(void) ;
#line 39
int check_ports_shutdown(void) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
static char *config_file  =    (char *)"/etc/ser2net.conf";
#line 44 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
int config_port_from_cmdline  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
char *config_port  =    (char *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
static char *pid_file  =    (char *)((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
static int detach  =    1;
#line 48 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
static int debug  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
int uucp_locking_enabled  =    1;
#line 52 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
int cisco_ios_baud_rates  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
selector_t *ser2net_sel  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
char *rfc2217_signature  =    (char *)"ser2net";
#line 57 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
static char *help_string  =    (char *)"%s: Valid parameters are:\n  -c <config file> - use a config file besides /etc/ser2net.conf\n  -C <config line> - Handle a single configuration line.  This may be\n     specified multiple times for multiple lines.  This is just like a\n     line in the config file.  This disables the default config file,\n     you must specify a -c after the last -C to have it read a config\n     file, too.\n  -p <controller port> - Start a controller session on the given TCP port\n  -P <file> - set location of pid file\n  -n - Don\'t detach from the controlling terminal\n  -d - Don\'t detach and send debug I/O to standard output\n  -u - Disable UUCP locking\n  -b - Do CISCO IOS baud-rate negotiation, instead of RFC2217\n  -v - print the program\'s version and exit\n  -s - specify a default signature for RFC2217 protocol\n";
#line 76 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
void reread_config(void) 
{ 
  char *prev_config_port ;
  int tmp ;
  int rv ;
  int tmp___0 ;

  {
#line 79
  if (config_file) {
    {
#line 80
    prev_config_port = config_port;
#line 81
    config_port = (char *)((void *)0);
#line 82
    syslog(6, "Got SIGHUP, re-reading configuration");
#line 83
    readconfig(config_file);
    }
#line 84
    if (config_port_from_cmdline) {
      {
#line 86
      free((void *)config_port);
#line 87
      config_port = prev_config_port;
      }
#line 88
      goto config_port_unchanged;
    }
#line 90
    if (config_port) {
#line 90
      if (prev_config_port) {
        {
#line 90
        tmp = strcmp((char const   *)config_port, (char const   *)prev_config_port);
        }
#line 90
        if (tmp == 0) {
          {
#line 92
          free((void *)prev_config_port);
          }
#line 93
          goto config_port_unchanged;
        }
      }
    }
#line 96
    if (prev_config_port) {
      {
#line 97
      controller_shutdown();
#line 98
      free((void *)prev_config_port);
      }
    }
#line 101
    if (config_port) {
      {
#line 102
      tmp___0 = controller_init(config_port);
#line 102
      rv = tmp___0;
      }
#line 103
      if (rv == -1) {
        {
#line 104
        syslog(3, "Invalid control port specified: %s", config_port);
        }
      }
#line 106
      if (rv) {
        {
#line 107
        syslog(3, "Control port is disabled");
#line 108
        free((void *)config_port);
#line 109
        config_port = (char *)((void *)0);
        }
      }
    }
  }
  config_port_unchanged: 
#line 114
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
void arg_error(char *name ) 
{ 


  {
  {
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)help_string,
          name);
#line 121
  exit(1);
  }
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
void make_pidfile(char *pidfile ) 
{ 
  FILE *fpidfile ;
  __pid_t tmp ;

  {
#line 128
  if (! pidfile) {
#line 129
    return;
  }
  {
#line 130
  fpidfile = fopen((char const   */* __restrict  */)pidfile, (char const   */* __restrict  */)"w");
  }
#line 131
  if (! fpidfile) {
    {
#line 132
    syslog(4, "Error opening pidfile \'%s\': %m, pidfile not created", pidfile);
    }
#line 135
    return;
  }
  {
#line 137
  tmp = getpid();
#line 137
  fprintf((FILE */* __restrict  */)fpidfile, (char const   */* __restrict  */)"%d\n",
          tmp);
#line 138
  fclose(fpidfile);
  }
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
void shutdown_cleanly(void) 
{ 
  int tmp ;

  {
  {
#line 144
  shutdown_ports();
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 146
    tmp = check_ports_shutdown();
    }
#line 146
    if (tmp) {
      {
#line 147
      exit(1);
      }
    }
    {
#line 148
    sel_select_once(ser2net_sel);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/ser2net.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int err ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int rv ;
  int pid ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 158
  err = sel_alloc_selector(& ser2net_sel);
  }
#line 159
  if (err) {
    {
#line 160
    tmp = strerror(err);
#line 160
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not initialize ser2net selector: \'%s\'\n",
            tmp);
    }
#line 163
    return (-1);
  }
#line 166
  i = 1;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i < argc)) {
#line 166
      goto while_break;
    }
#line 167
    if ((int )*(*(argv + i) + 0) != 45) {
      {
#line 168
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid argument: \'%s\'\n",
              *(argv + i));
#line 169
      arg_error(*(argv + 0));
      }
    } else {
      {
#line 167
      tmp___0 = strlen((char const   *)*(argv + i));
      }
#line 167
      if (tmp___0 != 2UL) {
        {
#line 168
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid argument: \'%s\'\n",
                *(argv + i));
#line 169
        arg_error(*(argv + 0));
        }
      }
    }
    {
#line 173
    if ((int )*(*(argv + i) + 1) == 110) {
#line 173
      goto case_110;
    }
#line 177
    if ((int )*(*(argv + i) + 1) == 100) {
#line 177
      goto case_100;
    }
#line 182
    if ((int )*(*(argv + i) + 1) == 98) {
#line 182
      goto case_98;
    }
#line 186
    if ((int )*(*(argv + i) + 1) == 67) {
#line 186
      goto case_67;
    }
#line 197
    if ((int )*(*(argv + i) + 1) == 99) {
#line 197
      goto case_99;
    }
#line 207
    if ((int )*(*(argv + i) + 1) == 112) {
#line 207
      goto case_112;
    }
#line 222
    if ((int )*(*(argv + i) + 1) == 80) {
#line 222
      goto case_80;
    }
#line 232
    if ((int )*(*(argv + i) + 1) == 117) {
#line 232
      goto case_117;
    }
#line 237
    if ((int )*(*(argv + i) + 1) == 118) {
#line 237
      goto case_118;
    }
#line 241
    if ((int )*(*(argv + i) + 1) == 115) {
#line 241
      goto case_115;
    }
#line 250
    goto switch_default;
    case_110: /* CIL Label */ 
#line 174
    detach = 0;
#line 175
    goto switch_break;
    case_100: /* CIL Label */ 
#line 178
    detach = 0;
#line 179
    debug = 1;
#line 180
    goto switch_break;
    case_98: /* CIL Label */ 
#line 183
    cisco_ios_baud_rates = 1;
#line 184
    goto switch_break;
    case_67: /* CIL Label */ 
#line 188
    i ++;
#line 189
    if (i == argc) {
      {
#line 190
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No config line specified with -C\n");
#line 191
      arg_error(*(argv + 0));
      }
    }
    {
#line 193
    handle_config_line(*(argv + i));
#line 194
    config_file = (char *)((void *)0);
    }
#line 195
    goto switch_break;
    case_99: /* CIL Label */ 
#line 199
    i ++;
#line 200
    if (i == argc) {
      {
#line 201
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No config file specified with -c\n");
#line 202
      arg_error(*(argv + 0));
      }
    }
#line 204
    config_file = *(argv + i);
#line 205
    goto switch_break;
    case_112: /* CIL Label */ 
#line 209
    i ++;
#line 210
    if (i == argc) {
      {
#line 211
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No control port specified with -p\n");
#line 212
      arg_error(*(argv + 0));
      }
    }
    {
#line 214
    config_port = strdup((char const   *)*(argv + i));
    }
#line 215
    if (! config_port) {
      {
#line 216
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not allocate memory for -p\n");
#line 217
      exit(1);
      }
    }
#line 219
    config_port_from_cmdline = 1;
#line 220
    goto switch_break;
    case_80: /* CIL Label */ 
#line 223
    i ++;
#line 224
    if (i == argc) {
      {
#line 225
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No pid file specified with -P\n");
#line 226
      arg_error(*(argv + 0));
      }
    }
#line 228
    pid_file = *(argv + i);
#line 229
    goto switch_break;
    case_117: /* CIL Label */ 
#line 233
    uucp_locking_enabled = 0;
#line 234
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 238
    printf((char const   */* __restrict  */)"%s version %s\n", *(argv + 0), "2.9.1");
#line 239
    exit(0);
    }
    case_115: /* CIL Label */ 
#line 242
    i ++;
#line 243
    if (i == argc) {
      {
#line 244
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No signature specified\n");
#line 245
      exit(1);
      }
    }
#line 247
    rfc2217_signature = *(argv + i);
#line 248
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 251
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid option: \'%s\'\n",
            *(argv + i));
#line 252
    arg_error(*(argv + 0));
    }
    switch_break: /* CIL Label */ ;
    }
#line 166
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  setup_signals();
  }
#line 258
  if (debug) {
#line 258
    if (! detach) {
      {
#line 259
      openlog("ser2net", 35, 3 << 3);
      }
    }
  }
#line 261
  if (config_file) {
    {
#line 262
    tmp___1 = readconfig(config_file);
    }
#line 262
    if (tmp___1 == -1) {
#line 263
      return (1);
    }
  }
#line 267
  if ((unsigned long )config_port != (unsigned long )((void *)0)) {
    {
#line 269
    rv = controller_init(config_port);
    }
#line 270
    if (rv == -1) {
      {
#line 271
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid control port specified: %s\n",
              config_port);
#line 273
      arg_error(*(argv + 0));
      }
    }
#line 275
    if (rv == -2) {
      {
#line 276
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open control port, see syslog: %s\n",
              config_port);
#line 278
      exit(1);
      }
    }
  }
#line 282
  if (detach) {
    {
#line 286
    openlog("ser2net", 3, 3 << 3);
#line 287
    syslog(5, "ser2net startup");
#line 288
    pid = fork();
    }
#line 288
    if (pid > 0) {
      {
#line 289
      exit(0);
      }
    } else
#line 290
    if (pid < 0) {
      {
#line 291
      tmp___2 = __errno_location();
#line 291
      tmp___3 = strerror(*tmp___2);
#line 291
      syslog(3, "Error forking first fork: %s", tmp___3);
#line 292
      exit(1);
      }
    } else {
      {
#line 295
      setsid();
#line 297
      pid = fork();
      }
#line 297
      if (pid > 0) {
        {
#line 298
        exit(0);
        }
      } else
#line 299
      if (pid < 0) {
        {
#line 300
        tmp___4 = __errno_location();
#line 300
        tmp___5 = strerror(*tmp___4);
#line 300
        syslog(3, "Error forking second fork: %s", tmp___5);
#line 302
        exit(1);
        }
      }
    }
    {
#line 307
    tmp___8 = chdir("/");
    }
#line 307
    if (tmp___8 < 0) {
      {
#line 308
      tmp___6 = __errno_location();
#line 308
      tmp___7 = strerror(*tmp___6);
#line 308
      syslog(3, "unable to chdir to \'/\': %s", tmp___7);
#line 309
      exit(1);
      }
    }
    {
#line 311
    close(0);
#line 312
    close(1);
#line 313
    close(2);
    }
  }
  {
#line 317
  make_pidfile(pid_file);
#line 320
  signal(13, (void (*)(int  ))1);
#line 322
  set_signal_handler(1, & reread_config);
#line 323
  set_signal_handler(2, & shutdown_cleanly);
#line 325
  sel_select_loop(ser2net_sel);
  }
#line 327
  return (0);
}
}
#line 48 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t ( __attribute__((__leaf__)) cfgetospeed)(struct termios  const  *__termios_p ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 76
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) cfmakeraw)(struct termios *__termios_p ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.h"
void devinit(struct termios *termctl ) ;
#line 69
int devconfig(char *instr , dev_info_t *dinfo ) ;
#line 72
void show_devcfg(struct controller_info *cntlr , struct termios *termctl ) ;
#line 75
int setdevcontrol(char *instr , int fd ) ;
#line 78
void show_devcontrol(struct controller_info *cntlr , int fd ) ;
#line 81
void serparm_to_str(char *str , int strlen___0 , struct termios *termctl ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.c"
void devinit(struct termios *termctl ) 
{ 


  {
  {
#line 49
  cfmakeraw(termctl);
#line 50
  cfsetospeed(termctl, (speed_t )13);
#line 51
  cfsetispeed(termctl, (speed_t )13);
#line 52
  termctl->c_cflag &= 4294967231U;
#line 53
  termctl->c_cflag &= 4294967247U;
#line 54
  termctl->c_cflag |= 48U;
#line 55
  termctl->c_cflag &= 4294967039U;
#line 56
  termctl->c_cflag &= 4294965247U;
#line 57
  termctl->c_cflag &= 4294966271U;
#line 58
  termctl->c_cflag |= 128U;
#line 59
  termctl->c_cflag &= 2147483647U;
#line 60
  termctl->c_iflag &= 4294960127U;
#line 61
  termctl->c_iflag |= 1U;
  }
#line 62
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.c"
int devconfig(char *instr , dev_info_t *dinfo ) 
{ 
  char *str ;
  char *pos ;
  char *strtok_data ;
  int rv ;
  struct termios *termctl ;
  enum str_type stype ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;

  {
  {
#line 73
  rv = 0;
#line 74
  termctl = & dinfo->termctl;
#line 78
  str = strdup((char const   *)instr);
  }
#line 79
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 80
    return (-1);
  }
  {
#line 83
  dinfo->allow_2217 = 0;
#line 84
  dinfo->disablebreak = 0;
#line 85
  dinfo->banner = (char *)((void *)0);
#line 86
  dinfo->signature = (char *)((void *)0);
#line 87
  dinfo->openstr = (char *)((void *)0);
#line 88
  dinfo->closestr = (char *)((void *)0);
#line 89
  dinfo->trace_read.file = (char *)((void *)0);
#line 90
  dinfo->trace_read.hexdump = 0;
#line 91
  dinfo->trace_read.timestamp = 0;
#line 92
  dinfo->trace_write.file = (char *)((void *)0);
#line 93
  dinfo->trace_write.hexdump = 0;
#line 94
  dinfo->trace_write.timestamp = 0;
#line 95
  dinfo->trace_both.file = (char *)((void *)0);
#line 96
  dinfo->trace_both.hexdump = 0;
#line 97
  dinfo->trace_both.timestamp = 0;
#line 98
  pos = strtok_r((char */* __restrict  */)str, (char const   */* __restrict  */)", \t",
                 (char **/* __restrict  */)(& strtok_data));
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! ((unsigned long )pos != (unsigned long )((void *)0))) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___57 = strcmp((char const   *)pos, "300");
    }
#line 100
    if (tmp___57 == 0) {
      {
#line 101
      cfsetospeed(termctl, (speed_t )7);
#line 102
      cfsetispeed(termctl, (speed_t )7);
      }
    } else {
      {
#line 103
      tmp___56 = strcmp((char const   *)pos, "600");
      }
#line 103
      if (tmp___56 == 0) {
        {
#line 104
        cfsetospeed(termctl, (speed_t )8);
#line 105
        cfsetispeed(termctl, (speed_t )8);
        }
      } else {
        {
#line 106
        tmp___55 = strcmp((char const   *)pos, "1200");
        }
#line 106
        if (tmp___55 == 0) {
          {
#line 107
          cfsetospeed(termctl, (speed_t )9);
#line 108
          cfsetispeed(termctl, (speed_t )9);
          }
        } else {
          {
#line 109
          tmp___54 = strcmp((char const   *)pos, "2400");
          }
#line 109
          if (tmp___54 == 0) {
            {
#line 110
            cfsetospeed(termctl, (speed_t )11);
#line 111
            cfsetispeed(termctl, (speed_t )11);
            }
          } else {
            {
#line 112
            tmp___53 = strcmp((char const   *)pos, "4800");
            }
#line 112
            if (tmp___53 == 0) {
              {
#line 113
              cfsetospeed(termctl, (speed_t )12);
#line 114
              cfsetispeed(termctl, (speed_t )12);
              }
            } else {
              {
#line 115
              tmp___52 = strcmp((char const   *)pos, "9600");
              }
#line 115
              if (tmp___52 == 0) {
                {
#line 116
                cfsetospeed(termctl, (speed_t )13);
#line 117
                cfsetispeed(termctl, (speed_t )13);
                }
              } else {
                {
#line 118
                tmp___51 = strcmp((char const   *)pos, "19200");
                }
#line 118
                if (tmp___51 == 0) {
                  {
#line 119
                  cfsetospeed(termctl, (speed_t )14);
#line 120
                  cfsetispeed(termctl, (speed_t )14);
                  }
                } else {
                  {
#line 121
                  tmp___50 = strcmp((char const   *)pos, "38400");
                  }
#line 121
                  if (tmp___50 == 0) {
                    {
#line 122
                    cfsetospeed(termctl, (speed_t )15);
#line 123
                    cfsetispeed(termctl, (speed_t )15);
                    }
                  } else {
                    {
#line 124
                    tmp___49 = strcmp((char const   *)pos, "57600");
                    }
#line 124
                    if (tmp___49 == 0) {
                      {
#line 125
                      cfsetospeed(termctl, (speed_t )4097);
#line 126
                      cfsetispeed(termctl, (speed_t )4097);
                      }
                    } else {
                      {
#line 127
                      tmp___48 = strcmp((char const   *)pos, "115200");
                      }
#line 127
                      if (tmp___48 == 0) {
                        {
#line 128
                        cfsetospeed(termctl, (speed_t )4098);
#line 129
                        cfsetispeed(termctl, (speed_t )4098);
                        }
                      } else {
                        {
#line 131
                        tmp___47 = strcmp((char const   *)pos, "230400");
                        }
#line 131
                        if (tmp___47 == 0) {
                          {
#line 132
                          cfsetospeed(termctl, (speed_t )4099);
#line 133
                          cfsetispeed(termctl, (speed_t )4099);
                          }
                        } else {
                          {
#line 136
                          tmp___46 = strcmp((char const   *)pos, "460800");
                          }
#line 136
                          if (tmp___46 == 0) {
                            {
#line 137
                            cfsetospeed(termctl, (speed_t )4100);
#line 138
                            cfsetispeed(termctl, (speed_t )4100);
                            }
                          } else {
                            {
#line 141
                            tmp___45 = strcmp((char const   *)pos, "500000");
                            }
#line 141
                            if (tmp___45 == 0) {
                              {
#line 142
                              cfsetospeed(termctl, (speed_t )4101);
#line 143
                              cfsetispeed(termctl, (speed_t )4101);
                              }
                            } else {
                              {
#line 146
                              tmp___44 = strcmp((char const   *)pos, "576000");
                              }
#line 146
                              if (tmp___44 == 0) {
                                {
#line 147
                                cfsetospeed(termctl, (speed_t )4102);
#line 148
                                cfsetispeed(termctl, (speed_t )4102);
                                }
                              } else {
                                {
#line 151
                                tmp___43 = strcmp((char const   *)pos, "921600");
                                }
#line 151
                                if (tmp___43 == 0) {
                                  {
#line 152
                                  cfsetospeed(termctl, (speed_t )4103);
#line 153
                                  cfsetispeed(termctl, (speed_t )4103);
                                  }
                                } else {
                                  {
#line 156
                                  tmp___42 = strcmp((char const   *)pos, "1000000");
                                  }
#line 156
                                  if (tmp___42 == 0) {
                                    {
#line 157
                                    cfsetospeed(termctl, (speed_t )4104);
#line 158
                                    cfsetispeed(termctl, (speed_t )4104);
                                    }
                                  } else {
                                    {
#line 161
                                    tmp___41 = strcmp((char const   *)pos, "1152000");
                                    }
#line 161
                                    if (tmp___41 == 0) {
                                      {
#line 162
                                      cfsetospeed(termctl, (speed_t )4105);
#line 163
                                      cfsetispeed(termctl, (speed_t )4105);
                                      }
                                    } else {
                                      {
#line 166
                                      tmp___40 = strcmp((char const   *)pos, "1500000");
                                      }
#line 166
                                      if (tmp___40 == 0) {
                                        {
#line 167
                                        cfsetospeed(termctl, (speed_t )4106);
#line 168
                                        cfsetispeed(termctl, (speed_t )4106);
                                        }
                                      } else {
                                        {
#line 171
                                        tmp___39 = strcmp((char const   *)pos, "2000000");
                                        }
#line 171
                                        if (tmp___39 == 0) {
                                          {
#line 172
                                          cfsetospeed(termctl, (speed_t )4107);
#line 173
                                          cfsetispeed(termctl, (speed_t )4107);
                                          }
                                        } else {
                                          {
#line 176
                                          tmp___38 = strcmp((char const   *)pos, "2500000");
                                          }
#line 176
                                          if (tmp___38 == 0) {
                                            {
#line 177
                                            cfsetospeed(termctl, (speed_t )4108);
#line 178
                                            cfsetispeed(termctl, (speed_t )4108);
                                            }
                                          } else {
                                            {
#line 181
                                            tmp___37 = strcmp((char const   *)pos,
                                                              "3000000");
                                            }
#line 181
                                            if (tmp___37 == 0) {
                                              {
#line 182
                                              cfsetospeed(termctl, (speed_t )4109);
#line 183
                                              cfsetispeed(termctl, (speed_t )4109);
                                              }
                                            } else {
                                              {
#line 186
                                              tmp___36 = strcmp((char const   *)pos,
                                                                "3500000");
                                              }
#line 186
                                              if (tmp___36 == 0) {
                                                {
#line 187
                                                cfsetospeed(termctl, (speed_t )4110);
#line 188
                                                cfsetispeed(termctl, (speed_t )4110);
                                                }
                                              } else {
                                                {
#line 191
                                                tmp___35 = strcmp((char const   *)pos,
                                                                  "4000000");
                                                }
#line 191
                                                if (tmp___35 == 0) {
                                                  {
#line 192
                                                  cfsetospeed(termctl, (speed_t )4111);
#line 193
                                                  cfsetispeed(termctl, (speed_t )4111);
                                                  }
                                                } else {
                                                  {
#line 195
                                                  tmp___34 = strcmp((char const   *)pos,
                                                                    "1STOPBIT");
                                                  }
#line 195
                                                  if (tmp___34 == 0) {
#line 196
                                                    termctl->c_cflag &= 4294967231U;
                                                  } else {
                                                    {
#line 197
                                                    tmp___33 = strcmp((char const   *)pos,
                                                                      "2STOPBITS");
                                                    }
#line 197
                                                    if (tmp___33 == 0) {
#line 198
                                                      termctl->c_cflag |= 64U;
                                                    } else {
                                                      {
#line 199
                                                      tmp___32 = strcmp((char const   *)pos,
                                                                        "7DATABITS");
                                                      }
#line 199
                                                      if (tmp___32 == 0) {
#line 200
                                                        termctl->c_cflag &= 4294967247U;
#line 201
                                                        termctl->c_cflag |= 32U;
                                                      } else {
                                                        {
#line 202
                                                        tmp___31 = strcmp((char const   *)pos,
                                                                          "8DATABITS");
                                                        }
#line 202
                                                        if (tmp___31 == 0) {
#line 203
                                                          termctl->c_cflag &= 4294967247U;
#line 204
                                                          termctl->c_cflag |= 48U;
                                                        } else {
                                                          {
#line 205
                                                          tmp___30 = strcmp((char const   *)pos,
                                                                            "NONE");
                                                          }
#line 205
                                                          if (tmp___30 == 0) {
#line 206
                                                            termctl->c_cflag &= 4294967039U;
                                                          } else {
                                                            {
#line 207
                                                            tmp___29 = strcmp((char const   *)pos,
                                                                              "EVEN");
                                                            }
#line 207
                                                            if (tmp___29 == 0) {
#line 208
                                                              termctl->c_cflag |= 256U;
#line 209
                                                              termctl->c_cflag &= 4294966783U;
                                                            } else {
                                                              {
#line 210
                                                              tmp___28 = strcmp((char const   *)pos,
                                                                                "ODD");
                                                              }
#line 210
                                                              if (tmp___28 == 0) {
#line 211
                                                                termctl->c_cflag |= 768U;
                                                              } else {
                                                                {
#line 212
                                                                tmp___27 = strcmp((char const   *)pos,
                                                                                  "XONXOFF");
                                                                }
#line 212
                                                                if (tmp___27 == 0) {
#line 213
                                                                  termctl->c_iflag |= 7168U;
#line 214
                                                                  termctl->c_cc[8] = (cc_t )17;
#line 215
                                                                  termctl->c_cc[9] = (cc_t )19;
                                                                } else {
                                                                  {
#line 216
                                                                  tmp___26 = strcmp((char const   *)pos,
                                                                                    "-XONXOFF");
                                                                  }
#line 216
                                                                  if (tmp___26 == 0) {
#line 217
                                                                    termctl->c_iflag &= 4294960127U;
                                                                  } else {
                                                                    {
#line 218
                                                                    tmp___25 = strcmp((char const   *)pos,
                                                                                      "RTSCTS");
                                                                    }
#line 218
                                                                    if (tmp___25 == 0) {
#line 219
                                                                      termctl->c_cflag |= 2147483648U;
                                                                    } else {
                                                                      {
#line 220
                                                                      tmp___24 = strcmp((char const   *)pos,
                                                                                        "-RTSCTS");
                                                                      }
#line 220
                                                                      if (tmp___24 == 0) {
#line 221
                                                                        termctl->c_cflag &= 2147483647U;
                                                                      } else {
                                                                        {
#line 222
                                                                        tmp___23 = strcmp((char const   *)pos,
                                                                                          "LOCAL");
                                                                        }
#line 222
                                                                        if (tmp___23 == 0) {
#line 223
                                                                          termctl->c_cflag |= 2048U;
                                                                        } else {
                                                                          {
#line 224
                                                                          tmp___22 = strcmp((char const   *)pos,
                                                                                            "-LOCAL");
                                                                          }
#line 224
                                                                          if (tmp___22 == 0) {
#line 225
                                                                            termctl->c_cflag &= 4294965247U;
                                                                          } else {
                                                                            {
#line 226
                                                                            tmp___21 = strcmp((char const   *)pos,
                                                                                              "HANGUP_WHEN_DONE");
                                                                            }
#line 226
                                                                            if (tmp___21 == 0) {
#line 227
                                                                              termctl->c_cflag |= 1024U;
                                                                            } else {
                                                                              {
#line 228
                                                                              tmp___20 = strcmp((char const   *)pos,
                                                                                                "-HANGUP_WHEN_DONE");
                                                                              }
#line 228
                                                                              if (tmp___20 == 0) {
#line 229
                                                                                termctl->c_cflag &= 4294966271U;
                                                                              } else {
                                                                                {
#line 230
                                                                                tmp___19 = strcmp((char const   *)pos,
                                                                                                  "remctl");
                                                                                }
#line 230
                                                                                if (tmp___19 == 0) {
#line 231
                                                                                  dinfo->allow_2217 = 1;
                                                                                } else {
                                                                                  {
#line 232
                                                                                  tmp___18 = strcmp((char const   *)pos,
                                                                                                    "NOBREAK");
                                                                                  }
#line 232
                                                                                  if (tmp___18 == 0) {
#line 233
                                                                                    dinfo->disablebreak = 1;
                                                                                  } else {
                                                                                    {
#line 234
                                                                                    tmp___16 = strcmp((char const   *)pos,
                                                                                                      "hexdump");
                                                                                    }
#line 234
                                                                                    if (tmp___16 == 0) {
#line 236
                                                                                      dinfo->trace_read.hexdump = (int )*pos != 45;
#line 237
                                                                                      dinfo->trace_write.hexdump = (int )*pos != 45;
#line 238
                                                                                      dinfo->trace_both.hexdump = (int )*pos != 45;
                                                                                    } else {
                                                                                      {
#line 234
                                                                                      tmp___17 = strcmp((char const   *)pos,
                                                                                                        "-hexdump");
                                                                                      }
#line 234
                                                                                      if (tmp___17 == 0) {
#line 236
                                                                                        dinfo->trace_read.hexdump = (int )*pos != 45;
#line 237
                                                                                        dinfo->trace_write.hexdump = (int )*pos != 45;
#line 238
                                                                                        dinfo->trace_both.hexdump = (int )*pos != 45;
                                                                                      } else {
                                                                                        {
#line 239
                                                                                        tmp___14 = strcmp((char const   *)pos,
                                                                                                          "timestamp");
                                                                                        }
#line 239
                                                                                        if (tmp___14 == 0) {
#line 241
                                                                                          dinfo->trace_read.timestamp = (int )*pos != 45;
#line 242
                                                                                          dinfo->trace_write.timestamp = (int )*pos != 45;
#line 243
                                                                                          dinfo->trace_both.timestamp = (int )*pos != 45;
                                                                                        } else {
                                                                                          {
#line 239
                                                                                          tmp___15 = strcmp((char const   *)pos,
                                                                                                            "-timestamp");
                                                                                          }
#line 239
                                                                                          if (tmp___15 == 0) {
#line 241
                                                                                            dinfo->trace_read.timestamp = (int )*pos != 45;
#line 242
                                                                                            dinfo->trace_write.timestamp = (int )*pos != 45;
#line 243
                                                                                            dinfo->trace_both.timestamp = (int )*pos != 45;
                                                                                          } else {
                                                                                            {
#line 244
                                                                                            tmp___12 = strcmp((char const   *)pos,
                                                                                                              "tr-hexdump");
                                                                                            }
#line 244
                                                                                            if (tmp___12 == 0) {
#line 246
                                                                                              dinfo->trace_read.hexdump = (int )*pos != 45;
                                                                                            } else {
                                                                                              {
#line 244
                                                                                              tmp___13 = strcmp((char const   *)pos,
                                                                                                                "-tr-hexdump");
                                                                                              }
#line 244
                                                                                              if (tmp___13 == 0) {
#line 246
                                                                                                dinfo->trace_read.hexdump = (int )*pos != 45;
                                                                                              } else {
                                                                                                {
#line 247
                                                                                                tmp___10 = strcmp((char const   *)pos,
                                                                                                                  "tr-timestamp");
                                                                                                }
#line 247
                                                                                                if (tmp___10 == 0) {
#line 249
                                                                                                  dinfo->trace_read.timestamp = (int )*pos != 45;
                                                                                                } else {
                                                                                                  {
#line 247
                                                                                                  tmp___11 = strcmp((char const   *)pos,
                                                                                                                    "-tr-timestamp");
                                                                                                  }
#line 247
                                                                                                  if (tmp___11 == 0) {
#line 249
                                                                                                    dinfo->trace_read.timestamp = (int )*pos != 45;
                                                                                                  } else {
                                                                                                    {
#line 250
                                                                                                    tmp___8 = strcmp((char const   *)pos,
                                                                                                                     "tw-hexdump");
                                                                                                    }
#line 250
                                                                                                    if (tmp___8 == 0) {
#line 252
                                                                                                      dinfo->trace_write.hexdump = (int )*pos != 45;
                                                                                                    } else {
                                                                                                      {
#line 250
                                                                                                      tmp___9 = strcmp((char const   *)pos,
                                                                                                                       "-tw-hexdump");
                                                                                                      }
#line 250
                                                                                                      if (tmp___9 == 0) {
#line 252
                                                                                                        dinfo->trace_write.hexdump = (int )*pos != 45;
                                                                                                      } else {
                                                                                                        {
#line 253
                                                                                                        tmp___6 = strcmp((char const   *)pos,
                                                                                                                         "tw-timestamp");
                                                                                                        }
#line 253
                                                                                                        if (tmp___6 == 0) {
#line 255
                                                                                                          dinfo->trace_write.timestamp = (int )*pos != 45;
                                                                                                        } else {
                                                                                                          {
#line 253
                                                                                                          tmp___7 = strcmp((char const   *)pos,
                                                                                                                           "-tw-timestamp");
                                                                                                          }
#line 253
                                                                                                          if (tmp___7 == 0) {
#line 255
                                                                                                            dinfo->trace_write.timestamp = (int )*pos != 45;
                                                                                                          } else {
                                                                                                            {
#line 256
                                                                                                            tmp___4 = strcmp((char const   *)pos,
                                                                                                                             "tb-hexdump");
                                                                                                            }
#line 256
                                                                                                            if (tmp___4 == 0) {
#line 258
                                                                                                              dinfo->trace_both.hexdump = (int )*pos != 45;
                                                                                                            } else {
                                                                                                              {
#line 256
                                                                                                              tmp___5 = strcmp((char const   *)pos,
                                                                                                                               "-tb-hexdump");
                                                                                                              }
#line 256
                                                                                                              if (tmp___5 == 0) {
#line 258
                                                                                                                dinfo->trace_both.hexdump = (int )*pos != 45;
                                                                                                              } else {
                                                                                                                {
#line 259
                                                                                                                tmp___2 = strcmp((char const   *)pos,
                                                                                                                                 "tb-timestamp");
                                                                                                                }
#line 259
                                                                                                                if (tmp___2 == 0) {
#line 261
                                                                                                                  dinfo->trace_both.timestamp = (int )*pos != 45;
                                                                                                                } else {
                                                                                                                  {
#line 259
                                                                                                                  tmp___3 = strcmp((char const   *)pos,
                                                                                                                                   "-tb-timestamp");
                                                                                                                  }
#line 259
                                                                                                                  if (tmp___3 == 0) {
#line 261
                                                                                                                    dinfo->trace_both.timestamp = (int )*pos != 45;
                                                                                                                  } else {
                                                                                                                    {
#line 262
                                                                                                                    tmp___1 = strncmp((char const   *)pos,
                                                                                                                                      "tr=",
                                                                                                                                      (size_t )3);
                                                                                                                    }
#line 262
                                                                                                                    if (tmp___1 == 0) {
                                                                                                                      {
#line 264
                                                                                                                      dinfo->trace_read.file = find_tracefile(pos + 3);
                                                                                                                      }
                                                                                                                    } else {
                                                                                                                      {
#line 265
                                                                                                                      tmp___0 = strncmp((char const   *)pos,
                                                                                                                                        "tw=",
                                                                                                                                        (size_t )3);
                                                                                                                      }
#line 265
                                                                                                                      if (tmp___0 == 0) {
                                                                                                                        {
#line 267
                                                                                                                        dinfo->trace_write.file = find_tracefile(pos + 3);
                                                                                                                        }
                                                                                                                      } else {
                                                                                                                        {
#line 268
                                                                                                                        tmp = strncmp((char const   *)pos,
                                                                                                                                      "tb=",
                                                                                                                                      (size_t )3);
                                                                                                                        }
#line 268
                                                                                                                        if (tmp == 0) {
                                                                                                                          {
#line 270
                                                                                                                          dinfo->trace_both.file = find_tracefile(pos + 3);
                                                                                                                          }
                                                                                                                        } else {
                                                                                                                          {
#line 271
                                                                                                                          s = find_str(pos,
                                                                                                                                       & stype);
                                                                                                                          }
#line 271
                                                                                                                          if (s) {
                                                                                                                            {
#line 275
                                                                                                                            if ((unsigned int )stype == 0U) {
#line 275
                                                                                                                              goto case_0;
                                                                                                                            }
#line 276
                                                                                                                            if ((unsigned int )stype == 3U) {
#line 276
                                                                                                                              goto case_3;
                                                                                                                            }
#line 277
                                                                                                                            if ((unsigned int )stype == 1U) {
#line 277
                                                                                                                              goto case_1;
                                                                                                                            }
#line 278
                                                                                                                            if ((unsigned int )stype == 2U) {
#line 278
                                                                                                                              goto case_2;
                                                                                                                            }
#line 274
                                                                                                                            goto switch_break;
                                                                                                                            case_0: /* CIL Label */ 
#line 275
                                                                                                                            dinfo->banner = s;
#line 275
                                                                                                                            goto switch_break;
                                                                                                                            case_3: /* CIL Label */ 
#line 276
                                                                                                                            dinfo->signature = s;
#line 276
                                                                                                                            goto switch_break;
                                                                                                                            case_1: /* CIL Label */ 
#line 277
                                                                                                                            dinfo->openstr = s;
#line 277
                                                                                                                            goto switch_break;
                                                                                                                            case_2: /* CIL Label */ 
#line 278
                                                                                                                            dinfo->closestr = s;
#line 278
                                                                                                                            goto switch_break;
                                                                                                                            switch_break: /* CIL Label */ ;
                                                                                                                            }
                                                                                                                          } else {
#line 282
                                                                                                                            rv = -1;
#line 283
                                                                                                                            goto out;
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 286
    pos = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", \t",
                   (char **/* __restrict  */)(& strtok_data));
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 290
  free((void *)str);
  }
#line 291
  return (rv);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.c"
static char *baud_string(int speed ) 
{ 
  char *str ;

  {
  {
#line 299
  if (speed == 7) {
#line 299
    goto case_7;
  }
#line 300
  if (speed == 8) {
#line 300
    goto case_8;
  }
#line 301
  if (speed == 9) {
#line 301
    goto case_9;
  }
#line 302
  if (speed == 11) {
#line 302
    goto case_11;
  }
#line 303
  if (speed == 12) {
#line 303
    goto case_12;
  }
#line 304
  if (speed == 13) {
#line 304
    goto case_13;
  }
#line 305
  if (speed == 14) {
#line 305
    goto case_14;
  }
#line 306
  if (speed == 15) {
#line 306
    goto case_15;
  }
#line 307
  if (speed == 4097) {
#line 307
    goto case_4097;
  }
#line 308
  if (speed == 4098) {
#line 308
    goto case_4098;
  }
#line 310
  if (speed == 4099) {
#line 310
    goto case_4099;
  }
#line 313
  if (speed == 4100) {
#line 313
    goto case_4100;
  }
#line 316
  if (speed == 4101) {
#line 316
    goto case_4101;
  }
#line 319
  if (speed == 4102) {
#line 319
    goto case_4102;
  }
#line 322
  if (speed == 4103) {
#line 322
    goto case_4103;
  }
#line 325
  if (speed == 4104) {
#line 325
    goto case_4104;
  }
#line 328
  if (speed == 4105) {
#line 328
    goto case_4105;
  }
#line 331
  if (speed == 4106) {
#line 331
    goto case_4106;
  }
#line 334
  if (speed == 4107) {
#line 334
    goto case_4107;
  }
#line 337
  if (speed == 4108) {
#line 337
    goto case_4108;
  }
#line 340
  if (speed == 4109) {
#line 340
    goto case_4109;
  }
#line 343
  if (speed == 4110) {
#line 343
    goto case_4110;
  }
#line 346
  if (speed == 4111) {
#line 346
    goto case_4111;
  }
#line 348
  goto switch_default;
  case_7: /* CIL Label */ 
#line 299
  str = (char *)"300";
#line 299
  goto switch_break;
  case_8: /* CIL Label */ 
#line 300
  str = (char *)"600";
#line 300
  goto switch_break;
  case_9: /* CIL Label */ 
#line 301
  str = (char *)"1200";
#line 301
  goto switch_break;
  case_11: /* CIL Label */ 
#line 302
  str = (char *)"2400";
#line 302
  goto switch_break;
  case_12: /* CIL Label */ 
#line 303
  str = (char *)"4800";
#line 303
  goto switch_break;
  case_13: /* CIL Label */ 
#line 304
  str = (char *)"9600";
#line 304
  goto switch_break;
  case_14: /* CIL Label */ 
#line 305
  str = (char *)"19200";
#line 305
  goto switch_break;
  case_15: /* CIL Label */ 
#line 306
  str = (char *)"38400";
#line 306
  goto switch_break;
  case_4097: /* CIL Label */ 
#line 307
  str = (char *)"57600";
#line 307
  goto switch_break;
  case_4098: /* CIL Label */ 
#line 308
  str = (char *)"115200";
#line 308
  goto switch_break;
  case_4099: /* CIL Label */ 
#line 310
  str = (char *)"230400";
#line 310
  goto switch_break;
  case_4100: /* CIL Label */ 
#line 313
  str = (char *)"460800";
#line 313
  goto switch_break;
  case_4101: /* CIL Label */ 
#line 316
  str = (char *)"500000";
#line 316
  goto switch_break;
  case_4102: /* CIL Label */ 
#line 319
  str = (char *)"576000";
#line 319
  goto switch_break;
  case_4103: /* CIL Label */ 
#line 322
  str = (char *)"921600";
#line 322
  goto switch_break;
  case_4104: /* CIL Label */ 
#line 325
  str = (char *)"1000000";
#line 325
  goto switch_break;
  case_4105: /* CIL Label */ 
#line 328
  str = (char *)"1152000";
#line 328
  goto switch_break;
  case_4106: /* CIL Label */ 
#line 331
  str = (char *)"1500000";
#line 331
  goto switch_break;
  case_4107: /* CIL Label */ 
#line 334
  str = (char *)"2000000";
#line 334
  goto switch_break;
  case_4108: /* CIL Label */ 
#line 337
  str = (char *)"2500000";
#line 337
  goto switch_break;
  case_4109: /* CIL Label */ 
#line 340
  str = (char *)"3000000";
#line 340
  goto switch_break;
  case_4110: /* CIL Label */ 
#line 343
  str = (char *)"3500000";
#line 343
  goto switch_break;
  case_4111: /* CIL Label */ 
#line 346
  str = (char *)"4000000";
#line 346
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 348
  str = (char *)"unknown speed";
  switch_break: /* CIL Label */ ;
  }
#line 350
  return (str);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.c"
void serparm_to_str(char *str , int strlen___0 , struct termios *termctl ) 
{ 
  speed_t speed ;
  speed_t tmp ;
  int stopbits ;
  int databits ;
  int parity_enabled ;
  int parity ;
  char *sstr ;
  char pchar ;
  char schar ;
  char dchar ;

  {
  {
#line 356
  tmp = cfgetospeed((struct termios  const  *)termctl);
#line 356
  speed = tmp;
#line 357
  stopbits = (int )(termctl->c_cflag & 64U);
#line 358
  databits = (int )(termctl->c_cflag & 48U);
#line 359
  parity_enabled = (int )(termctl->c_cflag & 256U);
#line 360
  parity = (int )(termctl->c_cflag & 512U);
#line 364
  sstr = baud_string((int )speed);
  }
#line 366
  if (stopbits) {
#line 367
    schar = (char )'2';
  } else {
#line 369
    schar = (char )'1';
  }
  {
#line 372
  if (databits == 32) {
#line 372
    goto case_32;
  }
#line 373
  if (databits == 48) {
#line 373
    goto case_48;
  }
#line 374
  goto switch_default;
  case_32: /* CIL Label */ 
#line 372
  dchar = (char )'7';
#line 372
  goto switch_break;
  case_48: /* CIL Label */ 
#line 373
  dchar = (char )'8';
#line 373
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 374
  dchar = (char )'?';
  switch_break: /* CIL Label */ ;
  }
#line 377
  if (parity_enabled) {
#line 378
    if (parity) {
#line 379
      pchar = (char )'O';
    } else {
#line 381
      pchar = (char )'E';
    }
  } else {
#line 384
    pchar = (char )'N';
  }
  {
#line 387
  snprintf((char */* __restrict  */)str, (size_t )strlen___0, (char const   */* __restrict  */)"%s %c%c%c",
           sstr, (int )pchar, (int )dchar, (int )schar);
  }
#line 388
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.c"
void show_devcfg(struct controller_info *cntlr , struct termios *termctl ) 
{ 
  speed_t speed ;
  speed_t tmp ;
  int stopbits ;
  int databits ;
  int parity_enabled ;
  int parity ;
  int xon ;
  int xoff ;
  int xany ;
  int flow_rtscts ;
  int clocal ;
  int hangup_when_done ;
  char *str ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 394
  tmp = cfgetospeed((struct termios  const  *)termctl);
#line 394
  speed = tmp;
#line 395
  stopbits = (int )(termctl->c_cflag & 64U);
#line 396
  databits = (int )(termctl->c_cflag & 48U);
#line 397
  parity_enabled = (int )(termctl->c_cflag & 256U);
#line 398
  parity = (int )(termctl->c_cflag & 512U);
#line 399
  xon = (int )(termctl->c_iflag & 1024U);
#line 400
  xoff = (int )(termctl->c_iflag & 4096U);
#line 401
  xany = (int )(termctl->c_iflag & 2048U);
#line 402
  flow_rtscts = (int )(termctl->c_cflag & 2147483648U);
#line 403
  clocal = (int )(termctl->c_cflag & 2048U);
#line 404
  hangup_when_done = (int )(termctl->c_cflag & 1024U);
#line 407
  str = baud_string((int )speed);
#line 408
  tmp___0 = strlen((char const   *)str);
#line 408
  controller_output(cntlr, str, (int )tmp___0);
#line 409
  controller_output(cntlr, (char *)" ", 1);
  }
#line 411
  if (xon) {
#line 411
    if (xoff) {
#line 411
      if (xany) {
        {
#line 412
        controller_output(cntlr, (char *)"XONXOFF ", 8);
        }
      }
    }
  }
#line 415
  if (flow_rtscts) {
    {
#line 416
    controller_output(cntlr, (char *)"RTSCTS ", 7);
    }
  }
#line 419
  if (clocal) {
    {
#line 420
    controller_output(cntlr, (char *)"LOCAL ", 6);
    }
  }
#line 423
  if (hangup_when_done) {
    {
#line 424
    controller_output(cntlr, (char *)"HANGUP_WHEN_DONE ", 17);
    }
  }
#line 427
  if (stopbits) {
#line 428
    str = (char *)"2STOPBITS";
  } else {
#line 430
    str = (char *)"1STOPBIT";
  }
  {
#line 432
  tmp___1 = strlen((char const   *)str);
#line 432
  controller_output(cntlr, str, (int )tmp___1);
#line 433
  controller_output(cntlr, (char *)" ", 1);
  }
  {
#line 436
  if (databits == 32) {
#line 436
    goto case_32;
  }
#line 437
  if (databits == 48) {
#line 437
    goto case_48;
  }
#line 438
  goto switch_default;
  case_32: /* CIL Label */ 
#line 436
  str = (char *)"7DATABITS";
#line 436
  goto switch_break;
  case_48: /* CIL Label */ 
#line 437
  str = (char *)"8DATABITS";
#line 437
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 438
  str = (char *)"unknown databits";
  switch_break: /* CIL Label */ ;
  }
  {
#line 440
  tmp___2 = strlen((char const   *)str);
#line 440
  controller_output(cntlr, str, (int )tmp___2);
#line 441
  controller_output(cntlr, (char *)" ", 1);
  }
#line 443
  if (parity_enabled) {
#line 444
    if (parity) {
#line 445
      str = (char *)"ODD";
    } else {
#line 447
      str = (char *)"EVEN";
    }
  } else {
#line 450
    str = (char *)"NONE";
  }
  {
#line 452
  tmp___3 = strlen((char const   *)str);
#line 452
  controller_output(cntlr, str, (int )tmp___3);
  }
#line 453
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.c"
int setdevcontrol(char *instr , int fd ) 
{ 
  int rv ;
  char *str ;
  char *pos ;
  int status ;
  char *strtok_data ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 458
  rv = 0;
#line 464
  tmp = strlen((char const   *)instr);
#line 464
  tmp___0 = malloc(tmp + 1UL);
#line 464
  str = (char *)tmp___0;
  }
#line 465
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 466
    return (-1);
  }
  {
#line 469
  strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)instr);
#line 471
  pos = strtok_r((char */* __restrict  */)str, (char const   */* __restrict  */)" \t",
                 (char **/* __restrict  */)(& strtok_data));
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! ((unsigned long )pos != (unsigned long )((void *)0))) {
#line 472
      goto while_break;
    }
    {
#line 473
    tmp___4 = strcmp((char const   *)pos, "RTSHI");
    }
#line 473
    if (tmp___4 == 0) {
      {
#line 474
      ioctl(fd, 21525UL, & status);
#line 475
      status |= 4;
#line 476
      ioctl(fd, 21528UL, & status);
      }
    } else {
      {
#line 477
      tmp___3 = strcmp((char const   *)pos, "RTSLO");
      }
#line 477
      if (tmp___3 == 0) {
        {
#line 478
        ioctl(fd, 21525UL, & status);
#line 479
        status &= -5;
#line 480
        ioctl(fd, 21528UL, & status);
        }
      } else {
        {
#line 481
        tmp___2 = strcmp((char const   *)pos, "DTRHI");
        }
#line 481
        if (tmp___2 == 0) {
          {
#line 482
          ioctl(fd, 21525UL, & status);
#line 483
          status |= 2;
#line 484
          ioctl(fd, 21528UL, & status);
          }
        } else {
          {
#line 485
          tmp___1 = strcmp((char const   *)pos, "DTRLO");
          }
#line 485
          if (tmp___1 == 0) {
            {
#line 486
            ioctl(fd, 21525UL, & status);
#line 487
            status &= -3;
#line 488
            ioctl(fd, 21528UL, & status);
            }
          } else {
#line 490
            rv = -1;
#line 491
            goto out;
          }
        }
      }
    }
    {
#line 494
    pos = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                   (char **/* __restrict  */)(& strtok_data));
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 498
  free((void *)str);
  }
#line 499
  return (rv);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/devcfg.c"
void show_devcontrol(struct controller_info *cntlr , int fd ) 
{ 
  char *str ;
  int status ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 508
  ioctl(fd, 21525UL, & status);
  }
#line 510
  if (status & 4) {
#line 511
    str = (char *)"RTSHI";
  } else {
#line 513
    str = (char *)"RTSLO";
  }
  {
#line 515
  tmp = strlen((char const   *)str);
#line 515
  controller_output(cntlr, str, (int )tmp);
#line 516
  controller_output(cntlr, (char *)" ", 1);
  }
#line 518
  if (status & 2) {
#line 519
    str = (char *)"DTRHI";
  } else {
#line 521
    str = (char *)"DTRLO";
  }
  {
#line 523
  tmp___0 = strlen((char const   *)str);
#line 523
  controller_output(cntlr, str, (int )tmp___0);
#line 524
  controller_output(cntlr, (char *)" ", 1);
  }
#line 525
  return;
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.h"
int scan_int(char *str ) ;
#line 45
int port_from_in_addr(int family , struct sockaddr *addr ) ;
#line 48
int write_full(int fd , char *data , size_t count ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.c"
int scan_int(char *str ) 
{ 
  int rv ;

  {
#line 36
  rv = 0;
#line 38
  if ((int )*str == 0) {
#line 39
    return (-1);
  }
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    if ((int )*str == 57) {
#line 45
      goto case_57;
    }
#line 45
    if ((int )*str == 56) {
#line 45
      goto case_57;
    }
#line 45
    if ((int )*str == 55) {
#line 45
      goto case_57;
    }
#line 45
    if ((int )*str == 54) {
#line 45
      goto case_57;
    }
#line 45
    if ((int )*str == 53) {
#line 45
      goto case_57;
    }
#line 45
    if ((int )*str == 52) {
#line 45
      goto case_57;
    }
#line 45
    if ((int )*str == 51) {
#line 45
      goto case_57;
    }
#line 45
    if ((int )*str == 50) {
#line 45
      goto case_57;
    }
#line 45
    if ((int )*str == 49) {
#line 45
      goto case_57;
    }
#line 45
    if ((int )*str == 48) {
#line 45
      goto case_57;
    }
#line 49
    if ((int )*str == 0) {
#line 49
      goto case_0;
    }
#line 52
    goto switch_default;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 46
    rv = rv * 10 + ((int )*str - 48);
#line 47
    goto switch_break;
    case_0: /* CIL Label */ 
#line 50
    return (rv);
    switch_default: /* CIL Label */ 
#line 53
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 56
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return (rv);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.c"
int scan_tcp_port(char *str , int domain , struct sockaddr_storage *addr , socklen_t *addr_len ) 
{ 
  char *strtok_data ;
  char *ip ;
  char *port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  int tmp ;

  {
  {
#line 75
  memset((void *)addr, 0, sizeof(*addr));
#line 77
  ip = strtok_r((char */* __restrict  */)str, (char const   */* __restrict  */)",",
                (char **/* __restrict  */)(& strtok_data));
#line 78
  port = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"",
                  (char **/* __restrict  */)(& strtok_data));
  }
#line 79
  if ((unsigned long )port == (unsigned long )((void *)0)) {
#line 80
    port = ip;
#line 81
    ip = (char *)((void *)0);
  }
  {
#line 84
  memset((void *)(& hints), 0, sizeof(hints));
#line 85
  hints.ai_flags = 1;
#line 86
  hints.ai_family = domain;
#line 87
  tmp = getaddrinfo((char const   */* __restrict  */)ip, (char const   */* __restrict  */)port,
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 87
  if (tmp) {
#line 88
    return (-1);
  }
  {
#line 90
  memcpy((void */* __restrict  */)addr, (void const   */* __restrict  */)ai->ai_addr,
         (size_t )ai->ai_addrlen);
#line 91
  *addr_len = ai->ai_addrlen;
#line 92
  freeaddrinfo(ai);
  }
#line 93
  return (0);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.c"
void check_ipv6_only(int family , struct sockaddr *addr , int fd ) 
{ 
  int null ;
  struct in6_addr  const  *__a ;
  int tmp ;

  {
#line 100
  if (family == 10) {
#line 100
    __a = (struct in6_addr  const  *)(& ((struct sockaddr_in6 *)addr)->sin6_addr);
#line 100
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 100
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 100
        if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 100
          if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 100
            tmp = 1;
          } else {
#line 100
            tmp = 0;
          }
        } else {
#line 100
          tmp = 0;
        }
      } else {
#line 100
        tmp = 0;
      }
    } else {
#line 100
      tmp = 0;
    }
#line 100
    if (tmp) {
      {
#line 102
      null = 0;
#line 104
      setsockopt(fd, 41, 26, (void const   *)(& null), (socklen_t )sizeof(null));
      }
    }
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.c"
int port_from_in_addr(int family , struct sockaddr *addr ) 
{ 


  {
  {
#line 112
  if (family == 10) {
#line 112
    goto case_10;
  }
#line 116
  goto switch_default;
  case_10: /* CIL Label */ 
#line 113
  return ((int )((struct sockaddr_in6 *)addr)->sin6_port);
  switch_default: /* CIL Label */ 
#line 117
  return ((int )((struct sockaddr_in *)addr)->sin_port);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.c"
int write_full(int fd , char *data , size_t count ) 
{ 
  size_t written ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  restart: 
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    tmp = write(fd, (void const   *)data, count);
#line 127
    written = (size_t )tmp;
    }
#line 127
    if (! (written > 0UL)) {
#line 127
      goto while_break;
    }
#line 128
    data += written;
#line 129
    count -= written;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (written < 0UL) {
    {
#line 132
    tmp___0 = __errno_location();
    }
#line 132
    if (*tmp___0 == 11) {
#line 133
      goto restart;
    }
#line 134
    return (-1);
  }
#line 136
  return (0);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/utils.c"
void write_ignore_fail(int fd , char *data , size_t count ) 
{ 
  ssize_t written ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    written = write(fd, (void const   *)data, count);
    }
#line 144
    if (! (written > 0L)) {
#line 144
      goto while_break;
    }
#line 145
    data += written;
#line 146
    count -= (size_t )written;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 51 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t ( __attribute__((__leaf__)) cfgetispeed)(struct termios  const  *__termios_p ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 80
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsendbreak)(int __fd ,
                                                                                  int __duration ) ;
#line 90
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcflush)(int __fd ,
                                                                              int __queue_selector ) ;
#line 94
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcflow)(int __fd ,
                                                                             int __action ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 677 "/usr/include/netdb.h"
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 427
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                                                 char *__buf ,
                                                                                                 size_t __buflen )  __asm__("__xpg_strerror_r")  ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static char *uucp_lck_dir  =    (char *)"/var/lock";
#line 75 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
char *state_str[4]  = {      (char *)"unconnected",      (char *)"waiting input",      (char *)"waiting output",      (char *)"closing"};
#line 83 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
char *enabled_str[4]  = {      (char *)"off",      (char *)"raw",      (char *)"rawlp",      (char *)"telnet"};
#line 227 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
port_info_t *ports  =    (port_info_t *)((void *)0);
#line 229
static void shutdown_port(port_info_t *port , char *reason ) ;
#line 230
static void finish_shutdown_port(port_info_t *port ) ;
#line 233 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static unsigned char telnet_init_seq___0[12]  = 
#line 233
  {      (unsigned char)255,      (unsigned char)251,      (unsigned char)3,      (unsigned char)255, 
        (unsigned char)251,      (unsigned char)1,      (unsigned char)255,      (unsigned char)254, 
        (unsigned char)1,      (unsigned char)255,      (unsigned char)253,      (unsigned char)0};
#line 241
static void com_port_handler(void *cb_data , unsigned char *option , int len ) ;
#line 242
static int com_port_will(void *cb_data ) ;
#line 244 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static struct telnet_cmd telnet_cmds___0[5]  = {      {(unsigned char)3, 0U, 1U, 1U, 0U, 0U, 0U, (void (*)(void *cb_data , unsigned char *option ,
                                                          int len ))0, (int (*)(void *cb_data ))0}, 
        {(unsigned char)1,
      0U, 1U, 1U, 1U, 0U, 0U, (void (*)(void *cb_data , unsigned char *option , int len ))0,
      (int (*)(void *cb_data ))0}, 
        {(unsigned char)0, 1U, 1U, 0U, 1U, 0U, 0U, (void (*)(void *cb_data , unsigned char *option ,
                                                          int len ))0, (int (*)(void *cb_data ))0}, 
        {(unsigned char)44,
      1U, 0U, 0U, 0U, 0U, 0U, & com_port_handler, & com_port_will}, 
        {(unsigned char)255, 0U, 0U, 0U, 0U, 0U, 0U, (void (*)(void *cb_data , unsigned char *option ,
                                                            int len ))0, (int (*)(void *cb_data ))0}};
#line 257 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static int uucp_fname_lock_size(char *devname ) 
{ 
  char *ptr ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 262
  ptr = strrchr((char const   *)devname, '/');
  }
#line 263
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 264
    ptr = devname;
  } else {
#line 266
    ptr ++;
  }
  {
#line 269
  tmp = strlen((char const   *)uucp_lck_dir);
#line 269
  tmp___0 = strlen((char const   *)ptr);
  }
#line 269
  return ((int )((7UL + tmp) + tmp___0));
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void uucp_fname_lock(char *buf___1 , char *devname ) 
{ 
  char *ptr ;

  {
  {
#line 277
  ptr = strrchr((char const   *)devname, '/');
  }
#line 278
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 279
    ptr = devname;
  } else {
#line 281
    ptr ++;
  }
  {
#line 283
  sprintf((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"%s/LCK..%s",
          uucp_lck_dir, ptr);
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void uucp_rm_lock(char *devname ) 
{ 
  char *lck_file ;
  int tmp ;
  void *tmp___0 ;

  {
#line 291
  if (! uucp_locking_enabled) {
#line 291
    return;
  }
  {
#line 293
  tmp = uucp_fname_lock_size(devname);
#line 293
  tmp___0 = malloc((size_t )tmp);
#line 293
  lck_file = (char *)tmp___0;
  }
#line 294
  if ((unsigned long )lck_file == (unsigned long )((void *)0)) {
#line 295
    return;
  }
  {
#line 297
  uucp_fname_lock(lck_file, devname);
#line 298
  unlink((char const   *)lck_file);
#line 299
  free((void *)lck_file);
  }
#line 300
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static int uucp_mk_lock(char *devname ) 
{ 
  struct stat stt ;
  int pid ;
  char *lck_file ;
  union __anonunion_buf_65 buf___1 ;
  int fd ;
  int tmp ;
  void *tmp___0 ;
  int n ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int mask ;
  size_t rv ;
  __mode_t tmp___4 ;
  __pid_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 307
  pid = -1;
#line 309
  if (! uucp_locking_enabled) {
#line 310
    return (0);
  }
  {
#line 312
  tmp___8 = stat((char const   */* __restrict  */)uucp_lck_dir, (struct stat */* __restrict  */)(& stt));
  }
#line 312
  if (tmp___8 == 0) {
    {
#line 320
    tmp = uucp_fname_lock_size(devname);
#line 320
    tmp___0 = malloc((size_t )tmp);
#line 320
    lck_file = (char *)tmp___0;
    }
#line 321
    if ((unsigned long )lck_file == (unsigned long )((void *)0)) {
#line 322
      return (-1);
    }
    {
#line 324
    uucp_fname_lock(lck_file, devname);
#line 326
    pid = 0;
#line 327
    fd = open((char const   *)lck_file, 0);
    }
#line 327
    if (fd >= 0) {
      {
#line 330
      tmp___1 = read(fd, (void *)(& buf___1), sizeof(buf___1));
#line 330
      n = (int )tmp___1;
#line 331
      close(fd);
      }
#line 332
      if (n == 4) {
#line 333
        pid = (int )buf___1.ival;
      } else
#line 334
      if (n > 0) {
        {
#line 335
        buf___1.str[n] = (char)0;
#line 336
        sscanf((char const   */* __restrict  */)(buf___1.str), (char const   */* __restrict  */)"%d",
               & pid);
        }
      }
#line 339
      if (pid > 0) {
        {
#line 339
        tmp___2 = kill(pid, 0);
        }
#line 339
        if (tmp___2 < 0) {
          {
#line 339
          tmp___3 = __errno_location();
          }
#line 339
          if (*tmp___3 == 3) {
            {
#line 341
            unlink((char const   *)lck_file);
#line 342
            sleep(1U);
#line 343
            pid = 0;
            }
          } else {
#line 345
            pid = 1;
          }
        } else {
#line 345
          pid = 1;
        }
      } else {
#line 345
        pid = 1;
      }
    }
#line 349
    if (pid == 0) {
      {
#line 353
      tmp___4 = umask((__mode_t )18);
#line 353
      mask = (int )tmp___4;
#line 354
      fd = open((char const   *)lck_file, 193, 438);
#line 355
      umask((__mode_t )mask);
      }
#line 356
      if (fd >= 0) {
        {
#line 357
        tmp___5 = getpid();
#line 357
        snprintf((char */* __restrict  */)(buf___1.str), sizeof(buf___1), (char const   */* __restrict  */)"%10ld\n",
                 (long )tmp___5);
#line 359
        tmp___6 = strlen((char const   *)(buf___1.str));
#line 359
        tmp___7 = write_full(fd, buf___1.str, tmp___6);
#line 359
        rv = (size_t )tmp___7;
#line 360
        close(fd);
        }
#line 361
        if (rv < 0UL) {
          {
#line 362
          pid = -1;
#line 363
          unlink((char const   *)lck_file);
          }
        }
      } else {
#line 366
        pid = -1;
      }
    }
    {
#line 370
    free((void *)lck_file);
    }
  }
#line 373
  return (pid);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void init_port_data(port_info_t *port ) 
{ 


  {
  {
#line 380
  port->enabled = 0;
#line 381
  port->portname = (char *)((void *)0);
#line 382
  memset((void *)(& port->tcpport), 0, sizeof(port->tcpport));
#line 383
  port->tcpport_len = (socklen_t )0;
#line 384
  port->acceptfd = -1;
#line 385
  port->tcpfd = -1;
#line 386
  port->timeout = 0;
#line 387
  port->next = (struct port_info *)((void *)0);
#line 388
  port->new_config = (struct port_info *)((void *)0);
#line 389
  port->tcp_monitor = (struct controller_info *)((void *)0);
#line 391
  port->devname = (char *)((void *)0);
#line 392
  port->devfd = -1;
#line 393
  memset((void *)(& port->remote), 0, sizeof(port->remote));
#line 394
  memset((void *)(& port->dinfo.termctl), 0, sizeof(port->dinfo.termctl));
#line 395
  port->tcp_to_dev_state = 0;
#line 396
  buffer_init(& port->tcp_to_dev, port->tcp_to_devbuf, (unsigned int )sizeof(port->tcp_to_devbuf));
#line 398
  port->tcp_bytes_received = 0U;
#line 399
  port->tcp_bytes_sent = 0U;
#line 400
  port->banner = (struct sbuf *)((void *)0);
#line 401
  port->dev_to_tcp_state = 0;
#line 402
  buffer_init(& port->dev_to_tcp, port->dev_to_tcpbuf, (unsigned int )sizeof(port->dev_to_tcpbuf));
#line 404
  port->dev_bytes_received = 0U;
#line 405
  port->dev_bytes_sent = 0U;
#line 406
  port->devstr = (struct sbuf *)((void *)0);
#line 407
  port->closestr = (char *)((void *)0);
#line 408
  port->is_2217 = 0;
#line 409
  port->dev_monitor = (struct controller_info *)((void *)0);
#line 410
  port->break_set = 0;
#line 411
  port->dinfo.disablebreak = 0;
#line 412
  port->wt.file = -1;
#line 413
  port->wt.timestamp = 0;
#line 414
  port->wt.hexdump = 0;
#line 415
  port->rt.file = -1;
#line 416
  port->rt.timestamp = 0;
#line 417
  port->rt.hexdump = 0;
#line 418
  port->bt.file = -1;
#line 419
  port->bt.timestamp = 0;
#line 420
  port->bt.hexdump = 0;
  }
#line 421
  return;
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void reset_timer(port_info_t *port ) 
{ 


  {
#line 426
  port->timeout_left = port->timeout;
#line 427
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static int timestamp(trace_t *tr___1 , char *buf___1 , int size ) 
{ 
  time_t result ;
  struct tm *tmp ;
  size_t tmp___0 ;

  {
#line 434
  if (! tr___1->timestamp) {
#line 435
    return (0);
  }
  {
#line 436
  result = time((time_t *)((void *)0));
#line 437
  tmp = localtime((time_t const   *)(& result));
#line 437
  tmp___0 = strftime((char */* __restrict  */)buf___1, (size_t )size, (char const   */* __restrict  */)"%Y/%m/%d %H:%M:%S ",
                     (struct tm  const  */* __restrict  */)tmp);
  }
#line 437
  return ((int )tmp___0);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static int trace_write_end(char *out___0 , int size , unsigned char *start , int col ) 
{ 
  int pos ;
  int w ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  {
#line 443
  pos = 0;
#line 445
  strncat((char */* __restrict  */)out___0, (char const   */* __restrict  */)" |",
          (size_t )(size - pos));
#line 446
  pos += 2;
#line 447
  w = 0;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! (w < col)) {
#line 447
      goto while_break;
    }
    {
#line 448
    tmp___1 = __ctype_b_loc();
    }
#line 448
    if ((int const   )*(*tmp___1 + (int )*(start + w)) & 16384) {
#line 448
      tmp___0 = (int )*(start + w);
    } else {
#line 448
      tmp___0 = '.';
    }
    {
#line 448
    tmp___2 = snprintf((char */* __restrict  */)(out___0 + pos), (size_t )(size - pos),
                       (char const   */* __restrict  */)"%c", tmp___0);
#line 448
    pos += tmp___2;
#line 447
    w ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 451
  strncat((char */* __restrict  */)(out___0 + pos), (char const   */* __restrict  */)"|\n",
          (size_t )(size - pos));
#line 452
  pos += 2;
  }
#line 453
  return (pos);
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static char out[1024]  ;
#line 456 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
int trace_write(port_info_t *port , trace_t *tr___1 , unsigned char *buf___1 , unsigned int buf_len ,
                char *prefix ) 
{ 
  int rv ;
  int w ;
  int col ;
  int pos ;
  int file ;
  unsigned int q ;
  unsigned char *start ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  ssize_t tmp___8 ;

  {
#line 460
  rv = 0;
#line 460
  col = 0;
#line 460
  file = tr___1->file;
#line 465
  if (buf_len == 0U) {
#line 466
    return (0);
  }
#line 468
  if (! tr___1->hexdump) {
    {
#line 469
    tmp = write(file, (void const   *)buf___1, (size_t )buf_len);
    }
#line 469
    return ((int )tmp);
  }
  {
#line 471
  pos = timestamp(tr___1, out, (int )sizeof(out));
#line 472
  tmp___0 = snprintf((char */* __restrict  */)(out + pos), sizeof(out) - (unsigned long )pos,
                     (char const   */* __restrict  */)"%s ", prefix);
#line 472
  pos += tmp___0;
#line 474
  start = buf___1;
#line 475
  q = 0U;
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! (q < buf_len)) {
#line 475
      goto while_break;
    }
    {
#line 476
    tmp___1 = snprintf((char */* __restrict  */)(out + pos), sizeof(out) - (unsigned long )pos,
                       (char const   */* __restrict  */)"%02x ", (int )*(buf___1 + q));
#line 476
    pos += tmp___1;
#line 477
    col ++;
    }
#line 478
    if (col >= 8) {
      {
#line 479
      tmp___2 = trace_write_end(out + pos, (int )(sizeof(out) - (unsigned long )pos),
                                start, col);
#line 479
      pos += tmp___2;
#line 480
      tmp___3 = strlen((char const   *)(out));
#line 480
      tmp___4 = write(file, (void const   *)(out), tmp___3);
#line 480
      rv = (int )tmp___4;
      }
#line 481
      if (rv < 0) {
#line 482
        return (rv);
      }
      {
#line 483
      pos = timestamp(tr___1, out, (int )sizeof(out));
#line 484
      tmp___5 = snprintf((char */* __restrict  */)(out + pos), sizeof(out) - (unsigned long )pos,
                         (char const   */* __restrict  */)"%s ", prefix);
#line 484
      pos += tmp___5;
#line 485
      col = 0;
#line 486
      start = (buf___1 + q) + 1;
      }
    }
#line 475
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  if (col > 0) {
#line 490
    w = 8;
    {
#line 490
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 490
      if (! (w > col)) {
#line 490
        goto while_break___0;
      }
      {
#line 491
      strncat((char */* __restrict  */)(out + pos), (char const   */* __restrict  */)"   ",
              sizeof(out) - (unsigned long )pos);
#line 492
      pos += 3;
#line 490
      w --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 494
    tmp___6 = trace_write_end(out + pos, (int )(sizeof(out) - (unsigned long )pos),
                              start, col);
#line 494
    pos += tmp___6;
#line 495
    tmp___7 = strlen((char const   *)(out));
#line 495
    tmp___8 = write(file, (void const   *)(out), tmp___7);
#line 495
    rv = (int )tmp___8;
    }
#line 496
    if (rv < 0) {
#line 497
      return (rv);
    }
  }
#line 499
  return ((int )buf_len);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void do_trace(port_info_t *port , trace_t *tr___1 , unsigned char *buf___1 ,
                     unsigned int buf_len , char *prefix ) 
{ 
  int rv ;
  char errbuf[128] ;
  int err ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! (buf_len > 0U)) {
#line 508
      goto while_break;
    }
    retry_write: 
    {
#line 510
    rv = trace_write(port, tr___1, buf___1, buf_len, prefix);
    }
#line 511
    if (rv == -1) {
      {
#line 513
      tmp = __errno_location();
#line 513
      err = *tmp;
      }
#line 515
      if (err == 4) {
#line 516
        goto retry_write;
      }
      {
#line 520
      tmp___0 = strerror_r(err, errbuf, sizeof(errbuf));
      }
#line 520
      if (tmp___0 == -1) {
        {
#line 521
        syslog(3, "Unable write to trace file on port %s: %d", port->portname, err);
        }
      } else {
        {
#line 524
        syslog(3, "Unable to write to trace file on port %s: %s", port->portname,
               errbuf);
        }
      }
      {
#line 527
      close(tr___1->file);
#line 528
      tr___1->file = -1;
      }
#line 529
      return;
    }
#line 533
    buf_len -= (unsigned int )rv;
#line 534
    buf___1 += rv;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  return;
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static char buf[1024]  ;
#line 542
static void header_trace(port_info_t *port ) ;
#line 542 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static trace_t tr  =    {1, 1, -1};
#line 538 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void header_trace(port_info_t *port ) 
{ 
  int len ;
  int doneR ;
  int doneW ;
  char portstr[32] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 543
  len = 0;
#line 543
  doneR = -1;
#line 543
  doneW = -1;
#line 546
  tmp = timestamp(& tr, buf, (int )sizeof(buf));
#line 546
  len += tmp;
#line 547
  tmp___0 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned long )len,
                     (char const   */* __restrict  */)"OPEN (");
#line 547
  len += tmp___0;
#line 548
  getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& port->remote)),
              (socklen_t )sizeof(port->remote), (char */* __restrict  */)(buf + len),
              (socklen_t )(sizeof(buf) - (unsigned long )len), (char */* __restrict  */)(portstr),
              (socklen_t )sizeof(portstr), 1);
#line 551
  tmp___1 = strlen((char const   *)(buf + len));
#line 551
  len = (int )((size_t )len + tmp___1);
  }
#line 552
  if (sizeof(buf) - (unsigned long )len > 2UL) {
#line 553
    buf[len] = (char )':';
#line 554
    len ++;
  }
  {
#line 556
  strncpy((char */* __restrict  */)(buf + len), (char const   */* __restrict  */)(portstr),
          sizeof(buf) - (unsigned long )len);
#line 557
  tmp___2 = strlen((char const   *)(buf + len));
#line 557
  len = (int )((size_t )len + tmp___2);
#line 558
  tmp___3 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned long )len,
                     (char const   */* __restrict  */)")\n");
#line 558
  len += tmp___3;
  }
#line 560
  if (port->rt.file != -1) {
#line 560
    if (port->rt.timestamp) {
      {
#line 561
      write_ignore_fail(port->rt.file, buf, (size_t )len);
#line 562
      doneR = port->rt.file;
      }
    }
  }
#line 565
  if (port->wt.file != doneR) {
#line 565
    if (port->wt.timestamp) {
      {
#line 566
      write_ignore_fail(port->wt.file, buf, (size_t )len);
#line 567
      doneW = port->wt.file;
      }
    }
  }
#line 570
  if (port->bt.file != doneR) {
#line 570
    if (port->bt.file != doneW) {
#line 570
      if (port->bt.timestamp) {
        {
#line 572
        write_ignore_fail(port->bt.file, buf, (size_t )len);
        }
      }
    }
  }
#line 573
  return;
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static char buf___0[1024]  ;
#line 579
static void footer_trace(port_info_t *port , char *reason ) ;
#line 579 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static trace_t tr___0  =    {1, 1, -1};
#line 575 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void footer_trace(port_info_t *port , char *reason ) 
{ 
  int len ;
  int doneR ;
  int doneW ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 580
  len = 0;
#line 580
  doneR = -1;
#line 580
  doneW = -1;
#line 582
  tmp = timestamp(& tr___0, buf___0, (int )sizeof(buf___0));
#line 582
  len += tmp;
#line 583
  tmp___0 = snprintf((char */* __restrict  */)(buf___0 + len), sizeof(buf___0), (char const   */* __restrict  */)"CLOSE (%s)\n",
                     reason);
#line 583
  len += tmp___0;
  }
#line 585
  if (port->rt.file != -1) {
#line 585
    if (port->rt.timestamp) {
      {
#line 586
      write_ignore_fail(port->rt.file, buf___0, (size_t )len);
#line 587
      doneR = port->rt.file;
      }
    }
  }
#line 590
  if (port->wt.file != doneR) {
#line 590
    if (port->wt.timestamp) {
      {
#line 591
      write_ignore_fail(port->wt.file, buf___0, (size_t )len);
#line 592
      doneW = port->wt.file;
      }
    }
  }
#line 595
  if (port->bt.file != doneR) {
#line 595
    if (port->bt.file != doneW) {
#line 595
      if (port->bt.timestamp) {
        {
#line 597
        write_ignore_fail(port->bt.file, buf___0, (size_t )len);
        }
      }
    }
  }
#line 598
  return;
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_dev_fd_read(int fd , void *data ) 
{ 
  port_info_t *port ;
  int count ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  int i ;
  int j ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 606
  port = (port_info_t *)data;
#line 609
  port->dev_to_tcp.pos = 0U;
#line 610
  if (port->enabled == 3) {
    {
#line 612
    tmp = read(fd, (void *)port->dev_to_tcp.buf, (size_t )(port->tcp_to_dev.maxsize / 2U));
#line 612
    count = (int )tmp;
    }
  } else {
    {
#line 614
    tmp___0 = read(fd, (void *)port->dev_to_tcp.buf, (size_t )port->tcp_to_dev.maxsize);
#line 614
    count = (int )tmp___0;
    }
  }
#line 617
  if ((unsigned long )port->dev_monitor != (unsigned long )((void *)0)) {
    {
#line 618
    controller_write(port->dev_monitor, (char *)port->dev_to_tcp.buf, count);
    }
  }
#line 623
  if (count < 0) {
    {
#line 625
    syslog(3, "dev read error for port %s: %m", port->portname);
#line 626
    shutdown_port(port, (char *)"dev read error");
    }
#line 627
    return;
  } else
#line 628
  if (count == 0) {
    {
#line 630
    shutdown_port(port, (char *)"closed port");
    }
#line 631
    return;
  }
#line 634
  if (port->rt.file != -1) {
    {
#line 636
    do_trace(port, & port->rt, port->dev_to_tcp.buf, (unsigned int )count, (char *)"term");
    }
  }
#line 637
  if (port->bt.file != -1) {
    {
#line 639
    do_trace(port, & port->bt, port->dev_to_tcp.buf, (unsigned int )count, (char *)"term");
    }
  }
#line 641
  port->dev_bytes_received += (unsigned int )count;
#line 643
  if (port->enabled == 3) {
#line 648
    i = 0;
    {
#line 648
    while (1) {
      while_continue: /* CIL Label */ ;
#line 648
      if (! (i < count)) {
#line 648
        goto while_break;
      }
#line 649
      if ((int )*(port->dev_to_tcp.buf + i) == 255) {
#line 650
        j = count;
        {
#line 650
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 650
          if (! (j > i)) {
#line 650
            goto while_break___0;
          }
#line 651
          *(port->dev_to_tcp.buf + (j + 1)) = *(port->dev_to_tcp.buf + j);
#line 650
          j --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 652
        count ++;
#line 653
        i ++;
#line 654
        *(port->dev_to_tcp.buf + i) = (unsigned char)255;
      }
#line 648
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 659
  port->dev_to_tcp.cursize = (unsigned int )count;
  retry_write: 
  {
#line 662
  tmp___1 = write(port->tcpfd, (void const   *)port->dev_to_tcp.buf, (size_t )port->dev_to_tcp.cursize);
#line 662
  count = (int )tmp___1;
  }
#line 663
  if (count == -1) {
    {
#line 664
    tmp___2 = __errno_location();
    }
#line 664
    if (*tmp___2 == 4) {
#line 666
      goto retry_write;
    }
    {
#line 669
    tmp___4 = __errno_location();
    }
#line 669
    if (*tmp___4 == 11) {
      {
#line 672
      sel_set_fd_read_handler(ser2net_sel, port->devfd, 1);
#line 674
      sel_set_fd_write_handler(ser2net_sel, port->tcpfd, 0);
#line 676
      port->dev_to_tcp_state = 2;
      }
    } else {
      {
#line 677
      tmp___3 = __errno_location();
      }
#line 677
      if (*tmp___3 == 32) {
        {
#line 678
        shutdown_port(port, (char *)"EPIPE");
        }
#line 679
        return;
      } else {
        {
#line 682
        syslog(3, "The tcp write for port %s had error: %m", port->portname);
#line 684
        shutdown_port(port, (char *)"tcp write error");
        }
#line 685
        return;
      }
    }
  } else {
#line 688
    port->tcp_bytes_sent += (unsigned int )count;
#line 689
    port->dev_to_tcp.cursize -= (unsigned int )count;
#line 690
    if (port->dev_to_tcp.cursize != 0U) {
      {
#line 693
      port->dev_to_tcp.pos = (unsigned int )count;
#line 694
      sel_set_fd_read_handler(ser2net_sel, port->devfd, 1);
#line 696
      sel_set_fd_write_handler(ser2net_sel, port->tcpfd, 0);
#line 698
      port->dev_to_tcp_state = 2;
      }
    }
  }
  {
#line 702
  reset_timer(port);
  }
#line 703
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void dev_fd_write(port_info_t *port , struct sbuf *buf___1 ) 
{ 
  int reterr ;
  int buferr ;

  {
  {
#line 713
  reterr = buffer_write(port->devfd, buf___1, & buferr);
  }
#line 714
  if (reterr == -1) {
    {
#line 715
    syslog(3, "The dev write for port %s had error: %m", port->portname);
#line 717
    shutdown_port(port, (char *)"dev write error");
    }
#line 718
    return;
  }
#line 721
  if (buf___1->cursize == 0U) {
    {
#line 723
    sel_set_fd_read_handler(ser2net_sel, port->tcpfd, 0);
#line 725
    sel_set_fd_write_handler(ser2net_sel, port->devfd, 1);
#line 727
    port->tcp_to_dev_state = 1;
    }
  }
  {
#line 730
  reset_timer(port);
  }
#line 731
  return;
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_dev_fd_write(int fd , void *data ) 
{ 
  port_info_t *port ;

  {
  {
#line 736
  port = (port_info_t *)data;
#line 738
  dev_fd_write(port, & port->tcp_to_dev);
  }
#line 739
  return;
}
}
#line 742 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_dev_fd_except(int fd , void *data ) 
{ 
  port_info_t *port ;

  {
  {
#line 745
  port = (port_info_t *)data;
#line 747
  syslog(3, "Select exception on device for port %s", port->portname);
#line 749
  shutdown_port(port, (char *)"fd exception");
  }
#line 750
  return;
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_dev_fd_devstr_write(int fd , void *data ) 
{ 
  port_info_t *port ;

  {
  {
#line 756
  port = (port_info_t *)data;
#line 758
  dev_fd_write(port, port->devstr);
  }
#line 759
  if ((port->devstr)->cursize == 0U) {
    {
#line 760
    sel_set_fd_handlers(ser2net_sel, port->devfd, (void *)port, & handle_dev_fd_read,
                        & handle_dev_fd_write, & handle_dev_fd_except);
#line 766
    free((void *)(port->devstr)->buf);
#line 767
    free((void *)port->devstr);
#line 768
    port->devstr = (struct sbuf *)((void *)0);
    }
  }
#line 769
  return;
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_dev_fd_close_write(int fd , void *data ) 
{ 
  port_info_t *port ;
  int reterr ;
  int buferr ;

  {
  {
#line 775
  port = (port_info_t *)data;
#line 778
  reterr = buffer_write(port->devfd, port->devstr, & buferr);
  }
#line 779
  if (reterr == -1) {
    {
#line 780
    syslog(3, "The dev write for port %s had error: %m", port->portname);
    }
#line 782
    goto closeit;
  }
#line 785
  if ((port->devstr)->cursize != 0U) {
#line 786
    return;
  }
  closeit: 
  {
#line 789
  finish_shutdown_port(port);
  }
#line 790
  return;
}
}
#line 793 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_tcp_fd_read___0(int fd , void *data ) 
{ 
  port_info_t *port ;
  int count ;
  ssize_t tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 796
  port = (port_info_t *)data;
#line 799
  port->tcp_to_dev.pos = 0U;
#line 800
  tmp = read(fd, (void *)port->tcp_to_dev.buf, (size_t )port->tcp_to_dev.maxsize);
#line 800
  count = (int )tmp;
  }
#line 801
  if (count < 0) {
    {
#line 803
    syslog(3, "read error for port %s: %m", port->portname);
#line 804
    shutdown_port(port, (char *)"tcp read error");
    }
#line 805
    return;
  } else
#line 806
  if (count == 0) {
    {
#line 808
    shutdown_port(port, (char *)"tcp read close");
    }
#line 809
    return;
  }
#line 811
  port->tcp_to_dev.cursize = (unsigned int )count;
#line 813
  port->tcp_bytes_received += (unsigned int )count;
#line 815
  if (port->enabled == 3) {
    {
#line 816
    tmp___0 = process_telnet_data(port->tcp_to_dev.buf, count, & port->tn_data);
#line 816
    port->tcp_to_dev.cursize = (unsigned int )tmp___0;
    }
#line 819
    if (port->tn_data.error) {
      {
#line 820
      shutdown_port(port, (char *)"telnet output error");
      }
#line 821
      return;
    }
#line 823
    if (port->tcp_to_dev.cursize == 0U) {
#line 827
      return;
    }
  }
#line 831
  if ((unsigned long )port->tcp_monitor != (unsigned long )((void *)0)) {
    {
#line 832
    controller_write(port->tcp_monitor, (char *)port->tcp_to_dev.buf, (int )port->tcp_to_dev.cursize);
    }
  }
#line 837
  if (port->wt.file != -1) {
    {
#line 839
    do_trace(port, & port->wt, port->tcp_to_dev.buf, port->tcp_to_dev.cursize, (char *)"tcp ");
    }
  }
#line 841
  if (port->bt.file != -1) {
    {
#line 843
    do_trace(port, & port->bt, port->tcp_to_dev.buf, port->tcp_to_dev.cursize, (char *)"tcp ");
    }
  }
  retry_write: 
  {
#line 847
  tmp___1 = write(port->devfd, (void const   *)port->tcp_to_dev.buf, (size_t )port->tcp_to_dev.cursize);
#line 847
  count = (int )tmp___1;
  }
#line 848
  if (count == -1) {
    {
#line 849
    tmp___2 = __errno_location();
    }
#line 849
    if (*tmp___2 == 4) {
#line 851
      goto retry_write;
    }
    {
#line 854
    tmp___3 = __errno_location();
    }
#line 854
    if (*tmp___3 == 11) {
      {
#line 857
      sel_set_fd_read_handler(ser2net_sel, port->tcpfd, 1);
#line 859
      sel_set_fd_write_handler(ser2net_sel, port->devfd, 0);
#line 861
      port->tcp_to_dev_state = 2;
      }
    } else {
      {
#line 864
      syslog(3, "The dev write for port %s had error: %m", port->portname);
#line 866
      shutdown_port(port, (char *)"dev write error");
      }
#line 867
      return;
    }
  } else {
#line 870
    port->dev_bytes_sent += (unsigned int )count;
#line 871
    port->tcp_to_dev.cursize -= (unsigned int )count;
#line 872
    if (port->tcp_to_dev.cursize != 0U) {
      {
#line 875
      port->tcp_to_dev.pos = (unsigned int )count;
#line 876
      sel_set_fd_read_handler(ser2net_sel, port->tcpfd, 1);
#line 878
      sel_set_fd_write_handler(ser2net_sel, port->devfd, 0);
#line 880
      port->tcp_to_dev_state = 2;
      }
    }
  }
  {
#line 884
  reset_timer(port);
  }
#line 885
  return;
}
}
#line 890 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void tcp_fd_write(port_info_t *port , struct sbuf *buf___1 ) 
{ 
  telnet_data_t *td ;
  int buferr ;
  int reterr ;

  {
#line 893
  td = & port->tn_data;
#line 896
  if (td->out_telnet_cmd.cursize > 0U) {
    {
#line 897
    reterr = buffer_write(port->tcpfd, & td->out_telnet_cmd, & buferr);
    }
#line 898
    if (reterr == -1) {
#line 899
      if (buferr == 32) {
        {
#line 900
        shutdown_port(port, (char *)"EPIPE");
        }
      } else {
        {
#line 903
        syslog(3, "The tcp write for port %s had error: %m", port->portname);
#line 905
        shutdown_port(port, (char *)"tcp write error");
        }
      }
    }
#line 909
    if (td->out_telnet_cmd.cursize > 0U) {
#line 912
      return;
    }
  }
  {
#line 916
  reterr = buffer_write(port->tcpfd, buf___1, & buferr);
  }
#line 917
  if (reterr == -1) {
#line 918
    if (buferr == 32) {
      {
#line 919
      shutdown_port(port, (char *)"EPIPE");
      }
    } else {
      {
#line 922
      syslog(3, "The tcp write for port %s had error: %m", port->portname);
#line 924
      shutdown_port(port, (char *)"tcp write error");
      }
    }
#line 926
    return;
  }
#line 928
  if (buf___1->cursize == 0U) {
    {
#line 930
    sel_set_fd_read_handler(ser2net_sel, port->devfd, 0);
#line 932
    sel_set_fd_write_handler(ser2net_sel, port->tcpfd, 1);
#line 934
    port->dev_to_tcp_state = 1;
    }
  }
  {
#line 937
  reset_timer(port);
  }
#line 938
  return;
}
}
#line 943 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_tcp_fd_write___0(int fd , void *data ) 
{ 
  port_info_t *port ;

  {
  {
#line 946
  port = (port_info_t *)data;
#line 947
  tcp_fd_write(port, & port->dev_to_tcp);
  }
#line 948
  return;
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_tcp_fd_except___0(int fd , void *data ) 
{ 
  port_info_t *port ;

  {
  {
#line 954
  port = (port_info_t *)data;
#line 956
  syslog(3, "Select exception on port %s", port->portname);
#line 957
  shutdown_port(port, (char *)"tcp fd exception");
  }
#line 958
  return;
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_tcp_fd_banner_write(int fd , void *data ) 
{ 
  port_info_t *port ;

  {
  {
#line 963
  port = (port_info_t *)data;
#line 965
  tcp_fd_write(port, port->banner);
  }
#line 966
  if ((port->banner)->cursize == 0U) {
    {
#line 967
    sel_set_fd_handlers(ser2net_sel, port->tcpfd, (void *)port, & handle_tcp_fd_read___0,
                        & handle_tcp_fd_write___0, & handle_tcp_fd_except___0);
#line 973
    free((void *)(port->banner)->buf);
#line 974
    free((void *)port->banner);
#line 975
    port->banner = (struct sbuf *)((void *)0);
    }
  }
#line 977
  return;
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void telnet_cmd_handler___0(void *cb_data , unsigned char cmd ) 
{ 
  port_info_t *port ;

  {
#line 982
  port = (port_info_t *)cb_data;
#line 984
  if ((int )cmd == 243) {
    {
#line 985
    tcsendbreak(port->devfd, 0);
    }
  }
#line 986
  return;
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void telnet_output_ready___0(void *cb_data ) 
{ 
  port_info_t *port ;

  {
  {
#line 992
  port = (port_info_t *)cb_data;
#line 993
  sel_set_fd_read_handler(ser2net_sel, port->devfd, 1);
#line 995
  sel_set_fd_write_handler(ser2net_sel, port->tcpfd, 0);
  }
#line 997
  return;
}
}
#line 1000 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static int is_device_already_inuse(port_info_t *check_port ) 
{ 
  port_info_t *port ;
  int tmp ;

  {
#line 1003
  port = ports;
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1005
    if (! ((unsigned long )port != (unsigned long )((void *)0))) {
#line 1005
      goto while_break;
    }
#line 1006
    if ((unsigned long )port != (unsigned long )check_port) {
      {
#line 1007
      tmp = strcmp((char const   *)port->devname, (char const   *)check_port->devname);
      }
#line 1007
      if (tmp == 0) {
#line 1007
        if (port->tcp_to_dev_state != 0) {
#line 1010
          return (1);
        }
      }
    }
#line 1013
    port = port->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1016
  return (0);
}
}
#line 1019 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static int from_hex_digit(char c ) 
{ 


  {
#line 1022
  if ((int )c >= 48) {
#line 1022
    if ((int )c <= 57) {
#line 1023
      return ((int )c - 48);
    }
  }
#line 1024
  if ((int )c >= 65) {
#line 1024
    if ((int )c <= 70) {
#line 1025
      return (((int )c - 65) + 10);
    }
  }
#line 1026
  if ((int )c >= 97) {
#line 1026
    if ((int )c <= 102) {
#line 1027
      return (((int )c - 97) + 10);
    }
  }
#line 1028
  return (0);
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static char *smonths[12]  = 
#line 1031
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 1033 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static char *sdays[7]  = {      (char *)"Sun",      (char *)"Mon",      (char *)"Tue",      (char *)"Wed", 
        (char *)"Thu",      (char *)"Fri",      (char *)"Sat"};
#line 1035 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void process_str(port_info_t *port , struct tm *time___0 , struct timeval *tv ,
                        char *s , void (*op)(void *data , char val ) , void *data ,
                        int isfilename ) 
{ 
  char val ;
  char *t ;
  char str[15] ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  char d[10] ;
  char *dp ;
  char d___0[10] ;
  char *dp___0 ;
  char *dp___1 ;
  char d___1[10] ;
  char *dp___2 ;
  char *dp___3 ;
  char d___2[10] ;
  char *dp___4 ;
  char d___3[10] ;
  char *dp___5 ;
  char d___4[10] ;
  char *dp___6 ;
  int v ;
  char d___5[10] ;
  char *dp___7 ;
  char d___6[10] ;
  char *dp___8 ;
  char d___7[10] ;
  char *dp___9 ;
  char d___8[30] ;
  char *dp___10 ;
  char d___9[10] ;
  char *dp___11 ;
  char ip[100] ;
  char *ipp ;
  int tmp___5 ;

  {
  {
#line 1042
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1042
    if (! *s) {
#line 1042
      goto while_break;
    }
#line 1043
    if ((int )*s == 92) {
#line 1044
      s ++;
#line 1045
      if (! *s) {
#line 1046
        return;
      }
      {
#line 1049
      if ((int )*s == 97) {
#line 1049
        goto case_97;
      }
#line 1050
      if ((int )*s == 98) {
#line 1050
        goto case_98;
      }
#line 1051
      if ((int )*s == 102) {
#line 1051
        goto case_102;
      }
#line 1052
      if ((int )*s == 110) {
#line 1052
        goto case_110;
      }
#line 1053
      if ((int )*s == 114) {
#line 1053
        goto case_114;
      }
#line 1054
      if ((int )*s == 116) {
#line 1054
        goto case_116;
      }
#line 1055
      if ((int )*s == 118) {
#line 1055
        goto case_118;
      }
#line 1056
      if ((int )*s == 92) {
#line 1056
        goto case_92;
      }
#line 1057
      if ((int )*s == 63) {
#line 1057
        goto case_63;
      }
#line 1058
      if ((int )*s == 39) {
#line 1058
        goto case_39;
      }
#line 1059
      if ((int )*s == 34) {
#line 1059
        goto case_34;
      }
#line 1061
      if ((int )*s == 100) {
#line 1061
        goto case_100;
      }
#line 1076
      if ((int )*s == 112) {
#line 1076
        goto case_112;
      }
#line 1082
      if ((int )*s == 115) {
#line 1082
        goto case_115;
      }
#line 1087
      if ((int )*s == 66) {
#line 1087
        goto serparms;
      }
#line 1099
      if ((int )*s == 55) {
#line 1099
        goto case_55;
      }
#line 1099
      if ((int )*s == 54) {
#line 1099
        goto case_55;
      }
#line 1099
      if ((int )*s == 53) {
#line 1099
        goto case_55;
      }
#line 1099
      if ((int )*s == 52) {
#line 1099
        goto case_55;
      }
#line 1099
      if ((int )*s == 51) {
#line 1099
        goto case_55;
      }
#line 1099
      if ((int )*s == 50) {
#line 1099
        goto case_55;
      }
#line 1099
      if ((int )*s == 49) {
#line 1099
        goto case_55;
      }
#line 1099
      if ((int )*s == 48) {
#line 1099
        goto case_55;
      }
#line 1122
      if ((int )*s == 120) {
#line 1122
        goto case_120;
      }
#line 1141
      if ((int )*s == 89) {
#line 1141
        goto case_89;
      }
#line 1151
      if ((int )*s == 121) {
#line 1151
        goto case_121;
      }
#line 1161
      if ((int )*s == 77) {
#line 1161
        goto case_77;
      }
#line 1172
      if ((int )*s == 109) {
#line 1172
        goto case_109;
      }
#line 1182
      if ((int )*s == 65) {
#line 1182
        goto case_65;
      }
#line 1193
      if ((int )*s == 68) {
#line 1193
        goto case_68;
      }
#line 1203
      if ((int )*s == 72) {
#line 1203
        goto case_72;
      }
#line 1213
      if ((int )*s == 104) {
#line 1213
        goto case_104;
      }
#line 1230
      if ((int )*s == 105) {
#line 1230
        goto case_105;
      }
#line 1240
      if ((int )*s == 83) {
#line 1240
        goto seconds;
      }
#line 1251
      if ((int )*s == 113) {
#line 1251
        goto case_113;
      }
#line 1261
      if ((int )*s == 80) {
#line 1261
        goto case_80;
      }
#line 1271
      if ((int )*s == 84) {
#line 1271
        goto case_84;
      }
#line 1282
      if ((int )*s == 101) {
#line 1282
        goto case_101;
      }
#line 1292
      if ((int )*s == 85) {
#line 1292
        goto case_85;
      }
#line 1302
      if ((int )*s == 73) {
#line 1302
        goto case_73;
      }
#line 1314
      goto switch_default;
      case_97: /* CIL Label */ 
      {
#line 1049
      (*op)(data, (char)7);
      }
#line 1049
      goto switch_break;
      case_98: /* CIL Label */ 
      {
#line 1050
      (*op)(data, (char)8);
      }
#line 1050
      goto switch_break;
      case_102: /* CIL Label */ 
      {
#line 1051
      (*op)(data, (char)12);
      }
#line 1051
      goto switch_break;
      case_110: /* CIL Label */ 
      {
#line 1052
      (*op)(data, (char)10);
      }
#line 1052
      goto switch_break;
      case_114: /* CIL Label */ 
      {
#line 1053
      (*op)(data, (char)13);
      }
#line 1053
      goto switch_break;
      case_116: /* CIL Label */ 
      {
#line 1054
      (*op)(data, (char)9);
      }
#line 1054
      goto switch_break;
      case_118: /* CIL Label */ 
      {
#line 1055
      (*op)(data, (char)11);
      }
#line 1055
      goto switch_break;
      case_92: /* CIL Label */ 
      {
#line 1056
      (*op)(data, (char )'\\');
      }
#line 1056
      goto switch_break;
      case_63: /* CIL Label */ 
      {
#line 1057
      (*op)(data, (char )'?');
      }
#line 1057
      goto switch_break;
      case_39: /* CIL Label */ 
      {
#line 1058
      (*op)(data, (char )'\'');
      }
#line 1058
      goto switch_break;
      case_34: /* CIL Label */ 
      {
#line 1059
      (*op)(data, (char )'\"');
      }
#line 1059
      goto switch_break;
      case_100: /* CIL Label */ 
#line 1063
      if (isfilename) {
        {
#line 1065
        t = strrchr((char const   *)port->devname, '/');
        }
#line 1066
        if (t) {
#line 1067
          t ++;
        } else {
#line 1069
          t = port->devname;
        }
      } else {
#line 1071
        t = port->devname;
      }
      {
#line 1072
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1072
        if (! *t) {
#line 1072
          goto while_break___0;
        }
        {
#line 1073
        (*op)(data, *t);
#line 1072
        t ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1074
      goto switch_break;
      case_112: /* CIL Label */ 
#line 1078
      t = port->portname;
      {
#line 1078
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1078
        if (! *t) {
#line 1078
          goto while_break___1;
        }
        {
#line 1079
        (*op)(data, *t);
#line 1078
        t ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1080
      goto switch_break;
      case_115: /* CIL Label */ 
#line 1083
      if (isfilename) {
#line 1084
        goto seconds;
      }
#line 1085
      goto serparms;
      serparms: 
      case_66: /* CIL Label */ 
      {
#line 1092
      serparm_to_str(str, (int )sizeof(str), & port->dinfo.termctl);
#line 1093
      t = str;
      }
      {
#line 1093
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1093
        if (! *t) {
#line 1093
          goto while_break___2;
        }
        {
#line 1094
        (*op)(data, *t);
#line 1093
        t ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1096
      goto switch_break;
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 1101
      val = (char )((int )*s - 48);
#line 1102
      s ++;
#line 1103
      if (! *s) {
        {
#line 1104
        (*op)(data, val);
        }
#line 1105
        return;
      }
      {
#line 1107
      tmp = __ctype_b_loc();
      }
#line 1107
      if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
#line 1108
        goto while_continue;
      }
#line 1110
      val = (char )(((int )val * 8 + (int )*s) - 48);
#line 1111
      s ++;
#line 1112
      if (! *s) {
        {
#line 1113
        (*op)(data, val);
        }
#line 1114
        return;
      }
      {
#line 1116
      tmp___0 = __ctype_b_loc();
      }
#line 1116
      if (! ((int const   )*(*tmp___0 + (int )*s) & 2048)) {
#line 1117
        goto while_continue;
      }
#line 1119
      val = (char )(((int )val * 8 + (int )*s) - 48);
#line 1120
      goto switch_break;
      case_120: /* CIL Label */ 
#line 1124
      s ++;
#line 1125
      if (! *s) {
#line 1126
        return;
      }
      {
#line 1127
      tmp___1 = __ctype_b_loc();
      }
#line 1127
      if (! ((int const   )*(*tmp___1 + (int )*s) & 4096)) {
#line 1128
        goto while_continue;
      }
      {
#line 1129
      tmp___2 = from_hex_digit(*s);
#line 1129
      val = (char )tmp___2;
#line 1130
      s ++;
      }
#line 1131
      if (! *s) {
        {
#line 1132
        (*op)(data, val);
        }
#line 1133
        return;
      }
      {
#line 1135
      tmp___3 = __ctype_b_loc();
      }
#line 1135
      if (! ((int const   )*(*tmp___3 + (int )*s) & 2048)) {
#line 1136
        goto while_continue;
      }
      {
#line 1137
      tmp___4 = from_hex_digit(*s);
#line 1137
      val = (char )((int )val * 16 + tmp___4);
      }
#line 1138
      goto switch_break;
      case_89: /* CIL Label */ 
      {
#line 1144
      snprintf((char */* __restrict  */)(d), sizeof(d), (char const   */* __restrict  */)"%d",
               time___0->tm_year + 1900);
#line 1145
      dp = d;
      }
      {
#line 1145
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1145
        if (! *dp) {
#line 1145
          goto while_break___3;
        }
        {
#line 1146
        (*op)(data, *dp);
#line 1145
        dp ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1147
      goto switch_break;
      case_121: /* CIL Label */ 
      {
#line 1154
      snprintf((char */* __restrict  */)(d___0), sizeof(d___0), (char const   */* __restrict  */)"%d",
               time___0->tm_yday);
#line 1155
      dp___0 = d___0;
      }
      {
#line 1155
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1155
        if (! *dp___0) {
#line 1155
          goto while_break___4;
        }
        {
#line 1156
        (*op)(data, *dp___0);
#line 1155
        dp___0 ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1157
      goto switch_break;
      case_77: /* CIL Label */ 
#line 1162
      if (time___0->tm_mon >= 12) {
        {
#line 1163
        (*op)(data, (char )'?');
        }
      } else {
#line 1165
        dp___1 = smonths[time___0->tm_mon];
        {
#line 1166
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1166
          if (! *dp___1) {
#line 1166
            goto while_break___5;
          }
          {
#line 1167
          (*op)(data, *dp___1);
#line 1166
          dp___1 ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 1169
      goto switch_break;
      case_109: /* CIL Label */ 
      {
#line 1175
      snprintf((char */* __restrict  */)(d___1), sizeof(d___1), (char const   */* __restrict  */)"%d",
               time___0->tm_mon);
#line 1176
      dp___2 = d___1;
      }
      {
#line 1176
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1176
        if (! *dp___2) {
#line 1176
          goto while_break___6;
        }
        {
#line 1177
        (*op)(data, *dp___2);
#line 1176
        dp___2 ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1178
      goto switch_break;
      case_65: /* CIL Label */ 
#line 1183
      if (time___0->tm_wday >= 7) {
        {
#line 1184
        (*op)(data, (char )'?');
        }
      } else {
#line 1186
        dp___3 = sdays[time___0->tm_wday];
        {
#line 1187
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1187
          if (! *dp___3) {
#line 1187
            goto while_break___7;
          }
          {
#line 1188
          (*op)(data, *dp___3);
#line 1187
          dp___3 ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 1190
      goto switch_break;
      case_68: /* CIL Label */ 
      {
#line 1196
      snprintf((char */* __restrict  */)(d___2), sizeof(d___2), (char const   */* __restrict  */)"%d",
               time___0->tm_mday);
#line 1197
      dp___4 = d___2;
      }
      {
#line 1197
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1197
        if (! *dp___4) {
#line 1197
          goto while_break___8;
        }
        {
#line 1198
        (*op)(data, *dp___4);
#line 1197
        dp___4 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1199
      goto switch_break;
      case_72: /* CIL Label */ 
      {
#line 1206
      snprintf((char */* __restrict  */)(d___3), sizeof(d___3), (char const   */* __restrict  */)"%2.2d",
               time___0->tm_hour);
#line 1207
      dp___5 = d___3;
      }
      {
#line 1207
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1207
        if (! *dp___5) {
#line 1207
          goto while_break___9;
        }
        {
#line 1208
        (*op)(data, *dp___5);
#line 1207
        dp___5 ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1209
      goto switch_break;
      case_104: /* CIL Label */ 
#line 1218
      v = time___0->tm_hour;
#line 1219
      if (v == 0) {
#line 1220
        v = 12;
      } else
#line 1221
      if (v > 12) {
#line 1222
        v -= 12;
      }
      {
#line 1223
      snprintf((char */* __restrict  */)(d___4), sizeof(d___4), (char const   */* __restrict  */)"%2.2d",
               v);
#line 1224
      dp___6 = d___4;
      }
      {
#line 1224
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1224
        if (! *dp___6) {
#line 1224
          goto while_break___10;
        }
        {
#line 1225
        (*op)(data, *dp___6);
#line 1224
        dp___6 ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1226
      goto switch_break;
      case_105: /* CIL Label */ 
      {
#line 1233
      snprintf((char */* __restrict  */)(d___5), sizeof(d___5), (char const   */* __restrict  */)"%2.2d",
               time___0->tm_min);
#line 1234
      dp___7 = d___5;
      }
      {
#line 1234
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1234
        if (! *dp___7) {
#line 1234
          goto while_break___11;
        }
        {
#line 1235
        (*op)(data, *dp___7);
#line 1234
        dp___7 ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1236
      goto switch_break;
      seconds: 
      case_83: /* CIL Label */ 
      {
#line 1244
      snprintf((char */* __restrict  */)(d___6), sizeof(d___6), (char const   */* __restrict  */)"%2.2d",
               time___0->tm_sec);
#line 1245
      dp___8 = d___6;
      }
      {
#line 1245
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1245
        if (! *dp___8) {
#line 1245
          goto while_break___12;
        }
        {
#line 1246
        (*op)(data, *dp___8);
#line 1245
        dp___8 ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1247
      goto switch_break;
      case_113: /* CIL Label */ 
#line 1252
      if (time___0->tm_hour < 12) {
        {
#line 1253
        (*op)(data, (char )'a');
        }
      } else {
        {
#line 1255
        (*op)(data, (char )'p');
        }
      }
      {
#line 1257
      (*op)(data, (char )'m');
      }
#line 1258
      goto switch_break;
      case_80: /* CIL Label */ 
#line 1262
      if (time___0->tm_hour < 12) {
        {
#line 1263
        (*op)(data, (char )'A');
        }
      } else {
        {
#line 1265
        (*op)(data, (char )'P');
        }
      }
      {
#line 1267
      (*op)(data, (char )'M');
      }
#line 1268
      goto switch_break;
      case_84: /* CIL Label */ 
      {
#line 1274
      snprintf((char */* __restrict  */)(d___7), sizeof(d___7), (char const   */* __restrict  */)"%2.2d:%2.2d:%2.2d",
               time___0->tm_hour, time___0->tm_min, time___0->tm_sec);
#line 1276
      dp___9 = d___7;
      }
      {
#line 1276
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1276
        if (! *dp___9) {
#line 1276
          goto while_break___13;
        }
        {
#line 1277
        (*op)(data, *dp___9);
#line 1276
        dp___9 ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1278
      goto switch_break;
      case_101: /* CIL Label */ 
      {
#line 1285
      snprintf((char */* __restrict  */)(d___8), sizeof(d___8), (char const   */* __restrict  */)"%ld",
               tv->tv_sec);
#line 1286
      dp___10 = d___8;
      }
      {
#line 1286
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1286
        if (! *dp___10) {
#line 1286
          goto while_break___14;
        }
        {
#line 1287
        (*op)(data, *dp___10);
#line 1286
        dp___10 ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 1288
      goto switch_break;
      case_85: /* CIL Label */ 
      {
#line 1295
      snprintf((char */* __restrict  */)(d___9), sizeof(d___9), (char const   */* __restrict  */)"%6.6ld",
               tv->tv_usec);
#line 1296
      dp___11 = d___9;
      }
      {
#line 1296
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1296
        if (! *dp___11) {
#line 1296
          goto while_break___15;
        }
        {
#line 1297
        (*op)(data, *dp___11);
#line 1296
        dp___11 ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
#line 1298
      goto switch_break;
      case_73: /* CIL Label */ 
      {
#line 1305
      tmp___5 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& port->remote)),
                            (socklen_t )sizeof(port->remote), (char */* __restrict  */)(ip),
                            (socklen_t )sizeof(ip), (char */* __restrict  */)((void *)0),
                            (socklen_t )0, 1);
      }
#line 1305
      if (! tmp___5) {
#line 1308
        goto switch_break;
      }
#line 1309
      ipp = ip;
      {
#line 1309
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 1309
        if (! *ipp) {
#line 1309
          goto while_break___16;
        }
        {
#line 1310
        (*op)(data, *ipp);
#line 1309
        ipp ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
#line 1311
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1315
      (*op)(data, *s);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1318
      (*op)(data, *s);
      }
    }
#line 1319
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1321
  return;
}
}
#line 1323 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void count_op(void *data , char c ) 
{ 
  unsigned int *idata ;

  {
#line 1326
  idata = (unsigned int *)data;
#line 1328
  (*idata) ++;
#line 1329
  return;
}
}
#line 1336 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void buffer_op(void *data , char c ) 
{ 
  struct bufop_data *bufop ;

  {
#line 1339
  bufop = (struct bufop_data *)data;
#line 1340
  *(bufop->str + bufop->pos) = c;
#line 1341
  (bufop->pos) ++;
#line 1342
  return;
}
}
#line 1344 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static char *process_str_to_str(port_info_t *port , char *str , struct timeval *tv ,
                                unsigned int *lenrv , int isfilename ) 
{ 
  unsigned int len ;
  struct tm now ;
  struct bufop_data bufop ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1348
  len = 0U;
#line 1352
  localtime_r((time_t const   */* __restrict  */)(& tv->tv_sec), (struct tm */* __restrict  */)(& now));
#line 1353
  process_str(port, & now, tv, str, & count_op, (void *)(& len), isfilename);
  }
#line 1354
  if (! lenrv) {
#line 1356
    len ++;
  }
#line 1357
  bufop.pos = 0U;
#line 1358
  if (len == 0U) {
    {
#line 1360
    tmp = malloc((size_t )1);
#line 1360
    bufop.str = (char *)tmp;
    }
  } else {
    {
#line 1362
    tmp___0 = malloc((size_t )len);
#line 1362
    bufop.str = (char *)tmp___0;
    }
  }
#line 1363
  if (! bufop.str) {
    {
#line 1364
    syslog(3, "Out of memory processing string: %s", port->portname);
    }
#line 1365
    return ((char *)((void *)0));
  }
  {
#line 1367
  process_str(port, & now, tv, str, & buffer_op, (void *)(& bufop), isfilename);
  }
#line 1369
  if (lenrv) {
#line 1370
    *lenrv = len;
  } else {
#line 1372
    *(bufop.str + bufop.pos) = (char )'\000';
  }
#line 1374
  return (bufop.str);
}
}
#line 1377 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static struct sbuf *process_str_to_buf(port_info_t *port , char *str ) 
{ 
  char *bstr ;
  struct sbuf *buf___1 ;
  unsigned int len ;
  struct timeval tv ;
  void *tmp ;

  {
#line 1385
  if (! str) {
#line 1386
    return ((struct sbuf *)((void *)0));
  }
  {
#line 1387
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 1389
  tmp = malloc(sizeof(*buf___1));
#line 1389
  buf___1 = (struct sbuf *)tmp;
  }
#line 1390
  if (! buf___1) {
    {
#line 1391
    syslog(3, "Out of memory processing string: %s", port->portname);
    }
#line 1392
    return ((struct sbuf *)((void *)0));
  }
  {
#line 1394
  bstr = process_str_to_str(port, str, & tv, & len, 0);
  }
#line 1395
  if (! bstr) {
    {
#line 1396
    free((void *)buf___1);
#line 1397
    syslog(3, "Error processing string: %s", port->portname);
    }
#line 1398
    return ((struct sbuf *)((void *)0));
  }
  {
#line 1400
  buffer_init(buf___1, (unsigned char *)bstr, len);
#line 1401
  buf___1->cursize = len;
  }
#line 1402
  return (buf___1);
}
}
#line 1405 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void open_trace_file(port_info_t *port , trace_info_t *in , trace_t *out___0 ,
                            struct timeval *tv ) 
{ 
  int rv ;
  char *trfilename ;
  char *trfile ;
  char errbuf[128] ;
  int err ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1412
  trfilename = in->file;
#line 1415
  trfile = process_str_to_str(port, trfilename, tv, (unsigned int *)((void *)0), 1);
  }
#line 1416
  if (! trfile) {
    {
#line 1417
    syslog(3, "Unable to translate trace file %s", trfilename);
#line 1418
    out___0->file = -1;
    }
#line 1419
    return;
  }
  {
#line 1422
  rv = open((char const   *)trfile, 1089, 384);
  }
#line 1423
  if (rv == -1) {
    {
#line 1425
    tmp = __errno_location();
#line 1425
    err = *tmp;
#line 1427
    tmp___0 = strerror_r(err, errbuf, sizeof(errbuf));
    }
#line 1427
    if (tmp___0 == -1) {
      {
#line 1428
      syslog(3, "Unable to open trace file %s: %d", trfile, err);
      }
    } else {
      {
#line 1431
      syslog(3, "Unable to open trace file %s: %s", trfile, errbuf);
      }
    }
  } else {
#line 1435
    out___0->hexdump = in->hexdump;
#line 1436
    out___0->timestamp = in->timestamp;
  }
  {
#line 1439
  free((void *)trfile);
#line 1440
  out___0->file = rv;
  }
#line 1441
  return;
}
}
#line 1443 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void setup_trace(port_info_t *port ) 
{ 
  struct timeval tv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1449
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 1451
  if (port->dinfo.trace_write.file) {
    {
#line 1452
    open_trace_file(port, & port->dinfo.trace_write, & port->wt, & tv);
    }
  } else {
#line 1454
    port->wt.file = -1;
  }
#line 1456
  if (port->dinfo.trace_read.file) {
#line 1457
    if (port->dinfo.trace_write.file) {
      {
#line 1457
      tmp = strcmp((char const   *)port->dinfo.trace_read.file, (char const   *)port->dinfo.trace_write.file);
      }
#line 1457
      if (tmp == 0) {
#line 1460
        port->rt.file = port->wt.file;
#line 1461
        port->rt.timestamp = port->wt.timestamp;
#line 1462
        port->rt.hexdump = port->wt.hexdump;
#line 1463
        goto try_both;
      }
    }
    {
#line 1465
    open_trace_file(port, & port->dinfo.trace_read, & port->rt, & tv);
    }
  } else {
#line 1467
    port->rt.file = -1;
  }
  try_both: 
#line 1469
  if (port->dinfo.trace_both.file) {
#line 1470
    if (port->dinfo.trace_write.file) {
      {
#line 1470
      tmp___1 = strcmp((char const   *)port->dinfo.trace_both.file, (char const   *)port->dinfo.trace_write.file);
      }
#line 1470
      if (tmp___1 == 0) {
#line 1473
        port->bt.file = port->wt.file;
#line 1474
        port->bt.timestamp = port->wt.timestamp;
#line 1475
        port->bt.hexdump = port->wt.hexdump;
#line 1476
        goto out;
      } else {
#line 1470
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1477
    if (port->dinfo.trace_read.file) {
      {
#line 1477
      tmp___0 = strcmp((char const   *)port->dinfo.trace_both.file, (char const   *)port->dinfo.trace_read.file);
      }
#line 1477
      if (tmp___0 == 0) {
#line 1480
        port->bt.file = port->rt.file;
#line 1481
        port->bt.timestamp = port->rt.timestamp;
#line 1482
        port->bt.hexdump = port->rt.hexdump;
#line 1483
        goto out;
      }
    }
    {
#line 1485
    open_trace_file(port, & port->dinfo.trace_both, & port->bt, & tv);
    }
  } else {
#line 1487
    port->bt.file = -1;
  }
  out: 
#line 1489
  return;
}
}
#line 1493 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static int setup_tcp_port(port_info_t *port ) 
{ 
  int options ;
  struct timeval then ;
  void (*tcp_write_handler)(int fd , void *data ) ;
  void (*dev_write_handler)(int fd , void *data ) ;
  int tmp ;
  int tmp___0 ;
  int rv ;
  char *err ;
  size_t tmp___1 ;
  char *err___0 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void (*tmp___5)(int fd , void *data ) ;
  int tmp___6 ;

  {
  {
#line 1501
  tmp = fcntl(port->tcpfd, 4, 2048);
  }
#line 1501
  if (tmp == -1) {
    {
#line 1502
    close(port->tcpfd);
#line 1503
    port->tcpfd = -1;
#line 1504
    syslog(3, "Could not fcntl the tcp port %s: %m", port->portname);
    }
#line 1505
    return (-1);
  }
  {
#line 1507
  options = 1;
#line 1508
  tmp___0 = setsockopt(port->tcpfd, 6, 1, (void const   *)((char *)(& options)), (socklen_t )sizeof(options));
  }
#line 1508
  if (tmp___0 == -1) {
    {
#line 1510
    close(port->tcpfd);
#line 1511
    port->tcpfd = -1;
#line 1512
    syslog(3, "Could not enable TCP_NODELAY tcp port %s: %m", port->portname);
    }
#line 1514
    return (-1);
  }
  {
#line 1538
  rv = uucp_mk_lock(port->devname);
  }
#line 1539
  if (rv > 0) {
    {
#line 1542
    err = (char *)"Port already in use by another process\n\r";
#line 1543
    tmp___1 = strlen((char const   *)err);
#line 1543
    write_ignore_fail(port->tcpfd, err, tmp___1);
#line 1544
    close(port->tcpfd);
#line 1545
    port->tcpfd = -1;
    }
#line 1546
    return (-1);
  } else
#line 1547
  if (rv < 0) {
    {
#line 1550
    err___0 = (char *)"Error creating port lock file\n\r";
#line 1551
    tmp___2 = strlen((char const   *)err___0);
#line 1551
    write_ignore_fail(port->tcpfd, err___0, tmp___2);
#line 1552
    close(port->tcpfd);
#line 1553
    port->tcpfd = -1;
    }
#line 1554
    return (-1);
  }
#line 1561
  options = 2304;
#line 1562
  if (port->enabled == 2) {
#line 1563
    options |= 1;
  } else {
#line 1565
    options |= 2;
  }
  {
#line 1567
  port->devfd = open((char const   *)port->devname, options);
  }
#line 1568
  if (port->devfd == -1) {
    {
#line 1569
    close(port->tcpfd);
#line 1570
    port->tcpfd = -1;
#line 1571
    syslog(3, "Could not open device %s for port %s: %m", port->devname, port->portname);
#line 1575
    uucp_rm_lock(port->devname);
    }
#line 1577
    return (-1);
  }
#line 1580
  if (port->enabled != 2) {
#line 1580
    if (! port->dinfo.disablebreak) {
      {
#line 1580
      tmp___3 = tcsetattr(port->devfd, 0, (struct termios  const  *)(& port->dinfo.termctl));
      }
#line 1580
      if (tmp___3 == -1) {
        {
#line 1584
        close(port->tcpfd);
#line 1585
        port->tcpfd = -1;
#line 1586
        close(port->devfd);
#line 1587
        port->devfd = -1;
#line 1588
        syslog(3, "Could not set up device %s for port %s: %m", port->devname, port->portname);
#line 1592
        uucp_rm_lock(port->devname);
        }
#line 1594
        return (-1);
      }
    }
  }
#line 1598
  if (port->enabled != 2) {
    {
#line 1598
    tmp___4 = ioctl(port->devfd, 21544UL);
    }
#line 1598
    if (tmp___4 == -1) {
      {
#line 1601
      syslog(3, "Could not turn off break for device %s port %s: %m", port->devname,
             port->portname);
      }
    }
  }
  {
#line 1605
  port->is_2217 = 0;
#line 1606
  port->break_set = 0;
#line 1608
  port->banner = process_str_to_buf(port, port->dinfo.banner);
  }
#line 1609
  if (port->banner) {
#line 1610
    tcp_write_handler = & handle_tcp_fd_banner_write;
  } else {
#line 1612
    tcp_write_handler = & handle_tcp_fd_write___0;
  }
  {
#line 1614
  port->devstr = process_str_to_buf(port, port->dinfo.openstr);
  }
#line 1615
  if (port->devstr) {
#line 1616
    dev_write_handler = & handle_dev_fd_devstr_write;
  } else {
#line 1618
    dev_write_handler = & handle_dev_fd_write;
  }
#line 1620
  if (port->dinfo.closestr) {
    {
#line 1621
    port->closestr = strdup((char const   *)port->dinfo.closestr);
    }
  } else {
#line 1623
    port->closestr = (char *)((void *)0);
  }
#line 1625
  if (port->enabled == 2) {
#line 1625
    tmp___5 = (void (*)(int fd , void *data ))((void *)0);
  } else {
#line 1625
    tmp___5 = & handle_dev_fd_read;
  }
  {
#line 1625
  sel_set_fd_handlers(ser2net_sel, port->devfd, (void *)port, tmp___5, dev_write_handler,
                      & handle_dev_fd_except);
  }
#line 1633
  if (port->enabled == 2) {
#line 1633
    tmp___6 = 1;
  } else {
#line 1633
    tmp___6 = 0;
  }
  {
#line 1633
  sel_set_fd_read_handler(ser2net_sel, port->devfd, tmp___6);
#line 1638
  sel_set_fd_except_handler(ser2net_sel, port->devfd, 0);
  }
#line 1640
  if (port->devstr) {
    {
#line 1641
    sel_set_fd_write_handler(ser2net_sel, port->devfd, 0);
    }
  }
  {
#line 1643
  port->dev_to_tcp_state = 1;
#line 1645
  sel_set_fd_handlers(ser2net_sel, port->tcpfd, (void *)port, & handle_tcp_fd_read___0,
                      tcp_write_handler, & handle_tcp_fd_except___0);
#line 1651
  sel_set_fd_read_handler(ser2net_sel, port->tcpfd, 0);
#line 1653
  sel_set_fd_except_handler(ser2net_sel, port->tcpfd, 0);
#line 1655
  port->tcp_to_dev_state = 1;
  }
#line 1657
  if (port->enabled == 3) {
    {
#line 1658
    telnet_init(& port->tn_data, (void *)port, & telnet_output_ready___0, & telnet_cmd_handler___0,
                telnet_cmds___0, telnet_init_seq___0, (int )sizeof(telnet_init_seq___0));
    }
  } else {
    {
#line 1663
    buffer_init(& port->tn_data.out_telnet_cmd, (unsigned char *)((void *)0), 0U);
#line 1664
    sel_set_fd_read_handler(ser2net_sel, port->devfd, 0);
    }
#line 1666
    if (port->banner) {
      {
#line 1667
      sel_set_fd_write_handler(ser2net_sel, port->tcpfd, 0);
      }
    }
  }
  {
#line 1671
  setup_trace(port);
#line 1672
  header_trace(port);
#line 1674
  gettimeofday((struct timeval */* __restrict  */)(& then), (__timezone_ptr_t )((void *)0));
#line 1675
  (then.tv_sec) ++;
#line 1676
  sel_start_timer(port->timer, & then);
#line 1678
  reset_timer(port);
  }
#line 1679
  return (0);
}
}
#line 1683 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void handle_accept_port_read___0(int fd , void *data ) 
{ 
  port_info_t *port ;
  socklen_t len ;
  char *err ;
  int optval ;
  int tmp ;
  struct sockaddr_storage dummy_sockaddr ;
  socklen_t len___0 ;
  int new_fd ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 1686
  port = (port_info_t *)data;
#line 1688
  err = (char *)((void *)0);
#line 1691
  if (port->tcp_to_dev_state != 0) {
#line 1692
    err = (char *)"Port already in use\n\r";
  } else {
    {
#line 1693
    tmp = is_device_already_inuse(port);
    }
#line 1693
    if (tmp) {
#line 1694
      err = (char *)"Port\'s device already in use\n\r";
    }
  }
#line 1697
  if ((unsigned long )err != (unsigned long )((void *)0)) {
    {
#line 1699
    len___0 = (socklen_t )sizeof(dummy_sockaddr);
#line 1700
    tmp___0 = accept(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dummy_sockaddr)),
                     (socklen_t */* __restrict  */)(& len___0));
#line 1700
    new_fd = tmp___0;
    }
#line 1702
    if (new_fd != -1) {
      {
#line 1703
      tmp___1 = strlen((char const   *)err);
#line 1703
      write_ignore_fail(new_fd, err, tmp___1);
#line 1704
      close(new_fd);
      }
    }
#line 1706
    return;
  }
  {
#line 1709
  len = (socklen_t )sizeof(port->remote);
#line 1711
  port->tcpfd = accept(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& port->remote)),
                       (socklen_t */* __restrict  */)(& len));
  }
#line 1712
  if (port->tcpfd == -1) {
    {
#line 1713
    syslog(3, "Could not accept on port %s: %m", port->portname);
    }
#line 1714
    return;
  }
  {
#line 1717
  optval = 1;
#line 1718
  tmp___2 = setsockopt(port->tcpfd, 1, 9, (void const   *)((void *)(& optval)), (socklen_t )sizeof(optval));
  }
#line 1718
  if (tmp___2 == -1) {
    {
#line 1720
    close(port->tcpfd);
#line 1721
    syslog(3, "Could not enable SO_KEEPALIVE on tcp port %s: %m", port->portname);
    }
#line 1723
    return;
  }
  {
#line 1727
  setup_tcp_port(port);
  }
#line 1728
  return;
}
}
#line 1731 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static char *startup_port(port_info_t *port ) 
{ 
  int optval ;
  int portnum ;
  char *err ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1734
  optval = 1;
#line 1737
  portnum = port_from_in_addr((int )port->tcpport.ss_family, (struct sockaddr *)(& port->tcpport));
  }
#line 1739
  if (portnum == 0) {
    {
#line 1741
    tmp___1 = is_device_already_inuse(port);
    }
#line 1741
    if (tmp___1) {
      {
#line 1742
      err = (char *)"Port\'s device already in use\n\r";
#line 1743
      tmp = strlen((char const   *)err);
#line 1743
      write_ignore_fail(0, err, tmp);
#line 1744
      exit(1);
      }
    } else {
      {
#line 1746
      port->acceptfd = -1;
#line 1747
      port->tcpfd = 0;
#line 1748
      tmp___0 = setup_tcp_port(port);
      }
#line 1748
      if (tmp___0 == -1) {
        {
#line 1749
        exit(1);
        }
      }
    }
#line 1751
    return ((char *)((void *)0));
  }
  {
#line 1754
  tmp___2 = scan_tcp_port(port->portname, 0, & port->tcpport, & port->tcpport_len);
  }
#line 1754
  if (tmp___2 == -1) {
#line 1758
    return ((char *)"port number was invalid");
  }
  {
#line 1760
  port->acceptfd = socket((int )port->tcpport.ss_family, 1, 0);
  }
#line 1761
  if (port->acceptfd == -1) {
    {
#line 1761
    tmp___4 = __errno_location();
    }
#line 1761
    if (*tmp___4 == 97) {
      {
#line 1763
      tmp___3 = scan_tcp_port(port->portname, 2, & port->tcpport, & port->tcpport_len);
      }
#line 1763
      if (tmp___3 == -1) {
#line 1767
        return ((char *)"port number was invalid");
      }
      {
#line 1769
      port->acceptfd = socket((int )port->tcpport.ss_family, 1, 0);
      }
    }
  }
#line 1771
  if (port->acceptfd == -1) {
#line 1772
    return ((char *)"Unable to create TCP socket");
  }
  {
#line 1775
  tmp___5 = fcntl(port->acceptfd, 4, 2048);
  }
#line 1775
  if (tmp___5 == -1) {
    {
#line 1776
    close(port->acceptfd);
    }
#line 1777
    return ((char *)"Could not fcntl the accept port");
  }
  {
#line 1780
  tmp___6 = setsockopt(port->acceptfd, 1, 2, (void const   *)((void *)(& optval)),
                       (socklen_t )sizeof(optval));
  }
#line 1780
  if (tmp___6 == -1) {
    {
#line 1785
    close(port->acceptfd);
    }
#line 1786
    return ((char *)"Unable to set reuseaddress on socket");
  }
  {
#line 1789
  check_ipv6_only((int )port->tcpport.ss_family, (struct sockaddr *)(& port->tcpport),
                  port->acceptfd);
#line 1793
  tmp___7 = bind(port->acceptfd, (struct sockaddr  const  *)((struct sockaddr *)(& port->tcpport)),
                 port->tcpport_len);
  }
#line 1793
  if (tmp___7 == -1) {
    {
#line 1796
    close(port->acceptfd);
    }
#line 1797
    return ((char *)"Unable to bind TCP port");
  }
  {
#line 1800
  tmp___8 = listen(port->acceptfd, 1);
  }
#line 1800
  if (tmp___8 != 0) {
    {
#line 1801
    close(port->acceptfd);
    }
#line 1802
    return ((char *)"Unable to listen to TCP port");
  }
  {
#line 1805
  sel_set_fd_handlers(ser2net_sel, port->acceptfd, (void *)port, & handle_accept_port_read___0,
                      (void (*)(int fd , void *data ))((void *)0), (void (*)(int fd ,
                                                                             void *data ))((void *)0));
#line 1811
  sel_set_fd_read_handler(ser2net_sel, port->acceptfd, 0);
  }
#line 1814
  return ((char *)((void *)0));
}
}
#line 1817 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
char *change_port_state(port_info_t *port , int state ) 
{ 
  char *rv ;

  {
#line 1820
  rv = (char *)((void *)0);
#line 1822
  if (port->enabled == state) {
#line 1823
    return (rv);
  }
#line 1826
  if (state == 0) {
#line 1827
    if (port->acceptfd != -1) {
      {
#line 1828
      sel_set_fd_read_handler(ser2net_sel, port->acceptfd, 1);
#line 1831
      sel_clear_fd_handlers(ser2net_sel, port->acceptfd);
#line 1832
      close(port->acceptfd);
#line 1833
      port->acceptfd = -1;
      }
    }
  } else
#line 1835
  if (port->enabled == 0) {
    {
#line 1836
    rv = startup_port(port);
    }
  }
#line 1839
  port->enabled = state;
#line 1841
  return (rv);
}
}
#line 1844 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void free_port(port_info_t *port ) 
{ 


  {
  {
#line 1847
  sel_free_timer(port->timer);
#line 1848
  change_port_state(port, 0);
  }
#line 1849
  if ((unsigned long )port->portname != (unsigned long )((void *)0)) {
    {
#line 1850
    free((void *)port->portname);
    }
  }
#line 1852
  if ((unsigned long )port->devname != (unsigned long )((void *)0)) {
    {
#line 1853
    free((void *)port->devname);
    }
  }
#line 1855
  if ((unsigned long )port->new_config != (unsigned long )((void *)0)) {
    {
#line 1856
    free_port(port->new_config);
    }
  }
  {
#line 1858
  free((void *)port);
  }
#line 1859
  return;
}
}
#line 1861 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void finish_shutdown_port(port_info_t *port ) 
{ 
  int portnum ;
  port_info_t *curr ;
  port_info_t *prev ;
  port_info_t *curr___0 ;
  port_info_t *prev___0 ;

  {
#line 1868
  if (port->devfd != -1) {
    {
#line 1869
    sel_clear_fd_handlers(ser2net_sel, port->devfd);
#line 1870
    tcflush(port->devfd, 1);
#line 1871
    close(port->devfd);
#line 1872
    port->devfd = -1;
    }
  }
  {
#line 1875
  uucp_rm_lock(port->devname);
#line 1877
  port->tcp_to_dev_state = 0;
  }
  {
#line 1878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1878
    port->tcp_to_dev.cursize = 0U;
#line 1878
    port->tcp_to_dev.pos = 0U;
#line 1878
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1879
  port->tcp_bytes_received = 0U;
#line 1880
  port->tcp_bytes_sent = 0U;
#line 1881
  if (port->banner) {
    {
#line 1882
    free((void *)(port->banner)->buf);
#line 1883
    free((void *)port->banner);
#line 1884
    port->banner = (struct sbuf *)((void *)0);
    }
  }
#line 1886
  if (port->devstr) {
    {
#line 1887
    free((void *)(port->devstr)->buf);
#line 1888
    free((void *)port->devstr);
#line 1889
    port->devstr = (struct sbuf *)((void *)0);
    }
  }
#line 1891
  if (port->closestr) {
    {
#line 1892
    free((void *)port->closestr);
    }
  }
#line 1893
  port->dev_to_tcp_state = 0;
  {
#line 1894
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1894
    port->dev_to_tcp.cursize = 0U;
#line 1894
    port->dev_to_tcp.pos = 0U;
#line 1894
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1895
  port->dev_bytes_received = 0U;
#line 1896
  port->dev_bytes_sent = 0U;
#line 1898
  portnum = port_from_in_addr((int )port->tcpport.ss_family, (struct sockaddr *)(& port->tcpport));
  }
#line 1900
  if (portnum == 0) {
    {
#line 1904
    exit(0);
    }
  }
#line 1910
  if (port->config_num == -1) {
    {
#line 1913
    change_port_state(port, 0);
#line 1914
    prev = (port_info_t *)((void *)0);
#line 1915
    curr = ports;
    }
    {
#line 1916
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1916
      if ((unsigned long )curr != (unsigned long )((void *)0)) {
#line 1916
        if (! ((unsigned long )curr != (unsigned long )port)) {
#line 1916
          goto while_break___1;
        }
      } else {
#line 1916
        goto while_break___1;
      }
#line 1917
      prev = curr;
#line 1918
      curr = curr->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1920
    if ((unsigned long )curr != (unsigned long )((void *)0)) {
#line 1921
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 1922
        ports = curr->next;
      } else {
#line 1924
        prev->next = curr->next;
      }
      {
#line 1926
      free_port(curr);
      }
    }
#line 1929
    return;
  }
#line 1932
  if ((unsigned long )port->new_config != (unsigned long )((void *)0)) {
#line 1935
    prev___0 = (port_info_t *)((void *)0);
#line 1936
    curr___0 = ports;
    {
#line 1937
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1937
      if ((unsigned long )curr___0 != (unsigned long )((void *)0)) {
#line 1937
        if (! ((unsigned long )curr___0 != (unsigned long )port)) {
#line 1937
          goto while_break___2;
        }
      } else {
#line 1937
        goto while_break___2;
      }
#line 1938
      prev___0 = curr___0;
#line 1939
      curr___0 = curr___0->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1941
    if ((unsigned long )curr___0 != (unsigned long )((void *)0)) {
      {
#line 1942
      port = curr___0->new_config;
#line 1943
      port->acceptfd = curr___0->acceptfd;
#line 1944
      sel_set_fd_handlers(ser2net_sel, port->acceptfd, (void *)port, & handle_accept_port_read___0,
                          (void (*)(int fd , void *data ))((void *)0), (void (*)(int fd ,
                                                                                 void *data ))((void *)0));
#line 1950
      curr___0->acceptfd = -1;
#line 1951
      port->next = curr___0->next;
      }
#line 1952
      if ((unsigned long )prev___0 == (unsigned long )((void *)0)) {
#line 1953
        ports = port;
      } else {
#line 1955
        prev___0->next = port;
      }
      {
#line 1957
      curr___0->enabled = 0;
#line 1958
      curr___0->new_config = (struct port_info *)((void *)0);
#line 1959
      free_port(curr___0);
      }
    }
  }
#line 1962
  return;
}
}
#line 1964 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void shutdown_port(port_info_t *port , char *reason ) 
{ 


  {
  {
#line 1967
  footer_trace(port, reason);
  }
#line 1969
  if (port->wt.file != -1) {
    {
#line 1970
    close(port->wt.file);
    }
#line 1971
    if (port->rt.file == port->wt.file) {
#line 1972
      port->rt.file = -1;
    }
#line 1973
    if (port->bt.file == port->wt.file) {
#line 1974
      port->bt.file = -1;
    }
#line 1975
    port->wt.file = -1;
  }
#line 1977
  if (port->rt.file != -1) {
    {
#line 1978
    close(port->rt.file);
    }
#line 1979
    if (port->bt.file == port->rt.file) {
#line 1980
      port->bt.file = -1;
    }
#line 1981
    port->rt.file = -1;
  }
#line 1983
  if (port->bt.file != -1) {
    {
#line 1984
    close(port->bt.file);
#line 1985
    port->bt.file = -1;
    }
  }
  {
#line 1987
  sel_stop_timer(port->timer);
  }
#line 1988
  if (port->tcpfd != -1) {
    {
#line 1989
    sel_clear_fd_handlers(ser2net_sel, port->tcpfd);
#line 1990
    close(port->tcpfd);
#line 1991
    port->tcpfd = -1;
    }
  }
#line 1994
  if (port->devstr) {
    {
#line 1995
    free((void *)(port->devstr)->buf);
#line 1996
    free((void *)port->devstr);
    }
  }
  {
#line 1998
  port->devstr = process_str_to_buf(port, port->closestr);
  }
#line 1999
  if (port->devstr) {
#line 1999
    if (port->devfd != -1) {
      {
#line 2000
      port->tcp_to_dev_state = 3;
#line 2001
      sel_set_fd_read_handler(ser2net_sel, port->devfd, 1);
#line 2003
      sel_set_fd_except_handler(ser2net_sel, port->devfd, 1);
#line 2005
      sel_set_fd_handlers(ser2net_sel, port->devfd, (void *)port, (void (*)(int fd ,
                                                                            void *data ))((void *)0),
                          & handle_dev_fd_close_write, (void (*)(int fd , void *data ))((void *)0));
#line 2011
      sel_set_fd_write_handler(ser2net_sel, port->devfd, 0);
      }
    } else {
      {
#line 2014
      finish_shutdown_port(port);
      }
    }
  } else {
    {
#line 2014
    finish_shutdown_port(port);
    }
  }
#line 2015
  return;
}
}
#line 2017 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void got_timeout(selector_t *sel , sel_timer_t *timer , void *data ) 
{ 
  port_info_t *port ;
  struct timeval then ;
  unsigned char modemstate ;
  int val ;
  unsigned char data___0[3] ;
  int tmp ;

  {
#line 2022
  port = (port_info_t *)data;
#line 2027
  if (port->timeout) {
#line 2028
    (port->timeout_left) --;
#line 2029
    if (port->timeout_left < 0) {
      {
#line 2030
      shutdown_port(port, (char *)"timeout");
      }
#line 2031
      return;
    }
  }
#line 2035
  if (port->is_2217) {
    {
#line 2035
    tmp = ioctl(port->devfd, 21525UL, & val);
    }
#line 2035
    if (tmp != -1) {
#line 2036
      modemstate = (unsigned char)0;
#line 2037
      if (val & 64) {
#line 2038
        modemstate = (unsigned char )((int )modemstate | 128);
      }
#line 2039
      if (val & 128) {
#line 2040
        modemstate = (unsigned char )((int )modemstate | 64);
      }
#line 2041
      if (val & 256) {
#line 2042
        modemstate = (unsigned char )((int )modemstate | 32);
      }
#line 2043
      if (val & 32) {
#line 2044
        modemstate = (unsigned char )((int )modemstate | 16);
      }
#line 2046
      modemstate = (unsigned char )((int )modemstate & (int )port->modemstate_mask);
#line 2047
      if ((int )modemstate != (int )port->last_modemstate) {
        {
#line 2049
        data___0[0] = (unsigned char)44;
#line 2050
        data___0[1] = (unsigned char)107;
#line 2051
        data___0[2] = modemstate;
#line 2052
        port->last_modemstate = modemstate;
#line 2053
        telnet_send_option(& port->tn_data, data___0, 3);
        }
      }
    }
  }
  {
#line 2057
  gettimeofday((struct timeval */* __restrict  */)(& then), (__timezone_ptr_t )((void *)0));
#line 2058
  (then.tv_sec) ++;
#line 2059
  sel_start_timer(port->timer, & then);
  }
#line 2060
  return;
}
}
#line 2063 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
char *portconfig(char *portnum , char *state , char *timeout , char *devname , char *devcfg ,
                 int config_num___0 ) 
{ 
  port_info_t *new_port ;
  port_info_t *curr ;
  port_info_t *prev ;
  char *rv ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int new_state ;
  int tmp___11 ;

  {
  {
#line 2072
  rv = (char *)((void *)0);
#line 2074
  tmp = malloc(sizeof(port_info_t ));
#line 2074
  new_port = (port_info_t *)tmp;
  }
#line 2075
  if ((unsigned long )new_port == (unsigned long )((void *)0)) {
#line 2076
    return ((char *)"Could not allocate a port data structure");
  }
  {
#line 2079
  tmp___0 = sel_alloc_timer(ser2net_sel, & got_timeout, (void *)new_port, & new_port->timer);
  }
#line 2079
  if (tmp___0) {
    {
#line 2083
    free((void *)new_port);
    }
#line 2084
    return ((char *)"Could not allocate timer data");
  }
  {
#line 2088
  init_port_data(new_port);
#line 2090
  tmp___1 = strlen((char const   *)portnum);
#line 2090
  tmp___2 = malloc(tmp___1 + 1UL);
#line 2090
  new_port->portname = (char *)tmp___2;
  }
#line 2091
  if ((unsigned long )new_port->portname == (unsigned long )((void *)0)) {
#line 2092
    rv = (char *)"unable to allocate port name";
#line 2093
    goto errout;
  }
  {
#line 2095
  strcpy((char */* __restrict  */)new_port->portname, (char const   */* __restrict  */)portnum);
#line 2097
  tmp___3 = scan_tcp_port(new_port->portname, 0, & new_port->tcpport, & new_port->tcpport_len);
  }
#line 2097
  if (tmp___3 == -1) {
#line 2101
    rv = (char *)"port number was invalid";
#line 2102
    goto errout;
  }
  {
#line 2105
  tmp___7 = strcmp((char const   *)state, "raw");
  }
#line 2105
  if (tmp___7 == 0) {
#line 2106
    new_port->enabled = 1;
  } else {
    {
#line 2107
    tmp___6 = strcmp((char const   *)state, "rawlp");
    }
#line 2107
    if (tmp___6 == 0) {
#line 2108
      new_port->enabled = 2;
    } else {
      {
#line 2109
      tmp___5 = strcmp((char const   *)state, "telnet");
      }
#line 2109
      if (tmp___5 == 0) {
#line 2110
        new_port->enabled = 3;
      } else {
        {
#line 2111
        tmp___4 = strcmp((char const   *)state, "off");
        }
#line 2111
        if (tmp___4 == 0) {
#line 2112
          new_port->enabled = 0;
        } else {
#line 2114
          rv = (char *)"state was invalid";
#line 2115
          goto errout;
        }
      }
    }
  }
  {
#line 2118
  new_port->timeout = scan_int(timeout);
  }
#line 2119
  if (new_port->timeout == -1) {
#line 2120
    rv = (char *)"timeout was invalid";
#line 2121
    goto errout;
  }
  {
#line 2124
  devinit(& new_port->dinfo.termctl);
#line 2126
  tmp___8 = devconfig(devcfg, & new_port->dinfo);
  }
#line 2126
  if (tmp___8 == -1) {
#line 2127
    rv = (char *)"device configuration invalid";
#line 2128
    goto errout;
  }
#line 2132
  if (! new_port->dinfo.signature) {
#line 2133
    new_port->dinfo.signature = rfc2217_signature;
  }
  {
#line 2135
  tmp___9 = strlen((char const   *)devname);
#line 2135
  tmp___10 = malloc(tmp___9 + 1UL);
#line 2135
  new_port->devname = (char *)tmp___10;
  }
#line 2136
  if ((unsigned long )new_port->devname == (unsigned long )((void *)0)) {
#line 2137
    rv = (char *)"could not allocate device name";
#line 2138
    goto errout;
  }
  {
#line 2140
  strcpy((char */* __restrict  */)new_port->devname, (char const   */* __restrict  */)devname);
#line 2142
  new_port->config_num = config_num___0;
#line 2145
  curr = ports;
#line 2146
  prev = (port_info_t *)((void *)0);
  }
  {
#line 2147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2147
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 2147
      goto while_break;
    }
    {
#line 2148
    tmp___11 = strcmp((char const   *)curr->portname, (char const   *)new_port->portname);
    }
#line 2148
    if (tmp___11 == 0) {
#line 2150
      if (curr->dev_to_tcp_state == 0) {
        {
#line 2152
        new_state = new_port->enabled;
#line 2154
        new_port->enabled = curr->enabled;
#line 2155
        new_port->acceptfd = curr->acceptfd;
#line 2156
        curr->enabled = 0;
#line 2157
        curr->acceptfd = -1;
#line 2158
        sel_set_fd_handlers(ser2net_sel, new_port->acceptfd, (void *)new_port, & handle_accept_port_read___0,
                            (void (*)(int fd , void *data ))((void *)0), (void (*)(int fd ,
                                                                                   void *data ))((void *)0));
        }
#line 2166
        if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 2167
          ports = new_port;
        } else {
#line 2169
          prev->next = new_port;
        }
        {
#line 2171
        new_port->next = curr->next;
#line 2172
        free_port(curr);
#line 2174
        change_port_state(new_port, new_state);
        }
      } else {
#line 2177
        if ((unsigned long )curr->new_config != (unsigned long )((void *)0)) {
          {
#line 2178
          curr->enabled = 0;
#line 2179
          free((void *)curr->new_config);
          }
        }
#line 2181
        curr->config_num = config_num___0;
#line 2182
        curr->new_config = new_port;
      }
#line 2184
      return (rv);
    } else {
#line 2186
      prev = curr;
#line 2187
      curr = curr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2194
  if (new_port->enabled != 0) {
    {
#line 2195
    rv = startup_port(new_port);
    }
#line 2196
    if (rv) {
#line 2197
      goto errout;
    }
  }
#line 2201
  new_port->next = (struct port_info *)((void *)0);
#line 2202
  if ((unsigned long )ports == (unsigned long )((void *)0)) {
#line 2203
    ports = new_port;
  } else {
#line 2205
    curr = ports;
    {
#line 2206
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2206
      if (! ((unsigned long )curr->next != (unsigned long )((void *)0))) {
#line 2206
        goto while_break___0;
      }
#line 2207
      curr = curr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2209
    curr->next = new_port;
  }
#line 2212
  return (rv);
  errout: 
  {
#line 2215
  free_port(new_port);
  }
#line 2216
  return (rv);
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void clear_old_port_config(int curr_config ) 
{ 
  port_info_t *curr ;
  port_info_t *prev ;

  {
#line 2224
  curr = ports;
#line 2225
  prev = (port_info_t *)((void *)0);
  {
#line 2226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2226
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 2226
      goto while_break;
    }
#line 2227
    if (curr->config_num != curr_config) {
#line 2229
      if (curr->dev_to_tcp_state == 0) {
#line 2230
        if ((unsigned long )prev == (unsigned long )((void *)0)) {
          {
#line 2231
          ports = curr->next;
#line 2232
          free_port(curr);
#line 2233
          curr = ports;
          }
        } else {
          {
#line 2235
          prev->next = curr->next;
#line 2236
          free_port(curr);
#line 2237
          curr = prev->next;
          }
        }
      } else {
#line 2240
        curr->config_num = -1;
#line 2241
        prev = curr;
#line 2242
        curr = curr->next;
      }
    } else {
#line 2245
      prev = curr;
#line 2246
      curr = curr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2249
  return;
}
}
#line 2252 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void showshortport(struct controller_info *cntlr , port_info_t *port ) 
{ 
  char buffer[1025] ;
  char portbuff[32] ;
  int count ;
  int need_space ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 2257
  need_space = 0;
#line 2259
  snprintf((char */* __restrict  */)(buffer), (size_t )23, (char const   */* __restrict  */)"%-22s",
           port->portname);
#line 2260
  tmp = strlen((char const   *)(buffer));
#line 2260
  controller_output(cntlr, buffer, (int )tmp);
#line 2262
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)" %-6s ",
          enabled_str[port->enabled]);
#line 2263
  tmp___0 = strlen((char const   *)(buffer));
#line 2263
  controller_output(cntlr, buffer, (int )tmp___0);
#line 2265
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%7d ",
          port->timeout);
#line 2266
  tmp___1 = strlen((char const   *)(buffer));
#line 2266
  controller_output(cntlr, buffer, (int )tmp___1);
#line 2268
  getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& port->remote)),
              (socklen_t )sizeof(port->remote), (char */* __restrict  */)(buffer),
              (socklen_t )sizeof(buffer), (char */* __restrict  */)(portbuff), (socklen_t )sizeof(portbuff),
              3);
#line 2272
  tmp___2 = strlen((char const   *)(buffer));
#line 2272
  count = (int )tmp___2;
#line 2273
  controller_output(cntlr, buffer, count);
#line 2274
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)",%s ",
          portbuff);
#line 2275
  tmp___3 = strlen((char const   *)(buffer));
#line 2275
  count = (int )((size_t )count + tmp___3);
#line 2276
  tmp___4 = strlen((char const   *)(buffer));
#line 2276
  controller_output(cntlr, buffer, (int )tmp___4);
  }
  {
#line 2277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2277
    if (! (count < 23)) {
#line 2277
      goto while_break;
    }
    {
#line 2278
    controller_output(cntlr, (char *)" ", 1);
#line 2279
    count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2282
  snprintf((char */* __restrict  */)(buffer), (size_t )23, (char const   */* __restrict  */)"%-22s",
           port->devname);
#line 2283
  tmp___5 = strlen((char const   *)(buffer));
#line 2283
  controller_output(cntlr, buffer, (int )tmp___5);
#line 2285
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)" %-14s ",
          state_str[port->tcp_to_dev_state]);
#line 2286
  tmp___6 = strlen((char const   *)(buffer));
#line 2286
  controller_output(cntlr, buffer, (int )tmp___6);
#line 2288
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%-14s ",
          state_str[port->dev_to_tcp_state]);
#line 2289
  tmp___7 = strlen((char const   *)(buffer));
#line 2289
  controller_output(cntlr, buffer, (int )tmp___7);
#line 2291
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%9d ",
          port->tcp_bytes_received);
#line 2292
  tmp___8 = strlen((char const   *)(buffer));
#line 2292
  controller_output(cntlr, buffer, (int )tmp___8);
#line 2294
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%9d ",
          port->tcp_bytes_sent);
#line 2295
  tmp___9 = strlen((char const   *)(buffer));
#line 2295
  controller_output(cntlr, buffer, (int )tmp___9);
#line 2297
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%9d ",
          port->dev_bytes_received);
#line 2298
  tmp___10 = strlen((char const   *)(buffer));
#line 2298
  controller_output(cntlr, buffer, (int )tmp___10);
#line 2300
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%9d ",
          port->dev_bytes_sent);
#line 2301
  tmp___11 = strlen((char const   *)(buffer));
#line 2301
  controller_output(cntlr, buffer, (int )tmp___11);
  }
#line 2304
  if (port->enabled != 2) {
    {
#line 2305
    show_devcfg(cntlr, & port->dinfo.termctl);
#line 2306
    need_space = 1;
    }
  }
#line 2309
  if (port->tcp_to_dev_state != 0) {
#line 2310
    if (need_space) {
      {
#line 2311
      controller_output(cntlr, (char *)" ", 1);
      }
    }
    {
#line 2314
    show_devcontrol(cntlr, port->devfd);
    }
  }
  {
#line 2316
  controller_output(cntlr, (char *)"\n\r", 2);
  }
#line 2318
  return;
}
}
#line 2321 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void showport(struct controller_info *cntlr , port_info_t *port ) 
{ 
  char *str ;
  char buffer[1025] ;
  char portbuff[32] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;

  {
  {
#line 2327
  str = (char *)"TCP Port ";
#line 2328
  tmp = strlen((char const   *)str);
#line 2328
  controller_output(cntlr, str, (int )tmp);
#line 2329
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s",
          port->portname);
#line 2330
  tmp___0 = strlen((char const   *)(buffer));
#line 2330
  controller_output(cntlr, buffer, (int )tmp___0);
#line 2331
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2333
  str = (char *)"  enable state: ";
#line 2334
  tmp___1 = strlen((char const   *)str);
#line 2334
  controller_output(cntlr, str, (int )tmp___1);
#line 2335
  str = enabled_str[port->enabled];
#line 2336
  tmp___2 = strlen((char const   *)str);
#line 2336
  controller_output(cntlr, str, (int )tmp___2);
#line 2337
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2339
  str = (char *)"  timeout: ";
#line 2340
  tmp___3 = strlen((char const   *)str);
#line 2340
  controller_output(cntlr, str, (int )tmp___3);
#line 2341
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d",
          port->timeout);
#line 2342
  tmp___4 = strlen((char const   *)(buffer));
#line 2342
  controller_output(cntlr, buffer, (int )tmp___4);
#line 2343
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2345
  str = (char *)"  connected to (or last connection): ";
#line 2346
  tmp___5 = strlen((char const   *)str);
#line 2346
  controller_output(cntlr, str, (int )tmp___5);
#line 2347
  getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& port->remote)),
              (socklen_t )sizeof(port->remote), (char */* __restrict  */)(buffer),
              (socklen_t )sizeof(buffer), (char */* __restrict  */)(portbuff), (socklen_t )sizeof(portbuff),
              3);
#line 2351
  tmp___6 = strlen((char const   *)(buffer));
#line 2351
  controller_output(cntlr, buffer, (int )tmp___6);
#line 2352
  controller_output(cntlr, (char *)":", 1);
#line 2353
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)",%s ",
          portbuff);
#line 2354
  tmp___7 = strlen((char const   *)(buffer));
#line 2354
  controller_output(cntlr, buffer, (int )tmp___7);
#line 2355
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2357
  str = (char *)"  device: ";
#line 2358
  tmp___8 = strlen((char const   *)str);
#line 2358
  controller_output(cntlr, str, (int )tmp___8);
#line 2359
  str = port->devname;
#line 2360
  tmp___9 = strlen((char const   *)str);
#line 2360
  controller_output(cntlr, str, (int )tmp___9);
#line 2361
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2363
  str = (char *)"  device config: ";
#line 2364
  tmp___10 = strlen((char const   *)str);
#line 2364
  controller_output(cntlr, str, (int )tmp___10);
  }
#line 2365
  if (port->enabled == 2) {
    {
#line 2366
    str = (char *)"none\n\r";
#line 2367
    tmp___11 = strlen((char const   *)str);
#line 2367
    controller_output(cntlr, str, (int )tmp___11);
    }
  } else {
    {
#line 2369
    show_devcfg(cntlr, & port->dinfo.termctl);
#line 2370
    controller_output(cntlr, (char *)"\n\r", 2);
    }
  }
  {
#line 2373
  str = (char *)"  device controls: ";
#line 2374
  tmp___12 = strlen((char const   *)str);
#line 2374
  controller_output(cntlr, str, (int )tmp___12);
  }
#line 2375
  if (port->tcp_to_dev_state == 0) {
    {
#line 2376
    str = (char *)"not currently connected\n\r";
#line 2377
    tmp___13 = strlen((char const   *)str);
#line 2377
    controller_output(cntlr, str, (int )tmp___13);
    }
  } else {
    {
#line 2379
    show_devcontrol(cntlr, port->devfd);
#line 2380
    controller_output(cntlr, (char *)"\n\r", 2);
    }
  }
  {
#line 2383
  str = (char *)"  tcp to device state: ";
#line 2384
  tmp___14 = strlen((char const   *)str);
#line 2384
  controller_output(cntlr, str, (int )tmp___14);
#line 2385
  str = state_str[port->tcp_to_dev_state];
#line 2386
  tmp___15 = strlen((char const   *)str);
#line 2386
  controller_output(cntlr, str, (int )tmp___15);
#line 2387
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2389
  str = (char *)"  device to tcp state: ";
#line 2390
  tmp___16 = strlen((char const   *)str);
#line 2390
  controller_output(cntlr, str, (int )tmp___16);
#line 2391
  str = state_str[port->dev_to_tcp_state];
#line 2392
  tmp___17 = strlen((char const   *)str);
#line 2392
  controller_output(cntlr, str, (int )tmp___17);
#line 2393
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2395
  str = (char *)"  bytes read from TCP: ";
#line 2396
  tmp___18 = strlen((char const   *)str);
#line 2396
  controller_output(cntlr, str, (int )tmp___18);
#line 2397
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d",
          port->tcp_bytes_received);
#line 2398
  tmp___19 = strlen((char const   *)(buffer));
#line 2398
  controller_output(cntlr, buffer, (int )tmp___19);
#line 2399
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2401
  str = (char *)"  bytes written to TCP: ";
#line 2402
  tmp___20 = strlen((char const   *)str);
#line 2402
  controller_output(cntlr, str, (int )tmp___20);
#line 2403
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d",
          port->tcp_bytes_sent);
#line 2404
  tmp___21 = strlen((char const   *)(buffer));
#line 2404
  controller_output(cntlr, buffer, (int )tmp___21);
#line 2405
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2407
  str = (char *)"  bytes read from device: ";
#line 2408
  tmp___22 = strlen((char const   *)str);
#line 2408
  controller_output(cntlr, str, (int )tmp___22);
#line 2409
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d",
          port->dev_bytes_received);
#line 2410
  tmp___23 = strlen((char const   *)(buffer));
#line 2410
  controller_output(cntlr, buffer, (int )tmp___23);
#line 2411
  controller_output(cntlr, (char *)"\n\r", 2);
#line 2413
  str = (char *)"  bytes written to device: ";
#line 2414
  tmp___24 = strlen((char const   *)str);
#line 2414
  controller_output(cntlr, str, (int )tmp___24);
#line 2415
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d",
          port->dev_bytes_sent);
#line 2416
  tmp___25 = strlen((char const   *)(buffer));
#line 2416
  controller_output(cntlr, buffer, (int )tmp___25);
#line 2417
  controller_output(cntlr, (char *)"\n\r", 2);
  }
#line 2419
  if (port->config_num == -1) {
    {
#line 2420
    str = (char *)"  Port will be deleted when current session closes.\n\r";
#line 2421
    tmp___26 = strlen((char const   *)str);
#line 2421
    controller_output(cntlr, str, (int )tmp___26);
    }
  } else
#line 2422
  if ((unsigned long )port->new_config != (unsigned long )((void *)0)) {
    {
#line 2423
    str = (char *)"  Port will be reconfigured when current session closes.\n\r";
#line 2424
    tmp___27 = strlen((char const   *)str);
#line 2424
    controller_output(cntlr, str, (int )tmp___27);
    }
  }
#line 2426
  return;
}
}
#line 2429 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static port_info_t *find_port_by_num(char *portstr ) 
{ 
  port_info_t *port ;
  int tmp ;

  {
#line 2434
  port = ports;
  {
#line 2435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2435
    if (! ((unsigned long )port != (unsigned long )((void *)0))) {
#line 2435
      goto while_break;
    }
    {
#line 2436
    tmp = strcmp((char const   *)portstr, (char const   *)port->portname);
    }
#line 2436
    if (tmp == 0) {
#line 2437
      return (port);
    }
#line 2439
    port = port->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2442
  return ((port_info_t *)((void *)0));
}
}
#line 2446 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void showports(struct controller_info *cntlr , char *portspec ) 
{ 
  port_info_t *port ;
  char *err ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 2451
  if ((unsigned long )portspec == (unsigned long )((void *)0)) {
#line 2453
    port = ports;
    {
#line 2454
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2454
      if (! ((unsigned long )port != (unsigned long )((void *)0))) {
#line 2454
        goto while_break;
      }
      {
#line 2455
      showport(cntlr, port);
#line 2456
      port = port->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2459
    port = find_port_by_num(portspec);
    }
#line 2460
    if ((unsigned long )port == (unsigned long )((void *)0)) {
      {
#line 2461
      err = (char *)"Invalid port number: ";
#line 2462
      tmp = strlen((char const   *)err);
#line 2462
      controller_output(cntlr, err, (int )tmp);
#line 2463
      tmp___0 = strlen((char const   *)portspec);
#line 2463
      controller_output(cntlr, portspec, (int )tmp___0);
#line 2464
      controller_output(cntlr, (char *)"\n\r", 2);
      }
    } else {
      {
#line 2466
      showport(cntlr, port);
      }
    }
  }
#line 2469
  return;
}
}
#line 2472 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void showshortports(struct controller_info *cntlr , char *portspec ) 
{ 
  port_info_t *port ;
  char buffer[512] ;
  size_t tmp ;
  char *err ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 2478
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%-22s %-6s %7s %-22s %-22s %-14s %-14s %9s %9s %9s %9s %s\n\r",
          "Port name", "Type", "Timeout", "Remote address", "Device", "TCP to device",
          "Device to TCP", "TCP in", "TCP out", "Dev in", "Dev out", "State");
#line 2492
  tmp = strlen((char const   *)(buffer));
#line 2492
  controller_output(cntlr, buffer, (int )tmp);
  }
#line 2493
  if ((unsigned long )portspec == (unsigned long )((void *)0)) {
#line 2495
    port = ports;
    {
#line 2496
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2496
      if (! ((unsigned long )port != (unsigned long )((void *)0))) {
#line 2496
        goto while_break;
      }
      {
#line 2497
      showshortport(cntlr, port);
#line 2498
      port = port->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2501
    port = find_port_by_num(portspec);
    }
#line 2502
    if ((unsigned long )port == (unsigned long )((void *)0)) {
      {
#line 2503
      err = (char *)"Invalid port number: ";
#line 2504
      tmp___0 = strlen((char const   *)err);
#line 2504
      controller_output(cntlr, err, (int )tmp___0);
#line 2505
      tmp___1 = strlen((char const   *)portspec);
#line 2505
      controller_output(cntlr, portspec, (int )tmp___1);
#line 2506
      controller_output(cntlr, (char *)"\n\r", 2);
      }
    } else {
      {
#line 2508
      showshortport(cntlr, port);
      }
    }
  }
#line 2511
  return;
}
}
#line 2516 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void setporttimeout(struct controller_info *cntlr , char *portspec , char *timeout ) 
{ 
  int timeout_num ;
  port_info_t *port ;
  char *err ;
  size_t tmp ;
  size_t tmp___0 ;
  char *err___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 2522
  port = find_port_by_num(portspec);
  }
#line 2523
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 2524
    err = (char *)"Invalid port number: ";
#line 2525
    tmp = strlen((char const   *)err);
#line 2525
    controller_output(cntlr, err, (int )tmp);
#line 2526
    tmp___0 = strlen((char const   *)portspec);
#line 2526
    controller_output(cntlr, portspec, (int )tmp___0);
#line 2527
    controller_output(cntlr, (char *)"\n\r", 2);
    }
  } else {
    {
#line 2529
    timeout_num = scan_int(timeout);
    }
#line 2530
    if (timeout_num == -1) {
      {
#line 2531
      err___0 = (char *)"Invalid timeout: ";
#line 2532
      tmp___1 = strlen((char const   *)err___0);
#line 2532
      controller_output(cntlr, err___0, (int )tmp___1);
#line 2533
      tmp___2 = strlen((char const   *)timeout);
#line 2533
      controller_output(cntlr, timeout, (int )tmp___2);
#line 2534
      controller_output(cntlr, (char *)"\n\r", 2);
      }
    } else {
#line 2536
      port->timeout = timeout_num;
#line 2537
      if (port->tcpfd != -1) {
        {
#line 2538
        reset_timer(port);
        }
      }
    }
  }
#line 2542
  return;
}
}
#line 2547 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void setportdevcfg(struct controller_info *cntlr , char *portspec , char *devcfg ) 
{ 
  port_info_t *port ;
  char *err ;
  size_t tmp ;
  size_t tmp___0 ;
  char *err___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2552
  port = find_port_by_num(portspec);
  }
#line 2553
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 2554
    err = (char *)"Invalid port number: ";
#line 2555
    tmp = strlen((char const   *)err);
#line 2555
    controller_output(cntlr, err, (int )tmp);
#line 2556
    tmp___0 = strlen((char const   *)portspec);
#line 2556
    controller_output(cntlr, portspec, (int )tmp___0);
#line 2557
    controller_output(cntlr, (char *)"\n\r", 2);
    }
  } else {
    {
#line 2559
    tmp___2 = devconfig(devcfg, & port->dinfo);
    }
#line 2559
    if (tmp___2 == -1) {
      {
#line 2561
      err___0 = (char *)"Invalid device config\n\r";
#line 2562
      tmp___1 = strlen((char const   *)err___0);
#line 2562
      controller_output(cntlr, err___0, (int )tmp___1);
      }
    }
  }
#line 2565
  return;
}
}
#line 2570 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void setportcontrol(struct controller_info *cntlr , char *portspec , char *controls ) 
{ 
  port_info_t *port ;
  char *err ;
  size_t tmp ;
  size_t tmp___0 ;
  char *err___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *err___1 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 2575
  port = find_port_by_num(portspec);
  }
#line 2576
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 2577
    err = (char *)"Invalid port number: ";
#line 2578
    tmp = strlen((char const   *)err);
#line 2578
    controller_output(cntlr, err, (int )tmp);
#line 2579
    tmp___0 = strlen((char const   *)portspec);
#line 2579
    controller_output(cntlr, portspec, (int )tmp___0);
#line 2580
    controller_output(cntlr, (char *)"\n\r", 2);
    }
  } else
#line 2581
  if (port->tcp_to_dev_state == 0) {
    {
#line 2582
    err___0 = (char *)"Port is not currently connected: ";
#line 2583
    tmp___1 = strlen((char const   *)err___0);
#line 2583
    controller_output(cntlr, err___0, (int )tmp___1);
#line 2584
    tmp___2 = strlen((char const   *)portspec);
#line 2584
    controller_output(cntlr, portspec, (int )tmp___2);
#line 2585
    controller_output(cntlr, (char *)"\n\r", 2);
    }
  } else {
    {
#line 2587
    tmp___4 = setdevcontrol(controls, port->devfd);
    }
#line 2587
    if (tmp___4 == -1) {
      {
#line 2588
      err___1 = (char *)"Invalid device controls\n\r";
#line 2589
      tmp___3 = strlen((char const   *)err___1);
#line 2589
      controller_output(cntlr, err___1, (int )tmp___3);
      }
    }
  }
#line 2592
  return;
}
}
#line 2595 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void setportenable(struct controller_info *cntlr , char *portspec , char *enable ) 
{ 
  port_info_t *port ;
  int new_enable ;
  char *err ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 2602
  port = find_port_by_num(portspec);
  }
#line 2603
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 2604
    err = (char *)"Invalid port number: ";
#line 2605
    tmp = strlen((char const   *)err);
#line 2605
    controller_output(cntlr, err, (int )tmp);
#line 2606
    tmp___0 = strlen((char const   *)portspec);
#line 2606
    controller_output(cntlr, portspec, (int )tmp___0);
#line 2607
    controller_output(cntlr, (char *)"\n\r", 2);
    }
#line 2608
    return;
  }
  {
#line 2611
  tmp___6 = strcmp((char const   *)enable, "off");
  }
#line 2611
  if (tmp___6 == 0) {
#line 2612
    new_enable = 0;
  } else {
    {
#line 2613
    tmp___5 = strcmp((char const   *)enable, "raw");
    }
#line 2613
    if (tmp___5 == 0) {
#line 2614
      new_enable = 1;
    } else {
      {
#line 2615
      tmp___4 = strcmp((char const   *)enable, "rawlp");
      }
#line 2615
      if (tmp___4 == 0) {
#line 2616
        new_enable = 2;
      } else {
        {
#line 2617
        tmp___3 = strcmp((char const   *)enable, "telnet");
        }
#line 2617
        if (tmp___3 == 0) {
#line 2618
          new_enable = 3;
        } else {
          {
#line 2620
          err = (char *)"Invalid enable: ";
#line 2621
          tmp___1 = strlen((char const   *)err);
#line 2621
          controller_output(cntlr, err, (int )tmp___1);
#line 2622
          tmp___2 = strlen((char const   *)enable);
#line 2622
          controller_output(cntlr, enable, (int )tmp___2);
#line 2623
          controller_output(cntlr, (char *)"\n\r", 2);
          }
#line 2624
          return;
        }
      }
    }
  }
  {
#line 2627
  err = change_port_state(port, new_enable);
  }
#line 2628
  if ((unsigned long )err != (unsigned long )((void *)0)) {
    {
#line 2629
    tmp___7 = strlen((char const   *)err);
#line 2629
    controller_output(cntlr, err, (int )tmp___7);
#line 2630
    controller_output(cntlr, (char *)"\n\r", 2);
    }
  }
#line 2632
  return;
}
}
#line 2637 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void *data_monitor_start(struct controller_info *cntlr , char *type , char *portspec ) 
{ 
  port_info_t *port ;
  char *err ;
  size_t tmp ;
  size_t tmp___0 ;
  char *err___0 ;
  size_t tmp___1 ;
  char *err___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2644
  port = find_port_by_num(portspec);
  }
#line 2645
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 2646
    err = (char *)"Invalid port number: ";
#line 2647
    tmp = strlen((char const   *)err);
#line 2647
    controller_output(cntlr, err, (int )tmp);
#line 2648
    tmp___0 = strlen((char const   *)portspec);
#line 2648
    controller_output(cntlr, portspec, (int )tmp___0);
#line 2649
    controller_output(cntlr, (char *)"\n\r", 2);
    }
#line 2650
    return ((void *)0);
  }
#line 2653
  if ((unsigned long )port->tcp_monitor != (unsigned long )((void *)0)) {
    {
#line 2654
    err___0 = (char *)"Port is already being monitored";
#line 2655
    tmp___1 = strlen((char const   *)err___0);
#line 2655
    controller_output(cntlr, err___0, (int )tmp___1);
#line 2656
    controller_output(cntlr, (char *)"\n\r", 2);
    }
#line 2657
    return ((void *)0);
  } else
#line 2653
  if ((unsigned long )port->dev_monitor != (unsigned long )((void *)0)) {
    {
#line 2654
    err___0 = (char *)"Port is already being monitored";
#line 2655
    tmp___1 = strlen((char const   *)err___0);
#line 2655
    controller_output(cntlr, err___0, (int )tmp___1);
#line 2656
    controller_output(cntlr, (char *)"\n\r", 2);
    }
#line 2657
    return ((void *)0);
  }
  {
#line 2660
  tmp___5 = strcmp((char const   *)type, "tcp");
  }
#line 2660
  if (tmp___5 == 0) {
#line 2661
    port->tcp_monitor = cntlr;
#line 2662
    return ((void *)port);
  } else {
    {
#line 2663
    tmp___4 = strcmp((char const   *)type, "term");
    }
#line 2663
    if (tmp___4 == 0) {
#line 2664
      port->dev_monitor = cntlr;
#line 2665
      return ((void *)port);
    } else {
      {
#line 2667
      err___1 = (char *)"invalid monitor type: ";
#line 2668
      tmp___2 = strlen((char const   *)err___1);
#line 2668
      controller_output(cntlr, err___1, (int )tmp___2);
#line 2669
      tmp___3 = strlen((char const   *)type);
#line 2669
      controller_output(cntlr, type, (int )tmp___3);
#line 2670
      controller_output(cntlr, (char *)"\n\r", 2);
      }
#line 2671
      return ((void *)0);
    }
  }
}
}
#line 2676 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void data_monitor_stop(struct controller_info *cntlr , void *monitor_id ) 
{ 
  port_info_t *port ;

  {
#line 2680
  port = (port_info_t *)monitor_id;
#line 2682
  port->tcp_monitor = (struct controller_info *)((void *)0);
#line 2683
  port->dev_monitor = (struct controller_info *)((void *)0);
#line 2684
  return;
}
}
#line 2686 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void disconnect_port(struct controller_info *cntlr , char *portspec ) 
{ 
  port_info_t *port ;
  char *err ;
  size_t tmp ;
  size_t tmp___0 ;
  char *err___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 2692
  port = find_port_by_num(portspec);
  }
#line 2693
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 2694
    err = (char *)"Invalid port number: ";
#line 2695
    tmp = strlen((char const   *)err);
#line 2695
    controller_output(cntlr, err, (int )tmp);
#line 2696
    tmp___0 = strlen((char const   *)portspec);
#line 2696
    controller_output(cntlr, portspec, (int )tmp___0);
#line 2697
    controller_output(cntlr, (char *)"\n\r", 2);
    }
#line 2698
    return;
  } else
#line 2699
  if (port->tcp_to_dev_state == 0) {
    {
#line 2700
    err___0 = (char *)"Port not connected: ";
#line 2701
    tmp___1 = strlen((char const   *)err___0);
#line 2701
    controller_output(cntlr, err___0, (int )tmp___1);
#line 2702
    tmp___2 = strlen((char const   *)portspec);
#line 2702
    controller_output(cntlr, portspec, (int )tmp___2);
#line 2703
    controller_output(cntlr, (char *)"\n\r", 2);
    }
#line 2704
    return;
  }
  {
#line 2707
  shutdown_port(port, (char *)"disconnect");
  }
#line 2708
  return;
}
}
#line 2710 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static struct baud_rates_s baud_rates[18]  = 
#line 2710
  {      {50, 1, -1}, 
        {75, 2, -1}, 
        {110, 3, -1}, 
        {134, 4, -1}, 
        {150, 5, -1}, 
        {200, 6, -1}, 
        {300, 7, 3}, 
        {600, 8, 4}, 
        {1200, 9, 5}, 
        {1800, 10, -1}, 
        {2400, 11, 6}, 
        {4800, 12, 7}, 
        {9600, 13, 8}, 
        {19200, 14, 10}, 
        {38400, 15, 12}, 
        {57600, 4097, 13}, 
        {115200, 4098, 14}, 
        {230400, 4099, 15}};
#line 2740 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
int get_baud_rate(int rate , int *val ) 
{ 
  unsigned int i ;

  {
#line 2744
  i = 0U;
  {
#line 2744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2744
    if (! ((unsigned long )i < sizeof(baud_rates) / sizeof(struct baud_rates_s ))) {
#line 2744
      goto while_break;
    }
#line 2745
    if (cisco_ios_baud_rates) {
#line 2746
      if (rate == baud_rates[i].cisco_ios_val) {
#line 2747
        *val = baud_rates[i].val;
#line 2748
        return (1);
      }
    } else
#line 2751
    if (rate == baud_rates[i].real_rate) {
#line 2752
      *val = baud_rates[i].val;
#line 2753
      return (1);
    }
#line 2744
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2758
  return (0);
}
}
#line 2761 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void get_rate_from_baud_rate(int baud_rate , int *val ) 
{ 
  unsigned int i ;

  {
#line 2765
  i = 0U;
  {
#line 2765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2765
    if (! ((unsigned long )i < sizeof(baud_rates) / sizeof(struct baud_rates_s ))) {
#line 2765
      goto while_break;
    }
#line 2766
    if (baud_rate == baud_rates[i].val) {
#line 2767
      if (cisco_ios_baud_rates) {
#line 2768
        if (baud_rates[i].cisco_ios_val < 0) {
#line 2771
          *val = 0;
        } else {
#line 2773
          *val = baud_rates[i].cisco_ios_val;
        }
      } else {
#line 2775
        *val = baud_rates[i].real_rate;
      }
#line 2777
      return;
    }
#line 2765
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2780
  return;
}
}
#line 2782 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static int com_port_will(void *cb_data ) 
{ 
  port_info_t *port ;
  unsigned char data[3] ;
  int val ;
  int tmp ;

  {
#line 2785
  port = (port_info_t *)cb_data;
#line 2789
  if (! port->dinfo.allow_2217) {
#line 2790
    return (0);
  }
  {
#line 2793
  port->is_2217 = 1;
#line 2794
  port->linestate_mask = (unsigned char)0;
#line 2795
  port->modemstate_mask = (unsigned char)255;
#line 2796
  port->last_modemstate = (unsigned char)0;
#line 2800
  data[0] = (unsigned char)44;
#line 2801
  data[1] = (unsigned char)107;
#line 2802
  data[2] = (unsigned char)0;
#line 2803
  tmp = ioctl(port->devfd, 21525UL, & val);
  }
#line 2803
  if (tmp != -1) {
#line 2804
    if (val & 64) {
#line 2805
      data[2] = (unsigned char )((int )data[2] | 128);
    }
#line 2806
    if (val & 128) {
#line 2807
      data[2] = (unsigned char )((int )data[2] | 64);
    }
#line 2808
    if (val & 256) {
#line 2809
      data[2] = (unsigned char )((int )data[2] | 32);
    }
#line 2810
    if (val & 32) {
#line 2811
      data[2] = (unsigned char )((int )data[2] | 16);
    }
#line 2812
    port->last_modemstate = data[2];
  }
  {
#line 2814
  telnet_send_option(& port->tn_data, data, 3);
  }
#line 2815
  return (1);
}
}
#line 2818 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
static void com_port_handler(void *cb_data , unsigned char *option , int len ) 
{ 
  port_info_t *port ;
  unsigned char outopt[256] ;
  struct termios termio ;
  int val ;
  int sign_len ;
  size_t tmp ;
  int tmp___0 ;
  speed_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 2821
  port = (port_info_t *)cb_data;
#line 2826
  if (len < 2) {
#line 2827
    return;
  }
  {
#line 2830
  if ((int )*(option + 1) == 0) {
#line 2830
    goto case_0;
  }
#line 2844
  if ((int )*(option + 1) == 1) {
#line 2844
    goto case_1;
  }
#line 2891
  if ((int )*(option + 1) == 2) {
#line 2891
    goto case_2;
  }
#line 2921
  if ((int )*(option + 1) == 3) {
#line 2921
    goto case_3;
  }
#line 2952
  if ((int )*(option + 1) == 4) {
#line 2952
    goto case_4;
  }
#line 2979
  if ((int )*(option + 1) == 5) {
#line 2979
    goto case_5___0;
  }
#line 3127
  if ((int )*(option + 1) == 8) {
#line 3127
    goto case_8___1;
  }
#line 3134
  if ((int )*(option + 1) == 9) {
#line 3134
    goto case_9___0;
  }
#line 3141
  if ((int )*(option + 1) == 10) {
#line 3141
    goto case_10___0;
  }
#line 3151
  if ((int )*(option + 1) == 11) {
#line 3151
    goto case_11___0;
  }
#line 3161
  if ((int )*(option + 1) == 12) {
#line 3161
    goto case_12___0;
  }
#line 3181
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 2833
  tmp = strlen((char const   *)port->dinfo.signature);
#line 2833
  sign_len = (int )tmp;
  }
#line 2834
  if (sign_len > 254) {
#line 2835
    sign_len = 254;
  }
  {
#line 2837
  outopt[0] = (unsigned char)44;
#line 2838
  outopt[1] = (unsigned char)100;
#line 2839
  strncpy((char */* __restrict  */)((char *)(outopt) + 2), (char const   */* __restrict  */)port->dinfo.signature,
          (size_t )sign_len);
#line 2840
  telnet_send_option(& port->tn_data, outopt, 2 + sign_len);
  }
#line 2841
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2845
  if (cisco_ios_baud_rates) {
#line 2846
    if (len < 3) {
#line 2847
      return;
    }
#line 2848
    val = (int )*(option + 2);
  } else {
#line 2850
    if (len < 6) {
#line 2851
      return;
    }
#line 2855
    val = (int )*(option + 2) << 24;
#line 2856
    val |= (int )*(option + 3) << 16;
#line 2857
    val |= (int )*(option + 4) << 8;
#line 2858
    val |= (int )*(option + 5);
  }
  {
#line 2861
  tmp___2 = tcgetattr(port->devfd, & termio);
  }
#line 2861
  if (tmp___2 != -1) {
#line 2862
    if (val != 0) {
      {
#line 2862
      tmp___0 = get_baud_rate(val, & val);
      }
#line 2862
      if (tmp___0) {
        {
#line 2864
        cfsetispeed(& termio, (speed_t )val);
#line 2865
        cfsetospeed(& termio, (speed_t )val);
#line 2866
        tcsetattr(port->devfd, 0, (struct termios  const  *)(& termio));
        }
      }
    }
    {
#line 2868
    tcgetattr(port->devfd, & termio);
#line 2869
    tmp___1 = cfgetispeed((struct termios  const  *)(& termio));
#line 2869
    val = (int )tmp___1;
    }
  } else {
#line 2871
    val = 0;
  }
  {
#line 2873
  get_rate_from_baud_rate(val, & val);
#line 2874
  outopt[0] = (unsigned char)44;
#line 2875
  outopt[1] = (unsigned char)101;
  }
#line 2876
  if (cisco_ios_baud_rates) {
    {
#line 2877
    outopt[2] = (unsigned char )val;
#line 2878
    telnet_send_option(& port->tn_data, outopt, 3);
    }
  } else {
    {
#line 2883
    outopt[2] = (unsigned char )(val >> 24);
#line 2884
    outopt[3] = (unsigned char )(val >> 16);
#line 2885
    outopt[4] = (unsigned char )(val >> 8);
#line 2886
    outopt[5] = (unsigned char )val;
#line 2887
    telnet_send_option(& port->tn_data, outopt, 6);
    }
  }
#line 2889
  goto switch_break;
  case_2: /* CIL Label */ 
#line 2892
  if (len < 3) {
#line 2893
    return;
  }
  {
#line 2895
  val = 0;
#line 2896
  tmp___3 = tcgetattr(port->devfd, & termio);
  }
#line 2896
  if (tmp___3 != -1) {
#line 2897
    if ((int )*(option + 2) >= 5) {
#line 2897
      if ((int )*(option + 2) <= 8) {
#line 2898
        val = (int )*(option + 2);
#line 2899
        termio.c_cflag &= 4294967247U;
        {
#line 2901
        if (val == 5) {
#line 2901
          goto case_5;
        }
#line 2902
        if (val == 6) {
#line 2902
          goto case_6;
        }
#line 2903
        if (val == 7) {
#line 2903
          goto case_7;
        }
#line 2904
        if (val == 8) {
#line 2904
          goto case_8;
        }
#line 2900
        goto switch_break___0;
        case_5: /* CIL Label */ 
#line 2901
        termio.c_cflag = termio.c_cflag;
#line 2901
        goto switch_break___0;
        case_6: /* CIL Label */ 
#line 2902
        termio.c_cflag |= 16U;
#line 2902
        goto switch_break___0;
        case_7: /* CIL Label */ 
#line 2903
        termio.c_cflag |= 32U;
#line 2903
        goto switch_break___0;
        case_8: /* CIL Label */ 
#line 2904
        termio.c_cflag |= 48U;
#line 2904
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 2906
        tcsetattr(port->devfd, 0, (struct termios  const  *)(& termio));
        }
      }
    }
    {
#line 2909
    if ((termio.c_cflag & 48U) == 0U) {
#line 2909
      goto case_0___0;
    }
#line 2910
    if ((termio.c_cflag & 48U) == 16U) {
#line 2910
      goto case_16;
    }
#line 2911
    if ((termio.c_cflag & 48U) == 32U) {
#line 2911
      goto case_32;
    }
#line 2912
    if ((termio.c_cflag & 48U) == 48U) {
#line 2912
      goto case_48;
    }
#line 2908
    goto switch_break___1;
    case_0___0: /* CIL Label */ 
#line 2909
    val = 5;
#line 2909
    goto switch_break___1;
    case_16: /* CIL Label */ 
#line 2910
    val = 6;
#line 2910
    goto switch_break___1;
    case_32: /* CIL Label */ 
#line 2911
    val = 7;
#line 2911
    goto switch_break___1;
    case_48: /* CIL Label */ 
#line 2912
    val = 8;
#line 2912
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  {
#line 2915
  outopt[0] = (unsigned char)44;
#line 2916
  outopt[1] = (unsigned char)102;
#line 2917
  outopt[2] = (unsigned char )val;
#line 2918
  telnet_send_option(& port->tn_data, outopt, 3);
  }
#line 2919
  goto switch_break;
  case_3: /* CIL Label */ 
#line 2922
  if (len < 3) {
#line 2923
    return;
  }
  {
#line 2925
  val = 0;
#line 2926
  tmp___4 = tcgetattr(port->devfd, & termio);
  }
#line 2926
  if (tmp___4 != -1) {
#line 2928
    if ((int )*(option + 2) >= 1) {
#line 2928
      if ((int )*(option + 2) <= 3) {
#line 2929
        val = (int )*(option + 2);
#line 2930
        termio.c_cflag &= 4294966527U;
        {
#line 2932
        if (val == 1) {
#line 2932
          goto case_1___0;
        }
#line 2933
        if (val == 2) {
#line 2933
          goto case_2___0;
        }
#line 2934
        if (val == 3) {
#line 2934
          goto case_3___0;
        }
#line 2931
        goto switch_break___2;
        case_1___0: /* CIL Label */ 
#line 2932
        goto switch_break___2;
        case_2___0: /* CIL Label */ 
#line 2933
        termio.c_cflag |= 768U;
#line 2933
        goto switch_break___2;
        case_3___0: /* CIL Label */ 
#line 2934
        termio.c_cflag |= 256U;
#line 2934
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
        {
#line 2936
        tcsetattr(port->devfd, 0, (struct termios  const  *)(& termio));
        }
      }
    }
#line 2938
    if (termio.c_cflag & 256U) {
#line 2939
      if (termio.c_cflag & 512U) {
#line 2940
        val = 2;
      } else {
#line 2942
        val = 3;
      }
    } else {
#line 2944
      val = 1;
    }
  }
  {
#line 2946
  outopt[0] = (unsigned char)44;
#line 2947
  outopt[1] = (unsigned char)103;
#line 2948
  outopt[2] = (unsigned char )val;
#line 2949
  telnet_send_option(& port->tn_data, outopt, 3);
  }
#line 2950
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2953
  if (len < 3) {
#line 2954
    return;
  }
  {
#line 2956
  val = 0;
#line 2957
  tmp___5 = tcgetattr(port->devfd, & termio);
  }
#line 2957
  if (tmp___5 != -1) {
#line 2959
    if ((int )*(option + 2) == 1) {
#line 2959
      goto _L;
    } else
#line 2959
    if ((int )*(option + 2) == 2) {
      _L: /* CIL Label */ 
#line 2960
      val = (int )*(option + 2);
#line 2961
      termio.c_cflag &= 4294967231U;
      {
#line 2963
      if (val == 1) {
#line 2963
        goto case_1___1;
      }
#line 2964
      if (val == 2) {
#line 2964
        goto case_2___1;
      }
#line 2962
      goto switch_break___3;
      case_1___1: /* CIL Label */ 
#line 2963
      goto switch_break___3;
      case_2___1: /* CIL Label */ 
#line 2964
      termio.c_cflag |= 64U;
#line 2964
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 2966
      tcsetattr(port->devfd, 0, (struct termios  const  *)(& termio));
      }
    }
#line 2968
    if (termio.c_cflag & 64U) {
#line 2969
      val = 2;
    } else {
#line 2971
      val = 1;
    }
  }
  {
#line 2973
  outopt[0] = (unsigned char)44;
#line 2974
  outopt[1] = (unsigned char)104;
#line 2975
  outopt[2] = (unsigned char )val;
#line 2976
  telnet_send_option(& port->tn_data, outopt, 3);
  }
#line 2977
  goto switch_break;
  case_5___0: /* CIL Label */ 
#line 2980
  if (len < 3) {
#line 2981
    return;
  }
#line 2983
  val = 0;
  {
#line 2989
  if ((int )*(option + 2) == 3) {
#line 2989
    goto case_3___1;
  }
#line 2989
  if ((int )*(option + 2) == 2) {
#line 2989
    goto case_3___1;
  }
#line 2989
  if ((int )*(option + 2) == 1) {
#line 2989
    goto case_3___1;
  }
#line 2989
  if ((int )*(option + 2) == 0) {
#line 2989
    goto case_3___1;
  }
#line 3018
  if ((int )*(option + 2) == 19) {
#line 3018
    goto case_19;
  }
#line 3018
  if ((int )*(option + 2) == 18) {
#line 3018
    goto case_19;
  }
#line 3018
  if ((int )*(option + 2) == 17) {
#line 3018
    goto case_19;
  }
#line 3018
  if ((int )*(option + 2) == 16) {
#line 3018
    goto case_19;
  }
#line 3018
  if ((int )*(option + 2) == 15) {
#line 3018
    goto case_19;
  }
#line 3018
  if ((int )*(option + 2) == 14) {
#line 3018
    goto case_19;
  }
#line 3018
  if ((int )*(option + 2) == 13) {
#line 3018
    goto case_19;
  }
#line 3036
  if ((int )*(option + 2) == 6) {
#line 3036
    goto case_6___0;
  }
#line 3041
  if ((int )*(option + 2) == 5) {
#line 3041
    goto case_5___1;
  }
#line 3046
  if ((int )*(option + 2) == 4) {
#line 3046
    goto read_break_val;
  }
#line 3055
  if ((int )*(option + 2) == 8) {
#line 3055
    goto case_8___0;
  }
#line 3066
  if ((int )*(option + 2) == 9) {
#line 3066
    goto case_9;
  }
#line 3077
  if ((int )*(option + 2) == 7) {
#line 3077
    goto read_dtr_val;
  }
#line 3088
  if ((int )*(option + 2) == 11) {
#line 3088
    goto case_11;
  }
#line 3099
  if ((int )*(option + 2) == 12) {
#line 3099
    goto case_12;
  }
#line 3110
  if ((int )*(option + 2) == 10) {
#line 3110
    goto read_rts_val;
  }
#line 2985
  goto switch_break___4;
  case_3___1: /* CIL Label */ 
  case_2___2: /* CIL Label */ 
  case_1___2: /* CIL Label */ 
  case_0___1: /* CIL Label */ 
  {
#line 2991
  tmp___6 = tcgetattr(port->devfd, & termio);
  }
#line 2991
  if (tmp___6 != -1) {
#line 2992
    if ((int )*(option + 2) != 0) {
#line 2993
      val = (int )*(option + 2);
#line 2994
      termio.c_iflag &= 4294962175U;
#line 2995
      termio.c_cflag &= 2147483647U;
      {
#line 2997
      if (val == 1) {
#line 2997
        goto case_1___3;
      }
#line 2998
      if (val == 2) {
#line 2998
        goto case_2___3;
      }
#line 2999
      if (val == 3) {
#line 2999
        goto case_3___2;
      }
#line 2996
      goto switch_break___5;
      case_1___3: /* CIL Label */ 
#line 2997
      goto switch_break___5;
      case_2___3: /* CIL Label */ 
#line 2998
      termio.c_iflag |= 5120U;
#line 2998
      goto switch_break___5;
      case_3___2: /* CIL Label */ 
#line 2999
      termio.c_cflag |= 2147483648U;
#line 2999
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
      {
#line 3001
      tcsetattr(port->devfd, 0, (struct termios  const  *)(& termio));
      }
    }
#line 3003
    if (termio.c_cflag & 2147483648U) {
#line 3004
      val = 3;
    } else
#line 3005
    if (termio.c_iflag & 1024U) {
#line 3006
      val = 2;
    } else {
#line 3008
      val = 1;
    }
  }
#line 3010
  goto switch_break___4;
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16___0: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 3020
  tmp___7 = tcgetattr(port->devfd, & termio);
  }
#line 3020
  if (tmp___7 != -1) {
#line 3021
    if ((int )*(option + 2) == 15) {
      {
#line 3023
      termio.c_iflag |= 4096U;
#line 3024
      tcsetattr(port->devfd, 0, (struct termios  const  *)(& termio));
      }
    }
#line 3026
    if (termio.c_cflag & 2147483648U) {
#line 3027
      val = 16;
    } else
#line 3028
    if (termio.c_iflag & 4096U) {
#line 3029
      val = 15;
    } else {
#line 3031
      val = 14;
    }
  }
#line 3033
  goto switch_break___4;
  case_6___0: /* CIL Label */ 
  {
#line 3037
  tmp___8 = ioctl(port->devfd, 21544UL);
  }
#line 3037
  if (tmp___8 != -1) {
#line 3038
    port->break_set = 0;
  }
#line 3039
  goto read_break_val;
  case_5___1: /* CIL Label */ 
  {
#line 3042
  tmp___9 = ioctl(port->devfd, 21543UL);
  }
#line 3042
  if (tmp___9 != -1) {
#line 3043
    port->break_set = 1;
  }
#line 3044
  goto read_break_val;
  read_break_val: 
  case_4___0: /* CIL Label */ 
#line 3048
  if (port->break_set) {
#line 3049
    val = 5;
  } else {
#line 3051
    val = 6;
  }
#line 3052
  goto switch_break___4;
  case_8___0: /* CIL Label */ 
  {
#line 3057
  val = 2;
#line 3058
  ioctl(port->devfd, 21526UL, & val);
  }
#line 3064
  goto read_dtr_val;
  case_9: /* CIL Label */ 
  {
#line 3068
  val = 2;
#line 3069
  ioctl(port->devfd, 21527UL, & val);
  }
#line 3075
  goto read_dtr_val;
  read_dtr_val: 
  case_7___0: /* CIL Label */ 
  {
#line 3079
  tmp___10 = ioctl(port->devfd, 21525UL, & val);
  }
#line 3079
  if (tmp___10 == -1) {
#line 3080
    val = 7;
  } else
#line 3081
  if (val & 2) {
#line 3082
    val = 8;
  } else {
#line 3084
    val = 9;
  }
#line 3085
  goto switch_break___4;
  case_11: /* CIL Label */ 
  {
#line 3090
  val = 4;
#line 3091
  ioctl(port->devfd, 21526UL, & val);
  }
#line 3097
  goto read_rts_val;
  case_12: /* CIL Label */ 
  {
#line 3101
  val = 4;
#line 3102
  ioctl(port->devfd, 21527UL, & val);
  }
#line 3108
  goto read_rts_val;
  read_rts_val: 
  case_10: /* CIL Label */ 
  {
#line 3112
  tmp___11 = ioctl(port->devfd, 21525UL, & val);
  }
#line 3112
  if (tmp___11 == -1) {
#line 3113
    val = 10;
  } else
#line 3114
  if (val & 4) {
#line 3115
    val = 11;
  } else {
#line 3117
    val = 12;
  }
#line 3118
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
  {
#line 3121
  outopt[0] = (unsigned char)44;
#line 3122
  outopt[1] = (unsigned char)105;
#line 3123
  outopt[2] = (unsigned char )val;
#line 3124
  telnet_send_option(& port->tn_data, outopt, 3);
  }
#line 3125
  goto switch_break;
  case_8___1: /* CIL Label */ 
  {
#line 3128
  tcflow(port->devfd, 2);
#line 3129
  outopt[0] = (unsigned char)44;
#line 3130
  outopt[1] = (unsigned char)108;
#line 3131
  telnet_send_option(& port->tn_data, outopt, 2);
  }
#line 3132
  goto switch_break;
  case_9___0: /* CIL Label */ 
  {
#line 3135
  tcflow(port->devfd, 3);
#line 3136
  outopt[0] = (unsigned char)44;
#line 3137
  outopt[1] = (unsigned char)109;
#line 3138
  telnet_send_option(& port->tn_data, outopt, 2);
  }
#line 3139
  goto switch_break;
  case_10___0: /* CIL Label */ 
#line 3142
  if (len < 3) {
#line 3143
    return;
  }
  {
#line 3144
  port->linestate_mask = *(option + 2);
#line 3145
  outopt[0] = (unsigned char)44;
#line 3146
  outopt[1] = (unsigned char)110;
#line 3147
  outopt[2] = port->linestate_mask;
#line 3148
  telnet_send_option(& port->tn_data, outopt, 3);
  }
#line 3149
  goto switch_break;
  case_11___0: /* CIL Label */ 
#line 3152
  if (len < 3) {
#line 3153
    return;
  }
  {
#line 3154
  port->modemstate_mask = *(option + 2);
#line 3155
  outopt[0] = (unsigned char)44;
#line 3156
  outopt[1] = (unsigned char)111;
#line 3157
  outopt[2] = port->modemstate_mask;
#line 3158
  telnet_send_option(& port->tn_data, outopt, 3);
  }
#line 3159
  goto switch_break;
  case_12___0: /* CIL Label */ 
#line 3162
  if (len < 3) {
#line 3163
    return;
  }
  {
#line 3166
  if ((int )*(option + 2) == 1) {
#line 3166
    goto case_1___4;
  }
#line 3167
  if ((int )*(option + 2) == 2) {
#line 3167
    goto case_2___4;
  }
#line 3168
  if ((int )*(option + 2) == 3) {
#line 3168
    goto case_3___3;
  }
#line 3165
  goto switch_break___6;
  case_1___4: /* CIL Label */ 
#line 3166
  val = 0;
#line 3166
  goto purge_found;
  case_2___4: /* CIL Label */ 
#line 3167
  val = 1;
#line 3167
  goto purge_found;
  case_3___3: /* CIL Label */ 
#line 3168
  val = 2;
#line 3168
  goto purge_found;
  switch_break___6: /* CIL Label */ ;
  }
#line 3170
  goto switch_break;
  purge_found: 
  {
#line 3172
  tcflush(port->devfd, val);
#line 3173
  outopt[0] = (unsigned char)44;
#line 3174
  outopt[1] = (unsigned char)112;
#line 3175
  outopt[2] = *(option + 2);
#line 3176
  telnet_send_option(& port->tn_data, outopt, 3);
  }
#line 3177
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3182
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3184
  return;
}
}
#line 3186 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
void shutdown_ports(void) 
{ 
  port_info_t *port ;

  {
#line 3189
  port = ports;
  {
#line 3191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3191
    if (! ((unsigned long )port != (unsigned long )((void *)0))) {
#line 3191
      goto while_break;
    }
    {
#line 3192
    port->config_num = -1;
#line 3193
    shutdown_port(port, (char *)"program shutdown");
#line 3194
    port = port->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3196
  return;
}
}
#line 3198 "/home/june/repo/benchmarks/collector/temp/ser2net-2.9.1/dataxfer.c"
int check_ports_shutdown(void) 
{ 


  {
#line 3201
  return ((unsigned long )ports == (unsigned long )((void *)0));
}
}
