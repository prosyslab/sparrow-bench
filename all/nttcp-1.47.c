/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 61 "/usr/include/signal.h"
typedef __pid_t pid_t;
#line 67 "/usr/include/signal.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_46 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_47 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_46 __wait_terminated ;
   struct __anonstruct___wait_stopped_47 __wait_stopped ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_52 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_52 fd_set;
#line 155 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 379 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 264 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_65 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_66 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_67 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_68 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_69 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_70 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_71 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_72 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_73 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_74 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_75 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_76 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_77 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_78 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_65 __annonCompField5 ;
   union __anonunion____missing_field_name_66 __annonCompField6 ;
   union __anonunion____missing_field_name_67 __annonCompField7 ;
   union __anonunion____missing_field_name_68 __annonCompField8 ;
   union __anonunion____missing_field_name_69 __annonCompField9 ;
   union __anonunion____missing_field_name_70 __annonCompField10 ;
   union __anonunion____missing_field_name_71 __annonCompField11 ;
   union __anonunion____missing_field_name_72 __annonCompField12 ;
   union __anonunion____missing_field_name_73 __annonCompField13 ;
   union __anonunion____missing_field_name_74 __annonCompField14 ;
   union __anonunion____missing_field_name_75 __annonCompField15 ;
   union __anonunion____missing_field_name_76 __annonCompField16 ;
   union __anonunion____missing_field_name_77 __annonCompField17 ;
   union __anonunion____missing_field_name_78 __annonCompField18 ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 77 "/home/wheatley/newnew/temp/nttcp-1.47/support.h"
struct __anonstruct_LenStr_79 {
   int Leng ;
   int MaxLeng ;
   char *s ;
};
#line 77 "/home/wheatley/newnew/temp/nttcp-1.47/support.h"
typedef struct __anonstruct_LenStr_79 LenStr;
#line 101 "/home/wheatley/newnew/temp/nttcp-1.47/support.h"
struct __anonstruct_StrVec_80 {
   int Leng ;
   int MaxLeng ;
   char **String ;
};
#line 101 "/home/wheatley/newnew/temp/nttcp-1.47/support.h"
typedef struct __anonstruct_StrVec_80 StrVec;
#line 323 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
struct __anonstruct_RemoteConnection_81 {
   char *HostName ;
   char *IPName ;
   int Socket ;
   FILE *fin ;
   FILE *fout ;
};
#line 323 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
typedef struct __anonstruct_RemoteConnection_81 RemoteConnection;
#line 334 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
struct __anonstruct_Options_82 {
   int PidCalls ;
   int udp ;
   int Compare ;
   int StreamPattern ;
   int Transmit ;
   int Title ;
   int b_flag ;
   int SockOpt ;
   int NoDelay ;
   int BufCnt ;
   int BufLen ;
   int FixedDataSize ;
   int Window ;
   int SndWin ;
   int RcvWin ;
   int Verbose ;
   char *MulticastChannel ;
   short MulticastPort ;
   int GapLength ;
   int inetd ;
   short Service ;
   char *Format ;
   char *RemHost ;
   char *InitString ;
   int RemoteNumber ;
};
#line 334 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
typedef struct __anonstruct_Options_82 Options;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 469
extern int pause(void) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 357
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 131
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who ,
                                                                                struct rusage *__usage ) ;
#line 87 "/home/wheatley/newnew/temp/nttcp-1.47/support.h"
LenStr *LenStrcat(LenStr *dls , char *s ) ;
#line 88
LenStr *LenStrMake(char *s ) ;
#line 89
LenStr *LenStrncat(LenStr *dls , char *s , int n ) ;
#line 90
char *LenStrString(LenStr *ls ) ;
#line 91
LenStr *LenStrcpy(LenStr *dvs , char *s ) ;
#line 92
LenStr *LenStrPadRight(LenStr *ls , char c , int n ) ;
#line 93
LenStr *LenStrApp(LenStr *ls , char ch ) ;
#line 94
int LenStrLeng(LenStr *ls ) ;
#line 107
StrVec *StrVecCreate(void) ;
#line 108
void StrVecDestroy(StrVec *sa ) ;
#line 109
StrVec *StrVecFromString(char *s , char Sep ) ;
#line 110
StrVec *StrVecJoin(StrVec *sv , StrVec *sv1 ) ;
#line 111
char *StrVecToString(StrVec *sa , char Sep ) ;
#line 112
StrVec *StrVecAppend(StrVec *sa , char *s ) ;
#line 113
StrVec *StrVecFromArgv(int argc , char **argv ) ;
#line 261 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
char UsageMessage[1138]  = 
#line 261 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'n', 
        (char )'t',      (char )'t',      (char )'c',      (char )'p', 
        (char )' ',      (char )'[',      (char )'l',      (char )'o', 
        (char )'c',      (char )'a',      (char )'l',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )']', 
        (char )' ',      (char )'h',      (char )'o',      (char )'s', 
        (char )'t',      (char )' ',      (char )'[',      (char )'r', 
        (char )'e',      (char )'m',      (char )'o',      (char )'t', 
        (char )'e',      (char )' ',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )']',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'l',      (char )'o', 
        (char )'c',      (char )'a',      (char )'l',      (char )'/', 
        (char )'r',      (char )'e',      (char )'m',      (char )'o', 
        (char )'t',      (char )'e',      (char )' ',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )' ',      (char )'a', 
        (char )'r',      (char )'e',      (char )':',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'t',      (char )'\t', 
        (char )'t',      (char )'r',      (char )'a',      (char )'n', 
        (char )'s',      (char )'m',      (char )'i',      (char )'t', 
        (char )' ',      (char )'d',      (char )'a',      (char )'t', 
        (char )'a',      (char )' ',      (char )'(',      (char )'d', 
        (char )'e',      (char )'f',      (char )'a',      (char )'u', 
        (char )'l',      (char )'t',      (char )' ',      (char )'f', 
        (char )'o',      (char )'r',      (char )' ',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )' ',      (char )'s',      (char )'i',      (char )'d', 
        (char )'e',      (char )')',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'r',      (char )'\t',      (char )'r', 
        (char )'e',      (char )'c',      (char )'e',      (char )'i', 
        (char )'v',      (char )'e',      (char )' ',      (char )'d', 
        (char )'a',      (char )'t',      (char )'a',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'l',      (char )'#', 
        (char )'\t',      (char )'l',      (char )'e',      (char )'n', 
        (char )'g',      (char )'t',      (char )'h',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'b', 
        (char )'u',      (char )'f',      (char )'s',      (char )' ', 
        (char )'w',      (char )'r',      (char )'i',      (char )'t', 
        (char )'t',      (char )'e',      (char )'n',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'n', 
        (char )'e',      (char )'t',      (char )'w',      (char )'o', 
        (char )'r',      (char )'k',      (char )' ',      (char )'(', 
        (char )'d',      (char )'e',      (char )'f',      (char )'a', 
        (char )'u',      (char )'l',      (char )'t',      (char )' ', 
        (char )'4',      (char )'k',      (char )')',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'m',      (char )'\t', 
        (char )'u',      (char )'s',      (char )'e',      (char )' ', 
        (char )'I',      (char )'P',      (char )'/',      (char )'m', 
        (char )'u',      (char )'l',      (char )'t',      (char )'i', 
        (char )'c',      (char )'a',      (char )'s',      (char )'t', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'t',      (char )'r',      (char )'a',      (char )'n', 
        (char )'s',      (char )'m',      (char )'i',      (char )'t', 
        (char )' ',      (char )'(',      (char )'e',      (char )'n', 
        (char )'f',      (char )'o',      (char )'r',      (char )'c', 
        (char )'e',      (char )'s',      (char )' ',      (char )'-', 
        (char )'t',      (char )' ',      (char )'-',      (char )'u', 
        (char )')',      (char )'\n',      (char )'\t',      (char )'-', 
        (char )'n',      (char )'#',      (char )'\t',      (char )'n', 
        (char )'u',      (char )'m',      (char )'b',      (char )'e', 
        (char )'r',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'s',      (char )'o',      (char )'u', 
        (char )'r',      (char )'c',      (char )'e',      (char )' ', 
        (char )'b',      (char )'u',      (char )'f',      (char )'s', 
        (char )' ',      (char )'w',      (char )'r',      (char )'i', 
        (char )'t',      (char )'t',      (char )'e',      (char )'n', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'n',      (char )'e',      (char )'t',      (char )'w', 
        (char )'o',      (char )'r',      (char )'k',      (char )' ', 
        (char )'(',      (char )'d',      (char )'e',      (char )'f', 
        (char )'a',      (char )'u',      (char )'l',      (char )'t', 
        (char )' ',      (char )'2',      (char )'0',      (char )'4', 
        (char )'8',      (char )')',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'u',      (char )'\t',      (char )'u', 
        (char )'s',      (char )'e',      (char )' ',      (char )'U', 
        (char )'D',      (char )'P',      (char )' ',      (char )'i', 
        (char )'n',      (char )'s',      (char )'t',      (char )'e', 
        (char )'a',      (char )'d',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'T',      (char )'C', 
        (char )'P',      (char )'\n',      (char )'\t',      (char )'-', 
        (char )'g',      (char )'#',      (char )'u',      (char )'s', 
        (char )'\t',      (char )'g',      (char )'a',      (char )'p', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'m',      (char )'i',      (char )'c',      (char )'r', 
        (char )'o',      (char )' ',      (char )'s',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )'s',      (char )' ',      (char )'b',      (char )'e', 
        (char )'t',      (char )'w',      (char )'e',      (char )'e', 
        (char )'n',      (char )' ',      (char )'U',      (char )'D', 
        (char )'P',      (char )' ',      (char )'p',      (char )'a', 
        (char )'c',      (char )'k',      (char )'e',      (char )'t', 
        (char )'s',      (char )' ',      (char )'(',      (char )'d', 
        (char )'e',      (char )'f',      (char )'a',      (char )'u', 
        (char )'l',      (char )'t',      (char )' ',      (char )'0', 
        (char )'s',      (char )')',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'d',      (char )'\t',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'S', 
        (char )'O',      (char )'_',      (char )'D',      (char )'E', 
        (char )'B',      (char )'U',      (char )'G',      (char )' ', 
        (char )'i',      (char )'n',      (char )' ',      (char )'s', 
        (char )'o',      (char )'c',      (char )'k',      (char )'o', 
        (char )'p',      (char )'t',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'D',      (char )'\t',      (char )'d', 
        (char )'o',      (char )'n',      (char )'\'',      (char )'t', 
        (char )' ',      (char )'b',      (char )'u',      (char )'f', 
        (char )'f',      (char )'e',      (char )'r',      (char )' ', 
        (char )'T',      (char )'C',      (char )'P',      (char )' ', 
        (char )'w',      (char )'r',      (char )'i',      (char )'t', 
        (char )'e',      (char )'s',      (char )' ',      (char )'(', 
        (char )'s',      (char )'e',      (char )'t',      (char )'s', 
        (char )' ',      (char )'T',      (char )'C',      (char )'P', 
        (char )'_',      (char )'N',      (char )'O',      (char )'D', 
        (char )'E',      (char )'L',      (char )'A',      (char )'Y', 
        (char )' ',      (char )'s',      (char )'o',      (char )'c', 
        (char )'k',      (char )'e',      (char )'t',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )')',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'w',      (char )'#', 
        (char )'\t',      (char )'s',      (char )'e',      (char )'t', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'d',      (char )' ',      (char )'b',      (char )'u', 
        (char )'f',      (char )'f',      (char )'e',      (char )'r', 
        (char )' ',      (char )'s',      (char )'p',      (char )'a', 
        (char )'c',      (char )'e',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'#',      (char )'k', 
        (char )'i',      (char )'l',      (char )'o',      (char )'b', 
        (char )'y',      (char )'t',      (char )'e',      (char )'s', 
        (char )',',      (char )' ',      (char )'w',      (char )'h', 
        (char )'i',      (char )'c',      (char )'h',      (char )' ', 
        (char )'i',      (char )'s',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )'d',      (char )'e',      (char )'p', 
        (char )'e',      (char )'n',      (char )'d',      (char )'e', 
        (char )'n',      (char )'t',      (char )' ',      (char )'o', 
        (char )'n',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'s',      (char )'y', 
        (char )'s',      (char )'t',      (char )'e',      (char )'m', 
        (char )' ',      (char )'-',      (char )' ',      (char )'d', 
        (char )'e',      (char )'f',      (char )'a',      (char )'u', 
        (char )'l',      (char )'t',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'1',      (char )'6', 
        (char )'k',      (char )'\n',      (char )'\t',      (char )'-', 
        (char )'T',      (char )'\t',      (char )'p',      (char )'r', 
        (char )'i',      (char )'n',      (char )'t',      (char )' ', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )' ',      (char )'l',      (char )'i', 
        (char )'n',      (char )'e',      (char )' ',      (char )'(', 
        (char )'d',      (char )'e',      (char )'f',      (char )'a', 
        (char )'u',      (char )'l',      (char )'t',      (char )' ', 
        (char )'n',      (char )'o',      (char )')',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'f',      (char )'\t', 
        (char )'g',      (char )'i',      (char )'v',      (char )'e', 
        (char )' ',      (char )'o',      (char )'w',      (char )'n', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )'m',      (char )'a',      (char )'t',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'w', 
        (char )'h',      (char )'a',      (char )'t',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'h',      (char )'o',      (char )'w',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'p', 
        (char )'r',      (char )'i',      (char )'n',      (char )'t', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'c', 
        (char )'\t',      (char )'c',      (char )'o',      (char )'m', 
        (char )'p',      (char )'a',      (char )'r',      (char )'e', 
        (char )'s',      (char )' ',      (char )'e',      (char )'a', 
        (char )'c',      (char )'h',      (char )' ',      (char )'r', 
        (char )'e',      (char )'c',      (char )'e',      (char )'i', 
        (char )'v',      (char )'e',      (char )'d',      (char )' ', 
        (char )'b',      (char )'u',      (char )'f',      (char )'f', 
        (char )'e',      (char )'r',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'e',      (char )'x',      (char )'p',      (char )'e', 
        (char )'c',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'s',      (char )'\t',      (char )'f', 
        (char )'o',      (char )'r',      (char )'c',      (char )'e', 
        (char )' ',      (char )'s',      (char )'t',      (char )'r', 
        (char )'e',      (char )'a',      (char )'m',      (char )' ', 
        (char )'p',      (char )'a',      (char )'t',      (char )'t', 
        (char )'e',      (char )'r',      (char )'n',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'U',      (char )'D',      (char )'P',      (char )' ', 
        (char )'t',      (char )'r',      (char )'a',      (char )'n', 
        (char )'s',      (char )'m',      (char )'i',      (char )'s', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'S', 
        (char )'\t',      (char )'g',      (char )'i',      (char )'v', 
        (char )'e',      (char )' ',      (char )'a',      (char )'n', 
        (char )'o',      (char )'t',      (char )'h',      (char )'e', 
        (char )'r',      (char )' ',      (char )'i',      (char )'n', 
        (char )'i',      (char )'t',      (char )'i',      (char )'a', 
        (char )'l',      (char )'i',      (char )'s',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'p',      (char )'a',      (char )'t', 
        (char )'t',      (char )'e',      (char )'r',      (char )'n', 
        (char )' ',      (char )'g',      (char )'e',      (char )'n', 
        (char )'e',      (char )'r',      (char )'a',      (char )'t', 
        (char )'o',      (char )'r',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'p',      (char )'#',      (char )' ', 
        (char )' ',      (char )' ',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'y',      (char )' ',      (char )'a',      (char )'n', 
        (char )'o',      (char )'t',      (char )'h',      (char )'e', 
        (char )'r',      (char )' ',      (char )'s',      (char )'e', 
        (char )'r',      (char )'v',      (char )'i',      (char )'c', 
        (char )'e',      (char )' ',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'i',      (char )'\t',      (char )'b', 
        (char )'e',      (char )'h',      (char )'a',      (char )'v', 
        (char )'e',      (char )' ',      (char )'a',      (char )'s', 
        (char )' ',      (char )'i',      (char )'f',      (char )' ', 
        (char )'s',      (char )'t',      (char )'a',      (char )'r', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'v',      (char )'i',      (char )'a',      (char )' ', 
        (char )'i',      (char )'n',      (char )'e',      (char )'t', 
        (char )'d',      (char )'\n',      (char )'\t',      (char )'-', 
        (char )'R',      (char )'#',      (char )'\t',      (char )'c', 
        (char )'a',      (char )'l',      (char )'c',      (char )'u', 
        (char )'l',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'g',      (char )'e',      (char )'t', 
        (char )'p',      (char )'i',      (char )'d',      (char )'(', 
        (char )')',      (char )'/',      (char )'s',      (char )' ', 
        (char )'r',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'f',      (char )'r',      (char )'o', 
        (char )'m',      (char )' ',      (char )'#',      (char )' ', 
        (char )'g',      (char )'e',      (char )'t',      (char )'p', 
        (char )'i',      (char )'d',      (char )'(',      (char )')', 
        (char )' ',      (char )'c',      (char )'a',      (char )'l', 
        (char )'l',      (char )'s',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'v',      (char )'\t',      (char )'m', 
        (char )'o',      (char )'r',      (char )'e',      (char )' ', 
        (char )'v',      (char )'e',      (char )'r',      (char )'b', 
        (char )'o',      (char )'s',      (char )'e',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'V',      (char )'\t',      (char )'p', 
        (char )'r',      (char )'i',      (char )'n',      (char )'t', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'n',      (char )'u',      (char )'m', 
        (char )'b',      (char )'e',      (char )'r',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'e',      (char )'x',      (char )'i',      (char )'t', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'?', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'p',      (char )'r',      (char )'i',      (char )'n', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'i',      (char )'s',      (char )' ',      (char )'h', 
        (char )'e',      (char )'l',      (char )'p',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'N',      (char )'\t', 
        (char )'r',      (char )'e',      (char )'m',      (char )'o', 
        (char )'t',      (char )'e',      (char )' ',      (char )'n', 
        (char )'u',      (char )'m',      (char )'b',      (char )'e', 
        (char )'r',      (char )' ',      (char )'(',      (char )'i', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'n',      (char )'a',      (char )'l',      (char )' ', 
        (char )'u',      (char )'s',      (char )'e',      (char )' ', 
        (char )'o',      (char )'n',      (char )'l',      (char )'y', 
        (char )')',      (char )'\n',      (char )'\t',      (char )'d', 
        (char )'e',      (char )'f',      (char )'a',      (char )'u', 
        (char )'l',      (char )'t',      (char )' ',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'a', 
        (char )'t',      (char )' ',      (char )'i',      (char )'s', 
        (char )':',      (char )' ',      (char )'%',      (char )'9', 
        (char )'b',      (char )'%',      (char )'8',      (char )'.', 
        (char )'2',      (char )'r',      (char )'t',      (char )'%', 
        (char )'8',      (char )'.',      (char )'2',      (char )'c', 
        (char )'t',      (char )'%',      (char )'1',      (char )'2', 
        (char )'.',      (char )'4',      (char )'r',      (char )'b', 
        (char )'r',      (char )'%',      (char )'1',      (char )'2', 
        (char )'.',      (char )'4',      (char )'c',      (char )'b', 
        (char )'r',      (char )'%',      (char )'8',      (char )'c', 
        (char )'%',      (char )'1',      (char )'0',      (char )'.', 
        (char )'2',      (char )'r',      (char )'c',      (char )'r', 
        (char )'%',      (char )'1',      (char )'0',      (char )'.', 
        (char )'1',      (char )'c',      (char )'c',      (char )'r', 
        (char )'\n',      (char )'\000'};
#line 289 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
static char VersionString[54]  = 
#line 289
  {      (char )'n',      (char )'t',      (char )'t',      (char )'c', 
        (char )'p',      (char )' ',      (char )'v',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'1',      (char )'.', 
        (char )'4',      (char )'7',      (char )',',      (char )' ', 
        (char )'h',      (char )'t',      (char )'t',      (char )'p', 
        (char )':',      (char )'/',      (char )'/',      (char )'w', 
        (char )'w',      (char )'w',      (char )'.',      (char )'l', 
        (char )'e',      (char )'o',      (char )'.',      (char )'o', 
        (char )'r',      (char )'g',      (char )'/',      (char )'~', 
        (char )'e',      (char )'l',      (char )'m',      (char )'a', 
        (char )'r',      (char )'/',      (char )'n',      (char )'t', 
        (char )'t',      (char )'c',      (char )'p',      (char )'/', 
        (char )'\n',      (char )'\000'};
#line 293 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
char MsgBuf[1024]  ;
#line 296 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
char *myname  ;
#line 297 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
struct sockaddr_in dta_to  ;
#line 300 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int SysCalls  =    0;
#line 301 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int ReportLimit  =    100;
#line 302 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int Remote  =    0;
#line 303 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
char *version  =    (char *)"1.47";
#line 304 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
struct itimerval itval  ;
#line 313 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
struct linger Ling  =    {1, 1000000};
#line 319 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
struct timeval time0  ;
#line 320 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
struct rusage ru0  ;
#line 330 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
RemoteConnection Peer[100]  ;
#line 331 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int PeerCount  =    0;
#line 360 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
Options opt  ;
#line 362 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void fMessage(FILE *f , char *s ) 
{ 


  {
#line 363
  if (Remote) {
    {
#line 364
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s-%d: %s",
            myname, opt.RemoteNumber, s);
    }
  } else {
    {
#line 367
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s-l: %s",
            myname, s);
    }
  }
  {
#line 369
  fflush(f);
  }
#line 370
  return;
}
}
#line 374 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void Exit(char *s , int ret ) 
{ 


  {
  {
#line 375
  syslog(7, "%s", s);
#line 376
  fMessage(stderr, s);
#line 377
  exit(ret);
  }
}
}
#line 380 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void SigCld(int dummy ) 
{ 


  {
  {
#line 381
  wait((union wait *)((int *)0));
#line 383
  signal(17, & SigCld);
  }
#line 384
  return;
}
}
#line 386 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void AlarmNothing(int dummy ) 
{ 


  {
#line 388
  return;
}
}
#line 389 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
char *AlarmMsg  ;
#line 390 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void AlarmExit(int dummy ) 
{ 


  {
  {
#line 391
  fMessage(stderr, AlarmMsg);
#line 392
  exit(9);
  }
}
}
#line 395 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void SigPipe(int dummy ) 
{ 


  {
  {
#line 396
  Exit((char *)"got SIGPIPE, it seems our remote data socket dissapered.\n", 103);
  }
#line 397
  return;
}
}
#line 399 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void FetchRemoteMsg(char finCh ) 
{ 
  int p ;
  int pcnt ;
  int fdcnt ;
  int fdmax ;
  fd_set ReadMask ;
  fd_set TestMask ;
  char prevChar ;
  struct timeval tmo ;
  int __d0 ;
  int __d1 ;
  char MsgBuf___0[64] ;
  int rc ;
  ssize_t tmp ;

  {
#line 402
  prevChar = (char )'\000';
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ReadMask.__fds_bits[0]): "memory");
#line 404
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  tmo.tv_sec = (__time_t )10;
#line 406
  tmo.tv_usec = (__suseconds_t )0;
#line 407
  fdmax = 0;
#line 407
  pcnt = fdmax;
#line 408
  p = 0;
  {
#line 408
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 408
    if (! (p < PeerCount)) {
#line 408
      goto while_break___0;
    }
#line 409
    if (Peer[p].Socket <= 0) {
#line 410
      goto __Cont;
    }
#line 411
    ReadMask.__fds_bits[Peer[p].Socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << Peer[p].Socket % (8 * (int )sizeof(__fd_mask ));
#line 412
    pcnt ++;
#line 413
    if (Peer[p].Socket > fdmax) {
#line 414
      fdmax = Peer[p].Socket;
    }
    __Cont: /* CIL Label */ 
#line 408
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 416
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 416
    if (! (pcnt > 0)) {
#line 416
      goto while_break___1;
    }
#line 417
    if (opt.Verbose) {
      {
#line 419
      sprintf((char */* __restrict  */)(MsgBuf___0), (char const   */* __restrict  */)"try to get outstanding messages from %d remote clients\n",
              pcnt);
#line 420
      fMessage(stdout, MsgBuf___0);
      }
    }
    {
#line 422
    memcpy((void */* __restrict  */)(& TestMask), (void const   */* __restrict  */)(& ReadMask),
           sizeof(TestMask));
#line 423
    fdcnt = select(fdmax + 1, (fd_set */* __restrict  */)(& TestMask), (fd_set */* __restrict  */)((fd_set *)0),
                   (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& tmo));
    }
#line 424
    if (fdcnt <= 0) {
#line 425
      goto while_break___1;
    }
#line 427
    p = 0;
    {
#line 427
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 427
      if (! (p < PeerCount)) {
#line 427
        goto while_break___2;
      }
#line 428
      if (Peer[p].Socket < 0) {
#line 429
        goto __Cont___0;
      }
#line 430
      if ((TestMask.__fds_bits[Peer[p].Socket / (8 * (int )sizeof(__fd_mask ))] & (1L << Peer[p].Socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 432
        tmp = read(Peer[p].Socket, (void *)(MsgBuf), sizeof(MsgBuf) - 1UL);
#line 432
        rc = (int )tmp;
        }
#line 433
        if (rc > 0) {
          {
#line 434
          MsgBuf[rc] = (char )'\000';
#line 435
          fputs((char const   */* __restrict  */)(MsgBuf), (FILE */* __restrict  */)stdout);
          }
#line 436
          if (rc == 1) {
#line 436
            if ((int )MsgBuf[0] == (int )prevChar) {
#line 441
              prevChar = MsgBuf[rc - 1];
#line 442
              ReadMask.__fds_bits[Peer[p].Socket / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << Peer[p].Socket % (8 * (int )sizeof(__fd_mask )));
#line 443
              pcnt --;
            } else {
#line 436
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 436
          if (rc > 1) {
#line 436
            if ((int )MsgBuf[rc - 1] == (int )finCh) {
#line 436
              if ((int )MsgBuf[rc - 2] == (int )finCh) {
#line 441
                prevChar = MsgBuf[rc - 1];
#line 442
                ReadMask.__fds_bits[Peer[p].Socket / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << Peer[p].Socket % (8 * (int )sizeof(__fd_mask )));
#line 443
                pcnt --;
              }
            }
          }
        } else
#line 446
        if (rc <= 0) {
          {
#line 447
          ReadMask.__fds_bits[Peer[p].Socket / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << Peer[p].Socket % (8 * (int )sizeof(__fd_mask )));
#line 448
          close(Peer[p].Socket);
#line 449
          Peer[p].Socket = -1;
#line 450
          pcnt --;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 427
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 455
  return;
}
}
#line 457 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void sysError(FILE *f , char *s ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 458
  tmp = __errno_location();
#line 458
  tmp___0 = __errno_location();
#line 458
  tmp___1 = strerror(*tmp___0);
#line 458
  syslog(7, "%s: %s, errno=%d\n", s, tmp___1, *tmp);
#line 459
  fMessage(f, s);
#line 460
  tmp___2 = __errno_location();
#line 460
  tmp___3 = __errno_location();
#line 460
  tmp___4 = strerror(*tmp___3);
#line 460
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)": %s, errno=%d\n",
          tmp___4, *tmp___2);
#line 461
  fflush(f);
  }
#line 462
  return;
}
}
#line 464 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void exitError(char *s , int ret ) 
{ 


  {
  {
#line 465
  sysError(stderr, s);
  }
#line 466
  if (! Remote) {
    {
#line 467
    FetchRemoteMsg((char )'\000');
    }
  }
  {
#line 468
  fflush(stdout);
#line 469
  exit(ret);
  }
}
}
#line 473 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void tvAdd(struct timeval *tsum , struct timeval *t1 , struct timeval *t0 ) 
{ 


  {
#line 474
  tsum->tv_sec = t0->tv_sec + t1->tv_sec;
#line 475
  tsum->tv_usec = t0->tv_usec + t1->tv_usec;
#line 476
  if (tsum->tv_usec > 1000000L) {
#line 477
    (tsum->tv_sec) ++;
#line 477
    tsum->tv_usec -= 1000000L;
  }
#line 478
  return;
}
}
#line 480 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void tvSub(struct timeval *tdiff , struct timeval *t1 , struct timeval *t0 ) 
{ 


  {
#line 481
  tdiff->tv_sec = t1->tv_sec - t0->tv_sec;
#line 482
  tdiff->tv_usec = t1->tv_usec - t0->tv_usec;
#line 483
  if (tdiff->tv_usec < 0L) {
#line 484
    (tdiff->tv_sec) --;
#line 484
    tdiff->tv_usec += 1000000L;
  }
#line 485
  return;
}
}
#line 487 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void StartTimer(void) 
{ 


  {
  {
#line 493
  gettimeofday((struct timeval */* __restrict  */)(& time0), (__timezone_ptr_t )((struct timezone *)0));
#line 494
  getrusage(0, & ru0);
#line 496
  SysCalls = 0;
  }
#line 497
  return;
}
}
#line 499 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void StopTimer(double *cput , double *realt ) 
{ 
  struct timeval timedol ;
  struct rusage ru1 ;
  struct timeval td ;
  struct timeval tend ;
  struct timeval tstart ;
  double secs ;

  {
  {
#line 511
  gettimeofday((struct timeval */* __restrict  */)(& timedol), (__timezone_ptr_t )((struct timezone *)0));
#line 512
  getrusage(0, & ru1);
#line 520
  tvSub(& td, & timedol, & time0);
#line 521
  secs = (double )td.tv_sec + (double )td.tv_usec / (double )1000000;
  }
#line 522
  if (secs < 0.00001) {
#line 523
    *realt = 0.00001;
  } else {
#line 525
    *realt = secs;
  }
  {
#line 528
  tvAdd(& tend, & ru1.ru_utime, & ru1.ru_stime);
#line 529
  tvAdd(& tstart, & ru0.ru_utime, & ru0.ru_stime);
#line 530
  tvSub(& td, & tend, & tstart);
#line 531
  secs = (double )td.tv_sec + (double )td.tv_usec / (double )1000000;
  }
#line 532
  if (secs < 0.00001) {
#line 533
    *cput = 0.00001;
  } else {
#line 535
    *cput = secs;
  }
#line 536
  return;
}
}
#line 538 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
double GetPidRate(int cnt ) 
{ 
  int n ;
  double cput ;
  double realt ;
  pid_t pid ;
  __pid_t tmp ;

  {
  {
#line 539
  n = cnt;
#line 542
  StartTimer();
  }
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    n --;
#line 543
    if (! (n > 0)) {
#line 543
      goto while_break;
    }
    {
#line 544
    tmp = getpid();
#line 544
    pid = tmp;
#line 545
    pid ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 547
  StopTimer(& cput, & realt);
  }
#line 548
  return ((double )cnt / cput);
}
}
#line 554 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
static unsigned char rb[250]  ;
#line 555 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
static int actp  ;
#line 555 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
static int actq  ;
#line 565 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
unsigned char r250(void) 
{ 
  unsigned char tmp ;

  {
#line 580
  actp ++;
#line 580
  if (actp >= 250) {
#line 580
    actp = 0;
  }
#line 580
  actq ++;
#line 580
  if (actq >= 250) {
#line 580
    actq = 0;
  }
#line 581
  tmp = (unsigned char )((int )rb[actp] ^ (int )rb[actq]);
#line 581
  rb[actp] = tmp;
#line 581
  return (tmp);
}
}
#line 584 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void streamr250(char *cp , int len ) 
{ 
  char *tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    tmp___1 = len;
#line 585
    len --;
#line 585
    if (! (tmp___1 > 0)) {
#line 585
      goto while_break;
    }
#line 586
    actp ++;
#line 586
    if (actp >= 250) {
#line 586
      actp = 0;
    }
#line 586
    actq ++;
#line 586
    if (actq >= 250) {
#line 586
      actq = 0;
    }
#line 587
    tmp = cp;
#line 587
    cp ++;
#line 587
    tmp___0 = (unsigned char )((int )rb[actp] ^ (int )rb[actq]);
#line 587
    rb[actp] = tmp___0;
#line 587
    *((unsigned char *)tmp) = tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  return;
}
}
#line 591 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void initr250(char *seed ) 
{ 
  int q ;
  int i ;
  int w ;
  char *p ;
  char b ;

  {
  {
#line 595
  memset((void *)(rb), 0, sizeof(rb));
#line 596
  p = seed;
#line 597
  w = 1;
#line 598
  q = 0;
#line 600
  i = 0;
  }
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! (i < 1000)) {
#line 600
      goto while_break;
    }
#line 601
    w = (w * (int )*p) % 1009;
#line 602
    rb[q] = (unsigned char )(w & 255);
#line 603
    q ++;
#line 603
    if (q >= 250) {
#line 604
      q = 0;
    }
#line 605
    p ++;
#line 605
    if (! *p) {
#line 606
      p = seed;
    }
#line 600
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 609
  b = (char)-1;
  {
#line 610
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 610
    if (! b) {
#line 610
      goto while_break___0;
    }
#line 611
    rb[q] = (unsigned char )((int )rb[q] | (int )b);
#line 612
    b = (char )((int )b << 1);
#line 613
    rb[q] = (unsigned char )((int )rb[q] ^ (int )b);
#line 614
    q += 37;
#line 614
    if (q >= 250) {
#line 615
      q -= 250;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 617
  actp = 0;
#line 618
  actq = 103;
#line 621
  return;
}
}
#line 626 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int SetTCP_NoDelay(int fd ) 
{ 
  int one ;
  int ret ;
  struct protoent *p ;

  {
  {
#line 629
  p = getprotobyname("tcp");
  }
#line 630
  if ((unsigned long )p == (unsigned long )((struct protoent *)0)) {
#line 631
    return (-1);
  }
  {
#line 632
  ret = setsockopt(fd, p->p_proto, 1, (void const   *)((char *)(& one)), (socklen_t )sizeof(one));
  }
#line 633
  if (ret < 0) {
#line 634
    return (ret);
  } else {
#line 636
    return (0);
  }
}
}
#line 654 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void Pattern(char *cp , int cnt ) 
{ 


  {
  {
#line 655
  streamr250(cp, cnt);
  }
#line 656
  return;
}
}
#line 658 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void StartPattern(char *InitString ) 
{ 


  {
#line 659
  if (InitString) {
    {
#line 660
    initr250(InitString);
    }
  } else {
    {
#line 662
    initr250((char *)"This is a simple init string");
    }
  }
#line 663
  return;
}
}
#line 674 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int mread(int fd , char *bufp , unsigned int n ) 
{ 
  unsigned int count ;
  int nread ;
  ssize_t tmp ;

  {
#line 675
  count = 0U;
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 679
    tmp = read(fd, (void *)bufp, (size_t )(n - count));
#line 679
    nread = (int )tmp;
#line 680
    SysCalls ++;
    }
#line 681
    if (nread < 0) {
      {
#line 682
      perror("ttcp_mread");
      }
#line 683
      return (-1);
    }
#line 685
    if (nread == 0) {
#line 686
      return ((int )count);
    }
#line 687
    count += (unsigned int )nread;
#line 688
    bufp += nread;
#line 678
    if (! (count < n)) {
#line 678
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 690
  return ((int )count);
}
}
#line 693 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int Nread(int fd , char *buf , int count ) 
{ 
  register int cnt ;
  struct sockaddr_in from ;
  int len ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 695
  if (opt.udp) {
    {
#line 697
    len = (int )sizeof(from);
#line 698
    tmp = recvfrom(fd, (void */* __restrict  */)buf, (size_t )count, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                   (socklen_t */* __restrict  */)(& len));
#line 698
    cnt = (int )tmp;
#line 699
    SysCalls ++;
    }
  } else {
    {
#line 707
    tmp___0 = read(fd, (void *)buf, (size_t )count);
#line 707
    cnt = (int )tmp___0;
#line 708
    SysCalls ++;
    }
  }
#line 713
  return (cnt);
}
}
#line 717 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void delay(int us ) 
{ 
  struct timeval tv ;
  long remain ;
  double start ;
  double sec_delay ;
  struct timeval tv1 ;

  {
#line 741
  tv.tv_sec = (__time_t )(us / 1000000);
#line 742
  tv.tv_usec = (__suseconds_t )(us % 1000000);
#line 744
  remain = tv.tv_usec % 10000L;
#line 745
  tv.tv_usec -= remain;
#line 746
  if (tv.tv_usec > 0L) {
    {
#line 747
    select(1, (fd_set */* __restrict  */)((fd_set *)0), (fd_set */* __restrict  */)((fd_set *)0),
           (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& tv));
    }
  } else
#line 746
  if (tv.tv_sec > 0L) {
    {
#line 747
    select(1, (fd_set */* __restrict  */)((fd_set *)0), (fd_set */* __restrict  */)((fd_set *)0),
           (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& tv));
    }
  }
  {
#line 749
  sec_delay = (double )remain * 1e-6;
#line 750
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((struct timezone *)0));
#line 751
  start = (double )tv.tv_sec + (double )tv.tv_usec * 1e-6;
  }
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 754
    gettimeofday((struct timeval */* __restrict  */)(& tv1), (__timezone_ptr_t )((struct timezone *)0));
    }
#line 755
    if (((double )tv1.tv_sec + (double )tv1.tv_usec * 1e-6) - start >= sec_delay) {
#line 756
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 758
  return;
}
}
#line 760 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int Nwrite(int fd , char *buf , int count ) 
{ 
  int cnt ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 762
  if (opt.StreamPattern) {
    {
#line 763
    streamr250(buf, count);
    }
  }
#line 764
  if (opt.udp) {
    again: 
    {
#line 766
    tmp = sendto(fd, (void const   *)buf, (size_t )count, 0, (struct sockaddr  const  *)((struct sockaddr *)(& dta_to)),
                 (socklen_t )sizeof(dta_to));
#line 766
    cnt = (int )tmp;
#line 767
    SysCalls ++;
    }
#line 768
    if (cnt < 0) {
      {
#line 768
      tmp___1 = __errno_location();
      }
#line 768
      if (*tmp___1 == 105) {
        {
#line 769
        tmp___0 = __errno_location();
#line 769
        *tmp___0 = 0;
        }
#line 770
        goto again;
      }
    }
  } else {
    {
#line 774
    tmp___2 = write(fd, (void const   *)buf, (size_t )count);
#line 774
    cnt = (int )tmp___2;
#line 775
    SysCalls ++;
    }
  }
#line 777
  if (opt.GapLength) {
    {
#line 778
    delay(opt.GapLength);
    }
  }
#line 780
  return (cnt);
}
}
#line 783 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void Usage(void) 
{ 


  {
  {
#line 784
  fputs((char const   */* __restrict  */)(UsageMessage), (FILE */* __restrict  */)stderr);
#line 785
  fflush(stderr);
#line 786
  exit(1);
  }
}
}
#line 789 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void GetSizeValue(int *ac , char ***av , int *val , int Limit , char *what ) 
{ 
  char *arg ;
  int argc ;
  char **argv ;
  int tmp ;

  {
#line 791
  argc = *ac;
#line 792
  argv = *av;
#line 793
  if ((int )*(*(argv + 0) + 2) == 0) {
#line 794
    argc --;
#line 794
    argv ++;
#line 795
    arg = *(argv + 0);
  } else {
#line 798
    arg = *(argv + 0) + 2;
  }
#line 799
  *ac = argc;
#line 800
  *av = argv;
#line 801
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 802
    sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"missing argument value for %s\n",
            what);
#line 803
    fMessage(stderr, MsgBuf);
#line 804
    Usage();
    }
  }
  {
#line 806
  tmp = atoi((char const   *)arg);
#line 806
  *val = tmp;
  }
#line 806
  if (tmp <= 0) {
    {
#line 807
    sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"invalid value for %s (%.30s)\n",
            what, arg);
#line 808
    fMessage(stderr, MsgBuf);
#line 809
    Usage();
    }
  } else
#line 806
  if (*val >= Limit) {
    {
#line 807
    sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"invalid value for %s (%.30s)\n",
            what, arg);
#line 808
    fMessage(stderr, MsgBuf);
#line 809
    Usage();
    }
  }
#line 811
  return;
}
}
#line 813 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
char *EightBits(char *bits , char value ) 
{ 
  char bit ;
  int i ;

  {
#line 814
  bit = (char)1;
#line 815
  i = (int )(sizeof(value) * 8UL);
#line 816
  *(bits + i) = (char )'\000';
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    i --;
#line 818
    if ((int )value & (int )bit) {
#line 818
      *(bits + i) = (char )'1';
    } else {
#line 818
      *(bits + i) = (char )'0';
    }
#line 817
    bit = (char )((int )bit << 1);
#line 817
    if (! bit) {
#line 817
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 820
  return (bits);
}
}
#line 823 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int BufCompare(char *cp , char *expect , int leng , unsigned long nBytes , int BufLen ,
               int *Reported ) 
{ 
  int Failed ;
  int n ;
  int ne ;
  char rBits[9] ;
  char eBits[9] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 824
  Failed = 0;
#line 827
  ne = 0;
#line 828
  n = 0;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! (n < leng)) {
#line 828
      goto while_break;
    }
#line 829
    if ((int )*(cp + n) != (int )*(expect + ne)) {
#line 830
      Failed ++;
#line 831
      if (*Reported == 0) {
        {
#line 832
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"Here the list of at most %d failed comparisions:\n",
                ReportLimit);
#line 833
        fMessage(stdout, MsgBuf);
#line 834
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"%-9s%-10s%-10s\n",
                "byte#", "expected", "received");
#line 835
        fMessage(stdout, MsgBuf);
        }
      }
#line 837
      if (*Reported < ReportLimit) {
        {
#line 839
        (*Reported) ++;
#line 840
        tmp = EightBits(rBits, *(cp + n));
#line 840
        tmp___0 = EightBits(eBits, *(expect + n));
#line 840
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"%9ld%10s%10s\n",
                nBytes + (unsigned long )n, tmp___0, tmp);
#line 843
        fMessage(stdout, MsgBuf);
        }
      }
    }
#line 850
    ne ++;
#line 828
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  return (Failed);
}
}
#line 855 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
short GetService(void) 
{ 
  struct servent *ttcpService ;
  uint16_t tmp ;

  {
  {
#line 857
  ttcpService = getservbyname("ttcp", "tcp");
  }
#line 858
  if ((unsigned long )ttcpService == (unsigned long )((struct servent *)0)) {
#line 859
    return ((short)5037);
  } else {
    {
#line 861
    tmp = ntohs((uint16_t )ttcpService->s_port);
    }
#line 861
    return ((short )tmp);
  }
}
}
#line 864 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void InitOptions(Options *opt___0 ) 
{ 


  {
  {
#line 866
  opt___0->PidCalls = 0;
#line 867
  opt___0->udp = 0;
#line 868
  opt___0->Compare = 0;
#line 869
  opt___0->StreamPattern = 0;
#line 870
  opt___0->Title = 0;
#line 871
  opt___0->b_flag = 0;
#line 872
  opt___0->SockOpt = 0;
#line 873
  opt___0->NoDelay = 0;
#line 874
  opt___0->BufCnt = 2048;
#line 875
  opt___0->BufLen = 4096;
#line 876
  opt___0->FixedDataSize = 0;
#line 877
  opt___0->Window = 0;
#line 878
  opt___0->Verbose = 0;
#line 879
  opt___0->GapLength = 0;
#line 880
  opt___0->inetd = 0;
#line 881
  opt___0->Service = GetService();
#line 882
  opt___0->MulticastChannel = (char *)((void *)0);
#line 883
  opt___0->MulticastPort = (short)0;
#line 884
  opt___0->Transmit = 1;
#line 885
  opt___0->Format = (char *)"%9b%8.2rt%8.2ct%12.4rbr%12.4cbr%8c%10.2rcr%10.1ccr";
#line 886
  opt___0->InitString = (char *)0;
  }
#line 887
  return;
}
}
#line 890 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void ParseOptions(int *ac , char ***av , Options *opt___0 ) 
{ 
  int argc ;
  char **argv ;
  int tmp ;
  int val ;
  char *p ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 891
  argc = *ac;
#line 892
  argv = *av;
#line 893
  argv ++;
#line 893
  argc --;
  {
#line 894
  while (1) {
    while_continue: /* CIL Label */ ;
#line 894
    if (argc > 0) {
#line 894
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 894
        goto while_break;
      }
    } else {
#line 894
      goto while_break;
    }
    {
#line 896
    if ((int )*(*(argv + 0) + 1) == 116) {
#line 896
      goto case_116;
    }
#line 899
    if ((int )*(*(argv + 0) + 1) == 114) {
#line 899
      goto case_114;
    }
#line 902
    if ((int )*(*(argv + 0) + 1) == 84) {
#line 902
      goto case_84;
    }
#line 910
    if ((int )*(*(argv + 0) + 1) == 100) {
#line 910
      goto case_100;
    }
#line 913
    if ((int )*(*(argv + 0) + 1) == 68) {
#line 913
      goto case_68;
    }
#line 916
    if ((int )*(*(argv + 0) + 1) == 102) {
#line 916
      goto case_102;
    }
#line 924
    if ((int )*(*(argv + 0) + 1) == 103) {
#line 924
      goto case_103;
    }
#line 928
    if ((int )*(*(argv + 0) + 1) == 108) {
#line 928
      goto case_108;
    }
#line 934
    if ((int )*(*(argv + 0) + 1) == 110) {
#line 934
      goto case_110;
    }
#line 940
    if ((int )*(*(argv + 0) + 1) == 120) {
#line 940
      goto case_120;
    }
#line 944
    if ((int )*(*(argv + 0) + 1) == 78) {
#line 944
      goto case_78;
    }
#line 948
    if ((int )*(*(argv + 0) + 1) == 119) {
#line 948
      goto case_119;
    }
#line 954
    if ((int )*(*(argv + 0) + 1) == 117) {
#line 954
      goto case_117;
    }
#line 957
    if ((int )*(*(argv + 0) + 1) == 118) {
#line 957
      goto case_118;
    }
#line 960
    if ((int )*(*(argv + 0) + 1) == 86) {
#line 960
      goto case_86;
    }
#line 963
    if ((int )*(*(argv + 0) + 1) == 63) {
#line 963
      goto case_63;
    }
#line 967
    if ((int )*(*(argv + 0) + 1) == 115) {
#line 967
      goto case_115;
    }
#line 970
    if ((int )*(*(argv + 0) + 1) == 99) {
#line 970
      goto case_99;
    }
#line 973
    if ((int )*(*(argv + 0) + 1) == 112) {
#line 973
      goto case_112;
    }
#line 979
    if ((int )*(*(argv + 0) + 1) == 82) {
#line 979
      goto case_82;
    }
#line 983
    if ((int )*(*(argv + 0) + 1) == 83) {
#line 983
      goto case_83;
    }
#line 991
    if ((int )*(*(argv + 0) + 1) == 105) {
#line 991
      goto case_105;
    }
#line 994
    if ((int )*(*(argv + 0) + 1) == 109) {
#line 994
      goto case_109;
    }
#line 1016
    goto switch_default;
    case_116: /* CIL Label */ 
#line 897
    opt___0->Transmit = 1;
#line 898
    goto switch_break;
    case_114: /* CIL Label */ 
#line 900
    opt___0->Transmit = 0;
#line 901
    goto switch_break;
    case_84: /* CIL Label */ 
#line 903
    opt___0->Title = 1;
#line 904
    goto switch_break;
    case_100: /* CIL Label */ 
#line 911
    opt___0->SockOpt |= 1;
#line 912
    goto switch_break;
    case_68: /* CIL Label */ 
#line 914
    opt___0->NoDelay = 1;
#line 915
    goto switch_break;
    case_102: /* CIL Label */ 
#line 917
    if (*(*(argv + 0) + 2)) {
#line 918
      opt___0->Format = *(argv + 0) + 2;
    } else {
#line 920
      argv ++;
#line 920
      argc --;
#line 921
      opt___0->Format = *(argv + 0);
    }
#line 923
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 925
    GetSizeValue(& argc, & argv, & opt___0->GapLength, 10000000, (char *)"UDP gap-length");
    }
#line 927
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 929
    GetSizeValue(& argc, & argv, & opt___0->BufLen, 100000000, (char *)"bufferlength");
    }
#line 931
    if (opt___0->FixedDataSize > 0) {
#line 931
      if (opt___0->BufLen > 0) {
#line 932
        opt___0->BufCnt = opt___0->FixedDataSize / opt___0->BufLen;
      }
    }
#line 933
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 935
    GetSizeValue(& argc, & argv, & opt___0->BufCnt, 1000000000, (char *)"buffercount");
    }
#line 937
    if (opt___0->FixedDataSize > 0) {
#line 937
      if (opt___0->BufCnt > 0) {
#line 938
        opt___0->BufLen = opt___0->FixedDataSize / opt___0->BufCnt;
      }
    }
#line 939
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 941
    GetSizeValue(& argc, & argv, & opt___0->FixedDataSize, 1000000000, (char *)"fixed data size");
    }
#line 943
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 945
    GetSizeValue(& argc, & argv, & opt___0->RemoteNumber, 10, (char *)"RemoteNumber");
    }
#line 947
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 949
    GetSizeValue(& argc, & argv, & opt___0->SndWin, 10000, (char *)"windowsize");
#line 951
    tmp = opt___0->SndWin * 1024;
#line 951
    opt___0->SndWin = tmp;
#line 951
    opt___0->RcvWin = tmp;
#line 952
    opt___0->Window = 1;
    }
#line 953
    goto switch_break;
    case_117: /* CIL Label */ 
#line 955
    opt___0->udp = 1;
#line 956
    goto switch_break;
    case_118: /* CIL Label */ 
#line 958
    opt___0->Verbose = 1;
#line 959
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 961
    fputs((char const   */* __restrict  */)(VersionString), (FILE */* __restrict  */)stdout);
#line 962
    exit(0);
    }
    case_63: /* CIL Label */ 
    {
#line 964
    fputs((char const   */* __restrict  */)(VersionString), (FILE */* __restrict  */)stdout);
#line 965
    fputs((char const   */* __restrict  */)(UsageMessage), (FILE */* __restrict  */)stdout);
#line 966
    exit(0);
    }
    case_115: /* CIL Label */ 
#line 968
    opt___0->StreamPattern = 1;
#line 969
    goto switch_break;
    case_99: /* CIL Label */ 
#line 971
    opt___0->Compare = 1;
#line 972
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 975
    GetSizeValue(& argc, & argv, & val, 65536, (char *)"service port");
#line 976
    opt___0->Service = (short )val;
    }
#line 978
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 980
    GetSizeValue(& argc, & argv, & opt___0->PidCalls, 2000000000, (char *)"pid calls");
    }
#line 982
    goto switch_break;
    case_83: /* CIL Label */ 
#line 984
    if (*(*(argv + 0) + 2)) {
#line 985
      opt___0->InitString = *(argv + 0) + 2;
    } else {
#line 987
      argv ++;
#line 987
      argc --;
#line 988
      opt___0->InitString = *(argv + 0);
    }
#line 990
    goto switch_break;
    case_105: /* CIL Label */ 
#line 992
    opt___0->inetd = 1;
#line 993
    goto switch_break;
    case_109: /* CIL Label */ 
#line 997
    if (*(*(argv + 0) + 2)) {
#line 998
      opt___0->MulticastChannel = *(argv + 0) + 2;
    } else {
#line 1000
      argv ++;
#line 1000
      argc --;
#line 1001
      opt___0->MulticastChannel = *(argv + 0);
    }
    {
#line 1003
    p = strchr((char const   *)opt___0->MulticastChannel, ':');
    }
#line 1003
    if (p) {
      {
#line 1004
      *p = (char )'\000';
#line 1005
      tmp___0 = atoi((char const   *)(p + 1));
#line 1005
      opt___0->MulticastPort = (short )tmp___0;
      }
    } else {
#line 1008
      opt___0->MulticastPort = (short)5047;
    }
#line 1014
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1017
    strcpy((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"unknown option: ");
#line 1018
    tmp___1 = strlen((char const   *)(MsgBuf));
#line 1018
    strncat((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)*(argv + 0),
            (sizeof(MsgBuf) - tmp___1) - 1UL);
#line 1019
    fMessage(stderr, MsgBuf);
#line 1020
    Usage();
    }
    switch_break: /* CIL Label */ ;
    }
#line 1023
    argv ++;
#line 1023
    argc --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1028
  *ac = argc;
#line 1029
  *av = argv;
#line 1030
  return;
}
}
#line 1033 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int MakeArgvFromEnv(char *EnvName , char **argv , int start , int Max ) 
{ 
  char *env ;
  char *tmp ;
  int ac ;
  char *tok ;
  char *space ;
  char *nenv ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1037
  tmp = getenv((char const   *)EnvName);
#line 1037
  env = tmp;
  }
#line 1038
  if ((unsigned long )env != (unsigned long )((char *)0)) {
    {
#line 1039
    ac = start;
#line 1040
    space = (char *)" \t\n";
#line 1041
    tmp___0 = strdup((char const   *)env);
#line 1041
    nenv = tmp___0;
    }
#line 1042
    if ((unsigned long )nenv == (unsigned long )((char *)0)) {
#line 1043
      return (-1);
    }
    {
#line 1045
    tok = strtok((char */* __restrict  */)nenv, (char const   */* __restrict  */)space);
    }
    {
#line 1046
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1046
      if (! ((unsigned long )tok != (unsigned long )((char *)0))) {
#line 1046
        goto while_break;
      }
#line 1047
      tmp___1 = ac;
#line 1047
      ac ++;
#line 1047
      *(argv + tmp___1) = tok;
#line 1048
      if (ac == Max - 1) {
#line 1049
        goto while_break;
      }
      {
#line 1050
      tok = strtok((char */* __restrict  */)((char *)0), (char const   */* __restrict  */)space);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1052
    *(argv + ac) = (char *)((void *)0);
#line 1053
    return (ac - start);
  } else {
#line 1056
    return (0);
  }
}
}
#line 1060 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void ParseOptionsFromEnv(char *EnvName , Options *opt___0 ) 
{ 
  int ac ;
  int argc ;
  char **av_scratch ;
  char **argv ;
  void *tmp ;

  {
  {
#line 1068
  tmp = malloc(50UL * sizeof(char *));
#line 1068
  argv = (char **)tmp;
  }
#line 1069
  if ((unsigned long )argv == (unsigned long )((char **)0)) {
#line 1070
    return;
  }
  {
#line 1072
  argc = 1;
#line 1073
  ac = MakeArgvFromEnv(EnvName, argv, argc, 50);
  }
#line 1074
  if (ac < 0) {
    {
#line 1075
    free((void *)argv);
    }
#line 1076
    return;
  }
  {
#line 1078
  argc = ac + 1;
#line 1079
  av_scratch = argv;
#line 1080
  ParseOptions(& argc, & av_scratch, opt___0);
#line 1081
  free((void *)argv);
  }
#line 1082
  return;
}
}
#line 1085 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int createControlSocket(char *RemHost ) 
{ 
  int rh ;
  struct sockaddr_in sinrh ;
  struct sockaddr_in sinlh ;
  struct hostent *addr ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1089
  memset((void *)(& sinrh), 0, sizeof(sinrh));
#line 1090
  tmp___1 = atoi((char const   *)RemHost);
  }
#line 1090
  if (tmp___1 > 0) {
    {
#line 1091
    sinrh.sin_family = (sa_family_t )2;
#line 1092
    sinrh.sin_addr.s_addr = inet_addr((char const   *)RemHost);
#line 1093
    Peer[PeerCount].IPName = RemHost;
#line 1094
    Peer[PeerCount].HostName = RemHost;
    }
  } else {
    {
#line 1098
    addr = gethostbyname((char const   *)RemHost);
    }
#line 1098
    if ((unsigned long )addr == (unsigned long )((void *)0)) {
      {
#line 1099
      strcpy((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"bad hostname: ");
#line 1100
      tmp = strlen((char const   *)(MsgBuf));
#line 1100
      strncat((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)RemHost,
              (sizeof(MsgBuf) - tmp) - 1UL);
#line 1101
      sysError(stderr, MsgBuf);
      }
#line 1102
      return (-6);
    }
    {
#line 1104
    sinrh.sin_family = (sa_family_t )addr->h_addrtype;
#line 1105
    memcpy((void */* __restrict  */)(& sinrh.sin_addr.s_addr), (void const   */* __restrict  */)*(addr->h_addr_list + 0),
           (size_t )addr->h_length);
#line 1106
    tmp___0 = inet_ntoa(sinrh.sin_addr);
#line 1106
    Peer[PeerCount].IPName = strdup((char const   *)tmp___0);
#line 1107
    Peer[PeerCount].HostName = RemHost;
    }
  }
  {
#line 1109
  sinrh.sin_port = htons((uint16_t )opt.Service);
#line 1110
  sinrh.sin_family = (sa_family_t )2;
#line 1112
  rh = socket(2, 1, 0);
  }
#line 1112
  if (rh < 0) {
    {
#line 1113
    sysError(stderr, (char *)"control-socket");
    }
#line 1114
    return (-7);
  }
  {
#line 1116
  Peer[PeerCount].Socket = rh;
#line 1118
  memset((void *)(& sinlh), 0, sizeof(sinlh));
#line 1119
  sinlh.sin_family = (sa_family_t )2;
#line 1120
  sinlh.sin_port = (in_port_t )0;
#line 1121
  tmp___2 = bind(rh, (struct sockaddr  const  *)((struct sockaddr *)(& sinlh)), (socklen_t )sizeof(sinlh));
  }
#line 1121
  if (tmp___2 < 0) {
    {
#line 1122
    sysError(stderr, (char *)"bind");
#line 1123
    close(rh);
    }
#line 1124
    return (-8);
  }
  {
#line 1127
  tmp___3 = connect(rh, (struct sockaddr  const  *)((struct sockaddr *)(& sinrh)),
                    (socklen_t )sizeof(sinrh));
  }
#line 1127
  if (tmp___3 < 0) {
    {
#line 1128
    sysError(stderr, (char *)"connect");
#line 1129
    close(rh);
    }
#line 1130
    return (-9);
  }
  {
#line 1133
  tmp___4 = SetTCP_NoDelay(rh);
  }
#line 1133
  if (tmp___4 < 0) {
    {
#line 1134
    sysError(stderr, (char *)"cannot set TCP_NODELAY on protocol socket");
#line 1135
    close(rh);
    }
#line 1136
    return (-10);
  }
#line 1138
  Peer[PeerCount].Socket = rh;
#line 1139
  PeerCount ++;
#line 1140
  return (0);
}
}
#line 1143 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
void stripNewLine(char *s ) 
{ 
  int l ;
  size_t tmp ;

  {
  {
#line 1144
  tmp = strlen((char const   *)s);
#line 1144
  l = (int )(tmp - 1UL);
  }
#line 1145
  if (0 <= l) {
#line 1145
    if ((int )*(s + l) == 10) {
#line 1146
      *(s + l) = (char )'\000';
    }
  }
#line 1147
  return;
}
}
#line 1827
int main(int argc , char **argv ) ;
#line 1827 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
static int going  =    0;
#line 1150 "/home/wheatley/newnew/temp/nttcp-1.47/nttcp.c"
int main(int argc , char **argv ) 
{ 
  struct sockaddr_in PeerAddr ;
  int PeerAddrLeng ;
  char *DataPortFormat ;
  int DataPort ;
  struct sockaddr_in sinlh ;
  int fd ;
  char *buf ;
  char *ExpectBuf ;
  unsigned long nBytes ;
  unsigned long nBuffer ;
  double cput ;
  double realt ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  int nsrv ;
  int srv ;
  int fromleng ;
  struct sockaddr_in sinsrv ;
  struct sockaddr_in frominet ;
  int tmp___2 ;
  int tmp___3 ;
  int FailCnt ;
  pid_t pid ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  StrVec *OptionArg ;
  struct hostent *PeerHost ;
  char OptionLine[1024] ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  __pid_t tmp___15 ;
  __pid_t tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int i ;
  int p ;
  StrVec *RemOpt ;
  char *RemOptStr ;
  char *RemNum ;
  int RemOptLeng ;
  char OptBuf[64] ;
  char **av ;
  void *tmp___21 ;
  int ac ;
  int tmp___22 ;
  StrVec *sv ;
  StrVec *tmp___23 ;
  StrVec *MoreOpt ;
  StrVec *tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int rs ;
  ssize_t tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  int tmp___31 ;
  int p___0 ;
  char LineBuf[256] ;
  int p___1 ;
  char *tmp___32 ;
  char loop ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  uint16_t tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int ml ;
  int p___2 ;
  int join_group ;
  struct ip_mreq mreq ;
  char Message[256] ;
  uint16_t tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  struct sockaddr_in frominet___0 ;
  int fromleng___0 ;
  struct sockaddr_in peer ;
  int peerlen ;
  int tmp___43 ;
  char *tmp___44 ;
  int one ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int optlen ;
  int WinSize ;
  int tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;
  char const   *tmp___51 ;
  double tmp___52 ;
  int n ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int cnt ;
  int ReportCnt ;
  unsigned long FailedCnt ;
  int tmp___57 ;
  int tmp___58 ;
  struct ip_mreq mreq___0 ;
  char *iFormat ;
  char *fFormat ;
  char *fs ;
  LenStr *TitleLine ;
  LenStr *StatLine ;
  char *cp ;
  char *nc ;
  char *TitleStr ;
  int fp ;
  int fw ;
  int l ;
  int tmp___59 ;
  size_t tmp___60 ;
  long tmp___61 ;
  long tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;

  {
  {
#line 1154
  DataPortFormat = (char *)"dataport: %d\n";
#line 1159
  ExpectBuf = (char *)0;
#line 1165
  myname = strrchr((char const   *)*(argv + 0), '/');
  }
#line 1165
  if ((unsigned long )myname != (unsigned long )((char *)0)) {
#line 1166
    myname ++;
  } else {
#line 1168
    myname = *(argv + 0);
  }
  {
#line 1170
  tmp___0 = getuid();
  }
#line 1170
  if (tmp___0 == 0U) {
#line 1170
    goto _L;
  } else {
    {
#line 1170
    tmp___1 = geteuid();
    }
#line 1170
    if (tmp___1 == 0U) {
      _L: /* CIL Label */ 
      {
#line 1171
      tmp = setuid((1U << (sizeof(uid_t ) * 8UL - 1UL)) - 1U);
      }
#line 1171
      if (tmp != 0) {
        {
#line 1172
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"cannot setuid(%d)\n",
                (1U << (sizeof(uid_t ) * 8UL - 1UL)) - 1U);
#line 1173
        fMessage(stdout, MsgBuf);
#line 1174
        exit(1);
        }
      }
    }
  }
  {
#line 1178
  InitOptions(& opt);
#line 1179
  ParseOptionsFromEnv((char *)"NTTCP_LOC_OPT", & opt);
#line 1180
  ParseOptions(& argc, & argv, & opt);
  }
#line 1181
  if (opt.Verbose) {
    {
#line 1182
    sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"%s, version %s\n",
            myname, version);
#line 1183
    fMessage(stdout, MsgBuf);
    }
  }
#line 1185
  if (opt.inetd) {
#line 1190
    if (opt.Verbose) {
      {
#line 1191
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"running in inetd mode on port %d - ignoring options beside -v and -p\n",
              (int )opt.Service);
#line 1193
      fMessage(stdout, MsgBuf);
      }
    }
    {
#line 1195
    srv = socket(2, 1, 0);
    }
#line 1195
    if (srv < 0) {
      {
#line 1196
      exitError((char *)"service-socket: socket", 99);
      }
    }
    {
#line 1197
    memset((void *)(& sinsrv), 0, sizeof(sinsrv));
#line 1198
    sinsrv.sin_family = (sa_family_t )2;
#line 1199
    sinsrv.sin_port = htons((uint16_t )opt.Service);
#line 1200
    tmp___2 = bind(srv, (struct sockaddr  const  *)((struct sockaddr *)(& sinsrv)),
                   (socklen_t )sizeof(sinsrv));
    }
#line 1200
    if (tmp___2 < 0) {
      {
#line 1201
      exitError((char *)"service-socket: bind:", 101);
      }
    }
    {
#line 1202
    tmp___3 = listen(srv, 2);
    }
#line 1202
    if (tmp___3 < 0) {
      {
#line 1203
      exitError((char *)"service-socket", 103);
      }
    }
    {
#line 1204
    signal(17, & SigCld);
    }
    {
#line 1205
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1208
      fromleng = (int )sizeof(frominet);
#line 1209
      memset((void *)(& frominet), 0, (size_t )fromleng);
      }
      {
#line 1210
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1210
        nsrv = accept(srv, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& frominet)),
                      (socklen_t */* __restrict  */)(& fromleng));
        }
#line 1210
        if (! (nsrv < 0)) {
#line 1210
          goto while_break___0;
        }
        {
#line 1211
        tmp___4 = __errno_location();
        }
#line 1211
        if (*tmp___4 == 4) {
#line 1212
          goto while_continue___0;
        } else {
#line 1214
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1215
      if (nsrv < 0) {
        {
#line 1216
        exitError((char *)"service-accept", 115);
        }
      }
#line 1217
      FailCnt = 0;
      {
#line 1218
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1218
        pid = fork();
        }
#line 1218
        if (! (pid < 0)) {
#line 1218
          goto while_break___1;
        }
        {
#line 1219
        tmp___5 = __errno_location();
        }
#line 1219
        if (*tmp___5 == 11) {
#line 1219
          FailCnt ++;
#line 1219
          if (FailCnt < 100) {
            {
#line 1220
            sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"fork failed for try #%d\n",
                    FailCnt);
#line 1221
            fMessage(stdout, MsgBuf);
#line 1222
            signal(14, & AlarmNothing);
#line 1223
            itval.it_interval.tv_usec = (__suseconds_t )0;
#line 1223
            itval.it_interval.tv_sec = itval.it_interval.tv_usec;
#line 1223
            itval.it_value.tv_sec = (__time_t )0;
#line 1223
            itval.it_value.tv_usec = (__suseconds_t )200000;
#line 1223
            setitimer(0, (struct itimerval  const  */* __restrict  */)(& itval), (struct itimerval */* __restrict  */)((struct itimerval *)0));
#line 1223
            pause();
            }
#line 1224
            goto while_continue___1;
          } else {
#line 1227
            goto while_break___1;
          }
        } else {
#line 1227
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1229
      if (pid < 0) {
        {
#line 1230
        exitError((char *)"service-fork", 116);
        }
      }
#line 1231
      if (pid == 0) {
        {
#line 1232
        close(0);
#line 1233
        tmp___6 = dup2(nsrv, 0);
        }
#line 1233
        if (tmp___6 < 0) {
          {
#line 1234
          exitError((char *)"service-dup2(0)", 117);
          }
        }
        {
#line 1235
        close(1);
#line 1236
        tmp___7 = dup2(nsrv, 1);
        }
#line 1236
        if (tmp___7 < 0) {
          {
#line 1237
          exitError((char *)"service-dup2(1)", 118);
          }
        }
        {
#line 1238
        close(2);
#line 1239
        tmp___8 = dup2(nsrv, 2);
        }
#line 1239
        if (tmp___8 < 0) {
          {
#line 1240
          exitError((char *)"service-dup2(2)", 119);
          }
        }
#line 1241
        goto while_break;
      }
#line 1243
      if (opt.Verbose) {
        {
#line 1244
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"forked child (pid=%d) on socket-fd=fd=%d after %d retries\n",
                pid, nsrv, FailCnt);
#line 1248
        fMessage(stdout, MsgBuf);
        }
      }
      {
#line 1250
      close(nsrv);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1254
  PeerAddrLeng = (int )sizeof(PeerAddr);
#line 1255
  tmp___20 = getpeername(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& PeerAddr)),
                         (socklen_t */* __restrict  */)(& PeerAddrLeng));
  }
#line 1255
  if (tmp___20 == 0) {
    {
#line 1260
    Remote = 1;
#line 1261
    tmp___9 = inet_ntoa(PeerAddr.sin_addr);
#line 1261
    Peer[PeerCount].IPName = strdup((char const   *)tmp___9);
#line 1263
    PeerHost = gethostbyaddr((void const   *)((char *)(& PeerAddr.sin_addr.s_addr)),
                             (__socklen_t )sizeof(PeerAddr.sin_addr.s_addr), (int )PeerAddr.sin_family);
#line 1265
    openlog((char const   *)myname, 2, 1 << 3);
    }
#line 1266
    if (PeerHost) {
      {
#line 1267
      Peer[PeerCount].HostName = strdup((char const   *)PeerHost->h_name);
      }
    } else {
#line 1269
      Peer[PeerCount].HostName = (char *)"?";
    }
    {
#line 1270
    syslog(6, "call from %.50s (=%.30s)\n", Peer[PeerCount].HostName, Peer[PeerCount].IPName);
#line 1273
    tmp___10 = setsockopt(0, 1, 13, (void const   *)((char *)(& Ling)), (socklen_t )sizeof(Ling));
    }
#line 1273
    if (tmp___10 < 0) {
      {
#line 1274
      exitError((char *)"setsockopt-linger", 2);
      }
    }
    {
#line 1275
    tmp___11 = setsockopt(1, 1, 13, (void const   *)((char *)(& Ling)), (socklen_t )sizeof(Ling));
    }
#line 1275
    if (tmp___11 < 0) {
      {
#line 1276
      exitError((char *)"setsockopt-linger", 2);
      }
    }
    {
#line 1279
    tmp___12 = SetTCP_NoDelay(1);
    }
#line 1279
    if (tmp___12 < 0) {
      {
#line 1280
      exitError((char *)"cannot set TCP_NODELAY on protocol socket", 3);
      }
    }
    {
#line 1282
    OptionLine[sizeof(OptionLine) - 1UL] = (char )'\000';
#line 1283
    tmp___13 = fgets((char */* __restrict  */)(OptionLine), (int )sizeof(OptionLine),
                     (FILE */* __restrict  */)stdin);
    }
#line 1283
    if ((unsigned long )tmp___13 == (unsigned long )((char *)0)) {
      {
#line 1284
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"%s: fgets: cannot read stdin\n",
              myname);
#line 1285
      Exit(MsgBuf, 2);
      }
    }
#line 1287
    if ((int )OptionLine[sizeof(OptionLine) - 1UL] != 0) {
      {
#line 1288
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"%s: optionline longer than %d\n",
              myname, sizeof(OptionLine) - 1UL);
#line 1290
      Exit(MsgBuf, 3);
      }
    }
    {
#line 1292
    tmp___14 = strlen((char const   *)(OptionLine));
#line 1292
    OptionLine[tmp___14 - 1UL] = (char )'\000';
#line 1294
    OptionArg = StrVecFromString(OptionLine, (char )'@');
#line 1295
    argv = OptionArg->String;
#line 1296
    argc = OptionArg->Leng;
#line 1297
    myname = *(argv + 0);
#line 1298
    InitOptions(& opt);
#line 1299
    ParseOptions(& argc, & argv, & opt);
    }
#line 1300
    if (opt.Verbose) {
      {
#line 1301
      tmp___15 = getpid();
#line 1301
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"Pid=%d, InetPeer= %.30s\n",
              tmp___15, Peer[PeerCount].IPName);
#line 1303
      fMessage(stdout, MsgBuf);
#line 1304
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"Optionline=\"%.201s\"\n",
              OptionLine);
#line 1305
      fMessage(stdout, MsgBuf);
      }
    }
    {
#line 1307
    Peer[PeerCount].Socket = 0;
#line 1308
    Peer[PeerCount].fin = stdin;
#line 1309
    Peer[PeerCount].fout = stdout;
#line 1310
    syslog(7, "call from %.50 (=%.30s): done remote initial processing\n", Peer[PeerCount].HostName,
           Peer[PeerCount].IPName);
#line 1313
    PeerCount ++;
    }
  } else {
#line 1316
    if (opt.Verbose) {
      {
#line 1317
      tmp___16 = getpid();
#line 1317
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"Pid=%d\n",
              tmp___16);
#line 1318
      fMessage(stdout, MsgBuf);
      }
    }
    {
#line 1321
    tmp___19 = __errno_location();
    }
#line 1321
    if (*tmp___19 != 88) {
      {
#line 1322
      tmp___17 = __errno_location();
#line 1322
      tmp___18 = strerror(*tmp___17);
#line 1322
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: getpeername %s\n",
              myname, tmp___18);
#line 1324
      exit(4);
      }
    }
  }
#line 1329
  if (opt.InitString) {
#line 1330
    opt.Compare = 1;
  } else
#line 1329
  if (opt.StreamPattern) {
#line 1330
    opt.Compare = 1;
  }
#line 1331
  if (! opt.udp) {
#line 1331
    if (opt.Compare) {
#line 1332
      opt.StreamPattern = 1;
    }
  }
  {
#line 1334
  StartPattern(opt.InitString);
  }
#line 1341
  if (! Remote) {
#line 1350
    if (argc <= 0) {
      {
#line 1351
      fMessage(stderr, (char *)"don\'t know where to connect to\n");
#line 1352
      Usage();
      }
    }
#line 1354
    i = 0;
    {
#line 1355
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1355
      if (i < argc) {
#line 1355
        if (! ((int )*(*(argv + i) + 0) != 45)) {
#line 1355
          goto while_break___2;
        }
      } else {
#line 1355
        goto while_break___2;
      }
      {
#line 1357
      createControlSocket(*(argv + i));
#line 1358
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1360
    if (PeerCount == 0) {
      {
#line 1361
      exitError((char *)"Could not connect to remote host\n", 10);
      }
    }
#line 1362
    if (PeerCount > 1) {
#line 1365
      if ((unsigned long )opt.MulticastChannel == (unsigned long )((void *)0)) {
#line 1366
        opt.MulticastChannel = (char *)"224.17.50.37";
#line 1367
        opt.MulticastPort = (short)5047;
      }
#line 1369
      opt.Transmit = 1;
#line 1370
      opt.udp = 1;
    }
    {
#line 1380
    RemOpt = StrVecCreate(10);
#line 1381
    StrVecAppend(RemOpt, myname);
    }
#line 1382
    if (opt.Transmit) {
      {
#line 1383
      StrVecAppend(RemOpt, (char *)"-r");
      }
    } else {
      {
#line 1385
      StrVecAppend(RemOpt, (char *)"-t");
      }
#line 1386
      if (opt.NoDelay) {
        {
#line 1387
        StrVecAppend(RemOpt, (char *)"-D");
        }
      }
    }
    {
#line 1391
    tmp___21 = malloc(50UL * sizeof(char *));
#line 1391
    av = (char **)tmp___21;
    }
#line 1392
    if ((unsigned long )argv != (unsigned long )((char **)0)) {
      {
#line 1393
      tmp___22 = MakeArgvFromEnv((char *)"NTTCP_REM_OPT", av, 0, 50);
#line 1393
      ac = tmp___22;
#line 1394
      tmp___23 = StrVecFromArgv(ac, av);
#line 1394
      sv = tmp___23;
      }
#line 1395
      if ((unsigned long )sv != (unsigned long )((StrVec *)0)) {
        {
#line 1396
        StrVecJoin(RemOpt, sv);
#line 1397
        StrVecDestroy(sv);
        }
      }
      {
#line 1399
      free((void *)av);
      }
    }
    {
#line 1402
    sprintf((char */* __restrict  */)(OptBuf), (char const   */* __restrict  */)"-l%d",
            opt.BufLen);
#line 1403
    StrVecAppend(RemOpt, OptBuf);
#line 1404
    sprintf((char */* __restrict  */)(OptBuf), (char const   */* __restrict  */)"-n%d",
            opt.BufCnt);
#line 1405
    StrVecAppend(RemOpt, OptBuf);
    }
#line 1406
    if (opt.udp) {
      {
#line 1407
      StrVecAppend(RemOpt, (char *)"-u");
      }
    }
#line 1408
    if (opt.Verbose) {
      {
#line 1409
      StrVecAppend(RemOpt, (char *)"-v");
      }
    }
#line 1410
    if (opt.Compare) {
      {
#line 1411
      StrVecAppend(RemOpt, (char *)"-c");
      }
    }
#line 1412
    if (opt.StreamPattern) {
      {
#line 1413
      StrVecAppend(RemOpt, (char *)"-s");
      }
    }
#line 1414
    if (opt.Format) {
      {
#line 1415
      StrVecAppend(RemOpt, (char *)"-f");
#line 1416
      StrVecAppend(RemOpt, opt.Format);
      }
    }
#line 1418
    if (opt.InitString) {
      {
#line 1419
      StrVecAppend(RemOpt, (char *)"-S");
#line 1420
      StrVecAppend(RemOpt, opt.InitString);
      }
    }
#line 1422
    if (opt.PidCalls) {
      {
#line 1423
      sprintf((char */* __restrict  */)(OptBuf), (char const   */* __restrict  */)"-R%d",
              opt.PidCalls);
#line 1424
      StrVecAppend(RemOpt, OptBuf);
      }
    }
#line 1426
    if (opt.GapLength > 0) {
      {
#line 1427
      sprintf((char */* __restrict  */)(OptBuf), (char const   */* __restrict  */)"-g%d",
              opt.GapLength);
#line 1428
      StrVecAppend(RemOpt, OptBuf);
      }
    }
#line 1430
    if (opt.MulticastChannel) {
      {
#line 1431
      sprintf((char */* __restrict  */)(OptBuf), (char const   */* __restrict  */)"-m%s:%d",
              opt.MulticastChannel, (int )opt.MulticastPort);
#line 1433
      StrVecAppend(RemOpt, OptBuf);
      }
    }
    {
#line 1435
    StrVecAppend(RemOpt, (char *)"-Nx");
#line 1436
    argv ++;
#line 1436
    argc --;
    }
#line 1437
    if (argc > 0) {
      {
#line 1438
      tmp___24 = StrVecFromArgv(argc, argv);
#line 1438
      MoreOpt = tmp___24;
#line 1439
      StrVecJoin(RemOpt, MoreOpt);
#line 1440
      StrVecDestroy(MoreOpt);
      }
    }
    {
#line 1442
    RemOptStr = StrVecToString(RemOpt, (char )'@');
#line 1443
    tmp___25 = strlen((char const   *)RemOptStr);
#line 1443
    RemOptLeng = (int )tmp___25;
#line 1444
    tmp___26 = RemOptLeng;
#line 1444
    RemOptLeng ++;
#line 1444
    *(RemOptStr + tmp___26) = (char )'\n';
#line 1445
    *(RemOptStr + RemOptLeng) = (char )'\000';
#line 1447
    tmp___27 = strstr((char const   *)RemOptStr, "-Nx");
#line 1447
    RemNum = tmp___27 + 2;
#line 1449
    p = 0;
    }
    {
#line 1449
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1449
      if (! (p < PeerCount)) {
#line 1449
        goto while_break___3;
      }
      {
#line 1450
      rs = Peer[p].Socket;
#line 1451
      *RemNum = (char )(49 + p);
#line 1452
      tmp___28 = write(rs, (void const   *)RemOptStr, (size_t )RemOptLeng);
      }
#line 1452
      if (tmp___28 != (ssize_t )RemOptLeng) {
        {
#line 1453
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"cannot write options to peer \"%.50s\"=\"%.30s\"\n",
                Peer[p].HostName, Peer[p].IPName);
#line 1455
        exitError(MsgBuf, 11);
        }
      }
#line 1449
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1464
  tmp___29 = malloc((size_t )opt.BufLen);
#line 1464
  buf = (char *)tmp___29;
  }
#line 1464
  if ((unsigned long )buf == (unsigned long )((char *)((void *)0))) {
    {
#line 1465
    sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"malloc failed for %d bytes (snd/rcv buffer)\n",
            opt.BufLen);
#line 1466
    Exit(MsgBuf, 12);
    }
  }
#line 1468
  if (opt.Compare) {
    {
#line 1469
    tmp___30 = malloc((size_t )opt.BufLen);
#line 1469
    ExpectBuf = (char *)tmp___30;
    }
#line 1469
    if ((unsigned long )ExpectBuf == (unsigned long )((char *)((void *)0))) {
      {
#line 1470
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"malloc failed for %d bytes (ExpectBuf)\n",
              opt.BufLen);
#line 1471
      Exit(MsgBuf, 13);
      }
    }
  }
#line 1474
  if (opt.udp) {
#line 1474
    tmp___31 = 2;
  } else {
#line 1474
    tmp___31 = 1;
  }
  {
#line 1474
  fd = socket(2, tmp___31, 0);
  }
#line 1474
  if (fd < 0) {
    {
#line 1475
    exitError((char *)"data-socket", 13);
    }
  }
#line 1477
  if (Remote) {
#line 1478
    Peer[0].fin = stdin;
#line 1479
    Peer[0].fout = stdout;
  } else {
#line 1487
    p___0 = 0;
    {
#line 1487
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1487
      if (! (p___0 < PeerCount)) {
#line 1487
        goto while_break___4;
      }
      {
#line 1488
      Peer[p___0].fin = fdopen(Peer[p___0].Socket, "r");
      }
#line 1489
      if ((unsigned long )Peer[p___0].fin == (unsigned long )((void *)0)) {
        {
#line 1490
        exitError((char *)"fdopen", 21);
        }
      }
      {
#line 1491
      Peer[p___0].fout = fdopen(Peer[p___0].Socket, "w");
      }
#line 1492
      if ((unsigned long )Peer[p___0].fout == (unsigned long )((void *)0)) {
        {
#line 1493
        exitError((char *)"fdopen", 21);
        }
      }
#line 1487
      p___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1519
  if (opt.Transmit) {
#line 1522
    p___1 = 0;
    {
#line 1522
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1522
      if (! (p___1 < PeerCount)) {
#line 1522
        goto while_break___5;
      }
#line 1523
      DataPort = 0;
      {
#line 1524
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1524
        tmp___32 = fgets((char */* __restrict  */)(LineBuf), (int )sizeof(LineBuf),
                         (FILE */* __restrict  */)Peer[p___1].fin);
        }
#line 1524
        if (! ((unsigned long )tmp___32 != (unsigned long )((void *)0))) {
#line 1524
          goto while_break___6;
        }
#line 1525
        if (opt.Verbose) {
          {
#line 1526
          stripNewLine(LineBuf);
#line 1527
          sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"from %s: \"%.50s\" (=%.30s)\n",
                  Peer[p___1].HostName, Peer[p___1].IPName, LineBuf);
#line 1530
          fMessage(stdout, MsgBuf);
          }
        }
        {
#line 1532
        sscanf((char const   */* __restrict  */)(LineBuf), (char const   */* __restrict  */)DataPortFormat,
               & DataPort);
        }
#line 1533
        if (DataPort > 0) {
#line 1534
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1537
      if (opt.MulticastChannel) {
#line 1537
        if (DataPort != 5047) {
          {
#line 1538
          sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"receiving side %.50s (=%.30s) couldn\'t get multicast socket",
                  Peer[p___1].HostName, Peer[p___1].IPName);
#line 1541
          Exit(MsgBuf, 14);
          }
        }
      }
#line 1544
      if (DataPort == 0) {
        {
#line 1545
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"couldn\'t get dataport from receiving side \"%.50s\" (=%.30s)",
                Peer[p___1].HostName, Peer[p___1].IPName);
#line 1549
        Exit(MsgBuf, 15);
        }
      }
#line 1522
      p___1 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1553
    memset((void *)(& dta_to), 0, sizeof(dta_to));
#line 1554
    dta_to.sin_family = (sa_family_t )2;
    }
#line 1555
    if (opt.MulticastChannel) {
      {
#line 1556
      dta_to.sin_addr.s_addr = inet_addr((char const   *)opt.MulticastChannel);
#line 1557
      dta_to.sin_port = htons((uint16_t )opt.MulticastPort);
      }
    } else {
      {
#line 1560
      dta_to.sin_addr.s_addr = inet_addr((char const   *)Peer[0].IPName);
#line 1561
      dta_to.sin_port = htons((uint16_t )DataPort);
      }
    }
#line 1563
    if (opt.udp) {
#line 1565
      if (opt.MulticastChannel) {
        {
#line 1581
        loop = (char)0;
#line 1582
        tmp___33 = setsockopt(fd, 0, 34, (void const   *)(& loop), (socklen_t )sizeof(loop));
        }
#line 1582
        if (tmp___33 < 0) {
          {
#line 1583
          exitError((char *)"cannot diable multicast loopback", 15);
          }
        }
      }
    } else {
      {
#line 1589
      memset((void *)(& sinlh), 0, sizeof(sinlh));
#line 1590
      sinlh.sin_family = (sa_family_t )2;
#line 1591
      sinlh.sin_port = (in_port_t )0;
#line 1593
      tmp___34 = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& sinlh)),
                      (socklen_t )sizeof(sinlh));
      }
#line 1593
      if (tmp___34 < 0) {
        {
#line 1594
        exitError((char *)"bind-dta", 14);
        }
      }
#line 1596
      if (opt.Verbose & 2) {
        {
#line 1597
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"waiting for connect\n");
#line 1598
        fMessage(stdout, MsgBuf);
        }
      }
      {
#line 1600
      tmp___37 = connect(fd, (struct sockaddr  const  *)((struct sockaddr *)(& dta_to)),
                         (socklen_t )sizeof(dta_to));
      }
#line 1600
      if (tmp___37 < 0) {
        {
#line 1601
        tmp___35 = inet_ntoa(dta_to.sin_addr);
#line 1601
        tmp___36 = ntohs(dta_to.sin_port);
#line 1601
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"connect-dta: fd=%d, sin_port=%d, s_addr=%s",
                fd, (int )tmp___36, tmp___35);
#line 1603
        exitError(MsgBuf, 15);
        }
      }
#line 1605
      if (opt.Verbose & 2) {
        {
#line 1606
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"connected !\n");
#line 1607
        fMessage(stdout, MsgBuf);
        }
      }
#line 1609
      if (opt.NoDelay) {
        {
#line 1610
        tmp___38 = SetTCP_NoDelay(fd);
        }
#line 1610
        if (tmp___38 < 0) {
          {
#line 1611
          exitError((char *)"setsockopt: nodelay", 16);
          }
        }
      }
    }
  } else {
    {
#line 1616
    memset((void *)(& sinlh), 0, sizeof(sinlh));
#line 1617
    sinlh.sin_family = (sa_family_t )2;
    }
#line 1619
    if (opt.MulticastChannel) {
      {
#line 1622
      sinlh.sin_port = htons((uint16_t )opt.MulticastPort);
#line 1623
      tmp___40 = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& sinlh)),
                      (socklen_t )sizeof(sinlh));
      }
#line 1623
      if (tmp___40 < 0) {
        {
#line 1626
        fprintf((FILE */* __restrict  */)Peer[0].fout, (char const   */* __restrict  */)DataPortFormat,
                -1);
#line 1627
        tmp___39 = ntohs(sinlh.sin_port);
#line 1627
        sprintf((char */* __restrict  */)(Message), (char const   */* __restrict  */)"cannot bind to fixed multicast port %d\n",
                (int )tmp___39);
#line 1630
        exitError(Message, 23);
        }
      }
      {
#line 1633
      mreq.imr_interface.s_addr = (in_addr_t )0;
#line 1634
      mreq.imr_multiaddr.s_addr = inet_addr((char const   *)opt.MulticastChannel);
#line 1635
      join_group = setsockopt(fd, 0, 35, (void const   *)((char *)(& mreq)), (socklen_t )sizeof(mreq));
      }
#line 1637
      if (join_group < 0) {
        {
#line 1638
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)DataPortFormat,
                -1);
        }
      } else {
        {
#line 1640
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)DataPortFormat,
                5047);
        }
      }
      {
#line 1643
      tmp___41 = strlen((char const   *)(MsgBuf));
#line 1643
      ml = (int )tmp___41;
#line 1644
      p___2 = 0;
      }
      {
#line 1644
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1644
        if (! (p___2 < PeerCount)) {
#line 1644
          goto while_break___7;
        }
        {
#line 1645
        fputs((char const   */* __restrict  */)(MsgBuf), (FILE */* __restrict  */)Peer[p___2].fout);
#line 1646
        fflush(Peer[p___2].fout);
#line 1644
        p___2 ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1648
      if (join_group < 0) {
        {
#line 1649
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"cannot join multicast channel %.50s\n",
                opt.MulticastChannel);
#line 1652
        exitError(MsgBuf, 22);
        }
      }
    } else {
#line 1658
      DataPort = 5038;
      {
#line 1659
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1659
        if (! (DataPort < 20000)) {
#line 1659
          goto while_break___8;
        }
        {
#line 1660
        sinlh.sin_port = htons((uint16_t )DataPort);
#line 1661
        tmp___42 = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& sinlh)),
                        (socklen_t )sizeof(sinlh));
        }
#line 1661
        if (tmp___42 < 0) {
#line 1662
          DataPort ++;
        } else {
#line 1664
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1666
      if (DataPort >= 20000) {
        {
#line 1667
        fprintf((FILE */* __restrict  */)Peer[0].fout, (char const   */* __restrict  */)DataPortFormat,
                0);
#line 1668
        exitError((char *)"too many bind calls on datasocket", 17);
        }
      } else {
        {
#line 1671
        listen(fd, 5);
#line 1677
        fprintf((FILE */* __restrict  */)Peer[0].fout, (char const   */* __restrict  */)DataPortFormat,
                DataPort);
        }
      }
      {
#line 1679
      fflush(Peer[0].fout);
      }
    }
#line 1681
    if (! opt.udp) {
      {
#line 1687
      fromleng___0 = (int )sizeof(frominet___0);
#line 1688
      memset((void *)(& frominet___0), 0, (size_t )fromleng___0);
#line 1689
      AlarmMsg = (char *)"accept timed out\n";
#line 1690
      signal(14, & AlarmExit);
#line 1691
      itval.it_interval.tv_usec = (__suseconds_t )0;
#line 1691
      itval.it_interval.tv_sec = itval.it_interval.tv_usec;
#line 1691
      itval.it_value.tv_sec = (__time_t )80;
#line 1691
      itval.it_value.tv_usec = (__suseconds_t )0;
#line 1691
      setitimer(0, (struct itimerval  const  */* __restrict  */)(& itval), (struct itimerval */* __restrict  */)((struct itimerval *)0));
#line 1692
      fd = accept(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& frominet___0)),
                  (socklen_t */* __restrict  */)(& fromleng___0));
      }
#line 1692
      if (fd < 0) {
        {
#line 1693
        exitError((char *)"accept", 18);
        }
      }
      {
#line 1694
      itval.it_interval.tv_usec = (__suseconds_t )0;
#line 1694
      itval.it_interval.tv_sec = itval.it_interval.tv_usec;
#line 1694
      itval.it_value.tv_sec = (__time_t )0;
#line 1694
      itval.it_value.tv_usec = (__suseconds_t )0;
#line 1694
      setitimer(0, (struct itimerval  const  */* __restrict  */)(& itval), (struct itimerval */* __restrict  */)((struct itimerval *)0));
      }
#line 1695
      if (opt.Verbose) {
        {
#line 1697
        peerlen = (int )sizeof(peer);
#line 1698
        tmp___43 = getpeername(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer)),
                               (socklen_t */* __restrict  */)(& peerlen));
        }
#line 1698
        if (tmp___43 < 0) {
          {
#line 1699
          exitError((char *)"getpeername", 19);
          }
        }
        {
#line 1700
        tmp___44 = inet_ntoa(peer.sin_addr);
#line 1700
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"accept from %s\n",
                tmp___44);
#line 1702
        fMessage(stdout, MsgBuf);
        }
      }
    }
  }
#line 1715
  if (! opt.udp) {
#line 1718
    if (opt.SockOpt) {
      {
#line 1720
      tmp___45 = setsockopt(fd, 1, opt.SockOpt, (void const   *)((char *)(& one)),
                            (socklen_t )sizeof(one));
      }
#line 1720
      if (tmp___45 < 0) {
        {
#line 1721
        exitError((char *)"setsockopt", 23);
        }
      }
    }
#line 1723
    if (opt.Window) {
      {
#line 1724
      tmp___46 = setsockopt(fd, 1, 7, (void const   *)((char *)(& opt.SndWin)), (socklen_t )sizeof(opt.SndWin));
      }
#line 1724
      if (tmp___46 < 0) {
        {
#line 1726
        exitError((char *)"setsockopt", 24);
        }
      }
      {
#line 1727
      tmp___47 = setsockopt(fd, 1, 8, (void const   *)((char *)(& opt.RcvWin)), (socklen_t )sizeof(opt.RcvWin));
      }
#line 1727
      if (tmp___47 < 0) {
        {
#line 1729
        exitError((char *)"setsockopt", 25);
        }
      }
    }
  }
#line 1734
  if (opt.Verbose) {
    {
#line 1738
    optlen = (int )sizeof(WinSize);
#line 1739
    tmp___48 = getsockopt(fd, 1, 7, (void */* __restrict  */)((char *)(& WinSize)),
                          (socklen_t */* __restrict  */)(& optlen));
    }
#line 1739
    if (tmp___48 < 0) {
      {
#line 1740
      strcpy((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"get send window size didn\'t work\n");
      }
    } else {
      {
#line 1742
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"send window size = %d\n",
              WinSize);
      }
    }
    {
#line 1743
    fMessage(stdout, MsgBuf);
#line 1744
    optlen = (int )sizeof(WinSize);
#line 1745
    tmp___49 = getsockopt(fd, 1, 8, (void */* __restrict  */)((char *)(& WinSize)),
                          (socklen_t */* __restrict  */)(& optlen));
    }
#line 1745
    if (tmp___49 < 0) {
      {
#line 1746
      strcpy((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"get recv window size didn\'t work\n");
      }
    } else {
      {
#line 1748
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"receive window size = %d\n",
              WinSize);
      }
    }
    {
#line 1749
    fMessage(stdout, MsgBuf);
    }
  }
#line 1752
  if (opt.Verbose) {
#line 1753
    if (Remote) {
#line 1753
      tmp___50 = "\n";
    } else {
#line 1753
      tmp___50 = "";
    }
#line 1753
    if (opt.udp) {
#line 1753
      tmp___51 = "udp";
    } else {
#line 1753
      tmp___51 = "tcp";
    }
    {
#line 1753
    sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"buflen=%d, bufcnt=%d, dataport=%d/%s%s\n",
            opt.BufLen, opt.BufCnt, DataPort, tmp___51, tmp___50);
#line 1756
    fMessage(stdout, MsgBuf);
    }
#line 1758
    if (! Remote) {
      {
#line 1760
      FetchRemoteMsg((char )'\n');
      }
    }
  }
#line 1763
  if (opt.PidCalls) {
    {
#line 1765
    tmp___52 = GetPidRate(opt.PidCalls);
#line 1765
    sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"pid-rate (from %d calls): %.0f/s\n",
            opt.PidCalls, tmp___52);
#line 1767
    fMessage(stdout, MsgBuf);
    }
#line 1768
    goto Fin;
  }
#line 1772
  if (opt.Transmit) {
    {
#line 1773
    n = opt.BufCnt;
#line 1774
    signal(13, & SigPipe);
    }
#line 1775
    if (opt.udp) {
      {
#line 1776
      Nwrite(fd, buf, 4);
#line 1777
      nBytes = 0UL;
#line 1778
      nBuffer = 0UL;
      }
#line 1779
      if (opt.StreamPattern) {
        {
#line 1780
        StartPattern(opt.InitString);
        }
      } else {
        {
#line 1782
        Pattern(buf, opt.BufLen);
        }
      }
      {
#line 1783
      StartTimer();
      }
      {
#line 1784
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1784
        tmp___53 = n;
#line 1784
        n --;
#line 1784
        if (tmp___53) {
          {
#line 1784
          tmp___54 = Nwrite(fd, buf, opt.BufLen);
          }
#line 1784
          if (! (tmp___54 == opt.BufLen)) {
#line 1784
            goto while_break___9;
          }
        } else {
#line 1784
          goto while_break___9;
        }
#line 1785
        nBytes += (unsigned long )opt.BufLen;
#line 1786
        nBuffer ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1788
      StopTimer(& cput, & realt);
#line 1789
      opt.GapLength = 0;
#line 1790
      Nwrite(fd, buf, 4);
#line 1791
      sleep(2U);
#line 1792
      Nwrite(fd, buf, 4);
#line 1793
      sleep(2U);
#line 1794
      Nwrite(fd, buf, 4);
      }
    } else {
      {
#line 1797
      nBytes = 0UL;
#line 1798
      nBuffer = 0UL;
#line 1799
      StartTimer();
      }
      {
#line 1800
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1800
        tmp___55 = n;
#line 1800
        n --;
#line 1800
        if (tmp___55) {
          {
#line 1800
          tmp___56 = Nwrite(fd, buf, opt.BufLen);
          }
#line 1800
          if (! (tmp___56 == opt.BufLen)) {
#line 1800
            goto while_break___10;
          }
        } else {
#line 1800
          goto while_break___10;
        }
#line 1801
        nBytes += (unsigned long )opt.BufLen;
#line 1802
        nBuffer ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1804
      StopTimer(& cput, & realt);
      }
    }
#line 1806
    if (opt.Verbose) {
      {
#line 1807
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"transmitted %ld bytes\n",
              nBytes);
#line 1808
      fMessage(stdout, MsgBuf);
      }
    }
    {
#line 1810
    close(fd);
#line 1811
    syslog(7, "call from %.50s (=%.30s): everything transmitted\n", Peer[0].HostName,
           Peer[0].IPName);
    }
  } else {
#line 1817
    FailedCnt = 0UL;
#line 1818
    if (opt.Compare) {
#line 1819
      FailedCnt = 0UL;
#line 1819
      ReportCnt = (int )FailedCnt;
#line 1820
      if (! opt.StreamPattern) {
        {
#line 1821
        streamr250(ExpectBuf, opt.BufLen);
        }
      }
    }
#line 1823
    nBytes = 0UL;
#line 1824
    nBuffer = 0UL;
#line 1825
    if (opt.udp) {
      {
#line 1826
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 1826
        cnt = Nread(fd, buf, opt.BufLen);
        }
#line 1826
        if (! (cnt > 0)) {
#line 1826
          goto while_break___11;
        }
#line 1828
        if (cnt <= 4) {
#line 1829
          if (going) {
            {
#line 1830
            StopTimer(& cput, & realt);
            }
#line 1831
            if (opt.Verbose) {
              {
#line 1832
              fMessage(stdout, (char *)"got EOF\n");
              }
            }
#line 1833
            goto while_break___11;
          } else {
            {
#line 1836
            going = 1;
#line 1837
            StartTimer();
            }
          }
        } else {
#line 1841
          nBuffer ++;
#line 1842
          if (opt.StreamPattern) {
            {
#line 1843
            streamr250(ExpectBuf, cnt);
            }
          }
#line 1844
          if (opt.Compare) {
            {
#line 1845
            tmp___57 = BufCompare(buf, ExpectBuf, cnt, nBytes, opt.BufLen, & ReportCnt);
#line 1845
            FailedCnt += (unsigned long )tmp___57;
            }
          }
#line 1846
          nBytes += (unsigned long )cnt;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
#line 1851
      syslog(7, "call from %.50s (%.30s): start receiving\n", Peer[0].HostName, Peer[0].IPName);
#line 1853
      StartTimer();
      }
      {
#line 1854
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 1854
        cnt = Nread(fd, buf, opt.BufLen);
        }
#line 1854
        if (! (cnt > 0)) {
#line 1854
          goto while_break___12;
        }
#line 1855
        if (opt.Compare) {
          {
#line 1856
          streamr250(ExpectBuf, cnt);
#line 1857
          tmp___58 = BufCompare(buf, ExpectBuf, cnt, nBytes, opt.BufLen, & ReportCnt);
#line 1857
          FailedCnt += (unsigned long )tmp___58;
          }
        }
#line 1859
        nBytes += (unsigned long )cnt;
#line 1860
        nBuffer ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 1862
      StopTimer(& cput, & realt);
#line 1863
      syslog(7, "call from %.50s (%.30s: everything received\n", Peer[0].HostName,
             Peer[0].IPName);
      }
    }
#line 1867
    if (opt.Verbose) {
      {
#line 1868
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"received %ld bytes\n",
              nBytes);
#line 1869
      fMessage(stdout, MsgBuf);
      }
    }
#line 1871
    if (opt.Compare) {
#line 1871
      if ((unsigned long )ReportCnt < FailedCnt) {
        {
#line 1872
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"further %ld differences not reported\n",
                FailedCnt - (unsigned long )ReportCnt);
#line 1874
        fMessage(stdout, MsgBuf);
        }
      }
    }
#line 1877
    if (opt.MulticastChannel) {
      {
#line 1880
      mreq___0.imr_interface.s_addr = (in_addr_t )0;
#line 1881
      mreq___0.imr_multiaddr.s_addr = inet_addr((char const   *)opt.MulticastChannel);
#line 1882
      setsockopt(fd, 0, 36, (void const   *)((char *)(& mreq___0)), (socklen_t )sizeof(mreq___0));
      }
    }
  }
  {
#line 1902
  iFormat = (char *)"%*.*ld";
#line 1903
  fFormat = (char *)"%*.*f";
#line 1907
  fs = opt.Format;
#line 1908
  TitleLine = LenStrMake((char *)" ");
  }
#line 1909
  if (Remote) {
    {
#line 1910
    sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"%d",
            opt.RemoteNumber);
#line 1911
    StatLine = LenStrMake(MsgBuf);
    }
  } else {
    {
#line 1914
    StatLine = LenStrMake((char *)"l");
    }
  }
  {
#line 1916
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1916
    if (! *fs) {
#line 1916
      goto while_break___13;
    }
    {
#line 1921
    cp = strchr((char const   *)fs, '%');
    }
#line 1922
    if (cp) {
#line 1923
      l = (int )(cp - fs);
#line 1924
      if ((unsigned long )l >= sizeof(MsgBuf)) {
#line 1925
        l = (int )(sizeof(MsgBuf) - 1UL);
      }
      {
#line 1926
      LenStrncat(StatLine, fs, l);
#line 1927
      tmp___59 = LenStrLeng(TitleLine);
#line 1927
      LenStrPadRight(TitleLine, (char )' ', tmp___59 + l);
#line 1928
      fs = cp;
      }
    } else {
      {
#line 1931
      LenStrcpy(StatLine, fs);
#line 1932
      tmp___60 = strlen((char const   *)fs);
#line 1932
      LenStrPadRight(TitleLine, (char )' ', (int )tmp___60);
      }
#line 1933
      goto while_break___13;
    }
    {
#line 1935
    fs ++;
#line 1936
    nc = fs;
#line 1937
    tmp___61 = strtol((char const   */* __restrict  */)fs, (char **/* __restrict  */)(& nc),
                      0);
#line 1937
    fw = (int )tmp___61;
    }
#line 1938
    if ((unsigned long )nc == (unsigned long )fs) {
#line 1939
      fw = 0;
    } else {
#line 1941
      fs = nc;
    }
#line 1942
    if ((int )*fs == 46) {
      {
#line 1943
      fs ++;
#line 1944
      nc = fs;
#line 1945
      tmp___62 = strtol((char const   */* __restrict  */)fs, (char **/* __restrict  */)(& nc),
                        0);
#line 1945
      fp = (int )tmp___62;
      }
#line 1946
      if ((unsigned long )nc == (unsigned long )fs) {
#line 1947
        fp = 0;
      } else {
#line 1949
        fs = nc;
      }
    } else {
#line 1952
      fp = 0;
    }
#line 1954
    if (fp > 30) {
#line 1955
      fp = 30;
    }
#line 1956
    if (fw > 30) {
#line 1957
      fw = 30;
    }
    {
#line 1970
    tmp___68 = strncmp((char const   *)fs, "ccr", (size_t )3);
    }
#line 1970
    if (tmp___68 == 0) {
      {
#line 1971
      sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)fFormat,
              fw, fp, (double )SysCalls / cput);
#line 1973
      TitleStr = (char *)"CPU-C/s";
#line 1974
      fs += 3;
      }
    } else {
      {
#line 1976
      tmp___67 = strncmp((char const   *)fs, "cbr", (size_t )3);
      }
#line 1976
      if (tmp___67 == 0) {
        {
#line 1977
        sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)fFormat,
                fw, fp, ((double )nBytes / cput) / (double )125000);
#line 1979
        TitleStr = (char *)"CPU-MBit/s";
#line 1980
        fs += 3;
        }
      } else {
        {
#line 1982
        tmp___66 = strncmp((char const   *)fs, "ct", (size_t )2);
        }
#line 1982
        if (tmp___66 == 0) {
          {
#line 1983
          sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)fFormat,
                  fw, fp, cput);
#line 1984
          TitleStr = (char *)"CPU s";
#line 1985
          fs += 2;
          }
        } else {
          {
#line 1987
          tmp___65 = strncmp((char const   *)fs, "rcr", (size_t )3);
          }
#line 1987
          if (tmp___65 == 0) {
            {
#line 1988
            sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)fFormat,
                    fw, fp, (double )SysCalls / realt);
#line 1990
            TitleStr = (char *)"Real-C/s";
#line 1991
            fs += 3;
            }
          } else {
            {
#line 1993
            tmp___64 = strncmp((char const   *)fs, "rbr", (size_t )3);
            }
#line 1993
            if (tmp___64 == 0) {
              {
#line 1994
              sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)fFormat,
                      fw, fp, ((double )nBytes / realt) / (double )125000);
#line 1996
              TitleStr = (char *)"Real-MBit/s";
#line 1997
              fs += 3;
              }
            } else {
              {
#line 1999
              tmp___63 = strncmp((char const   *)fs, "rt", (size_t )2);
              }
#line 1999
              if (tmp___63 == 0) {
                {
#line 2000
                sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)fFormat,
                        fw, fp, realt);
#line 2001
                TitleStr = (char *)"Real s";
#line 2002
                fs += 2;
                }
              } else
#line 2004
              if ((int )*fs == 108) {
                {
#line 2005
                sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)iFormat,
                        fw, fp, opt.BufLen);
#line 2006
                TitleStr = (char *)"BufLen";
#line 2007
                fs ++;
                }
              } else
#line 2009
              if ((int )*fs == 110) {
                {
#line 2010
                sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)iFormat,
                        fw, fp, nBuffer);
#line 2011
                TitleStr = (char *)"BufCnt";
#line 2012
                fs ++;
                }
              } else
#line 2014
              if ((int )*fs == 98) {
                {
#line 2015
                sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)iFormat,
                        fw, fp, nBytes);
#line 2016
                TitleStr = (char *)"Bytes";
#line 2017
                fs ++;
                }
              } else
#line 2019
              if ((int )*fs == 99) {
                {
#line 2020
                sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)iFormat,
                        fw, fp, SysCalls);
#line 2021
                TitleStr = (char *)"Calls";
#line 2022
                fs ++;
                }
              } else {
#line 2025
                goto while_continue___13;
              }
            }
          }
        }
      }
    }
    {
#line 2027
    LenStrcat(StatLine, MsgBuf);
#line 2028
    sprintf((char */* __restrict  */)(MsgBuf), (char const   */* __restrict  */)"%*s",
            fw, TitleStr);
#line 2029
    LenStrcat(TitleLine, MsgBuf);
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 2032
  if (opt.Title) {
    {
#line 2033
    LenStrApp(TitleLine, (char )'\n');
#line 2034
    tmp___69 = LenStrString(TitleLine);
#line 2034
    fputs((char const   */* __restrict  */)tmp___69, (FILE */* __restrict  */)stdout);
    }
  }
  {
#line 2036
  LenStrApp(StatLine, (char )'\n');
#line 2037
  tmp___70 = LenStrString(StatLine);
#line 2037
  fputs((char const   */* __restrict  */)tmp___70, (FILE */* __restrict  */)stdout);
  }
  Fin: 
#line 2041
  if (Remote) {
#line 2042
    if (opt.Verbose) {
      {
#line 2043
      fMessage(stdout, (char *)"exiting\n\n");
      }
    }
    {
#line 2045
    fflush(stdout);
#line 2046
    fflush(stderr);
#line 2047
    shutdown(0, 2);
#line 2048
    shutdown(1, 2);
#line 2049
    shutdown(2, 2);
    }
  } else {
    {
#line 2052
    FetchRemoteMsg((char )'\n');
    }
  }
  {
#line 2054
  exit(0);
  }
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 85 "/home/wheatley/newnew/temp/nttcp-1.47/support.h"
void LenStrDestroy(LenStr *ls ) ;
#line 86
LenStr *LenStrCreate(int l ) ;
#line 32 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
char *strrpad(char *s , char pad , int size ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 33
  tmp = strlen((char const   *)s);
#line 33
  i = (int )tmp;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < size)) {
#line 34
      goto while_break;
    }
#line 35
    *(s + i) = pad;
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  *(s + i) = (char )'\000';
#line 39
  return (s);
}
}
#line 41 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
int LenStrLeng(LenStr *ls ) 
{ 


  {
#line 42
  return (ls->Leng);
}
}
#line 44 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
LenStr *LenStrApp(LenStr *ls , char ch ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 45
  if (ls->Leng == ls->MaxLeng) {
    {
#line 46
    ls->MaxLeng += (ls->MaxLeng >> 3) + 1;
#line 47
    tmp = realloc((void *)ls->s, (unsigned long )(ls->MaxLeng + 1) * sizeof(char ));
#line 47
    ls->s = (char *)tmp;
    }
  }
#line 49
  tmp___0 = ls->Leng;
#line 49
  (ls->Leng) ++;
#line 49
  *(ls->s + tmp___0) = ch;
#line 50
  *(ls->s + ls->Leng) = (char )'\000';
#line 51
  return (ls);
}
}
#line 53 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
LenStr *LenStrEnsureSpace(LenStr *ls , int n ) 
{ 
  char *ns ;
  void *tmp ;

  {
#line 54
  if (ls->MaxLeng - ls->Leng < n) {
    {
#line 55
    tmp = realloc((void *)ls->s, (unsigned long )(n + 1) * sizeof(char ));
#line 55
    ns = (char *)tmp;
    }
#line 56
    if ((unsigned long )ns == (unsigned long )((char *)0)) {
#line 57
      return ((LenStr *)0);
    } else {
#line 59
      ls->s = ns;
#line 60
      return (ls);
    }
  } else {
#line 64
    return (ls);
  }
}
}
#line 66 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
LenStr *LenStrPadRight(LenStr *ls , char c , int n ) 
{ 


  {
#line 67
  if (ls->Leng >= n) {
#line 68
    return (ls);
  }
  {
#line 69
  ls = LenStrEnsureSpace(ls, n);
#line 70
  strrpad(ls->s, c, n);
#line 71
  ls->Leng = n;
  }
#line 72
  return (ls);
}
}
#line 74 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
LenStr *LenStrcpy(LenStr *dvs , char *s ) 
{ 
  int l ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 75
  tmp = strlen((char const   *)s);
#line 75
  l = (int )tmp;
  }
#line 76
  if (l >= dvs->MaxLeng) {
    {
#line 77
    tmp___0 = realloc((void *)dvs->s, (unsigned long )(l + 1) * sizeof(char ));
#line 77
    dvs->s = (char *)tmp___0;
#line 78
    dvs->MaxLeng = l;
    }
  }
  {
#line 80
  strcpy((char */* __restrict  */)dvs->s, (char const   */* __restrict  */)s);
#line 81
  dvs->Leng = l;
  }
#line 82
  return (dvs);
}
}
#line 84 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
char *LenStrString(LenStr *ls ) 
{ 


  {
#line 85
  return (ls->s);
}
}
#line 87 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
LenStr *LenStrncat(LenStr *dls , char *s , int n ) 
{ 
  int l ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 88
  tmp = strlen((char const   *)s);
#line 88
  l = (int )tmp;
  }
#line 89
  if (l < n) {
#line 90
    n = l;
  }
#line 91
  if (n + dls->Leng >= dls->MaxLeng) {
    {
#line 92
    dls->MaxLeng = dls->Leng + l;
#line 93
    tmp___0 = realloc((void *)dls->s, (unsigned long )(dls->MaxLeng + 1) * sizeof(char ));
#line 93
    dls->s = (char *)tmp___0;
    }
  }
  {
#line 95
  strncat((char */* __restrict  */)(dls->s + dls->Leng), (char const   */* __restrict  */)s,
          (size_t )n);
#line 96
  dls->Leng += n;
#line 97
  *(dls->s + dls->Leng) = (char )'\000';
  }
#line 98
  return (dls);
}
}
#line 100 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
LenStr *LenStrMake(char *s ) 
{ 
  LenStr *vs ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 101
  tmp = malloc(sizeof(LenStr ));
#line 101
  vs = (LenStr *)tmp;
#line 102
  tmp___1 = strlen((char const   *)s);
#line 102
  tmp___0 = (int )tmp___1;
#line 102
  vs->Leng = tmp___0;
#line 102
  vs->MaxLeng = tmp___0;
#line 103
  tmp___2 = malloc((size_t )(vs->Leng + 1));
#line 103
  vs->s = (char *)tmp___2;
#line 104
  strcpy((char */* __restrict  */)vs->s, (char const   */* __restrict  */)s);
  }
#line 105
  return (vs);
}
}
#line 107 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
LenStr *LenStrcat(LenStr *dls , char *s ) 
{ 
  int l ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 108
  tmp = strlen((char const   *)s);
#line 108
  l = (int )tmp;
  }
#line 109
  if (l + dls->Leng >= dls->MaxLeng) {
    {
#line 110
    dls->MaxLeng = dls->Leng + l;
#line 111
    tmp___0 = realloc((void *)dls->s, (unsigned long )(dls->MaxLeng + 1) * sizeof(char ));
#line 111
    dls->s = (char *)tmp___0;
    }
  }
  {
#line 113
  strcat((char */* __restrict  */)(dls->s + dls->Leng), (char const   */* __restrict  */)s);
#line 114
  dls->Leng += l;
  }
#line 115
  return (dls);
}
}
#line 117 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
LenStr *LenStrCreate(int l ) 
{ 
  LenStr *vs ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 118
  tmp = malloc(sizeof(LenStr ));
#line 118
  vs = (LenStr *)tmp;
#line 119
  vs->Leng = 0;
#line 120
  vs->MaxLeng = l;
#line 121
  tmp___0 = malloc((size_t )(l + 1));
#line 121
  vs->s = (char *)tmp___0;
#line 122
  *(vs->s + 0) = (char )'\000';
  }
#line 123
  return (vs);
}
}
#line 125 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
void LenStrDestroy(LenStr *ls ) 
{ 


  {
#line 126
  if (ls->s) {
    {
#line 127
    free((void *)ls->s);
    }
  }
  {
#line 128
  free((void *)ls);
  }
#line 129
  return;
}
}
#line 132 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
StrVec *StrVecFromArgv(int argc , char **argv ) 
{ 
  StrVec *sa ;
  void *tmp ;
  int i ;
  char **tmp___0 ;
  void *tmp___1 ;
  StrVec *nsa ;
  StrVec *tmp___2 ;

  {
  {
#line 133
  tmp = malloc(sizeof(StrVec ));
#line 133
  sa = (StrVec *)tmp;
  }
#line 136
  if ((unsigned long )sa == (unsigned long )((StrVec *)0)) {
#line 137
    return ((StrVec *)0);
  }
  {
#line 138
  tmp___1 = malloc((unsigned long )argc * sizeof(char *));
#line 138
  tmp___0 = (char **)tmp___1;
#line 138
  sa->String = tmp___0;
  }
#line 138
  if ((unsigned long )tmp___0 == (unsigned long )((char **)0)) {
    {
#line 139
    free((void *)sa);
    }
#line 140
    return ((StrVec *)0);
  }
#line 142
  sa->Leng = 0;
#line 143
  sa->MaxLeng = argc;
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < argc)) {
#line 144
      goto while_break;
    }
    {
#line 145
    tmp___2 = StrVecAppend(sa, *(argv + i));
#line 145
    nsa = tmp___2;
    }
#line 146
    if ((unsigned long )nsa == (unsigned long )((StrVec *)0)) {
      {
#line 147
      StrVecDestroy(sa);
      }
#line 148
      return ((StrVec *)0);
    } else {
#line 151
      sa = nsa;
    }
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (sa);
}
}
#line 155 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
StrVec *StrVecExpand(StrVec *sv , int n ) 
{ 
  char **ss ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 156
  if (n > sv->MaxLeng) {
#line 158
    if ((unsigned long )sv->String == (unsigned long )((char **)0)) {
      {
#line 159
      tmp = malloc((unsigned long )n * sizeof(char *));
#line 159
      ss = (char **)tmp;
      }
    } else {
      {
#line 161
      tmp___0 = realloc((void *)sv->String, (unsigned long )n * sizeof(char *));
#line 161
      ss = (char **)tmp___0;
      }
    }
#line 162
    if ((unsigned long )ss == (unsigned long )((char **)0)) {
#line 163
      return ((StrVec *)0);
    }
#line 164
    sv->MaxLeng = n;
#line 165
    sv->String = ss;
  }
#line 167
  return (sv);
}
}
#line 169 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
StrVec *StrVecAppend(StrVec *sa , char *s ) 
{ 
  char *ns ;
  StrVec *nsa ;
  int nl ;
  int tmp ;

  {
#line 171
  if (sa->Leng >= sa->MaxLeng) {
    {
#line 173
    nl = sa->MaxLeng;
#line 174
    nl += (nl >> 3) + 4;
#line 175
    nsa = StrVecExpand(sa, nl);
    }
#line 175
    if ((unsigned long )nsa == (unsigned long )((StrVec *)0)) {
#line 176
      return ((StrVec *)0);
    }
  }
  {
#line 178
  ns = strdup((char const   *)s);
  }
#line 178
  if ((unsigned long )ns == (unsigned long )((char *)0)) {
#line 179
    return ((StrVec *)0);
  }
#line 180
  tmp = sa->Leng;
#line 180
  (sa->Leng) ++;
#line 180
  *(sa->String + tmp) = ns;
#line 181
  return (sa);
}
}
#line 183 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
char *StrVecToString(StrVec *sa , char Sep ) 
{ 
  int i ;
  int StrLeng ;
  char *str ;
  char *dstr ;
  char *cp ;
  int l ;
  void *tmp ;
  char *cp___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 184
  StrLeng = 0;
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < sa->Leng)) {
#line 187
      goto while_break;
    }
#line 188
    cp = *(sa->String + i);
#line 189
    l = 0;
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! *cp) {
#line 190
        goto while_break___0;
      }
#line 191
      l ++;
#line 192
      if ((int )*cp == (int )Sep) {
#line 193
        l ++;
        {
#line 194
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 194
          if (*cp) {
#line 194
            if (! ((int )*cp == (int )Sep)) {
#line 194
              goto while_break___1;
            }
          } else {
#line 194
            goto while_break___1;
          }
#line 195
          cp ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 198
        cp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    StrLeng += l + 1;
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  tmp = malloc((unsigned long )(StrLeng + 1) * sizeof(char ));
#line 202
  str = (char *)tmp;
#line 202
  dstr = str;
  }
#line 203
  if ((unsigned long )dstr == (unsigned long )((char *)0)) {
#line 204
    return ((char *)0);
  }
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 205
    if (! (i < sa->Leng)) {
#line 205
      goto while_break___2;
    }
#line 206
    cp___0 = *(sa->String + i);
#line 207
    if (i > 0) {
#line 208
      tmp___0 = dstr;
#line 208
      dstr ++;
#line 208
      *tmp___0 = Sep;
    }
    {
#line 209
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 209
      if (! *cp___0) {
#line 209
        goto while_break___3;
      }
#line 210
      if ((int )*cp___0 == (int )Sep) {
#line 211
        tmp___1 = dstr;
#line 211
        dstr ++;
#line 211
        *tmp___1 = (char )'\\';
      }
#line 212
      tmp___2 = dstr;
#line 212
      dstr ++;
#line 212
      tmp___3 = cp___0;
#line 212
      cp___0 ++;
#line 212
      *tmp___2 = *tmp___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 205
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 215
  *dstr = (char )'\000';
#line 216
  return (str);
}
}
#line 218 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
StrVec *StrVecJoin(StrVec *sv , StrVec *sv1 ) 
{ 
  int i ;
  char *sd ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 220
  sv = StrVecExpand(sv, sv->Leng + sv1->Leng);
  }
#line 222
  if ((unsigned long )sv == (unsigned long )((StrVec *)0)) {
#line 223
    return ((StrVec *)0);
  }
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < sv1->Leng)) {
#line 225
      goto while_break;
    }
    {
#line 226
    tmp = strdup((char const   *)*(sv1->String + i));
#line 226
    sd = tmp;
    }
#line 227
    if ((unsigned long )sd != (unsigned long )((char *)0)) {
#line 228
      tmp___0 = sv->Leng;
#line 228
      (sv->Leng) ++;
#line 228
      *(sv->String + tmp___0) = sd;
    } else {
      {
#line 230
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 230
        i --;
#line 230
        if (! (i >= 0)) {
#line 230
          goto while_break___0;
        }
        {
#line 231
        (sv->Leng) --;
#line 231
        free((void *)*(sv->String + sv->Leng));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 232
      return ((StrVec *)0);
    }
#line 225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return (sv);
}
}
#line 237 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
StrVec *StrVecCreate(void) 
{ 
  StrVec *sa ;
  void *tmp ;

  {
  {
#line 238
  tmp = malloc(sizeof(StrVec ));
#line 238
  sa = (StrVec *)tmp;
  }
#line 240
  if ((unsigned long )sa == (unsigned long )((StrVec *)0)) {
#line 241
    return ((StrVec *)0);
  }
#line 242
  sa->Leng = 0;
#line 243
  sa->MaxLeng = 0;
#line 244
  sa->String = (char **)0;
#line 245
  return (sa);
}
}
#line 247 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
StrVec *StrVecFromString(char *s , char Sep ) 
{ 
  char *scp ;
  char *rcp ;
  char *ss ;
  StrVec *sa ;
  StrVec *nsa ;
  char *start ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 251
  ss = strdup((char const   *)s);
  }
#line 251
  if ((unsigned long )ss == (unsigned long )((char *)0)) {
#line 252
    return ((StrVec *)0);
  }
  {
#line 253
  sa = StrVecCreate();
  }
#line 253
  if ((unsigned long )sa == (unsigned long )((StrVec *)0)) {
    {
#line 254
    free((void *)ss);
    }
#line 255
    return ((StrVec *)0);
  }
#line 257
  rcp = ss;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! *rcp) {
#line 258
      goto while_break;
    }
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      if (! ((int )*rcp == (int )Sep)) {
#line 261
        goto while_break___0;
      }
#line 262
      rcp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 263
    start = rcp;
#line 263
    scp = start;
    {
#line 264
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 264
      if (! *rcp) {
#line 264
        goto while_break___1;
      }
#line 265
      if ((int )*rcp == 92) {
#line 266
        tmp = scp;
#line 266
        scp ++;
#line 266
        rcp ++;
#line 266
        *tmp = *rcp;
#line 267
        if (*rcp) {
#line 267
          rcp ++;
        }
#line 268
        goto while_continue___1;
      }
#line 270
      if ((int )*rcp == (int )Sep) {
#line 271
        if (*rcp) {
#line 271
          rcp ++;
        }
#line 272
        *scp = (char )'\000';
#line 273
        goto while_break___1;
      }
#line 275
      tmp___0 = scp;
#line 275
      scp ++;
#line 275
      tmp___1 = rcp;
#line 275
      rcp ++;
#line 275
      *tmp___0 = *tmp___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 277
    nsa = StrVecAppend(sa, start);
    }
#line 277
    if ((unsigned long )nsa == (unsigned long )((StrVec *)0)) {
      {
#line 278
      free((void *)ss);
#line 279
      StrVecDestroy(sa);
      }
#line 280
      return ((StrVec *)0);
    } else {
#line 283
      sa = nsa;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 285
  free((void *)ss);
  }
#line 286
  return (sa);
}
}
#line 288 "/home/wheatley/newnew/temp/nttcp-1.47/support.c"
void StrVecDestroy(StrVec *sa ) 
{ 
  int i ;

  {
#line 290
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < sa->Leng)) {
#line 290
      goto while_break;
    }
    {
#line 291
    free((void *)*(sa->String + i));
#line 290
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  if (sa->Leng > 0) {
    {
#line 293
    free((void *)sa->String);
    }
  }
  {
#line 294
  free((void *)sa);
  }
#line 295
  return;
}
}
