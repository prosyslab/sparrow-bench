/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 46 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.h"
struct __anonstruct_argv_t_31 {
   char *string ;
   unsigned char quoted ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.h"
typedef struct __anonstruct_argv_t_31 argv_t;
#line 53 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.h"
struct __anonstruct_buffer_t_32 {
   unsigned char *data ;
   unsigned char *ptr ;
   unsigned char *limit ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.h"
typedef struct __anonstruct_buffer_t_32 buffer_t;
#line 71 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
enum state_t {
    WHITESPACE = 0,
    WORDSPACE = 1,
    TOKENSTART = 2
} ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 39 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.h"
struct __anonstruct_list_t_54 {
   char *buf ;
   void *next ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.h"
typedef struct __anonstruct_list_t_54 list_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.h"
struct __anonstruct_script_t_33 {
   char *name ;
   int size ;
   uid_t uid ;
   gid_t gid ;
   char *buf ;
   size_t curpos ;
   void *next ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.h"
typedef struct __anonstruct_script_t_33 script_t;
#line 40
enum tag_t {
    HTML = 0,
    RUN = 1,
    INCLUDE = 2,
    EVAL = 3,
    COMMENT = 4,
    NOOP = 5
} ;
#line 45 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.h"
struct __anonstruct_token_t_34 {
   script_t *script ;
   enum tag_t tag ;
   size_t len ;
   char *buf ;
   void *next ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.h"
typedef struct __anonstruct_token_t_34 token_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
struct __anonstruct_haserl_t_35 {
   unsigned long uploadkb ;
   char *shell ;
   char *uploaddir ;
   char *uploadhandler ;
   char *var_prefix ;
   char *get_prefix ;
   char *post_prefix ;
   char *cookie_prefix ;
   char *nul_prefix ;
   char *haserl_prefix ;
   token_t *uploadlist ;
   int debug ;
   int acceptall ;
   int silent ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
typedef struct __anonstruct_haserl_t_35 haserl_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/sliding_buffer.h"
struct __anonstruct_sliding_buffer_t_30 {
   int fh ;
   unsigned char *buf ;
   unsigned char *ptr ;
   unsigned char *segment ;
   size_t len ;
   size_t maxsize ;
   size_t bufsize ;
   size_t maxread ;
   size_t nrread ;
   int eof ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/sliding_buffer.h"
typedef struct __anonstruct_sliding_buffer_t_30 sliding_buffer_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_10 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_10 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_24 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_25 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_27 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_28 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_29 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_30 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_23 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_24 _kill ;
   struct __anonstruct__timer_25 _timer ;
   struct __anonstruct__rt_26 _rt ;
   struct __anonstruct__sigchld_27 _sigchld ;
   struct __anonstruct__sigfault_28 _sigfault ;
   struct __anonstruct__sigpoll_29 _sigpoll ;
   struct __anonstruct__sigsys_30 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_22 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_23 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_22 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_42 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_42 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_49 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_50 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_49 __wait_terminated ;
   struct __anonstruct___wait_stopped_50 __wait_stopped ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.h"
struct __anonstruct_mime_var_t_60 {
   char *name ;
   char *filename ;
   char *type ;
   char *tempname ;
   buffer_t value ;
   int fh ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.h"
typedef struct __anonstruct_mime_var_t_60 mime_var_t;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.h"
int argc_argv(char *instr , argv_t **argv , char *commentstr ) ;
#line 64
void haserl_buffer_init(buffer_t *buf ) ;
#line 65
void buffer_reset(buffer_t *buf ) ;
#line 66
void buffer_destroy(buffer_t *buf ) ;
#line 67
void buffer_add(buffer_t *buf , void const   *data , unsigned long size ) ;
#line 71
void uppercase(char *instr ) ;
#line 72
void lowercase(char *instr ) ;
#line 73
char *skip_whitespace(char *instr ) ;
#line 74
char *find_whitespace(char *instr ) ;
#line 75
int count_lines(char *instr , size_t len , char *where ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
void *xrealloc(void *buf , size_t size ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
int argc_argv(char *instr , argv_t **argv , char *commentstr ) 
{ 
  char quote ;
  int arg_count ;
  enum state_t state ;
  argv_t *argv_array ;
  int argc_slots ;
  size_t len ;
  size_t pos ;
  char quoted ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 69
  quote = (char )'\000';
#line 70
  arg_count = 0;
#line 71
  state = (enum state_t )0;
#line 75
  argv_array = (argv_t *)((void *)0);
#line 76
  argc_slots = 0;
#line 79
  len = strlen((char const   *)instr);
#line 80
  pos = (size_t )0;
#line 81
  quoted = (char)0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (pos < len)) {
#line 83
      goto while_break;
    }
#line 89
    if ((unsigned int )state == 0U) {
      {
#line 89
      tmp = strchr((char const   *)commentstr, (int )*instr);
      }
#line 89
      if (tmp) {
        {
#line 91
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 91
          if ((int )*instr != 10) {
#line 91
            if (! ((int )*instr != 0)) {
#line 91
              goto while_break___0;
            }
          } else {
#line 91
            goto while_break___0;
          }
#line 93
          instr ++;
#line 94
          pos ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 103
    if ((int )*instr == 39) {
#line 103
      goto case_39;
    }
#line 103
    if ((int )*instr == 34) {
#line 103
      goto case_39;
    }
#line 133
    if ((int )*instr == 92) {
#line 133
      goto case_92;
    }
#line 154
    if ((int )*instr == 10) {
#line 154
      goto case_10;
    }
#line 154
    if ((int )*instr == 13) {
#line 154
      goto case_10;
    }
#line 154
    if ((int )*instr == 9) {
#line 154
      goto case_10;
    }
#line 154
    if ((int )*instr == 32) {
#line 154
      goto case_10;
    }
#line 162
    if ((int )*instr == 0) {
#line 162
      goto case_0;
    }
#line 165
    goto switch_default;
    case_39: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 105
    if ((unsigned int )state == 0U) {
#line 107
      quote = *instr;
#line 108
      state = (enum state_t )2;
#line 109
      quoted = (char)-1;
#line 110
      if ((int )*(instr + 1) == (int )quote) {
#line 112
        *instr = (char )'\000';
      } else {
#line 116
        instr ++;
#line 117
        pos ++;
      }
    } else
#line 123
    if ((int )*instr == (int )quote) {
#line 123
      if (quoted) {
#line 125
        quote = (char )'\000';
#line 126
        *instr = (char )'\000';
#line 127
        state = (enum state_t )0;
      }
    }
#line 130
    goto switch_break;
    case_92: /* CIL Label */ 
#line 134
    if (quote) {
#line 134
      if ((int )*(instr + 1) == (int )quote) {
        {
#line 136
        tmp___0 = strlen((char const   *)instr);
#line 136
        memmove((void *)instr, (void const   *)(instr + 1), tmp___0);
#line 137
        len --;
        }
      } else {
#line 134
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 142
    if ((unsigned int )state == 0U) {
#line 144
      state = (enum state_t )2;
    }
#line 147
    goto switch_break;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 155
    if ((unsigned int )state == 1U) {
#line 155
      if ((int )quote == 0) {
#line 157
        state = (enum state_t )0;
#line 158
        *instr = (char )'\000';
      }
    }
#line 160
    goto switch_break;
    case_0: /* CIL Label */ 
#line 163
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 166
    if ((unsigned int )state == 0U) {
#line 168
      state = (enum state_t )2;
    }
    switch_break: /* CIL Label */ ;
    }
#line 173
    if ((unsigned int )state == 2U) {
#line 175
      arg_count ++;
#line 176
      if (arg_count > argc_slots) {
        {
#line 178
        argc_slots += 10;
#line 179
        tmp___1 = xrealloc((void *)argv_array, sizeof(argv_t ) * (unsigned long )(argc_slots + 10));
#line 179
        argv_array = (argv_t *)tmp___1;
        }
      }
#line 185
      if ((unsigned long )argv_array == (unsigned long )((void *)0)) {
#line 187
        return (-1);
      }
#line 189
      (argv_array + (arg_count - 1))->string = instr;
#line 190
      (argv_array + (arg_count - 1))->quoted = (unsigned char )quoted;
#line 191
      state = (enum state_t )1;
#line 192
      quoted = (char)0;
    }
#line 195
    instr ++;
#line 196
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  if (arg_count == 0) {
#line 199
    return (0);
  }
#line 201
  (argv_array + arg_count)->string = (char *)((void *)0);
#line 202
  *argv = argv_array;
#line 203
  return (arg_count);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
void haserl_buffer_init(buffer_t *buf ) 
{ 


  {
#line 212
  buf->data = (unsigned char *)((void *)0);
#line 213
  buf->ptr = (unsigned char *)((void *)0);
#line 214
  buf->limit = (unsigned char *)((void *)0);
#line 215
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
void buffer_destroy(buffer_t *buf ) 
{ 


  {
#line 220
  if (buf->data) {
    {
#line 222
    free((void *)buf->data);
    }
  }
  {
#line 224
  haserl_buffer_init(buf);
  }
#line 225
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
void buffer_reset(buffer_t *buf ) 
{ 


  {
#line 231
  if (buf->data) {
#line 233
    buf->ptr = buf->data;
  } else {
#line 237
    buf->ptr = (unsigned char *)((void *)0);
  }
#line 239
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
void buffer_add(buffer_t *buf , void const   *data , unsigned long size ) 
{ 
  unsigned long newsize ;
  unsigned long index___0 ;
  void *tmp ;

  {
#line 249
  if ((unsigned long )(buf->ptr + size) >= (unsigned long )buf->limit) {
#line 251
    index___0 = (unsigned long )(buf->limit - buf->data);
#line 252
    newsize = index___0;
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 253
      if (! (newsize <= index___0 + size)) {
#line 253
        goto while_break;
      }
#line 255
      newsize += 1024UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 257
    index___0 = (unsigned long )(buf->ptr - buf->data);
#line 258
    tmp = realloc((void *)buf->data, newsize);
#line 258
    buf->data = (unsigned char *)tmp;
#line 259
    buf->limit = buf->data + newsize;
#line 260
    buf->ptr = buf->data + index___0;
    }
  }
  {
#line 263
  memcpy((void */* __restrict  */)buf->ptr, (void const   */* __restrict  */)data,
         size);
#line 264
  buf->ptr += size;
  }
#line 265
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
void uppercase(char *instr ) 
{ 
  int tmp ;

  {
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! ((int )*instr != 0)) {
#line 273
      goto while_break;
    }
    {
#line 275
    tmp = toupper((int )*instr);
#line 275
    *instr = (char )tmp;
#line 276
    instr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
void lowercase(char *instr ) 
{ 
  int tmp ;

  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((int )*instr != 0)) {
#line 285
      goto while_break;
    }
    {
#line 287
    tmp = tolower((int )*instr);
#line 287
    *instr = (char )tmp;
#line 288
    instr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
char *skip_whitespace(char *instr ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    tmp = __ctype_b_loc();
    }
#line 296
    if ((int const   )*(*tmp + (int )*instr) & 8192) {
#line 296
      if (! *instr) {
#line 296
        goto while_break;
      }
    } else {
#line 296
      goto while_break;
    }
#line 297
    instr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return (instr);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
char *find_whitespace(char *instr ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 306
    tmp = __ctype_b_loc();
    }
#line 306
    if ((int const   )*(*tmp + (int )*instr) & 8192) {
#line 306
      goto while_break;
    } else
#line 306
    if (! *instr) {
#line 306
      goto while_break;
    }
#line 307
    instr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return (instr);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/common.c"
int count_lines(char *instr , size_t len , char *where ) 
{ 
  size_t line ;

  {
#line 317
  line = (size_t )1;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if ((unsigned long )where > (unsigned long )instr) {
#line 318
      if (! len) {
#line 318
        goto while_break;
      }
    } else {
#line 318
      goto while_break;
    }
#line 320
    if ((int )*instr == 10) {
#line 321
      line ++;
    }
#line 322
    len --;
#line 323
    instr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return ((int )line);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 578 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_error.h"
char *g_err_msg[8] ;
#line 36
void die_with_message(void *sp , char *where , char const   *s  , ...) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.h"
void bash_destroy(void) ;
#line 30
void bash_exec(buffer_t *buf , char *str ) ;
#line 32
void bash_echo(buffer_t *buf , char *str , size_t len ) ;
#line 33
void bash_eval(buffer_t *buf , char *str , size_t len ) ;
#line 34
void bash_setup(char *shell , list_t *env ) ;
#line 35
void bash_doscript(buffer_t *script , char *name ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
static int subshell_pipe[2]  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
static int subshell_pid  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
void bash_setup(char *shell , list_t *env ) 
{ 
  int retcode ;
  int count ;
  argv_t *argv ;
  char *av[20] ;
  list_t *next ;

  {
#line 55
  retcode = 0;
#line 61
  if ((unsigned long )shell == (unsigned long )((void *)0)) {
#line 62
    return;
  }
  {
#line 64
  retcode = pipe((int *)(& subshell_pipe[0]));
  }
#line 65
  if (retcode == 0) {
    {
#line 67
    subshell_pid = fork();
    }
#line 68
    if (subshell_pid == -1) {
      {
#line 70
      die_with_message((void *)0, (char *)((void *)0), (char const   *)g_err_msg[6]);
      }
    }
#line 73
    if (subshell_pid == 0) {
      {
#line 76
      dup2(subshell_pipe[0], 0);
#line 77
      close(subshell_pipe[0]);
#line 78
      close(subshell_pipe[1]);
#line 79
      count = argc_argv(shell, & argv, (char *)"");
      }
#line 80
      if (count > 19) {
#line 83
        av[19] = (char *)"\000";
#line 84
        count = 18;
      }
      {
#line 86
      while (1) {
        while_continue: /* CIL Label */ ;
#line 86
        if (! (count >= 0)) {
#line 86
          goto while_break;
        }
#line 88
        av[count] = (argv + count)->string;
#line 89
        count --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 94
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 94
        if (! env) {
#line 94
          goto while_break___0;
        }
        {
#line 96
        next = (list_t *)env->next;
#line 97
        putenv(env->buf);
#line 98
        env = next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 101
      execv((char const   *)(argv + 0)->string, (char * const  *)(av));
#line 102
      free((void *)argv);
#line 105
      die_with_message((void *)0, (char *)((void *)0), (char const   *)g_err_msg[6]);
      }
    } else {
      {
#line 110
      close(subshell_pipe[0]);
      }
    }
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
void bash_destroy(void) 
{ 
  int status ;

  {
  {
#line 122
  waitpid(subshell_pid, & status, 0);
  }
#line 123
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
void bash_exec(buffer_t *buf , char *str ) 
{ 
  size_t tmp ;

  {
  {
#line 129
  tmp = strlen((char const   *)str);
#line 129
  buffer_add(buf, (void const   *)str, tmp);
  }
#line 130
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
static char echo_start[14]  = 
#line 141
  {      (char )'p',      (char )'r',      (char )'i',      (char )'n', 
        (char )'t',      (char )'f',      (char )' ',      (char )'\'', 
        (char )'%',      (char )'s',      (char )'\'',      (char )' ', 
        (char )'\'',      (char )'\000'};
#line 142 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
static char echo_quote[5]  = {      (char )'\'',      (char )'\\',      (char )'\'',      (char )'\'', 
        (char )'\000'};
#line 143 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
static char echo_end[3]  = {      (char )'\'',      (char )'\n',      (char )'\000'};
#line 134 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
void bash_echo(buffer_t *buf , char *str , size_t len ) 
{ 
  size_t maxlen ;
  size_t pos ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 144
  maxlen = (size_t )3096;
#line 147
  if (len == 0UL) {
#line 148
    return;
  }
  {
#line 149
  pos = (size_t )0;
#line 151
  tmp = strlen((char const   *)(echo_start));
#line 151
  buffer_add(buf, (void const   *)(echo_start), tmp);
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (pos < len)) {
#line 152
      goto while_break;
    }
#line 154
    if ((int )*(str + pos) == 39) {
      {
#line 155
      tmp___0 = strlen((char const   *)(echo_quote));
#line 155
      buffer_add(buf, (void const   *)(echo_quote), tmp___0);
      }
    } else {
      {
#line 157
      buffer_add(buf, (void const   *)(str + pos), 1UL);
      }
    }
#line 158
    pos ++;
#line 159
    if (pos % maxlen == 0UL) {
      {
#line 161
      tmp___1 = strlen((char const   *)(echo_end));
#line 161
      buffer_add(buf, (void const   *)(echo_end), tmp___1);
#line 162
      tmp___2 = strlen((char const   *)(echo_start));
#line 162
      buffer_add(buf, (void const   *)(echo_start), tmp___2);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  tmp___3 = strlen((char const   *)(echo_end));
#line 165
  buffer_add(buf, (void const   *)(echo_end), tmp___3);
  }
#line 166
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
static char echo_start___0[9]  = 
#line 173
  {      (char )'e',      (char )'c',      (char )'h',      (char )'o', 
        (char )' ',      (char )'-',      (char )'n',      (char )' ', 
        (char )'\000'};
#line 174 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
static char echo_end___0[2]  = {      (char )'\n',      (char )'\000'};
#line 170 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
void bash_eval(buffer_t *buf , char *str , size_t len ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 175
  if (len == 0UL) {
#line 176
    return;
  }
  {
#line 178
  tmp = strlen((char const   *)(echo_start___0));
#line 178
  buffer_add(buf, (void const   *)(echo_start___0), tmp);
#line 179
  buffer_add(buf, (void const   *)str, len);
#line 180
  tmp___0 = strlen((char const   *)(echo_end___0));
#line 180
  buffer_add(buf, (void const   *)(echo_end___0), tmp___0);
  }
#line 181
  return;
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
static char postfix[7]  = {      (char )'\n',      (char )'e',      (char )'x',      (char )'i', 
        (char )'t',      (char )'\n',      (char )'\000'};
#line 638 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_bash.c"
void bash_doscript(buffer_t *script , char *name ) 
{ 
  size_t tmp ;

  {
  {
#line 644
  write(subshell_pipe[1], (void const   *)script->data, (size_t )(script->ptr - script->data));
#line 647
  tmp = strlen((char const   *)(postfix));
#line 647
  write(subshell_pipe[1], (void const   *)(postfix), tmp);
  }
#line 650
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
haserl_t global ;
#line 34 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_error.h"
void die_with_error(char *msg ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_error.c"
char *g_err_msg[8]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_error.c"
  {      (char *)"",      (char *)"Memory Allocation Failure",      (char *)"Unable to open file %s",      (char *)"%c&gt; before &lt;%c", 
        (char *)"Missing %c&gt;",      (char *)"Unknown operation",      (char *)"Unable to start subshell",      (char *)"Unspecified Error"};
#line 53 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_error.c"
void die_with_error(char *msg ) 
{ 


  {
  {
#line 56
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: %s\n",
          msg);
#line 57
  exit(-1);
  }
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_error.c"
void die_with_message(void *sp , char *where , char const   *s  , ...) 
{ 
  script_t *script ;
  va_list p ;
  FILE *fo ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 69
  script = (script_t *)sp;
#line 72
  fo = stderr;
#line 74
  if (global.silent == 0) {
    {
#line 76
    tmp = getenv("REQUEST_METHOD");
    }
#line 76
    if (tmp) {
      {
#line 78
      fo = stdout;
#line 79
      fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"HTTP/1.0 500 Server Error\nContent-Type: text/html\n\n<html><body><b><font color=#CC0000>haserl CGI Error</font></b><br><pre>\n");
      }
    }
    {
#line 84
    __builtin_va_start(p, s);
#line 85
    vfprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)s, p);
#line 86
    __builtin_va_end(p);
    }
#line 88
    if (where) {
#line 88
      if (sp) {
        {
#line 90
        tmp___0 = count_lines(script->buf, (size_t )script->size, where);
#line 90
        fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)" near line %d of %s\n",
                tmp___0, script->name);
        }
      }
    }
    {
#line 95
    printf((char const   */* __restrict  */)"\n");
#line 97
    tmp___1 = getenv("REQUEST_METHOD");
    }
#line 97
    if (tmp___1) {
      {
#line 98
      fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"</pre></body></html>\n");
      }
    }
  }
  {
#line 100
  exit(-1);
  }
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/sliding_buffer.h"
int s_buffer_init(sliding_buffer_t *sbuf , int size ) ;
#line 43
void s_buffer_destroy(sliding_buffer_t *sbuf ) ;
#line 44
int s_buffer_read(sliding_buffer_t *sbuf , char *matchstr ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/sliding_buffer.c"
int s_buffer_init(sliding_buffer_t *sbuf , int size ) 
{ 
  void *tmp ;

  {
  {
#line 41
  sbuf->maxsize = (size_t )size;
#line 42
  tmp = malloc(sbuf->maxsize);
#line 42
  sbuf->buf = (unsigned char *)tmp;
#line 45
  (sbuf->maxsize) --;
#line 46
  sbuf->fh = 0;
#line 47
  sbuf->eof = 0;
#line 48
  sbuf->len = (size_t )0;
#line 49
  sbuf->ptr = sbuf->buf;
#line 50
  sbuf->bufsize = (size_t )0;
#line 51
  sbuf->maxread = (size_t )0;
#line 52
  sbuf->nrread = (size_t )0;
  }
#line 53
  return ((unsigned long )sbuf->buf != (unsigned long )((void *)0));
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/sliding_buffer.c"
void s_buffer_destroy(sliding_buffer_t *sbuf ) 
{ 


  {
  {
#line 62
  free((void *)sbuf->buf);
  }
#line 63
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/sliding_buffer.c"
int s_buffer_read(sliding_buffer_t *sbuf , char *matchstr ) 
{ 
  int len ;
  int pos ;
  int r ;
  size_t n ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
#line 80
  if (sbuf->eof) {
#line 80
    if ((unsigned long )sbuf->ptr > (unsigned long )sbuf->buf) {
#line 82
      return (0);
    }
  }
#line 88
  if (sbuf->bufsize == 0UL) {
#line 88
    goto _L___0;
  } else {
    {
#line 88
    tmp___4 = strlen((char const   *)matchstr);
    }
#line 88
    if ((unsigned long )sbuf->ptr >= (unsigned long )((sbuf->buf + sbuf->bufsize) - tmp___4)) {
      _L___0: /* CIL Label */ 
#line 91
      len = (int )(sbuf->bufsize - (size_t )(sbuf->ptr - sbuf->buf));
#line 92
      if (len) {
        {
#line 94
        memmove((void *)sbuf->buf, (void const   *)sbuf->ptr, (size_t )len);
        }
      }
      {
#line 96
      sbuf->ptr = sbuf->buf;
#line 97
      sbuf->bufsize = (size_t )len;
#line 101
      tmp___0 = fcntl(sbuf->fh, 3);
      }
#line 101
      if (tmp___0 == -1) {
#line 103
        r = 0;
      } else {
#line 107
        n = sbuf->maxsize - (size_t )len;
#line 108
        if (sbuf->maxread) {
#line 108
          if (sbuf->maxread < sbuf->nrread + n) {
#line 109
            n = sbuf->maxread - sbuf->nrread;
          }
        }
        {
#line 110
        tmp = read(sbuf->fh, (void *)(sbuf->buf + len), n);
#line 110
        r = (int )tmp;
        }
      }
#line 115
      if (r == 0) {
#line 117
        sbuf->eof = -1;
      } else
#line 115
      if (r < 0) {
        {
#line 115
        tmp___3 = __errno_location();
        }
#line 115
        if (*tmp___3 != 4) {
#line 117
          sbuf->eof = -1;
        } else {
#line 115
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 121
        if (r > 0) {
#line 121
          tmp___1 = r;
        } else {
#line 121
          tmp___1 = 0;
        }
#line 121
        sbuf->bufsize += (size_t )tmp___1;
#line 122
        if (r > 0) {
#line 122
          tmp___2 = r;
        } else {
#line 122
          tmp___2 = 0;
        }
#line 122
        sbuf->nrread += (size_t )tmp___2;
      }
    }
  }
  {
#line 129
  pos = 0;
#line 130
  tmp___5 = strlen((char const   *)matchstr);
#line 130
  len = (int )((sbuf->bufsize - (size_t )((int )(sbuf->ptr - sbuf->buf))) - tmp___5);
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    tmp___6 = strlen((char const   *)matchstr);
#line 131
    tmp___7 = memcmp((void const   *)matchstr, (void const   *)(sbuf->ptr + pos),
                     tmp___6);
    }
#line 131
    if (tmp___7) {
#line 131
      if (! (pos < len)) {
#line 131
        goto while_break;
      }
    } else {
#line 131
      goto while_break;
    }
#line 133
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (pos < len) {
    {
#line 141
    sbuf->len = (size_t )pos;
#line 142
    sbuf->segment = sbuf->ptr;
#line 143
    tmp___8 = strlen((char const   *)matchstr);
#line 143
    sbuf->ptr = (sbuf->segment + pos) + tmp___8;
    }
#line 144
    return (-1);
  }
#line 147
  if (sbuf->eof) {
    {
#line 149
    tmp___9 = strlen((char const   *)matchstr);
#line 149
    len = (int )((size_t )len + tmp___9);
    }
  }
#line 155
  sbuf->segment = sbuf->ptr;
#line 156
  sbuf->len = (size_t )len;
#line 157
  sbuf->ptr += sbuf->len;
#line 158
  if (sbuf->eof) {
#line 158
    tmp___10 = -1;
  } else {
#line 158
    tmp___10 = 0;
  }
#line 158
  return (tmp___10);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 545 "/usr/include/unistd.h"
extern char **environ ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 80
extern int optopt ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 180 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.h"
script_t *load_script(char *filename , script_t *scriptlist ) ;
#line 57
void free_script_list(script_t *script ) ;
#line 59
void free_token_list(token_t *tokenlist ) ;
#line 63
token_t *build_token_list(script_t *scriptbuf , token_t *tokenlist ) ;
#line 64
void preprocess_token_list(token_t *tokenlist ) ;
#line 65
token_t *process_token_list(buffer_t *buf , token_t *token ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.h"
int rfc2388_handler(list_t *env ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
haserl_t global  ;
#line 47
char x2c(char *what ) ;
#line 48
void unescape_url(char *url ) ;
#line 49
void *xmalloc(size_t size ) ;
#line 51
list_t *myputenv(list_t *cur , char *str , char *prefix ) ;
#line 52
void free_list_chain(list_t *list ) ;
#line 53
void readenv(list_t *env ) ;
#line 54
void CookieVars(list_t *env ) ;
#line 55
void sessionid(list_t *env ) ;
#line 56
list_t *wcversion(list_t *env ) ;
#line 57
void haserlflags(list_t *env ) ;
#line 58
int ReadCGIQueryString(list_t *env ) ;
#line 59
int ReadCGIPOSTValues(list_t *env ) ;
#line 63
int parseCommandLine(int argc , char **argv ) ;
#line 64
int BecomeUser(uid_t uid , gid_t gid ) ;
#line 65
void assignGlobalStartupValues(void) ;
#line 66
void unlink_uploadlist(void) ;
#line 67
int main(int argc , char **argv ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
void (*shell_exec)(buffer_t *buf , char *str )  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
void (*shell_echo)(buffer_t *buf , char *str , size_t len )  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
void (*shell_eval)(buffer_t *buf , char *str , size_t len )  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
void (*shell_setup)(char * , list_t * )  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
void (*shell_doscript)(buffer_t * , char * )  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.h"
void (*shell_destroy)(void)  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
struct option ga_long_options[11]  = 
#line 131 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
  {      {"version", 0, (int *)0, 'v'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"debug", 0, (int *)0, 'd'}, 
        {"upload-limit", 1, (int *)0, 'u'}, 
        {"upload-dir", 1, (int *)0, 'U'}, 
        {"upload-handler", 1, (int *)0, 'H'}, 
        {"accept-all", 0, (int *)0, 'a'}, 
        {"accept-none", 0, (int *)0, 'n'}, 
        {"shell", 1, (int *)0, 's'}, 
        {"silent", 0, (int *)0, 'S'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 145 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
char const   *gs_short_options  =    "+vhdu:U:H:ans:S";
#line 151 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
char x2c(char *what ) 
{ 
  char digit ;
  int tmp ;

  {
#line 156
  if ((int )*(what + 0) >= 65) {
#line 156
    digit = (char )((((int )*(what + 0) & 223) - 65) + 10);
  } else {
#line 156
    digit = (char )((int )*(what + 0) - 48);
  }
#line 157
  digit = (char )((int )digit * 16);
#line 158
  if ((int )*(what + 1) >= 65) {
#line 158
    tmp = (((int )*(what + 1) & 223) - 65) + 10;
  } else {
#line 158
    tmp = (int )*(what + 1) - 48;
  }
#line 158
  digit = (char )((int )digit + tmp);
#line 159
  return (digit);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void unescape_url(char *url ) 
{ 
  int i ;
  int j ;
  char tmp ;

  {
#line 170
  i = 0;
#line 170
  j = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! *(url + j)) {
#line 170
      goto while_break;
    }
#line 172
    tmp = *(url + j);
#line 172
    *(url + i) = tmp;
#line 172
    if ((int )tmp != 37) {
#line 173
      goto __Cont;
    }
#line 174
    if (! *(url + (j + 1))) {
#line 175
      goto while_break;
    } else
#line 174
    if (! *(url + (j + 2))) {
#line 175
      goto while_break;
    }
    {
#line 176
    *(url + i) = x2c(url + (j + 1));
#line 177
    j += 2;
    }
    __Cont: /* CIL Label */ 
#line 170
    i ++;
#line 170
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  *(url + i) = (char )'\000';
#line 180
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void *xmalloc(size_t size ) 
{ 
  void *buf ;

  {
  {
#line 192
  buf = malloc(size);
  }
#line 192
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 194
    die_with_message((void *)0, (char *)((void *)0), (char const   *)g_err_msg[1]);
    }
  }
  {
#line 196
  memset(buf, 0, size);
  }
#line 197
  return (buf);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void *xrealloc(void *buf , size_t size ) 
{ 


  {
  {
#line 207
  buf = realloc(buf, size);
  }
#line 207
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 209
    die_with_message((void *)0, (char *)((void *)0), (char const   *)g_err_msg[1]);
    }
  }
#line 211
  return (buf);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
list_t *myputenv(list_t *cur , char *str , char *prefix ) 
{ 
  list_t *prev ;
  size_t keylen ;
  char *entry ;
  char *temp ;
  int array ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;

  {
  {
#line 222
  prev = (list_t *)((void *)0);
#line 224
  entry = (char *)((void *)0);
#line 225
  temp = (char *)((void *)0);
#line 226
  array = 0;
#line 229
  tmp = strlen((char const   *)str);
#line 229
  tmp___0 = memchr((void const   *)str, '=', tmp);
#line 229
  temp = (char *)tmp___0;
  }
#line 231
  if ((unsigned long )temp == (unsigned long )((char *)0)) {
#line 233
    return (cur);
  }
  {
#line 236
  keylen = (size_t )(temp - str);
#line 239
  tmp___1 = memcmp((void const   *)((str + keylen) - 2), (void const   *)"[]", (size_t )2);
  }
#line 239
  if (tmp___1 == 0) {
#line 241
    keylen -= 2UL;
#line 242
    array = 1;
  }
  {
#line 245
  tmp___2 = strlen((char const   *)str);
#line 245
  tmp___3 = strlen((char const   *)prefix);
#line 245
  tmp___4 = xmalloc((tmp___2 + tmp___3) + 1UL);
#line 245
  entry = (char *)tmp___4;
#line 246
  *(entry + 0) = (char )'\000';
#line 247
  tmp___6 = strlen((char const   *)prefix);
  }
#line 247
  if (tmp___6) {
    {
#line 249
    tmp___5 = strlen((char const   *)prefix);
#line 249
    strncat((char */* __restrict  */)entry, (char const   */* __restrict  */)prefix,
            tmp___5);
    }
  }
#line 252
  if (array == 1) {
    {
#line 254
    strncat((char */* __restrict  */)entry, (char const   */* __restrict  */)str,
            keylen);
#line 255
    strcat((char */* __restrict  */)entry, (char const   */* __restrict  */)((str + keylen) + 2));
    }
  } else {
    {
#line 259
    strcat((char */* __restrict  */)entry, (char const   */* __restrict  */)str);
    }
  }
  {
#line 263
  tmp___7 = strlen((char const   *)prefix);
#line 263
  len = (int )((keylen + tmp___7) + 1UL);
  }
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 264
      goto while_break;
    }
    {
#line 266
    tmp___12 = memcmp((void const   *)cur->buf, (void const   *)entry, (size_t )len);
    }
#line 266
    if (tmp___12 == 0) {
#line 268
      if (array == 1) {
        {
#line 273
        tmp___8 = strlen((char const   *)cur->buf);
#line 273
        tmp___9 = strlen((char const   *)entry);
#line 273
        tmp___10 = xmalloc(((tmp___8 + tmp___9) - (size_t )len) + 2UL);
#line 273
        temp = (char *)tmp___10;
#line 274
        tmp___11 = strlen((char const   *)cur->buf);
#line 274
        memmove((void *)temp, (void const   *)cur->buf, tmp___11 + 1UL);
#line 275
        strcat((char */* __restrict  */)temp, (char const   */* __restrict  */)"\n");
#line 276
        strcat((char */* __restrict  */)temp, (char const   */* __restrict  */)((str + keylen) + 3));
#line 277
        free((void *)entry);
#line 278
        entry = temp;
        }
      }
      {
#line 281
      free((void *)cur->buf);
      }
#line 282
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 283
        prev->next = cur->next;
      }
      {
#line 284
      free((void *)cur);
#line 285
      cur = prev;
      }
    }
#line 287
    prev = cur;
#line 288
    if (cur) {
#line 290
      cur = (list_t *)cur->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  tmp___13 = xmalloc(sizeof(list_t ));
#line 295
  cur = (list_t *)tmp___13;
#line 296
  cur->buf = entry;
  }
#line 297
  if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 298
    prev->next = (void *)cur;
  }
#line 300
  return (cur);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void free_list_chain(list_t *list ) 
{ 
  list_t *next ;

  {
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! list) {
#line 309
      goto while_break;
    }
    {
#line 311
    next = (list_t *)list->next;
#line 312
    free((void *)list->buf);
#line 313
    free((void *)list);
#line 314
    list = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void readenv(list_t *env ) 
{ 
  int count ;

  {
#line 328
  count = 0;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! ((unsigned long )*(environ + count) != (unsigned long )((void *)0))) {
#line 330
      goto while_break;
    }
    {
#line 332
    myputenv(env, *(environ + count), global.nul_prefix);
#line 333
    count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void CookieVars(list_t *env ) 
{ 
  char *qs ;
  char *token ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 348
  tmp___0 = getenv("HTTP_COOKIE");
  }
#line 348
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 350
    tmp = getenv("HTTP_COOKIE");
#line 350
    qs = strdup((char const   *)tmp);
    }
  } else {
#line 354
    return;
  }
  {
#line 358
  token = strtok((char */* __restrict  */)qs, (char const   */* __restrict  */)";");
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! token) {
#line 359
      goto while_break;
    }
    {
#line 362
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 362
      if (! ((int )*(token + 0) == 32)) {
#line 362
        goto while_break___0;
      }
#line 364
      token ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 366
    myputenv(env, token, global.var_prefix);
#line 367
    myputenv(env, token, global.cookie_prefix);
#line 368
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)";");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  free((void *)qs);
  }
#line 371
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void sessionid(list_t *env ) 
{ 
  char session[29] ;
  time_t tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 383
  tmp = time((time_t *)((void *)0));
#line 383
  tmp___0 = getpid();
#line 383
  sprintf((char */* __restrict  */)(session), (char const   */* __restrict  */)"SESSIONID=%x%x",
          tmp___0, (int )tmp);
#line 384
  myputenv(env, session, global.nul_prefix);
  }
#line 385
  return;
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
list_t *wcversion(list_t *env ) 
{ 
  char version[200] ;
  list_t *tmp ;

  {
  {
#line 391
  sprintf((char */* __restrict  */)(version), (char const   */* __restrict  */)"HASERLVER=%s",
          "0.9.32");
#line 392
  tmp = myputenv(env, version, global.nul_prefix);
  }
#line 392
  return (tmp);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void haserlflags(list_t *env ) 
{ 
  char buf[200] ;

  {
  {
#line 401
  snprintf((char */* __restrict  */)(buf), (size_t )200, (char const   */* __restrict  */)"UPLOAD_DIR=%s",
           global.uploaddir);
#line 402
  myputenv(env, buf, global.haserl_prefix);
#line 404
  snprintf((char */* __restrict  */)(buf), (size_t )200, (char const   */* __restrict  */)"UPLOAD_LIMIT=%lu",
           global.uploadkb);
#line 405
  myputenv(env, buf, global.haserl_prefix);
#line 407
  snprintf((char */* __restrict  */)(buf), (size_t )200, (char const   */* __restrict  */)"ACCEPT_ALL=%d",
           global.acceptall);
#line 408
  myputenv(env, buf, global.haserl_prefix);
#line 410
  snprintf((char */* __restrict  */)(buf), (size_t )200, (char const   */* __restrict  */)"SHELL=%s",
           global.shell);
#line 411
  myputenv(env, buf, global.haserl_prefix);
  }
#line 413
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
int ReadCGIQueryString(list_t *env ) 
{ 
  char *qs ;
  char *token ;
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 426
  tmp___0 = getenv("QUERY_STRING");
  }
#line 426
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 428
    tmp = getenv("QUERY_STRING");
#line 428
    qs = strdup((char const   *)tmp);
    }
  } else {
#line 432
    return (0);
  }
#line 436
  i = 0;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! *(qs + i)) {
#line 436
      goto while_break;
    }
#line 438
    if ((int )*(qs + i) == 43) {
#line 440
      *(qs + i) = (char )' ';
    }
#line 436
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 446
  token = strtok((char */* __restrict  */)qs, (char const   */* __restrict  */)"&;");
  }
  {
#line 447
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 447
    if (! token) {
#line 447
      goto while_break___0;
    }
    {
#line 449
    unescape_url(token);
#line 450
    myputenv(env, token, global.var_prefix);
#line 451
    myputenv(env, token, global.get_prefix);
#line 452
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"&;");
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 454
  free((void *)qs);
  }
#line 455
  return (0);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
int ReadCGIPOSTValues(list_t *env ) 
{ 
  size_t content_length ;
  size_t max_len ;
  size_t i ;
  size_t j ;
  size_t x ;
  sliding_buffer_t sbuf ;
  buffer_t token ;
  unsigned char *data ;
  char const   *CONTENT_LENGTH ;
  char *tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned long tmp___8 ;
  int tmp___9 ;

  {
  {
#line 466
  content_length = (size_t )0;
#line 472
  CONTENT_LENGTH = "CONTENT_LENGTH";
#line 474
  tmp = getenv(CONTENT_LENGTH);
  }
#line 474
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 476
    return (0);
  } else {
    {
#line 474
    tmp___0 = getenv(CONTENT_LENGTH);
#line 474
    tmp___1 = strtoul((char const   */* __restrict  */)tmp___0, (char **/* __restrict  */)((void *)0),
                      10);
    }
#line 474
    if (tmp___1 == 0UL) {
#line 476
      return (0);
    }
  }
  {
#line 478
  tmp___5 = getenv("CONTENT_TYPE");
  }
#line 478
  if (tmp___5) {
    {
#line 480
    tmp___3 = getenv("CONTENT_TYPE");
#line 480
    tmp___4 = strncasecmp((char const   *)tmp___3, "multipart/form-data", (size_t )19);
    }
#line 480
    if (tmp___4 == 0) {
      {
#line 484
      tmp___2 = rfc2388_handler(env);
#line 484
      i = (size_t )tmp___2;
      }
#line 485
      return ((int )i);
    }
  }
  {
#line 489
  s_buffer_init(& sbuf, 32768);
#line 490
  sbuf.fh = 0;
#line 491
  tmp___7 = getenv(CONTENT_LENGTH);
  }
#line 491
  if (tmp___7) {
    {
#line 493
    tmp___6 = getenv(CONTENT_LENGTH);
#line 493
    sbuf.maxread = strtoul((char const   */* __restrict  */)tmp___6, (char **/* __restrict  */)((void *)0),
                           10);
    }
  }
  {
#line 495
  haserl_buffer_init(& token);
  }
#line 499
  if (global.uploadkb == 0UL) {
#line 499
    tmp___8 = 2048UL;
  } else {
#line 499
    tmp___8 = global.uploadkb;
  }
#line 499
  max_len = tmp___8 * 1024UL;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 504
    tmp___9 = s_buffer_read(& sbuf, (char *)"&");
#line 504
    x = (size_t )tmp___9;
#line 505
    content_length += sbuf.len;
    }
#line 506
    if (content_length > max_len) {
      {
#line 508
      die_with_message((void *)0, (char *)((void *)0), "Attempted to send content larger than allowed limits.");
      }
    }
#line 512
    if (x == 0UL) {
      {
#line 514
      buffer_add(& token, (void const   *)((char *)sbuf.segment), sbuf.len);
      }
    } else
#line 512
    if (token.data) {
      {
#line 514
      buffer_add(& token, (void const   *)((char *)sbuf.segment), sbuf.len);
      }
    }
#line 517
    if (x) {
#line 519
      data = sbuf.segment;
#line 520
      *(sbuf.segment + sbuf.len) = (unsigned char )'\000';
#line 521
      if (token.data) {
        {
#line 524
        buffer_add(& token, (void const   *)(sbuf.segment + sbuf.len), 1UL);
#line 525
        data = token.data;
        }
      }
      {
#line 529
      j = strlen((char const   *)((char *)data));
#line 530
      i = (size_t )0;
      }
      {
#line 530
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 530
        if (! (i <= j)) {
#line 530
          goto while_break___0;
        }
#line 532
        if ((int )*(data + i) == 43) {
#line 534
          *(data + i) = (unsigned char )' ';
        }
#line 530
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 537
      unescape_url((char *)data);
#line 538
      myputenv(env, (char *)data, global.var_prefix);
#line 539
      myputenv(env, (char *)data, global.post_prefix);
      }
#line 540
      if (token.data) {
        {
#line 542
        buffer_reset(& token);
        }
      }
    }
#line 501
    if (! (! sbuf.eof)) {
#line 501
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 547
  s_buffer_destroy(& sbuf);
#line 548
  buffer_destroy(& token);
  }
#line 549
  return (0);
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
int parseCommandLine(int argc , char **argv ) 
{ 
  int c ;
  int option_index ;
  int tmp ;

  {
#line 557
  option_index = 0;
#line 562
  optopt = 0;
#line 563
  optind = 0;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 565
    c = getopt_long(argc, (char * const  *)argv, gs_short_options, (struct option  const  *)(ga_long_options),
                    & option_index);
    }
#line 565
    if (! (c != -1)) {
#line 565
      goto while_break;
    }
    {
#line 570
    if (c == 100) {
#line 570
      goto case_100;
    }
#line 573
    if (c == 115) {
#line 573
      goto case_115;
    }
#line 576
    if (c == 83) {
#line 576
      goto case_83;
    }
#line 579
    if (c == 117) {
#line 579
      goto case_117;
    }
#line 589
    if (c == 97) {
#line 589
      goto case_97;
    }
#line 592
    if (c == 110) {
#line 592
      goto case_110;
    }
#line 595
    if (c == 85) {
#line 595
      goto case_85;
    }
#line 598
    if (c == 72) {
#line 598
      goto case_72;
    }
#line 602
    if (c == 104) {
#line 602
      goto case_104;
    }
#line 602
    if (c == 118) {
#line 602
      goto case_104;
    }
#line 568
    goto switch_break;
    case_100: /* CIL Label */ 
#line 571
    global.debug = -1;
#line 572
    goto switch_break;
    case_115: /* CIL Label */ 
#line 574
    global.shell = optarg;
#line 575
    goto switch_break;
    case_83: /* CIL Label */ 
#line 577
    global.silent = -1;
#line 578
    goto switch_break;
    case_117: /* CIL Label */ 
#line 580
    if (optarg) {
      {
#line 582
      tmp = atoi((char const   *)optarg);
#line 582
      global.uploadkb = (unsigned long )tmp;
      }
    } else {
#line 586
      global.uploadkb = 2048UL;
    }
#line 588
    goto switch_break;
    case_97: /* CIL Label */ 
#line 590
    global.acceptall = -1;
#line 591
    goto switch_break;
    case_110: /* CIL Label */ 
#line 593
    global.acceptall = 1;
#line 594
    goto switch_break;
    case_85: /* CIL Label */ 
#line 596
    global.uploaddir = optarg;
#line 597
    goto switch_break;
    case_72: /* CIL Label */ 
#line 599
    global.uploadhandler = optarg;
#line 600
    goto switch_break;
    case_104: /* CIL Label */ 
    case_118: /* CIL Label */ 
    {
#line 603
    printf((char const   */* __restrict  */)"This is haserl version 0.9.32 (http://haserl.sourceforge.net)\n");
#line 605
    exit(0);
    }
#line 606
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 609
  return (optind);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
int BecomeUser(uid_t uid , gid_t gid ) 
{ 
  __uid_t tmp ;
  __gid_t tmp___0 ;
  __uid_t tmp___1 ;

  {
  {
#line 617
  tmp = getuid();
  }
#line 617
  if (tmp == 0U) {
    {
#line 618
    setgroups((size_t )1, (__gid_t const   *)(& gid));
    }
  }
  {
#line 620
  setgid(gid);
#line 621
  tmp___0 = getgid();
#line 621
  setgid(tmp___0);
#line 623
  setuid(uid);
#line 624
  tmp___1 = getuid();
#line 624
  setuid(tmp___1);
  }
#line 626
  return (0);
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void assignGlobalStartupValues(void) 
{ 


  {
#line 636
  global.uploadkb = 0UL;
#line 637
  global.shell = (char *)"/bin/sh";
#line 638
  global.silent = 0;
#line 639
  global.uploaddir = (char *)"/tmp";
#line 640
  global.uploadhandler = (char *)((void *)0);
#line 641
  global.debug = 0;
#line 642
  global.acceptall = 0;
#line 643
  global.uploadlist = (token_t *)((void *)0);
#line 644
  global.var_prefix = (char *)"FORM_";
#line 645
  global.get_prefix = (char *)"GET_";
#line 646
  global.post_prefix = (char *)"POST_";
#line 647
  global.cookie_prefix = (char *)"COOKIE_";
#line 648
  global.haserl_prefix = (char *)"HASERL_";
#line 649
  global.nul_prefix = (char *)"";
#line 651
  return;
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void unlink_uploadlist(void) 
{ 
  token_t *me ;

  {
#line 658
  me = global.uploadlist;
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! me) {
#line 660
      goto while_break;
    }
    {
#line 662
    unlink((char const   *)me->buf);
#line 663
    free((void *)me->buf);
#line 664
    me = (token_t *)me->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 667
  return;
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
void cleanup(void) 
{ 


  {
#line 672
  if (global.uploadlist) {
    {
#line 674
    unlink_uploadlist();
#line 675
    free_token_list(global.uploadlist);
#line 676
    global.uploadlist = (token_t *)((void *)0);
    }
  }
#line 678
  return;
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/haserl.c"
int main(int argc , char **argv ) 
{ 
  token_t *tokenchain ;
  buffer_t script_text ;
  script_t *scriptchain ;
  char *filename ;
  argv_t *av ;
  char **av2 ;
  int av2c ;
  int command ;
  int count ;
  list_t *env ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 690
  tokenchain = (token_t *)((void *)0);
#line 695
  filename = (char *)((void *)0);
#line 697
  av = (argv_t *)((void *)0);
#line 698
  av2 = argv;
#line 699
  av2c = argc;
#line 704
  env = (list_t *)((void *)0);
#line 706
  tmp = atexit(& cleanup);
  }
#line 706
  if (tmp != 0) {
    {
#line 708
    die_with_message((void *)0, (char *)((void *)0), "atexit() failed");
    }
  }
  {
#line 711
  assignGlobalStartupValues();
#line 713
  haserl_buffer_init(& script_text);
  }
  {
#line 719
  if (argc == 1) {
#line 719
    goto case_1;
  }
#line 737
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 721
  puts("This is haserl version 0.9.32\nThis program runs as a cgi interpeter, not interactively\nPlease see:  http://haserl.sourceforge.net\n");
  }
#line 735
  return (0);
#line 736
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 739
  command = argc_argv(*(argv + 1), & av, (char *)"");
  }
#line 741
  if (command > 1) {
    {
#line 744
    av2c = (argc - 1) + command;
#line 745
    tmp___0 = xmalloc(sizeof(char *) * (unsigned long )av2c);
#line 745
    av2 = (char **)tmp___0;
#line 746
    *(av2 + 0) = *(argv + 0);
#line 747
    count = 1;
    }
    {
#line 747
    while (1) {
      while_continue: /* CIL Label */ ;
#line 747
      if (! (count <= command)) {
#line 747
        goto while_break;
      }
#line 749
      *(av2 + count) = (av + (count - 1))->string;
#line 747
      count ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 751
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 751
      if (! (count < av2c)) {
#line 751
        goto while_break___0;
      }
#line 753
      *(av2 + count) = *(argv + ((count - command) + 1));
#line 751
      count ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 757
  parseCommandLine(av2c, av2);
#line 758
  free((void *)av);
  }
#line 759
  if ((unsigned long )av2 != (unsigned long )argv) {
    {
#line 760
    free((void *)av2);
    }
  }
#line 762
  if (optind < av2c) {
#line 764
    filename = *(av2 + optind);
  } else {
    {
#line 768
    die_with_message((void *)0, (char *)((void *)0), "No script file specified");
    }
  }
#line 771
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 775
  scriptchain = load_script(filename, (script_t *)((void *)0));
#line 777
  BecomeUser(scriptchain->uid, scriptchain->gid);
#line 780
  tmp___1 = strcmp((char const   *)global.shell, "lua");
  }
#line 780
  if (tmp___1) {
    {
#line 780
    tmp___2 = strcmp((char const   *)global.shell, "luac");
    }
#line 780
    if (tmp___2) {
#line 784
      shell_exec = & bash_exec;
#line 785
      shell_echo = & bash_echo;
#line 786
      shell_eval = & bash_eval;
#line 787
      shell_setup = & bash_setup;
#line 788
      shell_doscript = & bash_doscript;
#line 789
      shell_destroy = & bash_destroy;
    } else {
      {
#line 845
      die_with_message((void *)0, (char *)((void *)0), "Lua shells are not enabled.");
      }
    }
  } else {
    {
#line 845
    die_with_message((void *)0, (char *)((void *)0), "Lua shells are not enabled.");
    }
  }
  {
#line 850
  env = wcversion(env);
#line 851
  readenv(env);
#line 852
  sessionid(env);
#line 853
  haserlflags(env);
#line 856
  tmp___3 = strcmp((char const   *)global.shell, "luac");
  }
#line 856
  if (tmp___3) {
    {
#line 858
    tokenchain = build_token_list(scriptchain, (token_t *)((void *)0));
#line 859
    preprocess_token_list(tokenchain);
    }
  }
#line 864
  if (global.acceptall != 1) {
    {
#line 867
    CookieVars(env);
#line 868
    tmp___8 = getenv("REQUEST_METHOD");
    }
#line 868
    if (tmp___8) {
      {
#line 870
      tmp___4 = getenv("REQUEST_METHOD");
#line 870
      tmp___5 = strcasecmp((char const   *)tmp___4, "GET");
      }
#line 870
      if (tmp___5 == 0) {
#line 872
        if (global.acceptall == -1) {
          {
#line 873
          ReadCGIPOSTValues(env);
          }
        }
        {
#line 874
        ReadCGIQueryString(env);
        }
      }
      {
#line 877
      tmp___6 = getenv("REQUEST_METHOD");
#line 877
      tmp___7 = strcasecmp((char const   *)tmp___6, "POST");
      }
#line 877
      if (tmp___7 == 0) {
#line 879
        if (global.acceptall == -1) {
          {
#line 880
          ReadCGIQueryString(env);
          }
        }
        {
#line 881
        ReadCGIPOSTValues(env);
        }
      }
    }
  }
  {
#line 888
  tmp___9 = strcmp((char const   *)global.shell, "luac");
  }
#line 888
  if (tmp___9) {
    {
#line 890
    process_token_list(& script_text, tokenchain);
    }
  }
#line 895
  if (global.debug == -1) {
    {
#line 898
    tmp___10 = getenv("REQUEST_METHOD");
    }
#line 898
    if (tmp___10) {
      {
#line 900
      write(1, (void const   *)"Content-Type: text/plain\n\n", (size_t )26);
      }
    }
    {
#line 902
    write(1, (void const   *)script_text.data, (size_t )(script_text.ptr - script_text.data));
    }
  } else {
    {
#line 910
    (*shell_setup)(global.shell, env);
#line 914
    (*shell_doscript)(& script_text, scriptchain->name);
#line 916
    (*shell_destroy)();
    }
  }
  {
#line 921
  buffer_destroy(& script_text);
#line 922
  free_token_list(tokenchain);
#line 925
  free_list_chain(env);
#line 926
  free_script_list(scriptchain);
  }
#line 928
  return (0);
}
}
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.h"
token_t *push_token_on_list(token_t *tokenlist , script_t *scriptbuf , char *start ,
                            size_t len ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
char const   *g_tag[6]  = {      "",      "",      "in",      "=", 
        "#",      ""};
#line 78 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
char open_tag[3]  = {      (char )'<',      (char )'%',      (char )'\000'};
#line 79 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
char close_tag[3]  = {      (char )'%',      (char )'>',      (char )'\000'};
#line 84 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
script_t *load_script(char *filename , script_t *scriptlist ) 
{ 
  script_t *scriptbuf ;
  int scriptfp ;
  struct stat filestat ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 91
  scriptfp = open((char const   *)filename, 2048);
  }
#line 92
  if (scriptfp == -1) {
    {
#line 94
    die_with_message((void *)0, (char *)((void *)0), (char const   *)g_err_msg[2],
                     filename);
    }
  }
  {
#line 97
  fstat(scriptfp, & filestat);
#line 98
  tmp = xmalloc(sizeof(script_t ));
#line 98
  scriptbuf = (script_t *)tmp;
#line 99
  tmp___0 = strlen((char const   *)filename);
#line 99
  tmp___1 = xmalloc(tmp___0 + 1UL);
#line 99
  scriptbuf->name = (char *)tmp___1;
#line 100
  tmp___2 = xmalloc((size_t )(filestat.st_size + 1L));
#line 100
  scriptbuf->buf = (char *)tmp___2;
#line 102
  tmp___3 = strlen((char const   *)filename);
#line 102
  memset((void *)scriptbuf->name, 0, tmp___3 + 1UL);
#line 103
  tmp___4 = strlen((char const   *)filename);
#line 103
  memcpy((void */* __restrict  */)scriptbuf->name, (void const   */* __restrict  */)filename,
         tmp___4);
#line 104
  memset((void *)scriptbuf->buf, 0, (size_t )(filestat.st_size + 1L));
#line 105
  read(scriptfp, (void *)scriptbuf->buf, (size_t )filestat.st_size);
#line 107
  scriptbuf->size = (int )filestat.st_size;
#line 108
  scriptbuf->uid = filestat.st_uid;
#line 109
  scriptbuf->gid = filestat.st_gid;
#line 110
  scriptbuf->curpos = (size_t )0;
#line 111
  scriptbuf->next = (void *)0;
  }
#line 114
  if ((unsigned long )scriptlist != (unsigned long )((void *)0)) {
    {
#line 116
    while (1) {
      while_continue: /* CIL Label */ ;
#line 116
      if (! scriptlist->next) {
#line 116
        goto while_break;
      }
#line 117
      scriptlist = (script_t *)scriptlist->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 118
    scriptlist->next = (void *)scriptbuf;
  }
  {
#line 125
  tmp___5 = memcmp((void const   *)scriptbuf->buf, (void const   *)"#!", (size_t )2);
  }
#line 125
  if (tmp___5 == 0) {
    {
#line 127
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 127
      if (scriptbuf->curpos < (size_t )scriptbuf->size) {
#line 127
        if (! ((int )*(scriptbuf->buf + scriptbuf->curpos) != 10)) {
#line 127
          goto while_break___0;
        }
      } else {
#line 127
        goto while_break___0;
      }
#line 130
      (scriptbuf->curpos) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 132
    (scriptbuf->curpos) ++;
  }
#line 139
  if ((unsigned long )scriptlist == (unsigned long )((void *)0)) {
    {
#line 141
    tmp___6 = strstr((char const   *)(scriptbuf->buf + scriptbuf->curpos), (char const   *)(open_tag));
    }
#line 141
    if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
#line 143
      open_tag[1] = (char )'?';
#line 144
      close_tag[0] = (char )'?';
    }
  }
  {
#line 147
  close(scriptfp);
  }
#line 148
  return (scriptbuf);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
void free_script_list(script_t *script ) 
{ 
  script_t *next ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! script) {
#line 156
      goto while_break;
    }
#line 158
    next = (script_t *)script->next;
#line 159
    if (script->name) {
      {
#line 160
      free((void *)script->name);
      }
    }
#line 161
    if (script->buf) {
      {
#line 162
      free((void *)script->buf);
      }
    }
    {
#line 163
    free((void *)script);
#line 164
    script = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
token_t *push_token_on_list(token_t *tokenlist , script_t *scriptbuf , char *start ,
                            size_t len ) 
{ 
  token_t *me ;
  token_t *next ;
  void *tmp ;

  {
#line 176
  if (len == 0UL) {
#line 177
    return (tokenlist);
  }
  {
#line 179
  tmp = xmalloc(sizeof(token_t ));
#line 179
  me = (token_t *)tmp;
  }
#line 181
  if ((unsigned long )tokenlist == (unsigned long )((void *)0)) {
#line 183
    next = (token_t *)((void *)0);
  } else {
#line 187
    next = (token_t *)tokenlist->next;
#line 188
    tokenlist->next = (void *)me;
  }
#line 191
  me->next = (void *)next;
#line 192
  me->script = scriptbuf;
#line 193
  me->buf = start;
#line 194
  me->len = len;
#line 196
  return (me);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
void free_token_list(token_t *tokenlist ) 
{ 
  token_t *next ;

  {
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! tokenlist) {
#line 205
      goto while_break;
    }
    {
#line 207
    next = (token_t *)tokenlist->next;
#line 208
    free((void *)tokenlist);
#line 209
    tokenlist = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
char *skip_comment(char *startbuf , char *endbuf ) 
{ 
  unsigned int c_lev ;
  char *s_tag ;
  char *e_tag ;

  {
#line 219
  c_lev = 1U;
#line 222
  startbuf += 2;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! ((unsigned long )startbuf < (unsigned long )endbuf)) {
#line 223
      goto while_break;
    }
    {
#line 225
    s_tag = strstr((char const   *)startbuf, (char const   *)(open_tag));
#line 226
    e_tag = strstr((char const   *)startbuf, (char const   *)(close_tag));
    }
#line 228
    if (! e_tag) {
#line 230
      goto while_break;
    }
#line 233
    if (s_tag) {
#line 233
      if ((unsigned long )s_tag < (unsigned long )e_tag) {
#line 235
        c_lev ++;
#line 236
        startbuf = s_tag + 2;
#line 237
        goto while_continue;
      }
    }
#line 240
    c_lev --;
#line 241
    startbuf = e_tag;
#line 242
    if (c_lev == 0U) {
#line 244
      return (startbuf);
    }
#line 246
    startbuf += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  return ((char *)((void *)0));
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
token_t *build_token_list(script_t *scriptbuf , token_t *tokenlist ) 
{ 
  char *start ;
  char *end ;
  char *curpos ;
  char *endpos ;
  token_t *curtoken ;
  token_t *firsttoken ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 268
  curtoken = tokenlist;
#line 269
  firsttoken = tokenlist;
#line 271
  curpos = scriptbuf->buf + scriptbuf->curpos;
#line 272
  endpos = scriptbuf->buf + scriptbuf->size;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! ((unsigned long )curpos < (unsigned long )endpos)) {
#line 274
      goto while_break;
    }
    {
#line 276
    start = strstr((char const   *)curpos, (char const   *)(open_tag));
#line 277
    end = strstr((char const   *)curpos, (char const   *)(close_tag));
    }
#line 280
    if (start) {
      {
#line 280
      tmp = memcmp((void const   *)(start + 2), (void const   *)g_tag[4], (size_t )1);
      }
#line 280
      if (tmp == 0) {
        {
#line 283
        curtoken = push_token_on_list(curtoken, scriptbuf, curpos, (size_t )(start - curpos));
        }
#line 285
        if ((unsigned long )firsttoken == (unsigned long )((void *)0)) {
#line 286
          firsttoken = curtoken;
        }
        {
#line 288
        end = skip_comment(start, endpos);
        }
#line 289
        if (end) {
#line 291
          curpos = end + 2;
#line 292
          goto while_continue;
        }
      }
    }
#line 296
    if (start) {
#line 296
      if (! end) {
        {
#line 297
        die_with_message((void *)scriptbuf, start, (char const   *)g_err_msg[4], (int )open_tag[1]);
        }
      }
    }
#line 300
    if ((unsigned long )start > (unsigned long )end) {
      {
#line 301
      die_with_message((void *)scriptbuf, end, (char const   *)g_err_msg[3], (int )open_tag[1],
                       (int )open_tag[1]);
      }
    } else
#line 300
    if (! start) {
#line 300
      if (end) {
        {
#line 301
        die_with_message((void *)scriptbuf, end, (char const   *)g_err_msg[3], (int )open_tag[1],
                         (int )open_tag[1]);
        }
      }
    }
#line 304
    if (start) {
      {
#line 304
      tmp___0 = strstr((char const   *)(start + 1), (char const   *)(open_tag));
      }
#line 304
      if (tmp___0) {
        {
#line 304
        tmp___1 = strstr((char const   *)(start + 1), (char const   *)(open_tag));
        }
#line 304
        if ((unsigned long )tmp___1 < (unsigned long )end) {
          {
#line 306
          die_with_message((void *)scriptbuf, start, (char const   *)g_err_msg[4],
                           (int )open_tag[1]);
          }
        }
      }
    }
#line 308
    if (end) {
      {
#line 311
      curtoken = push_token_on_list(curtoken, scriptbuf, curpos, (size_t )(start - curpos));
      }
#line 313
      if ((unsigned long )firsttoken == (unsigned long )((void *)0)) {
#line 314
        firsttoken = curtoken;
      }
      {
#line 316
      curtoken = push_token_on_list(curtoken, scriptbuf, start, (size_t )(end - start));
      }
#line 318
      if ((unsigned long )firsttoken == (unsigned long )((void *)0)) {
#line 319
        firsttoken = curtoken;
      }
#line 320
      curpos = end + 2;
    } else {
      {
#line 325
      curtoken = push_token_on_list(curtoken, scriptbuf, curpos, (size_t )(endpos - curpos));
      }
#line 327
      if ((unsigned long )firsttoken == (unsigned long )((void *)0)) {
#line 328
        firsttoken = curtoken;
      }
#line 329
      curpos = endpos;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return (firsttoken);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
void preprocess_token_list(token_t *tokenlist ) 
{ 
  script_t *newscript ;
  token_t *me ;
  char *cp ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
#line 344
  me = tokenlist;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! me) {
#line 346
      goto while_break;
    }
    {
#line 348
    tmp___3 = memcmp((void const   *)me->buf, (void const   *)(open_tag), (size_t )2);
    }
#line 348
    if (tmp___3) {
#line 350
      me->tag = (enum tag_t )0;
    } else {
      {
#line 354
      me->tag = (enum tag_t )5;
#line 355
      *(me->buf + me->len) = (char )'\000';
#line 356
      cp = me->buf + 2;
#line 357
      tmp___1 = memcmp((void const   *)cp, (void const   *)g_tag[2], (size_t )2);
      }
#line 357
      if (tmp___1 == 0) {
        {
#line 359
        me->tag = (enum tag_t )2;
#line 361
        me->buf = find_whitespace(me->buf);
#line 362
        me->buf = skip_whitespace(me->buf);
#line 363
        cp = find_whitespace(me->buf);
#line 364
        *cp = (char )'\000';
#line 365
        tmp = strlen((char const   *)me->buf);
#line 365
        me->len = tmp + 1UL;
#line 366
        newscript = load_script(me->buf, me->script);
#line 367
        build_token_list(newscript, me);
        }
      } else {
        {
#line 369
        tmp___0 = memcmp((void const   *)cp, (void const   *)g_tag[3], (size_t )1);
        }
#line 369
        if (tmp___0 == 0) {
          {
#line 372
          me->tag = (enum tag_t )3;
#line 373
          me->buf = find_whitespace(me->buf);
#line 374
          me->len = strlen((char const   *)me->buf);
          }
        }
      }
      {
#line 504
      tmp___2 = __ctype_b_loc();
      }
#line 504
      if ((int const   )*(*tmp___2 + (int )*cp) & 8192) {
#line 506
        me->tag = (enum tag_t )1;
#line 507
        me->buf = cp;
      }
#line 509
      if ((unsigned int )me->tag == 5U) {
        {
#line 511
        die_with_message((void *)me->script, cp, (char const   *)g_err_msg[5]);
        }
      }
      {
#line 513
      me->len = strlen((char const   *)me->buf);
      }
    }
#line 515
    me = (token_t *)me->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return;
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/h_script.c"
token_t *process_token_list(buffer_t *buf , token_t *token ) 
{ 
  char *c ;
  unsigned short const   **tmp ;

  {
  {
#line 525
  haserl_buffer_init(buf);
#line 526
  (*shell_exec)(buf, (char *)"\n");
  }
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! token) {
#line 528
      goto while_break;
    }
    {
#line 532
    if ((unsigned int )token->tag == 0U) {
#line 532
      goto case_0;
    }
#line 541
    if ((unsigned int )token->tag == 1U) {
#line 541
      goto case_1;
    }
#line 545
    if ((unsigned int )token->tag == 3U) {
#line 545
      goto case_3;
    }
#line 604
    goto switch_default;
    case_0: /* CIL Label */ 
#line 535
    c = token->buf;
    {
#line 536
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 536
      if ((unsigned long )c < (unsigned long )(token->buf + token->len)) {
        {
#line 536
        tmp = __ctype_b_loc();
        }
#line 536
        if (! ((int const   )*(*tmp + (int )*c) & 8192)) {
#line 536
          goto while_break___0;
        }
      } else {
#line 536
        goto while_break___0;
      }
#line 537
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 538
    if ((unsigned long )c != (unsigned long )(token->buf + token->len)) {
      {
#line 539
      (*shell_echo)(buf, token->buf, token->len);
      }
    }
#line 540
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 542
    (*shell_exec)(buf, token->buf);
#line 543
    (*shell_exec)(buf, (char *)"\n");
    }
#line 544
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 546
    (*shell_eval)(buf, token->buf, token->len);
    }
#line 547
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 605
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 607
    token = (token_t *)token->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  return (token);
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 350 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                                                             __mode_t __mode ) ;
#line 620 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 373
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                                                     char const   *__needle )  __attribute__((__pure__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.h"
void empty_stdin(void) ;
#line 37
void mime_var_init(mime_var_t *obj ) ;
#line 38
void mime_var_destroy(mime_var_t *obj ) ;
#line 39
char *mime_substr(char *start , int len ) ;
#line 40
void mime_tag_add(mime_var_t *obj , char *str ) ;
#line 41
void mime_var_putenv(list_t *env , mime_var_t *obj ) ;
#line 42
void mime_exec(mime_var_t *obj , char *fifo ) ;
#line 43
void mime_var_open_target(mime_var_t *obj ) ;
#line 44
void mime_var_writer(mime_var_t *obj , char *str , int len ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
void empty_stdin(void) 
{ 
  char c[2000] ;
  ssize_t tmp ;

  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    tmp = read(0, (void *)(& c), (size_t )2000);
    }
#line 54
    if (! tmp) {
#line 54
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
void mime_var_init(mime_var_t *obj ) 
{ 


  {
  {
#line 63
  obj->name = (char *)((void *)0);
#line 64
  obj->filename = (char *)((void *)0);
#line 65
  obj->type = (char *)((void *)0);
#line 66
  obj->tempname = (char *)((void *)0);
#line 67
  haserl_buffer_init(& obj->value);
#line 68
  obj->fh = 0;
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
void mime_var_destroy(mime_var_t *obj ) 
{ 
  int status ;
  struct sigaction new_action ;
  int tmp ;

  {
#line 77
  if (obj->name) {
    {
#line 79
    free((void *)obj->name);
#line 80
    obj->name = (char *)((void *)0);
    }
  }
#line 82
  if (obj->filename) {
    {
#line 84
    free((void *)obj->filename);
#line 85
    obj->filename = (char *)((void *)0);
    }
  }
#line 87
  if (obj->type) {
    {
#line 89
    free((void *)obj->type);
#line 90
    obj->type = (char *)((void *)0);
    }
  }
#line 92
  if (obj->tempname) {
    {
#line 94
    free((void *)obj->tempname);
#line 95
    obj->tempname = (char *)((void *)0);
    }
  }
  {
#line 97
  buffer_destroy(& obj->value);
  }
#line 98
  if (obj->fh) {
    {
#line 100
    tmp = abs(obj->fh);
#line 100
    close(tmp);
    }
#line 101
    if (global.uploadhandler) {
      {
#line 103
      wait((union wait *)(& status));
#line 104
      new_action.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 105
      sigemptyset(& new_action.sa_mask);
#line 106
      new_action.sa_flags = 0;
#line 107
      sigaction(13, (struct sigaction  const  */* __restrict  */)(& new_action), (struct sigaction */* __restrict  */)((void *)0));
      }
    }
#line 109
    obj->fh = 0;
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
char *mime_substr(char *start , int len ) 
{ 
  char *ptr ;
  void *tmp ;

  {
#line 118
  if (! start) {
#line 119
    return ((char *)((void *)0));
  }
#line 120
  if (len < 0) {
#line 121
    return ((char *)((void *)0));
  }
  {
#line 122
  tmp = xmalloc((size_t )(len + 2));
#line 122
  ptr = (char *)tmp;
#line 123
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)start, (size_t )len);
  }
#line 124
  return (ptr);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
static char *tag[3]  = {      (char *)"name=\"",      (char *)"filename=\"",      (char *)"Content-Type: "};
#line 128 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
void mime_tag_add(mime_var_t *obj , char *str ) 
{ 
  char *a ;
  char *b ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 131
  a = (char *)((void *)0);
#line 132
  b = (char *)((void *)0);
#line 135
  a = strcasestr((char const   *)str, (char const   *)tag[0]);
  }
#line 136
  if (a) {
    {
#line 138
    tmp = strlen((char const   *)tag[0]);
#line 138
    a += tmp;
#line 139
    b = strchr((char const   *)a, '\"');
    }
#line 140
    if (! obj->name) {
      {
#line 141
      obj->name = mime_substr(a, (int )(b - a));
      }
    }
  }
  {
#line 144
  a = strcasestr((char const   *)str, (char const   *)tag[1]);
  }
#line 145
  if (a) {
    {
#line 147
    tmp___0 = strlen((char const   *)tag[1]);
#line 147
    a += tmp___0;
#line 148
    b = strchr((char const   *)a, '\"');
    }
#line 149
    if (! obj->filename) {
      {
#line 150
      obj->filename = mime_substr(a, (int )(b - a));
      }
    }
  }
  {
#line 153
  a = strcasestr((char const   *)str, (char const   *)tag[2]);
  }
#line 154
  if (a) {
    {
#line 156
    tmp___1 = strlen((char const   *)tag[2]);
#line 156
    a += tmp___1;
#line 157
    tmp___2 = strlen((char const   *)a);
#line 157
    b = a + tmp___2;
    }
#line 158
    if (! obj->type) {
      {
#line 159
      obj->type = mime_substr(a, (int )(b - a));
      }
    }
  }
#line 161
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
void mime_var_putenv(list_t *env , mime_var_t *obj ) 
{ 
  buffer_t buf ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 167
  haserl_buffer_init(& buf);
  }
#line 168
  if (obj->name) {
    {
#line 174
    buffer_add(& obj->value, (void const   *)"", 1UL);
#line 175
    tmp = strlen((char const   *)obj->name);
#line 175
    buffer_add(& buf, (void const   *)obj->name, tmp);
#line 176
    buffer_add(& buf, (void const   *)"=", 1UL);
#line 177
    tmp___0 = strlen((char const   *)((char *)obj->value.data));
#line 177
    buffer_add(& buf, (void const   *)((char *)obj->value.data), tmp___0 + 1UL);
#line 179
    myputenv(env, (char *)buf.data, global.var_prefix);
#line 180
    myputenv(env, (char *)buf.data, global.post_prefix);
#line 181
    buffer_reset(& buf);
    }
  }
#line 183
  if (obj->filename) {
    {
#line 186
    tmp___1 = strlen((char const   *)obj->name);
#line 186
    buffer_add(& buf, (void const   *)obj->name, tmp___1);
#line 187
    buffer_add(& buf, (void const   *)"_path=", 6UL);
#line 188
    tmp___2 = strlen((char const   *)((char *)obj->value.data));
#line 188
    buffer_add(& buf, (void const   *)((char *)obj->value.data), tmp___2 + 1UL);
#line 190
    myputenv(env, (char *)buf.data, global.haserl_prefix);
#line 191
    myputenv(env, (char *)buf.data, global.var_prefix);
#line 192
    myputenv(env, (char *)buf.data, global.post_prefix);
#line 193
    buffer_reset(& buf);
#line 196
    tmp___3 = strlen((char const   *)obj->name);
#line 196
    buffer_add(& buf, (void const   *)obj->name, tmp___3);
#line 197
    buffer_add(& buf, (void const   *)"_name=", 6UL);
#line 198
    tmp___4 = strlen((char const   *)obj->filename);
#line 198
    buffer_add(& buf, (void const   *)obj->filename, tmp___4 + 1UL);
#line 199
    myputenv(env, (char *)buf.data, global.var_prefix);
#line 200
    myputenv(env, (char *)buf.data, global.post_prefix);
#line 201
    buffer_reset(& buf);
    }
  }
  {
#line 203
  buffer_destroy(& buf);
  }
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
void mime_exec(mime_var_t *obj , char *fifo ) 
{ 
  int pid ;
  char *av[4] ;
  char *type ;
  char *filename ;
  char *name ;
  char *c ;
  int fh ;
  struct sigaction new_action ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 219
  pid = fork();
  }
#line 220
  if (pid == -1) {
    {
#line 222
    empty_stdin();
#line 223
    die_with_message((void *)0, (char *)((void *)0), (char const   *)g_err_msg[6]);
    }
  }
#line 226
  if (pid == 0) {
#line 232
    if (obj->type) {
      {
#line 235
      tmp = strlen((char const   *)obj->type);
#line 235
      tmp___0 = xmalloc((13UL + tmp) + 1UL);
#line 235
      type = (char *)tmp___0;
#line 236
      sprintf((char */* __restrict  */)type, (char const   */* __restrict  */)"CONTENT_TYPE=%s",
              obj->type);
#line 237
      putenv(type);
      }
    }
#line 239
    if (obj->filename) {
      {
#line 241
      tmp___1 = strlen((char const   *)obj->filename);
#line 241
      tmp___2 = xmalloc((9UL + tmp___1) + 1UL);
#line 241
      filename = (char *)tmp___2;
#line 242
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"FILENAME=%s",
              obj->filename);
#line 243
      putenv(filename);
      }
    }
#line 246
    if (obj->name) {
      {
#line 248
      tmp___3 = strlen((char const   *)obj->name);
#line 248
      tmp___4 = xmalloc((5UL + tmp___3) + 1UL);
#line 248
      name = (char *)tmp___4;
#line 249
      sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"NAME=%s",
              obj->name);
#line 250
      putenv(name);
      }
    }
    {
#line 253
    av[0] = global.uploadhandler;
#line 254
    av[1] = fifo;
#line 255
    av[2] = (char *)((void *)0);
#line 256
    execv((char const   *)av[0], (char * const  *)(av));
#line 259
    fh = open((char const   *)fifo, 0);
    }
    {
#line 260
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 260
      tmp___5 = read(fh, (void *)(& c), (size_t )1);
      }
#line 260
      if (! tmp___5) {
#line 260
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 263
    exit(-1);
    }
  } else {
    {
#line 268
    new_action.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 269
    sigemptyset(& new_action.sa_mask);
#line 270
    new_action.sa_flags = 0;
#line 271
    sigaction(13, (struct sigaction  const  */* __restrict  */)(& new_action), (struct sigaction */* __restrict  */)((void *)0));
    }
  }
#line 276
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
void mime_var_open_target(mime_var_t *obj ) 
{ 
  char *tmpname ;
  token_t *curtoken ;
  int ok ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 283
  curtoken = global.uploadlist;
#line 287
  if (global.uploadkb == 0UL) {
    {
#line 289
    empty_stdin();
#line 290
    die_with_message((void *)0, (char *)((void *)0), "File uploads are not allowed.");
    }
  }
  {
#line 294
  ok = -1;
#line 295
  tmp = strlen((char const   *)global.uploaddir);
#line 295
  tmp___0 = xmalloc(tmp + 8UL);
#line 295
  tmpname = (char *)tmp___0;
#line 296
  strcpy((char */* __restrict  */)tmpname, (char const   */* __restrict  */)global.uploaddir);
#line 297
  strcat((char */* __restrict  */)tmpname, (char const   */* __restrict  */)"/XXXXXX");
#line 298
  obj->fh = mkstemp(tmpname);
  }
#line 300
  if (obj->fh == -1) {
#line 302
    ok = 0;
  }
#line 308
  if (ok) {
#line 308
    if (global.uploadhandler) {
      {
#line 312
      close(obj->fh);
#line 313
      unlink((char const   *)tmpname);
#line 314
      tmp___1 = mkfifo((char const   *)tmpname, (__mode_t )384);
      }
#line 314
      if (tmp___1) {
#line 316
        ok = 0;
      }
#line 321
      if (ok) {
        {
#line 323
        mime_exec(obj, tmpname);
#line 324
        obj->fh = open((char const   *)tmpname, 1);
        }
      }
#line 326
      if (obj->fh == -1) {
#line 327
        ok = 0;
      }
    } else {
      {
#line 331
      tmp___2 = strlen((char const   *)tmpname);
#line 331
      buffer_add(& obj->value, (void const   *)tmpname, tmp___2);
      }
    }
  } else {
    {
#line 331
    tmp___2 = strlen((char const   *)tmpname);
#line 331
    buffer_add(& obj->value, (void const   *)tmpname, tmp___2);
    }
  }
#line 334
  if (! ok) {
    {
#line 336
    empty_stdin();
#line 337
    die_with_message((void *)0, (char *)((void *)0), (char const   *)g_err_msg[2],
                     tmpname);
    }
  }
  {
#line 340
  tmp___3 = strlen((char const   *)tmpname);
#line 340
  curtoken = push_token_on_list(curtoken, (script_t *)((void *)0), tmpname, tmp___3 + 1UL);
  }
#line 342
  if ((unsigned long )global.uploadlist == (unsigned long )((void *)0)) {
#line 344
    global.uploadlist = curtoken;
  }
#line 347
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
void mime_var_writer(mime_var_t *obj , char *str , int len ) 
{ 
  int err ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 358
  if (! obj->filename) {
    {
#line 360
    buffer_add(& obj->value, (void const   *)str, (unsigned long )len);
    }
  }
#line 364
  if (! obj->fh) {
#line 364
    if (obj->filename) {
      {
#line 365
      mime_var_open_target(obj);
      }
    }
  }
#line 368
  if (obj->fh > 0) {
    {
#line 370
    tmp = write(obj->fh, (void const   *)str, (size_t )len);
#line 370
    err = (int )tmp;
    }
#line 373
    if (err == -1) {
      {
#line 375
      tmp___0 = abs(obj->fh);
#line 375
      obj->fh = tmp___0 * -1;
      }
    }
  }
#line 378
  return;
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/haserl-0.9.32/src/rfc2388.c"
int rfc2388_handler(list_t *env ) 
{ 
  int state ;
  int i ;
  int x ;
  unsigned long max_len ;
  unsigned long content_length ;
  sliding_buffer_t sbuf ;
  char *crlf ;
  char *boundary ;
  char *str ;
  buffer_t buf ;
  mime_var_t var ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 396
  crlf = (char *)"\r\n";
#line 403
  str = getenv("CONTENT_TYPE");
#line 404
  tmp = strlen((char const   *)str);
#line 404
  i = (int )(tmp - 9UL);
  }
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (i >= 0) {
      {
#line 405
      tmp___0 = memcmp((void const   *)"boundary=", (void const   *)(str + i), (size_t )9);
      }
#line 405
      if (! tmp___0) {
#line 405
        goto while_break;
      }
    } else {
#line 405
      goto while_break;
    }
#line 407
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  if (i == -1) {
    {
#line 411
    empty_stdin();
#line 412
    die_with_message((void *)0, (char *)((void *)0), "No Mime Boundary Information Found");
    }
  }
#line 415
  i += 9;
#line 416
  if ((int )*(str + i) == 34) {
#line 417
    i ++;
  }
  {
#line 419
  tmp___1 = strlen((char const   *)(str + i));
#line 419
  tmp___2 = xmalloc(tmp___1 + 5UL);
#line 419
  boundary = (char *)tmp___2;
#line 420
  memcpy((void */* __restrict  */)boundary, (void const   */* __restrict  */)crlf,
         (size_t )2);
#line 421
  memcpy((void */* __restrict  */)(boundary + 2), (void const   */* __restrict  */)"--",
         (size_t )2);
#line 422
  tmp___3 = strlen((char const   *)(str + i));
#line 422
  memcpy((void */* __restrict  */)(boundary + 4), (void const   */* __restrict  */)(str + i),
         tmp___3 + 1UL);
  }
#line 423
  if (i > 0) {
#line 423
    if ((int )*(str + (i - 1)) == 34) {
      {
#line 425
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 425
        if (*(boundary + i)) {
#line 425
          if (! ((int )*(boundary + i) != 34)) {
#line 425
            goto while_break___0;
          }
        } else {
#line 425
          goto while_break___0;
        }
#line 426
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 427
      *(boundary + i) = (char )'\000';
    }
  }
#line 431
  if (global.uploadkb == 0UL) {
#line 431
    tmp___4 = 2048UL;
  } else {
#line 431
    tmp___4 = global.uploadkb;
  }
  {
#line 431
  max_len = tmp___4 * 1024UL;
#line 432
  content_length = 0UL;
#line 435
  s_buffer_init(& sbuf, 131072);
#line 436
  sbuf.fh = 0;
#line 437
  tmp___6 = getenv("CONTENT_LENGTH");
  }
#line 437
  if (tmp___6) {
    {
#line 439
    tmp___5 = getenv("CONTENT_LENGTH");
#line 439
    sbuf.maxread = strtoul((char const   */* __restrict  */)tmp___5, (char **/* __restrict  */)((void *)0),
                           10);
    }
  }
  {
#line 443
  haserl_buffer_init(& buf);
#line 444
  buffer_add(& buf, (void const   *)"", 1UL);
#line 445
  buffer_reset(& buf);
#line 447
  state = 0;
#line 448
  str = boundary + 2;
  }
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 452
    x = s_buffer_read(& sbuf, str);
#line 453
    content_length += sbuf.len;
    }
#line 454
    if (content_length >= max_len) {
      {
#line 456
      empty_stdin();
#line 457
      free((void *)boundary);
#line 458
      s_buffer_destroy(& sbuf);
#line 459
      buffer_destroy(& buf);
      }
#line 460
      if (var.name) {
        {
#line 462
        mime_var_destroy(& var);
        }
      }
      {
#line 464
      die_with_message((void *)0, (char *)((void *)0), "Attempted to send content larger than allowed limits.");
      }
    }
    {
#line 471
    if (state == 0) {
#line 471
      goto case_0;
    }
#line 482
    if (state == 1) {
#line 482
      goto case_1;
    }
#line 506
    if (state == 2) {
#line 506
      goto case_2;
    }
#line 525
    if (state == 3) {
#line 525
      goto case_3;
    }
#line 468
    goto switch_break;
    case_0: /* CIL Label */ 
#line 473
    if (x) {
      {
#line 475
      state = 1;
#line 476
      str = crlf;
#line 477
      buffer_reset(& buf);
      }
    }
#line 479
    goto switch_break;
    case_1: /* CIL Label */ 
#line 483
    if (! x) {
      {
#line 485
      buffer_add(& buf, (void const   *)sbuf.segment, sbuf.len);
      }
    }
#line 487
    if (x) {
      {
#line 489
      buffer_add(& buf, (void const   *)sbuf.segment, sbuf.len);
#line 490
      tmp___7 = memcmp((void const   *)buf.data, (void const   *)(boundary + 2), (size_t )2);
      }
#line 490
      if (tmp___7) {
        {
#line 498
        buffer_reset(& buf);
#line 499
        mime_var_init(& var);
#line 500
        state = 2;
#line 501
        str = crlf;
        }
      } else {
#line 493
        str = boundary + 2;
#line 494
        state = 0;
      }
    }
#line 504
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 507
    buffer_add(& buf, (void const   *)sbuf.segment, sbuf.len);
    }
#line 508
    if (x) {
#line 510
      if (sbuf.len == 0UL) {
        {
#line 512
        buffer_reset(& buf);
#line 513
        state = 3;
#line 514
        str = boundary;
        }
      } else {
        {
#line 518
        buffer_add(& buf, (void const   *)"", 1UL);
#line 519
        mime_tag_add(& var, (char *)buf.data);
#line 520
        buffer_reset(& buf);
        }
      }
    }
#line 523
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 527
    mime_var_writer(& var, (char *)sbuf.segment, (int )sbuf.len);
    }
#line 528
    if (x) {
      {
#line 530
      buffer_reset(& buf);
#line 531
      mime_var_putenv(env, & var);
#line 532
      mime_var_destroy(& var);
#line 533
      state = 1;
#line 534
      str = crlf;
      }
    }
#line 537
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 449
    if (! (! sbuf.eof)) {
#line 449
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 543
  free((void *)boundary);
#line 544
  s_buffer_destroy(& sbuf);
#line 545
  buffer_destroy(& buf);
  }
#line 546
  return (0);
}
}
