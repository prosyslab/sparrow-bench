/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 678 "/usr/include/stdio.h"
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/spline-1.2/utils.h"
void *xmalloc(size_t size ) ;
#line 32
void *xrealloc(void *ptr , size_t size ) ;
#line 34
char *gettextline(FILE *stream ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/spline-1.2/utils.c"
void *xmalloc(size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 32
  ptr = malloc(size);
  }
#line 33
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 34
    perror("xmalloc");
#line 34
    exit(1);
    }
  }
#line 37
  return (ptr);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/spline-1.2/utils.c"
void *xrealloc(void *ptr , size_t size ) 
{ 


  {
  {
#line 42
  ptr = realloc(ptr, size);
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 44
    perror("xrealloc");
#line 44
    exit(1);
    }
  }
#line 47
  return (ptr);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/spline-1.2/utils.c"
char *gettextline(FILE *stream ) 
{ 
  char *line ;
  size_t len ;
  ssize_t nread ;

  {
  {
#line 57
  line = (char *)((void *)0);
#line 58
  len = (size_t )0;
#line 61
  nread = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& len),
                  (FILE */* __restrict  */)stream);
  }
#line 62
  if (nread > 0L) {
#line 63
    *(line + (len - 1UL)) = (char )'\000';
  } else
#line 64
  if (nread == -1L) {
#line 65
    line = (char *)((void *)0);
  }
#line 85
  return (line);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 347
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fpclassify)(double __value )  __attribute__((__const__)) ;
#line 347
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fpclassifyf)(float __value )  __attribute__((__const__)) ;
#line 347
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fpclassifyl)(long double __value )  __attribute__((__const__)) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
char const   *progname  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
double *x  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
double *y  ;
#line 40
int warranty(void) ;
#line 41
int usage(void) ;
#line 42
void insertpoint(char const   *inname , double xv , double yv , int *n ) ;
#line 43
void computelimits(int s , int e , double *llimit , double *ulimit ) ;
#line 44
void calcspline(int n , int d , double xstep , double llimit , double ulimit , int calclimit ) ;
#line 46
void readandcalcspline(FILE *infile , char const   *inname , int d , double xstep ,
                       double llimit , double ulimit , int calclimit , int verbose ,
                       int *s ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
static struct option  const  long_options[11]  = 
#line 50
  {      {"auto", 2, (int *)0, 'a'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"help", 0, (int *)0, '?'}, 
        {"llimit", 1, (int *)0, 'l'}, 
        {"ulimit", 1, (int *)0, 'u'}, 
        {"points", 1, (int *)0, 'n'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"license", 0, (int *)0, 'W'}, 
        {"warranty", 0, (int *)0, 'W'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 64 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
int warranty(void) 
{ 


  {
  {
#line 68
  printf((char const   */* __restrict  */)"This program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2 of the License, or (at your\noption) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc.,\n59 Temple Place Suite 330, Boston, MA 02111-1307 USA.\n");
#line 89
  exit(0);
  }
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
int usage(void) 
{ 


  {
  {
#line 95
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-hv][-a [xstep]][-l llimit][-u ulimit][-n points] {data-file(s)}\n\n",
          progname);
#line 98
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -a, --auto      supply abscissas automatically.\n  -l, --llimit    set lower x-limit.\n  -u, --ulimit    set upper x-limit.\n  -n, --points    space output points so that approx. n intervals\n                  occur between the lower and upper limit.\n  -h, --help      display this help and exit.\n  -v, --verbose   be verbose.\n  -V, --version   display version and copyright information and exit.\n  -W, --warranty  display licensing terms.\n");
#line 111
  exit(0);
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
void insertpoint(char const   *inname , double xv , double yv , int *n ) 
{ 
  int k ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 120
  k = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (k < *n) {
#line 121
      if (! (xv > *(x + k))) {
#line 121
        goto while_break;
      }
    } else {
#line 121
      goto while_break;
    }
#line 121
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  if (k == *n) {
#line 126
    if (*n == 0) {
      {
#line 127
      tmp = xmalloc(sizeof(double ));
#line 127
      x = (double *)tmp;
#line 128
      tmp___0 = xmalloc(sizeof(double ));
#line 128
      y = (double *)tmp___0;
      }
    } else {
      {
#line 130
      tmp___1 = xrealloc((void *)x, (unsigned long )(*n + 1) * sizeof(double ));
#line 130
      x = (double *)tmp___1;
#line 131
      tmp___2 = xrealloc((void *)y, (unsigned long )(*n + 1) * sizeof(double ));
#line 131
      y = (double *)tmp___2;
      }
    }
#line 134
    *(x + *n) = xv;
#line 134
    *(y + *n) = yv;
#line 134
    (*n) ++;
  } else {
#line 135
    if (sizeof(xv - *(x + k)) == sizeof(float )) {
      {
#line 135
      tmp___5 = __fpclassifyf((float )(xv - *(x + k)));
#line 135
      tmp___9 = tmp___5;
      }
    } else {
#line 135
      if (sizeof(xv - *(x + k)) == sizeof(double )) {
        {
#line 135
        tmp___6 = __fpclassify(xv - *(x + k));
#line 135
        tmp___8 = tmp___6;
        }
      } else {
        {
#line 135
        tmp___7 = __fpclassifyl((long double )(xv - *(x + k)));
#line 135
        tmp___8 = tmp___7;
        }
      }
#line 135
      tmp___9 = tmp___8;
    }
#line 135
    if (tmp___9 == 2) {
      {
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%s: duplicate abscissas found, sample (%g,%g), dropped.\n",
              progname, inname, xv, yv);
      }
    } else {
      {
#line 140
      tmp___3 = xrealloc((void *)x, (unsigned long )(*n + 1) * sizeof(double ));
#line 140
      x = (double *)tmp___3;
#line 140
      tmp___4 = xrealloc((void *)y, (unsigned long )(*n + 1) * sizeof(double ));
#line 140
      y = (double *)tmp___4;
#line 143
      memmove((void *)(x + (k + 1)), (void const   *)(x + k), (unsigned long )(*n - k) * sizeof(double ));
#line 144
      memmove((void *)(y + (k + 1)), (void const   *)(y + k), (unsigned long )(*n - k) * sizeof(double ));
#line 146
      *(x + k) = xv;
#line 146
      *(y + k) = yv;
#line 146
      (*n) ++;
      }
    }
  }
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
void computelimits(int s , int e , double *llimit , double *ulimit ) 
{ 
  int i ;

  {
#line 155
  *llimit = (double )3.40282346638528859812e+38F;
#line 155
  *ulimit = (double )(- 3.40282346638528859812e+38F);
#line 156
  i = s;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < e)) {
#line 156
      goto while_break;
    }
#line 157
    if (*(x + i) < *llimit) {
#line 157
      *llimit = *(x + i);
    }
#line 158
    if (*(x + i) > *ulimit) {
#line 158
      *ulimit = *(x + i);
    }
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
void calcspline(int n , int d , double xstep , double llimit , double ulimit , int calclimit ) 
{ 
  double dx ;
  double dy ;
  double m ;
  int i ;
  int i___0 ;
  int p ;
  double *dx___0 ;
  double *dy___0 ;
  double *m___0 ;
  double *t ;
  double *C ;
  double *D ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  double num ;
  double den ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  double xv ;
  double xd ;

  {
#line 166
  if (n > 0) {
#line 167
    if (n == 1) {
      {
#line 168
      printf((char const   */* __restrict  */)"%g %g\n", *(x + 0), *(y + 0));
      }
    } else
#line 169
    if (n == 2) {
#line 173
      dx = *(x + 1) - *(x + 0);
#line 173
      dy = *(y + 1) - *(y + 0);
#line 178
      if (calclimit) {
        {
#line 178
        computelimits(0, n, & llimit, & ulimit);
        }
      }
#line 179
      xstep = (ulimit - llimit) / (double )d;
#line 181
      m = dy / dx;
#line 182
      i = 0;
      {
#line 182
      while (1) {
        while_continue: /* CIL Label */ ;
#line 182
        if (! (i <= d)) {
#line 182
          goto while_break;
        }
        {
#line 183
        printf((char const   */* __restrict  */)"%g %g\n", *(x + 0) + (double )i * xstep,
               *(y + 0) + ((double )i * m) * xstep);
#line 182
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 193
      tmp = xrealloc((void *)x, (unsigned long )(n + 4) * sizeof(double ));
#line 193
      x = (double *)tmp;
#line 194
      tmp___0 = xrealloc((void *)y, (unsigned long )(n + 4) * sizeof(double ));
#line 194
      y = (double *)tmp___0;
#line 197
      memmove((void *)(x + 2), (void const   *)(x + 0), (unsigned long )n * sizeof(double ));
#line 198
      memmove((void *)(y + 2), (void const   *)(y + 0), (unsigned long )n * sizeof(double ));
#line 199
      n += 4;
#line 208
      tmp___1 = xmalloc((unsigned long )n * sizeof(double ));
#line 208
      dx___0 = (double *)tmp___1;
#line 209
      tmp___2 = xmalloc((unsigned long )n * sizeof(double ));
#line 209
      dy___0 = (double *)tmp___2;
#line 210
      tmp___3 = xmalloc((unsigned long )n * sizeof(double ));
#line 210
      m___0 = (double *)tmp___3;
#line 211
      tmp___4 = xmalloc((unsigned long )n * sizeof(double ));
#line 211
      t = (double *)tmp___4;
#line 215
      i___0 = 2;
      }
      {
#line 215
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 215
        if (! (i___0 < n - 3)) {
#line 215
          goto while_break___0;
        }
#line 216
        *(dx___0 + i___0) = *(x + (i___0 + 1)) - *(x + i___0);
#line 216
        *(dy___0 + i___0) = *(y + (i___0 + 1)) - *(y + i___0);
#line 217
        *(m___0 + i___0) = *(dy___0 + i___0) / *(dx___0 + i___0);
#line 215
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 222
      *(x + 1) = (*(x + 2) + *(x + 3)) - *(x + 4);
#line 222
      *(dx___0 + 1) = *(x + 2) - *(x + 1);
#line 223
      *(y + 1) = *(dx___0 + 1) * (*(m___0 + 3) - (double )2 * *(m___0 + 2)) + *(y + 2);
#line 223
      *(dy___0 + 1) = *(y + 2) - *(y + 1);
#line 224
      *(m___0 + 1) = *(dy___0 + 1) / *(dx___0 + 1);
#line 226
      *(x + 0) = (double )2 * *(x + 2) - *(x + 4);
#line 226
      *(dx___0 + 0) = *(x + 1) - *(x + 0);
#line 227
      *(y + 0) = *(dx___0 + 0) * (*(m___0 + 2) - (double )2 * *(m___0 + 1)) + *(y + 1);
#line 227
      *(dy___0 + 0) = *(y + 1) - *(y + 0);
#line 228
      *(m___0 + 0) = *(dy___0 + 0) / *(dx___0 + 0);
#line 230
      *(x + (n - 2)) = (*(x + (n - 3)) + *(x + (n - 4))) - *(x + (n - 5));
#line 231
      *(y + (n - 2)) = ((double )2 * *(m___0 + (n - 4)) - *(m___0 + (n - 5))) * (*(x + (n - 2)) - *(x + ((long )n - 3L))) + *(y + (n - 3));
#line 233
      *(x + (n - 1)) = (double )2 * *(x + (n - 3)) - *(x + (n - 5));
#line 234
      *(y + (n - 1)) = ((double )2 * *(m___0 + (n - 3)) - *(m___0 + (n - 4))) * (*(x + (n - 1)) - *(x + (n - 2))) + *(y + (n - 2));
#line 236
      i___0 = n - 3;
      {
#line 236
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 236
        if (! (i___0 < n - 1)) {
#line 236
          goto while_break___1;
        }
#line 237
        *(dx___0 + i___0) = *(x + (i___0 + 1)) - *(x + i___0);
#line 237
        *(dy___0 + i___0) = *(y + (i___0 + 1)) - *(y + i___0);
#line 238
        *(m___0 + i___0) = *(dy___0 + i___0) / *(dx___0 + i___0);
#line 236
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 243
      *(t + 0) = 0.0;
#line 243
      *(t + 1) = 0.0;
#line 244
      i___0 = 2;
      {
#line 244
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 244
        if (! (i___0 < n - 2)) {
#line 244
          goto while_break___2;
        }
        {
#line 247
        tmp___5 = fabs(*(m___0 + (i___0 + 1)) - *(m___0 + i___0));
#line 247
        tmp___6 = fabs(*(m___0 + (i___0 - 1)) - *(m___0 + (i___0 - 2)));
#line 247
        num = tmp___5 * *(m___0 + (i___0 - 1)) + tmp___6 * *(m___0 + i___0);
#line 248
        tmp___7 = fabs(*(m___0 + (i___0 + 1)) - *(m___0 + i___0));
#line 248
        tmp___8 = fabs(*(m___0 + (i___0 - 1)) - *(m___0 + (i___0 - 2)));
#line 248
        den = tmp___7 + tmp___8;
        }
#line 250
        if (sizeof(den) == sizeof(float )) {
          {
#line 250
          tmp___9 = __fpclassifyf((float )den);
#line 250
          tmp___13 = tmp___9;
          }
        } else {
#line 250
          if (sizeof(den) == sizeof(double )) {
            {
#line 250
            tmp___10 = __fpclassify(den);
#line 250
            tmp___12 = tmp___10;
            }
          } else {
            {
#line 250
            tmp___11 = __fpclassifyl((long double )den);
#line 250
            tmp___12 = tmp___11;
            }
          }
#line 250
          tmp___13 = tmp___12;
        }
#line 250
        if (tmp___13 != 2) {
#line 250
          *(t + i___0) = num / den;
        } else {
#line 251
          *(t + i___0) = 0.0;
        }
#line 244
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 258
      tmp___14 = xmalloc((unsigned long )n * sizeof(double ));
#line 258
      C = (double *)tmp___14;
#line 259
      tmp___15 = xmalloc((unsigned long )n * sizeof(double ));
#line 259
      D = (double *)tmp___15;
#line 261
      i___0 = 2;
      }
      {
#line 261
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 261
        if (! (i___0 < n - 2)) {
#line 261
          goto while_break___3;
        }
#line 264
        *(C + i___0) = (((double )3 * *(m___0 + i___0) - (double )2 * *(t + i___0)) - *(t + (i___0 + 1))) / *(dx___0 + i___0);
#line 265
        *(D + i___0) = ((*(t + i___0) + *(t + (i___0 + 1))) - (double )2 * *(m___0 + i___0)) / (*(dx___0 + i___0) * *(dx___0 + i___0));
#line 261
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 271
      if (calclimit) {
        {
#line 271
        computelimits(2, n - 2, & llimit, & ulimit);
        }
      }
#line 272
      xstep = (ulimit - llimit) / (double )d;
#line 274
      p = 2;
#line 276
      xv = llimit;
      {
#line 276
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 276
        if (! (xv < ulimit + xstep)) {
#line 276
          goto while_break___4;
        }
        {
#line 277
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 277
          if (! (xv >= *(x + p))) {
#line 277
            goto while_break___5;
          }
          {
#line 278
          printf((char const   */* __restrict  */)"%g %g\n", *(x + p), *(y + p));
#line 278
          p ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 284
        if (xv - *(x + (p - 1)) > xstep / 100.0) {
#line 284
          if (*(x + p) - xv > xstep / 100.0) {
            {
#line 286
            xd = xv - *(x + (p - 1));
#line 287
            printf((char const   */* __restrict  */)"%g %g\n", xv, *(y + (p - 1)) + (*(t + (p - 1)) + (*(C + (p - 1)) + *(D + (p - 1)) * xd) * xd) * xd);
            }
          }
        }
#line 276
        xv += xstep;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 292
      free((void *)dx___0);
#line 292
      free((void *)dy___0);
#line 292
      free((void *)m___0);
#line 292
      free((void *)t);
#line 292
      free((void *)C);
#line 292
      free((void *)D);
      }
    }
  }
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
void readandcalcspline(FILE *infile , char const   *inname , int d , double xstep ,
                       double llimit , double ulimit , int calclimit , int verbose ,
                       int *s ) 
{ 
  int n ;
  int l ;
  char *line ;
  int *tmp ;
  char *tmp___0 ;
  char *il ;
  unsigned short const   **tmp___1 ;
  int k ;
  double f1 ;
  double f2 ;

  {
#line 305
  if ((unsigned long )infile != (unsigned long )stdin) {
    {
#line 306
    infile = fopen((char const   */* __restrict  */)inname, (char const   */* __restrict  */)"r");
    }
#line 307
    if ((unsigned long )infile == (unsigned long )((void *)0)) {
      {
#line 308
      tmp = __errno_location();
#line 308
      tmp___0 = strerror(*tmp);
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t open \"%s\": %s.\n",
              progname, inname, tmp___0);
      }
#line 311
      return;
    }
  }
#line 315
  if (verbose) {
    {
#line 315
    printf((char const   */* __restrict  */)"# %s\n", inname);
    }
  }
#line 320
  n = 0;
#line 320
  l = 0;
#line 320
  x = (double *)((void *)0);
#line 320
  y = (double *)((void *)0);
#line 320
  line = (char *)((void *)0);
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if ((unsigned long )line != (unsigned long )((void *)0)) {
      {
#line 325
      free((void *)line);
      }
    }
    {
#line 327
    line = gettextline(infile);
#line 329
    il = line;
#line 329
    l ++;
    }
#line 330
    if ((unsigned long )il != (unsigned long )((void *)0)) {
      {
#line 331
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 331
        tmp___1 = __ctype_b_loc();
        }
#line 331
        if (! ((int const   )*(*tmp___1 + (int )*il) & 8192)) {
#line 331
          goto while_break___0;
        }
#line 331
        il ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 333
    if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 333
      goto _L;
    } else
#line 333
    if ((int )*(il + 0) == 0) {
      _L: /* CIL Label */ 
#line 334
      if (n > 0) {
#line 335
        if (*s > 0) {
          {
#line 335
          printf((char const   */* __restrict  */)"\n");
          }
        }
        {
#line 336
        calcspline(n, d, xstep, llimit, ulimit, calclimit);
#line 336
        (*s) ++;
#line 337
        free((void *)x);
#line 337
        free((void *)y);
#line 337
        y = (double *)((void *)0);
#line 337
        x = y;
#line 337
        n = 0;
        }
      }
    } else
#line 339
    if ((int )*(il + 0) != 35) {
      {
#line 344
      k = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%lf %lf",
                 & f1, & f2);
      }
#line 346
      if (k < 1) {
        {
#line 347
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%s:%d: parse error at \'%s\'\n",
                progname, inname, l, line);
        }
      } else
#line 349
      if (k == 1) {
        {
#line 350
        insertpoint(inname, llimit + (double )n * xstep, f1, & n);
        }
      } else {
        {
#line 352
        insertpoint(inname, f1, f2, & n);
        }
      }
    }
#line 321
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 321
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  if ((unsigned long )infile != (unsigned long )stdin) {
    {
#line 357
    fclose(infile);
    }
  }
#line 358
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/spline-1.2/aspline.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int i ;
  int d ;
  double xstep ;
  double llimit ;
  double ulimit ;
  int calclimit ;
  int verbose ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double temp ;
  int s ;
  int s___0 ;

  {
  {
#line 367
  tmp = strrchr((char const   *)*(argv + 0), '/');
#line 367
  progname = (char const   *)tmp;
  }
#line 368
  if ((unsigned long )progname == (unsigned long )((void *)0)) {
#line 368
    progname = (char const   *)*(argv + 0);
  } else {
#line 369
    progname ++;
  }
#line 376
  verbose = 0;
#line 376
  calclimit = 1;
#line 376
  xstep = 1.0;
#line 376
  ulimit = 0.0;
#line 376
  llimit = ulimit;
#line 376
  d = 100;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 377
    c = getopt_long(argc, (char * const  *)argv, "a:?hl:n:u:vVW", long_options, (int *)0);
    }
#line 377
    if (! (c != -1)) {
#line 377
      goto while_break;
    }
    {
#line 380
    if (c == 0) {
#line 380
      goto case_0;
    }
#line 381
    if (c == 97) {
#line 381
      goto case_97;
    }
#line 384
    if (c == 108) {
#line 384
      goto case_108;
    }
#line 386
    if (c == 63) {
#line 386
      goto case_63;
    }
#line 386
    if (c == 104) {
#line 386
      goto case_63;
    }
#line 387
    if (c == 110) {
#line 387
      goto case_110;
    }
#line 388
    if (c == 117) {
#line 388
      goto case_117;
    }
#line 389
    if (c == 118) {
#line 389
      goto case_118;
    }
#line 390
    if (c == 86) {
#line 390
      goto case_86;
    }
#line 398
    if (c == 87) {
#line 398
      goto case_87;
    }
#line 399
    goto switch_default;
    case_0: /* CIL Label */ 
#line 380
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 381
    xstep = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0));
    }
#line 382
    if (sizeof(xstep) == sizeof(float )) {
      {
#line 382
      tmp___0 = __fpclassifyf((float )xstep);
#line 382
      tmp___4 = tmp___0;
      }
    } else {
#line 382
      if (sizeof(xstep) == sizeof(double )) {
        {
#line 382
        tmp___1 = __fpclassify(xstep);
#line 382
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 382
        tmp___2 = __fpclassifyl((long double )xstep);
#line 382
        tmp___3 = tmp___2;
        }
      }
#line 382
      tmp___4 = tmp___3;
    }
#line 382
    if (tmp___4 == 2) {
#line 382
      xstep = 1.0;
    }
#line 383
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 384
    llimit = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0));
#line 384
    calclimit = 0;
    }
#line 384
    goto switch_break;
    case_63: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
#line 386
    usage();
    }
#line 386
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 387
    d = atoi((char const   *)optarg);
    }
#line 387
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 388
    ulimit = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0));
#line 388
    calclimit = 0;
    }
#line 388
    goto switch_break;
    case_118: /* CIL Label */ 
#line 389
    verbose ++;
#line 389
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s version %s\nAkima spline interpolation (c) 1996-1998 David Frey.\nThis is free software; see the GNU General Public Licence version 2 or later\nfor copying conditions.\nThere is NO warranty.  See %s --licence for details.\n",
            progname, "1.2", progname);
    }
#line 397
    return (0);
#line 397
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 398
    warranty();
    }
#line 398
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 399
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  if (ulimit < llimit) {
#line 406
    temp = ulimit;
#line 406
    ulimit = llimit;
#line 406
    llimit = temp;
  }
#line 409
  if (argc > optind) {
#line 412
    s = 0;
#line 413
    i = optind;
    {
#line 413
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 413
      if (! (i < argc)) {
#line 413
        goto while_break___0;
      }
      {
#line 414
      readandcalcspline((FILE *)((void *)0), (char const   *)*(argv + i), d, xstep,
                        llimit, ulimit, calclimit, verbose, & s);
      }
#line 418
      if (s > 0) {
#line 418
        if (i < argc - 1) {
          {
#line 418
          printf((char const   */* __restrict  */)"\n");
          }
        }
      }
#line 419
      s ++;
#line 413
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 424
    s___0 = 0;
#line 425
    readandcalcspline(stdin, "stdin", d, xstep, llimit, ulimit, calclimit, verbose,
                      & s___0);
    }
  }
#line 429
  return (0);
}
}
