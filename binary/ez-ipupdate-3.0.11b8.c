/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.h"
typedef unsigned int md5_uint32;
#line 82 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.h"
struct md5_ctx {
   md5_uint32 A ;
   md5_uint32 B ;
   md5_uint32 C ;
   md5_uint32 D ;
   md5_uint32 total[2] ;
   md5_uint32 buflen ;
   char buffer[128] ;
};
#line 36 "./conf_file.h"
struct conf_cmd {
   int id ;
   char *name ;
   int arg_type ;
   int available ;
   int (*proc)(struct conf_cmd * , char * ) ;
   char *help ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_62 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_63 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_62 ifr_ifrn ;
   union __anonunion_ifr_ifru_63 ifr_ifru ;
};
#line 222 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
struct service_t {
   char *title ;
   char *names[3] ;
   void (*init)(void) ;
   int (*update_entry)(void) ;
   int (*check_info)(void) ;
   char **fields_used ;
   char *default_server ;
   char *default_port ;
   char *default_request ;
};
#line 4336 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 4553
struct tm;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/pid_file.c"
int pid_file_create(char *pid_file___0 ) 
{ 
  char buf___0[64] ;
  FILE *fp ;
  pid_t mypid ;
  pid_t otherpid ;
  gid_t oldegid ;
  uid_t oldeuid ;
  __gid_t tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 24
  fp = (FILE *)((void *)0);
#line 26
  otherpid = -1;
#line 29
  oldegid = (gid_t )-1;
#line 30
  oldeuid = (uid_t )-1;
#line 34
  oldegid = getegid();
#line 35
  oldeuid = geteuid();
#line 37
  tmp = getgid();
#line 37
  setegid(tmp);
#line 38
  tmp___0 = getuid();
#line 38
  seteuid(tmp___0);
#line 42
  fp = fopen((char const   */* __restrict  */)pid_file___0, (char const   */* __restrict  */)"r");
  }
#line 42
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 45
    tmp___3 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 45
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      {
#line 47
      tmp___1 = __errno_location();
#line 47
      tmp___2 = strerror(*tmp___1);
#line 47
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading pid file: %s (%s)\n",
              pid_file___0, tmp___2);
      }
#line 48
      goto ERR;
    }
    {
#line 50
    fclose(fp);
#line 51
    otherpid = atoi((char const   *)(buf___0));
#line 54
    tmp___4 = kill(otherpid, 0);
    }
#line 54
    if (tmp___4 == 0) {
      {
#line 57
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"there is another program already running with pid %d.\n",
              otherpid);
      }
#line 58
      goto ERR;
    }
  }
  {
#line 63
  fp = fopen((char const   */* __restrict  */)pid_file___0, (char const   */* __restrict  */)"w");
  }
#line 63
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 65
    tmp___5 = __errno_location();
#line 65
    tmp___6 = strerror(*tmp___5);
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not create pid file: %s (%s)\n",
            pid_file___0, tmp___6);
    }
#line 66
    goto ERR;
  }
  {
#line 69
  mypid = getpid();
#line 70
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d\n", mypid);
#line 71
  fclose(fp);
#line 77
  setegid(oldegid);
#line 78
  seteuid(oldeuid);
  }
#line 81
  return (0);
  ERR: 
#line 84
  if (fp) {
    {
#line 84
    fclose(fp);
#line 84
    fp = (FILE *)((void *)0);
    }
  }
  {
#line 86
  setegid(oldegid);
#line 87
  seteuid(oldeuid);
  }
#line 89
  return (-1);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/pid_file.c"
int pid_file_delete(char *pid_file___0 ) 
{ 
  int ret ;
  gid_t oldegid ;
  uid_t oldeuid ;
  __gid_t tmp ;
  __uid_t tmp___0 ;

  {
  {
#line 101
  oldegid = (gid_t )-1;
#line 102
  oldeuid = (uid_t )-1;
#line 106
  oldegid = getegid();
#line 107
  oldeuid = geteuid();
#line 109
  tmp = getgid();
#line 109
  setegid(tmp);
#line 110
  tmp___0 = getuid();
#line 110
  seteuid(tmp___0);
#line 113
  ret = unlink((char const   *)pid_file___0);
#line 116
  setegid(oldegid);
#line 117
  seteuid(oldeuid);
  }
#line 120
  return (ret);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.h"
void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 107
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 114
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 124
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 133
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 139
int md5_stream(FILE *stream , void *resblock ) ;
#line 145
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 60 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ 
  md5_uint32 tmp ;

  {
#line 63
  ctx->A = (md5_uint32 )1732584193;
#line 64
  ctx->B = 4023233417U;
#line 65
  ctx->C = 2562383102U;
#line 66
  ctx->D = (md5_uint32 )271733878;
#line 68
  tmp = (md5_uint32 )0;
#line 68
  ctx->total[1] = tmp;
#line 68
  ctx->total[0] = tmp;
#line 69
  ctx->buflen = (md5_uint32 )0;
#line 70
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 


  {
#line 80
  *((md5_uint32 *)resbuf + 0) = (md5_uint32 )ctx->A;
#line 81
  *((md5_uint32 *)resbuf + 1) = (md5_uint32 )ctx->B;
#line 82
  *((md5_uint32 *)resbuf + 2) = (md5_uint32 )ctx->C;
#line 83
  *((md5_uint32 *)resbuf + 3) = (md5_uint32 )ctx->D;
#line 85
  return (resbuf);
}
}
#line 106
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ 
  md5_uint32 bytes ;
  size_t pad ;
  void *tmp ;

  {
#line 97
  bytes = ctx->buflen;
#line 101
  ctx->total[0] += bytes;
#line 102
  if (ctx->total[0] < bytes) {
#line 103
    (ctx->total[1]) ++;
  }
#line 105
  if (bytes >= 56U) {
#line 105
    pad = (size_t )(120U - bytes);
  } else {
#line 105
    pad = (size_t )(56U - bytes);
  }
  {
#line 106
  memcpy(& ctx->buffer[bytes], fillbuf, pad);
#line 109
  *((md5_uint32 *)(& ctx->buffer[(size_t )bytes + pad])) = ctx->total[0] << 3;
#line 110
  *((md5_uint32 *)(& ctx->buffer[((size_t )bytes + pad) + 4UL])) = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 114
  md5_process_block((void const   *)(ctx->buffer), ((size_t )bytes + pad) + 8UL, ctx);
#line 116
  tmp = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  }
#line 116
  return (tmp);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.c"
int md5_stream(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;

  {
  {
#line 132
  md5_init_ctx(& ctx);
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    sum = (size_t )0;
    {
#line 144
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 146
      n = fread((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                (FILE */* __restrict  */)stream);
#line 148
      sum += n;
      }
#line 144
      if (sum < 4096UL) {
#line 144
        if (! (n != 0UL)) {
#line 144
          goto while_break___0;
        }
      } else {
#line 144
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 151
    if (n == 0UL) {
      {
#line 151
      tmp = ferror(stream);
      }
#line 151
      if (tmp) {
#line 152
        return (1);
      }
    }
#line 155
    if (n == 0UL) {
#line 156
      goto while_break;
    }
    {
#line 161
    md5_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (sum > 0UL) {
    {
#line 166
    md5_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 169
  md5_finish_ctx(& ctx, resblock);
  }
#line 170
  return (0);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.c"
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp ;

  {
  {
#line 183
  md5_init_ctx(& ctx);
#line 186
  md5_process_bytes((void const   *)buffer, len, & ctx);
#line 189
  tmp = md5_finish_ctx(& ctx, resblock);
  }
#line 189
  return (tmp);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.c"
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;

  {
#line 198
  if (ctx->buflen != 0U) {
#line 200
    left_over = (size_t )ctx->buflen;
#line 201
    if (128UL - left_over > len) {
#line 201
      tmp = len;
    } else {
#line 201
      tmp = 128UL - left_over;
    }
    {
#line 201
    add = tmp;
#line 203
    memcpy(& ctx->buffer[left_over], buffer, add);
#line 204
    ctx->buflen = (md5_uint32 )((size_t )ctx->buflen + add);
    }
#line 206
    if (left_over + add > 64UL) {
      {
#line 208
      md5_process_block((void const   *)(ctx->buffer), (left_over + add) & 0xffffffffffffffc0UL,
                        ctx);
#line 210
      memcpy(ctx->buffer, & ctx->buffer[(left_over + add) & 0xffffffffffffffc0UL],
             (left_over + add) & 63UL);
#line 212
      ctx->buflen = (md5_uint32 )((left_over + add) & 63UL);
      }
    }
#line 215
    buffer = (void const   *)((char const   *)buffer + add);
#line 216
    len -= add;
  }
#line 220
  if (len > 64UL) {
    {
#line 222
    md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 223
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 224
    len &= 63UL;
    }
  }
#line 228
  if (len > 0UL) {
    {
#line 230
    memcpy(ctx->buffer, buffer, len);
#line 231
    ctx->buflen = (md5_uint32 )len;
    }
  }
#line 233
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/md5.c"
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  md5_uint32 correct_words[16] ;
  md5_uint32 const   *words ;
  size_t nwords ;
  md5_uint32 const   *endp ;
  md5_uint32 A ;
  md5_uint32 B ;
  md5_uint32 C ;
  md5_uint32 D ;
  md5_uint32 *cwp ;
  md5_uint32 A_save ;
  md5_uint32 B_save ;
  md5_uint32 C_save ;
  md5_uint32 D_save ;
  md5_uint32 *tmp ;
  md5_uint32 tmp___0 ;
  md5_uint32 *tmp___1 ;
  md5_uint32 tmp___2 ;
  md5_uint32 *tmp___3 ;
  md5_uint32 tmp___4 ;
  md5_uint32 *tmp___5 ;
  md5_uint32 tmp___6 ;
  md5_uint32 *tmp___7 ;
  md5_uint32 tmp___8 ;
  md5_uint32 *tmp___9 ;
  md5_uint32 tmp___10 ;
  md5_uint32 *tmp___11 ;
  md5_uint32 tmp___12 ;
  md5_uint32 *tmp___13 ;
  md5_uint32 tmp___14 ;
  md5_uint32 *tmp___15 ;
  md5_uint32 tmp___16 ;
  md5_uint32 *tmp___17 ;
  md5_uint32 tmp___18 ;
  md5_uint32 *tmp___19 ;
  md5_uint32 tmp___20 ;
  md5_uint32 *tmp___21 ;
  md5_uint32 tmp___22 ;
  md5_uint32 *tmp___23 ;
  md5_uint32 tmp___24 ;
  md5_uint32 *tmp___25 ;
  md5_uint32 tmp___26 ;
  md5_uint32 *tmp___27 ;
  md5_uint32 tmp___28 ;
  md5_uint32 *tmp___29 ;
  md5_uint32 tmp___30 ;

  {
#line 252
  words = (md5_uint32 const   *)buffer;
#line 253
  nwords = len / sizeof(md5_uint32 );
#line 254
  endp = words + nwords;
#line 255
  A = ctx->A;
#line 256
  B = ctx->B;
#line 257
  C = ctx->C;
#line 258
  D = ctx->D;
#line 263
  ctx->total[0] = (md5_uint32 )((size_t )ctx->total[0] + len);
#line 264
  if ((size_t )ctx->total[0] < len) {
#line 265
    (ctx->total[1]) ++;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 269
      goto while_break;
    }
#line 271
    cwp = correct_words;
#line 272
    A_save = A;
#line 273
    B_save = B;
#line 274
    C_save = C;
#line 275
    D_save = D;
    {
#line 305
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 305
      tmp = cwp;
#line 305
      cwp ++;
#line 305
      tmp___0 = (md5_uint32 )*words;
#line 305
      *tmp = tmp___0;
#line 305
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
#line 305
      words ++;
#line 305
      A = (A << 7) | (A >> 25);
#line 305
      A += B;
#line 305
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 306
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 306
      tmp___1 = cwp;
#line 306
      cwp ++;
#line 306
      tmp___2 = (md5_uint32 )*words;
#line 306
      *tmp___1 = tmp___2;
#line 306
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
#line 306
      words ++;
#line 306
      D = (D << 12) | (D >> 20);
#line 306
      D += A;
#line 306
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 307
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 307
      tmp___3 = cwp;
#line 307
      cwp ++;
#line 307
      tmp___4 = (md5_uint32 )*words;
#line 307
      *tmp___3 = tmp___4;
#line 307
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
#line 307
      words ++;
#line 307
      C = (C << 17) | (C >> 15);
#line 307
      C += D;
#line 307
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 308
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 308
      tmp___5 = cwp;
#line 308
      cwp ++;
#line 308
      tmp___6 = (md5_uint32 )*words;
#line 308
      *tmp___5 = tmp___6;
#line 308
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
#line 308
      words ++;
#line 308
      B = (B << 22) | (B >> 10);
#line 308
      B += C;
#line 308
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 309
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 309
      tmp___7 = cwp;
#line 309
      cwp ++;
#line 309
      tmp___8 = (md5_uint32 )*words;
#line 309
      *tmp___7 = tmp___8;
#line 309
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
#line 309
      words ++;
#line 309
      A = (A << 7) | (A >> 25);
#line 309
      A += B;
#line 309
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 310
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 310
      tmp___9 = cwp;
#line 310
      cwp ++;
#line 310
      tmp___10 = (md5_uint32 )*words;
#line 310
      *tmp___9 = tmp___10;
#line 310
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
#line 310
      words ++;
#line 310
      D = (D << 12) | (D >> 20);
#line 310
      D += A;
#line 310
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 311
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 311
      tmp___11 = cwp;
#line 311
      cwp ++;
#line 311
      tmp___12 = (md5_uint32 )*words;
#line 311
      *tmp___11 = tmp___12;
#line 311
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
#line 311
      words ++;
#line 311
      C = (C << 17) | (C >> 15);
#line 311
      C += D;
#line 311
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 312
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 312
      tmp___13 = cwp;
#line 312
      cwp ++;
#line 312
      tmp___14 = (md5_uint32 )*words;
#line 312
      *tmp___13 = tmp___14;
#line 312
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
#line 312
      words ++;
#line 312
      B = (B << 22) | (B >> 10);
#line 312
      B += C;
#line 312
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 313
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 313
      tmp___15 = cwp;
#line 313
      cwp ++;
#line 313
      tmp___16 = (md5_uint32 )*words;
#line 313
      *tmp___15 = tmp___16;
#line 313
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
#line 313
      words ++;
#line 313
      A = (A << 7) | (A >> 25);
#line 313
      A += B;
#line 313
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 314
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 314
      tmp___17 = cwp;
#line 314
      cwp ++;
#line 314
      tmp___18 = (md5_uint32 )*words;
#line 314
      *tmp___17 = tmp___18;
#line 314
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
#line 314
      words ++;
#line 314
      D = (D << 12) | (D >> 20);
#line 314
      D += A;
#line 314
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 315
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 315
      tmp___19 = cwp;
#line 315
      cwp ++;
#line 315
      tmp___20 = (md5_uint32 )*words;
#line 315
      *tmp___19 = tmp___20;
#line 315
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
#line 315
      words ++;
#line 315
      C = (C << 17) | (C >> 15);
#line 315
      C += D;
#line 315
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 316
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 316
      tmp___21 = cwp;
#line 316
      cwp ++;
#line 316
      tmp___22 = (md5_uint32 )*words;
#line 316
      *tmp___21 = tmp___22;
#line 316
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
#line 316
      words ++;
#line 316
      B = (B << 22) | (B >> 10);
#line 316
      B += C;
#line 316
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 317
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 317
      tmp___23 = cwp;
#line 317
      cwp ++;
#line 317
      tmp___24 = (md5_uint32 )*words;
#line 317
      *tmp___23 = tmp___24;
#line 317
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
#line 317
      words ++;
#line 317
      A = (A << 7) | (A >> 25);
#line 317
      A += B;
#line 317
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 318
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 318
      tmp___25 = cwp;
#line 318
      cwp ++;
#line 318
      tmp___26 = (md5_uint32 )*words;
#line 318
      *tmp___25 = tmp___26;
#line 318
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
#line 318
      words ++;
#line 318
      D = (D << 12) | (D >> 20);
#line 318
      D += A;
#line 318
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 319
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 319
      tmp___27 = cwp;
#line 319
      cwp ++;
#line 319
      tmp___28 = (md5_uint32 )*words;
#line 319
      *tmp___27 = tmp___28;
#line 319
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
#line 319
      words ++;
#line 319
      C = (C << 17) | (C >> 15);
#line 319
      C += D;
#line 319
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 320
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 320
      tmp___29 = cwp;
#line 320
      cwp ++;
#line 320
      tmp___30 = (md5_uint32 )*words;
#line 320
      *tmp___29 = tmp___30;
#line 320
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
#line 320
      words ++;
#line 320
      B = (B << 22) | (B >> 10);
#line 320
      B += C;
#line 320
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 336
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 336
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 336
      A = (A << 5) | (A >> 27);
#line 336
      A += B;
#line 336
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 337
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 337
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 337
      D = (D << 9) | (D >> 23);
#line 337
      D += A;
#line 337
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 338
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 338
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 338
      C = (C << 14) | (C >> 18);
#line 338
      C += D;
#line 338
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 339
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 339
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 339
      B = (B << 20) | (B >> 12);
#line 339
      B += C;
#line 339
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 340
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 340
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 340
      A = (A << 5) | (A >> 27);
#line 340
      A += B;
#line 340
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 341
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 341
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 341
      D = (D << 9) | (D >> 23);
#line 341
      D += A;
#line 341
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 342
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 342
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 342
      C = (C << 14) | (C >> 18);
#line 342
      C += D;
#line 342
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 343
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 343
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 343
      B = (B << 20) | (B >> 12);
#line 343
      B += C;
#line 343
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 344
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 344
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 344
      A = (A << 5) | (A >> 27);
#line 344
      A += B;
#line 344
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 345
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 345
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 345
      D = (D << 9) | (D >> 23);
#line 345
      D += A;
#line 345
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 346
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 346
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 346
      C = (C << 14) | (C >> 18);
#line 346
      C += D;
#line 346
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 347
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 347
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 347
      B = (B << 20) | (B >> 12);
#line 347
      B += C;
#line 347
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 348
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 348
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 348
      A = (A << 5) | (A >> 27);
#line 348
      A += B;
#line 348
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 349
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 349
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 349
      D = (D << 9) | (D >> 23);
#line 349
      D += A;
#line 349
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 350
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 350
      C = (C << 14) | (C >> 18);
#line 350
      C += D;
#line 350
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 351
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 351
      B = (B << 20) | (B >> 12);
#line 351
      B += C;
#line 351
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 354
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 354
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 354
      A = (A << 4) | (A >> 28);
#line 354
      A += B;
#line 354
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 355
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 355
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 355
      D = (D << 11) | (D >> 21);
#line 355
      D += A;
#line 355
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 356
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 356
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 356
      C = (C << 16) | (C >> 16);
#line 356
      C += D;
#line 356
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 357
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 357
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 357
      B = (B << 23) | (B >> 9);
#line 357
      B += C;
#line 357
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 358
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 358
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 358
      A = (A << 4) | (A >> 28);
#line 358
      A += B;
#line 358
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 359
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 359
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 359
      D = (D << 11) | (D >> 21);
#line 359
      D += A;
#line 359
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 360
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 360
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 360
      C = (C << 16) | (C >> 16);
#line 360
      C += D;
#line 360
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 361
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 361
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 361
      B = (B << 23) | (B >> 9);
#line 361
      B += C;
#line 361
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 362
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 362
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 362
      A = (A << 4) | (A >> 28);
#line 362
      A += B;
#line 362
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 363
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 363
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 363
      D = (D << 11) | (D >> 21);
#line 363
      D += A;
#line 363
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 364
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 364
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 364
      C = (C << 16) | (C >> 16);
#line 364
      C += D;
#line 364
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 365
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 365
      B = (B << 23) | (B >> 9);
#line 365
      B += C;
#line 365
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 366
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 366
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 366
      A = (A << 4) | (A >> 28);
#line 366
      A += B;
#line 366
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 367
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 367
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 367
      D = (D << 11) | (D >> 21);
#line 367
      D += A;
#line 367
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 368
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 368
      C = (C << 16) | (C >> 16);
#line 368
      C += D;
#line 368
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 369
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 369
      B = (B << 23) | (B >> 9);
#line 369
      B += C;
#line 369
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 372
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 372
      A = (A << 6) | (A >> 26);
#line 372
      A += B;
#line 372
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 373
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 373
      D = (D << 10) | (D >> 22);
#line 373
      D += A;
#line 373
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 374
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 374
      C = (C << 15) | (C >> 17);
#line 374
      C += D;
#line 374
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 375
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 375
      B = (B << 21) | (B >> 11);
#line 375
      B += C;
#line 375
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 376
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 376
      A = (A << 6) | (A >> 26);
#line 376
      A += B;
#line 376
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 377
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 377
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 377
      D = (D << 10) | (D >> 22);
#line 377
      D += A;
#line 377
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 378
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 378
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 378
      C = (C << 15) | (C >> 17);
#line 378
      C += D;
#line 378
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 379
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 379
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 379
      B = (B << 21) | (B >> 11);
#line 379
      B += C;
#line 379
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 380
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 380
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 380
      A = (A << 6) | (A >> 26);
#line 380
      A += B;
#line 380
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 381
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 381
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 381
      D = (D << 10) | (D >> 22);
#line 381
      D += A;
#line 381
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 382
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 382
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 382
      C = (C << 15) | (C >> 17);
#line 382
      C += D;
#line 382
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 383
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 383
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 383
      B = (B << 21) | (B >> 11);
#line 383
      B += C;
#line 383
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 384
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 384
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 384
      A = (A << 6) | (A >> 26);
#line 384
      A += B;
#line 384
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 385
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 385
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 385
      D = (D << 10) | (D >> 22);
#line 385
      D += A;
#line 385
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 386
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 386
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 386
      C = (C << 15) | (C >> 17);
#line 386
      C += D;
#line 386
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 387
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 387
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 387
      B = (B << 21) | (B >> 11);
#line 387
      B += C;
#line 387
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 390
    A += A_save;
#line 391
    B += B_save;
#line 392
    C += C_save;
#line 393
    D += D_save;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  ctx->A = A;
#line 398
  ctx->B = B;
#line 399
  ctx->C = C;
#line 400
  ctx->D = D;
#line 401
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 46 "./conf_file.h"
int parse_conf_file(char *fname , struct conf_cmd *commands ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/conf_file.c"
int parse_conf_file(char *fname , struct conf_cmd *commands ) 
{ 
  char buf___0[8193] ;
  FILE *in ;
  int using_a_file ;
  char *p ;
  char *cmd_start ;
  char *arg ;
  struct conf_cmd *cmd ;
  int lnum ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 73
  using_a_file = 1;
#line 78
  lnum = 0;
#line 81
  buf___0[8192] = (char )'\000';
#line 83
  tmp___1 = strcmp("-", (char const   *)fname);
  }
#line 83
  if (tmp___1 == 0) {
#line 85
    in = stdin;
#line 86
    using_a_file = 0;
  } else {
    {
#line 90
    in = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 90
    if ((unsigned long )in == (unsigned long )((void *)0)) {
      {
#line 92
      tmp = __errno_location();
#line 92
      tmp___0 = strerror(*tmp);
#line 92
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not open config file \"%s\": %s\n",
              fname, tmp___0);
      }
#line 93
      return (-1);
    }
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    lnum ++;
#line 97
    tmp___3 = fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)in);
    }
#line 97
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 97
      goto while_break;
    }
#line 99
    p = buf___0;
    {
#line 102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 102
      if (! ((int )*p == 32)) {
#line 102
        if (! ((int )*p == 9)) {
#line 102
          goto while_break___0;
        }
      }
#line 102
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 105
    if ((int )*p == 35) {
#line 107
      goto while_continue;
    } else
#line 105
    if ((int )*p == 13) {
#line 107
      goto while_continue;
    } else
#line 105
    if ((int )*p == 10) {
#line 107
      goto while_continue;
    } else
#line 105
    if ((int )*p == 0) {
#line 107
      goto while_continue;
    }
#line 110
    cmd_start = p;
    {
#line 113
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 113
      if ((int )*p != 0) {
#line 113
        if ((int )*p != 13) {
#line 113
          if (! ((int )*p != 10)) {
#line 113
            goto while_break___1;
          }
        } else {
#line 113
          goto while_break___1;
        }
      } else {
#line 113
        goto while_break___1;
      }
#line 113
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 114
    *p = (char )'\000';
#line 115
    p = cmd_start;
    {
#line 118
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 118
      if ((int )*p != 0) {
#line 118
        if (! ((int )*p != 61)) {
#line 118
          goto while_break___2;
        }
      } else {
#line 118
        goto while_break___2;
      }
#line 118
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 121
    if ((int )*p == 0) {
#line 123
      arg = (char *)((void *)0);
    } else {
#line 127
      *p = (char )'\000';
#line 128
      p ++;
#line 129
      arg = p;
    }
#line 133
    cmd = commands;
    {
#line 134
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 134
      if (! ((unsigned long )cmd->name != (unsigned long )((void *)0))) {
#line 134
        goto while_break___3;
      }
      {
#line 136
      tmp___2 = strcmp((char const   *)cmd->name, (char const   *)cmd_start);
      }
#line 136
      if (tmp___2 == 0) {
#line 139
        goto while_break___3;
      }
#line 141
      cmd ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 143
    if ((unsigned long )cmd->name == (unsigned long )((void *)0)) {
      {
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s,%d: unknown command: %s\n",
              fname, lnum, cmd_start);
#line 147
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"commands are:\n");
#line 148
      cmd = commands;
      }
      {
#line 149
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 149
        if (! ((unsigned long )cmd->name != (unsigned long )((void *)0))) {
#line 149
          goto while_break___4;
        }
        {
#line 151
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-14s usage: ",
                cmd->name);
#line 152
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)cmd->help,
                cmd->name);
#line 153
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 154
        cmd ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 156
      goto ERR;
    }
    {
#line 162
    if (cmd->arg_type == 1) {
#line 162
      goto case_1;
    }
#line 169
    if (cmd->arg_type == 2) {
#line 169
      goto case_2;
    }
#line 175
    if (cmd->arg_type == 0) {
#line 175
      goto case_0;
    }
#line 178
    goto switch_default;
    case_1: /* CIL Label */ 
#line 163
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
#line 165
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"option \"%s\" requires an argument\n",
              cmd->name);
      }
#line 166
      goto ERR;
    }
#line 168
    goto switch_break;
    case_2: /* CIL Label */ 
#line 170
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 172
      arg = (char *)"";
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
#line 176
    arg = (char *)"";
#line 177
    goto switch_break;
    switch_default: /* CIL Label */ ;
#line 180
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 184
    if (! cmd->available) {
      {
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"the command \"%s\" is not available\n",
              cmd->name);
      }
#line 187
      goto while_continue;
    }
    {
#line 191
    (*(cmd->proc))(cmd, arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  if (using_a_file) {
#line 196
    if (in) {
      {
#line 198
      fclose(in);
      }
    }
  }
#line 201
  return (0);
  ERR: 
#line 204
  if (using_a_file) {
#line 206
    if (in) {
      {
#line 208
      fclose(in);
      }
    }
  }
#line 211
  return (-1);
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 34 "./cache_file.h"
int read_cache_file(char *file , time_t *date , char **ipaddr ) ;
#line 35
int write_cache_file(char *file , time_t date , char *ipaddr ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/cache_file.c"
int read_cache_file(char *file , time_t *date , char **ipaddr ) 
{ 
  FILE *fp ;
  char buf___0[8193] ;
  char *p ;
  char *datestr ;
  char *ipstr ;
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 80
  fp = (FILE *)((void *)0);
#line 90
  buf___0[8192] = (char )'\000';
#line 93
  *date = (time_t )0;
#line 94
  *ipaddr = (char *)((void *)0);
#line 97
  tmp___0 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 97
  if (tmp___0 != 0) {
    {
#line 99
    tmp = __errno_location();
    }
#line 99
    if (*tmp == 2) {
#line 101
      return (0);
    }
#line 103
    return (-1);
  }
  {
#line 107
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 107
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 109
    return (-1);
  }
  {
#line 112
  tmp___3 = fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)fp);
  }
#line 112
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 116
    p = buf___0;
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 117
      if ((int )*p != 0) {
#line 117
        if ((int )*p != 13) {
#line 117
          if (! ((int )*p != 10)) {
#line 117
            goto while_break;
          }
        } else {
#line 117
          goto while_break;
        }
      } else {
#line 117
        goto while_break;
      }
#line 117
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 118
    *p = (char )'\000';
#line 121
    p = buf___0;
    {
#line 122
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 122
      if ((int )*p != 0) {
#line 122
        if (! ((int )*p != 44)) {
#line 122
          goto while_break___0;
        }
      } else {
#line 122
        goto while_break___0;
      }
#line 122
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 123
    if ((int )*p == 0) {
      {
#line 125
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malformed cache file\n");
      }
#line 126
      goto ERR;
    }
    {
#line 130
    tmp___1 = p;
#line 130
    p ++;
#line 130
    *tmp___1 = (char )'\000';
#line 132
    datestr = buf___0;
#line 133
    ipstr = p;
#line 135
    tmp___2 = strtoul((char const   */* __restrict  */)datestr, (char **/* __restrict  */)((void *)0),
                      10);
#line 135
    *date = (time_t )tmp___2;
#line 136
    *ipaddr = strdup((char const   *)ipstr);
    }
  } else {
#line 140
    *date = (time_t )0;
#line 141
    *ipaddr = (char *)((void *)0);
  }
  {
#line 144
  fclose(fp);
  }
#line 146
  return (0);
  ERR: 
#line 150
  if (fp) {
    {
#line 150
    fclose(fp);
    }
  }
#line 151
  return (-1);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/cache_file.c"
int write_cache_file(char *file , time_t date , char *ipaddr ) 
{ 
  FILE *fp ;

  {
  {
#line 156
  fp = (FILE *)((void *)0);
#line 158
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
#line 158
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 160
    return (-1);
  }
  {
#line 163
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%ld,%s\n",
          date, ipaddr);
#line 165
  fclose(fp);
  }
#line 167
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 764
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
#line 948
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 92 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) herror)(char const   *__str ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 4 "./dprintf.h"
int options  ;
#line 243 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *program_name  =    (char *)((void *)0);
#line 244 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *cache_file  =    (char *)((void *)0);
#line 245 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *config_file  =    (char *)((void *)0);
#line 246 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *server  =    (char *)((void *)0);
#line 247 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *port  =    (char *)((void *)0);
#line 248 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char user[256]  ;
#line 249 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char auth[512]  ;
#line 250 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char user_name[128]  ;
#line 251 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char password[128]  ;
#line 252 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *address  =    (char *)((void *)0);
#line 253 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *request  =    (char *)((void *)0);
#line 254 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *request_over_ride  =    (char *)((void *)0);
#line 255 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int wildcard  =    0;
#line 256 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *mx  =    (char *)((void *)0);
#line 257 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *url  =    (char *)((void *)0);
#line 258 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *host  =    (char *)((void *)0);
#line 259 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *cloak_title  =    (char *)((void *)0);
#line 260 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *interface  =    (char *)((void *)0);
#line 261 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int ntrys  =    1;
#line 262 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int update_period  =    120;
#line 263 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int resolv_period  =    30;
#line 264 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
struct timeval timeout  ;
#line 265 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int max_interval  =    0;
#line 266 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int service_set  =    0;
#line 267 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *post_update_cmd  =    (char *)((void *)0);
#line 268 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *post_update_cmd_arg  =    (char *)((void *)0);
#line 269 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int connection_type  =    1;
#line 270 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
time_t last_update  =    (time_t )0;
#line 271 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *notify_email  =    (char *)((void *)0);
#line 272 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *pid_file  =    (char *)((void *)0);
#line 273 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *partner  =    (char *)((void *)0);
#line 275 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static int volatile   client_sockfd  ;
#line 276 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static int volatile   last_sig  =    (int volatile   )0;
#line 281
int NULL_check_info(void) ;
#line 282 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *NULL_fields_used[1]  = {      (char *)((void *)0)};
#line 284
int EZIP_update_entry(void) ;
#line 285
int EZIP_check_info(void) ;
#line 286 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *EZIP_fields_used[8]  = 
#line 286
  {      (char *)"server",      (char *)"user",      (char *)"address",      (char *)"wildcard", 
        (char *)"mx",      (char *)"url",      (char *)"host",      (char *)((void *)0)};
#line 288
int PGPOW_update_entry(void) ;
#line 289
int PGPOW_check_info(void) ;
#line 290 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *PGPOW_fields_used[3]  = {      (char *)"server",      (char *)"host",      (char *)((void *)0)};
#line 292
int DHS_update_entry(void) ;
#line 293
int DHS_check_info(void) ;
#line 294 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *DHS_fields_used[8]  = 
#line 294
  {      (char *)"server",      (char *)"user",      (char *)"address",      (char *)"wildcard", 
        (char *)"mx",      (char *)"url",      (char *)"host",      (char *)((void *)0)};
#line 296
void DYNDNS_init(void) ;
#line 297
int DYNDNS_update_entry(void) ;
#line 298
int DYNDNS_check_info(void) ;
#line 299 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *DYNDNS_fields_used[7]  = {      (char *)"server",      (char *)"user",      (char *)"address",      (char *)"wildcard", 
        (char *)"mx",      (char *)"host",      (char *)((void *)0)};
#line 300 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *DYNDNS_STAT_fields_used[7]  = {      (char *)"server",      (char *)"user",      (char *)"address",      (char *)"wildcard", 
        (char *)"mx",      (char *)"host",      (char *)((void *)0)};
#line 302
int ODS_update_entry(void) ;
#line 303
int ODS_check_info(void) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *ODS_fields_used[4]  = {      (char *)"server",      (char *)"host",      (char *)"address",      (char *)((void *)0)};
#line 306
int TZO_update_entry(void) ;
#line 307
int TZO_check_info(void) ;
#line 308 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *TZO_fields_used[6]  = {      (char *)"server",      (char *)"user",      (char *)"address",      (char *)"host", 
        (char *)"connection-type",      (char *)((void *)0)};
#line 310
int EASYDNS_update_entry(void) ;
#line 311
int EASYDNS_check_info(void) ;
#line 312 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *EASYDNS_fields_used[7]  = {      (char *)"server",      (char *)"user",      (char *)"address",      (char *)"wildcard", 
        (char *)"mx",      (char *)"host",      (char *)((void *)0)};
#line 314
int EASYDNS_PARTNER_update_entry(void) ;
#line 315
int EASYDNS_PARTNER_check_info(void) ;
#line 316 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *EASYDNS_PARTNER_fields_used[7]  = {      (char *)"server",      (char *)"partner",      (char *)"user",      (char *)"address", 
        (char *)"wildcard",      (char *)"host",      (char *)((void *)0)};
#line 319
int GNUDIP_update_entry(void) ;
#line 320
int GNUDIP_check_info(void) ;
#line 321 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *GNUDIP_fields_used[5]  = {      (char *)"server",      (char *)"user",      (char *)"host",      (char *)"address", 
        (char *)((void *)0)};
#line 324
int JUSTL_update_entry(void) ;
#line 325
int JUSTL_check_info(void) ;
#line 326 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *JUSTL_fields_used[4]  = {      (char *)"server",      (char *)"user",      (char *)"host",      (char *)((void *)0)};
#line 328
int DYNS_update_entry(void) ;
#line 329
int DYNS_check_info(void) ;
#line 330 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *DYNS_fields_used[4]  = {      (char *)"server",      (char *)"user",      (char *)"host",      (char *)((void *)0)};
#line 332
int HN_update_entry(void) ;
#line 333
int HN_check_info(void) ;
#line 334 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *HN_fields_used[4]  = {      (char *)"server",      (char *)"user",      (char *)"address",      (char *)((void *)0)};
#line 336
int ZONEEDIT_update_entry(void) ;
#line 337
int ZONEEDIT_check_info(void) ;
#line 338 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *ZONEEDIT_fields_used[6]  = {      (char *)"server",      (char *)"user",      (char *)"address",      (char *)"mx", 
        (char *)"host",      (char *)((void *)0)};
#line 340
int HEIPV6TB_update_entry(void) ;
#line 341
int HEIPV6TB_check_info(void) ;
#line 342 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char *HEIPV6TB_fields_used[3]  = {      (char *)"server",      (char *)"user",      (char *)((void *)0)};
#line 344 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
struct service_t services[17]  = 
#line 344
  {      {(char *)"NULL", {(char *)"null", (char *)"NULL", (char *)0}, (void (*)(void))((void *)0),
      (int (*)(void))((void *)0), & NULL_check_info, NULL_fields_used, (char *)"",
      (char *)"", (char *)""}, 
        {(char *)"ez-ip", {(char *)"ezip", (char *)"ez-ip", (char *)0}, (void (*)(void))((void *)0),
      & EZIP_update_entry, & EZIP_check_info, EZIP_fields_used, (char *)"www.EZ-IP.Net",
      (char *)"80", (char *)"/members/update/"}, 
        {(char *)"justlinux v1.0 (penguinpowered)", {(char *)"pgpow", (char *)"penguinpowered",
                                                  (char *)0}, (void (*)(void))((void *)0),
      & PGPOW_update_entry, & PGPOW_check_info, PGPOW_fields_used, (char *)"www.penguinpowered.com",
      (char *)"2345", (char *)"update"}, 
        {(char *)"dhs", {(char *)"dhs", (char *)0, (char *)0}, (void (*)(void))((void *)0),
      & DHS_update_entry, & DHS_check_info, DHS_fields_used, (char *)"members.dhs.org",
      (char *)"80", (char *)"/nic/hosts"}, 
        {(char *)"dyndns", {(char *)"dyndns", (char *)0, (char *)0}, & DYNDNS_init, & DYNDNS_update_entry,
      & DYNDNS_check_info, DYNDNS_fields_used, (char *)"members.dyndns.org", (char *)"80",
      (char *)"/nic/update"}, 
        {(char *)"dyndns-static", {(char *)"dyndns-static", (char *)"dyndns-stat", (char *)"statdns"},
      & DYNDNS_init, & DYNDNS_update_entry, & DYNDNS_check_info, DYNDNS_STAT_fields_used,
      (char *)"members.dyndns.org", (char *)"80", (char *)"/nic/update"}, 
        {(char *)"dyndns-custom", {(char *)"dyndns-custom", (char *)"mydyndns", (char *)0},
      & DYNDNS_init, & DYNDNS_update_entry, & DYNDNS_check_info, DYNDNS_STAT_fields_used,
      (char *)"members.dyndns.org", (char *)"80", (char *)"/nic/update"}, 
        {(char *)"ods", {(char *)"ods", (char *)0, (char *)0}, (void (*)(void))((void *)0),
      & ODS_update_entry, & ODS_check_info, ODS_fields_used, (char *)"update.ods.org",
      (char *)"7070", (char *)"update"}, 
        {(char *)"tzo", {(char *)"tzo", (char *)0, (char *)0}, (void (*)(void))((void *)0),
      & TZO_update_entry, & TZO_check_info, TZO_fields_used, (char *)"cgi.tzo.com",
      (char *)"80", (char *)"/webclient/signedon.html"}, 
        {(char *)"easydns", {(char *)"easydns", (char *)0, (char *)0}, (void (*)(void))((void *)0),
      & EASYDNS_update_entry, & EASYDNS_check_info, EASYDNS_fields_used, (char *)"members.easydns.com",
      (char *)"80", (char *)"/dyn/ez-ipupdate.php"}, 
        {(char *)"easydns-partner", {(char *)"easydns-partner", (char *)0, (char *)0},
      (void (*)(void))((void *)0), & EASYDNS_PARTNER_update_entry, & EASYDNS_PARTNER_check_info,
      EASYDNS_PARTNER_fields_used, (char *)"api.easydns.com", (char *)"80", (char *)"/dyn/ez-ipupdate.php"}, 
        {(char *)"gnudip",
      {(char *)"gnudip", (char *)0, (char *)0}, (void (*)(void))((void *)0), & GNUDIP_update_entry,
      & GNUDIP_check_info, GNUDIP_fields_used, (char *)"", (char *)"3495", (char *)"0"}, 
        {(char *)"justlinux v2.0 (penguinpowered)",
      {(char *)"justlinux", (char *)0, (char *)0}, (void (*)(void))((void *)0), & JUSTL_update_entry,
      & JUSTL_check_info, JUSTL_fields_used, (char *)"www.justlinux.com", (char *)"80",
      (char *)"/bin/controlpanel/dyndns/jlc.pl"}, 
        {(char *)"dyns", {(char *)"dyns", (char *)0, (char *)0}, (void (*)(void))((void *)0),
      & DYNS_update_entry, & DYNS_check_info, DYNS_fields_used, (char *)"www.dyns.cx",
      (char *)"80", (char *)"/postscript.php"}, 
        {(char *)"hammer node", {(char *)"hn", (char *)0, (char *)0}, (void (*)(void))((void *)0),
      & HN_update_entry, & HN_check_info, HN_fields_used, (char *)"dup.hn.org", (char *)"80",
      (char *)"/vanity/update"}, 
        {(char *)"zoneedit", {(char *)"zoneedit", (char *)0, (char *)0}, (void (*)(void))((void *)0),
      & ZONEEDIT_update_entry, & ZONEEDIT_check_info, ZONEEDIT_fields_used, (char *)"dynamic.zoneedit.com",
      (char *)"80", (char *)"/auth/dynamic.html"}, 
        {(char *)"heipv6tb", {(char *)"heipv6tb", (char *)0, (char *)0}, (void (*)(void))((void *)0),
      & HEIPV6TB_update_entry, & HEIPV6TB_check_info, HEIPV6TB_fields_used, (char *)"ipv6tb.he.net",
      (char *)"80", (char *)"/index.cgi"}};
#line 519 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static struct service_t *service  =    (struct service_t *)((void *)0);
#line 563
int conf_handler(struct conf_cmd *cmd , char *arg ) ;
#line 564 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static struct conf_cmd conf_commands[30]  = 
#line 564
  {      {6, (char *)"address", 1, 1, & conf_handler, (char *)"%s=<ip address>"}, 
        {26, (char *)"cache-file", 1, 1, & conf_handler, (char *)"%s=<cache file>"}, 
        {12, (char *)"cloak-title", 1, 1, & conf_handler, (char *)"%s=<title>"}, 
        {17, (char *)"daemon", 0, 1, & conf_handler, (char *)"%s=<command>"}, 
        {19, (char *)"execute", 1, 1, & conf_handler, (char *)"%s=<shell command>"}, 
        {18, (char *)"debug", 0, 1, & conf_handler, (char *)"%s"}, 
        {20, (char *)"foreground", 0, 1, & conf_handler, (char *)"%s"}, 
        {28, (char *)"pid-file", 1, 1, & conf_handler, (char *)"%s=<file>"}, 
        {11, (char *)"host", 1, 1, & conf_handler, (char *)"%s=<host>"}, 
        {13, (char *)"interface", 1, 1, & conf_handler, (char *)"%s=<interface>"}, 
        {8, (char *)"mx", 1, 1, & conf_handler, (char *)"%s=<mail exchanger>"}, 
        {9, (char *)"max-interval", 1, 1, & conf_handler, (char *)"%s=<number of seconds between updates>"}, 
        {27,
      (char *)"notify-email", 1, 1, & conf_handler, (char *)"%s=<address to email if bad things happen>"}, 
        {29,
      (char *)"offline", 0, 1, & conf_handler, (char *)"%s"}, 
        {14, (char *)"retrys", 1, 1, & conf_handler, (char *)"%s=<number of trys>"}, 
        {3, (char *)"server", 1, 1, & conf_handler, (char *)"%s=<server name>"}, 
        {2, (char *)"service-type", 1, 1, & conf_handler, (char *)"%s=<service type>"}, 
        {22,
      (char *)"timeout", 1, 1, & conf_handler, (char *)"%s=<sec.millisec>"}, 
        {15, (char *)"resolv-period", 1, 1, & conf_handler, (char *)"%s=<time between failed resolve attempts>"}, 
        {16,
      (char *)"period", 1, 1, & conf_handler, (char *)"%s=<time between update attempts>"}, 
        {10,
      (char *)"url", 1, 1, & conf_handler, (char *)"%s=<url>"}, 
        {5, (char *)"user", 1, 1, & conf_handler, (char *)"%s=<user name>[:password]"}, 
        {23,
      (char *)"run-as-user", 1, 1, & conf_handler, (char *)"%s=<user>"}, 
        {24, (char *)"run-as-euser", 1, 1, & conf_handler, (char *)"%s=<user> (this is not secure)"}, 
        {7,
      (char *)"wildcard", 0, 1, & conf_handler, (char *)"%s"}, 
        {21, (char *)"quiet", 0, 1, & conf_handler, (char *)"%s"}, 
        {25, (char *)"connection-type", 1, 1, & conf_handler, (char *)"%s=<connection type>"}, 
        {4,
      (char *)"request", 1, 1, & conf_handler, (char *)"%s=<request uri>"}, 
        {30, (char *)"partner", 1, 1, & conf_handler, (char *)"%s=<easydns partner>"}, 
        {0,
      (char *)0, 0, 0, (int (*)(struct conf_cmd * , char * ))0, (char *)0}};
#line 599
void print_usage(void) ;
#line 600
void print_version(void) ;
#line 601
void parse_args(int argc , char **argv ) ;
#line 602
int do_connect(int *sock , char *host___0 , char *port___0 ) ;
#line 603
void base64Encode(char *intext , char *output___0 ) ;
#line 604
int main(int argc , char **argv ) ;
#line 605
void warn_fields(char **okay_fields ) ;
#line 606
static int is_in_list(char *needle , char **haystack ) ;
#line 610 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void print_usage(void) 
{ 
  int i ;
  int width ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 615
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"usage: ");
#line 616
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s [options] \n\n",
          program_name);
#line 617
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" Options are:\n");
#line 618
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -a, --address <ip address>\tstring to send as your ip address\n");
#line 619
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -b, --cache-file <file>\tfile to use for caching the ipaddress\n");
#line 620
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -c, --config-file <file>\tconfiguration file, almost all arguments can be\n");
#line 621
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t\t\t\tgiven with: <name>[=<value>]\n\t\t\t\tto see a list of possible config commands\n");
#line 622
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t\t\t\ttry \"echo help | %s -c -\"\n",
          program_name);
#line 623
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -d, --daemon\t\t\trun as a daemon periodicly updating if \n\t\t\t\tnecessary\n");
#line 627
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -e, --execute <command>\tshell command to execute after a successful\n\t\t\t\tupdate\n");
#line 628
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -f, --foreground\t\twhen running as a daemon run in the foreground\n");
#line 629
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -F, --pidfile <file>\t\tuse <file> as a pid file\n");
#line 630
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -g, --request-uri <uri>\tURI to send updates to\n");
#line 631
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -h, --host <host>\t\tstring to send as host parameter\n");
#line 632
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -i, --interface <iface>\twhich interface to use\n");
#line 633
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -L, --cloak_title <host>\tsome stupid thing for DHS only\n");
#line 634
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -m, --mx <mail exchange>\tstring to send as your mail exchange\n");
#line 635
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -M, --max-interval <# of sec>\tmax time in between updates\n");
#line 636
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -N, --notify-email <email>\taddress to send mail to if bad things happen\n");
#line 637
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -o, --offline\t\t\tset to off line mode\n");
#line 638
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -p, --resolv-period <sec>\tperiod to check IP if it can\'t be resolved\n");
#line 639
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -P, --period <# of sec>\tperiod to check IP in daemon \n\t\t\t\tmode (default: 1800 seconds)\n");
#line 640
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -q, --quiet \t\t\tbe quiet\n");
#line 641
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -r, --retrys <num>\t\tnumber of trys (default: 1)\n");
#line 642
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -R, --run-as-user <user>\tchange to <user> for running, be ware\n\t\t\t\tthat this can cause problems with handeling\n\t\t\t\tSIGHUP properly if that user can\'t read the\n\t\t\t\tconfig file. also it can\'t write it\'s pid file \n\t\t\t\tto a root directory\n");
#line 643
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -Q, --run-as-euser <user>\tchange to effective <user> for running, \n\t\t\t\tthis is NOT secure but it does solve the \n\t\t\t\tproblems with run-as-user and config files and \n\t\t\t\tpid files.\n");
#line 644
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -s, --server <server[:port]>\tthe server to connect to\n");
#line 645
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -S, --service-type <server>\tthe type of service that you are using\n");
#line 646
  tmp = fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t\t\t\ttry one of: ");
#line 646
  width = tmp + 28;
#line 647
  i = 0;
  }
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! ((unsigned long )i < sizeof(services) / sizeof(services[0]))) {
#line 647
      goto while_break;
    }
#line 649
    if (width > 60) {
      {
#line 649
      tmp___0 = fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n\t\t\t\t");
#line 649
      width = (tmp___0 - 1) + 28;
      }
    }
    {
#line 650
    tmp___1 = fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s ",
                      services[i].names[0]);
#line 650
    width += tmp___1;
#line 647
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 652
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
#line 653
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -t, --timeout <sec.millisec>\tthe amount of time to wait on I/O\n");
#line 654
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -T, --connection-type <num>\tnumber sent to TZO as your connection \n\t\t\t\ttype (default: 1)\n");
#line 655
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -U, --url <url>\t\tstring to send as the url parameter\n");
#line 656
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -u, --user <user[:passwd]>\tuser ID and password, if either is left blank \n\t\t\t\tthey will be prompted for\n");
#line 657
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -w, --wildcard\t\tset your domain to have a wildcard alias\n");
#line 658
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  -z, --partner <partner>\tspecify easyDNS partner (for easydns-partner \n\t\t\t\tservices)\n");
#line 659
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"      --help\t\t\tdisplay this help and exit\n");
#line 660
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"      --version\t\t\toutput version information and exit\n");
#line 661
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"      --credits\t\t\tprint the credits and exit\n");
#line 662
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"      --signalhelp\t\tprint help about signals\n");
#line 663
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
  }
#line 664
  return;
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void print_version(void) 
{ 


  {
  {
#line 668
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s: - %s - $Id: ez-ipupdate.c,v 1.48 2001/07/17 00:49:41 amackay Exp $\n",
          program_name, "3.0.11b8");
  }
#line 669
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void print_credits(void) 
{ 


  {
  {
#line 673
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"AUTHORS / CONTRIBUTORS\n  Angus Mackay <amackay@gusnet.cx>\n  Jeremy Bopp <jbopp@mail.utexas.edu>\n  Mark Jeftovic <markjr@easydns.com>\n  Stefaan Ponnet <webmaster@dyns.cx>\n  Colin Viebrock <colin@easydns.com>\n  Tim Brown <timb@machine.org.uk>\n\n");
  }
#line 681
  return;
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void print_signalhelp(void) 
{ 


  {
  {
#line 685
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\nsignals are only really used when in daemon mode.\n\n");
#line 686
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"signals: \n");
#line 687
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  HUP\t\tcauses it to re-read its config file\n");
#line 688
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  TERM\t\twake up and possibly perform an update\n");
#line 689
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  QUIT\t\tshutdown\n");
#line 690
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
  }
#line 691
  return;
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void sigint_handler(int sig ) 
{ 
  char message[13] ;

  {
  {
#line 696
  message[0] = (char )'i';
#line 696
  message[1] = (char )'n';
#line 696
  message[2] = (char )'t';
#line 696
  message[3] = (char )'e';
#line 696
  message[4] = (char )'r';
#line 696
  message[5] = (char )'u';
#line 696
  message[6] = (char )'p';
#line 696
  message[7] = (char )'t';
#line 696
  message[8] = (char )'e';
#line 696
  message[9] = (char )'d';
#line 696
  message[10] = (char )'.';
#line 696
  message[11] = (char )'\n';
#line 696
  message[12] = (char )'\000';
#line 697
  close((int )client_sockfd);
#line 698
  write(2, (void const   *)(message), sizeof(message) - 1UL);
  }
#line 701
  if (pid_file) {
    {
#line 703
    pid_file_delete(pid_file);
    }
  }
  {
#line 707
  exit(1);
  }
}
}
#line 709 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void generic_sig_handler(int sig ) 
{ 


  {
#line 711
  last_sig = (int volatile   )sig;
#line 712
  return;
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int get_duration(char *str ) 
{ 
  char *multchar ;
  int mult ;
  char save ;
  int duration ;
  unsigned short const   **tmp ;
  long tmp___0 ;

  {
#line 722
  multchar = str;
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;
#line 722
    if (! ((int )*multchar != 0)) {
#line 722
      goto while_break;
    }
#line 722
    multchar ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 723
  if ((unsigned long )multchar != (unsigned long )str) {
#line 723
    multchar --;
  }
#line 724
  if ((int )*multchar == 0) {
#line 724
    mult = 1;
#line 724
    multchar ++;
  } else {
    {
#line 724
    tmp = __ctype_b_loc();
    }
#line 724
    if ((int const   )*(*tmp + (int )*multchar) & 2048) {
#line 724
      mult = 1;
#line 724
      multchar ++;
    } else
#line 725
    if ((int )*multchar == 77) {
#line 725
      mult = 60;
    } else
#line 726
    if ((int )*multchar == 72) {
#line 726
      mult = 3600;
    } else
#line 727
    if ((int )*multchar == 100) {
#line 727
      mult = 86400;
    } else
#line 728
    if ((int )*multchar == 119) {
#line 728
      mult = 604800;
    } else
#line 729
    if ((int )*multchar == 102) {
#line 729
      mult = 1209600;
    } else
#line 730
    if ((int )*multchar == 109) {
#line 730
      mult = 2592000;
    } else
#line 731
    if ((int )*multchar == 121) {
#line 731
      mult = 31536000;
    } else {
      {
#line 734
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid multiplier: %c\n",
              (int )*multchar);
#line 735
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"valid multipliers:\n");
#line 736
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %c -> %s (%d)\n",
              'M', "Minute", 60);
#line 737
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %c -> %s (%d)\n",
              'H', "Hour", 3600);
#line 738
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %c -> %s (%d)\n",
              'd', "day", 86400);
#line 739
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %c -> %s (%d)\n",
              'w', "week", 604800);
#line 740
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %c -> %s (%d)\n",
              'f', "fortnight", 1209600);
#line 741
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %c -> %s (%d)\n",
              'm', "month", 2592000);
#line 742
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %c -> %s (%d)\n",
              'y', "year", 31536000);
#line 743
      exit(1);
      }
    }
  }
  {
#line 745
  save = *multchar;
#line 746
  *multchar = (char )'\000';
#line 747
  tmp___0 = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
                   0);
#line 747
  duration = (int )(tmp___0 * (long )mult);
#line 748
  *multchar = save;
  }
#line 750
  return (duration);
}
}
#line 755 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char buf[16]  ;
#line 753 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char const   *format_time(int seconds ) 
{ 


  {
  {
#line 757
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d:%02d:%02d",
           seconds / 3600, (seconds % 3600) / 60, seconds % 60);
  }
#line 759
  return ((char const   *)(buf));
}
}
#line 765 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
char *chomp(char *buf___0 ) 
{ 
  char *p ;
  char *tmp ;

  {
#line 769
  p = buf___0;
  {
#line 769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 769
    if (! ((int )*p != 0)) {
#line 769
      goto while_break;
    }
#line 769
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  if ((unsigned long )p != (unsigned long )buf___0) {
#line 770
    p --;
  }
  {
#line 771
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 771
    if ((unsigned long )p >= (unsigned long )buf___0) {
#line 771
      if (! ((int )*p == 10)) {
#line 771
        if (! ((int )*p == 13)) {
#line 771
          goto while_break___0;
        }
      }
    } else {
#line 771
      goto while_break___0;
    }
#line 773
    tmp = p;
#line 773
    p --;
#line 773
    *tmp = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 776
  return (buf___0);
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void show_message(char *fmt  , ...) 
{ 
  va_list args ;
  char buf___0[256] ;

  {
  {
#line 789
  __builtin_va_start(args, fmt);
  }
#line 791
  if (options & 4) {
#line 791
    if (! (options & 16)) {
      {
#line 796
      vsnprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)fmt,
                args);
#line 801
      syslog(5, (char const   *)(buf___0));
      }
    } else {
      {
#line 806
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
               args);
      }
    }
  } else {
    {
#line 806
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             args);
    }
  }
  {
#line 812
  __builtin_va_end(args);
  }
#line 813
  return;
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int is_dotted_quad(char *addr ) 
{ 
  int q[4] ;
  char *p ;
  int i ;
  int tmp ;

  {
  {
#line 825
  tmp = sscanf((char const   */* __restrict  */)addr, (char const   */* __restrict  */)"%d.%d.%d.%d",
               & q[0], & q[1], & q[2], & q[3]);
  }
#line 825
  if (tmp != 4) {
#line 827
    return (0);
  }
#line 830
  if (q[0] > 255) {
#line 835
    return (0);
  } else
#line 830
  if (q[0] < 0) {
#line 835
    return (0);
  } else
#line 830
  if (q[1] > 255) {
#line 835
    return (0);
  } else
#line 830
  if (q[1] < 0) {
#line 835
    return (0);
  } else
#line 830
  if (q[2] > 255) {
#line 835
    return (0);
  } else
#line 830
  if (q[2] < 0) {
#line 835
    return (0);
  } else
#line 830
  if (q[3] > 255) {
#line 835
    return (0);
  } else
#line 830
  if (q[3] < 0) {
#line 835
    return (0);
  }
#line 839
  p = addr;
#line 840
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 840
    p = strchr((char const   *)p, '.');
#line 840
    p ++;
    }
  }
#line 841
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 841
    p = strchr((char const   *)p, '.');
#line 841
    p ++;
    }
  }
#line 842
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 842
    p = strchr((char const   *)p, '.');
    }
  }
#line 843
  i = 0;
  {
#line 843
  while (1) {
    while_continue: /* CIL Label */ ;
#line 843
    if ((int )*p != 0) {
#line 843
      if (! (i < 4)) {
#line 843
        goto while_break;
      }
    } else {
#line 843
      goto while_break;
    }
#line 843
    i ++;
#line 843
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 844
  if ((int )*p != 0) {
#line 846
    return (0);
  }
#line 849
  return (1);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void parse_service(char *str ) 
{ 
  int i ;
  int width ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 857
  i = 0;
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if (! ((unsigned long )i < sizeof(services) / sizeof(services[0]))) {
#line 857
      goto while_break;
    }
#line 860
    j = 0;
    {
#line 860
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 860
      if ((unsigned long )j < sizeof(services[i].names) / sizeof(services[i].names[0])) {
#line 860
        if (! ((unsigned long )services[i].names[j] != (unsigned long )((void *)0))) {
#line 860
          goto while_break___0;
        }
      } else {
#line 860
        goto while_break___0;
      }
      {
#line 862
      tmp = strcmp((char const   *)services[i].names[j], (char const   *)str);
      }
#line 862
      if (tmp == 0) {
#line 864
        service = & services[i];
#line 865
        return;
      }
#line 860
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 857
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 869
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown service type: %s\n",
          str);
#line 870
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"try one of: \n");
#line 871
  width = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  ");
#line 872
  i = 0;
  }
  {
#line 872
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 872
    if (! ((unsigned long )i < sizeof(services) / sizeof(services[0]))) {
#line 872
      goto while_break___1;
    }
#line 874
    if (width > 60) {
      {
#line 874
      tmp___0 = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  ");
#line 874
      width = tmp___0 - 1;
      }
    }
    {
#line 875
    tmp___1 = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                      services[i].names[0]);
#line 875
    width += tmp___1;
#line 872
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 877
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 878
  exit(1);
  }
}
}
#line 881 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int option_handler(int id , char *optarg___0 ) 
{ 
  struct passwd *pw ;
  char *tmp ;
  int i ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  double tmp___10 ;

  {
  {
#line 891
  if (id == 6) {
#line 891
    goto case_6;
  }
#line 897
  if (id == 17) {
#line 897
    goto case_17;
  }
#line 902
  if (id == 18) {
#line 902
    goto case_18;
  }
#line 911
  if (id == 19) {
#line 911
    goto case_19;
  }
#line 924
  if (id == 20) {
#line 924
    goto case_20;
  }
#line 929
  if (id == 28) {
#line 929
    goto case_28;
  }
#line 939
  if (id == 11) {
#line 939
    goto case_11;
  }
#line 945
  if (id == 13) {
#line 945
    goto case_13;
  }
#line 956
  if (id == 8) {
#line 956
    goto case_8;
  }
#line 962
  if (id == 9) {
#line 962
    goto case_9;
  }
#line 973
  if (id == 27) {
#line 973
    goto case_27;
  }
#line 979
  if (id == 29) {
#line 979
    goto case_29;
  }
#line 984
  if (id == 16) {
#line 984
    goto case_16;
  }
#line 995
  if (id == 15) {
#line 995
    goto case_15;
  }
#line 1006
  if (id == 21) {
#line 1006
    goto case_21;
  }
#line 1011
  if (id == 14) {
#line 1011
    goto case_14;
  }
#line 1016
  if (id == 3) {
#line 1016
    goto case_3;
  }
#line 1030
  if (id == 4) {
#line 1030
    goto case_4;
  }
#line 1036
  if (id == 30) {
#line 1036
    goto case_30;
  }
#line 1042
  if (id == 2) {
#line 1042
    goto case_2;
  }
#line 1049
  if (id == 5) {
#line 1049
    goto case_5;
  }
#line 1061
  if (id == 23) {
#line 1061
    goto case_23;
  }
#line 1086
  if (id == 24) {
#line 1086
    goto case_24;
  }
#line 1111
  if (id == 10) {
#line 1111
    goto case_10;
  }
#line 1117
  if (id == 7) {
#line 1117
    goto case_7;
  }
#line 1122
  if (id == 12) {
#line 1122
    goto case_12;
  }
#line 1128
  if (id == 22) {
#line 1128
    goto case_22;
  }
#line 1134
  if (id == 25) {
#line 1134
    goto case_25;
  }
#line 1139
  if (id == 26) {
#line 1139
    goto case_26;
  }
#line 1145
  goto switch_default;
  case_6: /* CIL Label */ 
#line 892
  if (address) {
    {
#line 892
    free((void *)address);
    }
  }
  {
#line 893
  address = strdup((char const   *)optarg___0);
  }
#line 895
  goto switch_break;
  case_17: /* CIL Label */ 
#line 898
  options |= 4;
#line 900
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 907
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"debugging was not enabled at compile time\n");
  }
#line 909
  goto switch_break;
  case_19: /* CIL Label */ 
#line 913
  if (post_update_cmd) {
    {
#line 913
    free((void *)post_update_cmd);
    }
  }
  {
#line 914
  tmp___0 = strlen((char const   *)optarg___0);
#line 914
  tmp___1 = malloc(((tmp___0 + 1UL) + 32UL) + 1UL);
#line 914
  post_update_cmd = (char *)tmp___1;
#line 915
  tmp___2 = strlen((char const   *)optarg___0);
#line 915
  post_update_cmd_arg = (post_update_cmd + tmp___2) + 1;
#line 916
  sprintf((char */* __restrict  */)post_update_cmd, (char const   */* __restrict  */)"%s ",
          optarg___0);
  }
#line 922
  goto switch_break;
  case_20: /* CIL Label */ 
#line 925
  options |= 16;
#line 927
  goto switch_break;
  case_28: /* CIL Label */ 
#line 931
  if (pid_file) {
    {
#line 931
    free((void *)pid_file);
    }
  }
  {
#line 932
  pid_file = strdup((char const   *)optarg___0);
  }
#line 937
  goto switch_break;
  case_11: /* CIL Label */ 
#line 940
  if (host) {
    {
#line 940
    free((void *)host);
    }
  }
  {
#line 941
  host = strdup((char const   *)optarg___0);
  }
#line 943
  goto switch_break;
  case_13: /* CIL Label */ 
#line 947
  if (interface) {
    {
#line 947
    free((void *)interface);
    }
  }
  {
#line 948
  interface = strdup((char const   *)optarg___0);
  }
#line 954
  goto switch_break;
  case_8: /* CIL Label */ 
#line 957
  if (mx) {
    {
#line 957
    free((void *)mx);
    }
  }
  {
#line 958
  mx = strdup((char const   *)optarg___0);
  }
#line 960
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 963
  max_interval = get_duration(optarg___0);
  }
#line 964
  if (max_interval < 86400) {
    {
#line 966
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: max-interval of %d is too short, using %d\n",
            max_interval, 86400);
#line 968
    max_interval = 86400;
    }
  }
#line 971
  goto switch_break;
  case_27: /* CIL Label */ 
#line 974
  if (notify_email) {
    {
#line 974
    free((void *)notify_email);
    }
  }
  {
#line 975
  notify_email = strdup((char const   *)optarg___0);
  }
#line 977
  goto switch_break;
  case_29: /* CIL Label */ 
#line 980
  options |= 32;
#line 982
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 985
  update_period = get_duration(optarg___0);
  }
#line 986
  if (update_period < 10) {
    {
#line 988
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: period of %d is too short, using %d\n",
            update_period, 10);
#line 990
    update_period = 10;
    }
  }
#line 993
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 996
  resolv_period = get_duration(optarg___0);
  }
#line 997
  if (resolv_period < 1) {
    {
#line 999
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: period of %d is too short, using %d\n",
            resolv_period, 1);
#line 1001
    resolv_period = 1;
    }
  }
#line 1004
  goto switch_break;
  case_21: /* CIL Label */ 
#line 1007
  options |= 8;
#line 1009
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 1012
  ntrys = atoi((char const   *)optarg___0);
  }
#line 1014
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1017
  if (server) {
    {
#line 1017
    free((void *)server);
    }
  }
  {
#line 1018
  server = strdup((char const   *)optarg___0);
#line 1019
  tmp = strchr((char const   *)server, ':');
  }
#line 1020
  if (tmp) {
#line 1022
    tmp___3 = tmp;
#line 1022
    tmp ++;
#line 1022
    *tmp___3 = (char )'\000';
#line 1023
    if (port) {
      {
#line 1023
      free((void *)port);
      }
    }
    {
#line 1024
    port = strdup((char const   *)tmp);
    }
  }
#line 1028
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1031
  if (request_over_ride) {
    {
#line 1031
    free((void *)request_over_ride);
    }
  }
  {
#line 1032
  request_over_ride = strdup((char const   *)optarg___0);
  }
#line 1034
  goto switch_break;
  case_30: /* CIL Label */ 
#line 1037
  if (partner) {
    {
#line 1037
    free((void *)partner);
    }
  }
  {
#line 1038
  partner = strdup((char const   *)optarg___0);
  }
#line 1040
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1043
  parse_service(optarg___0);
#line 1044
  service_set = 1;
  }
#line 1047
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1050
  strncpy((char */* __restrict  */)(user), (char const   */* __restrict  */)optarg___0,
          sizeof(user));
#line 1051
  user[sizeof(user) - 1UL] = (char )'\000';
#line 1053
  tmp = strchr((char const   *)optarg___0, ':');
  }
#line 1054
  if (tmp) {
#line 1056
    tmp ++;
    {
#line 1057
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1057
      if (! *tmp) {
#line 1057
        goto while_break;
      }
#line 1057
      tmp___4 = tmp;
#line 1057
      tmp ++;
#line 1057
      *tmp___4 = (char )'*';
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1059
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 1063
  pw = getpwnam((char const   *)optarg___0);
  }
#line 1063
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 1065
    i = atoi((char const   *)optarg___0);
    }
  } else {
    {
#line 1069
    tmp___5 = setgid(pw->pw_gid);
    }
#line 1069
    if (tmp___5 != 0) {
      {
#line 1071
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error changing group id\n");
      }
    }
#line 1074
    i = (int )pw->pw_uid;
  }
  {
#line 1076
  tmp___6 = setuid((__uid_t )i);
  }
#line 1076
  if (tmp___6 != 0) {
    {
#line 1078
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error changing user id\n");
    }
  }
#line 1084
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 1088
  pw = getpwnam((char const   *)optarg___0);
  }
#line 1088
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 1090
    i = atoi((char const   *)optarg___0);
    }
  } else {
    {
#line 1094
    tmp___7 = setegid(pw->pw_gid);
    }
#line 1094
    if (tmp___7 != 0) {
      {
#line 1096
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error changing group id\n");
      }
    }
#line 1099
    i = (int )pw->pw_uid;
  }
  {
#line 1101
  tmp___8 = seteuid((__uid_t )i);
  }
#line 1101
  if (tmp___8 != 0) {
    {
#line 1103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error changing user id\n");
    }
  }
#line 1109
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1112
  if (url) {
    {
#line 1112
    free((void *)url);
    }
  }
  {
#line 1113
  url = strdup((char const   *)optarg___0);
  }
#line 1115
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1118
  wildcard = 1;
#line 1120
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1123
  if (cloak_title) {
    {
#line 1123
    free((void *)cloak_title);
    }
  }
  {
#line 1124
  cloak_title = strdup((char const   *)optarg___0);
  }
#line 1126
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 1129
  tmp___9 = atoi((char const   *)optarg___0);
#line 1129
  timeout.tv_sec = (__time_t )tmp___9;
#line 1130
  tmp___10 = atof((char const   *)optarg___0);
#line 1130
  timeout.tv_usec = (__suseconds_t )((tmp___10 - (double )timeout.tv_sec) * (double )1000000L);
  }
#line 1132
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 1135
  connection_type = atoi((char const   *)optarg___0);
  }
#line 1137
  goto switch_break;
  case_26: /* CIL Label */ 
#line 1140
  if (cache_file) {
    {
#line 1140
    free((void *)cache_file);
    }
  }
  {
#line 1141
  cache_file = strdup((char const   *)optarg___0);
  }
#line 1143
  goto switch_break;
  switch_default: /* CIL Label */ ;
#line 1147
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1150
  return (0);
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int conf_handler(struct conf_cmd *cmd , char *arg ) 
{ 
  int tmp ;

  {
  {
#line 1155
  tmp = option_handler(cmd->id, arg);
  }
#line 1155
  return (tmp);
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void parse_args(int argc , char **argv ) 
{ 
  struct option long_options[33] ;
  int opt ;
  int tmp ;

  {
#line 1168
  long_options[0].name = "address";
#line 1168
  long_options[0].has_arg = 1;
#line 1168
  long_options[0].flag = (int *)0;
#line 1168
  long_options[0].val = 'a';
#line 1168
  long_options[1].name = "cache-file";
#line 1168
  long_options[1].has_arg = 1;
#line 1168
  long_options[1].flag = (int *)0;
#line 1168
  long_options[1].val = 'b';
#line 1168
  long_options[2].name = "config_file";
#line 1168
  long_options[2].has_arg = 1;
#line 1168
  long_options[2].flag = (int *)0;
#line 1168
  long_options[2].val = 'c';
#line 1168
  long_options[3].name = "config-file";
#line 1168
  long_options[3].has_arg = 1;
#line 1168
  long_options[3].flag = (int *)0;
#line 1168
  long_options[3].val = 'c';
#line 1168
  long_options[4].name = "daemon";
#line 1168
  long_options[4].has_arg = 0;
#line 1168
  long_options[4].flag = (int *)0;
#line 1168
  long_options[4].val = 'd';
#line 1168
  long_options[5].name = "debug";
#line 1168
  long_options[5].has_arg = 0;
#line 1168
  long_options[5].flag = (int *)0;
#line 1168
  long_options[5].val = 'D';
#line 1168
  long_options[6].name = "execute";
#line 1168
  long_options[6].has_arg = 1;
#line 1168
  long_options[6].flag = (int *)0;
#line 1168
  long_options[6].val = 'e';
#line 1168
  long_options[7].name = "foreground";
#line 1168
  long_options[7].has_arg = 0;
#line 1168
  long_options[7].flag = (int *)0;
#line 1168
  long_options[7].val = 'f';
#line 1168
  long_options[8].name = "pid-file";
#line 1168
  long_options[8].has_arg = 1;
#line 1168
  long_options[8].flag = (int *)0;
#line 1168
  long_options[8].val = 'F';
#line 1168
  long_options[9].name = "host";
#line 1168
  long_options[9].has_arg = 1;
#line 1168
  long_options[9].flag = (int *)0;
#line 1168
  long_options[9].val = 'h';
#line 1168
  long_options[10].name = "interface";
#line 1168
  long_options[10].has_arg = 1;
#line 1168
  long_options[10].flag = (int *)0;
#line 1168
  long_options[10].val = 'i';
#line 1168
  long_options[11].name = "cloak_title";
#line 1168
  long_options[11].has_arg = 1;
#line 1168
  long_options[11].flag = (int *)0;
#line 1168
  long_options[11].val = 'L';
#line 1168
  long_options[12].name = "mx";
#line 1168
  long_options[12].has_arg = 1;
#line 1168
  long_options[12].flag = (int *)0;
#line 1168
  long_options[12].val = 'm';
#line 1168
  long_options[13].name = "max-interval";
#line 1168
  long_options[13].has_arg = 1;
#line 1168
  long_options[13].flag = (int *)0;
#line 1168
  long_options[13].val = 'M';
#line 1168
  long_options[14].name = "notify-email";
#line 1168
  long_options[14].has_arg = 1;
#line 1168
  long_options[14].flag = (int *)0;
#line 1168
  long_options[14].val = 'N';
#line 1168
  long_options[15].name = "resolv-period";
#line 1168
  long_options[15].has_arg = 1;
#line 1168
  long_options[15].flag = (int *)0;
#line 1168
  long_options[15].val = 'p';
#line 1168
  long_options[16].name = "period";
#line 1168
  long_options[16].has_arg = 1;
#line 1168
  long_options[16].flag = (int *)0;
#line 1168
  long_options[16].val = 'P';
#line 1168
  long_options[17].name = "quiet";
#line 1168
  long_options[17].has_arg = 0;
#line 1168
  long_options[17].flag = (int *)0;
#line 1168
  long_options[17].val = 'q';
#line 1168
  long_options[18].name = "retrys";
#line 1168
  long_options[18].has_arg = 1;
#line 1168
  long_options[18].flag = (int *)0;
#line 1168
  long_options[18].val = 'r';
#line 1168
  long_options[19].name = "run-as-user";
#line 1168
  long_options[19].has_arg = 1;
#line 1168
  long_options[19].flag = (int *)0;
#line 1168
  long_options[19].val = 'R';
#line 1168
  long_options[20].name = "run-as-euser";
#line 1168
  long_options[20].has_arg = 1;
#line 1168
  long_options[20].flag = (int *)0;
#line 1168
  long_options[20].val = 'Q';
#line 1168
  long_options[21].name = "server";
#line 1168
  long_options[21].has_arg = 1;
#line 1168
  long_options[21].flag = (int *)0;
#line 1168
  long_options[21].val = 's';
#line 1168
  long_options[22].name = "service-type";
#line 1168
  long_options[22].has_arg = 1;
#line 1168
  long_options[22].flag = (int *)0;
#line 1168
  long_options[22].val = 'S';
#line 1168
  long_options[23].name = "timeout";
#line 1168
  long_options[23].has_arg = 1;
#line 1168
  long_options[23].flag = (int *)0;
#line 1168
  long_options[23].val = 't';
#line 1168
  long_options[24].name = "connection-type";
#line 1168
  long_options[24].has_arg = 1;
#line 1168
  long_options[24].flag = (int *)0;
#line 1168
  long_options[24].val = 'T';
#line 1168
  long_options[25].name = "url";
#line 1168
  long_options[25].has_arg = 1;
#line 1168
  long_options[25].flag = (int *)0;
#line 1168
  long_options[25].val = 'U';
#line 1168
  long_options[26].name = "user";
#line 1168
  long_options[26].has_arg = 1;
#line 1168
  long_options[26].flag = (int *)0;
#line 1168
  long_options[26].val = 'u';
#line 1168
  long_options[27].name = "wildcard";
#line 1168
  long_options[27].has_arg = 0;
#line 1168
  long_options[27].flag = (int *)0;
#line 1168
  long_options[27].val = 'w';
#line 1168
  long_options[28].name = "help";
#line 1168
  long_options[28].has_arg = 0;
#line 1168
  long_options[28].flag = (int *)0;
#line 1168
  long_options[28].val = 'H';
#line 1168
  long_options[29].name = "version";
#line 1168
  long_options[29].has_arg = 0;
#line 1168
  long_options[29].flag = (int *)0;
#line 1168
  long_options[29].val = 'V';
#line 1168
  long_options[30].name = "credits";
#line 1168
  long_options[30].has_arg = 0;
#line 1168
  long_options[30].flag = (int *)0;
#line 1168
  long_options[30].val = 'C';
#line 1168
  long_options[31].name = "signalhelp";
#line 1168
  long_options[31].has_arg = 0;
#line 1168
  long_options[31].flag = (int *)0;
#line 1168
  long_options[31].val = 'Z';
#line 1168
  long_options[32].name = (char const   *)0;
#line 1168
  long_options[32].has_arg = 0;
#line 1168
  long_options[32].flag = (int *)0;
#line 1168
  long_options[32].val = 0;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1208
    opt = getopt_long(argc, (char * const  *)argv, "a:b:c:dDe:fF:g:h:i:L:m:M:N:o:p:P:qQ:r:R:s:S:t:T:U:u:wHVCZz:",
                      (struct option  const  *)(long_options), (int *)((void *)0));
    }
#line 1208
    if (! (opt != -1)) {
#line 1208
      goto while_break;
    }
    {
#line 1213
    if (opt == 97) {
#line 1213
      goto case_97;
    }
#line 1217
    if (opt == 98) {
#line 1217
      goto case_98;
    }
#line 1221
    if (opt == 99) {
#line 1221
      goto case_99;
    }
#line 1235
    if (opt == 100) {
#line 1235
      goto case_100;
    }
#line 1239
    if (opt == 68) {
#line 1239
      goto case_68;
    }
#line 1243
    if (opt == 101) {
#line 1243
      goto case_101;
    }
#line 1247
    if (opt == 102) {
#line 1247
      goto case_102;
    }
#line 1251
    if (opt == 70) {
#line 1251
      goto case_70;
    }
#line 1255
    if (opt == 103) {
#line 1255
      goto case_103;
    }
#line 1259
    if (opt == 104) {
#line 1259
      goto case_104;
    }
#line 1263
    if (opt == 105) {
#line 1263
      goto case_105;
    }
#line 1267
    if (opt == 76) {
#line 1267
      goto case_76;
    }
#line 1271
    if (opt == 109) {
#line 1271
      goto case_109;
    }
#line 1275
    if (opt == 77) {
#line 1275
      goto case_77;
    }
#line 1279
    if (opt == 78) {
#line 1279
      goto case_78;
    }
#line 1283
    if (opt == 111) {
#line 1283
      goto case_111;
    }
#line 1287
    if (opt == 112) {
#line 1287
      goto case_112;
    }
#line 1291
    if (opt == 80) {
#line 1291
      goto case_80;
    }
#line 1295
    if (opt == 113) {
#line 1295
      goto case_113;
    }
#line 1299
    if (opt == 81) {
#line 1299
      goto case_81;
    }
#line 1303
    if (opt == 114) {
#line 1303
      goto case_114;
    }
#line 1307
    if (opt == 82) {
#line 1307
      goto case_82;
    }
#line 1311
    if (opt == 115) {
#line 1311
      goto case_115;
    }
#line 1315
    if (opt == 83) {
#line 1315
      goto case_83;
    }
#line 1319
    if (opt == 116) {
#line 1319
      goto case_116;
    }
#line 1323
    if (opt == 84) {
#line 1323
      goto case_84;
    }
#line 1327
    if (opt == 117) {
#line 1327
      goto case_117;
    }
#line 1331
    if (opt == 85) {
#line 1331
      goto case_85;
    }
#line 1335
    if (opt == 119) {
#line 1335
      goto case_119;
    }
#line 1339
    if (opt == 72) {
#line 1339
      goto case_72;
    }
#line 1344
    if (opt == 86) {
#line 1344
      goto case_86;
    }
#line 1349
    if (opt == 67) {
#line 1349
      goto case_67;
    }
#line 1354
    if (opt == 90) {
#line 1354
      goto case_90;
    }
#line 1359
    if (opt == 122) {
#line 1359
      goto case_122;
    }
#line 1363
    goto switch_default;
    case_97: /* CIL Label */ 
    {
#line 1214
    option_handler(6, optarg);
    }
#line 1215
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 1218
    option_handler(26, optarg);
    }
#line 1219
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1222
    if (config_file) {
      {
#line 1222
      free((void *)config_file);
      }
    }
    {
#line 1223
    config_file = strdup((char const   *)optarg);
    }
#line 1225
    if (config_file) {
      {
#line 1227
      tmp = parse_conf_file(config_file, conf_commands);
      }
#line 1227
      if (tmp != 0) {
        {
#line 1229
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error parsing config file \"%s\"\n",
                config_file);
#line 1230
        exit(1);
        }
      }
    }
#line 1233
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 1236
    option_handler(17, optarg);
    }
#line 1237
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 1240
    option_handler(18, optarg);
    }
#line 1241
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 1244
    option_handler(19, optarg);
    }
#line 1245
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 1248
    option_handler(20, optarg);
    }
#line 1249
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 1252
    option_handler(28, optarg);
    }
#line 1253
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 1256
    option_handler(4, optarg);
    }
#line 1257
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 1260
    option_handler(11, optarg);
    }
#line 1261
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 1264
    option_handler(13, optarg);
    }
#line 1265
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1268
    option_handler(12, optarg);
    }
#line 1269
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 1272
    option_handler(8, optarg);
    }
#line 1273
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 1276
    option_handler(9, optarg);
    }
#line 1277
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 1280
    option_handler(27, optarg);
    }
#line 1281
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 1284
    option_handler(29, optarg);
    }
#line 1285
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 1288
    option_handler(15, optarg);
    }
#line 1289
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 1292
    option_handler(16, optarg);
    }
#line 1293
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 1296
    option_handler(21, optarg);
    }
#line 1297
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 1300
    option_handler(24, optarg);
    }
#line 1301
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 1304
    option_handler(14, optarg);
    }
#line 1305
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 1308
    option_handler(23, optarg);
    }
#line 1309
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1312
    option_handler(3, optarg);
    }
#line 1313
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 1316
    option_handler(2, optarg);
    }
#line 1317
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1320
    option_handler(22, optarg);
    }
#line 1321
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 1324
    option_handler(25, optarg);
    }
#line 1325
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 1328
    option_handler(5, optarg);
    }
#line 1329
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 1332
    option_handler(10, optarg);
    }
#line 1333
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 1336
    option_handler(7, optarg);
    }
#line 1337
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 1340
    print_usage();
#line 1341
    exit(0);
    }
#line 1342
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 1345
    print_version();
#line 1346
    exit(0);
    }
#line 1347
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 1350
    print_credits();
#line 1351
    exit(0);
    }
#line 1352
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 1355
    print_signalhelp();
#line 1356
    exit(0);
    }
#line 1357
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 1360
    option_handler(30, optarg);
    }
#line 1361
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s --help\' for more information\n",
            *(argv + 0));
#line 1371
    exit(1);
    }
#line 1372
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1375
  return;
}
}
#line 1383 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int do_connect(int *sock , char *host___0 , char *port___0 ) 
{ 
  struct sockaddr_in address___0 ;
  int len ;
  int result ;
  struct hostent *hostinfo ;
  struct servent *servinfo ;
  int tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1392
  tmp = socket(2, 1, 0);
#line 1392
  *sock = tmp;
  }
#line 1392
  if (tmp == -1) {
#line 1394
    if (! (options & 8)) {
      {
#line 1396
      perror("socket");
      }
    }
#line 1398
    return (-1);
  }
  {
#line 1400
  address___0.sin_family = (sa_family_t )2;
#line 1403
  hostinfo = gethostbyname((char const   *)host___0);
  }
#line 1404
  if (! hostinfo) {
#line 1406
    if (! (options & 8)) {
      {
#line 1408
      herror("gethostbyname");
      }
    }
    {
#line 1410
    close(*sock);
    }
#line 1411
    return (-1);
  }
  {
#line 1413
  address___0.sin_addr = *((struct in_addr *)*(hostinfo->h_addr_list));
#line 1416
  servinfo = getservbyname((char const   *)port___0, "tcp");
  }
#line 1417
  if (servinfo) {
#line 1419
    address___0.sin_port = (in_port_t )servinfo->s_port;
  } else {
    {
#line 1423
    tmp___0 = atoi((char const   *)port___0);
#line 1423
    address___0.sin_port = htons((uint16_t )tmp___0);
    }
  }
  {
#line 1427
  len = (int )sizeof(address___0);
#line 1428
  result = connect(*sock, (struct sockaddr  const  *)((struct sockaddr *)(& address___0)),
                   (socklen_t )len);
  }
#line 1428
  if (result == -1) {
#line 1430
    if (! (options & 8)) {
      {
#line 1432
      perror("connect");
      }
    }
    {
#line 1434
    close(*sock);
    }
#line 1435
    return (-1);
  }
#line 1439
  if (! (options & 8)) {
    {
#line 1441
    tmp___1 = ntohs(address___0.sin_port);
#line 1441
    tmp___2 = inet_ntoa(address___0.sin_addr);
#line 1441
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connected to %s (%s) on port %d.\n",
            host___0, tmp___2, (int )tmp___1);
    }
  }
#line 1448
  return (0);
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static char table64[65]  = 
#line 1451
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'\000'};
#line 1453 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void base64Encode(char *intext , char *output___0 ) 
{ 
  unsigned char ibuf[3] ;
  unsigned char obuf[4] ;
  int i ;
  int inputparts ;

  {
  {
#line 1460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1460
    if (! *intext) {
#line 1460
      goto while_break;
    }
#line 1461
    inputparts = 0;
#line 1461
    i = inputparts;
    {
#line 1461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1461
      if (! (i < 3)) {
#line 1461
        goto while_break___0;
      }
#line 1462
      if (*intext) {
#line 1463
        inputparts ++;
#line 1464
        ibuf[i] = (unsigned char )*intext;
#line 1465
        intext ++;
      } else {
#line 1468
        ibuf[i] = (unsigned char)0;
      }
#line 1461
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1471
    obuf[0] = (unsigned char )(((int )ibuf[0] & 252) >> 2);
#line 1472
    obuf[1] = (unsigned char )((((int )ibuf[0] & 3) << 4) | (((int )ibuf[1] & 240) >> 4));
#line 1473
    obuf[2] = (unsigned char )((((int )ibuf[1] & 15) << 2) | (((int )ibuf[2] & 192) >> 6));
#line 1474
    obuf[3] = (unsigned char )((int )ibuf[2] & 63);
    {
#line 1477
    if (inputparts == 1) {
#line 1477
      goto case_1;
    }
#line 1482
    if (inputparts == 2) {
#line 1482
      goto case_2;
    }
#line 1488
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1478
    sprintf((char */* __restrict  */)output___0, (char const   */* __restrict  */)"%c%c==",
            (int )table64[obuf[0]], (int )table64[obuf[1]]);
    }
#line 1481
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1483
    sprintf((char */* __restrict  */)output___0, (char const   */* __restrict  */)"%c%c%c=",
            (int )table64[obuf[0]], (int )table64[obuf[1]], (int )table64[obuf[2]]);
    }
#line 1487
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1489
    sprintf((char */* __restrict  */)output___0, (char const   */* __restrict  */)"%c%c%c%c",
            (int )table64[obuf[0]], (int )table64[obuf[1]], (int )table64[obuf[2]],
            (int )table64[obuf[3]]);
    }
#line 1494
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1496
    output___0 += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 1498
  *output___0 = (char)0;
#line 1499
  return;
}
}
#line 1514 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void output(void *buf___0 ) 
{ 
  fd_set writefds ;
  int max_fd ;
  struct timeval tv ;
  int ret ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 1524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1524
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writefds.__fds_bits[0]): "memory");
#line 1524
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1525
  writefds.__fds_bits[client_sockfd / (int volatile   )(8 * (int )sizeof(__fd_mask ))] |= 1L << client_sockfd % (int volatile   )(8 * (int )sizeof(__fd_mask ));
#line 1526
  max_fd = (int )client_sockfd;
#line 1527
  memcpy((void */* __restrict  */)(& tv), (void const   */* __restrict  */)(& timeout),
         sizeof(struct timeval ));
#line 1529
  ret = select(max_fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& writefds),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 1532
  if (! (ret == -1)) {
#line 1536
    if (ret == 0) {
      {
#line 1538
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"timeout\n");
      }
    } else
#line 1543
    if ((writefds.__fds_bits[client_sockfd / (int volatile   )(8 * (int )sizeof(__fd_mask ))] & (1L << client_sockfd % (int volatile   )(8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 1545
      tmp___1 = strlen((char const   *)buf___0);
#line 1545
      tmp___2 = send((int )client_sockfd, (void const   *)buf___0, tmp___1, 0);
      }
#line 1545
      if (tmp___2 == -1L) {
        {
#line 1547
        tmp = __errno_location();
#line 1547
        tmp___0 = strerror(*tmp);
#line 1547
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error send()ing request: %s\n",
                tmp___0);
        }
      }
    }
  }
#line 1555
  return;
}
}
#line 1557 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int read_input(char *buf___0 , int len ) 
{ 
  fd_set readfds ;
  int max_fd ;
  struct timeval tv ;
  int ret ;
  int bread ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 1563
  bread = -1;
  {
#line 1566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1566
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 1566
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1567
  readfds.__fds_bits[client_sockfd / (int volatile   )(8 * (int )sizeof(__fd_mask ))] |= 1L << client_sockfd % (int volatile   )(8 * (int )sizeof(__fd_mask ));
#line 1568
  max_fd = (int )client_sockfd;
#line 1569
  memcpy((void */* __restrict  */)(& tv), (void const   */* __restrict  */)(& timeout),
         sizeof(struct timeval ));
#line 1571
  ret = select(max_fd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 1574
  if (! (ret == -1)) {
#line 1578
    if (ret == 0) {
      {
#line 1580
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"timeout\n");
      }
    } else
#line 1585
    if ((readfds.__fds_bits[client_sockfd / (int volatile   )(8 * (int )sizeof(__fd_mask ))] & (1L << client_sockfd % (int volatile   )(8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 1587
      tmp = recv((int )client_sockfd, (void *)buf___0, (size_t )(len - 1), 0);
#line 1587
      bread = (int )tmp;
#line 1589
      *(buf___0 + bread) = (char )'\000';
      }
#line 1591
      if (bread == -1) {
        {
#line 1593
        tmp___0 = __errno_location();
#line 1593
        tmp___1 = strerror(*tmp___0);
#line 1593
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error recv()ing reply: %s\n",
                tmp___1);
        }
      }
    }
  }
#line 1602
  return (bread);
}
}
#line 1605 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int get_if_addr(int sock , char *name , struct sockaddr_in *sin ) 
{ 
  struct ifreq ifr ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1610
  memset((void *)(& ifr), 0, sizeof(ifr));
#line 1611
  strcpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)name);
#line 1613
  tmp = ioctl(sock, 35093UL, & ifr);
  }
#line 1613
  if (tmp < 0) {
    {
#line 1615
    perror("ioctl(SIOCGIFADDR)");
#line 1616
    memset((void *)sin, 0, sizeof(struct sockaddr_in ));
    }
#line 1618
    return (-1);
  }
  {
#line 1620
  tmp___0 = ioctl(sock, 35093UL, & ifr);
  }
#line 1620
  if (tmp___0 < 0) {
    {
#line 1622
    perror("ioctl(SIOCGIFADDR)");
#line 1623
    memset((void *)sin, 0, sizeof(struct sockaddr_in ));
    }
#line 1625
    return (-1);
  }
#line 1628
  if ((int )ifr.ifr_ifru.ifru_addr.sa_family == 2) {
    {
#line 1630
    memcpy((void */* __restrict  */)sin, (void const   */* __restrict  */)(& ifr.ifr_ifru.ifru_addr),
           sizeof(struct sockaddr_in ));
    }
#line 1632
    return (0);
  } else {
    {
#line 1636
    memset((void *)sin, 0, sizeof(struct sockaddr_in ));
    }
#line 1638
    return (-1);
  }
#line 1640
  return (-1);
}
}
#line 1646 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static int PGPOW_read_response(char *buf___0 ) 
{ 
  int bytes ;
  int tmp ;

  {
  {
#line 1650
  bytes = read_input(buf___0, 4095);
  }
#line 1651
  if (bytes < 1) {
    {
#line 1653
    close((int )client_sockfd);
    }
#line 1654
    return (-1);
  }
  {
#line 1656
  *(buf___0 + bytes) = (char )'\000';
#line 1660
  tmp = strncmp("OK", (char const   *)buf___0, (size_t )2);
  }
#line 1660
  if (tmp != 0) {
#line 1662
    return (1);
  } else {
#line 1666
    return (0);
  }
}
}
#line 1670 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static int ODS_read_response(char *buf___0 , int len ) 
{ 
  int bytes ;
  int bread ;
  char *p ;
  int max_iter ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1672
  bytes = 0;
#line 1673
  bread = 0;
#line 1674
  p = buf___0;
#line 1675
  max_iter = 32;
  {
#line 1677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1677
    if (bytes < len) {
#line 1677
      if (! (max_iter > 0)) {
#line 1677
        goto while_break;
      }
    } else {
#line 1677
      goto while_break;
    }
    {
#line 1679
    bread = read_input(p, len - bytes);
#line 1680
    bytes += bread;
    }
#line 1681
    if (bytes < 1) {
      {
#line 1683
      close((int )client_sockfd);
      }
#line 1684
      return (-1);
    }
    {
#line 1686
    tmp = strstr((char const   *)buf___0, "\r\n");
    }
#line 1686
    if ((unsigned long )tmp > 0UL) {
#line 1688
      goto while_break;
    }
#line 1692
    p += bread;
#line 1677
    max_iter --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1696
  tmp___0 = atoi((char const   *)buf___0);
  }
#line 1696
  return (tmp___0);
}
}
#line 1699 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int NULL_check_info(void) 
{ 
  char buf___0[64] ;

  {
#line 1703
  if (options & 4) {
    {
#line 1705
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no compile time default service was set therefor you must specify a service type.\n");
    }
#line 1708
    return (-1);
  }
  {
#line 1710
  printf((char const   */* __restrict  */)"service: ");
#line 1711
  buf___0[0] = (char )'\000';
#line 1712
  fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)stdin);
#line 1713
  chomp(buf___0);
#line 1714
  option_handler(2, buf___0);
  }
#line 1716
  return (0);
}
}
#line 1719 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int EZIP_check_info(void) 
{ 


  {
  {
#line 1721
  warn_fields(service->fields_used);
  }
#line 1723
  return (0);
}
}
#line 1726 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int EZIP_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1729
  bp = buf___0;
#line 1734
  buf___0[4095] = (char )'\000';
#line 1736
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 1736
  if (tmp != 0) {
#line 1738
    if (! (options & 8)) {
      {
#line 1740
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 1742
    return (1);
  }
  {
#line 1745
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?mode=update&",
           request);
#line 1746
  output((void *)(buf___0));
  }
#line 1747
  if (address) {
    {
#line 1749
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
             "ipaddress", address);
#line 1750
    output((void *)(buf___0));
    }
  }
#line 1752
  if (wildcard) {
#line 1752
    tmp___0 = "yes";
  } else {
#line 1752
    tmp___0 = "no";
  }
  {
#line 1752
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "wildcard", tmp___0);
#line 1753
  output((void *)(buf___0));
#line 1754
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "mx", mx);
#line 1755
  output((void *)(buf___0));
#line 1756
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "url", url);
#line 1757
  output((void *)(buf___0));
#line 1758
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "host", host);
#line 1759
  output((void *)(buf___0));
#line 1760
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 1761
  output((void *)(buf___0));
#line 1762
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
           auth);
#line 1763
  output((void *)(buf___0));
  }
#line 1764
  if (options & 4) {
#line 1764
    tmp___1 = "daemon";
  } else {
#line 1764
    tmp___1 = "";
  }
  {
#line 1764
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___1, "by Angus Mackay");
#line 1766
  output((void *)(buf___0));
#line 1767
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 1768
  output((void *)(buf___0));
#line 1769
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 1770
  output((void *)(buf___0));
#line 1772
  bp = buf___0;
#line 1773
  bytes = 0;
#line 1774
  btot = 0;
  }
  {
#line 1775
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1775
    bytes = read_input(bp, 4095 - btot);
    }
#line 1775
    if (! (bytes > 0)) {
#line 1775
      goto while_break;
    }
#line 1777
    bp += bytes;
#line 1778
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1781
  close((int )client_sockfd);
#line 1782
  buf___0[btot] = (char )'\000';
#line 1786
  tmp___2 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 1786
  if (tmp___2 != 1) {
#line 1788
    ret = -1;
  }
  {
#line 1793
  if (ret == -1) {
#line 1793
    goto case_neg_1;
  }
#line 1801
  if (ret == 200) {
#line 1801
    goto case_200;
  }
#line 1808
  if (ret == 401) {
#line 1808
    goto case_401;
  }
#line 1816
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 1794
  if (! (options & 8)) {
    {
#line 1796
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 1798
  return (1);
#line 1799
  goto switch_break;
  case_200: /* CIL Label */ 
#line 1802
  if (! (options & 8)) {
    {
#line 1804
    printf((char const   */* __restrict  */)"request successful\n");
    }
  }
#line 1806
  goto switch_break;
  case_401: /* CIL Label */ 
#line 1809
  if (! (options & 8)) {
    {
#line 1811
    show_message((char *)"authentication failure\n");
    }
  }
#line 1813
  return (2);
#line 1814
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1817
  if (! (options & 8)) {
    {
#line 1820
    auth[0] = (char )'\000';
#line 1821
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 1822
    show_message((char *)"unknown return code: %d\n", ret);
#line 1823
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server response: %s\n",
            auth);
    }
  }
#line 1825
  return (1);
#line 1826
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1829
  return (0);
}
}
#line 1832 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void DYNDNS_init(void) 
{ 


  {
#line 1835
  if (options & 4) {
#line 1837
    if (! (max_interval > 0)) {
#line 1839
      max_interval = 2160000;
    }
  }
#line 1842
  return;
}
}
#line 1844 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int DYNDNS_check_info(void) 
{ 
  char buf___0[8193] ;
  int tmp ;

  {
#line 1848
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1848
    goto _L;
  } else
#line 1848
  if ((int )*host == 0) {
    _L: /* CIL Label */ 
#line 1850
    if (options & 4) {
#line 1852
      return (-1);
    }
#line 1854
    if (host) {
      {
#line 1854
      free((void *)host);
      }
    }
    {
#line 1855
    printf((char const   */* __restrict  */)"host: ");
#line 1856
    buf___0[0] = (char )'\000';
#line 1857
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 1858
    host = strdup((char const   *)(buf___0));
#line 1859
    chomp(host);
    }
  }
#line 1862
  if ((unsigned long )address != (unsigned long )((void *)0)) {
    {
#line 1862
    tmp = is_dotted_quad(address);
    }
#line 1862
    if (! tmp) {
      {
#line 1864
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"the IP address \"%s\" is invalid\n",
              address);
      }
#line 1865
      return (-1);
    }
  }
#line 1868
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 1868
    if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 1870
      if (options & 4) {
        {
#line 1872
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
        }
#line 1873
        return (-1);
      }
#line 1875
      if (interface) {
        {
#line 1875
        free((void *)interface);
        }
      }
      {
#line 1876
      printf((char const   */* __restrict  */)"interface: ");
#line 1877
      buf___0[0] = (char )'\000';
#line 1878
      fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 1879
      chomp(buf___0);
#line 1880
      option_handler(13, buf___0);
      }
    }
  }
  {
#line 1883
  warn_fields(service->fields_used);
  }
#line 1885
  return (0);
}
}
#line 2021
extern int ( /* missing proto */  time)() ;
#line 1888 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int DYNDNS_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *p ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int howlong ;
  char *p___0 ;
  char *tmp___8 ;
  char reason[256] ;
  char mult ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
  {
#line 1891
  bp = buf___0;
#line 1895
  retval = 0;
#line 1897
  buf___0[4095] = (char )'\000';
#line 1899
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 1899
  if (tmp != 0) {
#line 1901
    if (! (options & 8)) {
      {
#line 1903
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 1905
    return (1);
  }
  {
#line 1908
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?",
           request);
#line 1909
  output((void *)(buf___0));
#line 1911
  tmp___1 = is_in_list((char *)"dyndns-static", service->names);
  }
#line 1911
  if (tmp___1) {
    {
#line 1913
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
             "system", "statdns");
#line 1914
    output((void *)(buf___0));
    }
  } else {
    {
#line 1916
    tmp___0 = is_in_list((char *)"dyndns-custom", service->names);
    }
#line 1916
    if (tmp___0) {
      {
#line 1918
      snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
               "system", "custom");
#line 1919
      output((void *)(buf___0));
      }
    }
  }
  {
#line 1922
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "hostname", host);
#line 1923
  output((void *)(buf___0));
  }
#line 1924
  if ((unsigned long )address != (unsigned long )((void *)0)) {
    {
#line 1926
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
             "myip", address);
#line 1927
    output((void *)(buf___0));
    }
  }
#line 1929
  if (wildcard) {
#line 1929
    tmp___2 = "ON";
  } else {
#line 1929
    tmp___2 = "OFF";
  }
  {
#line 1929
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "wildcard", tmp___2);
#line 1930
  output((void *)(buf___0));
  }
#line 1931
  if ((unsigned long )mx != (unsigned long )((void *)0)) {
#line 1931
    if ((int )*mx != 0) {
      {
#line 1933
      snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
               "mx", mx);
#line 1934
      output((void *)(buf___0));
      }
    }
  }
#line 1938
  if (options & 32) {
    {
#line 1940
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
             "offline", "yes");
#line 1941
    output((void *)(buf___0));
    }
  }
  {
#line 1943
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 1944
  output((void *)(buf___0));
#line 1945
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
           auth);
#line 1946
  output((void *)(buf___0));
  }
#line 1947
  if (options & 4) {
#line 1947
    tmp___3 = "daemon";
  } else {
#line 1947
    tmp___3 = "";
  }
  {
#line 1947
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___3, "by Angus Mackay");
#line 1949
  output((void *)(buf___0));
#line 1950
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 1951
  output((void *)(buf___0));
#line 1952
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 1953
  output((void *)(buf___0));
#line 1955
  bp = buf___0;
#line 1956
  bytes = 0;
#line 1957
  btot = 0;
  }
  {
#line 1958
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1958
    bytes = read_input(bp, 4095 - btot);
    }
#line 1958
    if (! (bytes > 0)) {
#line 1958
      goto while_break;
    }
#line 1960
    bp += bytes;
#line 1961
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1964
  close((int )client_sockfd);
#line 1965
  buf___0[btot] = (char )'\000';
#line 1969
  tmp___4 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 1969
  if (tmp___4 != 1) {
#line 1971
    ret = -1;
  }
  {
#line 1976
  if (ret == -1) {
#line 1976
    goto case_neg_1;
  }
#line 1984
  if (ret == 200) {
#line 1984
    goto case_200;
  }
#line 2116
  if (ret == 401) {
#line 2116
    goto case_401;
  }
#line 2124
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 1977
  if (! (options & 8)) {
    {
#line 1979
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 1981
  retval = 1;
#line 1982
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 1985
  tmp___26 = strstr((char const   *)(buf___0), "\ngood ");
  }
#line 1985
  if ((unsigned long )tmp___26 != (unsigned long )((void *)0)) {
#line 1987
    if (! (options & 8)) {
      {
#line 1989
      printf((char const   */* __restrict  */)"request successful\n");
      }
    }
  } else {
    {
#line 1994
    tmp___25 = strstr((char const   *)(buf___0), "\nnohost");
    }
#line 1994
    if ((unsigned long )tmp___25 != (unsigned long )((void *)0)) {
      {
#line 1996
      show_message((char *)"invalid hostname: %s\n", host);
#line 1997
      retval = 2;
      }
    } else {
      {
#line 1999
      tmp___24 = strstr((char const   *)(buf___0), "\nnotfqdn");
      }
#line 1999
      if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
        {
#line 2001
        show_message((char *)"malformed hostname: %s\n", host);
#line 2002
        retval = 2;
        }
      } else {
        {
#line 2004
        tmp___23 = strstr((char const   *)(buf___0), "\n!yours");
        }
#line 2004
        if ((unsigned long )tmp___23 != (unsigned long )((void *)0)) {
          {
#line 2006
          show_message((char *)"host \"%s\" is not under your control\n", host);
#line 2007
          retval = 2;
          }
        } else {
          {
#line 2009
          tmp___22 = strstr((char const   *)(buf___0), "\nabuse");
          }
#line 2009
          if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
            {
#line 2011
            show_message((char *)"host \"%s\" has been blocked for abuse\n", host);
#line 2012
            retval = 2;
            }
          } else {
            {
#line 2014
            tmp___21 = strstr((char const   *)(buf___0), "\nnochg");
            }
#line 2014
            if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
              {
#line 2016
              show_message((char *)"%s says that your IP address has not changed since the last update\n",
                           server);
              }
#line 2019
              if (max_interval > 0) {
                {
#line 2021
                tmp___5 = time((void *)0);
#line 2021
                last_update = (time_t )(tmp___5 - max_interval / 2);
                }
              }
#line 2023
              retval = 0;
            } else {
              {
#line 2025
              tmp___20 = strstr((char const   *)(buf___0), "\nbadauth");
              }
#line 2025
              if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
                {
#line 2027
                show_message((char *)"authentication failure\n");
#line 2028
                retval = 2;
                }
              } else {
                {
#line 2030
                tmp___19 = strstr((char const   *)(buf___0), "\nbadsys");
                }
#line 2030
                if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
                  {
#line 2032
                  show_message((char *)"invalid system parameter\n");
#line 2033
                  retval = 2;
                  }
                } else {
                  {
#line 2035
                  tmp___18 = strstr((char const   *)(buf___0), "\nbadagent");
                  }
#line 2035
                  if ((unsigned long )tmp___18 != (unsigned long )((void *)0)) {
                    {
#line 2037
                    show_message((char *)"this useragent has been blocked\n");
#line 2038
                    retval = 2;
                    }
                  } else {
                    {
#line 2040
                    tmp___17 = strstr((char const   *)(buf___0), "\nnumhost");
                    }
#line 2040
                    if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
                      {
#line 2042
                      show_message((char *)"Too many or too few hosts found\n");
#line 2043
                      retval = 2;
                      }
                    } else {
                      {
#line 2045
                      tmp___16 = strstr((char const   *)(buf___0), "\ndnserr");
                      }
#line 2045
                      if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
                        {
#line 2047
                        tmp___6 = strstr((char const   *)(buf___0), "\ndnserr");
#line 2047
                        p = tmp___6;
                        }
#line 2048
                        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2048
                          tmp___7 = "(null)";
                        } else {
#line 2048
                          tmp___7 = (char const   *)p;
                        }
                        {
#line 2048
                        show_message((char *)"dyndns internal error, please report this number to their support people: %s\n",
                                     tmp___7);
#line 2050
                        retval = 1;
                        }
                      } else {
                        {
#line 2052
                        tmp___15 = strstr((char const   *)(buf___0), "\n911");
                        }
#line 2052
                        if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
                          {
#line 2054
                          show_message((char *)"Ahhhh! call 911!\n");
#line 2055
                          retval = 2;
                          }
                        } else {
                          {
#line 2057
                          tmp___14 = strstr((char const   *)(buf___0), "\n999");
                          }
#line 2057
                          if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
                            {
#line 2059
                            show_message((char *)"Ahhhh! call 999!\n");
#line 2060
                            retval = 2;
                            }
                          } else {
                            {
#line 2062
                            tmp___13 = strstr((char const   *)(buf___0), "\n!donator");
                            }
#line 2062
                            if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
                              {
#line 2064
                              show_message((char *)"a feature requested is only available to donators, please donate.\n",
                                           host);
#line 2065
                              retval = 0;
                              }
                            } else {
                              {
#line 2069
                              tmp___12 = strstr((char const   *)(buf___0), "\nw");
                              }
#line 2069
                              if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
                                {
#line 2071
                                howlong = 0;
#line 2072
                                tmp___8 = strstr((char const   *)(buf___0), "\nw");
#line 2072
                                p___0 = tmp___8;
#line 2077
                                tmp___9 = strlen((char const   *)p___0);
                                }
#line 2077
                                if (tmp___9 >= 2UL) {
                                  {
#line 2079
                                  sscanf((char const   */* __restrict  */)p___0, (char const   */* __restrict  */)"%d%c %255[^\r\n]",
                                         & howlong, & mult, reason);
                                  }
#line 2080
                                  if ((int )mult == 104) {
#line 2082
                                    howlong *= 3600;
                                  } else
#line 2084
                                  if ((int )mult == 109) {
#line 2086
                                    howlong *= 60;
                                  }
#line 2088
                                  if (howlong > 86400) {
#line 2090
                                    howlong = 86400;
                                  }
                                } else {
                                  {
#line 2095
                                  sprintf((char */* __restrict  */)(reason), (char const   */* __restrict  */)"problem parsing reason for wait response");
                                  }
                                }
                                {
#line 2098
                                tmp___10 = format_time(howlong);
#line 2098
                                show_message((char *)"Wait response received, waiting for %s before next update.\n",
                                             tmp___10);
                                }
#line 2100
                                if ((unsigned long )(reason) == (unsigned long )((void *)0)) {
#line 2100
                                  tmp___11 = "(null)";
                                } else {
#line 2100
                                  tmp___11 = (char const   *)(reason);
                                }
                                {
#line 2100
                                show_message((char *)"Wait response reason: %d\n",
                                             tmp___11);
#line 2101
                                sleep((unsigned int )howlong);
#line 2102
                                retval = 1;
                                }
                              } else {
                                {
#line 2106
                                show_message((char *)"error processing request\n");
                                }
#line 2107
                                if (! (options & 8)) {
                                  {
#line 2109
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"==== server output: ====\n%s\n",
                                          buf___0);
                                  }
                                }
#line 2111
                                retval = 1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2114
  goto switch_break;
  case_401: /* CIL Label */ 
#line 2117
  if (! (options & 8)) {
    {
#line 2119
    show_message((char *)"authentication failure\n");
    }
  }
#line 2121
  retval = 2;
#line 2122
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2125
  if (! (options & 8)) {
    {
#line 2128
    auth[0] = (char )'\000';
#line 2129
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 2130
    show_message((char *)"unknown return code: %d\n", ret);
#line 2131
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server response: %s\n",
            auth);
    }
  }
#line 2133
  retval = 1;
#line 2134
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2137
  return (retval);
}
}
#line 2140 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int PGPOW_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 2144
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 2144
    goto _L;
  } else
#line 2144
  if ((int )*host == 0) {
    _L: /* CIL Label */ 
#line 2146
    if (options & 4) {
#line 2148
      return (-1);
    }
#line 2150
    if (host) {
      {
#line 2150
      free((void *)host);
      }
    }
    {
#line 2151
    printf((char const   */* __restrict  */)"host: ");
#line 2152
    buf___0[0] = (char )'\000';
#line 2153
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 2154
    host = strdup((char const   *)(buf___0));
#line 2155
    chomp(host);
    }
  }
#line 2158
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 2158
    if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 2160
      if (options & 4) {
        {
#line 2162
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
        }
#line 2163
        return (-1);
      }
#line 2165
      if (interface) {
        {
#line 2165
        free((void *)interface);
        }
      }
      {
#line 2166
      printf((char const   */* __restrict  */)"interface: ");
#line 2167
      buf___0[0] = (char )'\000';
#line 2168
      fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 2169
      chomp(buf___0);
#line 2170
      option_handler(13, buf___0);
      }
    }
  }
  {
#line 2173
  warn_fields(service->fields_used);
  }
#line 2175
  return (0);
}
}
#line 2178 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int PGPOW_update_entry(void) 
{ 
  char buf___0[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 2182
  buf___0[4095] = (char )'\000';
#line 2184
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 2184
  if (tmp != 0) {
#line 2186
    if (! (options & 8)) {
      {
#line 2188
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 2190
    return (1);
  }
  {
#line 2194
  tmp___0 = PGPOW_read_response(buf___0);
  }
#line 2194
  if (tmp___0 != 0) {
    {
#line 2196
    show_message((char *)"strange server response, are you connecting to the right server?\n");
#line 2197
    close((int )client_sockfd);
    }
#line 2198
    return (1);
  }
  {
#line 2202
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"VER %s [%s-%s %s (%s)]\r\n",
           "1.0", "ez-update", "3.0.11b8", "", "by Angus Mackay");
#line 2204
  output((void *)(buf___0));
#line 2206
  tmp___2 = PGPOW_read_response(buf___0);
  }
#line 2206
  if (tmp___2 != 0) {
    {
#line 2208
    tmp___1 = strncmp("ERR", (char const   *)(buf___0), (size_t )3);
    }
#line 2208
    if (tmp___1 == 0) {
      {
#line 2210
      show_message((char *)"error talking to server: %s\n", & buf___0[3]);
      }
    } else {
      {
#line 2214
      show_message((char *)"error talking to server:\n\t%s\n", buf___0);
      }
    }
    {
#line 2216
    close((int )client_sockfd);
    }
#line 2217
    return (1);
  }
  {
#line 2221
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"USER %s\r\n",
           user_name);
#line 2222
  output((void *)(buf___0));
#line 2224
  tmp___4 = PGPOW_read_response(buf___0);
  }
#line 2224
  if (tmp___4 != 0) {
    {
#line 2226
    tmp___3 = strncmp("ERR", (char const   *)(buf___0), (size_t )3);
    }
#line 2226
    if (tmp___3 == 0) {
      {
#line 2228
      show_message((char *)"error talking to server: %s\n", & buf___0[3]);
      }
    } else {
      {
#line 2232
      show_message((char *)"error talking to server:\n\t%s\n", buf___0);
      }
    }
    {
#line 2234
    close((int )client_sockfd);
    }
#line 2235
    return (1);
  }
  {
#line 2239
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"PASS %s\r\n",
           password);
#line 2240
  output((void *)(buf___0));
#line 2242
  tmp___6 = PGPOW_read_response(buf___0);
  }
#line 2242
  if (tmp___6 != 0) {
    {
#line 2244
    tmp___5 = strncmp("ERR", (char const   *)(buf___0), (size_t )3);
    }
#line 2244
    if (tmp___5 == 0) {
      {
#line 2246
      show_message((char *)"error talking to server: %s\n", & buf___0[3]);
      }
    } else {
      {
#line 2250
      show_message((char *)"error talking to server:\n\t%s\n", buf___0);
      }
    }
    {
#line 2252
    close((int )client_sockfd);
    }
#line 2253
    return (1);
  }
  {
#line 2257
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"HOST %s\r\n",
           host);
#line 2258
  output((void *)(buf___0));
#line 2260
  tmp___8 = PGPOW_read_response(buf___0);
  }
#line 2260
  if (tmp___8 != 0) {
    {
#line 2262
    tmp___7 = strncmp("ERR", (char const   *)(buf___0), (size_t )3);
    }
#line 2262
    if (tmp___7 == 0) {
      {
#line 2264
      show_message((char *)"error talking to server: %s\n", & buf___0[3]);
      }
    } else {
      {
#line 2268
      show_message((char *)"error talking to server:\n\t%s\n", buf___0);
      }
    }
    {
#line 2270
    close((int )client_sockfd);
    }
#line 2271
    return (1);
  }
  {
#line 2275
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"OPER %s\r\n",
           request);
#line 2276
  output((void *)(buf___0));
#line 2278
  tmp___10 = PGPOW_read_response(buf___0);
  }
#line 2278
  if (tmp___10 != 0) {
    {
#line 2280
    tmp___9 = strncmp("ERR", (char const   *)(buf___0), (size_t )3);
    }
#line 2280
    if (tmp___9 == 0) {
      {
#line 2282
      show_message((char *)"error talking to server: %s\n", & buf___0[3]);
      }
    } else {
      {
#line 2286
      show_message((char *)"error talking to server:\n\t%s\n", buf___0);
      }
    }
    {
#line 2288
    close((int )client_sockfd);
    }
#line 2289
    return (1);
  }
  {
#line 2292
  tmp___13 = strcmp("update", (char const   *)request);
  }
#line 2292
  if (tmp___13 == 0) {
    {
#line 2295
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"IP %s\r\n",
             address);
#line 2296
    output((void *)(buf___0));
#line 2298
    tmp___12 = PGPOW_read_response(buf___0);
    }
#line 2298
    if (tmp___12 != 0) {
      {
#line 2300
      tmp___11 = strncmp("ERR", (char const   *)(buf___0), (size_t )3);
      }
#line 2300
      if (tmp___11 == 0) {
        {
#line 2302
        show_message((char *)"error talking to server: %s\n", & buf___0[3]);
        }
      } else {
        {
#line 2306
        show_message((char *)"error talking to server:\n\t%s\n", buf___0);
        }
      }
      {
#line 2308
      close((int )client_sockfd);
      }
#line 2309
      return (1);
    }
  }
  {
#line 2314
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"DONE\r\n");
#line 2315
  output((void *)(buf___0));
#line 2317
  tmp___15 = PGPOW_read_response(buf___0);
  }
#line 2317
  if (tmp___15 != 0) {
    {
#line 2319
    tmp___14 = strncmp("ERR", (char const   *)(buf___0), (size_t )3);
    }
#line 2319
    if (tmp___14 == 0) {
      {
#line 2321
      show_message((char *)"error talking to server: %s\n", & buf___0[3]);
      }
    } else {
      {
#line 2325
      show_message((char *)"error talking to server:\n\t%s\n", buf___0);
      }
    }
    {
#line 2327
    close((int )client_sockfd);
    }
#line 2328
    return (1);
  }
#line 2331
  if (! (options & 8)) {
    {
#line 2333
    printf((char const   */* __restrict  */)"request successful\n");
    }
  }
  {
#line 2336
  close((int )client_sockfd);
  }
#line 2337
  return (0);
}
}
#line 2340 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int DHS_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 2344
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 2344
    goto _L;
  } else
#line 2344
  if ((int )*host == 0) {
    _L: /* CIL Label */ 
#line 2346
    if (options & 4) {
#line 2348
      return (-1);
    }
#line 2350
    if (host) {
      {
#line 2350
      free((void *)host);
      }
    }
    {
#line 2351
    printf((char const   */* __restrict  */)"host: ");
#line 2352
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 2353
    host = strdup((char const   *)(buf___0));
#line 2354
    chomp(host);
    }
  }
#line 2357
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 2357
    if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 2359
      if (options & 4) {
        {
#line 2361
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
        }
#line 2362
        return (-1);
      }
#line 2364
      if (interface) {
        {
#line 2364
        free((void *)interface);
        }
      }
      {
#line 2365
      printf((char const   */* __restrict  */)"interface: ");
#line 2366
      buf___0[0] = (char )'\000';
#line 2367
      fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 2368
      chomp(buf___0);
#line 2369
      option_handler(13, buf___0);
      }
    }
  }
  {
#line 2372
  warn_fields(service->fields_used);
  }
#line 2374
  return (0);
}
}
#line 2383 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int DHS_update_entry(void) 
{ 
  char buf___0[4096] ;
  char putbuf[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  char *domain ;
  char *hostname ;
  char *p ;
  int limit ;
  int retval ;
  int tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  __time_t tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  size_t tmp___50 ;
  size_t tmp___51 ;
  size_t tmp___52 ;
  int tmp___53 ;

  {
  {
#line 2387
  bp = buf___0;
#line 2391
  domain = (char *)((void *)0);
#line 2392
  hostname = (char *)((void *)0);
#line 2395
  retval = 0;
#line 2397
  buf___0[4095] = (char )'\000';
#line 2398
  putbuf[4095] = (char )'\000';
#line 2401
  hostname = strdup((char const   *)host);
#line 2402
  p = strchr((char const   *)hostname, '.');
  }
#line 2402
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2404
    if (! (options & 8)) {
      {
#line 2406
      show_message((char *)"error parsing hostname from host %s\n", host);
      }
    }
#line 2408
    return (1);
  }
#line 2410
  *p = (char )'\000';
#line 2411
  p ++;
#line 2412
  if ((int )*p == 0) {
#line 2414
    if (! (options & 8)) {
      {
#line 2416
      show_message((char *)"error parsing domain from host %s\n", host);
      }
    }
#line 2418
    return (1);
  }
  {
#line 2420
  domain = strdup((char const   *)p);
#line 2424
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 2424
  if (tmp != 0) {
#line 2426
    if (! (options & 8)) {
      {
#line 2428
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 2430
    return (1);
  }
  {
#line 2433
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"POST %s HTTP/1.0\r\n",
           request);
#line 2434
  output((void *)(buf___0));
#line 2435
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
           auth);
#line 2436
  output((void *)(buf___0));
  }
#line 2437
  if (options & 4) {
#line 2437
    tmp___0 = "daemon";
  } else {
#line 2437
    tmp___0 = "";
  }
  {
#line 2437
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___0, "by Angus Mackay");
#line 2439
  output((void *)(buf___0));
#line 2440
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 2441
  output((void *)(buf___0));
#line 2443
  p = putbuf;
#line 2444
  *p = (char )'\000';
#line 2445
  tmp___1 = strlen((char const   *)(buf___0));
#line 2445
  limit = (int )(4094UL - tmp___1);
#line 2446
  snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"hostscmd=edit&hostscmdstage=2&type=4&");
#line 2447
  tmp___2 = strlen((char const   *)p);
#line 2447
  p += tmp___2;
#line 2448
  tmp___3 = strlen((char const   *)(buf___0));
#line 2448
  limit = (int )(4094UL - tmp___3);
#line 2449
  snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
           "updatetype", "Online");
#line 2450
  tmp___4 = strlen((char const   *)p);
#line 2450
  p += tmp___4;
#line 2451
  tmp___5 = strlen((char const   *)(buf___0));
#line 2451
  limit = (int )(4094UL - tmp___5);
#line 2452
  snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
           "ip", address);
#line 2453
  tmp___6 = strlen((char const   *)p);
#line 2453
  p += tmp___6;
#line 2454
  tmp___7 = strlen((char const   *)(buf___0));
#line 2454
  limit = (int )(4094UL - tmp___7);
#line 2455
  snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
           "mx", mx);
#line 2456
  tmp___8 = strlen((char const   *)p);
#line 2456
  p += tmp___8;
#line 2457
  tmp___9 = strlen((char const   *)(buf___0));
#line 2457
  limit = (int )(4094UL - tmp___9);
#line 2458
  snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
           "offline_url", url);
#line 2459
  tmp___10 = strlen((char const   *)p);
#line 2459
  p += tmp___10;
#line 2460
  tmp___11 = strlen((char const   *)(buf___0));
#line 2460
  limit = (int )(4094UL - tmp___11);
  }
#line 2461
  if (cloak_title) {
    {
#line 2463
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
             "cloak", "Y");
#line 2464
    tmp___12 = strlen((char const   *)p);
#line 2464
    p += tmp___12;
#line 2465
    tmp___13 = strlen((char const   *)(buf___0));
#line 2465
    limit = (int )(4094UL - tmp___13);
#line 2466
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
             "cloak_title", cloak_title);
#line 2467
    tmp___14 = strlen((char const   *)p);
#line 2467
    p += tmp___14;
#line 2468
    tmp___15 = strlen((char const   *)(buf___0));
#line 2468
    limit = (int )(4094UL - tmp___15);
    }
  } else {
    {
#line 2472
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
             "cloak_title", "");
#line 2473
    tmp___16 = strlen((char const   *)p);
#line 2473
    p += tmp___16;
#line 2474
    tmp___17 = strlen((char const   *)(buf___0));
#line 2474
    limit = (int )(4094UL - tmp___17);
    }
  }
  {
#line 2476
  snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
           "submit", "Update");
#line 2477
  tmp___18 = strlen((char const   *)p);
#line 2477
  p += tmp___18;
#line 2478
  tmp___19 = strlen((char const   *)(buf___0));
#line 2478
  limit = (int )(4094UL - tmp___19);
#line 2479
  snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
           "domain", domain);
#line 2480
  tmp___20 = strlen((char const   *)p);
#line 2480
  p += tmp___20;
#line 2481
  tmp___21 = strlen((char const   *)(buf___0));
#line 2481
  limit = (int )(4094UL - tmp___21);
#line 2482
  snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s",
           "hostname", hostname);
#line 2483
  tmp___22 = strlen((char const   *)p);
#line 2483
  p += tmp___22;
#line 2484
  tmp___23 = strlen((char const   *)(buf___0));
#line 2484
  limit = (int )(4094UL - tmp___23);
#line 2486
  tmp___24 = strlen((char const   *)(putbuf));
#line 2486
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Content-length: %d\r\n",
           tmp___24);
#line 2487
  output((void *)(buf___0));
#line 2488
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 2489
  output((void *)(buf___0));
#line 2491
  output((void *)(putbuf));
#line 2492
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 2493
  output((void *)(buf___0));
#line 2495
  bp = buf___0;
#line 2496
  bytes = 0;
#line 2497
  btot = 0;
  }
  {
#line 2498
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2498
    bytes = read_input(bp, 4095 - btot);
    }
#line 2498
    if (! (bytes > 0)) {
#line 2498
      goto while_break;
    }
#line 2500
    bp += bytes;
#line 2501
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2504
  close((int )client_sockfd);
#line 2505
  buf___0[btot] = (char )'\000';
#line 2509
  tmp___25 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                    & ret);
  }
#line 2509
  if (tmp___25 != 1) {
#line 2511
    ret = -1;
  }
  {
#line 2516
  if (ret == -1) {
#line 2516
    goto case_neg_1;
  }
#line 2524
  if (ret == 200) {
#line 2524
    goto case_200;
  }
#line 2531
  if (ret == 401) {
#line 2531
    goto case_401;
  }
#line 2539
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 2517
  if (! (options & 8)) {
    {
#line 2519
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 2521
  retval = 1;
#line 2522
  goto switch_break;
  case_200: /* CIL Label */ 
#line 2525
  if (! (options & 8)) {
    {
#line 2527
    printf((char const   */* __restrict  */)"request successful\n");
    }
  }
#line 2529
  goto switch_break;
  case_401: /* CIL Label */ 
#line 2532
  if (! (options & 8)) {
    {
#line 2534
    show_message((char *)"authentication failure\n");
    }
  }
#line 2536
  retval = 2;
#line 2537
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2540
  if (! (options & 8)) {
    {
#line 2543
    auth[0] = (char )'\000';
#line 2544
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 2545
    show_message((char *)"unknown return code: %d\n", ret);
#line 2546
    show_message((char *)"server response: %s\n", auth);
    }
  }
#line 2548
  retval = 1;
#line 2549
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2554
  if ((int )*mx != 0) {
#line 2559
    if (60L < timeout.tv_sec) {
#line 2559
      tmp___26 = (__time_t )60;
    } else {
#line 2559
      tmp___26 = timeout.tv_sec;
    }
    {
#line 2559
    sleep((unsigned int )tmp___26);
#line 2561
    tmp___27 = do_connect((int *)(& client_sockfd), server, port);
    }
#line 2561
    if (tmp___27 != 0) {
#line 2563
      if (! (options & 8)) {
        {
#line 2565
        show_message((char *)"error connecting to %s:%s\n", server, port);
        }
      }
#line 2567
      return (1);
    }
    {
#line 2570
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"POST %s HTTP/1.0\r\n",
             request);
#line 2571
    output((void *)(buf___0));
#line 2572
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
             auth);
#line 2573
    output((void *)(buf___0));
    }
#line 2574
    if (options & 4) {
#line 2574
      tmp___28 = "daemon";
    } else {
#line 2574
      tmp___28 = "";
    }
    {
#line 2574
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
             "ez-update", "3.0.11b8", "", tmp___28, "by Angus Mackay");
#line 2576
    output((void *)(buf___0));
#line 2577
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
             server);
#line 2578
    output((void *)(buf___0));
#line 2580
    p = putbuf;
#line 2581
    *p = (char )'\000';
#line 2582
    tmp___29 = strlen((char const   *)(buf___0));
#line 2582
    limit = (int )(4094UL - tmp___29);
#line 2583
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"hostscmd=edit&hostscmdstage=2&type=4&");
#line 2584
    tmp___30 = strlen((char const   *)p);
#line 2584
    p += tmp___30;
#line 2585
    tmp___31 = strlen((char const   *)(buf___0));
#line 2585
    limit = (int )(4094UL - tmp___31);
#line 2586
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
             "updatetype", "Update+Mail+Exchanger");
#line 2587
    tmp___32 = strlen((char const   *)p);
#line 2587
    p += tmp___32;
#line 2588
    tmp___33 = strlen((char const   *)(buf___0));
#line 2588
    limit = (int )(4094UL - tmp___33);
#line 2589
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
             "ip", address);
#line 2590
    tmp___34 = strlen((char const   *)p);
#line 2590
    p += tmp___34;
#line 2591
    tmp___35 = strlen((char const   *)(buf___0));
#line 2591
    limit = (int )(4094UL - tmp___35);
#line 2592
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
             "mx", mx);
#line 2593
    tmp___36 = strlen((char const   *)p);
#line 2593
    p += tmp___36;
#line 2594
    tmp___37 = strlen((char const   *)(buf___0));
#line 2594
    limit = (int )(4094UL - tmp___37);
#line 2595
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
             "offline_url", url);
#line 2596
    tmp___38 = strlen((char const   *)p);
#line 2596
    p += tmp___38;
#line 2597
    tmp___39 = strlen((char const   *)(buf___0));
#line 2597
    limit = (int )(4094UL - tmp___39);
    }
#line 2598
    if (cloak_title) {
      {
#line 2600
      snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
               "cloak", "Y");
#line 2601
      tmp___40 = strlen((char const   *)p);
#line 2601
      p += tmp___40;
#line 2602
      tmp___41 = strlen((char const   *)(buf___0));
#line 2602
      limit = (int )(4094UL - tmp___41);
#line 2603
      snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
               "cloak_title", cloak_title);
#line 2604
      tmp___42 = strlen((char const   *)p);
#line 2604
      p += tmp___42;
#line 2605
      tmp___43 = strlen((char const   *)(buf___0));
#line 2605
      limit = (int )(4094UL - tmp___43);
      }
    } else {
      {
#line 2609
      snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
               "cloak_title", "");
#line 2610
      tmp___44 = strlen((char const   *)p);
#line 2610
      p += tmp___44;
#line 2611
      tmp___45 = strlen((char const   *)(buf___0));
#line 2611
      limit = (int )(4094UL - tmp___45);
      }
    }
    {
#line 2613
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
             "submit", "Update");
#line 2614
    tmp___46 = strlen((char const   *)p);
#line 2614
    p += tmp___46;
#line 2615
    tmp___47 = strlen((char const   *)(buf___0));
#line 2615
    limit = (int )(4094UL - tmp___47);
#line 2616
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s&",
             "domain", domain);
#line 2617
    tmp___48 = strlen((char const   *)p);
#line 2617
    p += tmp___48;
#line 2618
    tmp___49 = strlen((char const   *)(buf___0));
#line 2618
    limit = (int )(4094UL - tmp___49);
#line 2619
    snprintf((char */* __restrict  */)p, (size_t )limit, (char const   */* __restrict  */)"%s=%s",
             "hostname", hostname);
#line 2620
    tmp___50 = strlen((char const   *)p);
#line 2620
    p += tmp___50;
#line 2621
    tmp___51 = strlen((char const   *)(buf___0));
#line 2621
    limit = (int )(4094UL - tmp___51);
#line 2623
    tmp___52 = strlen((char const   *)(putbuf));
#line 2623
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Content-length: %d\r\n",
             tmp___52);
#line 2624
    output((void *)(buf___0));
#line 2625
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 2626
    output((void *)(buf___0));
#line 2628
    output((void *)(putbuf));
#line 2629
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 2630
    output((void *)(buf___0));
#line 2632
    bp = buf___0;
#line 2633
    bytes = 0;
#line 2634
    btot = 0;
    }
    {
#line 2635
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2635
      bytes = read_input(bp, 4095 - btot);
      }
#line 2635
      if (! (bytes > 0)) {
#line 2635
        goto while_break___0;
      }
#line 2637
      bp += bytes;
#line 2638
      btot += bytes;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2641
    close((int )client_sockfd);
#line 2642
    buf___0[btot] = (char )'\000';
#line 2646
    tmp___53 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                      & ret);
    }
#line 2646
    if (tmp___53 != 1) {
#line 2648
      ret = -1;
    }
    {
#line 2653
    if (ret == -1) {
#line 2653
      goto case_neg_1___0;
    }
#line 2661
    if (ret == 200) {
#line 2661
      goto case_200___0;
    }
#line 2668
    if (ret == 401) {
#line 2668
      goto case_401___0;
    }
#line 2676
    goto switch_default___0;
    case_neg_1___0: /* CIL Label */ 
#line 2654
    if (! (options & 8)) {
      {
#line 2656
      show_message((char *)"strange server response, are you connecting to the right server?\n");
      }
    }
#line 2658
    retval = 1;
#line 2659
    goto switch_break___0;
    case_200___0: /* CIL Label */ 
#line 2662
    if (! (options & 8)) {
      {
#line 2664
      printf((char const   */* __restrict  */)"request successful\n");
      }
    }
#line 2666
    goto switch_break___0;
    case_401___0: /* CIL Label */ 
#line 2669
    if (! (options & 8)) {
      {
#line 2671
      show_message((char *)"authentication failure\n");
      }
    }
#line 2673
    retval = 2;
#line 2674
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 2677
    if (! (options & 8)) {
      {
#line 2680
      auth[0] = (char )'\000';
#line 2681
      sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
             auth);
#line 2682
      show_message((char *)"unknown return code: %d\n", ret);
#line 2683
      show_message((char *)"server response: %s\n", auth);
      }
    }
#line 2685
    retval = 1;
#line 2686
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 2690
  return (retval);
}
}
#line 2693 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int ODS_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 2697
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 2697
    goto _L;
  } else
#line 2697
  if ((int )*host == 0) {
    _L: /* CIL Label */ 
#line 2699
    if (options & 4) {
#line 2701
      return (-1);
    }
#line 2703
    if (host) {
      {
#line 2703
      free((void *)host);
      }
    }
    {
#line 2704
    printf((char const   */* __restrict  */)"host: ");
#line 2705
    buf___0[0] = (char )'\000';
#line 2706
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 2707
    host = strdup((char const   *)(buf___0));
#line 2708
    chomp(host);
    }
  }
#line 2711
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 2711
    if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 2713
      if (options & 4) {
        {
#line 2715
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
        }
#line 2716
        return (-1);
      }
#line 2718
      if (address) {
        {
#line 2718
        free((void *)address);
        }
      }
      {
#line 2719
      address = strdup("");
      }
    }
  }
  {
#line 2722
  warn_fields(service->fields_used);
  }
#line 2724
  return (0);
}
}
#line 2727 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int ODS_update_entry(void) 
{ 
  char buf___0[4096] ;
  int response ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 2732
  buf___0[4095] = (char )'\000';
#line 2734
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 2734
  if (tmp != 0) {
#line 2736
    if (! (options & 8)) {
      {
#line 2738
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 2740
    return (1);
  }
  {
#line 2744
  tmp___0 = ODS_read_response(buf___0, (int )sizeof(buf___0));
  }
#line 2744
  if (tmp___0 != 100) {
    {
#line 2746
    show_message((char *)"strange server response, are you connecting to the right server?\n");
#line 2747
    close((int )client_sockfd);
    }
#line 2748
    return (1);
  }
  {
#line 2752
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"LOGIN %s %s\n",
           user_name, password);
#line 2753
  output((void *)(buf___0));
#line 2755
  response = ODS_read_response(buf___0, (int )sizeof(buf___0));
  }
#line 2756
  if (! (response == 225)) {
#line 2756
    if (! (response == 226)) {
      {
#line 2758
      tmp___1 = strlen((char const   *)(buf___0));
      }
#line 2758
      if (tmp___1 > 4UL) {
        {
#line 2760
        show_message((char *)"error talking to server: %s\n", & buf___0[4]);
        }
      } else {
        {
#line 2764
        show_message((char *)"error talking to server\n");
        }
      }
      {
#line 2766
      close((int )client_sockfd);
      }
#line 2767
      return (1);
    }
  }
  {
#line 2771
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"DELRR %s A\n",
           host);
#line 2772
  output((void *)(buf___0));
#line 2774
  tmp___3 = ODS_read_response(buf___0, (int )sizeof(buf___0));
  }
#line 2774
  if (tmp___3 != 901) {
    {
#line 2776
    tmp___2 = strlen((char const   *)(buf___0));
    }
#line 2776
    if (tmp___2 > 4UL) {
      {
#line 2778
      show_message((char *)"error talking to server: %s\n", & buf___0[4]);
      }
    } else {
      {
#line 2782
      show_message((char *)"error talking to server\n");
      }
    }
    {
#line 2784
    close((int )client_sockfd);
    }
#line 2785
    return (1);
  }
#line 2789
  if ((int )*address == 0) {
#line 2789
    tmp___4 = "CONNIP";
  } else {
#line 2789
    tmp___4 = (char const   *)address;
  }
  {
#line 2789
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"ADDRR %s A %s\n",
           host, tmp___4);
#line 2791
  output((void *)(buf___0));
#line 2793
  response = ODS_read_response(buf___0, (int )sizeof(buf___0));
  }
#line 2794
  if (! (response == 795)) {
#line 2794
    if (! (response == 796)) {
      {
#line 2796
      tmp___5 = strlen((char const   *)(buf___0));
      }
#line 2796
      if (tmp___5 > 4UL) {
        {
#line 2798
        show_message((char *)"error talking to server: %s\n", & buf___0[4]);
        }
      } else {
        {
#line 2802
        show_message((char *)"error talking to server\n");
        }
      }
      {
#line 2804
      close((int )client_sockfd);
      }
#line 2805
      return (1);
    }
  }
#line 2808
  if (! (options & 8)) {
    {
#line 2810
    printf((char const   */* __restrict  */)"request successful\n");
    }
  }
  {
#line 2813
  close((int )client_sockfd);
  }
#line 2814
  return (0);
}
}
#line 2817 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int TZO_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 2821
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 2821
    goto _L;
  } else
#line 2821
  if ((int )*host == 0) {
    _L: /* CIL Label */ 
#line 2823
    if (options & 4) {
#line 2825
      return (-1);
    }
#line 2827
    if (host) {
      {
#line 2827
      free((void *)host);
      }
    }
    {
#line 2828
    printf((char const   */* __restrict  */)"host: ");
#line 2829
    buf___0[0] = (char )'\000';
#line 2830
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 2831
    host = strdup((char const   *)(buf___0));
#line 2832
    chomp(host);
    }
  }
#line 2835
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 2835
    if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 2837
      if (options & 4) {
        {
#line 2839
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
        }
#line 2840
        return (-1);
      }
#line 2842
      if (interface) {
        {
#line 2842
        free((void *)interface);
        }
      }
      {
#line 2843
      printf((char const   */* __restrict  */)"interface: ");
#line 2844
      buf___0[0] = (char )'\000';
#line 2845
      fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 2846
      chomp(buf___0);
#line 2847
      option_handler(13, buf___0);
      }
    }
  }
  {
#line 2850
  warn_fields(service->fields_used);
  }
#line 2852
  return (0);
}
}
#line 2855 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int TZO_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;

  {
  {
#line 2858
  bp = buf___0;
#line 2863
  buf___0[4095] = (char )'\000';
#line 2865
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 2865
  if (tmp != 0) {
#line 2867
    if (! (options & 8)) {
      {
#line 2869
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 2871
    return (1);
  }
  {
#line 2874
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?",
           request);
#line 2875
  output((void *)(buf___0));
#line 2876
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "TZOName", host);
#line 2877
  output((void *)(buf___0));
#line 2878
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "Email", user_name);
#line 2879
  output((void *)(buf___0));
#line 2880
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "TZOKey", password);
#line 2881
  output((void *)(buf___0));
#line 2882
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "IPAddress", address);
#line 2883
  output((void *)(buf___0));
#line 2884
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 2885
  output((void *)(buf___0));
  }
#line 2886
  if (options & 4) {
#line 2886
    tmp___0 = "daemon";
  } else {
#line 2886
    tmp___0 = "";
  }
  {
#line 2886
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___0, "by Angus Mackay");
#line 2888
  output((void *)(buf___0));
#line 2889
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 2890
  output((void *)(buf___0));
#line 2891
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 2892
  output((void *)(buf___0));
#line 2894
  bp = buf___0;
#line 2895
  bytes = 0;
#line 2896
  btot = 0;
  }
  {
#line 2897
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2897
    bytes = read_input(bp, 4095 - btot);
    }
#line 2897
    if (! (bytes > 0)) {
#line 2897
      goto while_break;
    }
#line 2899
    bp += bytes;
#line 2900
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2903
  close((int )client_sockfd);
#line 2904
  buf___0[btot] = (char )'\000';
#line 2908
  tmp___1 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 2908
  if (tmp___1 != 1) {
#line 2910
    ret = -1;
  }
  {
#line 2915
  if (ret == -1) {
#line 2915
    goto case_neg_1;
  }
#line 2923
  if (ret == 200) {
#line 2923
    goto case_200;
  }
#line 2930
  if (ret == 302) {
#line 2930
    goto case_302;
  }
#line 2969
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 2916
  if (! (options & 8)) {
    {
#line 2918
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 2920
  return (1);
#line 2921
  goto switch_break;
  case_200: /* CIL Label */ 
#line 2924
  if (! (options & 8)) {
    {
#line 2926
    printf((char const   */* __restrict  */)"request successful\n");
    }
  }
#line 2928
  goto switch_break;
  case_302: /* CIL Label */ 
#line 2934
  if (! (options & 8)) {
    {
#line 2937
    auth[0] = (char )'\000';
#line 2938
    bp = strstr((char const   *)(buf___0), "Location: ");
#line 2939
    tmp___3 = strstr((char const   *)(buf___0), "\r\n\r\n");
    }
#line 2939
    if ((unsigned long )bp < (unsigned long )tmp___3) {
      {
#line 2939
      tmp___4 = sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"Location: http://%*[^/]%255[^\r\n]",
                       auth);
      }
#line 2939
      if (tmp___4 == 1) {
        {
#line 2941
        tmp___2 = strrchr((char const   *)(auth), '/');
#line 2941
        bp = tmp___2 + 1;
        }
      } else {
#line 2945
        bp = (char *)"";
      }
    } else {
#line 2945
      bp = (char *)"";
    }
    {
#line 2949
    tmp___11 = strlen((char const   *)bp);
#line 2949
    tmp___12 = strncmp((char const   *)bp, "domainmismatch.htm", tmp___11);
    }
#line 2949
    if (tmp___12) {
      {
#line 2949
      tmp___13 = strlen((char const   *)bp);
#line 2949
      tmp___14 = strncmp((char const   *)bp, "invname.htm", tmp___13);
      }
#line 2949
      if (tmp___14) {
        {
#line 2953
        tmp___9 = strlen((char const   *)bp);
#line 2953
        tmp___10 = strncmp((char const   *)bp, "invkey.htm", tmp___9);
        }
#line 2953
        if (tmp___10) {
          {
#line 2957
          tmp___5 = strlen((char const   *)bp);
#line 2957
          tmp___6 = strncmp((char const   *)bp, "emailmismatch.htm", tmp___5);
          }
#line 2957
          if (tmp___6) {
            {
#line 2957
            tmp___7 = strlen((char const   *)bp);
#line 2957
            tmp___8 = strncmp((char const   *)bp, "invemail.htm", tmp___7);
            }
#line 2957
            if (tmp___8) {
              {
#line 2963
              show_message((char *)"unknown error\n");
              }
            } else {
              {
#line 2959
              show_message((char *)"invalid user name(email address)\n");
              }
            }
          } else {
            {
#line 2959
            show_message((char *)"invalid user name(email address)\n");
            }
          }
        } else {
          {
#line 2955
          show_message((char *)"invalid password(tzo key)\n");
          }
        }
      } else {
        {
#line 2951
        show_message((char *)"invalid host name\n");
        }
      }
    } else {
      {
#line 2951
      show_message((char *)"invalid host name\n");
      }
    }
  }
#line 2966
  return (1);
#line 2967
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2970
  if (! (options & 8)) {
    {
#line 2973
    auth[0] = (char )'\000';
#line 2974
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 2975
    show_message((char *)"unknown return code: %d\n", ret);
#line 2976
    show_message((char *)"server response: %s\n", auth);
    }
  }
#line 2978
  return (1);
#line 2979
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2982
  return (0);
}
}
#line 2985 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int EASYDNS_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 2989
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 2989
    goto _L;
  } else
#line 2989
  if ((int )*host == 0) {
    _L: /* CIL Label */ 
#line 2991
    if (options & 4) {
#line 2993
      return (-1);
    }
#line 2995
    if (host) {
      {
#line 2995
      free((void *)host);
      }
    }
    {
#line 2996
    printf((char const   */* __restrict  */)"host: ");
#line 2997
    buf___0[0] = (char )'\000';
#line 2998
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 2999
    host = strdup((char const   *)(buf___0));
#line 3000
    chomp(host);
    }
  }
#line 3003
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 3003
    if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 3005
      if (options & 4) {
        {
#line 3007
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
        }
#line 3008
        return (-1);
      }
#line 3010
      if (interface) {
        {
#line 3010
        free((void *)interface);
        }
      }
      {
#line 3011
      printf((char const   */* __restrict  */)"interface: ");
#line 3012
      buf___0[0] = (char )'\000';
#line 3013
      fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3014
      chomp(buf___0);
#line 3015
      option_handler(13, buf___0);
      }
    }
  }
  {
#line 3018
  warn_fields(service->fields_used);
  }
#line 3020
  return (0);
}
}
#line 3023 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int EASYDNS_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 3026
  bp = buf___0;
#line 3031
  buf___0[4095] = (char )'\000';
#line 3033
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 3033
  if (tmp != 0) {
#line 3035
    if (! (options & 8)) {
      {
#line 3037
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 3039
    return (1);
  }
  {
#line 3042
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?action=edit&",
           request);
#line 3043
  output((void *)(buf___0));
  }
#line 3044
  if ((unsigned long )address != (unsigned long )((void *)0)) {
#line 3044
    if ((int )*address != 0) {
      {
#line 3046
      snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
               "myip", address);
#line 3047
      output((void *)(buf___0));
      }
    }
  }
#line 3049
  if (wildcard) {
#line 3049
    tmp___0 = "ON";
  } else {
#line 3049
    tmp___0 = "OFF";
  }
  {
#line 3049
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "wildcard", tmp___0);
#line 3050
  output((void *)(buf___0));
#line 3051
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "mx", mx);
#line 3052
  output((void *)(buf___0));
  }
#line 3053
  if ((int )*mx == 0) {
#line 3053
    tmp___1 = "NO";
  } else {
#line 3053
    tmp___1 = "YES";
  }
  {
#line 3053
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "backmx", tmp___1);
#line 3054
  output((void *)(buf___0));
#line 3055
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "host_id", host);
#line 3056
  output((void *)(buf___0));
#line 3057
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 3058
  output((void *)(buf___0));
#line 3059
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
           auth);
#line 3060
  output((void *)(buf___0));
  }
#line 3061
  if (options & 4) {
#line 3061
    tmp___2 = "daemon";
  } else {
#line 3061
    tmp___2 = "";
  }
  {
#line 3061
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___2, "by Angus Mackay");
#line 3063
  output((void *)(buf___0));
#line 3064
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 3065
  output((void *)(buf___0));
#line 3066
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 3067
  output((void *)(buf___0));
#line 3069
  bp = buf___0;
#line 3070
  bytes = 0;
#line 3071
  btot = 0;
  }
  {
#line 3072
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3072
    bytes = read_input(bp, 4095 - btot);
    }
#line 3072
    if (! (bytes > 0)) {
#line 3072
      goto while_break;
    }
#line 3074
    bp += bytes;
#line 3075
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3078
  close((int )client_sockfd);
#line 3079
  buf___0[btot] = (char )'\000';
#line 3083
  tmp___3 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 3083
  if (tmp___3 != 1) {
#line 3085
    ret = -1;
  }
  {
#line 3090
  if (ret == -1) {
#line 3090
    goto case_neg_1;
  }
#line 3098
  if (ret == 200) {
#line 3098
    goto case_200;
  }
#line 3117
  if (ret == 401) {
#line 3117
    goto case_401;
  }
#line 3125
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 3091
  if (! (options & 8)) {
    {
#line 3093
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 3095
  return (1);
#line 3096
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 3099
  tmp___4 = strstr((char const   *)(buf___0), "NOERROR\n");
  }
#line 3099
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 3101
    if (! (options & 8)) {
      {
#line 3103
      printf((char const   */* __restrict  */)"request successful\n");
      }
    }
  } else {
    {
#line 3108
    show_message((char *)"error processing request\n");
    }
#line 3109
    if (! (options & 8)) {
      {
#line 3111
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server output: %s\n",
              buf___0);
      }
    }
#line 3113
    return (1);
  }
#line 3115
  goto switch_break;
  case_401: /* CIL Label */ 
#line 3118
  if (! (options & 8)) {
    {
#line 3120
    show_message((char *)"authentication failure\n");
    }
  }
#line 3122
  return (2);
#line 3123
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3126
  if (! (options & 8)) {
    {
#line 3129
    auth[0] = (char )'\000';
#line 3130
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 3131
    show_message((char *)"unknown return code: %d\n", ret);
#line 3132
    show_message((char *)"server response: %s\n", auth);
    }
  }
#line 3134
  return (1);
#line 3135
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3138
  return (0);
}
}
#line 3141 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int EASYDNS_PARTNER_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 3145
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 3145
    goto _L;
  } else
#line 3145
  if ((int )*host == 0) {
    _L: /* CIL Label */ 
#line 3147
    if (options & 4) {
#line 3149
      return (-1);
    }
#line 3151
    if (host) {
      {
#line 3151
      free((void *)host);
      }
    }
    {
#line 3152
    printf((char const   */* __restrict  */)"host: ");
#line 3153
    buf___0[0] = (char )'\000';
#line 3154
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3155
    host = strdup((char const   *)(buf___0));
#line 3156
    chomp(host);
    }
  }
#line 3159
  if ((unsigned long )partner == (unsigned long )((void *)0)) {
#line 3159
    goto _L___0;
  } else
#line 3159
  if ((int )*partner == 0) {
    _L___0: /* CIL Label */ 
#line 3161
    if (options & 4) {
#line 3163
      return (-1);
    }
#line 3165
    if (partner) {
      {
#line 3165
      free((void *)partner);
      }
    }
    {
#line 3166
    printf((char const   */* __restrict  */)"easyDNS partner: ");
#line 3167
    buf___0[0] = (char )'\000';
#line 3168
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3169
    partner = strdup((char const   *)(buf___0));
#line 3170
    chomp(partner);
    }
  }
#line 3173
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 3173
    if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 3175
      if (options & 4) {
        {
#line 3177
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
        }
#line 3178
        return (-1);
      }
#line 3180
      if (interface) {
        {
#line 3180
        free((void *)interface);
        }
      }
      {
#line 3181
      printf((char const   */* __restrict  */)"interface: ");
#line 3182
      buf___0[0] = (char )'\000';
#line 3183
      fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3184
      chomp(buf___0);
#line 3185
      option_handler(13, buf___0);
      }
    }
  }
  {
#line 3188
  warn_fields(service->fields_used);
  }
#line 3190
  return (0);
}
}
#line 3193 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int EASYDNS_PARTNER_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 3196
  bp = buf___0;
#line 3201
  buf___0[4095] = (char )'\000';
#line 3203
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 3203
  if (tmp != 0) {
#line 3205
    if (! (options & 8)) {
      {
#line 3207
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 3209
    return (1);
  }
  {
#line 3212
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?action=edit&",
           request);
#line 3213
  output((void *)(buf___0));
  }
#line 3214
  if ((unsigned long )address != (unsigned long )((void *)0)) {
#line 3214
    if ((int )*address != 0) {
      {
#line 3216
      snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
               "myip", address);
#line 3217
      output((void *)(buf___0));
      }
    }
  }
  {
#line 3219
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "partner", partner);
#line 3220
  output((void *)(buf___0));
  }
#line 3221
  if (wildcard) {
#line 3221
    tmp___0 = "ON";
  } else {
#line 3221
    tmp___0 = "OFF";
  }
  {
#line 3221
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "wildcard", tmp___0);
#line 3222
  output((void *)(buf___0));
#line 3223
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s",
           "hostname", host);
#line 3224
  output((void *)(buf___0));
#line 3225
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 3226
  output((void *)(buf___0));
#line 3227
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
           auth);
#line 3228
  output((void *)(buf___0));
  }
#line 3229
  if (options & 4) {
#line 3229
    tmp___1 = "daemon";
  } else {
#line 3229
    tmp___1 = "";
  }
  {
#line 3229
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___1, "by Angus Mackay");
#line 3231
  output((void *)(buf___0));
#line 3232
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 3233
  output((void *)(buf___0));
#line 3234
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 3235
  output((void *)(buf___0));
#line 3237
  bp = buf___0;
#line 3238
  bytes = 0;
#line 3239
  btot = 0;
  }
  {
#line 3240
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3240
    bytes = read_input(bp, 4095 - btot);
    }
#line 3240
    if (! (bytes > 0)) {
#line 3240
      goto while_break;
    }
#line 3242
    bp += bytes;
#line 3243
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3246
  close((int )client_sockfd);
#line 3247
  buf___0[btot] = (char )'\000';
#line 3251
  tmp___2 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 3251
  if (tmp___2 != 1) {
#line 3253
    ret = -1;
  }
  {
#line 3258
  if (ret == -1) {
#line 3258
    goto case_neg_1;
  }
#line 3266
  if (ret == 200) {
#line 3266
    goto case_200;
  }
#line 3285
  if (ret == 401) {
#line 3285
    goto case_401;
  }
#line 3293
  if (ret == 403) {
#line 3293
    goto case_403;
  }
#line 3303
  if (ret == 404) {
#line 3303
    goto case_404;
  }
#line 3311
  if (ret == 405) {
#line 3311
    goto case_405;
  }
#line 3319
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 3259
  if (! (options & 8)) {
    {
#line 3261
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 3263
  return (1);
#line 3264
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 3267
  tmp___3 = strstr((char const   *)(buf___0), "OK\n");
  }
#line 3267
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 3269
    if (! (options & 8)) {
      {
#line 3271
      printf((char const   */* __restrict  */)"request successful\n");
      }
    }
  } else {
    {
#line 3276
    show_message((char *)"error processing request\n");
    }
#line 3277
    if (! (options & 8)) {
      {
#line 3279
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server output: %s\n",
              buf___0);
      }
    }
#line 3281
    return (1);
  }
#line 3283
  goto switch_break;
  case_401: /* CIL Label */ 
#line 3286
  if (! (options & 8)) {
    {
#line 3288
    show_message((char *)"authentication failure\n");
    }
  }
#line 3290
  return (2);
#line 3291
  goto switch_break;
  case_403: /* CIL Label */ 
#line 3294
  if (! (options & 8)) {
    {
#line 3296
    show_message((char *)"updating too frequently\n");
    }
  }
  {
#line 3298
  tmp___4 = format_time(86400);
#line 3298
  show_message((char *)"sleeping for %s\n", tmp___4);
#line 3299
  sleep(86400U);
  }
#line 3300
  return (1);
#line 3301
  goto switch_break;
  case_404: /* CIL Label */ 
#line 3304
  if (! (options & 8)) {
    {
#line 3306
    show_message((char *)"no dynamic service for this host/domain\n");
    }
  }
#line 3308
  return (2);
#line 3309
  goto switch_break;
  case_405: /* CIL Label */ 
#line 3312
  if (! (options & 8)) {
    {
#line 3314
    show_message((char *)"partner not supported\n");
    }
  }
#line 3316
  return (2);
#line 3317
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3320
  if (! (options & 8)) {
    {
#line 3323
    auth[0] = (char )'\000';
#line 3324
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 3325
    show_message((char *)"unknown return code: %d\n", ret);
#line 3326
    show_message((char *)"server response: %s\n", auth);
    }
  }
#line 3328
  return (1);
#line 3329
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3332
  return (0);
}
}
#line 3337 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int GNUDIP_check_info(void) 
{ 
  char buf___0[8193] ;
  int tmp ;

  {
#line 3341
  if ((unsigned long )server == (unsigned long )((void *)0)) {
#line 3341
    goto _L;
  } else
#line 3341
  if ((int )*server == 0) {
    _L: /* CIL Label */ 
#line 3343
    if (options & 4) {
#line 3345
      return (-1);
    }
#line 3347
    if (server) {
      {
#line 3347
      free((void *)server);
      }
    }
    {
#line 3348
    printf((char const   */* __restrict  */)"server: ");
#line 3349
    buf___0[0] = (char )'\000';
#line 3350
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3351
    server = strdup((char const   *)(buf___0));
#line 3352
    chomp(server);
    }
  }
#line 3355
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 3355
    goto _L___0;
  } else
#line 3355
  if ((int )*host == 0) {
    _L___0: /* CIL Label */ 
#line 3357
    if (options & 4) {
#line 3359
      return (-1);
    }
#line 3361
    if (host) {
      {
#line 3361
      free((void *)host);
      }
    }
    {
#line 3362
    printf((char const   */* __restrict  */)"host: ");
#line 3363
    buf___0[0] = (char )'\000';
#line 3364
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3365
    host = strdup((char const   *)(buf___0));
#line 3366
    chomp(host);
    }
  }
#line 3369
  if (address) {
    {
#line 3369
    tmp = strcmp((char const   *)address, "0.0.0.0");
    }
#line 3369
    if (tmp != 0) {
#line 3371
      if (! (options & 8)) {
        {
#line 3373
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: for GNUDIP the \"address\" parpameter is only used if set to \"0.0.0.0\" thus making an offline request.\n");
        }
      }
    }
  }
  {
#line 3377
  warn_fields(service->fields_used);
  }
#line 3379
  return (0);
}
}
#line 3382 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int GNUDIP_update_entry(void) 
{ 
  unsigned char digestbuf[16] ;
  char buf___0[4096] ;
  char *p ;
  int bytes ;
  int ret ;
  int i ;
  char *domainname ;
  char gnudip_request[2] ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 3395
  tmp___0 = strcmp((char const   *)address, "0.0.0.0");
  }
#line 3395
  if (tmp___0 == 0) {
#line 3395
    gnudip_request[0] = (char )'1';
  } else {
#line 3395
    gnudip_request[0] = (char )'0';
  }
#line 3396
  gnudip_request[1] = (char )'\000';
#line 3399
  p = host;
  {
#line 3399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3399
    if ((int )*p != 0) {
#line 3399
      if (! ((int )*p != 46)) {
#line 3399
        goto while_break;
      }
    } else {
#line 3399
      goto while_break;
    }
#line 3399
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3400
  if ((int )*p != 0) {
#line 3400
    p ++;
  }
#line 3401
  if ((int )*p == 0) {
#line 3403
    return (1);
  }
  {
#line 3405
  domainname = p;
#line 3407
  tmp___1 = do_connect((int *)(& client_sockfd), server, port);
  }
#line 3407
  if (tmp___1 != 0) {
#line 3409
    if (! (options & 8)) {
      {
#line 3411
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 3413
    return (1);
  }
  {
#line 3416
  bytes = read_input(buf___0, 4095);
  }
#line 3416
  if (bytes <= 0) {
    {
#line 3418
    close((int )client_sockfd);
    }
#line 3419
    return (1);
  }
  {
#line 3421
  buf___0[bytes] = (char )'\000';
#line 3426
  chomp(buf___0);
#line 3429
  tmp___2 = strlen((char const   *)(password));
#line 3429
  md5_buffer((char const   *)(password), tmp___2, (void *)(digestbuf));
#line 3430
  i = 0;
#line 3430
  p = auth;
  }
  {
#line 3430
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3430
    if (! (i < 16)) {
#line 3430
      goto while_break___0;
    }
    {
#line 3432
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%02x", (int )digestbuf[i]);
#line 3430
    i ++;
#line 3430
    p += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3434
  tmp___3 = strlen((char const   *)(auth));
#line 3434
  strncat((char */* __restrict  */)(auth), (char const   */* __restrict  */)".", 255UL - tmp___3);
#line 3435
  tmp___4 = strlen((char const   *)(auth));
#line 3435
  strncat((char */* __restrict  */)(auth), (char const   */* __restrict  */)(buf___0),
          255UL - tmp___4);
#line 3437
  tmp___5 = strlen((char const   *)(auth));
#line 3437
  md5_buffer((char const   *)(auth), tmp___5, (void *)(digestbuf));
#line 3438
  i = 0;
#line 3438
  p = buf___0;
  }
  {
#line 3438
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3438
    if (! (i < 16)) {
#line 3438
      goto while_break___1;
    }
    {
#line 3440
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%02x", (int )digestbuf[i]);
#line 3438
    i ++;
#line 3438
    p += 2;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3442
  strcpy((char */* __restrict  */)(auth), (char const   */* __restrict  */)(buf___0));
#line 3446
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s:%s:%s:%s\n",
           user_name, auth, domainname, gnudip_request);
#line 3448
  output((void *)(buf___0));
#line 3450
  bytes = 0;
#line 3451
  bytes = read_input(buf___0, 4095);
  }
#line 3451
  if (bytes <= 0) {
    {
#line 3453
    close((int )client_sockfd);
    }
#line 3454
    return (1);
  }
  {
#line 3456
  buf___0[bytes] = (char )'\000';
#line 3461
  close((int )client_sockfd);
#line 3463
  tmp___6 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
                   & ret);
  }
#line 3463
  if (tmp___6 != 1) {
#line 3465
    ret = -1;
  }
  {
#line 3470
  if (ret == -1) {
#line 3470
    goto case_neg_1;
  }
#line 3478
  if (ret == 0) {
#line 3478
    goto case_0;
  }
#line 3485
  if (ret == 1) {
#line 3485
    goto case_1;
  }
#line 3493
  if (ret == 2) {
#line 3493
    goto case_2;
  }
#line 3500
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 3471
  if (! (options & 8)) {
    {
#line 3473
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 3475
  return (1);
#line 3476
  goto switch_break;
  case_0: /* CIL Label */ 
#line 3479
  if (! (options & 8)) {
    {
#line 3481
    printf((char const   */* __restrict  */)"update request successful\n");
    }
  }
#line 3483
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3486
  if (! (options & 8)) {
    {
#line 3488
    show_message((char *)"invalid login attempt\n");
    }
  }
#line 3490
  return (1);
#line 3491
  goto switch_break;
  case_2: /* CIL Label */ 
#line 3494
  if (! (options & 8)) {
    {
#line 3496
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"offline request successful\n");
    }
  }
#line 3498
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3501
  if (! (options & 8)) {
    {
#line 3503
    show_message((char *)"unknown return code: %d\n", ret);
    }
  }
#line 3505
  return (1);
#line 3506
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3509
  return (0);
}
}
#line 3513 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int JUSTL_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 3517
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 3519
    if (options & 4) {
#line 3521
      return (-1);
    }
    {
#line 3523
    printf((char const   */* __restrict  */)"host: ");
#line 3524
    buf___0[0] = (char )'\000';
#line 3525
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3526
    chomp(buf___0);
#line 3527
    host = strdup((char const   *)(buf___0));
    }
  }
#line 3530
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 3530
    if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 3532
      if (options & 4) {
        {
#line 3534
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
        }
#line 3535
        return (-1);
      }
#line 3537
      if (interface) {
        {
#line 3537
        free((void *)interface);
        }
      }
      {
#line 3538
      printf((char const   */* __restrict  */)"interface: ");
#line 3539
      buf___0[0] = (char )'\000';
#line 3540
      fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3541
      chomp(buf___0);
#line 3542
      option_handler(13, buf___0);
      }
    }
  }
  {
#line 3545
  warn_fields(service->fields_used);
  }
#line 3547
  return (0);
}
}
#line 3550 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int JUSTL_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 3553
  bp = buf___0;
#line 3558
  buf___0[4095] = (char )'\000';
#line 3560
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 3560
  if (tmp != 0) {
#line 3562
    if (! (options & 8)) {
      {
#line 3564
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 3566
    return (1);
  }
  {
#line 3569
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?direct=1&",
           request);
#line 3570
  output((void *)(buf___0));
#line 3571
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "username", user_name);
#line 3572
  output((void *)(buf___0));
#line 3573
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "password", password);
#line 3574
  output((void *)(buf___0));
#line 3575
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "host", host);
#line 3576
  output((void *)(buf___0));
#line 3577
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "ip", address);
#line 3578
  output((void *)(buf___0));
#line 3579
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 3580
  output((void *)(buf___0));
#line 3581
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
           auth);
#line 3582
  output((void *)(buf___0));
  }
#line 3583
  if (options & 4) {
#line 3583
    tmp___0 = "daemon";
  } else {
#line 3583
    tmp___0 = "";
  }
  {
#line 3583
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___0, "by Angus Mackay");
#line 3585
  output((void *)(buf___0));
#line 3586
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 3587
  output((void *)(buf___0));
#line 3588
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 3589
  output((void *)(buf___0));
#line 3591
  bp = buf___0;
#line 3592
  bytes = 0;
#line 3593
  btot = 0;
  }
  {
#line 3594
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3594
    bytes = read_input(bp, 4095 - btot);
    }
#line 3594
    if (! (bytes > 0)) {
#line 3594
      goto while_break;
    }
#line 3596
    bp += bytes;
#line 3597
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3600
  close((int )client_sockfd);
#line 3601
  buf___0[btot] = (char )'\000';
#line 3605
  tmp___1 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 3605
  if (tmp___1 != 1) {
#line 3607
    ret = -1;
  }
  {
#line 3612
  if (ret == -1) {
#line 3612
    goto case_neg_1;
  }
#line 3620
  if (ret == 200) {
#line 3620
    goto case_200;
  }
#line 3639
  if (ret == 401) {
#line 3639
    goto case_401;
  }
#line 3647
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 3613
  if (! (options & 8)) {
    {
#line 3615
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 3617
  return (1);
#line 3618
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 3621
  tmp___2 = strstr((char const   *)(buf___0), " set ");
  }
#line 3621
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 3623
    if (! (options & 8)) {
      {
#line 3625
      printf((char const   */* __restrict  */)"request successful\n");
      }
    }
  } else {
    {
#line 3630
    show_message((char *)"error processing request\n");
    }
#line 3631
    if (! (options & 8)) {
      {
#line 3633
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server output: %s\n",
              buf___0);
      }
    }
#line 3635
    return (1);
  }
#line 3637
  goto switch_break;
  case_401: /* CIL Label */ 
#line 3640
  if (! (options & 8)) {
    {
#line 3642
    show_message((char *)"authentication failure\n");
    }
  }
#line 3644
  return (2);
#line 3645
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3648
  if (! (options & 8)) {
    {
#line 3651
    auth[0] = (char )'\000';
#line 3652
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 3653
    show_message((char *)"unknown return code: %d\n", ret);
#line 3654
    show_message((char *)"server response: %s\n", auth);
    }
  }
#line 3656
  return (1);
#line 3657
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3660
  return (0);
}
}
#line 3663 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int DYNS_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 3667
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 3669
    if (options & 4) {
#line 3671
      return (-1);
    }
    {
#line 3673
    printf((char const   */* __restrict  */)"host: ");
#line 3674
    buf___0[0] = (char )'\000';
#line 3675
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3676
    chomp(buf___0);
#line 3677
    host = strdup((char const   *)(buf___0));
    }
  }
#line 3680
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 3680
    if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 3682
      if (options & 4) {
        {
#line 3684
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
        }
#line 3685
        return (-1);
      }
#line 3687
      if (interface) {
        {
#line 3687
        free((void *)interface);
        }
      }
      {
#line 3688
      printf((char const   */* __restrict  */)"interface: ");
#line 3689
      buf___0[0] = (char )'\000';
#line 3690
      fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 3691
      chomp(buf___0);
#line 3692
      option_handler(13, buf___0);
      }
    }
  }
  {
#line 3695
  warn_fields(service->fields_used);
  }
#line 3697
  return (0);
}
}
#line 3700 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int DYNS_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 3703
  bp = buf___0;
#line 3708
  buf___0[4095] = (char )'\000';
#line 3710
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 3710
  if (tmp != 0) {
#line 3712
    if (! (options & 8)) {
      {
#line 3714
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 3716
    return (1);
  }
  {
#line 3719
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?",
           request);
#line 3720
  output((void *)(buf___0));
#line 3721
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "username", user_name);
#line 3722
  output((void *)(buf___0));
#line 3723
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "password", password);
#line 3724
  output((void *)(buf___0));
#line 3725
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "host", host);
#line 3726
  output((void *)(buf___0));
#line 3727
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s",
           "ip", address);
#line 3728
  output((void *)(buf___0));
#line 3729
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 3730
  output((void *)(buf___0));
#line 3731
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
           auth);
#line 3732
  output((void *)(buf___0));
  }
#line 3733
  if (options & 4) {
#line 3733
    tmp___0 = "daemon";
  } else {
#line 3733
    tmp___0 = "";
  }
  {
#line 3733
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___0, "by Angus Mackay");
#line 3735
  output((void *)(buf___0));
#line 3736
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 3737
  output((void *)(buf___0));
#line 3738
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 3739
  output((void *)(buf___0));
#line 3741
  bp = buf___0;
#line 3742
  bytes = 0;
#line 3743
  btot = 0;
  }
  {
#line 3744
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3744
    bytes = read_input(bp, 4095 - btot);
    }
#line 3744
    if (! (bytes > 0)) {
#line 3744
      goto while_break;
    }
#line 3746
    bp += bytes;
#line 3747
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3750
  close((int )client_sockfd);
#line 3751
  buf___0[btot] = (char )'\000';
#line 3755
  tmp___1 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 3755
  if (tmp___1 != 1) {
#line 3757
    ret = -1;
  }
  {
#line 3762
  if (ret == -1) {
#line 3762
    goto case_neg_1;
  }
#line 3770
  if (ret == 200) {
#line 3770
    goto case_200;
  }
#line 3813
  if (ret == 405) {
#line 3813
    goto case_405;
  }
#line 3821
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 3763
  if (! (options & 8)) {
    {
#line 3765
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 3767
  return (1);
#line 3768
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 3771
  tmp___5 = strstr((char const   *)(buf___0), "200 Host");
  }
#line 3771
  if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 3771
    goto _L;
  } else {
    {
#line 3771
    tmp___6 = strstr((char const   *)(buf___0), "200 host");
    }
#line 3771
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 3774
      if (! (options & 8)) {
        {
#line 3776
        printf((char const   */* __restrict  */)"request successful\n");
        }
      }
    } else {
      {
#line 3779
      tmp___4 = strstr((char const   *)(buf___0), "400 Bad Request");
      }
#line 3779
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 3781
        if (! (options & 8)) {
          {
#line 3783
          printf((char const   */* __restrict  */)"bad request\n");
          }
        }
      } else {
        {
#line 3786
        tmp___3 = strstr((char const   *)(buf___0), "401 User");
        }
#line 3786
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 3788
          if (! (options & 8)) {
            {
#line 3790
            printf((char const   */* __restrict  */)"authentication failure (username/password)\n");
            }
          }
        } else {
          {
#line 3793
          tmp___2 = strstr((char const   *)(buf___0), "405 Hostname");
          }
#line 3793
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 3795
            if (! (options & 8)) {
              {
#line 3797
              printf((char const   */* __restrict  */)"authentication failure (hostname not found)\n");
              }
            }
          } else {
            {
#line 3803
            show_message((char *)"error processing request\n");
            }
#line 3804
            if (! (options & 8)) {
              {
#line 3806
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server output: %s\n",
                      buf___0);
              }
            }
#line 3808
            return (1);
          }
        }
      }
    }
  }
#line 3811
  goto switch_break;
  case_405: /* CIL Label */ 
#line 3814
  if (! (options & 8)) {
    {
#line 3816
    show_message((char *)"authentication failure\n");
    }
  }
#line 3818
  return (1);
#line 3819
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3822
  if (! (options & 8)) {
    {
#line 3825
    auth[0] = (char )'\000';
#line 3826
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 3827
    show_message((char *)"unknown return code: %d\n", ret);
#line 3828
    show_message((char *)"server response: %s\n", auth);
    }
  }
#line 3830
  return (1);
#line 3831
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3834
  return (0);
}
}
#line 3837 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int HN_check_info(void) 
{ 


  {
  {
#line 3839
  warn_fields(service->fields_used);
  }
#line 3841
  return (0);
}
}
#line 3844 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int HN_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *p ;

  {
  {
#line 3847
  bp = buf___0;
#line 3852
  buf___0[4095] = (char )'\000';
#line 3854
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 3854
  if (tmp != 0) {
#line 3856
    if (! (options & 8)) {
      {
#line 3858
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 3860
    return (1);
  }
  {
#line 3863
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?ver=%d&",
           request, 1);
#line 3864
  output((void *)(buf___0));
  }
#line 3865
  if (address) {
    {
#line 3867
    snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
             "IP", address);
#line 3868
    output((void *)(buf___0));
    }
  }
  {
#line 3870
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 3871
  output((void *)(buf___0));
#line 3872
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
           auth);
#line 3873
  output((void *)(buf___0));
  }
#line 3874
  if (options & 4) {
#line 3874
    tmp___0 = "daemon";
  } else {
#line 3874
    tmp___0 = "";
  }
  {
#line 3874
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___0, "by Angus Mackay");
#line 3876
  output((void *)(buf___0));
#line 3877
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 3878
  output((void *)(buf___0));
#line 3879
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 3880
  output((void *)(buf___0));
#line 3882
  bp = buf___0;
#line 3883
  bytes = 0;
#line 3884
  btot = 0;
  }
  {
#line 3885
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3885
    bytes = read_input(bp, 4095 - btot);
    }
#line 3885
    if (! (bytes > 0)) {
#line 3885
      goto while_break;
    }
#line 3887
    bp += bytes;
#line 3888
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3891
  close((int )client_sockfd);
#line 3892
  buf___0[btot] = (char )'\000';
#line 3896
  tmp___1 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 3896
  if (tmp___1 != 1) {
#line 3898
    ret = -1;
  }
  {
#line 3905
  if (ret == -1) {
#line 3905
    goto case_neg_1;
  }
#line 3913
  if (ret == 200) {
#line 3913
    goto case_200;
  }
#line 3976
  if (ret == 401) {
#line 3976
    goto case_401;
  }
#line 3984
  goto switch_default___0;
  case_neg_1: /* CIL Label */ 
#line 3906
  if (! (options & 8)) {
    {
#line 3908
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 3910
  return (1);
#line 3911
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 3914
  ret = -1;
#line 3915
  p = strstr((char const   *)(buf___0), "DDNS_Response_");
  }
#line 3915
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 3917
    sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"DDNS_Response_%*code=%3d",
           & ret);
    }
  }
  {
#line 3930
  if (ret == -1) {
#line 3930
    goto case_neg_1___0;
  }
#line 3938
  if (ret == 101) {
#line 3938
    goto case_101;
  }
#line 3945
  if (ret == 201) {
#line 3945
    goto case_201;
  }
#line 3950
  if (ret == 202) {
#line 3950
    goto case_202;
  }
#line 3955
  if (ret == 203) {
#line 3955
    goto case_203;
  }
#line 3960
  if (ret == 204) {
#line 3960
    goto case_204;
  }
#line 3965
  goto switch_default;
  case_neg_1___0: /* CIL Label */ 
#line 3931
  if (! (options & 8)) {
    {
#line 3933
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 3935
  return (1);
#line 3936
  goto switch_break___0;
  case_101: /* CIL Label */ 
#line 3939
  if (! (options & 8)) {
    {
#line 3941
    printf((char const   */* __restrict  */)"request successful\n");
    }
  }
#line 3943
  goto switch_break___0;
  case_201: /* CIL Label */ 
  {
#line 3946
  show_message((char *)"Last update was less than %d seconds ago.\n", 300);
  }
#line 3947
  return (1);
#line 3948
  goto switch_break___0;
  case_202: /* CIL Label */ 
  {
#line 3951
  show_message((char *)"Server error.\n");
  }
#line 3952
  return (1);
#line 3953
  goto switch_break___0;
  case_203: /* CIL Label */ 
  {
#line 3956
  show_message((char *)"Failure because account is frozen (by admin).\n");
  }
#line 3957
  return (2);
#line 3958
  goto switch_break___0;
  case_204: /* CIL Label */ 
  {
#line 3961
  show_message((char *)"Failure because account is locked (by user).\n");
  }
#line 3962
  return (2);
#line 3963
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 3966
  if (! (options & 8)) {
    {
#line 3968
    show_message((char *)"unknown return code: %d\n", ret);
#line 3969
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server response: %s\n",
            buf___0);
    }
  }
#line 3971
  return (1);
#line 3972
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3974
  goto switch_break;
  case_401: /* CIL Label */ 
#line 3977
  if (! (options & 8)) {
    {
#line 3979
    show_message((char *)"authentication failure\n");
    }
  }
#line 3981
  return (2);
#line 3982
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 3985
  if (! (options & 8)) {
    {
#line 3988
    auth[0] = (char )'\000';
#line 3989
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 3990
    show_message((char *)"unknown return code: %d\n", ret);
#line 3991
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server response: %s\n",
            auth);
    }
  }
#line 3993
  return (1);
#line 3994
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3997
  return (0);
}
}
#line 4000 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int ZONEEDIT_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 4004
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 4004
    goto _L;
  } else
#line 4004
  if ((int )*host == 0) {
    _L: /* CIL Label */ 
#line 4006
    if (options & 4) {
#line 4008
      return (-1);
    }
#line 4010
    if (host) {
      {
#line 4010
      free((void *)host);
      }
    }
    {
#line 4011
    printf((char const   */* __restrict  */)"host: ");
#line 4012
    buf___0[0] = (char )'\000';
#line 4013
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 4014
    host = strdup((char const   *)(buf___0));
#line 4015
    chomp(host);
    }
  }
  {
#line 4018
  warn_fields(service->fields_used);
  }
#line 4020
  return (0);
}
}
#line 4023 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int ZONEEDIT_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 4026
  bp = buf___0;
#line 4031
  buf___0[4095] = (char )'\000';
#line 4033
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 4033
  if (tmp != 0) {
#line 4035
    if (! (options & 8)) {
      {
#line 4037
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 4039
    return (1);
  }
  {
#line 4042
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?",
           request);
#line 4043
  output((void *)(buf___0));
#line 4044
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
           "host", host);
#line 4045
  output((void *)(buf___0));
  }
#line 4046
  if (address) {
#line 4046
    if (*address) {
      {
#line 4047
      snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
               "dnsto", address);
#line 4048
      output((void *)(buf___0));
      }
    }
  }
#line 4050
  if (address) {
#line 4050
    if (*mx) {
#line 4050
      if ((int )*mx != 48) {
        {
#line 4051
        snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"%s=%s&",
                 "type", "a,mx");
#line 4052
        output((void *)(buf___0));
        }
      }
    }
  }
  {
#line 4054
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 4055
  output((void *)(buf___0));
#line 4056
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s (%s)\r\n",
           "zoneedit", "3.0.11b8", "", "by Angus Mackay");
#line 4058
  output((void *)(buf___0));
#line 4059
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 4060
  output((void *)(buf___0));
#line 4061
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
           auth);
#line 4062
  output((void *)(buf___0));
#line 4063
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 4064
  output((void *)(buf___0));
#line 4066
  bp = buf___0;
#line 4067
  bytes = 0;
#line 4068
  btot = 0;
  }
  {
#line 4069
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4069
    bytes = read_input(bp, 4095 - btot);
    }
#line 4069
    if (! (bytes > 0)) {
#line 4069
      goto while_break;
    }
#line 4071
    bp += bytes;
#line 4072
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4075
  close((int )client_sockfd);
#line 4076
  buf___0[btot] = (char )'\000';
#line 4080
  tmp___0 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 4080
  if (tmp___0 != 1) {
#line 4082
    ret = -1;
  }
  {
#line 4087
  if (ret == -1) {
#line 4087
    goto case_neg_1;
  }
#line 4095
  if (ret == 200) {
#line 4095
    goto case_200;
  }
#line 4114
  if (ret == 401) {
#line 4114
    goto case_401;
  }
#line 4122
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 4088
  if (! (options & 8)) {
    {
#line 4090
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 4092
  return (1);
#line 4093
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 4096
  tmp___1 = strstr((char const   *)(buf___0), "<SUCCESS");
  }
#line 4096
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 4098
    if (! (options & 8)) {
      {
#line 4100
      printf((char const   */* __restrict  */)"request successful\n");
      }
    }
  } else {
    {
#line 4105
    show_message((char *)"error processing request\n");
    }
#line 4106
    if (! (options & 8)) {
      {
#line 4108
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server output: %s\n",
              buf___0);
      }
    }
#line 4110
    return (1);
  }
#line 4112
  goto switch_break;
  case_401: /* CIL Label */ 
#line 4115
  if (! (options & 8)) {
    {
#line 4117
    show_message((char *)"authentication failure\n");
    }
  }
#line 4119
  return (2);
#line 4120
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4123
  if (! (options & 8)) {
    {
#line 4126
    auth[0] = (char )'\000';
#line 4127
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 4128
    show_message((char *)"unknown return code: %d\n", ret);
#line 4129
    show_message((char *)"server response: %s\n", auth);
    }
  }
#line 4131
  return (1);
#line 4132
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4135
  return (0);
}
}
#line 4138 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int HEIPV6TB_check_info(void) 
{ 
  char buf___0[8193] ;

  {
#line 4142
  if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 4144
    if (options & 4) {
      {
#line 4146
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide either an interface or an address\n");
      }
#line 4147
      return (-1);
    }
#line 4149
    if (interface) {
      {
#line 4149
      free((void *)interface);
      }
    }
    {
#line 4150
    printf((char const   */* __restrict  */)"interface: ");
#line 4151
    buf___0[0] = (char )'\000';
#line 4152
    fgets((char */* __restrict  */)(buf___0), 8192, (FILE */* __restrict  */)stdin);
#line 4153
    chomp(buf___0);
#line 4154
    option_handler(13, buf___0);
    }
  }
  {
#line 4156
  warn_fields(service->fields_used);
  }
#line 4158
  return (0);
}
}
#line 4161 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int HEIPV6TB_update_entry(void) 
{ 
  char buf___0[4096] ;
  char *bp ;
  int bytes ;
  int btot ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4164
  bp = buf___0;
#line 4169
  buf___0[4095] = (char )'\000';
#line 4171
  tmp = do_connect((int *)(& client_sockfd), server, port);
  }
#line 4171
  if (tmp != 0) {
#line 4173
    if (! (options & 8)) {
      {
#line 4175
      show_message((char *)"error connecting to %s:%s\n", server, port);
      }
    }
#line 4177
    return (1);
  }
  {
#line 4180
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"GET %s?menu=%s&",
           request, "edit_tunnel_address");
#line 4181
  output((void *)(buf___0));
#line 4182
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"aname=%s&",
           user_name);
#line 4183
  output((void *)(buf___0));
#line 4184
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"auth=%s&",
           password);
#line 4185
  output((void *)(buf___0));
#line 4186
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"ipv4b=%s",
           address);
#line 4187
  output((void *)(buf___0));
#line 4188
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)" HTTP/1.0\r\n");
#line 4189
  output((void *)(buf___0));
  }
#line 4190
  if (options & 4) {
#line 4190
    tmp___0 = "daemon";
  } else {
#line 4190
    tmp___0 = "";
  }
  {
#line 4190
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"User-Agent: %s-%s %s [%s] (%s)\r\n",
           "ez-update", "3.0.11b8", "", tmp___0, "by Angus Mackay");
#line 4192
  output((void *)(buf___0));
#line 4193
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"Host: %s\r\n",
           server);
#line 4194
  output((void *)(buf___0));
#line 4195
  snprintf((char */* __restrict  */)(buf___0), (size_t )4095, (char const   */* __restrict  */)"\r\n");
#line 4196
  output((void *)(buf___0));
#line 4198
  bp = buf___0;
#line 4199
  bytes = 0;
#line 4200
  btot = 0;
  }
  {
#line 4201
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4201
    bytes = read_input(bp, 4095 - btot);
    }
#line 4201
    if (! (bytes > 0)) {
#line 4201
      goto while_break;
    }
#line 4203
    bp += bytes;
#line 4204
    btot += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4207
  close((int )client_sockfd);
#line 4208
  buf___0[btot] = (char )'\000';
#line 4211
  tmp___1 = sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %3d",
                   & ret);
  }
#line 4211
  if (tmp___1 != 1) {
#line 4213
    ret = -1;
  }
  {
#line 4220
  if (ret == -1) {
#line 4220
    goto case_neg_1;
  }
#line 4227
  if (ret == 200) {
#line 4227
    goto case_200;
  }
#line 4233
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 4221
  if (! (options & 8)) {
    {
#line 4223
    show_message((char *)"strange server response, are you connecting to the right server?\n");
    }
  }
#line 4225
  return (1);
#line 4226
  goto switch_break;
  case_200: /* CIL Label */ 
#line 4228
  if (! (options & 8)) {
    {
#line 4230
    printf((char const   */* __restrict  */)"request successful\n");
    }
  }
#line 4232
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4234
  if (! (options & 8)) {
    {
#line 4237
    auth[0] = (char )'\000';
#line 4238
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)" HTTP/1.%*c %*3d %255[^\r\n]",
           auth);
#line 4239
    show_message((char *)"unknown return code: %d\n", ret);
#line 4240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"server response: %s\n",
            auth);
    }
  }
#line 4242
  return (1);
#line 4243
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4246
  return (0);
}
}
#line 4249 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
static int is_in_list(char *needle , char **haystack ) 
{ 
  char **p ;
  int found ;
  int tmp ;

  {
#line 4252
  found = 0;
#line 4254
  p = haystack;
  {
#line 4254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4254
    if (! ((unsigned long )*p != (unsigned long )((void *)0))) {
#line 4254
      goto while_break;
    }
    {
#line 4256
    tmp = strcmp((char const   *)needle, (char const   *)*p);
    }
#line 4256
    if (tmp == 0) {
#line 4258
      found = 1;
#line 4259
      goto while_break;
    }
#line 4254
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4263
  return (found);
}
}
#line 4266 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void warn_fields(char **okay_fields ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 4268
  if (wildcard != 0) {
    {
#line 4268
    tmp = is_in_list((char *)"wildcard", okay_fields);
    }
#line 4268
    if (! tmp) {
      {
#line 4270
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: this service does not support the %s option\n",
              "wildcard");
      }
    }
  }
#line 4273
  if (! ((unsigned long )mx == (unsigned long )((void *)0))) {
#line 4273
    if (! ((int )*mx == 0)) {
      {
#line 4273
      tmp___0 = is_in_list((char *)"mx", okay_fields);
      }
#line 4273
      if (! tmp___0) {
        {
#line 4275
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: this service does not support the %s option\n",
                "mx");
        }
      }
    }
  }
#line 4278
  if (! ((unsigned long )url == (unsigned long )((void *)0))) {
#line 4278
    if (! ((int )*url == 0)) {
      {
#line 4278
      tmp___1 = is_in_list((char *)"url", okay_fields);
      }
#line 4278
      if (! tmp___1) {
        {
#line 4280
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: this service does not support the %s option\n",
                "url");
        }
      }
    }
  }
#line 4283
  if (! ((unsigned long )cloak_title == (unsigned long )((void *)0))) {
#line 4283
    if (! ((int )*cloak_title == 0)) {
      {
#line 4283
      tmp___2 = is_in_list((char *)"cloak_title", okay_fields);
      }
#line 4283
      if (! tmp___2) {
        {
#line 4285
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: this service does not support the %s option\n",
                "cloak_title");
        }
      }
    }
  }
#line 4288
  if (connection_type != 1) {
    {
#line 4288
    tmp___3 = is_in_list((char *)"connection-type", okay_fields);
    }
#line 4288
    if (! tmp___3) {
      {
#line 4290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: this service does not support the %s option\n",
              "connection-type");
      }
    }
  }
#line 4293
  return;
}
}
#line 4295 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int exec_cmd(char *cmd ) 
{ 
  int kid ;
  int exit_code ;
  __pid_t tmp ;
  union __anonunion_67 __constr_expr_0 ;

  {
  {
#line 4301
  kid = vfork();
  }
  {
#line 4303
  if (kid == -1) {
#line 4303
    goto case_neg_1;
  }
#line 4310
  if (kid == 0) {
#line 4310
    goto case_0;
  }
#line 4319
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 4304
  if (! (options & 8)) {
    {
#line 4306
    perror("fork");
    }
  }
#line 4308
  return (-1);
#line 4309
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 4312
  execl("/bin/sh", "sh", "-c", cmd, (char *)0);
  }
#line 4313
  if (! (options & 8)) {
    {
#line 4315
    perror("exec");
    }
  }
  {
#line 4317
  exit(1);
  }
#line 4318
  goto switch_break;
  switch_default: /* CIL Label */ ;
#line 4322
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 4326
  tmp = waitpid(kid, & exit_code, 0);
  }
#line 4326
  if (tmp != kid) {
#line 4328
    return (1);
  }
#line 4336
  __constr_expr_0.__in = exit_code;
#line 4336
  exit_code = (__constr_expr_0.__i & 65280) >> 8;
#line 4338
  return (exit_code);
}
}
#line 4344 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
void handle_sig(int sig ) 
{ 
  int tmp ;

  {
  {
#line 4349
  if (sig == 1) {
#line 4349
    goto case_1;
  }
#line 4359
  if (sig == 15) {
#line 4359
    goto case_15;
  }
#line 4364
  if (sig == 3) {
#line 4364
    goto case_3;
  }
#line 4379
  goto switch_default;
  case_1: /* CIL Label */ 
#line 4350
  if (config_file) {
    {
#line 4352
    show_message((char *)"SIGHUP recieved, re-reading config file\n");
#line 4353
    tmp = parse_conf_file(config_file, conf_commands);
    }
#line 4353
    if (tmp != 0) {
      {
#line 4355
      show_message((char *)"error parsing config file \"%s\"\n", config_file);
      }
    }
  }
#line 4358
  goto switch_break;
  case_15: /* CIL Label */ 
#line 4363
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 4365
  show_message((char *)"received SIGQUIT, shutting down\n");
#line 4368
  closelog();
  }
#line 4372
  if (pid_file) {
    {
#line 4374
    pid_file_delete(pid_file);
    }
  }
  {
#line 4378
  exit(0);
  }
  switch_default: /* CIL Label */ ;
#line 4381
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4383
  return;
}
}
#line 4559
extern int ( /* missing proto */  localtime)() ;
#line 4560
extern int ( /* missing proto */  strftime)() ;
#line 4385 "/home/june/repo/benchmarks/collector/temp/ez-ipupdate-3.0.11b8/ez-ipupdate.c"
int main(int argc , char **argv ) 
{ 
  int ifresolve_warned ;
  int i ;
  int retval ;
  int sock ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int local_update_period ;
  struct sockaddr_in sin ;
  struct sockaddr_in sin2 ;
  __pid_t tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  time_t ipdate ;
  char *ipstr ;
  struct tm *ts ;
  char timebuf[64] ;
  int tmp___8 ;
  char *tmp___9 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int updateres ;
  char *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  int res ;
  char *tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char ipbuf[64] ;
  char *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  char const   *tmp___31 ;
  char buf___0[1024] ;
  int tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  int tmp___35 ;
  int need_update ;
  time_t ipdate___0 ;
  char *ipstr___0 ;
  char ipbuf___0[64] ;
  int *tmp___37 ;
  char *tmp___38 ;
  char const   *tmp___39 ;
  int *tmp___40 ;
  int tmp___41 ;
  struct sockaddr_in sin___0 ;
  int sock___0 ;
  int tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int res___0 ;
  struct sockaddr_in sin___1 ;
  int sock___1 ;
  char *tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int *tmp___49 ;
  char *tmp___50 ;
  char ipbuf___1[64] ;
  struct sockaddr_in sin___2 ;
  int sock___2 ;
  int tmp___51 ;
  char *tmp___52 ;
  int *tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;

  {
  {
#line 4387
  ifresolve_warned = 0;
#line 4389
  retval = 1;
#line 4391
  sock = -1;
#line 4400
  program_name = *(argv + 0);
#line 4401
  options = 0;
#line 4402
  user[0] = (char )'\000';
#line 4403
  timeout.tv_sec = (__time_t )120;
#line 4404
  timeout.tv_usec = (__suseconds_t )0;
#line 4405
  parse_service((char *)"NULL");
#line 4410
  signal(2, & sigint_handler);
#line 4411
  signal(1, & generic_sig_handler);
#line 4412
  signal(15, & generic_sig_handler);
#line 4413
  signal(3, & generic_sig_handler);
#line 4416
  parse_args(argc, argv);
  }
#line 4418
  if (! (options & 8)) {
#line 4418
    if (! (options & 4)) {
      {
#line 4420
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ez-ipupdate Version %s\nCopyright (C) 1998-2001 Angus Mackay.\n",
              "3.0.11b8");
      }
    }
  }
  {
#line 4433
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4433
    tmp___0 = is_in_list((char *)"null", service->names);
    }
#line 4433
    if (! tmp___0) {
#line 4433
      goto while_break;
    }
    {
#line 4435
    tmp = (*(service->check_info))();
    }
#line 4435
    if (tmp != 0) {
      {
#line 4437
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid data to perform requested action.\n");
#line 4438
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4442
  if ((unsigned long )server == (unsigned long )((void *)0)) {
    {
#line 4444
    server = strdup((char const   *)service->default_server);
    }
  }
#line 4446
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 4448
    port = strdup((char const   *)service->default_port);
    }
  }
#line 4451
  user_name[0] = (char )'\000';
#line 4452
  password[0] = (char )'\000';
#line 4453
  if ((int )user[0] != 0) {
    {
#line 4455
    sscanf((char const   */* __restrict  */)(user), (char const   */* __restrict  */)"%127[^:]:%127[^\n]",
           user_name, password);
    }
  }
#line 4459
  if ((int )user_name[0] == 0) {
    {
#line 4461
    printf((char const   */* __restrict  */)"user name: ");
#line 4462
    fgets((char */* __restrict  */)(user_name), (int )sizeof(user_name), (FILE */* __restrict  */)stdin);
#line 4463
    chomp(user_name);
    }
  }
#line 4465
  if ((int )password[0] == 0) {
    {
#line 4467
    tmp___1 = getpass("password: ");
#line 4467
    strncpy((char */* __restrict  */)(password), (char const   */* __restrict  */)tmp___1,
            sizeof(password));
    }
  }
  {
#line 4469
  sprintf((char */* __restrict  */)(user), (char const   */* __restrict  */)"%s:%s",
          user_name, password);
#line 4471
  base64Encode(user, auth);
  }
#line 4473
  if ((unsigned long )request_over_ride == (unsigned long )((void *)0)) {
#line 4473
    tmp___2 = service->default_request;
  } else {
#line 4473
    tmp___2 = request_over_ride;
  }
  {
#line 4473
  request = strdup((char const   *)tmp___2);
  }
#line 4476
  if ((unsigned long )service->init != (unsigned long )((void *)0)) {
    {
#line 4478
    (*(service->init))();
    }
  }
  {
#line 4481
  tmp___3 = (*(service->check_info))();
  }
#line 4481
  if (tmp___3 != 0) {
    {
#line 4483
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid data to perform requested action.\n");
#line 4484
    exit(1);
    }
  }
#line 4487
  if ((unsigned long )mx == (unsigned long )((void *)0)) {
    {
#line 4487
    mx = strdup("");
    }
  }
#line 4488
  if ((unsigned long )url == (unsigned long )((void *)0)) {
    {
#line 4488
    url = strdup("");
    }
  }
#line 4491
  if (options & 4) {
    {
#line 4493
    sock = socket(2, 1, 0);
    }
  }
#line 4497
  if (options & 4) {
#line 4499
    local_update_period = update_period;
#line 4504
    if ((unsigned long )interface == (unsigned long )((void *)0)) {
      {
#line 4506
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid data to perform requested action.\n");
#line 4507
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you must provide an interface for daemon mode");
#line 4508
      exit(1);
      }
    }
#line 4512
    if (! (options & 16)) {
      {
#line 4515
      close(0);
#line 4516
      close(1);
#line 4517
      close(2);
#line 4519
      tmp___4 = fork();
      }
#line 4519
      if (tmp___4 > 0) {
        {
#line 4519
        exit(0);
        }
      }
    }
#line 4523
    if (pid_file) {
      {
#line 4523
      tmp___5 = pid_file_create(pid_file);
      }
#line 4523
      if (tmp___5 != 0) {
        {
#line 4525
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"exiting...\n");
#line 4526
        exit(1);
        }
      }
    }
    {
#line 4531
    openlog((char const   *)program_name, 1, 1 << 3);
#line 4532
    options |= 8;
#line 4534
    show_message((char *)"ez-ipupdate Version %s, Copyright (C) 1998-2001 Angus Mackay.\n",
                 "3.0.11b8");
    }
#line 4536
    if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 4536
      tmp___6 = "(null)";
    } else {
#line 4536
      tmp___6 = (char const   *)host;
    }
#line 4536
    if ((unsigned long )interface == (unsigned long )((void *)0)) {
#line 4536
      tmp___7 = "(null)";
    } else {
#line 4536
      tmp___7 = (char const   *)interface;
    }
    {
#line 4536
    show_message((char *)"%s started for interface %s host %s using server %s and service %s\n",
                 program_name, tmp___7, tmp___6, server, service->title);
#line 4539
    memset((void *)(& sin), 0, sizeof(sin));
    }
#line 4541
    if (cache_file) {
      {
#line 4546
      tmp___15 = read_cache_file(cache_file, & ipdate, & ipstr);
      }
#line 4546
      if (tmp___15 == 0) {
#line 4551
        if (ipstr) {
          {
#line 4551
          tmp___9 = strchr((char const   *)ipstr, '.');
          }
#line 4551
          if (tmp___9) {
            {
#line 4556
            inet_aton((char const   *)ipstr, & sin.sin_addr);
#line 4557
            last_update = ipdate;
#line 4559
            tmp___8 = localtime(& ipdate);
#line 4559
            ts = (struct tm *)tmp___8;
#line 4560
            strftime(timebuf, sizeof(timebuf), "%Y/%m/%d %H:%M", ts);
#line 4561
            show_message((char *)"got last update %s on %s from cache file\n", ipstr,
                         timebuf);
            }
          } else {
            {
#line 4565
            show_message((char *)"malformed cache file: %s\n", cache_file);
            }
          }
        } else {
          {
#line 4565
          show_message((char *)"malformed cache file: %s\n", cache_file);
          }
        }
#line 4567
        if (ipstr) {
          {
#line 4567
          free((void *)ipstr);
#line 4567
          ipstr = (char *)((void *)0);
          }
        }
      } else {
        {
#line 4571
        tmp___14 = __errno_location();
        }
#line 4571
        if (*tmp___14 == 0) {
#line 4571
          tmp___13 = "malformed entry";
        } else {
          {
#line 4571
          tmp___11 = __errno_location();
#line 4571
          tmp___12 = strerror(*tmp___11);
#line 4571
          tmp___13 = (char const   *)tmp___12;
          }
        }
        {
#line 4571
        show_message((char *)"error reading cache file \"%s\": %s\n", cache_file,
                     tmp___13);
        }
      }
    }
    {
#line 4576
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4580
      if (last_sig != (int volatile   )0) {
        {
#line 4582
        handle_sig((int )last_sig);
#line 4583
        last_sig = (int volatile   )0;
        }
      }
      {
#line 4587
      tmp___35 = get_if_addr(sock, interface, & sin2);
      }
#line 4587
      if (tmp___35 == 0) {
        {
#line 4589
        ifresolve_warned = 0;
#line 4590
        tmp___32 = memcmp((void const   *)(& sin.sin_addr), (void const   *)(& sin2.sin_addr),
                          sizeof(struct in_addr ));
        }
#line 4590
        if (tmp___32 != 0) {
#line 4590
          goto _L;
        } else
#line 4590
        if (max_interval > 0) {
          {
#line 4590
          tmp___33 = time((void *)0);
          }
#line 4590
          if ((time_t )tmp___33 - last_update > (time_t )max_interval) {
            _L: /* CIL Label */ 
            {
#line 4596
            memcpy((void */* __restrict  */)(& sin), (void const   */* __restrict  */)(& sin2),
                   sizeof(sin));
            }
#line 4599
            if (address) {
              {
#line 4599
              free((void *)address);
              }
            }
            {
#line 4600
            tmp___16 = inet_ntoa(sin.sin_addr);
#line 4600
            address = strdup((char const   *)tmp___16);
#line 4602
            updateres = (*(service->update_entry))();
            }
#line 4602
            if (updateres == 0) {
              {
#line 4604
              tmp___17 = time((void *)0);
#line 4604
              last_update = (time_t )tmp___17;
#line 4605
              local_update_period = update_period;
              }
#line 4607
              if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 4607
                tmp___18 = "(null)";
              } else {
#line 4607
                tmp___18 = (char const   *)host;
              }
              {
#line 4607
              tmp___19 = inet_ntoa(sin.sin_addr);
#line 4607
              show_message((char *)"successful update for %s->%s (%s)\n", interface,
                           tmp___19, tmp___18);
              }
#line 4610
              if (post_update_cmd) {
#line 4614
                if (post_update_cmd) {
                  {
#line 4616
                  tmp___20 = inet_ntoa(sin.sin_addr);
#line 4616
                  sprintf((char */* __restrict  */)post_update_cmd_arg, (char const   */* __restrict  */)"%s",
                          tmp___20);
#line 4618
                  res = exec_cmd(post_update_cmd);
                  }
#line 4618
                  if (res != 0) {
#line 4620
                    if (res == -1) {
                      {
#line 4622
                      tmp___21 = __errno_location();
#line 4622
                      tmp___22 = strerror(*tmp___21);
                      }
#line 4622
                      if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 4622
                        tmp___23 = "(null)";
                      } else {
#line 4622
                        tmp___23 = (char const   *)host;
                      }
                      {
#line 4622
                      show_message((char *)"(%s) error running post update command: %s\n",
                                   tmp___23, tmp___22);
                      }
                    } else {
#line 4627
                      if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 4627
                        tmp___24 = "(null)";
                      } else {
#line 4627
                        tmp___24 = (char const   *)host;
                      }
                      {
#line 4627
                      show_message((char *)"(%s) error running post update command, command exit code: %d\n",
                                   tmp___24, res);
                      }
                    }
                  }
                }
              }
#line 4635
              if (cache_file) {
                {
#line 4639
                tmp___25 = inet_ntoa(sin.sin_addr);
#line 4639
                snprintf((char */* __restrict  */)(ipbuf), sizeof(ipbuf), (char const   */* __restrict  */)"%s",
                         tmp___25);
#line 4641
                tmp___28 = write_cache_file(cache_file, last_update, ipbuf);
                }
#line 4641
                if (tmp___28 != 0) {
                  {
#line 4643
                  tmp___26 = __errno_location();
#line 4643
                  tmp___27 = strerror(*tmp___26);
#line 4643
                  show_message((char *)"unable to write cache file \"%s\": %s\n",
                               cache_file, tmp___27);
                  }
                }
              }
            } else {
#line 4650
              if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 4650
                tmp___29 = "(null)";
              } else {
#line 4650
                tmp___29 = (char const   *)host;
              }
              {
#line 4650
              tmp___30 = inet_ntoa(sin.sin_addr);
#line 4650
              show_message((char *)"failure to update %s->%s (%s)\n", interface, tmp___30,
                           tmp___29);
#line 4652
              memset((void *)(& sin), 0, sizeof(sin));
              }
#line 4657
              if (local_update_period < 300) {
#line 4659
                local_update_period = 300;
              } else {
#line 4663
                local_update_period *= 2;
              }
#line 4665
              if (local_update_period > 7200) {
#line 4667
                local_update_period = 7200;
              }
#line 4672
              if (updateres == 2) {
#line 4674
                if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 4674
                  tmp___31 = "(null)";
                } else {
#line 4674
                  tmp___31 = (char const   *)host;
                }
                {
#line 4674
                show_message((char *)"shuting down updater for %s due to fatal error\n",
                             tmp___31);
                }
#line 4677
                if (notify_email) {
#line 4677
                  if ((int )*notify_email != 0) {
                    {
#line 4682
                    snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0),
                             (char const   */* __restrict  */)"echo \"ez-ipupdate shuting down updater for %s due to fatal error.\" | %s %s",
                             host, "mail", notify_email);
#line 4686
                    system((char const   *)(buf___0));
                    }
                  }
                }
#line 4688
                goto while_break___0;
              }
            }
          }
        }
        {
#line 4692
        sleep((unsigned int )local_update_period);
        }
      } else {
#line 4696
        if (! ifresolve_warned) {
#line 4698
          ifresolve_warned = 1;
#line 4699
          if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 4699
            tmp___34 = "(null)";
          } else {
#line 4699
            tmp___34 = (char const   *)host;
          }
          {
#line 4699
          show_message((char *)"(%s) unable to resolve interface %s\n", tmp___34,
                       interface);
          }
        }
        {
#line 4702
        sleep((unsigned int )resolv_period);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4707
    if (pid_file) {
      {
#line 4709
      pid_file_delete(pid_file);
      }
    }
  } else {
#line 4722
    need_update = 1;
#line 4724
    if (cache_file) {
      {
#line 4730
      tmp___41 = read_cache_file(cache_file, & ipdate___0, & ipstr___0);
      }
#line 4730
      if (tmp___41 != 0) {
        {
#line 4732
        tmp___40 = __errno_location();
        }
#line 4732
        if (*tmp___40 == 0) {
#line 4732
          tmp___39 = "malformed entry";
        } else {
          {
#line 4732
          tmp___37 = __errno_location();
#line 4732
          tmp___38 = strerror(*tmp___37);
#line 4732
          tmp___39 = (char const   *)tmp___38;
          }
        }
        {
#line 4732
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading cache file \"%s\": %s\n",
                cache_file, tmp___39);
        }
      }
#line 4739
      if ((unsigned long )ipstr___0 != (unsigned long )((void *)0)) {
#line 4742
        if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 4742
          goto _L___0;
        } else
#line 4742
        if ((int )*address == 0) {
          _L___0: /* CIL Label */ 
          {
#line 4748
          sock___0 = socket(2, 1, 0);
#line 4749
          tmp___42 = get_if_addr(sock___0, interface, & sin___0);
          }
#line 4749
          if (tmp___42 != 0) {
            {
#line 4751
            exit(1);
            }
          }
          {
#line 4753
          close(sock___0);
#line 4754
          tmp___43 = inet_ntoa(sin___0.sin_addr);
#line 4754
          snprintf((char */* __restrict  */)(ipbuf___0), sizeof(ipbuf___0), (char const   */* __restrict  */)"%s",
                   tmp___43);
          }
        } else {
          {
#line 4762
          snprintf((char */* __restrict  */)(ipbuf___0), sizeof(ipbuf___0), (char const   */* __restrict  */)"%s",
                   address);
          }
        }
        {
#line 4766
        tmp___44 = strcmp((char const   *)ipstr___0, (char const   *)(ipbuf___0));
        }
#line 4766
        if (tmp___44 == 0) {
#line 4769
          need_update = 0;
        }
#line 4773
        if (max_interval > 0) {
          {
#line 4775
          tmp___45 = time((void *)0);
          }
#line 4775
          if ((time_t )tmp___45 - ipdate___0 > (time_t )max_interval) {
#line 4778
            need_update = 1;
          }
        }
      }
#line 4782
      if (ipstr___0) {
        {
#line 4782
        free((void *)ipstr___0);
#line 4782
        ipstr___0 = (char *)((void *)0);
        }
      }
    }
#line 4785
    if (need_update) {
#line 4789
      if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 4789
        if ((unsigned long )interface != (unsigned long )((void *)0)) {
          {
#line 4794
          sock___1 = socket(2, 1, 0);
#line 4795
          tmp___47 = get_if_addr(sock___1, interface, & sin___1);
          }
#line 4795
          if (tmp___47 == 0) {
#line 4797
            if (address) {
              {
#line 4797
              free((void *)address);
              }
            }
            {
#line 4798
            tmp___46 = inet_ntoa(sin___1.sin_addr);
#line 4798
            address = strdup((char const   *)tmp___46);
            }
          } else {
            {
#line 4802
            show_message((char *)"could not resolve ip address for %s.\n", interface);
#line 4803
            exit(1);
            }
          }
          {
#line 4805
          close(sock___1);
          }
        }
      }
#line 4808
      i = 0;
      {
#line 4808
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4808
        if (! (i < ntrys)) {
#line 4808
          goto while_break___1;
        }
        {
#line 4810
        tmp___48 = (*(service->update_entry))();
        }
#line 4810
        if (tmp___48 == 0) {
#line 4812
          retval = 0;
#line 4813
          goto while_break___1;
        }
#line 4815
        if (i + 1 != ntrys) {
          {
#line 4815
          sleep((unsigned int )(10 + 10 * i));
          }
        }
#line 4808
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4817
      if (retval == 0) {
#line 4817
        if (post_update_cmd) {
          {
#line 4819
          res___0 = exec_cmd(post_update_cmd);
          }
#line 4819
          if (res___0 != 0) {
#line 4821
            if (! (options & 8)) {
#line 4823
              if (res___0 == -1) {
                {
#line 4825
                tmp___49 = __errno_location();
#line 4825
                tmp___50 = strerror(*tmp___49);
#line 4825
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error running post update command: %s\n",
                        tmp___50);
                }
              } else {
                {
#line 4830
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error running post update command, command exit code: %d\n",
                        res___0);
                }
              }
            }
          }
        }
      }
#line 4839
      if (retval == 0) {
#line 4839
        if (cache_file) {
#line 4843
          if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 4843
            goto _L___1;
          } else
#line 4843
          if ((int )*address == 0) {
            _L___1: /* CIL Label */ 
            {
#line 4849
            sock___2 = socket(2, 1, 0);
#line 4850
            tmp___51 = get_if_addr(sock___2, interface, & sin___2);
            }
#line 4850
            if (tmp___51 != 0) {
              {
#line 4852
              exit(1);
              }
            }
            {
#line 4854
            close(sock___2);
#line 4855
            tmp___52 = inet_ntoa(sin___2.sin_addr);
#line 4855
            snprintf((char */* __restrict  */)(ipbuf___1), sizeof(ipbuf___1), (char const   */* __restrict  */)"%s",
                     tmp___52);
            }
          } else {
            {
#line 4863
            snprintf((char */* __restrict  */)(ipbuf___1), sizeof(ipbuf___1), (char const   */* __restrict  */)"%s",
                     address);
            }
          }
          {
#line 4866
          tmp___55 = time((void *)0);
#line 4866
          tmp___56 = write_cache_file(cache_file, (time_t )tmp___55, ipbuf___1);
          }
#line 4866
          if (tmp___56 != 0) {
            {
#line 4868
            tmp___53 = __errno_location();
#line 4868
            tmp___54 = strerror(*tmp___53);
#line 4868
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to write cache file \"%s\": %s\n",
                    cache_file, tmp___54);
#line 4870
            exit(1);
            }
          }
        }
      }
    } else {
      {
#line 4876
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no update needed at this time\n");
      }
    }
  }
#line 4881
  if (sock > 0) {
    {
#line 4881
    close(sock);
    }
  }
#line 4884
  if (address) {
    {
#line 4884
    free((void *)address);
    }
  }
#line 4885
  if (cache_file) {
    {
#line 4885
    free((void *)cache_file);
    }
  }
#line 4886
  if (config_file) {
    {
#line 4886
    free((void *)config_file);
    }
  }
#line 4887
  if (host) {
    {
#line 4887
    free((void *)host);
    }
  }
#line 4888
  if (interface) {
    {
#line 4888
    free((void *)interface);
    }
  }
#line 4889
  if (mx) {
    {
#line 4889
    free((void *)mx);
    }
  }
#line 4890
  if (port) {
    {
#line 4890
    free((void *)port);
    }
  }
#line 4891
  if (request) {
    {
#line 4891
    free((void *)request);
    }
  }
#line 4892
  if (request_over_ride) {
    {
#line 4892
    free((void *)request_over_ride);
    }
  }
#line 4893
  if (server) {
    {
#line 4893
    free((void *)server);
    }
  }
#line 4894
  if (url) {
    {
#line 4894
    free((void *)url);
    }
  }
#line 4895
  if (partner) {
    {
#line 4895
    free((void *)partner);
    }
  }
#line 4898
  return (retval);
}
}
