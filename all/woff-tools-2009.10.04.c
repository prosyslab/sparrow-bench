/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 37 "/usr/include/stdint.h"
typedef short int16_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 80 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
#pragma pack(push,1)
#line 82 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
struct __anonstruct_sfntHeader_8 {
   uint32_t version ;
   uint16_t numTables ;
   uint16_t searchRange ;
   uint16_t entrySelector ;
   uint16_t rangeShift ;
};
#line 82 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
typedef struct __anonstruct_sfntHeader_8 sfntHeader;
#line 90 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
struct __anonstruct_sfntDirEntry_9 {
   uint32_t tag ;
   uint32_t checksum ;
   uint32_t offset ;
   uint32_t length ;
};
#line 90 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
typedef struct __anonstruct_sfntDirEntry_9 sfntDirEntry;
#line 97 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
struct __anonstruct_woffHeader_10 {
   uint32_t signature ;
   uint32_t flavor ;
   uint32_t length ;
   uint16_t numTables ;
   uint16_t reserved ;
   uint32_t totalSfntSize ;
   uint16_t majorVersion ;
   uint16_t minorVersion ;
   uint32_t metaOffset ;
   uint32_t metaCompLen ;
   uint32_t metaOrigLen ;
   uint32_t privOffset ;
   uint32_t privLen ;
};
#line 97 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
typedef struct __anonstruct_woffHeader_10 woffHeader;
#line 113 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
struct __anonstruct_woffDirEntry_11 {
   uint32_t tag ;
   uint32_t offset ;
   uint32_t compLen ;
   uint32_t origLen ;
   uint32_t checksum ;
};
#line 113 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
typedef struct __anonstruct_woffDirEntry_11 woffDirEntry;
#line 121 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
struct __anonstruct_sfntHeadTable_12 {
   uint32_t version ;
   uint32_t fontRevision ;
   uint32_t checkSumAdjustment ;
   uint32_t magicNumber ;
   uint16_t flags ;
   uint16_t unitsPerEm ;
   uint32_t created[2] ;
   uint32_t modified[2] ;
   int16_t xMin ;
   int16_t yMin ;
   int16_t xMax ;
   int16_t yMax ;
   uint16_t macStyle ;
   uint16_t lowestRecPpem ;
   int16_t fontDirectionHint ;
   int16_t indexToLocFormat ;
   int16_t glyphDataFormat ;
};
#line 121 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
typedef struct __anonstruct_sfntHeadTable_12 sfntHeadTable;
#line 143 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
struct __anonstruct_tableOrderRec_13 {
   uint32_t offset ;
   uint16_t oldIndex ;
   uint16_t newIndex ;
};
#line 143 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
typedef struct __anonstruct_tableOrderRec_13 tableOrderRec;
#line 149
#pragma pack(pop)
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
#line 382 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef uLong uLongf;
#line 80 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff-private.h"
#pragma pack(push,1)
#line 149
#pragma pack(pop)
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 109 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.h"
uint8_t const   *woffEncode(uint8_t const   *sfntData , uint32_t sfntLen , uint16_t majorVersion ,
                            uint16_t minorVersion , uint32_t *woffLen , uint32_t *pStatus ) ;
#line 123
uint8_t const   *woffSetMetadata(uint8_t const   *woffData , uint32_t *woffLen , uint8_t const   *metaData ,
                                 uint32_t metaLen , uint32_t *pStatus ) ;
#line 137
uint8_t const   *woffSetPrivateData(uint8_t const   *woffData , uint32_t *woffLen ,
                                    uint8_t const   *privData , uint32_t privLen ,
                                    uint32_t *pStatus ) ;
#line 205
void woffPrintStatus(FILE *f , uint32_t status , char const   *prefix ) ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/sfnt2woff.c"
static void die(char const   *msg ) 
{ 


  {
  {
#line 48
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# fatal error: %s\n",
          msg);
#line 49
  exit(2);
  }
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/sfnt2woff.c"
static void reportErr(uint32_t status ) 
{ 


  {
  {
#line 55
  woffPrintStatus(stderr, status, "### ");
#line 56
  exit(2);
  }
}
}
#line 59 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/sfnt2woff.c"
static void usage(char const   *progName ) 
{ 


  {
  {
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n  %s [-v <maj>.<min>] [-m <metadata.xml>] [-p <private.dat>] <otffile>\n    package OpenType <otffile> as WOFF, creating <otffile>.woff\nOptions:\n    -v <maj>.<min>     set font version number (major and minor, both integers)\n    -m <metadata.xml>  include metadata from <metadata.xml> (not validated)\n    -p <private.dat>   include private data block\n",
          progName);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/sfnt2woff.c"
uint8_t const   *readFile(char const   *name , uint32_t *len ) 
{ 
  FILE *inFile ;
  FILE *tmp ;
  char buf[200] ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  uint8_t *data ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 75
  tmp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
#line 75
  inFile = tmp;
  }
#line 76
  if (! inFile) {
    {
#line 78
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"unable to open file %s",
            name);
#line 79
    die((char const   *)(buf));
    }
  }
  {
#line 82
  tmp___0 = fseek(inFile, 0L, 2);
  }
#line 82
  if (tmp___0 != 0) {
    {
#line 83
    die("seek failure");
    }
  }
  {
#line 84
  tmp___1 = ftell(inFile);
#line 84
  *len = (uint32_t )tmp___1;
#line 85
  tmp___2 = fseek(inFile, 0L, 0);
  }
#line 85
  if (tmp___2 != 0) {
    {
#line 86
    die("seek failure");
    }
  }
  {
#line 88
  tmp___3 = malloc((size_t )*len);
#line 88
  data = (uint8_t *)tmp___3;
  }
#line 89
  if (! data) {
    {
#line 90
    die("malloc failure");
    }
  }
  {
#line 91
  tmp___4 = fread((void */* __restrict  */)data, (size_t )1, (size_t )*len, (FILE */* __restrict  */)inFile);
  }
#line 91
  if (tmp___4 != (size_t )*len) {
    {
#line 92
    die("file read failure");
    }
  }
  {
#line 93
  fclose(inFile);
  }
#line 95
  return ((uint8_t const   *)data);
}
}
#line 98 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/sfnt2woff.c"
int main(int argc , char **argv ) 
{ 
  char const   *progName ;
  char const   *metadataFile ;
  char const   *privateFile ;
  unsigned int maj ;
  unsigned int min ;
  uint32_t status ;
  int opt ;
  int tmp ;
  uint32_t sfntLen ;
  uint8_t const   *sfntData ;
  uint8_t const   *tmp___0 ;
  uint32_t woffLen ;
  uint8_t const   *woffData ;
  uint8_t const   *tmp___1 ;
  uint32_t len ;
  uint8_t const   *data ;
  uint8_t const   *tmp___2 ;
  uint32_t len___0 ;
  uint8_t const   *data___0 ;
  uint8_t const   *tmp___3 ;
  char *outName ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *ext ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  FILE *outFile ;
  FILE *tmp___9 ;
  size_t tmp___10 ;

  {
#line 101
  progName = (char const   *)*(argv + 0);
#line 102
  metadataFile = (char const   *)((void *)0);
#line 103
  privateFile = (char const   *)((void *)0);
#line 104
  maj = 0U;
#line 104
  min = 0U;
#line 105
  status = (uint32_t )0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    opt = getopt(argc, (char * const  *)argv, "v:m:p:h");
    }
#line 108
    if (! (opt != -1)) {
#line 108
      goto while_break;
    }
    {
#line 110
    if (opt == 118) {
#line 110
      goto case_118;
    }
#line 116
    if (opt == 109) {
#line 116
      goto case_109;
    }
#line 119
    if (opt == 112) {
#line 119
      goto case_112;
    }
#line 123
    if (opt == 63) {
#line 123
      goto case_63;
    }
#line 123
    if (opt == 104) {
#line 123
      goto case_63;
    }
#line 126
    goto switch_default;
    case_118: /* CIL Label */ 
    {
#line 111
    tmp = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%u.%u",
                 & maj, & min);
    }
#line 111
    if (tmp < 2) {
      {
#line 112
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# bad version number, setting to 0.0\n");
#line 113
      min = 0U;
#line 113
      maj = min;
      }
    } else
#line 111
    if (maj > 65535U) {
      {
#line 112
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# bad version number, setting to 0.0\n");
#line 113
      min = 0U;
#line 113
      maj = min;
      }
    } else
#line 111
    if (min > 65535U) {
      {
#line 112
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# bad version number, setting to 0.0\n");
#line 113
      min = 0U;
#line 113
      maj = min;
      }
    }
#line 115
    goto switch_break;
    case_109: /* CIL Label */ 
#line 117
    metadataFile = (char const   *)optarg;
#line 118
    goto switch_break;
    case_112: /* CIL Label */ 
#line 120
    privateFile = (char const   *)optarg;
#line 121
    goto switch_break;
    case_63: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
#line 124
    usage(progName);
#line 125
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# unknown option \"%c\"\n",
            opt);
    }
#line 128
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  argc -= optind;
#line 132
  argv += optind;
#line 134
  if (argc != 1) {
    {
#line 135
    usage(progName);
#line 136
    exit(1);
    }
  }
  {
#line 140
  tmp___0 = readFile((char const   *)*(argv + 0), & sfntLen);
#line 140
  sfntData = tmp___0;
#line 143
  tmp___1 = woffEncode(sfntData, sfntLen, (uint16_t )maj, (uint16_t )min, & woffLen,
                       & status);
#line 143
  woffData = tmp___1;
#line 144
  free((void *)sfntData);
  }
#line 145
  if (! ((status & 255U) == 0U)) {
    {
#line 146
    reportErr(status);
    }
  }
#line 149
  if (metadataFile) {
    {
#line 151
    tmp___2 = readFile(metadataFile, & len);
#line 151
    data = tmp___2;
#line 152
    woffData = woffSetMetadata(woffData, & woffLen, data, len, & status);
#line 153
    free((void *)data);
    }
#line 154
    if (! ((status & 255U) == 0U)) {
      {
#line 155
      reportErr(status);
      }
    }
  }
#line 159
  if (privateFile) {
    {
#line 161
    tmp___3 = readFile(privateFile, & len___0);
#line 161
    data___0 = tmp___3;
#line 162
    woffData = woffSetPrivateData(woffData, & woffLen, data___0, len___0, & status);
#line 163
    free((void *)data___0);
    }
#line 164
    if (! ((status & 255U) == 0U)) {
      {
#line 165
      reportErr(status);
      }
    }
  }
#line 169
  if (status & 4294967040U) {
    {
#line 170
    woffPrintStatus(stderr, status, "### ");
    }
  }
  {
#line 173
  tmp___4 = strlen((char const   *)*(argv + 0));
#line 173
  tmp___5 = malloc(tmp___4 + 8UL);
#line 173
  outName = (char *)tmp___5;
  }
#line 174
  if (! outName) {
    {
#line 175
    die("malloc failure");
    }
  }
  {
#line 176
  strcpy((char */* __restrict  */)outName, (char const   */* __restrict  */)*(argv + 0));
#line 177
  tmp___6 = strrchr((char const   *)outName, '.');
#line 177
  ext = tmp___6;
  }
#line 178
  if (ext) {
    {
#line 178
    tmp___7 = strcmp((char const   *)ext, ".ttf");
    }
#line 178
    if (tmp___7) {
      {
#line 178
      tmp___8 = strcmp((char const   *)ext, ".otf");
      }
#line 178
      if (! tmp___8) {
#line 179
        *ext = (char)0;
      }
    } else {
#line 179
      *ext = (char)0;
    }
  }
  {
#line 180
  strcat((char */* __restrict  */)outName, (char const   */* __restrict  */)".woff");
  }
#line 182
  if (woffData) {
    {
#line 183
    tmp___9 = fopen((char const   */* __restrict  */)outName, (char const   */* __restrict  */)"wb");
#line 183
    outFile = tmp___9;
#line 184
    free((void *)outName);
    }
#line 185
    if (! outFile) {
      {
#line 186
      die("unable to open output file");
      }
    }
    {
#line 187
    tmp___10 = fwrite((void const   */* __restrict  */)woffData, (size_t )1, (size_t )woffLen,
                      (FILE */* __restrict  */)outFile);
    }
#line 187
    if (tmp___10 != (size_t )woffLen) {
      {
#line 188
      die("file write failure");
      }
    }
    {
#line 189
    fclose(outFile);
#line 190
    free((void *)woffData);
    }
  } else {
    {
#line 192
    die("unable to create WOFF data");
    }
  }
#line 195
  return (0);
}
}
#line 146 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.h"
uint32_t woffGetDecodedSize(uint8_t const   *woffData , uint32_t woffLen , uint32_t *pStatus ) ;
#line 155
void woffDecodeToBuffer(uint8_t const   *woffData , uint32_t woffLen , uint8_t *sfntData ,
                        uint32_t bufferLen , uint32_t *pActualSfntLen , uint32_t *pStatus ) ;
#line 165
uint8_t const   *woffDecode(uint8_t const   *woffData , uint32_t woffLen , uint32_t *sfntLen ,
                            uint32_t *pStatus ) ;
#line 175
uint8_t const   *woffGetMetadata(uint8_t const   *woffData , uint32_t woffLen , uint32_t *metaLen ,
                                 uint32_t *pStatus ) ;
#line 184
uint8_t const   *woffGetPrivateData(uint8_t const   *woffData , uint32_t woffLen ,
                                    uint32_t *privLen , uint32_t *pStatus ) ;
#line 193
void woffGetFontVersion(uint8_t const   *woffData , uint32_t woffLen , uint16_t *major ,
                        uint16_t *minor , uint32_t *pStatus ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 1174 "/usr/include/zlib.h"
extern int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
                     int level ) ;
#line 1190
extern uLong compressBound(uLong sourceLen ) ;
#line 1197
extern int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 66 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static int compareOffsets(void const   *lhs , void const   *rhs ) 
{ 
  tableOrderRec const   *a ;
  tableOrderRec const   *b ;
  int tmp ;
  int tmp___0 ;

  {
#line 69
  a = (tableOrderRec const   *)lhs;
#line 70
  b = (tableOrderRec const   *)rhs;
#line 73
  if (a->offset > b->offset) {
#line 73
    tmp___0 = 1;
  } else {
#line 73
    if (a->offset < b->offset) {
#line 73
      tmp = -1;
    } else {
#line 73
      tmp = 0;
    }
#line 73
    tmp___0 = tmp;
  }
#line 73
  return (tmp___0);
}
}
#line 84 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static uint32_t calcChecksum(sfntDirEntry const   *dirEntry , uint8_t const   *sfntData ,
                             uint32_t sfntLen ) 
{ 
  uint32_t const   *csumPtr ;
  uint32_t const   *csumEnd ;
  uint32_t csum ;
  uint32_t length ;
  uint32_t offset ;
  uint32_t tag ;
  sfntHeadTable const   *head ;

  {
#line 91
  csum = (uint32_t )0;
#line 92
  length = ((((uint32_t )*((uint8_t *)(& dirEntry->length) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->length) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->length) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->length) + 3);
#line 93
  offset = ((((uint32_t )*((uint8_t *)(& dirEntry->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->offset) + 3);
#line 95
  if (((length + 3U) & 4294967292U) < length) {
#line 96
    return (csum);
  } else {
#line 98
    length = (length + 3U) & 4294967292U;
  }
#line 100
  if ((offset & 3U) != 0U) {
#line 101
    return (csum);
  }
#line 103
  if (length > sfntLen) {
#line 104
    return (csum);
  } else
#line 103
  if (offset > sfntLen - length) {
#line 104
    return (csum);
  }
#line 106
  csumPtr = (uint32_t const   *)(sfntData + offset);
#line 107
  csumEnd = csumPtr + length / 4U;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )csumPtr < (unsigned long )csumEnd)) {
#line 108
      goto while_break;
    }
#line 109
    csum += ((((uint32_t )*((uint8_t *)csumPtr + 0) << 24) + ((uint32_t )*((uint8_t *)csumPtr + 1) << 16)) + ((uint32_t )*((uint8_t *)csumPtr + 2) << 8)) + (uint32_t )*((uint8_t *)csumPtr + 3);
#line 110
    csumPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  tag = ((((uint32_t )*((uint8_t *)(& dirEntry->tag) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->tag) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->tag) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->tag) + 3);
#line 113
  if (tag == (uint32_t )((((104 << 24) | (101 << 16)) | (97 << 8)) | 100)) {
#line 113
    goto _L;
  } else
#line 113
  if (tag == (uint32_t )((((98 << 24) | (104 << 16)) | (101 << 8)) | 100)) {
    _L: /* CIL Label */ 
#line 115
    if (length < 54U) {
#line 116
      return ((uint32_t )0);
    }
#line 118
    head = (sfntHeadTable const   *)(sfntData + offset);
#line 119
    csum -= ((((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 0) << 24) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 2) << 8)) + (uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 3);
  }
#line 121
  return (csum);
}
}
#line 124 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
uint8_t const   *woffEncode(uint8_t const   *sfntData , uint32_t sfntLen , uint16_t majorVersion ,
                            uint16_t minorVersion , uint32_t *woffLen , uint32_t *pStatus ) 
{ 
  uint8_t *woffData ;
  uint8_t *woffDataNew ;
  tableOrderRec *tableOrder ;
  uint32_t tableOffset ;
  uint32_t totalSfntSize ;
  uint16_t numOrigTables ;
  uint16_t numTables ;
  uint16_t tableIndex ;
  uint16_t order ;
  sfntDirEntry const   *sfntDir ;
  uint32_t checkSumAdjustment ;
  woffHeader *newHeader ;
  uint32_t tag ;
  uint32_t removedDsigSize ;
  uint32_t status ;
  sfntHeader const   *header ;
  sfntHeadTable const   *head ;
  uint32_t prevTag ;
  uint32_t csum ;
  uint32_t tmp ;
  uint32_t const   *csumPtr ;
  uint32_t const   *csumEnd ;
  void *tmp___0 ;
  void *tmp___1 ;
  uLong sourceLen ;
  uLong destLen ;
  uint32_t sourceOffset ;
  uint16_t oldIndex ;
  uint16_t newIndex ;
  uint32_t csum___0 ;
  uint32_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  uint32_t tmp___6 ;
  uint8_t const   *cleanSfnt ;
  uint8_t const   *tmp___7 ;
  uint8_t const   *tmp___8 ;

  {
#line 129
  woffData = (uint8_t *)((void *)0);
#line 130
  woffDataNew = (uint8_t *)((void *)0);
#line 131
  tableOrder = (tableOrderRec *)((void *)0);
#line 141
  checkSumAdjustment = (uint32_t )0;
#line 143
  tag = (uint32_t )0;
#line 144
  removedDsigSize = (uint32_t )0;
#line 145
  status = (uint32_t )0;
#line 147
  header = (sfntHeader const   *)sfntData;
#line 148
  head = (sfntHeadTable const   *)((void *)0);
#line 150
  if (pStatus) {
#line 150
    if (! ((*pStatus & 255U) == 0U)) {
#line 151
      return ((uint8_t const   *)((void *)0));
    }
  }
#line 154
  if (((((uint32_t )*((uint8_t *)(& header->version) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->version) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->version) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->version) + 3) != 65536U) {
#line 154
    if (((((uint32_t )*((uint8_t *)(& header->version) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->version) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->version) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->version) + 3) != (uint32_t )((((79 << 24) | (84 << 16)) | (84 << 8)) | 79)) {
#line 154
      if (((((uint32_t )*((uint8_t *)(& header->version) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->version) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->version) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->version) + 3) != (uint32_t )((((116 << 24) | (114 << 16)) | (117 << 8)) | 101)) {
#line 157
        status |= 256U;
      }
    }
  }
#line 160
  numOrigTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& header->numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& header->numTables) + 1)));
#line 161
  sfntDir = (sfntDirEntry const   *)(sfntData + sizeof(sfntHeader ));
#line 163
  tableIndex = (uint16_t )0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! ((int )tableIndex < (int )numOrigTables)) {
#line 163
      goto while_break;
    }
    {
#line 166
    prevTag = tag;
#line 167
    tmp = calcChecksum(sfntDir + tableIndex, sfntData, sfntLen);
#line 167
    csum = tmp;
    }
#line 168
    if (csum != ((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 3)) {
#line 169
      status |= 512U;
    }
#line 171
    checkSumAdjustment += csum;
#line 172
    tag = ((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 3);
#line 173
    if (tag <= prevTag) {
      {
#line 174
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 174
        status |= 2U;
#line 174
        goto failure;
#line 174
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 176
    if (tag == (uint32_t )((((104 << 24) | (101 << 16)) | (97 << 8)) | 100)) {
#line 176
      goto _L;
    } else
#line 176
    if (tag == (uint32_t )((((98 << 24) | (104 << 16)) | (101 << 8)) | 100)) {
      _L: /* CIL Label */ 
#line 177
      if (((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->length) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->length) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->length) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->length) + 3) < 54U) {
        {
#line 178
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 178
          status |= 2U;
#line 178
          goto failure;
#line 178
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 180
      head = (sfntHeadTable const   *)(sfntData + (((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->offset) + 3)));
    }
#line 163
    tableIndex = (uint16_t )((int )tableIndex + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if (! head) {
    {
#line 185
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 185
      status |= 2U;
#line 185
      goto failure;
#line 185
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 187
  if ((status & 512U) == 0U) {
#line 190
    csumPtr = (uint32_t const   *)sfntData;
#line 191
    csumEnd = (csumPtr + 3) + 4 * (int )numOrigTables;
    {
#line 192
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 192
      if (! ((unsigned long )csumPtr < (unsigned long )csumEnd)) {
#line 192
        goto while_break___3;
      }
#line 193
      checkSumAdjustment += ((((uint32_t )*((uint8_t *)csumPtr + 0) << 24) + ((uint32_t )*((uint8_t *)csumPtr + 1) << 16)) + ((uint32_t )*((uint8_t *)csumPtr + 2) << 8)) + (uint32_t )*((uint8_t *)csumPtr + 3);
#line 194
      csumPtr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 196
    checkSumAdjustment = 2981146554U - checkSumAdjustment;
#line 197
    if (checkSumAdjustment != ((((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 0) << 24) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 2) << 8)) + (uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 3)) {
#line 198
      status |= 512U;
    }
  }
  {
#line 220
  tmp___0 = malloc((unsigned long )numOrigTables * sizeof(tableOrderRec ));
#line 220
  tableOrder = (tableOrderRec *)tmp___0;
  }
#line 221
  if (! tableOrder) {
    {
#line 222
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 222
      status |= 1U;
#line 222
      goto failure;
#line 222
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 224
  tableIndex = (uint16_t )0;
#line 224
  numTables = (uint16_t )0;
  {
#line 224
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 224
    if (! ((int )tableIndex < (int )numOrigTables)) {
#line 224
      goto while_break___5;
    }
#line 226
    if ((status & 512U) != 0U) {
#line 228
      tag = ((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 3);
#line 229
      if (tag == (uint32_t )((((68 << 24) | (83 << 16)) | (73 << 8)) | 71)) {
#line 230
        status |= 8192U;
#line 231
        removedDsigSize = ((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->length) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->length) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->length) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->length) + 3);
#line 232
        if (((removedDsigSize + 3U) & 4294967292U) < removedDsigSize) {
          {
#line 233
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 233
            status |= 2U;
#line 233
            goto failure;
#line 233
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 235
        goto __Cont;
      }
    }
#line 238
    (tableOrder + numTables)->offset = ((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->offset) + 3);
#line 239
    (tableOrder + numTables)->oldIndex = tableIndex;
#line 240
    (tableOrder + numTables)->newIndex = numTables;
#line 241
    numTables = (uint16_t )((int )numTables + 1);
    __Cont: /* CIL Label */ 
#line 224
    tableIndex = (uint16_t )((int )tableIndex + 1);
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 243
  qsort((void *)tableOrder, (size_t )numTables, sizeof(tableOrderRec ), & compareOffsets);
#line 247
  tableOffset = (uint32_t )(sizeof(woffHeader ) + (unsigned long )numTables * sizeof(woffDirEntry ));
#line 248
  tmp___1 = malloc((size_t )tableOffset);
#line 248
  woffData = (uint8_t *)tmp___1;
  }
#line 249
  if (! woffData) {
    {
#line 250
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 250
      status |= 1U;
#line 250
      goto failure;
#line 250
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 254
  totalSfntSize = (uint32_t )(sizeof(sfntHeader ) + (unsigned long )numTables * sizeof(sfntDirEntry ));
#line 263
  order = (uint16_t )0;
  {
#line 263
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 263
    if (! ((int )order < (int )numTables)) {
#line 263
      goto while_break___8;
    }
#line 267
    oldIndex = (tableOrder + order)->oldIndex;
#line 268
    newIndex = (tableOrder + order)->newIndex;
#line 270
    ((woffDirEntry *)(woffData + sizeof(woffHeader )) + newIndex)->tag = (uint32_t )(sfntDir + oldIndex)->tag;
#line 271
    if ((status & 512U) != 0U) {
      {
#line 272
      tmp___2 = calcChecksum(sfntDir + oldIndex, sfntData, sfntLen);
#line 272
      csum___0 = tmp___2;
#line 273
      ((woffDirEntry *)(woffData + sizeof(woffHeader )) + newIndex)->checksum = ((((uint32_t )*((uint8_t *)(& csum___0) + 0) << 24) + ((uint32_t )*((uint8_t *)(& csum___0) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& csum___0) + 2) << 8)) + (uint32_t )*((uint8_t *)(& csum___0) + 3);
      }
    } else {
#line 275
      ((woffDirEntry *)(woffData + sizeof(woffHeader )) + newIndex)->checksum = (uint32_t )(sfntDir + oldIndex)->checksum;
    }
#line 277
    ((woffDirEntry *)(woffData + sizeof(woffHeader )) + newIndex)->origLen = (uint32_t )(sfntDir + oldIndex)->length;
#line 278
    ((woffDirEntry *)(woffData + sizeof(woffHeader )) + newIndex)->offset = ((((uint32_t )*((uint8_t *)(& tableOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& tableOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& tableOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& tableOffset) + 3);
#line 281
    sourceOffset = ((((uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->offset) + 3);
#line 282
    if ((sourceOffset & 3U) != 0U) {
#line 283
      status |= 1024U;
    }
#line 285
    sourceLen = (uLong )(((((uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->length) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->length) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->length) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->length) + 3));
#line 286
    if (sourceLen > (uLong )sfntLen) {
#line 286
      goto _L___0;
    } else
#line 286
    if ((uLong )sourceOffset > (uLong )sfntLen - sourceLen) {
      _L___0: /* CIL Label */ 
      {
#line 287
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 287
        status |= 2U;
#line 287
        goto failure;
#line 287
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
    {
#line 289
    destLen = compressBound(sourceLen);
    }
#line 290
    if (((destLen + 3UL) & 0xfffffffffffffffcUL) < destLen) {
      {
#line 292
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 292
        status |= 2U;
#line 292
        goto failure;
#line 292
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 294
    destLen = (destLen + 3UL) & 0xfffffffffffffffcUL;
#line 295
    if ((uLong )tableOffset + destLen < (uLong )tableOffset) {
      {
#line 296
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 296
        status |= 2U;
#line 296
        goto failure;
#line 296
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    {
#line 298
    tmp___3 = realloc((void *)woffData, (uLong )tableOffset + destLen);
#line 298
    woffDataNew = (uint8_t *)tmp___3;
    }
#line 299
    if (woffDataNew) {
#line 300
      woffData = woffDataNew;
    } else {
      {
#line 302
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 302
        status |= 1U;
#line 302
        goto failure;
#line 302
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
    {
#line 306
    tmp___4 = compress2(woffData + tableOffset, & destLen, sfntData + sourceOffset,
                        sourceLen, 9);
    }
#line 306
    if (tmp___4 != 0) {
      {
#line 309
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 309
        status |= 3U;
#line 309
        goto failure;
#line 309
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 311
    if (destLen < sourceLen) {
#line 313
      tableOffset = (uint32_t )((uLong )tableOffset + destLen);
#line 314
      ((woffDirEntry *)(woffData + sizeof(woffHeader )) + newIndex)->compLen = ((((uint32_t )*((uint8_t *)(& destLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& destLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& destLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& destLen) + 3);
    } else {
#line 317
      if (((sourceLen + 3UL) & 0xfffffffffffffffcUL) < sourceLen) {
        {
#line 318
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 318
          status |= 2U;
#line 318
          goto failure;
#line 318
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
#line 320
      destLen = sourceLen;
#line 323
      if ((unsigned long )tableOffset + ((sourceLen + 3UL) & 0xfffffffffffffffcUL) < (unsigned long )tableOffset) {
        {
#line 324
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 324
          status |= 2U;
#line 324
          goto failure;
#line 324
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      {
#line 326
      tmp___5 = realloc((void *)woffData, (unsigned long )tableOffset + ((sourceLen + 3UL) & 0xfffffffffffffffcUL));
#line 326
      woffDataNew = (uint8_t *)tmp___5;
      }
#line 328
      if (woffDataNew) {
#line 329
        woffData = woffDataNew;
      } else {
        {
#line 331
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 331
          status |= 1U;
#line 331
          goto failure;
#line 331
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
      {
#line 334
      memcpy((void */* __restrict  */)(woffData + tableOffset), (void const   */* __restrict  */)(sfntData + (((((uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + oldIndex)->offset) + 3))),
             sourceLen);
      }
#line 336
      if ((uLong )tableOffset + sourceLen < (uLong )tableOffset) {
        {
#line 337
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 337
          status |= 2U;
#line 337
          goto failure;
#line 337
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
      }
#line 339
      tableOffset = (uint32_t )((uLong )tableOffset + sourceLen);
#line 340
      ((woffDirEntry *)(woffData + sizeof(woffHeader )) + newIndex)->compLen = ((woffDirEntry *)(woffData + sizeof(woffHeader )) + newIndex)->origLen;
    }
    {
#line 344
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 344
      if (! ((tableOffset & 3U) != 0U)) {
#line 344
        goto while_break___18;
      }
#line 345
      tmp___6 = tableOffset;
#line 345
      tableOffset ++;
#line 345
      *(woffData + tmp___6) = (uint8_t )0;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 349
    if ((uLong )totalSfntSize + sourceLen < (uLong )totalSfntSize) {
      {
#line 350
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 350
        status |= 2U;
#line 350
        goto failure;
#line 350
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
    }
#line 352
    totalSfntSize = (uint32_t )((uLong )totalSfntSize + sourceLen);
#line 353
    if (((totalSfntSize + 3U) & 4294967292U) < totalSfntSize) {
      {
#line 354
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 354
        status |= 2U;
#line 354
        goto failure;
#line 354
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
#line 356
    totalSfntSize = (totalSfntSize + 3U) & 4294967292U;
#line 263
    order = (uint16_t )((int )order + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
#line 359
  if (totalSfntSize > sfntLen) {
#line 360
    if (totalSfntSize > ((sfntLen + 3U) & 4294967292U)) {
      {
#line 361
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 361
        status |= 2U;
#line 361
        goto failure;
#line 361
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
    } else {
#line 363
      status |= 4096U;
    }
  } else
#line 365
  if (totalSfntSize < sfntLen) {
#line 368
    if ((status & 8192U) != 0U) {
#line 371
      status |= 2048U;
    } else
#line 368
    if ((unsigned long )(sfntLen - totalSfntSize) > (unsigned long )((removedDsigSize + 3U) & 4294967292U) + sizeof(sfntDirEntry )) {
#line 371
      status |= 2048U;
    }
  }
  {
#line 376
  newHeader = (woffHeader *)woffData;
#line 377
  newHeader->signature = (uint32_t )((((119 << 24) | (79 << 16)) | (70 << 8)) | 70);
#line 378
  newHeader->signature = ((((uint32_t )*((uint8_t *)(& newHeader->signature) + 0) << 24) + ((uint32_t )*((uint8_t *)(& newHeader->signature) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& newHeader->signature) + 2) << 8)) + (uint32_t )*((uint8_t *)(& newHeader->signature) + 3);
#line 379
  newHeader->flavor = (uint32_t )header->version;
#line 380
  newHeader->length = ((((uint32_t )*((uint8_t *)(& tableOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& tableOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& tableOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& tableOffset) + 3);
#line 381
  newHeader->numTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& numTables) + 1)));
#line 382
  newHeader->reserved = (uint16_t )0;
#line 383
  newHeader->totalSfntSize = ((((uint32_t )*((uint8_t *)(& totalSfntSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& totalSfntSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& totalSfntSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& totalSfntSize) + 3);
#line 384
  newHeader->majorVersion = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& majorVersion) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& majorVersion) + 1)));
#line 385
  newHeader->minorVersion = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& minorVersion) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& minorVersion) + 1)));
#line 386
  newHeader->metaOffset = (uint32_t )0;
#line 387
  newHeader->metaCompLen = (uint32_t )0;
#line 388
  newHeader->metaOrigLen = (uint32_t )0;
#line 389
  newHeader->privOffset = (uint32_t )0;
#line 390
  newHeader->privLen = (uint32_t )0;
#line 392
  free((void *)tableOrder);
  }
#line 394
  if ((status & 512U) != 0U) {
    {
#line 398
    tmp___7 = woffDecode((uint8_t const   *)woffData, tableOffset, & sfntLen, & status);
#line 398
    cleanSfnt = tmp___7;
    }
#line 400
    if (! ((status & 255U) == 0U)) {
      {
#line 401
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 401
        status |= status;
#line 401
        goto failure;
#line 401
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
    }
    {
#line 403
    free((void *)woffData);
#line 404
    tmp___8 = woffEncode(cleanSfnt, sfntLen, majorVersion, minorVersion, & tableOffset,
                         & status);
#line 404
    woffData = (uint8_t *)tmp___8;
#line 407
    free((void *)cleanSfnt);
    }
#line 408
    if (! ((status & 255U) == 0U)) {
      {
#line 409
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 409
        status |= status;
#line 409
        goto failure;
#line 409
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
    }
  }
#line 413
  if (woffLen) {
#line 414
    *woffLen = tableOffset;
  }
#line 416
  if (pStatus) {
#line 417
    *pStatus |= status;
  }
#line 419
  return ((uint8_t const   *)woffData);
  failure: 
#line 422
  if (tableOrder) {
    {
#line 423
    free((void *)tableOrder);
    }
  }
#line 425
  if (woffData) {
    {
#line 426
    free((void *)woffData);
    }
  }
#line 428
  if (pStatus) {
#line 429
    *pStatus = status;
  }
#line 431
  return ((uint8_t const   *)((void *)0));
}
}
#line 434 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static uint8_t const   *rebuildWoff(uint8_t const   *woffData , uint32_t *woffLen ,
                                    uint8_t const   *metaData , uint32_t metaCompLen ,
                                    uint32_t metaOrigLen , uint8_t const   *privData ,
                                    uint32_t privLen , uint32_t *pStatus ) 
{ 
  woffHeader const   *origHeader ;
  woffDirEntry const   *woffDir ;
  uint8_t *newData ;
  woffHeader *newHeader ;
  uint16_t numTables ;
  uint32_t tableLimit ;
  uint32_t totalSize ;
  uint32_t offset ;
  uint16_t i ;
  uint32_t status ;
  uint32_t end ;
  void *tmp ;
  uint32_t tmp___0 ;

  {
#line 441
  newData = (uint8_t *)((void *)0);
#line 446
  status = (uint32_t )0;
#line 448
  if ((unsigned long )*woffLen < sizeof(woffHeader )) {
    {
#line 449
    while (1) {
      while_continue: /* CIL Label */ ;
#line 449
      status |= 2U;
#line 449
      goto failure;
#line 449
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 451
  origHeader = (woffHeader const   *)woffData;
#line 453
  if (((((uint32_t )*((uint8_t *)(& origHeader->signature) + 0) << 24) + ((uint32_t )*((uint8_t *)(& origHeader->signature) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& origHeader->signature) + 2) << 8)) + (uint32_t )*((uint8_t *)(& origHeader->signature) + 3) != (uint32_t )((((119 << 24) | (79 << 16)) | (70 << 8)) | 70)) {
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 454
      status |= 4U;
#line 454
      goto failure;
#line 454
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 457
  numTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& origHeader->numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& origHeader->numTables) + 1)));
#line 458
  woffDir = (woffDirEntry const   *)(woffData + sizeof(woffHeader ));
#line 459
  tableLimit = (uint32_t )0;
#line 460
  i = (uint16_t )0;
  {
#line 460
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 460
    if (! ((int )i < (int )numTables)) {
#line 460
      goto while_break___1;
    }
#line 461
    end = (((((uint32_t )*((uint8_t *)(& (woffDir + i)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + i)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + i)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + i)->offset) + 3)) + (((((uint32_t )*((uint8_t *)(& (woffDir + i)->compLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + i)->compLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + i)->compLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + i)->compLen) + 3));
#line 462
    if (end > tableLimit) {
#line 463
      tableLimit = end;
    }
#line 460
    i = (uint16_t )((int )i + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 466
  tableLimit = (tableLimit + 3U) & 4294967292U;
#line 469
  offset = ((((uint32_t )*((uint8_t *)(& origHeader->metaOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& origHeader->metaOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& origHeader->metaOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& origHeader->metaOffset) + 3);
#line 470
  if (offset != 0U) {
#line 470
    if (offset < tableLimit) {
      {
#line 471
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 471
        status |= 7U;
#line 471
        goto failure;
#line 471
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 473
  offset = ((((uint32_t )*((uint8_t *)(& origHeader->privOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& origHeader->privOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& origHeader->privOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& origHeader->privOffset) + 3);
#line 474
  if (offset != 0U) {
#line 474
    if (offset < tableLimit) {
      {
#line 475
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 475
        status |= 7U;
#line 475
        goto failure;
#line 475
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 478
  totalSize = tableLimit;
#line 479
  if (metaCompLen) {
#line 480
    if (totalSize + metaCompLen < totalSize) {
      {
#line 481
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 481
        status |= 2U;
#line 481
        goto failure;
#line 481
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 483
    totalSize += metaCompLen;
  }
#line 485
  if (privLen) {
#line 486
    if (((totalSize + 3U) & 4294967292U) < totalSize) {
      {
#line 487
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 487
        status |= 2U;
#line 487
        goto failure;
#line 487
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 489
    totalSize = (totalSize + 3U) & 4294967292U;
#line 490
    if (totalSize + privLen < totalSize) {
      {
#line 491
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 491
        status |= 2U;
#line 491
        goto failure;
#line 491
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 493
    totalSize += privLen;
  }
  {
#line 495
  tmp = malloc((size_t )totalSize);
#line 495
  newData = (uint8_t *)tmp;
  }
#line 496
  if (! newData) {
    {
#line 497
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 497
      status |= 1U;
#line 497
      goto failure;
#line 497
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 501
  memcpy((void */* __restrict  */)newData, (void const   */* __restrict  */)woffData,
         (size_t )tableLimit);
#line 504
  newHeader = (woffHeader *)newData;
#line 505
  newHeader->length = ((((uint32_t )*((uint8_t *)(& totalSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& totalSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& totalSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& totalSize) + 3);
#line 506
  newHeader->metaOffset = (uint32_t )0;
#line 507
  newHeader->metaCompLen = (uint32_t )0;
#line 508
  newHeader->metaOrigLen = (uint32_t )0;
#line 509
  newHeader->privOffset = (uint32_t )0;
#line 510
  newHeader->privLen = (uint32_t )0;
#line 512
  offset = tableLimit;
  }
#line 513
  if (metaData) {
#line 513
    if (metaCompLen > 0U) {
#line 513
      if (metaOrigLen > 0U) {
        {
#line 514
        newHeader->metaOffset = ((((uint32_t )*((uint8_t *)(& offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& offset) + 3);
#line 515
        newHeader->metaCompLen = ((((uint32_t )*((uint8_t *)(& metaCompLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& metaCompLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& metaCompLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& metaCompLen) + 3);
#line 516
        newHeader->metaOrigLen = ((((uint32_t )*((uint8_t *)(& metaOrigLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& metaOrigLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& metaOrigLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& metaOrigLen) + 3);
#line 517
        memcpy((void */* __restrict  */)(newData + offset), (void const   */* __restrict  */)metaData,
               (size_t )metaCompLen);
#line 518
        offset += metaCompLen;
        }
      }
    }
  }
#line 521
  if (privData) {
#line 521
    if (privLen > 0U) {
      {
#line 522
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 522
        if (! ((offset & 3U) != 0U)) {
#line 522
          goto while_break___8;
        }
#line 523
        tmp___0 = offset;
#line 523
        offset ++;
#line 523
        *(newData + tmp___0) = (uint8_t )0;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 525
      newHeader->privOffset = ((((uint32_t )*((uint8_t *)(& offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& offset) + 3);
#line 526
      newHeader->privLen = ((((uint32_t )*((uint8_t *)(& privLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& privLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& privLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& privLen) + 3);
#line 527
      memcpy((void */* __restrict  */)(newData + offset), (void const   */* __restrict  */)privData,
             (size_t )privLen);
#line 528
      offset += privLen;
      }
    }
  }
  {
#line 531
  *woffLen = offset;
#line 532
  free((void *)woffData);
  }
#line 534
  if (pStatus) {
#line 535
    *pStatus |= status;
  }
#line 537
  return ((uint8_t const   *)newData);
  failure: 
#line 540
  if (newData) {
    {
#line 541
    free((void *)newData);
    }
  }
#line 543
  if (pStatus) {
#line 544
    *pStatus = status;
  }
#line 546
  return ((uint8_t const   *)((void *)0));
}
}
#line 549 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
uint8_t const   *woffSetMetadata(uint8_t const   *woffData , uint32_t *woffLen , uint8_t const   *metaData ,
                                 uint32_t metaLen , uint32_t *pStatus ) 
{ 
  woffHeader const   *header ;
  uLong compLen ;
  uint8_t *compData ;
  uint8_t const   *privData ;
  uint32_t privLen ;
  uint32_t status ;
  void *tmp ;
  int tmp___0 ;

  {
#line 555
  compLen = (uLong )0;
#line 556
  compData = (uint8_t *)((void *)0);
#line 557
  privData = (uint8_t const   *)((void *)0);
#line 558
  privLen = (uint32_t )0;
#line 559
  status = (uint32_t )0;
#line 561
  if (pStatus) {
#line 561
    if (! ((*pStatus & 255U) == 0U)) {
#line 562
      return ((uint8_t const   *)((void *)0));
    }
  }
#line 565
  if (! woffData) {
#line 565
    goto _L;
  } else
#line 565
  if (! woffLen) {
    _L: /* CIL Label */ 
    {
#line 566
    while (1) {
      while_continue: /* CIL Label */ ;
#line 566
      status |= 6U;
#line 566
      goto failure;
#line 566
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 569
  if ((unsigned long )*woffLen < sizeof(woffHeader )) {
    {
#line 570
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 570
      status |= 2U;
#line 570
      goto failure;
#line 570
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 572
  header = (woffHeader const   *)woffData;
#line 574
  if (((((uint32_t )*((uint8_t *)(& header->signature) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->signature) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->signature) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->signature) + 3) != (uint32_t )((((119 << 24) | (79 << 16)) | (70 << 8)) | 70)) {
    {
#line 575
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 575
      status |= 4U;
#line 575
      goto failure;
#line 575
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 578
  if (header->privOffset != 0U) {
#line 578
    if (header->privLen != 0U) {
#line 579
      privData = woffData + (((((uint32_t )*((uint8_t *)(& header->privOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->privOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->privOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->privOffset) + 3));
#line 580
      privLen = ((((uint32_t )*((uint8_t *)(& header->privLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->privLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->privLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->privLen) + 3);
#line 581
      if ((unsigned long )(privData + privLen) > (unsigned long )(woffData + *woffLen)) {
        {
#line 582
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 582
          status |= 2U;
#line 582
          goto failure;
#line 582
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
#line 586
  if (metaData) {
#line 586
    if (metaLen > 0U) {
      {
#line 587
      compLen = compressBound((uLong )metaLen);
#line 588
      tmp = malloc(compLen);
#line 588
      compData = (uint8_t *)tmp;
      }
#line 589
      if (! compData) {
        {
#line 590
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 590
          status |= 1U;
#line 590
          goto failure;
#line 590
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 593
      tmp___0 = compress2(compData, & compLen, metaData, (uLong )metaLen, 9);
      }
#line 593
      if (tmp___0 != 0) {
        {
#line 595
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 595
          status |= 3U;
#line 595
          goto failure;
#line 595
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 599
  woffData = rebuildWoff(woffData, woffLen, (uint8_t const   *)compData, (uint32_t )compLen,
                         metaLen, privData, privLen, pStatus);
#line 602
  free((void *)compData);
  }
#line 603
  return (woffData);
  failure: 
#line 606
  if (compData) {
    {
#line 607
    free((void *)compData);
    }
  }
#line 609
  if (pStatus) {
#line 610
    *pStatus = status;
  }
#line 612
  return ((uint8_t const   *)((void *)0));
}
}
#line 615 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
uint8_t const   *woffSetPrivateData(uint8_t const   *woffData , uint32_t *woffLen ,
                                    uint8_t const   *privData , uint32_t privLen ,
                                    uint32_t *pStatus ) 
{ 
  woffHeader const   *header ;
  uint8_t const   *metaData ;
  uint32_t metaLen ;
  uint32_t status ;

  {
#line 621
  metaData = (uint8_t const   *)((void *)0);
#line 622
  metaLen = (uint32_t )0;
#line 623
  status = (uint32_t )0;
#line 625
  if (pStatus) {
#line 625
    if (! ((*pStatus & 255U) == 0U)) {
#line 626
      return ((uint8_t const   *)((void *)0));
    }
  }
#line 629
  if (! woffData) {
#line 629
    goto _L;
  } else
#line 629
  if (! woffLen) {
    _L: /* CIL Label */ 
    {
#line 630
    while (1) {
      while_continue: /* CIL Label */ ;
#line 630
      status |= 6U;
#line 630
      goto failure;
#line 630
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 633
  if ((unsigned long )*woffLen < sizeof(woffHeader )) {
    {
#line 634
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 634
      status |= 2U;
#line 634
      goto failure;
#line 634
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 636
  header = (woffHeader const   *)woffData;
#line 638
  if (((((uint32_t )*((uint8_t *)(& header->signature) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->signature) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->signature) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->signature) + 3) != (uint32_t )((((119 << 24) | (79 << 16)) | (70 << 8)) | 70)) {
    {
#line 639
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 639
      status |= 4U;
#line 639
      goto failure;
#line 639
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 642
  if (header->metaOffset != 0U) {
#line 642
    if (header->metaCompLen != 0U) {
#line 643
      metaData = woffData + (((((uint32_t )*((uint8_t *)(& header->metaOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->metaOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->metaOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->metaOffset) + 3));
#line 644
      metaLen = ((((uint32_t )*((uint8_t *)(& header->metaCompLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->metaCompLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->metaCompLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->metaCompLen) + 3);
#line 645
      if ((unsigned long )(metaData + metaLen) > (unsigned long )(woffData + *woffLen)) {
        {
#line 646
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 646
          status |= 2U;
#line 646
          goto failure;
#line 646
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 650
  woffData = rebuildWoff(woffData, woffLen, metaData, metaLen, ((((uint32_t )*((uint8_t *)(& header->metaOrigLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->metaOrigLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->metaOrigLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->metaOrigLen) + 3),
                         privData, privLen, pStatus);
  }
#line 653
  return (woffData);
  failure: 
#line 656
  if (pStatus) {
#line 657
    *pStatus = status;
  }
#line 659
  return ((uint8_t const   *)((void *)0));
}
}
#line 668 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static uint32_t sanityCheck(uint8_t const   *woffData , uint32_t woffLen ) 
{ 
  woffHeader const   *header ;
  uint16_t numTables ;
  uint16_t i ;
  woffDirEntry const   *dirEntry ;
  uint64_t tableTotal ;
  uint64_t offs ;
  uint64_t orig ;
  uint64_t comp ;

  {
#line 674
  tableTotal = (uint64_t )0;
#line 676
  if (! woffData) {
#line 677
    return ((uint32_t )6);
  } else
#line 676
  if (! woffLen) {
#line 677
    return ((uint32_t )6);
  }
#line 680
  if ((unsigned long )woffLen < sizeof(woffHeader )) {
#line 681
    return ((uint32_t )2);
  }
#line 684
  header = (woffHeader const   *)woffData;
#line 685
  if (((((uint32_t )*((uint8_t *)(& header->signature) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->signature) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->signature) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->signature) + 3) != (uint32_t )((((119 << 24) | (79 << 16)) | (70 << 8)) | 70)) {
#line 686
    return ((uint32_t )4);
  }
#line 689
  if (((((uint32_t )*((uint8_t *)(& header->length) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->length) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->length) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->length) + 3) != woffLen) {
#line 690
    return ((uint32_t )2);
  } else
#line 689
  if ((int const   )header->reserved != 0) {
#line 690
    return ((uint32_t )2);
  }
#line 693
  numTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& header->numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& header->numTables) + 1)));
#line 694
  if ((unsigned long )woffLen < sizeof(woffHeader ) + (unsigned long )numTables * sizeof(woffDirEntry )) {
#line 695
    return ((uint32_t )2);
  }
#line 698
  dirEntry = (woffDirEntry const   *)(woffData + sizeof(woffHeader ));
#line 699
  i = (uint16_t )0;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! ((int )i < (int )numTables)) {
#line 699
      goto while_break;
    }
#line 700
    offs = (uint64_t )(((((uint32_t )*((uint8_t *)(& dirEntry->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->offset) + 3));
#line 701
    orig = (uint64_t )(((((uint32_t )*((uint8_t *)(& dirEntry->origLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->origLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->origLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->origLen) + 3));
#line 702
    comp = (uint64_t )(((((uint32_t )*((uint8_t *)(& dirEntry->compLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->compLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->compLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->compLen) + 3));
#line 703
    if (comp > orig) {
#line 704
      return ((uint32_t )2);
    } else
#line 703
    if (comp > (uint64_t )woffLen) {
#line 704
      return ((uint32_t )2);
    } else
#line 703
    if (offs > (uint64_t )woffLen - comp) {
#line 704
      return ((uint32_t )2);
    }
#line 706
    orig = (orig + 3UL) & 0xfffffffffffffffcUL;
#line 707
    tableTotal += orig;
#line 708
    if (tableTotal > 4294967295UL) {
#line 709
      return ((uint32_t )2);
    }
#line 711
    dirEntry ++;
#line 699
    i = (uint16_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  if (tableTotal > (4294967295UL - sizeof(sfntHeader )) - (unsigned long )numTables * sizeof(sfntDirEntry )) {
#line 718
    return ((uint32_t )2);
  } else
#line 714
  if ((uint64_t )(((((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->totalSfntSize) + 3)) != (tableTotal + sizeof(sfntHeader )) + (unsigned long )numTables * sizeof(sfntDirEntry )) {
#line 718
    return ((uint32_t )2);
  }
#line 721
  return ((uint32_t )0);
}
}
#line 724 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
uint32_t woffGetDecodedSize(uint8_t const   *woffData , uint32_t woffLen , uint32_t *pStatus ) 
{ 
  uint32_t status ;
  uint32_t totalLen ;

  {
#line 728
  status = (uint32_t )0;
#line 729
  totalLen = (uint32_t )0;
#line 731
  if (pStatus) {
#line 731
    if (! ((*pStatus & 255U) == 0U)) {
#line 732
      return ((uint32_t )0);
    }
  }
  {
#line 735
  status = sanityCheck(woffData, woffLen);
  }
#line 736
  if (! ((status & 255U) == 0U)) {
    {
#line 737
    while (1) {
      while_continue: /* CIL Label */ ;
#line 737
      status |= status;
#line 737
      goto failure;
#line 737
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 740
  totalLen = ((((uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 3);
  failure: 
#line 745
  if (pStatus) {
#line 746
    *pStatus = status;
  }
#line 748
  return (totalLen);
}
}
#line 751 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static void woffDecodeToBufferInternal(uint8_t const   *woffData , uint32_t woffLen ,
                                       uint8_t *sfntData , uint32_t bufferLen , uint32_t *pActualSfntLen ,
                                       uint32_t *pStatus ) 
{ 
  tableOrderRec *tableOrder ;
  woffHeader const   *header ;
  uint16_t numTables ;
  uint16_t tableIndex ;
  uint16_t order ;
  woffDirEntry const   *woffDir ;
  uint32_t totalLen ;
  sfntHeader *newHeader ;
  uint16_t searchRange ;
  uint16_t rangeShift ;
  uint16_t entrySelector ;
  uint32_t offset ;
  sfntDirEntry *sfntDir ;
  uint32_t headOffset ;
  uint32_t headLength ;
  sfntHeadTable *head ;
  uint32_t csum ;
  uint32_t const   *csumPtr ;
  uint32_t oldCheckSumAdjustment ;
  uint32_t status ;
  void *tmp ;
  uint32_t origLen ;
  uint32_t compLen ;
  uint32_t tag ;
  uint32_t sourceOffset ;
  uLongf destLen ;
  int tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 761
  tableOrder = (tableOrderRec *)((void *)0);
#line 772
  headOffset = (uint32_t )0;
#line 772
  headLength = (uint32_t )0;
#line 774
  csum = (uint32_t )0;
#line 777
  status = (uint32_t )0;
#line 779
  if (pStatus) {
#line 779
    if (! ((*pStatus & 255U) == 0U)) {
#line 780
      return;
    }
  }
#line 784
  header = (woffHeader const   *)woffData;
#line 785
  if (((((uint32_t )*((uint8_t *)(& header->flavor) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->flavor) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->flavor) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->flavor) + 3) != 65536U) {
#line 785
    if (((((uint32_t )*((uint8_t *)(& header->flavor) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->flavor) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->flavor) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->flavor) + 3) != (uint32_t )((((79 << 24) | (84 << 16)) | (84 << 8)) | 79)) {
#line 785
      if (((((uint32_t )*((uint8_t *)(& header->flavor) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->flavor) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->flavor) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->flavor) + 3) != (uint32_t )((((116 << 24) | (114 << 16)) | (117 << 8)) | 101)) {
#line 788
        status |= 256U;
      }
    }
  }
#line 791
  numTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& header->numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& header->numTables) + 1)));
#line 792
  woffDir = (woffDirEntry const   *)(woffData + sizeof(woffHeader ));
#line 794
  totalLen = ((((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->totalSfntSize) + 3);
#line 797
  newHeader = (sfntHeader *)sfntData;
#line 798
  newHeader->version = (uint32_t )header->flavor;
#line 799
  newHeader->numTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& numTables) + 1)));
#line 802
  searchRange = numTables;
#line 803
  searchRange = (uint16_t )((int )searchRange | ((int )searchRange >> 1));
#line 804
  searchRange = (uint16_t )((int )searchRange | ((int )searchRange >> 2));
#line 805
  searchRange = (uint16_t )((int )searchRange | ((int )searchRange >> 4));
#line 806
  searchRange = (uint16_t )((int )searchRange | ((int )searchRange >> 8));
#line 807
  searchRange = (uint16_t )((int )searchRange & ~ ((int )searchRange >> 1));
#line 808
  searchRange = (uint16_t )((int )searchRange * 16);
#line 809
  newHeader->searchRange = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& searchRange) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& searchRange) + 1)));
#line 810
  rangeShift = (uint16_t )((int )numTables * 16 - (int )searchRange);
#line 811
  newHeader->rangeShift = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& rangeShift) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& rangeShift) + 1)));
#line 812
  entrySelector = (uint16_t )0;
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! ((int )searchRange > 16)) {
#line 813
      goto while_break;
    }
#line 814
    entrySelector = (uint16_t )((int )entrySelector + 1);
#line 815
    searchRange = (uint16_t )((int )searchRange >> 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 817
  newHeader->entrySelector = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& entrySelector) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& entrySelector) + 1)));
#line 819
  tmp = malloc((unsigned long )numTables * sizeof(tableOrderRec ));
#line 819
  tableOrder = (tableOrderRec *)tmp;
  }
#line 820
  if (! tableOrder) {
    {
#line 821
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 821
      status |= 1U;
#line 821
      goto failure;
#line 821
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 823
  tableIndex = (uint16_t )0;
  {
#line 823
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 823
    if (! ((int )tableIndex < (int )numTables)) {
#line 823
      goto while_break___1;
    }
#line 824
    (tableOrder + tableIndex)->offset = ((((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 3);
#line 825
    (tableOrder + tableIndex)->oldIndex = tableIndex;
#line 823
    tableIndex = (uint16_t )((int )tableIndex + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 827
  qsort((void *)tableOrder, (size_t )numTables, sizeof(tableOrderRec ), & compareOffsets);
#line 830
  offset = (uint32_t )(sizeof(sfntHeader ) + (unsigned long )numTables * sizeof(sfntDirEntry ));
#line 831
  sfntDir = (sfntDirEntry *)(sfntData + sizeof(sfntHeader ));
#line 832
  order = (uint16_t )0;
  }
  {
#line 832
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 832
    if (! ((int )order < (int )numTables)) {
#line 832
      goto while_break___2;
    }
#line 834
    tableIndex = (tableOrder + order)->oldIndex;
#line 837
    origLen = ((((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->origLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->origLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->origLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->origLen) + 3);
#line 838
    compLen = ((((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->compLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->compLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->compLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->compLen) + 3);
#line 839
    sourceOffset = ((((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 3);
#line 841
    (sfntDir + tableIndex)->tag = (uint32_t )(woffDir + tableIndex)->tag;
#line 842
    (sfntDir + tableIndex)->offset = ((((uint32_t )*((uint8_t *)(& offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& offset) + 3);
#line 843
    (sfntDir + tableIndex)->length = (uint32_t )(woffDir + tableIndex)->origLen;
#line 844
    (sfntDir + tableIndex)->checksum = (uint32_t )(woffDir + tableIndex)->checksum;
#line 845
    csum += ((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 3);
#line 847
    if (compLen < origLen) {
      {
#line 848
      destLen = (uLongf )origLen;
#line 849
      tmp___0 = uncompress(sfntData + offset, & destLen, woffData + sourceOffset,
                           (uLong )compLen);
      }
#line 849
      if (tmp___0 != 0) {
#line 849
        goto _L;
      } else
#line 849
      if (destLen != (uLongf )origLen) {
        _L: /* CIL Label */ 
        {
#line 852
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 852
          status |= 3U;
#line 852
          goto failure;
#line 852
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 855
      memcpy((void */* __restrict  */)(sfntData + offset), (void const   */* __restrict  */)(woffData + sourceOffset),
             (size_t )origLen);
      }
    }
#line 860
    tag = ((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 3);
#line 861
    if (tag == (uint32_t )((((104 << 24) | (101 << 16)) | (97 << 8)) | 100)) {
#line 862
      headOffset = offset;
#line 863
      headLength = origLen;
    } else
#line 861
    if (tag == (uint32_t )((((98 << 24) | (104 << 16)) | (101 << 8)) | 100)) {
#line 862
      headOffset = offset;
#line 863
      headLength = origLen;
    }
#line 866
    offset += origLen;
    {
#line 868
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 868
      if (offset < totalLen) {
#line 868
        if (! ((offset & 3U) != 0U)) {
#line 868
          goto while_break___4;
        }
      } else {
#line 868
        goto while_break___4;
      }
#line 869
      tmp___1 = offset;
#line 869
      offset ++;
#line 869
      *(sfntData + tmp___1) = (uint8_t )0;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 832
    order = (uint16_t )((int )order + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 873
  if (headOffset > 0U) {
#line 877
    if (headLength < 54U) {
      {
#line 878
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 878
        status |= 2U;
#line 878
        goto failure;
#line 878
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 880
    head = (sfntHeadTable *)(sfntData + headOffset);
#line 881
    oldCheckSumAdjustment = ((((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 0) << 24) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 2) << 8)) + (uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 3);
#line 882
    head->checkSumAdjustment = (uint32_t )0;
#line 883
    csumPtr = (uint32_t const   *)sfntData;
    {
#line 884
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 884
      if (! ((unsigned long )csumPtr < (unsigned long )((uint32_t const   *)((sfntData + sizeof(sfntHeader )) + (unsigned long )numTables * sizeof(sfntDirEntry ))))) {
#line 884
        goto while_break___6;
      }
#line 886
      csum += ((((uint32_t )*((uint8_t *)csumPtr + 0) << 24) + ((uint32_t )*((uint8_t *)csumPtr + 1) << 16)) + ((uint32_t )*((uint8_t *)csumPtr + 2) << 8)) + (uint32_t )*((uint8_t *)csumPtr + 3);
#line 887
      csumPtr ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 889
    csum = 2981146554U - csum;
#line 891
    if (oldCheckSumAdjustment != csum) {
#line 894
      status |= 512U;
    }
#line 896
    head->checkSumAdjustment = ((((uint32_t )*((uint8_t *)(& csum) + 0) << 24) + ((uint32_t )*((uint8_t *)(& csum) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& csum) + 2) << 8)) + (uint32_t )*((uint8_t *)(& csum) + 3);
  }
#line 899
  if (pActualSfntLen) {
#line 900
    *pActualSfntLen = totalLen;
  }
#line 902
  if (pStatus) {
#line 903
    *pStatus |= status;
  }
  {
#line 905
  free((void *)tableOrder);
  }
#line 906
  return;
  failure: 
#line 909
  if (tableOrder) {
    {
#line 910
    free((void *)tableOrder);
    }
  }
#line 912
  if (pActualSfntLen) {
#line 913
    *pActualSfntLen = (uint32_t )0;
  }
#line 915
  if (pStatus) {
#line 916
    *pStatus = status;
  }
#line 918
  return;
}
}
#line 920 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
void woffDecodeToBuffer(uint8_t const   *woffData , uint32_t woffLen , uint8_t *sfntData ,
                        uint32_t bufferLen , uint32_t *pActualSfntLen , uint32_t *pStatus ) 
{ 
  uint32_t status ;
  uint32_t totalLen ;

  {
#line 925
  status = (uint32_t )0;
#line 928
  if (pStatus) {
#line 928
    if (! ((*pStatus & 255U) == 0U)) {
#line 929
      return;
    }
  }
  {
#line 932
  status = sanityCheck(woffData, woffLen);
  }
#line 933
  if (! ((status & 255U) == 0U)) {
    {
#line 934
    while (1) {
      while_continue: /* CIL Label */ ;
#line 934
      status |= status;
#line 934
      goto failure;
#line 934
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 937
  if (! sfntData) {
    {
#line 938
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 938
      status |= 6U;
#line 938
      goto failure;
#line 938
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 941
  totalLen = ((((uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 3);
#line 942
  if (bufferLen < totalLen) {
    {
#line 943
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 943
      status |= 5U;
#line 943
      goto failure;
#line 943
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 946
  woffDecodeToBufferInternal(woffData, woffLen, sfntData, bufferLen, pActualSfntLen,
                             pStatus);
  }
#line 948
  return;
  failure: 
#line 951
  if (pActualSfntLen) {
#line 952
    *pActualSfntLen = (uint32_t )0;
  }
#line 954
  if (pStatus) {
#line 955
    *pStatus = status;
  }
#line 957
  return;
}
}
#line 959 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
uint8_t const   *woffDecode(uint8_t const   *woffData , uint32_t woffLen , uint32_t *sfntLen ,
                            uint32_t *pStatus ) 
{ 
  uint32_t status ;
  uint8_t *sfntData ;
  uint32_t bufLen ;
  void *tmp ;

  {
#line 963
  status = (uint32_t )0;
#line 964
  sfntData = (uint8_t *)((void *)0);
#line 967
  if (pStatus) {
#line 967
    if (! ((*pStatus & 255U) == 0U)) {
#line 968
      return ((uint8_t const   *)((void *)0));
    }
  }
  {
#line 971
  status = sanityCheck(woffData, woffLen);
  }
#line 972
  if (! ((status & 255U) == 0U)) {
    {
#line 973
    while (1) {
      while_continue: /* CIL Label */ ;
#line 973
      status |= status;
#line 973
      goto failure;
#line 973
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 976
  bufLen = ((((uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& ((woffHeader const   *)woffData)->totalSfntSize) + 3);
#line 977
  tmp = malloc((size_t )bufLen);
#line 977
  sfntData = (uint8_t *)tmp;
  }
#line 978
  if (! sfntData) {
    {
#line 979
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 979
      status |= 1U;
#line 979
      goto failure;
#line 979
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 982
  woffDecodeToBufferInternal(woffData, woffLen, sfntData, bufLen, sfntLen, & status);
  }
#line 984
  if (! ((status & 255U) == 0U)) {
    {
#line 985
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 985
      status |= status;
#line 985
      goto failure;
#line 985
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 988
  if (pStatus) {
#line 989
    *pStatus |= status;
  }
#line 991
  return ((uint8_t const   *)sfntData);
  failure: 
#line 994
  if (sfntData) {
    {
#line 995
    free((void *)sfntData);
    }
  }
#line 997
  if (pStatus) {
#line 998
    *pStatus = status;
  }
#line 1000
  return ((uint8_t const   *)((void *)0));
}
}
#line 1005 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
uint8_t const   *woffGetMetadata(uint8_t const   *woffData , uint32_t woffLen , uint32_t *metaLen ,
                                 uint32_t *pStatus ) 
{ 
  woffHeader const   *header ;
  uint32_t offset ;
  uint32_t compLen ;
  uLong origLen ;
  uint8_t *data ;
  uint32_t status ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1012
  data = (uint8_t *)((void *)0);
#line 1013
  status = (uint32_t )0;
#line 1015
  if (pStatus) {
#line 1015
    if (! ((*pStatus & 255U) == 0U)) {
#line 1016
      return ((uint8_t const   *)((void *)0));
    }
  }
  {
#line 1019
  status = sanityCheck(woffData, woffLen);
  }
#line 1020
  if (! ((status & 255U) == 0U)) {
    {
#line 1021
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1021
      status |= status;
#line 1021
      goto failure;
#line 1021
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1024
  header = (woffHeader const   *)woffData;
#line 1026
  offset = ((((uint32_t )*((uint8_t *)(& header->metaOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->metaOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->metaOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->metaOffset) + 3);
#line 1027
  compLen = ((((uint32_t )*((uint8_t *)(& header->metaCompLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->metaCompLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->metaCompLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->metaCompLen) + 3);
#line 1028
  origLen = (uLong )(((((uint32_t )*((uint8_t *)(& header->metaOrigLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->metaOrigLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->metaOrigLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->metaOrigLen) + 3));
#line 1029
  if (offset == 0U) {
#line 1030
    return ((uint8_t const   *)((void *)0));
  } else
#line 1029
  if (compLen == 0U) {
#line 1030
    return ((uint8_t const   *)((void *)0));
  } else
#line 1029
  if (origLen == 0UL) {
#line 1030
    return ((uint8_t const   *)((void *)0));
  }
#line 1033
  if (compLen > woffLen) {
#line 1033
    goto _L;
  } else
#line 1033
  if (offset > woffLen - compLen) {
    _L: /* CIL Label */ 
    {
#line 1034
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1034
      status |= 2U;
#line 1034
      goto failure;
#line 1034
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1037
  tmp = malloc(origLen);
#line 1037
  data = (uint8_t *)tmp;
  }
#line 1038
  if (! data) {
    {
#line 1039
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1039
      status |= 1U;
#line 1039
      goto failure;
#line 1039
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1042
  tmp___0 = uncompress(data, & origLen, woffData + offset, (uLong )compLen);
  }
#line 1042
  if (tmp___0 != 0) {
#line 1042
    goto _L___0;
  } else
#line 1042
  if (origLen != (uLong )(((((uint32_t )*((uint8_t *)(& header->metaOrigLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->metaOrigLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->metaOrigLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->metaOrigLen) + 3))) {
    _L___0: /* CIL Label */ 
    {
#line 1045
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1045
      status |= 3U;
#line 1045
      goto failure;
#line 1045
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1048
  if (metaLen) {
#line 1049
    *metaLen = (uint32_t )origLen;
  }
#line 1051
  if (pStatus) {
#line 1052
    *pStatus |= status;
  }
#line 1054
  return ((uint8_t const   *)data);
  failure: 
#line 1057
  if (data) {
    {
#line 1058
    free((void *)data);
    }
  }
#line 1060
  if (pStatus) {
#line 1061
    *pStatus = status;
  }
#line 1063
  return ((uint8_t const   *)((void *)0));
}
}
#line 1066 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
uint8_t const   *woffGetPrivateData(uint8_t const   *woffData , uint32_t woffLen ,
                                    uint32_t *privLen , uint32_t *pStatus ) 
{ 
  woffHeader const   *header ;
  uint32_t offset ;
  uint32_t length ;
  uint8_t *data ;
  uint32_t status ;
  void *tmp ;

  {
#line 1072
  data = (uint8_t *)((void *)0);
#line 1073
  status = (uint32_t )0;
#line 1075
  if (pStatus) {
#line 1075
    if (! ((*pStatus & 255U) == 0U)) {
#line 1076
      return ((uint8_t const   *)((void *)0));
    }
  }
  {
#line 1079
  status = sanityCheck(woffData, woffLen);
  }
#line 1080
  if (! ((status & 255U) == 0U)) {
    {
#line 1081
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1081
      status |= status;
#line 1081
      goto failure;
#line 1081
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1084
  header = (woffHeader const   *)woffData;
#line 1086
  offset = ((((uint32_t )*((uint8_t *)(& header->privOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->privOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->privOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->privOffset) + 3);
#line 1087
  length = ((((uint32_t )*((uint8_t *)(& header->privLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->privLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->privLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->privLen) + 3);
#line 1088
  if (offset == 0U) {
#line 1089
    return ((uint8_t const   *)((void *)0));
  } else
#line 1088
  if (length == 0U) {
#line 1089
    return ((uint8_t const   *)((void *)0));
  }
#line 1092
  if (length > woffLen) {
#line 1092
    goto _L;
  } else
#line 1092
  if (offset > woffLen - length) {
    _L: /* CIL Label */ 
    {
#line 1093
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1093
      status |= 2U;
#line 1093
      goto failure;
#line 1093
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1096
  tmp = malloc((size_t )length);
#line 1096
  data = (uint8_t *)tmp;
  }
#line 1097
  if (! data) {
    {
#line 1098
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1098
      status |= 1U;
#line 1098
      goto failure;
#line 1098
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1101
  memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)(woffData + offset),
         (size_t )length);
  }
#line 1103
  if (privLen) {
#line 1104
    *privLen = length;
  }
#line 1106
  if (pStatus) {
#line 1107
    *pStatus |= status;
  }
#line 1109
  return ((uint8_t const   *)data);
  failure: 
#line 1112
  if (data) {
    {
#line 1113
    free((void *)data);
    }
  }
#line 1115
  if (pStatus) {
#line 1116
    *pStatus = status;
  }
#line 1118
  return ((uint8_t const   *)((void *)0));
}
}
#line 1121 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
void woffGetFontVersion(uint8_t const   *woffData , uint32_t woffLen , uint16_t *major ,
                        uint16_t *minor , uint32_t *pStatus ) 
{ 
  woffHeader const   *header ;
  uint32_t status ;
  uint16_t tmp ;

  {
#line 1126
  status = (uint32_t )0;
#line 1128
  if (pStatus) {
#line 1128
    if (! ((*pStatus & 255U) == 0U)) {
#line 1129
      return;
    }
  }
  {
#line 1132
  status = sanityCheck(woffData, woffLen);
  }
#line 1133
  if (! ((status & 255U) == 0U)) {
    {
#line 1134
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1134
      status |= status;
#line 1134
      goto failure;
#line 1134
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1137
  if (! major) {
#line 1137
    goto _L;
  } else
#line 1137
  if (! minor) {
    _L: /* CIL Label */ 
    {
#line 1138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1138
      status |= 6U;
#line 1138
      goto failure;
#line 1138
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1141
  tmp = (uint16_t )0;
#line 1141
  *minor = tmp;
#line 1141
  *major = tmp;
#line 1143
  header = (woffHeader const   *)woffData;
#line 1145
  *major = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& header->majorVersion) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& header->majorVersion) + 1)));
#line 1146
  *minor = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& header->minorVersion) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& header->minorVersion) + 1)));
  failure: 
#line 1149
  if (pStatus) {
#line 1150
    *pStatus = status;
  }
#line 1152
  return;
}
}
#line 1155 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
void woffPrintStatus(FILE *f , uint32_t status , char const   *prefix ) 
{ 
  char const   *template ;
  char const   *template___0 ;
  char const   *msg ;

  {
#line 1158
  if (! prefix) {
#line 1159
    prefix = "";
  }
#line 1161
  if (status & 4294967040U) {
#line 1162
    template = "%sWOFF warning: %s\n";
#line 1163
    if (status & 256U) {
      {
#line 1164
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)template,
              prefix, "unrecognized sfnt version");
      }
    }
#line 1166
    if (status & 512U) {
      {
#line 1167
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)template,
              prefix, "checksum mismatch (corrected)");
      }
    }
#line 1169
    if (status & 1024U) {
      {
#line 1170
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)template,
              prefix, "misaligned font table");
      }
    }
#line 1172
    if (status & 2048U) {
      {
#line 1173
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)template,
              prefix, "extraneous input data discarded");
      }
    }
#line 1175
    if (status & 4096U) {
      {
#line 1176
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)template,
              prefix, "final table not correctly padded");
      }
    }
#line 1178
    if (status & 8192U) {
      {
#line 1179
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)template,
              prefix, "digital signature (DSIG) table removed");
      }
    }
  }
#line 1182
  if (! ((status & 255U) == 0U)) {
#line 1183
    template___0 = "%sWOFF error: %s\n";
    {
#line 1186
    if ((status & 255U) == 1U) {
#line 1186
      goto case_1;
    }
#line 1189
    if ((status & 255U) == 2U) {
#line 1189
      goto case_2;
    }
#line 1192
    if ((status & 255U) == 3U) {
#line 1192
      goto case_3;
    }
#line 1195
    if ((status & 255U) == 4U) {
#line 1195
      goto case_4;
    }
#line 1198
    if ((status & 255U) == 5U) {
#line 1198
      goto case_5;
    }
#line 1201
    if ((status & 255U) == 6U) {
#line 1201
      goto case_6;
    }
#line 1204
    if ((status & 255U) == 7U) {
#line 1204
      goto case_7;
    }
#line 1207
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1187
    msg = "memory allocation failure";
#line 1188
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1190
    msg = "invalid input font";
#line 1191
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1193
    msg = "zlib compression/decompression failure";
#line 1194
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1196
    msg = "incorrect WOFF file signature";
#line 1197
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1199
    msg = "buffer too small";
#line 1200
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1202
    msg = "bad parameter to WOFF function";
#line 1203
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1205
    msg = "incorrect table directory order";
#line 1206
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1208
    msg = "unknown internal error";
#line 1209
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1211
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)template___0,
            prefix, msg);
    }
  }
#line 1213
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 48 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff2sfnt.c"
static void die___0(char const   *msg ) 
{ 


  {
  {
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# fatal error: %s\n",
          msg);
#line 52
  exit(2);
  }
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff2sfnt.c"
static void reportErr___0(uint32_t status ) 
{ 


  {
  {
#line 58
  woffPrintStatus(stderr, status, "### ");
#line 59
  exit((int )(status & 255U));
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff2sfnt.c"
static void usage___0(char const   *progName ) 
{ 


  {
  {
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n  %s [-v | -m | -p] <woff>\n    decode WOFF file <woff>, writing OpenType data to stdout\nOptions (instead of decoding to OpenType format)\n    -v   write font version to stdout\n    -m   write WOFF metadata block to stdout\n    -p   write private data block to stdout\nNote: only one of -v, -m, -p may be used at a time.\n",
          progName);
  }
#line 74
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static int compareOffsets___0(void const   *lhs , void const   *rhs ) 
{ 
  tableOrderRec const   *a ;
  tableOrderRec const   *b ;
  int tmp ;
  int tmp___0 ;

  {
#line 69
  a = (tableOrderRec const   *)lhs;
#line 70
  b = (tableOrderRec const   *)rhs;
#line 73
  if (a->offset > b->offset) {
#line 73
    tmp___0 = 1;
  } else {
#line 73
    if (a->offset < b->offset) {
#line 73
      tmp = -1;
    } else {
#line 73
      tmp = 0;
    }
#line 73
    tmp___0 = tmp;
  }
#line 73
  return (tmp___0);
}
}
#line 84 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static uint32_t calcChecksum___0(sfntDirEntry const   *dirEntry , uint8_t const   *sfntData ,
                                 uint32_t sfntLen ) 
{ 
  uint32_t const   *csumPtr ;
  uint32_t const   *csumEnd ;
  uint32_t csum ;
  uint32_t length ;
  uint32_t offset ;
  uint32_t tag ;
  sfntHeadTable const   *head ;

  {
#line 91
  csum = (uint32_t )0;
#line 92
  length = ((((uint32_t )*((uint8_t *)(& dirEntry->length) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->length) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->length) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->length) + 3);
#line 93
  offset = ((((uint32_t )*((uint8_t *)(& dirEntry->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->offset) + 3);
#line 95
  if (((length + 3U) & 4294967292U) < length) {
#line 96
    return (csum);
  } else {
#line 98
    length = (length + 3U) & 4294967292U;
  }
#line 100
  if ((offset & 3U) != 0U) {
#line 101
    return (csum);
  }
#line 103
  if (length > sfntLen) {
#line 104
    return (csum);
  } else
#line 103
  if (offset > sfntLen - length) {
#line 104
    return (csum);
  }
#line 106
  csumPtr = (uint32_t const   *)(sfntData + offset);
#line 107
  csumEnd = csumPtr + length / 4U;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )csumPtr < (unsigned long )csumEnd)) {
#line 108
      goto while_break;
    }
#line 109
    csum += ((((uint32_t )*((uint8_t *)csumPtr + 0) << 24) + ((uint32_t )*((uint8_t *)csumPtr + 1) << 16)) + ((uint32_t )*((uint8_t *)csumPtr + 2) << 8)) + (uint32_t )*((uint8_t *)csumPtr + 3);
#line 110
    csumPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  tag = ((((uint32_t )*((uint8_t *)(& dirEntry->tag) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->tag) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->tag) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->tag) + 3);
#line 113
  if (tag == (uint32_t )((((104 << 24) | (101 << 16)) | (97 << 8)) | 100)) {
#line 113
    goto _L;
  } else
#line 113
  if (tag == (uint32_t )((((98 << 24) | (104 << 16)) | (101 << 8)) | 100)) {
    _L: /* CIL Label */ 
#line 115
    if (length < 54U) {
#line 116
      return ((uint32_t )0);
    }
#line 118
    head = (sfntHeadTable const   *)(sfntData + offset);
#line 119
    csum -= ((((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 0) << 24) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 2) << 8)) + (uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 3);
  }
#line 121
  return (csum);
}
}
#line 434 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static uint8_t const   *rebuildWoff___0(uint8_t const   *woffData , uint32_t *woffLen ,
                                        uint8_t const   *metaData , uint32_t metaCompLen ,
                                        uint32_t metaOrigLen , uint8_t const   *privData ,
                                        uint32_t privLen , uint32_t *pStatus ) 
{ 
  woffHeader const   *origHeader ;
  woffDirEntry const   *woffDir ;
  uint8_t *newData ;
  woffHeader *newHeader ;
  uint16_t numTables ;
  uint32_t tableLimit ;
  uint32_t totalSize ;
  uint32_t offset ;
  uint16_t i ;
  uint32_t status ;
  uint32_t end ;
  void *tmp ;
  uint32_t tmp___0 ;

  {
#line 441
  newData = (uint8_t *)((void *)0);
#line 446
  status = (uint32_t )0;
#line 448
  if ((unsigned long )*woffLen < sizeof(woffHeader )) {
    {
#line 449
    while (1) {
      while_continue: /* CIL Label */ ;
#line 449
      status |= 2U;
#line 449
      goto failure;
#line 449
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 451
  origHeader = (woffHeader const   *)woffData;
#line 453
  if (((((uint32_t )*((uint8_t *)(& origHeader->signature) + 0) << 24) + ((uint32_t )*((uint8_t *)(& origHeader->signature) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& origHeader->signature) + 2) << 8)) + (uint32_t )*((uint8_t *)(& origHeader->signature) + 3) != (uint32_t )((((119 << 24) | (79 << 16)) | (70 << 8)) | 70)) {
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 454
      status |= 4U;
#line 454
      goto failure;
#line 454
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 457
  numTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& origHeader->numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& origHeader->numTables) + 1)));
#line 458
  woffDir = (woffDirEntry const   *)(woffData + sizeof(woffHeader ));
#line 459
  tableLimit = (uint32_t )0;
#line 460
  i = (uint16_t )0;
  {
#line 460
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 460
    if (! ((int )i < (int )numTables)) {
#line 460
      goto while_break___1;
    }
#line 461
    end = (((((uint32_t )*((uint8_t *)(& (woffDir + i)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + i)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + i)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + i)->offset) + 3)) + (((((uint32_t )*((uint8_t *)(& (woffDir + i)->compLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + i)->compLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + i)->compLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + i)->compLen) + 3));
#line 462
    if (end > tableLimit) {
#line 463
      tableLimit = end;
    }
#line 460
    i = (uint16_t )((int )i + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 466
  tableLimit = (tableLimit + 3U) & 4294967292U;
#line 469
  offset = ((((uint32_t )*((uint8_t *)(& origHeader->metaOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& origHeader->metaOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& origHeader->metaOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& origHeader->metaOffset) + 3);
#line 470
  if (offset != 0U) {
#line 470
    if (offset < tableLimit) {
      {
#line 471
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 471
        status |= 7U;
#line 471
        goto failure;
#line 471
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 473
  offset = ((((uint32_t )*((uint8_t *)(& origHeader->privOffset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& origHeader->privOffset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& origHeader->privOffset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& origHeader->privOffset) + 3);
#line 474
  if (offset != 0U) {
#line 474
    if (offset < tableLimit) {
      {
#line 475
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 475
        status |= 7U;
#line 475
        goto failure;
#line 475
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 478
  totalSize = tableLimit;
#line 479
  if (metaCompLen) {
#line 480
    if (totalSize + metaCompLen < totalSize) {
      {
#line 481
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 481
        status |= 2U;
#line 481
        goto failure;
#line 481
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 483
    totalSize += metaCompLen;
  }
#line 485
  if (privLen) {
#line 486
    if (((totalSize + 3U) & 4294967292U) < totalSize) {
      {
#line 487
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 487
        status |= 2U;
#line 487
        goto failure;
#line 487
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 489
    totalSize = (totalSize + 3U) & 4294967292U;
#line 490
    if (totalSize + privLen < totalSize) {
      {
#line 491
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 491
        status |= 2U;
#line 491
        goto failure;
#line 491
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 493
    totalSize += privLen;
  }
  {
#line 495
  tmp = malloc((size_t )totalSize);
#line 495
  newData = (uint8_t *)tmp;
  }
#line 496
  if (! newData) {
    {
#line 497
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 497
      status |= 1U;
#line 497
      goto failure;
#line 497
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 501
  memcpy((void */* __restrict  */)newData, (void const   */* __restrict  */)woffData,
         (size_t )tableLimit);
#line 504
  newHeader = (woffHeader *)newData;
#line 505
  newHeader->length = ((((uint32_t )*((uint8_t *)(& totalSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& totalSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& totalSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& totalSize) + 3);
#line 506
  newHeader->metaOffset = (uint32_t )0;
#line 507
  newHeader->metaCompLen = (uint32_t )0;
#line 508
  newHeader->metaOrigLen = (uint32_t )0;
#line 509
  newHeader->privOffset = (uint32_t )0;
#line 510
  newHeader->privLen = (uint32_t )0;
#line 512
  offset = tableLimit;
  }
#line 513
  if (metaData) {
#line 513
    if (metaCompLen > 0U) {
#line 513
      if (metaOrigLen > 0U) {
        {
#line 514
        newHeader->metaOffset = ((((uint32_t )*((uint8_t *)(& offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& offset) + 3);
#line 515
        newHeader->metaCompLen = ((((uint32_t )*((uint8_t *)(& metaCompLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& metaCompLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& metaCompLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& metaCompLen) + 3);
#line 516
        newHeader->metaOrigLen = ((((uint32_t )*((uint8_t *)(& metaOrigLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& metaOrigLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& metaOrigLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& metaOrigLen) + 3);
#line 517
        memcpy((void */* __restrict  */)(newData + offset), (void const   */* __restrict  */)metaData,
               (size_t )metaCompLen);
#line 518
        offset += metaCompLen;
        }
      }
    }
  }
#line 521
  if (privData) {
#line 521
    if (privLen > 0U) {
      {
#line 522
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 522
        if (! ((offset & 3U) != 0U)) {
#line 522
          goto while_break___8;
        }
#line 523
        tmp___0 = offset;
#line 523
        offset ++;
#line 523
        *(newData + tmp___0) = (uint8_t )0;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 525
      newHeader->privOffset = ((((uint32_t )*((uint8_t *)(& offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& offset) + 3);
#line 526
      newHeader->privLen = ((((uint32_t )*((uint8_t *)(& privLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& privLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& privLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& privLen) + 3);
#line 527
      memcpy((void */* __restrict  */)(newData + offset), (void const   */* __restrict  */)privData,
             (size_t )privLen);
#line 528
      offset += privLen;
      }
    }
  }
  {
#line 531
  *woffLen = offset;
#line 532
  free((void *)woffData);
  }
#line 534
  if (pStatus) {
#line 535
    *pStatus |= status;
  }
#line 537
  return ((uint8_t const   *)newData);
  failure: 
#line 540
  if (newData) {
    {
#line 541
    free((void *)newData);
    }
  }
#line 543
  if (pStatus) {
#line 544
    *pStatus = status;
  }
#line 546
  return ((uint8_t const   *)((void *)0));
}
}
#line 668 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static uint32_t sanityCheck___0(uint8_t const   *woffData , uint32_t woffLen ) 
{ 
  woffHeader const   *header ;
  uint16_t numTables ;
  uint16_t i ;
  woffDirEntry const   *dirEntry ;
  uint64_t tableTotal ;
  uint64_t offs ;
  uint64_t orig ;
  uint64_t comp ;

  {
#line 674
  tableTotal = (uint64_t )0;
#line 676
  if (! woffData) {
#line 677
    return ((uint32_t )6);
  } else
#line 676
  if (! woffLen) {
#line 677
    return ((uint32_t )6);
  }
#line 680
  if ((unsigned long )woffLen < sizeof(woffHeader )) {
#line 681
    return ((uint32_t )2);
  }
#line 684
  header = (woffHeader const   *)woffData;
#line 685
  if (((((uint32_t )*((uint8_t *)(& header->signature) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->signature) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->signature) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->signature) + 3) != (uint32_t )((((119 << 24) | (79 << 16)) | (70 << 8)) | 70)) {
#line 686
    return ((uint32_t )4);
  }
#line 689
  if (((((uint32_t )*((uint8_t *)(& header->length) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->length) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->length) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->length) + 3) != woffLen) {
#line 690
    return ((uint32_t )2);
  } else
#line 689
  if ((int const   )header->reserved != 0) {
#line 690
    return ((uint32_t )2);
  }
#line 693
  numTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& header->numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& header->numTables) + 1)));
#line 694
  if ((unsigned long )woffLen < sizeof(woffHeader ) + (unsigned long )numTables * sizeof(woffDirEntry )) {
#line 695
    return ((uint32_t )2);
  }
#line 698
  dirEntry = (woffDirEntry const   *)(woffData + sizeof(woffHeader ));
#line 699
  i = (uint16_t )0;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! ((int )i < (int )numTables)) {
#line 699
      goto while_break;
    }
#line 700
    offs = (uint64_t )(((((uint32_t )*((uint8_t *)(& dirEntry->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->offset) + 3));
#line 701
    orig = (uint64_t )(((((uint32_t )*((uint8_t *)(& dirEntry->origLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->origLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->origLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->origLen) + 3));
#line 702
    comp = (uint64_t )(((((uint32_t )*((uint8_t *)(& dirEntry->compLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& dirEntry->compLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& dirEntry->compLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& dirEntry->compLen) + 3));
#line 703
    if (comp > orig) {
#line 704
      return ((uint32_t )2);
    } else
#line 703
    if (comp > (uint64_t )woffLen) {
#line 704
      return ((uint32_t )2);
    } else
#line 703
    if (offs > (uint64_t )woffLen - comp) {
#line 704
      return ((uint32_t )2);
    }
#line 706
    orig = (orig + 3UL) & 0xfffffffffffffffcUL;
#line 707
    tableTotal += orig;
#line 708
    if (tableTotal > 4294967295UL) {
#line 709
      return ((uint32_t )2);
    }
#line 711
    dirEntry ++;
#line 699
    i = (uint16_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  if (tableTotal > (4294967295UL - sizeof(sfntHeader )) - (unsigned long )numTables * sizeof(sfntDirEntry )) {
#line 718
    return ((uint32_t )2);
  } else
#line 714
  if ((uint64_t )(((((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->totalSfntSize) + 3)) != (tableTotal + sizeof(sfntHeader )) + (unsigned long )numTables * sizeof(sfntDirEntry )) {
#line 718
    return ((uint32_t )2);
  }
#line 721
  return ((uint32_t )0);
}
}
#line 751 "/home/june/repo/benchmarks/collector2/temp/woff-tools-2009.10.04/woff.c"
static void woffDecodeToBufferInternal___0(uint8_t const   *woffData , uint32_t woffLen ,
                                           uint8_t *sfntData , uint32_t bufferLen ,
                                           uint32_t *pActualSfntLen , uint32_t *pStatus ) 
{ 
  tableOrderRec *tableOrder ;
  woffHeader const   *header ;
  uint16_t numTables ;
  uint16_t tableIndex ;
  uint16_t order ;
  woffDirEntry const   *woffDir ;
  uint32_t totalLen ;
  sfntHeader *newHeader ;
  uint16_t searchRange ;
  uint16_t rangeShift ;
  uint16_t entrySelector ;
  uint32_t offset ;
  sfntDirEntry *sfntDir ;
  uint32_t headOffset ;
  uint32_t headLength ;
  sfntHeadTable *head ;
  uint32_t csum ;
  uint32_t const   *csumPtr ;
  uint32_t oldCheckSumAdjustment ;
  uint32_t status ;
  void *tmp ;
  uint32_t origLen ;
  uint32_t compLen ;
  uint32_t tag ;
  uint32_t sourceOffset ;
  uLongf destLen ;
  int tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 761
  tableOrder = (tableOrderRec *)((void *)0);
#line 772
  headOffset = (uint32_t )0;
#line 772
  headLength = (uint32_t )0;
#line 774
  csum = (uint32_t )0;
#line 777
  status = (uint32_t )0;
#line 779
  if (pStatus) {
#line 779
    if (! ((*pStatus & 255U) == 0U)) {
#line 780
      return;
    }
  }
#line 784
  header = (woffHeader const   *)woffData;
#line 785
  if (((((uint32_t )*((uint8_t *)(& header->flavor) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->flavor) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->flavor) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->flavor) + 3) != 65536U) {
#line 785
    if (((((uint32_t )*((uint8_t *)(& header->flavor) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->flavor) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->flavor) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->flavor) + 3) != (uint32_t )((((79 << 24) | (84 << 16)) | (84 << 8)) | 79)) {
#line 785
      if (((((uint32_t )*((uint8_t *)(& header->flavor) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->flavor) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->flavor) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->flavor) + 3) != (uint32_t )((((116 << 24) | (114 << 16)) | (117 << 8)) | 101)) {
#line 788
        status |= 256U;
      }
    }
  }
#line 791
  numTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& header->numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& header->numTables) + 1)));
#line 792
  woffDir = (woffDirEntry const   *)(woffData + sizeof(woffHeader ));
#line 794
  totalLen = ((((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 0) << 24) + ((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& header->totalSfntSize) + 2) << 8)) + (uint32_t )*((uint8_t *)(& header->totalSfntSize) + 3);
#line 797
  newHeader = (sfntHeader *)sfntData;
#line 798
  newHeader->version = (uint32_t )header->flavor;
#line 799
  newHeader->numTables = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& numTables) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& numTables) + 1)));
#line 802
  searchRange = numTables;
#line 803
  searchRange = (uint16_t )((int )searchRange | ((int )searchRange >> 1));
#line 804
  searchRange = (uint16_t )((int )searchRange | ((int )searchRange >> 2));
#line 805
  searchRange = (uint16_t )((int )searchRange | ((int )searchRange >> 4));
#line 806
  searchRange = (uint16_t )((int )searchRange | ((int )searchRange >> 8));
#line 807
  searchRange = (uint16_t )((int )searchRange & ~ ((int )searchRange >> 1));
#line 808
  searchRange = (uint16_t )((int )searchRange * 16);
#line 809
  newHeader->searchRange = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& searchRange) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& searchRange) + 1)));
#line 810
  rangeShift = (uint16_t )((int )numTables * 16 - (int )searchRange);
#line 811
  newHeader->rangeShift = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& rangeShift) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& rangeShift) + 1)));
#line 812
  entrySelector = (uint16_t )0;
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! ((int )searchRange > 16)) {
#line 813
      goto while_break;
    }
#line 814
    entrySelector = (uint16_t )((int )entrySelector + 1);
#line 815
    searchRange = (uint16_t )((int )searchRange >> 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 817
  newHeader->entrySelector = (uint16_t )(((int )((uint16_t )*((uint8_t *)(& entrySelector) + 0)) << 8) + (int )((uint16_t )*((uint8_t *)(& entrySelector) + 1)));
#line 819
  tmp = malloc((unsigned long )numTables * sizeof(tableOrderRec ));
#line 819
  tableOrder = (tableOrderRec *)tmp;
  }
#line 820
  if (! tableOrder) {
    {
#line 821
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 821
      status |= 1U;
#line 821
      goto failure;
#line 821
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 823
  tableIndex = (uint16_t )0;
  {
#line 823
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 823
    if (! ((int )tableIndex < (int )numTables)) {
#line 823
      goto while_break___1;
    }
#line 824
    (tableOrder + tableIndex)->offset = ((((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 3);
#line 825
    (tableOrder + tableIndex)->oldIndex = tableIndex;
#line 823
    tableIndex = (uint16_t )((int )tableIndex + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 827
  qsort((void *)tableOrder, (size_t )numTables, sizeof(tableOrderRec ), & compareOffsets___0);
#line 830
  offset = (uint32_t )(sizeof(sfntHeader ) + (unsigned long )numTables * sizeof(sfntDirEntry ));
#line 831
  sfntDir = (sfntDirEntry *)(sfntData + sizeof(sfntHeader ));
#line 832
  order = (uint16_t )0;
  }
  {
#line 832
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 832
    if (! ((int )order < (int )numTables)) {
#line 832
      goto while_break___2;
    }
#line 834
    tableIndex = (tableOrder + order)->oldIndex;
#line 837
    origLen = ((((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->origLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->origLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->origLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->origLen) + 3);
#line 838
    compLen = ((((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->compLen) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->compLen) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->compLen) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->compLen) + 3);
#line 839
    sourceOffset = ((((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (woffDir + tableIndex)->offset) + 3);
#line 841
    (sfntDir + tableIndex)->tag = (uint32_t )(woffDir + tableIndex)->tag;
#line 842
    (sfntDir + tableIndex)->offset = ((((uint32_t )*((uint8_t *)(& offset) + 0) << 24) + ((uint32_t )*((uint8_t *)(& offset) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& offset) + 2) << 8)) + (uint32_t )*((uint8_t *)(& offset) + 3);
#line 843
    (sfntDir + tableIndex)->length = (uint32_t )(woffDir + tableIndex)->origLen;
#line 844
    (sfntDir + tableIndex)->checksum = (uint32_t )(woffDir + tableIndex)->checksum;
#line 845
    csum += ((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->checksum) + 3);
#line 847
    if (compLen < origLen) {
      {
#line 848
      destLen = (uLongf )origLen;
#line 849
      tmp___0 = uncompress(sfntData + offset, & destLen, woffData + sourceOffset,
                           (uLong )compLen);
      }
#line 849
      if (tmp___0 != 0) {
#line 849
        goto _L;
      } else
#line 849
      if (destLen != (uLongf )origLen) {
        _L: /* CIL Label */ 
        {
#line 852
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 852
          status |= 3U;
#line 852
          goto failure;
#line 852
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 855
      memcpy((void */* __restrict  */)(sfntData + offset), (void const   */* __restrict  */)(woffData + sourceOffset),
             (size_t )origLen);
      }
    }
#line 860
    tag = ((((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 0) << 24) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 2) << 8)) + (uint32_t )*((uint8_t *)(& (sfntDir + tableIndex)->tag) + 3);
#line 861
    if (tag == (uint32_t )((((104 << 24) | (101 << 16)) | (97 << 8)) | 100)) {
#line 862
      headOffset = offset;
#line 863
      headLength = origLen;
    } else
#line 861
    if (tag == (uint32_t )((((98 << 24) | (104 << 16)) | (101 << 8)) | 100)) {
#line 862
      headOffset = offset;
#line 863
      headLength = origLen;
    }
#line 866
    offset += origLen;
    {
#line 868
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 868
      if (offset < totalLen) {
#line 868
        if (! ((offset & 3U) != 0U)) {
#line 868
          goto while_break___4;
        }
      } else {
#line 868
        goto while_break___4;
      }
#line 869
      tmp___1 = offset;
#line 869
      offset ++;
#line 869
      *(sfntData + tmp___1) = (uint8_t )0;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 832
    order = (uint16_t )((int )order + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 873
  if (headOffset > 0U) {
#line 877
    if (headLength < 54U) {
      {
#line 878
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 878
        status |= 2U;
#line 878
        goto failure;
#line 878
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 880
    head = (sfntHeadTable *)(sfntData + headOffset);
#line 881
    oldCheckSumAdjustment = ((((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 0) << 24) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 2) << 8)) + (uint32_t )*((uint8_t *)(& head->checkSumAdjustment) + 3);
#line 882
    head->checkSumAdjustment = (uint32_t )0;
#line 883
    csumPtr = (uint32_t const   *)sfntData;
    {
#line 884
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 884
      if (! ((unsigned long )csumPtr < (unsigned long )((uint32_t const   *)((sfntData + sizeof(sfntHeader )) + (unsigned long )numTables * sizeof(sfntDirEntry ))))) {
#line 884
        goto while_break___6;
      }
#line 886
      csum += ((((uint32_t )*((uint8_t *)csumPtr + 0) << 24) + ((uint32_t )*((uint8_t *)csumPtr + 1) << 16)) + ((uint32_t )*((uint8_t *)csumPtr + 2) << 8)) + (uint32_t )*((uint8_t *)csumPtr + 3);
#line 887
      csumPtr ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 889
    csum = 2981146554U - csum;
#line 891
    if (oldCheckSumAdjustment != csum) {
#line 894
      status |= 512U;
    }
#line 896
    head->checkSumAdjustment = ((((uint32_t )*((uint8_t *)(& csum) + 0) << 24) + ((uint32_t )*((uint8_t *)(& csum) + 1) << 16)) + ((uint32_t )*((uint8_t *)(& csum) + 2) << 8)) + (uint32_t )*((uint8_t *)(& csum) + 3);
  }
#line 899
  if (pActualSfntLen) {
#line 900
    *pActualSfntLen = totalLen;
  }
#line 902
  if (pStatus) {
#line 903
    *pStatus |= status;
  }
  {
#line 905
  free((void *)tableOrder);
  }
#line 906
  return;
  failure: 
#line 909
  if (tableOrder) {
    {
#line 910
    free((void *)tableOrder);
    }
  }
#line 912
  if (pActualSfntLen) {
#line 913
    *pActualSfntLen = (uint32_t )0;
  }
#line 915
  if (pStatus) {
#line 916
    *pStatus = status;
  }
#line 918
  return;
}
}
