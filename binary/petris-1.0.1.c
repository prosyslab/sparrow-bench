/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 24 "/home/wheatley/newnew/temp/petris-1.0.1/petris.h"
struct _coords {
   int well_x ;
   int well_y ;
   int well_width ;
   int well_height ;
   int stat_x ;
   int stat_y ;
   int stat_width ;
};
#line 24 "/home/wheatley/newnew/temp/petris-1.0.1/petris.h"
typedef struct _coords COORDS;
#line 50 "/home/wheatley/newnew/temp/petris-1.0.1/petris.h"
struct _points {
   unsigned int points ;
   unsigned char lines ;
   unsigned char level ;
};
#line 50 "/home/wheatley/newnew/temp/petris-1.0.1/petris.h"
typedef struct _points POINTS;
#line 16 "/home/wheatley/newnew/temp/petris-1.0.1/game.h"
struct _dot {
   unsigned char y ;
   unsigned char x ;
   unsigned char color ;
};
#line 16 "/home/wheatley/newnew/temp/petris-1.0.1/game.h"
typedef struct _dot DOT;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 14 "/home/wheatley/newnew/temp/petris-1.0.1/highscore.c"
struct _hs_entry {
   char name[11] ;
   unsigned int points ;
};
#line 14 "/home/wheatley/newnew/temp/petris-1.0.1/highscore.c"
typedef struct _hs_entry hs_entry;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 603 "/usr/include/curses.h"
extern int delwin(WINDOW * ) ;
#line 674
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 699
extern int mvwprintw(WINDOW * , int  , int  , char const   *  , ...) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 813
extern int whline(WINDOW * , chtype  , int  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 36 "/home/wheatley/newnew/temp/petris-1.0.1/petris.h"
COORDS coords ;
#line 57
int exit_after_error(void) ;
#line 7 "/home/wheatley/newnew/temp/petris-1.0.1/game.h"
POINTS play_game(int level ) ;
#line 5 "/home/wheatley/newnew/temp/petris-1.0.1/main.h"
void update_screen(void) ;
#line 15 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
DOT const   block_data[7][4][4]  = { { {          {(unsigned char)2, (unsigned char)0, (unsigned char)1}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)1}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)1}, 
                {(unsigned char)2, (unsigned char)3, (unsigned char)1}}, 
     {          {(unsigned char)0, (unsigned char)1, (unsigned char)1}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)1}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)1}, 
                {(unsigned char)3, (unsigned char)1, (unsigned char)1}}, 
     {          {(unsigned char)2, (unsigned char)0, (unsigned char)1}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)1}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)1}, 
                {(unsigned char)2, (unsigned char)3, (unsigned char)1}}, 
     {          {(unsigned char)0, (unsigned char)1, (unsigned char)1}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)1}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)1}, 
                {(unsigned char)3, (unsigned char)1, (unsigned char)1}}}, 
   { {          {(unsigned char)1, (unsigned char)1, (unsigned char)2}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)2}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)2}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)2}}, 
     {          {(unsigned char)1, (unsigned char)1, (unsigned char)2}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)2}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)2}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)2}}, 
     {          {(unsigned char)1, (unsigned char)1, (unsigned char)2}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)2}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)2}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)2}}, 
     {          {(unsigned char)1, (unsigned char)1, (unsigned char)2}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)2}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)2}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)2}}}, 
   { {          {(unsigned char)1, (unsigned char)0, (unsigned char)3}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)3}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)3}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)3}}, 
     {          {(unsigned char)2, (unsigned char)0, (unsigned char)3}, 
                {(unsigned char)0, (unsigned char)1, (unsigned char)3}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)3}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)3}}, 
     {          {(unsigned char)0, (unsigned char)0, (unsigned char)3}, 
                {(unsigned char)1, (unsigned char)0, (unsigned char)3}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)3}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)3}}, 
     {          {(unsigned char)0, (unsigned char)1, (unsigned char)3}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)3}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)3}, 
                {(unsigned char)0, (unsigned char)2, (unsigned char)3}}}, 
   { {          {(unsigned char)1, (unsigned char)0, (unsigned char)4}, 
                {(unsigned char)2, (unsigned char)0, (unsigned char)4}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)4}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)4}}, 
     {          {(unsigned char)0, (unsigned char)0, (unsigned char)4}, 
                {(unsigned char)0, (unsigned char)1, (unsigned char)4}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)4}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)4}}, 
     {          {(unsigned char)1, (unsigned char)0, (unsigned char)4}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)4}, 
                {(unsigned char)0, (unsigned char)2, (unsigned char)4}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)4}}, 
     {          {(unsigned char)0, (unsigned char)1, (unsigned char)4}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)4}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)4}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)4}}}, 
   { {          {(unsigned char)1, (unsigned char)0, (unsigned char)5}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)5}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)5}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)5}}, 
     {          {(unsigned char)1, (unsigned char)0, (unsigned char)5}, 
                {(unsigned char)2, (unsigned char)0, (unsigned char)5}, 
                {(unsigned char)0, (unsigned char)1, (unsigned char)5}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)5}}, 
     {          {(unsigned char)1, (unsigned char)0, (unsigned char)5}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)5}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)5}, 
                {(unsigned char)2, (unsigned char)2, (unsigned char)5}}, 
     {          {(unsigned char)1, (unsigned char)0, (unsigned char)5}, 
                {(unsigned char)2, (unsigned char)0, (unsigned char)5}, 
                {(unsigned char)0, (unsigned char)1, (unsigned char)5}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)5}}}, 
   { {          {(unsigned char)2, (unsigned char)0, (unsigned char)6}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)6}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)6}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)6}}, 
     {          {(unsigned char)0, (unsigned char)0, (unsigned char)6}, 
                {(unsigned char)1, (unsigned char)0, (unsigned char)6}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)6}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)6}}, 
     {          {(unsigned char)2, (unsigned char)0, (unsigned char)6}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)6}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)6}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)6}}, 
     {          {(unsigned char)0, (unsigned char)0, (unsigned char)6}, 
                {(unsigned char)1, (unsigned char)0, (unsigned char)6}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)6}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)6}}}, 
   { {          {(unsigned char)1, (unsigned char)0, (unsigned char)7}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)7}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)7}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)7}}, 
     {          {(unsigned char)1, (unsigned char)0, (unsigned char)7}, 
                {(unsigned char)0, (unsigned char)1, (unsigned char)7}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)7}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)7}}, 
     {          {(unsigned char)1, (unsigned char)0, (unsigned char)7}, 
                {(unsigned char)0, (unsigned char)1, (unsigned char)7}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)7}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)7}}, 
     {          {(unsigned char)0, (unsigned char)1, (unsigned char)7}, 
                {(unsigned char)1, (unsigned char)1, (unsigned char)7}, 
                {(unsigned char)2, (unsigned char)1, (unsigned char)7}, 
                {(unsigned char)1, (unsigned char)2, (unsigned char)7}}}};
#line 64 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
unsigned char *well_data  ;
#line 68 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
int delay[10]  = 
#line 68
  {      1000000,      770000,      593000,      457000, 
        352000,      271000,      208000,      160000, 
        124000,      95000};
#line 71 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
WINDOW *well_win  ;
#line 74 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
unsigned char *yx2pointer(int y , int x ) 
{ 


  {
#line 76
  return ((well_data + y * coords.well_width) + x);
}
}
#line 81 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
void draw_block(WINDOW *win , int y , int x , int type , int orient , char erase___0 ) 
{ 
  int i ;
  DOT dot ;
  int tmp ;

  {
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 4)) {
#line 89
      goto while_break;
    }
#line 90
    dot = (DOT )block_data[type][orient][i];
#line 91
    if (win) {
#line 91
      if (erase___0) {
#line 91
        tmp = 0;
      } else {
#line 91
        tmp = (int )dot.color;
      }
#line 91
      win->_attrs = (chtype )tmp << 8;
    }
    {
#line 92
    mvwprintw(win, y + (int )dot.y, 2 * (x + (int )dot.x), "  ");
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (0 == (int )erase___0) {
    {
#line 99
    wrefresh(win);
    }
  }
#line 100
  return;
}
}
#line 103 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
void update_well(int start , int lines ) 
{ 
  int y ;
  int x ;
  unsigned char *tmp ;

  {
#line 107
  y = start;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (y < start + lines)) {
#line 107
      goto while_break;
    }
    {
#line 108
    wmove(well_win, y, 0);
#line 109
    x = 0;
    }
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      if (! (x < coords.well_width)) {
#line 109
        goto while_break___0;
      }
#line 110
      if (well_win) {
        {
#line 110
        tmp = yx2pointer(y, x);
#line 110
        well_win->_attrs = (chtype )*tmp << 8;
        }
      }
      {
#line 111
      mvwprintw(well_win, y, 2 * x, "  ");
#line 109
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 107
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  wrefresh(well_win);
  }
#line 115
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
int check_block_pos(int y , int x , int type , int orient ) 
{ 
  int i ;
  DOT dot ;
  unsigned char *tmp ;

  {
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 4)) {
#line 124
      goto while_break;
    }
#line 125
    dot = (DOT )block_data[type][orient][i];
#line 126
    if (y + (int )dot.y > coords.well_height - 1) {
#line 130
      return (0);
    } else
#line 126
    if (x + (int )dot.x < 0) {
#line 130
      return (0);
    } else
#line 126
    if (x + (int )dot.x > coords.well_width - 1) {
#line 130
      return (0);
    } else {
      {
#line 126
      tmp = yx2pointer(y + (int )dot.y, x + (int )dot.x);
      }
#line 126
      if ((int )*tmp > 0) {
#line 130
        return (0);
      }
    }
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return (1);
}
}
#line 137 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
void set_block(int y , int x , int type , int orient ) 
{ 
  int i ;
  DOT dot ;
  unsigned char *tmp ;

  {
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < 4)) {
#line 142
      goto while_break;
    }
    {
#line 143
    dot = (DOT )block_data[type][orient][i];
#line 144
    tmp = yx2pointer(y + (int )dot.y, x + (int )dot.x);
#line 144
    *tmp = dot.color;
#line 142
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  update_well(y, 4);
  }
#line 147
  return;
}
}
#line 150 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
void visualize_lines(int start , short line_stat ) 
{ 
  int i ;
  int y ;
  short tmp ;
  int tmp___0 ;

  {
#line 155
  if (well_win) {
#line 155
    well_win->_attrs = 0UL;
  }
#line 157
  i = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i < 6)) {
#line 157
      goto while_break;
    }
#line 158
    tmp = (short)1;
#line 159
    y = 3;
    {
#line 159
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 159
      if (! (y >= 0)) {
#line 159
        goto while_break___0;
      }
#line 160
      if ((int )line_stat & (int )tmp) {
        {
#line 161
        wmove(well_win, start + y, 0);
        }
#line 162
        if (i % 2) {
#line 162
          tmp___0 = ' ';
        } else {
#line 162
          tmp___0 = ':';
        }
        {
#line 162
        whline(well_win, (chtype )tmp___0, coords.well_width * 2);
        }
      }
#line 164
      tmp = (short )((int )tmp << 1);
#line 159
      y --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 166
    wrefresh(well_win);
#line 167
    usleep((__useconds_t )83333);
#line 157
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return;
}
}
#line 173 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
void remove_lines(int start , short line_stat ) 
{ 
  unsigned char *tmp_well ;
  short tmp ;
  int y ;
  int lines ;
  void *tmp___0 ;

  {
  {
#line 178
  lines = 0;
#line 180
  tmp___0 = malloc((size_t )(coords.well_height * coords.well_width));
#line 180
  tmp_well = (unsigned char *)tmp___0;
#line 181
  memset((void *)tmp_well, 0, (size_t )(4 * coords.well_width));
#line 184
  memcpy((void */* __restrict  */)(tmp_well + (start + 4) * coords.well_width), (void const   */* __restrict  */)(well_data + (start + 4) * coords.well_width),
         (size_t )(((coords.well_height - start) - 4) * coords.well_width));
#line 191
  tmp = (short)1;
#line 192
  y = 3;
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (y >= 0)) {
#line 192
      goto while_break;
    }
#line 193
    if (! ((int )line_stat & (int )tmp)) {
      {
#line 194
      memcpy((void */* __restrict  */)(tmp_well + ((start + y) + lines) * coords.well_width),
             (void const   */* __restrict  */)(well_data + (start + y) * coords.well_width),
             (size_t )coords.well_width);
      }
    } else {
#line 198
      lines ++;
    }
#line 200
    tmp = (short )((int )tmp << 1);
#line 192
    y --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  memcpy((void */* __restrict  */)(tmp_well + lines * coords.well_width), (void const   */* __restrict  */)well_data,
         (size_t )(coords.well_width * start));
#line 206
  memcpy((void */* __restrict  */)well_data, (void const   */* __restrict  */)tmp_well,
         (size_t )(coords.well_height * coords.well_width));
#line 208
  update_well(0, coords.well_height);
  }
#line 209
  return;
}
}
#line 214 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
POINTS check_lines(int start ) 
{ 
  int y ;
  int x ;
  short line ;
  short line_stat ;
  POINTS points ;
  unsigned char *tmp ;

  {
#line 218
  line_stat = (short)0;
#line 223
  points.points = 0U;
#line 224
  points.lines = (unsigned char)0;
#line 225
  points.level = (unsigned char)0;
#line 228
  if (start > coords.well_height - 4) {
#line 229
    start = coords.well_height - 4;
  }
#line 231
  y = start;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! (y < start + 4)) {
#line 231
      goto while_break;
    }
#line 232
    line_stat = (short )((int )line_stat << 1);
#line 233
    line = (short)1;
#line 235
    x = 0;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 235
      if (! (x < coords.well_width)) {
#line 235
        goto while_break___0;
      }
      {
#line 236
      tmp = yx2pointer(y, x);
      }
#line 236
      if ((int )*tmp == 0) {
#line 237
        line = (short)0;
#line 238
        goto while_break___0;
      }
#line 235
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 241
    if (1 == (int )line) {
#line 242
      if (0 == (int )line_stat) {
#line 243
        points.points = 50U;
      } else {
#line 245
        points.points *= 2U;
      }
#line 247
      points.lines = (unsigned char )((int )points.lines + 1);
#line 249
      line_stat = (short )((int )line_stat | 1);
    }
#line 231
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (line_stat) {
    {
#line 254
    visualize_lines(start, line_stat);
#line 255
    remove_lines(start, line_stat);
    }
  }
#line 258
  return (points);
}
}
#line 263
void update_stat(POINTS points , int block ) ;
#line 263 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
static int prev_block  =    0;
#line 261 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
void update_stat(POINTS points , int block ) 
{ 


  {
  {
#line 266
  draw_block(stdscr, coords.stat_y + 2, coords.stat_x / 2 + 2, prev_block, 0, (char)1);
#line 267
  draw_block(stdscr, coords.stat_y + 2, coords.stat_x / 2 + 2, block, 0, (char)0);
  }
#line 269
  if (stdscr) {
#line 269
    stdscr->_attrs = 17UL << 8;
  }
  {
#line 270
  mvprintw((coords.stat_y + 4) + 3, coords.stat_x + 2, "Points: %d", points.points);
  }
#line 271
  if (stdscr) {
#line 271
    stdscr->_attrs = 18UL << 8;
  }
  {
#line 272
  mvprintw((coords.stat_y + 4) + 5, coords.stat_x + 2, "Lines:  %d", (int )points.lines);
  }
#line 273
  if (stdscr) {
#line 273
    stdscr->_attrs = 19UL << 8;
  }
  {
#line 274
  mvprintw((coords.stat_y + 4) + 7, coords.stat_x + 2, "Level:  %d", (int )points.level);
#line 276
  prev_block = block;
#line 278
  wrefresh(stdscr);
  }
#line 279
  return;
}
}
#line 283 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
int drop_block(int type , int level ) 
{ 
  int defx ;
  int y ;
  int x ;
  int orient ;
  int ch ;
  fd_set inputs ;
  fd_set test_fds ;
  struct timeval timeout___0 ;
  int sel_ret ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 285
  defx = coords.well_width / 2 - 2;
#line 286
  y = 0;
#line 287
  x = defx;
#line 288
  orient = 0;
#line 289
  ch = 0;
#line 294
  tmp = check_block_pos(y, x, type, orient);
  }
#line 294
  if (0 == tmp) {
#line 295
    return (-1);
  }
#line 297
  timeout___0.tv_sec = (__time_t )0;
#line 298
  timeout___0.tv_usec = (__suseconds_t )delay[level];
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& inputs.__fds_bits[0]): "memory");
#line 300
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  inputs.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 303
  if (ch != -1) {
    {
#line 304
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 304
      tmp___0 = wgetch(stdscr);
      }
#line 304
      if (! (tmp___0 != -1)) {
#line 304
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 306
  draw_block(well_win, y, x, type, orient, (char)0);
  }
  {
#line 308
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 309
    test_fds = inputs;
#line 311
    sel_ret = select(1024, (fd_set */* __restrict  */)(& test_fds), (fd_set */* __restrict  */)((fd_set *)0),
                     (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& timeout___0));
#line 313
    ch = wgetch(stdscr);
    }
#line 313
    if (sel_ret == 1) {
#line 313
      if (ch == -1) {
        {
#line 313
        exit_after_error();
        }
      }
    }
    {
#line 316
    if (ch == 260) {
#line 316
      goto case_260;
    }
#line 323
    if (ch == 261) {
#line 323
      goto case_261;
    }
#line 330
    if (ch == 259) {
#line 330
      goto case_259;
    }
#line 339
    if (ch == 32) {
#line 339
      goto case_32;
    }
#line 348
    if (ch == 258) {
#line 348
      goto case_258;
    }
#line 352
    if (ch == 114) {
#line 352
      goto case_114;
    }
#line 315
    goto switch_break;
    case_260: /* CIL Label */ 
    {
#line 317
    tmp___1 = check_block_pos(y, x - 1, type, orient);
    }
#line 317
    if (tmp___1) {
      {
#line 318
      draw_block(well_win, y, x, type, orient, (char)1);
#line 319
      x --;
#line 319
      draw_block(well_win, y, x, type, orient, (char)0);
      }
    }
#line 321
    goto switch_break;
    case_261: /* CIL Label */ 
    {
#line 324
    tmp___2 = check_block_pos(y, x + 1, type, orient);
    }
#line 324
    if (tmp___2) {
      {
#line 325
      draw_block(well_win, y, x, type, orient, (char)1);
#line 326
      x ++;
#line 326
      draw_block(well_win, y, x, type, orient, (char)0);
      }
    }
#line 328
    goto switch_break;
    case_259: /* CIL Label */ 
#line 331
    if (orient + 1 == 4) {
#line 331
      tmp___3 = 0;
    } else {
#line 331
      tmp___3 = orient + 1;
    }
    {
#line 331
    tmp___4 = check_block_pos(y, x, type, tmp___3);
    }
#line 331
    if (tmp___4) {
      {
#line 333
      draw_block(well_win, y, x, type, orient, (char)1);
#line 334
      orient ++;
      }
#line 334
      if (orient == 4) {
#line 334
        orient = 0;
      }
      {
#line 335
      draw_block(well_win, y, x, type, orient, (char)0);
      }
    }
#line 337
    goto switch_break;
    case_32: /* CIL Label */ 
#line 340
    if (orient - 1 == -1) {
#line 340
      tmp___5 = 3;
    } else {
#line 340
      tmp___5 = orient - 1;
    }
    {
#line 340
    tmp___6 = check_block_pos(y, x, type, tmp___5);
    }
#line 340
    if (tmp___6) {
      {
#line 342
      draw_block(well_win, y, x, type, orient, (char)1);
#line 343
      orient --;
      }
#line 343
      if (orient == -1) {
#line 343
        orient = 3;
      }
      {
#line 344
      draw_block(well_win, y, x, type, orient, (char)0);
      }
    }
#line 346
    goto switch_break;
    case_258: /* CIL Label */ 
#line 349
    sel_ret = 0;
#line 350
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 353
    update_screen();
#line 354
    update_well(0, coords.well_height);
#line 355
    draw_block(well_win, y, x, type, orient, (char)0);
    }
    switch_break: /* CIL Label */ ;
    }
#line 361
    if (0 == sel_ret) {
      {
#line 362
      tmp___7 = check_block_pos(y + 1, x, type, orient);
      }
#line 362
      if (tmp___7) {
        {
#line 363
        draw_block(well_win, y, x, type, orient, (char)1);
#line 364
        y ++;
#line 364
        draw_block(well_win, y, x, type, orient, (char)0);
        }
      } else {
        {
#line 366
        set_block(y, x, type, orient);
        }
#line 367
        return (y);
      }
#line 369
      timeout___0.tv_sec = (__time_t )0;
#line 370
      timeout___0.tv_usec = (__suseconds_t )delay[level];
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 378 "/home/wheatley/newnew/temp/petris-1.0.1/game.c"
POINTS play_game(int level ) 
{ 
  POINTS points ;
  POINTS tmp ;
  int cur ;
  long tmp___0 ;
  int next ;
  long tmp___1 ;
  int y ;
  void *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 382
  tmp___0 = random();
#line 382
  cur = (int )(tmp___0 % 7L);
#line 383
  tmp___1 = random();
#line 383
  next = (int )(tmp___1 % 7L);
#line 387
  well_win = newwin(coords.well_height, 2 * coords.well_width, coords.well_y, coords.well_x);
#line 390
  tmp___2 = malloc((size_t )(coords.well_height * coords.well_width));
#line 390
  well_data = (unsigned char *)tmp___2;
#line 391
  memset((void *)well_data, 0, (size_t )(coords.well_height * coords.well_width));
#line 392
  update_screen();
#line 393
  wclear(well_win);
#line 395
  points.points = 0U;
#line 396
  points.lines = (unsigned char)0;
#line 397
  points.level = (unsigned char )level;
#line 398
  update_stat(points, next);
  }
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 401
    y = drop_block(cur, (int )points.level);
    }
#line 402
    if (y >= 0) {
      {
#line 403
      tmp = check_lines(y);
#line 404
      points.points += tmp.points + (unsigned int )points.level;
#line 405
      points.lines = (unsigned char )((int )points.lines + (int )tmp.lines);
      }
#line 406
      if ((int )points.lines / 10 > level) {
#line 406
        if ((int )points.lines / 10 < 10) {
#line 408
          points.level = (unsigned char )((int )points.lines / 10);
        }
      }
      {
#line 409
      cur = next;
#line 410
      tmp___3 = random();
#line 410
      next = (int )(tmp___3 % 7L);
#line 411
      update_stat(points, next);
      }
    } else {
      {
#line 413
      sleep(2U);
      }
#line 414
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 418
  free((void *)well_data);
#line 419
  well_data = (unsigned char *)0;
#line 420
  delwin(well_win);
  }
#line 422
  return (points);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 710 "/usr/include/curses.h"
extern int nodelay(WINDOW * , _Bool  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 799
extern int wborder(WINDOW * , chtype  , chtype  , chtype  , chtype  , chtype  , chtype  ,
                   chtype  , chtype  ) ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 7 "/home/wheatley/newnew/temp/petris-1.0.1/highscore.h"
int check_highscores(unsigned int points ) ;
#line 8
int view_highscores(void) ;
#line 7 "/home/wheatley/newnew/temp/petris-1.0.1/main.h"
void message(char *msg ) ;
#line 20 "/home/wheatley/newnew/temp/petris-1.0.1/highscore.c"
hs_entry hs_list[10]  ;
#line 22 "/home/wheatley/newnew/temp/petris-1.0.1/highscore.c"
int load_highscores(void) 
{ 
  FILE *file ;
  int i ;
  size_t items ;

  {
  {
#line 28
  file = fopen((char const   */* __restrict  */)"/var/games/petris.scores", (char const   */* __restrict  */)"r");
  }
#line 28
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 30
    message((char *)"Failed to open highscore file. Creating empty list.");
#line 31
    i = 0;
    }
    {
#line 31
    while (1) {
      while_continue: /* CIL Label */ ;
#line 31
      if (! (i < 10)) {
#line 31
        goto while_break;
      }
#line 32
      hs_list[i].name[0] = (char)0;
#line 33
      hs_list[i].points = 0U;
#line 31
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 35
    return (1);
  }
  {
#line 39
  items = fread((void */* __restrict  */)(hs_list), sizeof(hs_entry ), (size_t )10,
                (FILE */* __restrict  */)file);
#line 42
  i = (int )items;
  }
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 42
    if (! (i < 10)) {
#line 42
      goto while_break___0;
    }
#line 43
    hs_list[i].name[0] = (char )'\000';
#line 44
    hs_list[i].points = 0U;
#line 42
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 47
  fclose(file);
  }
#line 48
  return (1);
}
}
#line 51 "/home/wheatley/newnew/temp/petris-1.0.1/highscore.c"
int save_highscores(void) 
{ 
  FILE *file ;

  {
  {
#line 55
  file = fopen((char const   */* __restrict  */)"/var/games/petris.scores", (char const   */* __restrict  */)"w");
  }
#line 55
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 56
    message((char *)"Error saving highscore file. Your new highscore entry is lost :-(");
    }
#line 57
    return (0);
  }
  {
#line 60
  fwrite((void const   */* __restrict  */)(hs_list), sizeof(hs_entry ), (size_t )10,
         (FILE */* __restrict  */)file);
#line 62
  fclose(file);
  }
#line 63
  return (1);
}
}
#line 66 "/home/wheatley/newnew/temp/petris-1.0.1/highscore.c"
void insert_hs_entry(int index___0 , char *name , unsigned int points ) 
{ 
  int i ;

  {
#line 71
  i = 9;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i > index___0)) {
#line 71
      goto while_break;
    }
    {
#line 72
    strncpy((char */* __restrict  */)(hs_list[i].name), (char const   */* __restrict  */)(hs_list[i - 1].name),
            sizeof(hs_list[i].name) - 1UL);
#line 73
    hs_list[i].points = hs_list[i - 1].points;
#line 71
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  memset((void *)(hs_list[index___0].name), '\000', sizeof(hs_list[index___0].name));
#line 78
  strncpy((char */* __restrict  */)(hs_list[index___0].name), (char const   */* __restrict  */)name,
          sizeof(hs_list[index___0].name) - 1UL);
#line 79
  hs_list[index___0].points = points;
  }
#line 80
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/petris-1.0.1/highscore.c"
int check_highscores(unsigned int points ) 
{ 
  int i ;
  char *name ;

  {
  {
#line 87
  name = getenv("USER");
  }
#line 89
  if ((unsigned long )((void *)0) == (unsigned long )name) {
#line 90
    name = (char *)"nobody";
  }
  {
#line 92
  load_highscores();
#line 95
  i = 0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < 10)) {
#line 95
      goto while_break;
    }
#line 96
    if (points >= hs_list[i].points) {
      {
#line 97
      insert_hs_entry(i, name, points);
#line 98
      save_highscores();
      }
#line 99
      return (i + 1);
    }
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return (0);
}
}
#line 105 "/home/wheatley/newnew/temp/petris-1.0.1/highscore.c"
int view_highscores(void) 
{ 
  WINDOW *win ;
  char *name ;
  int i ;
  int ch ;
  int tmp ;

  {
  {
#line 113
  name = getenv("USER");
  }
#line 115
  if ((unsigned long )((void *)0) == (unsigned long )name) {
#line 116
    name = (char *)"nobody";
  }
  {
#line 118
  load_highscores();
#line 121
  win = newwin(21, 24, LINES / 2 - 10, COLS / 2 - 12);
#line 123
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
  }
#line 125
  if (win) {
#line 125
    win->_attrs = (20UL << 8) | (1UL << 21);
  }
  {
#line 126
  mvwprintw(win, 2, 6, "Highscores:");
#line 127
  wattr_off(win, 1UL << 21, (void *)0);
#line 128
  mvwprintw(win, 4, 2, "%-12sPoints:", "Name:");
  }
#line 131
  if (win) {
#line 131
    win->_attrs = 17UL << 8;
  }
#line 132
  i = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < 10)) {
#line 132
      goto while_break;
    }
    {
#line 133
    tmp = strcmp((char const   *)(hs_list[i].name), (char const   *)name);
    }
#line 133
    if (0 == tmp) {
      {
#line 134
      wattr_on(win, 1UL << 21, (void *)0);
      }
    } else {
      {
#line 136
      wattr_off(win, 1UL << 21, (void *)0);
      }
    }
    {
#line 138
    mvwprintw(win, 6 + i, 2, "%-12s%7d", hs_list[i].name, hs_list[i].points);
#line 132
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (win) {
#line 142
    win->_attrs = 20UL << 8;
  }
  {
#line 143
  mvwprintw(win, 17, 2, "Press q to quit, any");
#line 144
  mvwprintw(win, 18, 2, "other key to cont.");
#line 146
  update_screen();
#line 147
  wrefresh(win);
#line 149
  nodelay(stdscr, (_Bool)0);
#line 151
  ch = wgetch(stdscr);
  }
#line 151
  if (ch == -1) {
    {
#line 151
    exit_after_error();
    }
  }
#line 152
  if (ch == 113) {
#line 153
    return (0);
  } else
#line 152
  if (ch == 81) {
#line 153
    return (0);
  } else {
#line 155
    return (1);
  }
  {
#line 157
  nodelay(stdscr, (_Bool)1);
#line 158
  delwin(win);
  }
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 267 "/usr/include/curses.h"
extern chtype acs_map[] ;
#line 587
extern int cbreak(void) ;
#line 611
extern int endwin(void) ;
#line 622
extern _Bool has_colors(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 711
extern int noecho(void) ;
#line 764
extern int start_color(void) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 840
extern int wvline(WINDOW * , chtype  , int  ) ;
#line 847
extern char *tigetstr(char const   * ) ;
#line 848
extern int putp(char const   * ) ;
#line 36 "/home/wheatley/newnew/temp/petris-1.0.1/petris.h"
COORDS coords  ;
#line 6 "/home/wheatley/newnew/temp/petris-1.0.1/main.h"
void cursor_vis(int vis ) ;
#line 21 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
void init_coords(char *size ) 
{ 
  char *endptr ;
  short totw ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 27
  coords.well_y = 2;
#line 28
  coords.stat_y = 2;
#line 29
  coords.stat_width = 18;
#line 32
  tmp = strtol((char const   */* __restrict  */)size, (char **/* __restrict  */)(& endptr),
               10);
#line 32
  coords.well_width = (int )tmp;
  }
#line 33
  if ((unsigned long )endptr == (unsigned long )size) {
    {
#line 34
    endwin();
#line 35
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Petris: Bad [width]x[height] format.\n");
#line 36
    exit(1);
    }
  } else
#line 33
  if ((int )*endptr != 120) {
    {
#line 34
    endwin();
#line 35
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Petris: Bad [width]x[height] format.\n");
#line 36
    exit(1);
    }
  } else
#line 33
  if (coords.well_width < 4) {
    {
#line 34
    endwin();
#line 35
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Petris: Bad [width]x[height] format.\n");
#line 36
    exit(1);
    }
  }
  {
#line 39
  tmp___0 = strtol((char const   */* __restrict  */)(endptr + 1), (char **/* __restrict  */)0,
                   10);
#line 39
  coords.well_height = (int )tmp___0;
  }
#line 40
  if (coords.well_height < 4) {
    {
#line 41
    endwin();
#line 42
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Petris: Bad [width]x[height] format.\n");
#line 43
    exit(1);
    }
  }
#line 46
  totw = (short )(((2 * coords.well_width + 2) + coords.stat_width) + 2);
#line 52
  if ((int )totw > COLS) {
    {
#line 53
    endwin();
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Petris: Terminal too small. Aborting.\n");
#line 55
    exit(1);
    }
  } else
#line 52
  if (coords.well_y + coords.well_height >= LINES) {
    {
#line 53
    endwin();
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Petris: Terminal too small. Aborting.\n");
#line 55
    exit(1);
    }
  }
#line 59
  coords.well_x = (COLS / 2 - (int )totw / 2) + 1;
#line 60
  coords.stat_x = (coords.well_x + 2 * coords.well_width) + 3;
#line 61
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
void parse_args(int argc , char **argv ) 
{ 


  {
#line 66
  if (argc >= 2) {
    {
#line 67
    init_coords(*(argv + 1));
    }
  } else {
    {
#line 69
    init_coords((char *)"10x20");
    }
  }
#line 70
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
void cursor_vis(int vis ) 
{ 
  char *cmd ;

  {
#line 77
  if (vis == 1) {
    {
#line 78
    cmd = tigetstr("cnorm");
    }
  } else {
    {
#line 80
    cmd = tigetstr("civis");
    }
  }
#line 82
  if ((unsigned long )cmd == (unsigned long )((char *)-1)) {
    {
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning! Your termianl does not support cursor on / off\n");
#line 84
    sleep(3U);
    }
#line 85
    return;
  }
  {
#line 88
  putp((char const   *)cmd);
  }
#line 89
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
void init_colors(void) 
{ 
  _Bool tmp ;

  {
  {
#line 93
  tmp = has_colors();
  }
#line 93
  if (! tmp) {
    {
#line 94
    endwin();
#line 95
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Petris: Your terminal doesn\'t support colors. Aborting \n");
#line 96
    cursor_vis(1);
#line 97
    exit(1);
    }
  }
  {
#line 101
  start_color();
#line 104
  init_pair((short)1, (short)0, (short)1);
#line 105
  init_pair((short)2, (short)0, (short)3);
#line 106
  init_pair((short)3, (short)0, (short)2);
#line 107
  init_pair((short)4, (short)0, (short)6);
#line 108
  init_pair((short)5, (short)0, (short)5);
#line 109
  init_pair((short)6, (short)0, (short)4);
#line 110
  init_pair((short)7, (short)0, (short)7);
#line 113
  init_pair((short)17, (short)1, (short)0);
#line 114
  init_pair((short)18, (short)3, (short)0);
#line 115
  init_pair((short)19, (short)2, (short)0);
#line 116
  init_pair((short)20, (short)3, (short)0);
  }
#line 117
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
void update_screen(void) 
{ 


  {
  {
#line 124
  wclear(stdscr);
  }
#line 127
  if (stdscr) {
#line 127
    stdscr->_attrs = 0UL;
  }
  {
#line 128
  wmove(stdscr, coords.well_y, coords.well_x - 1);
#line 129
  wvline(stdscr, acs_map[(unsigned char )'x'], coords.well_height);
#line 130
  wmove(stdscr, coords.well_y, coords.well_x + 2 * coords.well_width);
#line 131
  wvline(stdscr, acs_map[(unsigned char )'x'], coords.well_height);
#line 132
  wmove(stdscr, coords.well_y + coords.well_height, coords.well_x - 1);
#line 133
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'m']);
#line 134
  whline(stdscr, acs_map[(unsigned char )'q'], 2 * coords.well_width);
#line 135
  wmove(stdscr, coords.well_y + coords.well_height, coords.well_x + 2 * coords.well_width);
#line 136
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'j']);
#line 139
  wmove(stdscr, coords.stat_y, coords.stat_x);
#line 140
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'l']);
#line 141
  whline(stdscr, acs_map[(unsigned char )'q'], coords.stat_width - 2);
#line 142
  wmove(stdscr, coords.stat_y, (coords.stat_x + coords.stat_width) - 1);
#line 143
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'k']);
#line 144
  wmove(stdscr, coords.stat_y + 1, coords.stat_x);
#line 145
  wvline(stdscr, acs_map[(unsigned char )'x'], 11);
#line 146
  wmove(stdscr, coords.stat_y + 1, (coords.stat_x + coords.stat_width) - 1);
#line 147
  wvline(stdscr, acs_map[(unsigned char )'x'], 11);
#line 148
  wmove(stdscr, (coords.stat_y + 4) + 8, coords.stat_x);
#line 149
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'m']);
#line 150
  whline(stdscr, acs_map[(unsigned char )'q'], coords.stat_width - 2);
#line 151
  wmove(stdscr, (coords.stat_y + 4) + 8, (coords.stat_x + coords.stat_width) - 1);
#line 152
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'j']);
#line 153
  wmove(stdscr, (coords.stat_y + 4) + 2, coords.stat_x);
#line 154
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'t']);
#line 155
  whline(stdscr, acs_map[(unsigned char )'q'], coords.stat_width - 2);
#line 156
  wmove(stdscr, (coords.stat_y + 4) + 2, (coords.stat_x + coords.stat_width) - 1);
#line 157
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'u']);
#line 159
  wrefresh(stdscr);
  }
#line 160
  return;
}
}
#line 162 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
int get_level(int level ) 
{ 
  WINDOW *win ;
  int ch ;

  {
  {
#line 165
  ch = 0;
#line 168
  win = newwin(12, 16, LINES / 2 - 6, COLS / 2 - 8);
#line 169
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
  }
#line 171
  if (win) {
#line 171
    win->_attrs = 20UL << 8;
  }
  {
#line 172
  mvwprintw(win, 2, 2, "Choose level");
#line 173
  mvwprintw(win, 3, 2, "(0 - %d)", 9);
#line 174
  mvwprintw(win, 5, 2, "Up arrow");
#line 175
  mvwprintw(win, 7, 2, "Down arrow");
#line 176
  mvwprintw(win, 9, 2, "Space for OK");
  }
#line 177
  if (win) {
#line 177
    win->_attrs = 19UL << 8;
  }
  {
#line 178
  mvwprintw(win, 6, 4, "%d ", level);
#line 180
  update_screen();
#line 181
  wrefresh(win);
#line 183
  nodelay(stdscr, (_Bool)0);
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (ch != 32) {
#line 185
      if (! (ch != 343)) {
#line 185
        goto while_break;
      }
    } else {
#line 185
      goto while_break;
    }
    {
#line 186
    ch = wgetch(stdscr);
    }
#line 186
    if (ch == -1) {
      {
#line 186
      exit_after_error();
      }
    }
    {
#line 188
    if (ch == 259) {
#line 188
      goto case_259;
    }
#line 193
    if (ch == 258) {
#line 193
      goto case_258;
    }
#line 187
    goto switch_break;
    case_259: /* CIL Label */ 
#line 189
    if (level + 1 > 9) {
#line 189
      level = 0;
    } else {
#line 189
      level ++;
    }
    {
#line 190
    mvwprintw(win, 6, 4, "%d ", level);
#line 191
    wrefresh(win);
    }
#line 192
    goto switch_break;
    case_258: /* CIL Label */ 
#line 194
    if (level - 1 < 0) {
#line 194
      level = 9;
    } else {
#line 194
      level --;
    }
    {
#line 195
    mvwprintw(win, 6, 4, "%d ", level);
#line 196
    wrefresh(win);
    }
#line 197
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  nodelay(stdscr, (_Bool)1);
#line 202
  delwin(win);
  }
#line 204
  return (level);
}
}
#line 208 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
int show_score(POINTS points , int use_hs ) 
{ 
  WINDOW *win ;
  int ranking ;
  int ch ;
  int ret ;
  int tmp ;

  {
  {
#line 212
  ch = 0;
#line 213
  ret = 1;
#line 216
  win = newwin(20, 28, LINES / 2 - 10, COLS / 2 - 14);
#line 217
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
  }
#line 219
  if (win) {
#line 219
    win->_attrs = (20UL << 8) | (1UL << 21);
  }
  {
#line 220
  mvwprintw(win, 2, 6, "*** GAME OVER ***");
  }
#line 221
  if (win) {
#line 221
    win->_attrs = 20UL << 8;
  }
  {
#line 222
  mvwprintw(win, 4, 2, "You scored:");
  }
#line 223
  if (win) {
#line 223
    win->_attrs = 17UL << 8;
  }
  {
#line 224
  mvwprintw(win, 6, 5, "Points: %d", points.points);
  }
#line 225
  if (win) {
#line 225
    win->_attrs = 18UL << 8;
  }
  {
#line 226
  mvwprintw(win, 7, 5, "Lines:  %d", (int )points.lines);
  }
#line 227
  if (win) {
#line 227
    win->_attrs = 19UL << 8;
  }
  {
#line 228
  mvwprintw(win, 8, 5, "Level:  %d", (int )points.level);
  }
#line 230
  if (win) {
#line 230
    win->_attrs = (17UL << 8) | (1UL << 21);
  }
#line 231
  if (use_hs) {
    {
#line 232
    ranking = check_highscores(points.points);
    }
#line 233
    if (ranking) {
      {
#line 234
      mvwprintw(win, 10, 2, "Congratulations!");
      }
#line 235
      if (win) {
#line 235
        win->_attrs = 20UL << 8;
      }
      {
#line 236
      mvwprintw(win, 12, 5, "You\'re on the high-");
#line 237
      mvwprintw(win, 13, 5, "score list as no. %d", ranking);
      }
    } else {
      {
#line 239
      mvwprintw(win, 11, 5, "Practice some more!");
      }
    }
  } else {
    {
#line 241
    mvwprintw(win, 10, 2, "Highscore disabled!");
    }
  }
#line 244
  if (win) {
#line 244
    win->_attrs = 20UL << 8;
  }
  {
#line 245
  mvwprintw(win, 15, 2, "Press q to quit, h to");
#line 246
  mvwprintw(win, 16, 2, "view highscores or any");
#line 247
  mvwprintw(win, 17, 2, "other key to play again.");
#line 249
  update_screen();
#line 250
  wrefresh(win);
  }
#line 252
  if (ch != -1) {
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 253
      tmp = wgetch(stdscr);
      }
#line 253
      if (! (tmp != -1)) {
#line 253
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 255
  nodelay(stdscr, (_Bool)0);
#line 257
  ch = wgetch(stdscr);
  }
#line 257
  if (ch == -1) {
    {
#line 257
    exit_after_error();
    }
  }
#line 258
  if (ch == 113) {
#line 259
    ret = 0;
  } else
#line 258
  if (ch == 81) {
#line 259
    ret = 0;
  } else
#line 260
  if (ch == 104) {
    {
#line 261
    ret = view_highscores();
    }
  } else
#line 260
  if (ch == 72) {
    {
#line 261
    ret = view_highscores();
    }
  }
  {
#line 263
  nodelay(stdscr, (_Bool)1);
#line 264
  delwin(win);
  }
#line 266
  return (ret);
}
}
#line 272 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
void message(char *msg ) 
{ 


  {
#line 274
  if (stdscr) {
#line 274
    stdscr->_attrs = (20UL << 8) | (1UL << 19);
  }
  {
#line 275
  mvprintw(0, 0, (char const   *)msg);
#line 276
  wrefresh(stdscr);
#line 277
  sleep(3U);
  }
#line 278
  return;
}
}
#line 281 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
int exit_after_error(void) 
{ 


  {
  {
#line 283
  cursor_vis(1);
#line 284
  endwin();
#line 285
  exit(1);
  }
}
}
#line 288 "/home/wheatley/newnew/temp/petris-1.0.1/main.c"
int main(int argc , char **argv ) 
{ 
  int play ;
  int level ;
  POINTS points ;
  int use_highscore ;
  WINDOW *tmp ;
  time_t tmp___0 ;

  {
  {
#line 290
  play = 1;
#line 291
  level = 0;
#line 293
  use_highscore = 1;
#line 296
  tmp = initscr();
  }
#line 296
  if ((unsigned long )((WINDOW *)0) == (unsigned long )tmp) {
    {
#line 297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Petris: Error initializing ncurses.\n");
#line 298
    exit(1);
    }
  }
  {
#line 301
  parse_args(argc, argv);
  }
#line 305
  if (coords.well_width != 10) {
#line 306
    use_highscore = 0;
  } else
#line 305
  if (coords.well_height != 20) {
#line 306
    use_highscore = 0;
  }
  {
#line 309
  cursor_vis(0);
#line 313
  keypad(stdscr, (_Bool)1);
#line 314
  nodelay(stdscr, (_Bool)1);
#line 315
  noecho();
#line 316
  cbreak();
#line 318
  init_colors();
#line 321
  tmp___0 = time((time_t *)0);
#line 321
  srandom((unsigned int )tmp___0);
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! play) {
#line 324
      goto while_break;
    }
    {
#line 325
    level = get_level(level);
#line 326
    points = play_game(level);
#line 327
    play = show_score(points, use_highscore);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 330
  cursor_vis(1);
#line 332
  endwin();
#line 334
  exit(0);
  }
}
}
