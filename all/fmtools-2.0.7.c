/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 1257 "/usr/include/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2] ;
};
#line 1302 "/usr/include/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4] ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.h"
struct tuner_test;
#line 26 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.h"
struct tuner {
   int fd ;
   int index ;
   struct v4l2_queryctrl volume_ctrl ;
   struct v4l2_tuner tuner ;
   struct tuner_test *test ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 1216 "/usr/include/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1357 "/usr/include/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8] ;
};
#line 38 "/usr/include/stdint.h"
typedef int int32_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 30 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
struct tuner_test {
   int freq ;
   int volume ;
   _Bool mute ;
};
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.h"
char *program_name ;
#line 39
void tuner_open(struct tuner *tuner , char const   *device , int index___0 ) ;
#line 40
void tuner_close(struct tuner *tuner ) ;
#line 49
long long tuner_get_min_freq(struct tuner  const  *tuner ) ;
#line 50
long long tuner_get_max_freq(struct tuner  const  *tuner ) ;
#line 51
void tuner_set_freq(struct tuner  const  *tuner , long long freq , _Bool override_range ) ;
#line 54
int tuner_get_signal(struct tuner  const  *tuner ) ;
#line 56
void tuner_usleep(struct tuner  const  *tuner , int usecs ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmscan.c"
static void usage(void) 
{ 


  {
  {
#line 38
  printf((char const   */* __restrict  */)"fmtools fmscan version %s\n\n", "2.0.7");
#line 39
  printf((char const   */* __restrict  */)"usage: %s [-h] [-d <dev>] [-T <tuner>] [-s <freq>] [-e <freq>] [-i <freq>] [-t <%%>]\n\n",
         program_name);
#line 41
  printf((char const   */* __restrict  */)"Auxiliary program to scan a frequency band for radio stations.\n\n");
#line 43
  printf((char const   */* __restrict  */)"  -h        - display this help\n");
#line 44
  printf((char const   */* __restrict  */)"  -d <dev>  - select device (default: /dev/radio0)\n");
#line 45
  printf((char const   */* __restrict  */)"  -T <tuner> - select tuner (default: 0)\n");
#line 46
  printf((char const   */* __restrict  */)"  -s <freq> - set start of scanning range to <freq>\n");
#line 47
  printf((char const   */* __restrict  */)"  -e <freq> - set end of scanning range to <freq>\n");
#line 48
  printf((char const   */* __restrict  */)"  -i <freq> - set increment value between channels to <freq>\n");
#line 49
  printf((char const   */* __restrict  */)"  -t <%%>    - set signal strength percentage to lock onto <%%>\n");
#line 50
  printf((char const   */* __restrict  */)"  <freq>    - a value in the format nnn.nn (MHz)\n");
#line 52
  exit(0);
  }
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmscan.c"
int main(int argc , char **argv ) 
{ 
  struct tuner tuner ;
  int tries ;
  double perc ;
  double begval ;
  double incval ;
  double endval ;
  double threshold ;
  double mhz ;
  char const   *device ;
  _Bool override ;
  _Bool quiet ;
  int index___0 ;
  int i ;
  int option ;
  int tmp ;
  double tmp___0 ;
  double min ;
  long long tmp___1 ;
  double max ;
  long long tmp___2 ;
  long long freq ;
  long totsig ;
  int i___0 ;
  long long tmp___3 ;
  long long tmp___4 ;
  int tmp___5 ;

  {
#line 58
  tries = 25;
#line 60
  device = (char const   *)((void *)0);
#line 61
  override = (_Bool)0;
#line 62
  quiet = (_Bool)0;
#line 63
  index___0 = 0;
#line 66
  program_name = *(argv + 0);
#line 69
  begval = 87.9;
#line 70
  incval = 0.20;
#line 71
  endval = 107.9;
#line 72
  threshold = 0.5;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    tmp = getopt(argc, (char * const  *)argv, "+e:hi:s:od:T:t:q");
#line 75
    option = tmp;
    }
#line 76
    if (option == -1) {
#line 77
      goto while_break;
    }
    {
#line 80
    if (option == 100) {
#line 80
      goto case_100;
    }
#line 83
    if (option == 84) {
#line 83
      goto case_84;
    }
#line 86
    if (option == 101) {
#line 86
      goto case_101;
    }
#line 89
    if (option == 105) {
#line 89
      goto case_105;
    }
#line 92
    if (option == 115) {
#line 92
      goto case_115;
    }
#line 95
    if (option == 111) {
#line 95
      goto case_111;
    }
#line 98
    if (option == 116) {
#line 98
      goto case_116;
    }
#line 101
    if (option == 113) {
#line 101
      goto case_113;
    }
#line 105
    goto switch_default;
    case_100: /* CIL Label */ 
#line 81
    device = (char const   *)optarg;
#line 82
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 84
    index___0 = atoi((char const   *)optarg);
    }
#line 85
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 87
    endval = atof((char const   *)optarg);
    }
#line 88
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 90
    incval = atof((char const   *)optarg);
    }
#line 91
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 93
    begval = atof((char const   *)optarg);
    }
#line 94
    goto switch_break;
    case_111: /* CIL Label */ 
#line 96
    override = (_Bool)1;
#line 97
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 99
    tmp___0 = atof((char const   *)optarg);
#line 99
    threshold = tmp___0 / 100.;
    }
#line 100
    goto switch_break;
    case_113: /* CIL Label */ 
#line 102
    quiet = (_Bool)1;
#line 103
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 106
    usage();
    }
#line 107
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 111
  tuner_open(& tuner, device, index___0);
  }
#line 113
  if (! override) {
    {
#line 114
    tmp___1 = tuner_get_min_freq((struct tuner  const  *)(& tuner));
#line 114
    min = (double )tmp___1 / 16000.0;
#line 115
    tmp___2 = tuner_get_max_freq((struct tuner  const  *)(& tuner));
#line 115
    max = (double )tmp___2 / 16000.0;
    }
#line 116
    if (begval < min) {
      {
#line 117
      begval = min;
#line 118
      printf((char const   */* __restrict  */)"Setting start to tuner minimum %.2f MHz\n",
             begval);
      }
    }
#line 121
    if (endval > max) {
      {
#line 122
      endval = max;
#line 123
      printf((char const   */* __restrict  */)"Setting end to tuner maximum %.2f MHz\n",
             endval);
      }
    }
  }
  {
#line 128
  printf((char const   */* __restrict  */)"Scanning range: %2.2f - %2.2f MHz (%2.2f MHz increments)...\n",
         begval, endval, incval);
#line 131
  i = 0;
  }
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 131
    mhz = begval + (double )i * incval;
#line 131
    if (! (mhz <= endval)) {
#line 131
      goto while_break___0;
    }
#line 136
    freq = (long long )(mhz * (double )16000 + 0.5);
#line 137
    if (! override) {
      {
#line 138
      tmp___4 = tuner_get_min_freq((struct tuner  const  *)(& tuner));
      }
#line 138
      if (freq < tmp___4) {
        {
#line 139
        freq = tuner_get_min_freq((struct tuner  const  *)(& tuner));
        }
      } else {
        {
#line 140
        tmp___3 = tuner_get_max_freq((struct tuner  const  *)(& tuner));
        }
#line 140
        if (freq > tmp___3) {
          {
#line 141
          freq = tuner_get_max_freq((struct tuner  const  *)(& tuner));
          }
        }
      }
    }
    {
#line 143
    tuner_set_freq((struct tuner  const  *)(& tuner), freq, override);
    }
#line 145
    if (! quiet) {
      {
#line 146
      printf((char const   */* __restrict  */)"%2.2f:\r", mhz);
#line 147
      fflush(stdout);
      }
    }
    {
#line 149
    tuner_usleep((struct tuner  const  *)(& tuner), 400000);
#line 151
    totsig = 0L;
#line 152
    i___0 = 0;
    }
    {
#line 152
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 152
      if (! (i___0 < tries)) {
#line 152
        goto while_break___1;
      }
      {
#line 153
      tmp___5 = tuner_get_signal((struct tuner  const  *)(& tuner));
#line 153
      totsig += (long )tmp___5;
#line 154
      perc = (double )totsig / (65535.0 * (double )(i___0 + 1));
      }
#line 155
      if (! quiet) {
        {
#line 156
        printf((char const   */* __restrict  */)"%2.2f: checking: %3.1f%% (%d/%d)    \r",
               mhz, perc * 100.0, i___0 + 1, tries);
#line 159
        fflush(stdout);
        }
      }
      {
#line 161
      tuner_usleep((struct tuner  const  *)(& tuner), 15000);
#line 152
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 165
    if (! quiet) {
      {
#line 166
      printf((char const   */* __restrict  */)"                                          \r");
      }
    }
#line 168
    perc = (double )totsig / (65535.0 * (double )tries);
#line 170
    if (perc > threshold) {
      {
#line 171
      printf((char const   */* __restrict  */)"%2.2f: %3.1f%%\n", mhz, perc * 100.0);
      }
    }
#line 131
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 175
  tuner_close(& tuner);
  }
#line 176
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 34 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.h"
char *program_name  ;
#line 36
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(int error , char const   *msg 
                                                                     , ...) ;
#line 42
_Bool tuner_is_muted(struct tuner  const  *tuner ) ;
#line 43
void tuner_set_mute(struct tuner *tuner , _Bool mute ) ;
#line 45
_Bool tuner_has_volume_control(struct tuner  const  *tuner ) ;
#line 46
double tuner_get_volume(struct tuner  const  *tuner ) ;
#line 47
void tuner_set_volume(struct tuner *tuner , double volume ) ;
#line 55
void tuner_sleep(struct tuner  const  *tuner , int secs ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void query_control(struct tuner  const  *tuner , uint32_t id , struct v4l2_queryctrl *qc ) ;
#line 40
static int32_t get_control(struct tuner  const  *tuner , uint32_t id ) ;
#line 41
static void set_control(struct tuner  const  *tuner , uint32_t id , int32_t value ) ;
#line 42
static void query_tuner(struct tuner  const  *tuner , struct v4l2_tuner *vt ) ;
#line 44
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(int error , char const   *msg 
                                                                     , ...) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
void ( /* format attribute */  fatal)(int error , char const   *msg  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          program_name);
#line 51
  __builtin_va_start(args, msg);
#line 52
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           args);
#line 53
  __builtin_va_end(args);
  }
#line 55
  if (error) {
    {
#line 56
    tmp = strerror(error);
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
  }
  {
#line 57
  _IO_putc('\n', stderr);
#line 59
  exit(1);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void *xmalloc(size_t n ) 
{ 
  void *p ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 65
  if (n) {
#line 65
    tmp = n;
  } else {
#line 65
    tmp = (size_t )1;
  }
  {
#line 65
  tmp___0 = malloc(tmp);
#line 65
  p = tmp___0;
  }
#line 66
  if (! p) {
    {
#line 67
    fatal(0, "out of memory");
    }
  }
#line 68
  return (p);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
void tuner_open(struct tuner *tuner , char const   *device , int index___0 ) 
{ 
  double volume ;
  int mute ;
  int n ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 74
  memset((void *)tuner, 0, sizeof(*tuner));
  }
#line 76
  if (! device) {
#line 77
    device = "/dev/radio0";
  } else {
    {
#line 78
    tmp___0 = strcmp(device, "test");
    }
#line 78
    if (tmp___0) {
      {
#line 78
      tmp___1 = strncmp(device, "test ", (size_t )5);
      }
#line 78
      if (! tmp___1) {
        _L: /* CIL Label */ 
        {
#line 83
        n = sscanf((char const   */* __restrict  */)device, (char const   */* __restrict  */)"test %lf %d",
                   & volume, & mute);
        }
#line 84
        if (n < 1) {
#line 85
          volume = (double )50;
        }
#line 86
        if (n < 2) {
#line 87
          mute = 0;
        }
        {
#line 89
        tmp = xmalloc(sizeof(*(tuner->test)));
#line 89
        tuner->test = (struct tuner_test *)tmp;
#line 90
        (tuner->test)->freq = 1440;
        }
#line 91
        if (volume >= (double )0) {
#line 91
          (tuner->test)->volume = (int )(volume * (double )10 + 1000.5);
        } else {
#line 91
          (tuner->test)->volume = 0;
        }
#line 92
        (tuner->test)->mute = (_Bool )(mute != 0);
#line 94
        device = "/dev/null";
      }
    } else {
#line 78
      goto _L;
    }
  }
  {
#line 97
  tuner->fd = open(device, 0);
  }
#line 98
  if (tuner->fd < 0) {
    {
#line 99
    tmp___2 = __errno_location();
#line 99
    fatal(*tmp___2, "Unable to open %s", device);
    }
  }
  {
#line 100
  tuner->index = index___0;
#line 102
  query_control((struct tuner  const  *)tuner, (uint32_t )9963781, & tuner->volume_ctrl);
#line 103
  query_tuner((struct tuner  const  *)tuner, & tuner->tuner);
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
void tuner_close(struct tuner *tuner ) 
{ 


  {
  {
#line 109
  close(tuner->fd);
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
_Bool tuner_is_muted(struct tuner  const  *tuner ) 
{ 
  int32_t tmp ;

  {
  {
#line 115
  tmp = get_control(tuner, (uint32_t )9963785);
  }
#line 115
  return ((_Bool )tmp);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
void tuner_set_mute(struct tuner *tuner , _Bool mute ) 
{ 


  {
  {
#line 121
  set_control((struct tuner  const  *)tuner, (uint32_t )9963785, (int32_t )mute);
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
_Bool tuner_has_volume_control(struct tuner  const  *tuner ) 
{ 
  struct v4l2_queryctrl  const  *vqc ;

  {
#line 127
  vqc = & tuner->volume_ctrl;
#line 128
  return ((_Bool )(vqc->maximum > vqc->minimum));
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
double tuner_get_volume(struct tuner  const  *tuner ) 
{ 
  struct v4l2_queryctrl  const  *vqc ;
  int volume ;
  int32_t tmp ;
  _Bool tmp___0 ;

  {
  {
#line 134
  tmp___0 = tuner_has_volume_control(tuner);
  }
#line 134
  if (tmp___0) {
    {
#line 135
    vqc = & tuner->volume_ctrl;
#line 136
    tmp = get_control(tuner, (uint32_t )9963781);
#line 136
    volume = tmp;
    }
#line 137
    return ((100.0 * (double )(volume - (int )vqc->minimum)) / (double )(vqc->maximum - vqc->minimum));
  } else {
#line 141
    return (100.0);
  }
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
void tuner_set_volume(struct tuner *tuner , double volume ) 
{ 
  struct v4l2_queryctrl *vqc ;
  _Bool tmp ;

  {
  {
#line 148
  tmp = tuner_has_volume_control((struct tuner  const  *)tuner);
  }
#line 148
  if (tmp) {
    {
#line 149
    vqc = & tuner->volume_ctrl;
#line 150
    set_control((struct tuner  const  *)tuner, (uint32_t )9963781, (int32_t )((volume / 100.0) * (double )(vqc->maximum - vqc->minimum) + (double )vqc->minimum));
    }
  }
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
long long tuner_get_min_freq(struct tuner  const  *tuner ) 
{ 
  long long rangelow ;

  {
#line 159
  rangelow = (long long )tuner->tuner.rangelow;
#line 160
  if (! (tuner->tuner.capability & 1U)) {
#line 161
    rangelow *= 1000LL;
  }
#line 162
  return (rangelow);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
long long tuner_get_max_freq(struct tuner  const  *tuner ) 
{ 
  long long rangehigh ;

  {
#line 168
  rangehigh = (long long )tuner->tuner.rangehigh;
#line 169
  if (! (tuner->tuner.capability & 1U)) {
#line 170
    rangehigh *= 1000LL;
  }
#line 171
  return (rangehigh);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
void tuner_set_freq(struct tuner  const  *tuner , long long freq , _Bool override_range ) 
{ 
  long long adj_freq ;
  struct v4l2_frequency vf ;
  long long tmp ;
  long long tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 181
  adj_freq = freq;
#line 182
  if (! (tuner->tuner.capability & 1U)) {
#line 183
    adj_freq = (adj_freq + 500LL) / 1000LL;
  }
#line 185
  if (adj_freq < (long long )tuner->tuner.rangelow) {
#line 185
    goto _L;
  } else
#line 185
  if (adj_freq > (long long )tuner->tuner.rangehigh) {
    _L: /* CIL Label */ 
#line 185
    if (! override_range) {
      {
#line 188
      tmp = tuner_get_max_freq(tuner);
#line 188
      tmp___0 = tuner_get_min_freq(tuner);
#line 188
      fatal(0, "Frequency %.1f MHz out of range (%.1f - %.1f MHz)", (double )freq / 16000.0,
            (double )tmp___0 / 16000.0, (double )tmp / 16000.0);
      }
    }
  }
  {
#line 193
  memset((void *)(& vf), 0, sizeof(vf));
#line 194
  vf.tuner = (__u32 )tuner->index;
#line 195
  vf.type = (__u32 )tuner->tuner.type;
#line 196
  vf.frequency = (__u32 )adj_freq;
  }
#line 197
  if (tuner->test) {
#line 198
    (tuner->test)->freq = (int )adj_freq;
  } else {
    {
#line 200
    tmp___2 = ioctl((int )tuner->fd, (unsigned long )(((1U << 30) | (unsigned int )(86 << 8)) | 57U) | (sizeof(struct v4l2_frequency ) << 16),
                    & vf);
    }
#line 200
    if (tmp___2 == -1) {
      {
#line 201
      tmp___1 = __errno_location();
#line 201
      fatal(*tmp___1, "VIDIOC_S_FREQUENCY");
      }
    }
  }
#line 202
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
int tuner_get_signal(struct tuner  const  *tuner ) 
{ 
  struct v4l2_tuner vt ;

  {
  {
#line 209
  query_tuner(tuner, & vt);
  }
#line 210
  return (vt.signal);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
void tuner_usleep(struct tuner  const  *tuner , int usecs ) 
{ 


  {
#line 216
  if (! tuner->test) {
    {
#line 217
    usleep((__useconds_t )usecs);
    }
  }
#line 218
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
void tuner_sleep(struct tuner  const  *tuner , int secs ) 
{ 


  {
#line 223
  if (! tuner->test) {
    {
#line 224
    sleep((unsigned int )secs);
    }
  }
#line 225
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void query_control(struct tuner  const  *tuner , uint32_t id , struct v4l2_queryctrl *qc ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 234
  memset((void *)qc, 0, sizeof(*qc));
#line 235
  qc->id = id;
  }
#line 236
  if (tuner->test) {
#line 237
    if (! (id == 9963781U)) {
      {
#line 237
      __assert_fail("id == ((0x00980000 | 0x900)+5)", "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c",
                    237U, "query_control");
      }
    }
#line 238
    if ((tuner->test)->volume) {
#line 239
      qc->minimum = 1000;
#line 240
      qc->maximum = 2000;
    }
  } else {
    {
#line 242
    tmp___2 = ioctl((int )tuner->fd, (unsigned long )(((3U << 30) | (unsigned int )(86 << 8)) | 36U) | (sizeof(struct v4l2_queryctrl ) << 16),
                    qc);
    }
#line 242
    if (! (tmp___2 != -1)) {
      {
#line 244
      tmp___0 = __errno_location();
      }
#line 244
      if (*tmp___0 == 25) {
        {
#line 247
        memset((void *)qc, 0, sizeof(*qc));
        }
      } else {
        {
#line 244
        tmp___1 = __errno_location();
        }
#line 244
        if (*tmp___1 == 22) {
          {
#line 247
          memset((void *)qc, 0, sizeof(*qc));
          }
        } else {
          {
#line 249
          tmp = __errno_location();
#line 249
          fatal(*tmp, "VIDIOC_QUERYCTRL");
          }
        }
      }
    }
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static int32_t get_control(struct tuner  const  *tuner , uint32_t id ) 
{ 
  struct v4l2_control control ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 258
  memset((void *)(& control), 0, sizeof(control));
#line 259
  control.id = id;
  }
#line 260
  if (tuner->test) {
#line 261
    if (id == 9963781U) {
#line 262
      control.value = (tuner->test)->volume;
    } else
#line 263
    if (id == 9963785U) {
#line 264
      control.value = (__s32 )(tuner->test)->mute;
    } else {
      {
#line 266
      abort();
      }
    }
  } else {
    {
#line 267
    tmp___0 = ioctl((int )tuner->fd, (unsigned long )(((3U << 30) | (unsigned int )(86 << 8)) | 27U) | (sizeof(struct v4l2_control ) << 16),
                    & control);
    }
#line 267
    if (tmp___0 == -1) {
      {
#line 268
      tmp = __errno_location();
#line 268
      fatal(*tmp, "VIDIOC_G_CTRL");
      }
    }
  }
#line 269
  return (control.value);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void set_control(struct tuner  const  *tuner , uint32_t id , int32_t value ) 
{ 
  struct v4l2_control control ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 277
  memset((void *)(& control), 0, sizeof(control));
#line 278
  control.id = id;
#line 279
  control.value = value;
  }
#line 280
  if (tuner->test) {
#line 281
    if (id == 9963785U) {
#line 282
      if (! (value == 0)) {
#line 282
        if (! (value == 1)) {
          {
#line 282
          __assert_fail("value == 0 || value == 1", "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c",
                        282U, "set_control");
          }
        }
      }
#line 283
      (tuner->test)->mute = (_Bool )value;
    } else
#line 284
    if (id == 9963781U) {
#line 285
      if (value >= 1000) {
#line 285
        if (! (value <= 2000)) {
          {
#line 285
          __assert_fail("value >= 1000 && value <= 2000", "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c",
                        285U, "set_control");
          }
        }
      } else {
        {
#line 285
        __assert_fail("value >= 1000 && value <= 2000", "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c",
                      285U, "set_control");
        }
      }
#line 286
      (tuner->test)->volume = value;
    } else {
      {
#line 288
      abort();
      }
    }
  } else {
    {
#line 290
    tmp___0 = ioctl((int )tuner->fd, (unsigned long )(((3U << 30) | (unsigned int )(86 << 8)) | 28U) | (sizeof(struct v4l2_control ) << 16),
                    & control);
    }
#line 290
    if (tmp___0 == -1) {
      {
#line 291
      tmp = __errno_location();
#line 291
      fatal(*tmp, "VIDIOC_S_CTRL");
      }
    }
  }
#line 292
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void query_tuner(struct tuner  const  *tuner , struct v4l2_tuner *vt ) 
{ 
  int freq ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 297
  memset((void *)vt, 0, sizeof(*vt));
#line 298
  vt->index = (__u32 )tuner->index;
  }
#line 299
  if (tuner->test) {
#line 300
    freq = (tuner->test)->freq;
#line 301
    vt->rangelow = (__u32 )1424;
#line 302
    vt->rangehigh = (__u32 )1456;
#line 303
    if (freq == (int )((double )16 * 89.6 + .5)) {
#line 303
      vt->signal = 64000;
    } else {
#line 303
      if (freq == (int )((double )16 * 90.4 + .5)) {
#line 303
        tmp___0 = 50000;
      } else {
#line 303
        if (freq == (int )((double )16 * 90.5 + .5)) {
#line 303
          tmp = 40000;
        } else {
#line 303
          tmp = 1000;
        }
#line 303
        tmp___0 = tmp;
      }
#line 303
      vt->signal = tmp___0;
    }
  } else {
    {
#line 307
    tmp___2 = ioctl((int )tuner->fd, (unsigned long )(((3U << 30) | (unsigned int )(86 << 8)) | 29U) | (sizeof(struct v4l2_tuner ) << 16),
                    vt);
    }
#line 307
    if (tmp___2 == -1) {
      {
#line 308
      tmp___1 = __errno_location();
#line 308
      fatal(*tmp___1, "VIDIOC_G_TUNER");
      }
    }
  }
#line 309
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 469 "/usr/include/unistd.h"
extern int pause(void) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fm.c"
static double clamp(double percent ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 39
  if (percent < 0.0) {
#line 39
    tmp___0 = 0.0;
  } else {
#line 39
    if (percent > 100.0) {
#line 39
      tmp = 100.0;
    } else {
#line 39
      tmp = percent;
    }
#line 39
    tmp___0 = tmp;
  }
#line 39
  return (tmp___0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fm.c"
static int convert_time(char const   *string ) 
{ 
  char worktime[81] ;
  int inttime ;
  char const   *suffix ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 45
  tmp___2 = strcmp(string, "forever");
  }
#line 45
  if (tmp___2 == 0) {
#line 48
    return (0);
  } else {
    {
#line 45
    tmp___3 = strcmp(string, "-");
    }
#line 45
    if (tmp___3 == 0) {
#line 48
      return (0);
    } else {
      {
#line 45
      tmp___4 = atoi(string);
      }
#line 45
      if (tmp___4 < 0) {
#line 48
        return (0);
      } else {
        {
#line 49
        tmp___0 = strcmp(string, "none");
        }
#line 49
        if (tmp___0 == 0) {
#line 51
          return (-1);
        } else {
          {
#line 49
          tmp___1 = strcmp(string, "0");
          }
#line 49
          if (tmp___1 == 0) {
#line 51
            return (-1);
          } else {
            {
#line 58
            tmp = strspn(string, "0123456789");
#line 58
            suffix = string + tmp;
#line 60
            strncpy((char */* __restrict  */)(worktime), (char const   */* __restrict  */)string,
                    (size_t )(suffix - string));
#line 61
            worktime[suffix - string] = (char )'\000';
#line 62
            inttime = atoi((char const   *)(worktime));
            }
            {
#line 67
            if ((int const   )*suffix == 0) {
#line 67
              goto case_0;
            }
#line 67
            if ((int const   )*suffix == 115) {
#line 67
              goto case_0;
            }
#line 69
            if ((int const   )*suffix == 109) {
#line 69
              goto case_109;
            }
#line 72
            if ((int const   )*suffix == 104) {
#line 72
              goto case_104;
            }
#line 75
            if ((int const   )*suffix == 100) {
#line 75
              goto case_100;
            }
#line 78
            goto switch_default;
            case_0: /* CIL Label */ 
            case_115: /* CIL Label */ 
#line 68
            goto switch_break;
            case_109: /* CIL Label */ 
#line 70
            inttime *= 60;
#line 71
            goto switch_break;
            case_104: /* CIL Label */ 
#line 73
            inttime *= 3600;
#line 74
            goto switch_break;
            case_100: /* CIL Label */ 
#line 76
            inttime *= 86400;
#line 77
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 79
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
#line 82
            return (inttime);
          }
        }
      }
    }
  }
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fm.c"
static char *format_time(char *buffer , char const   *string ) 
{ 
  char worktime[81] ;
  char const   *suffix ;
  char *format ;
  int int_time ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 91
  tmp___2 = strcmp(string, "forever");
  }
#line 91
  if (tmp___2 == 0) {
    {
#line 94
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"forever");
    }
  } else {
    {
#line 91
    tmp___3 = strcmp(string, "-");
    }
#line 91
    if (tmp___3 == 0) {
      {
#line 94
      strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"forever");
      }
    } else {
      {
#line 91
      tmp___4 = atoi(string);
      }
#line 91
      if (tmp___4 < 0) {
        {
#line 94
        strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"forever");
        }
      } else {
        {
#line 95
        tmp___0 = strcmp(string, "none");
        }
#line 95
        if (tmp___0 == 0) {
          {
#line 97
          strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"none");
          }
        } else {
          {
#line 95
          tmp___1 = strcmp(string, "0");
          }
#line 95
          if (tmp___1 == 0) {
            {
#line 97
            strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"none");
            }
          } else {
            {
#line 105
            tmp = strspn(string, "0123456789");
#line 105
            suffix = string + tmp;
#line 106
            strncpy((char */* __restrict  */)(worktime), (char const   */* __restrict  */)string,
                    (size_t )(suffix - string));
#line 107
            worktime[suffix - string] = (char )'\000';
#line 108
            int_time = atoi((char const   *)(worktime));
            }
            {
#line 112
            if ((int const   )*suffix == 109) {
#line 112
              goto case_109;
            }
#line 115
            if ((int const   )*suffix == 104) {
#line 115
              goto case_104;
            }
#line 118
            if ((int const   )*suffix == 100) {
#line 118
              goto case_100;
            }
#line 123
            goto switch_default;
            case_109: /* CIL Label */ 
#line 113
            format = (char *)"%d minute(s)";
#line 114
            goto switch_break;
            case_104: /* CIL Label */ 
#line 116
            format = (char *)"%d hour(s)";
#line 117
            goto switch_break;
            case_100: /* CIL Label */ 
#line 119
            format = (char *)"%d day(s)";
#line 120
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 124
            format = (char *)"%d second(s)";
#line 125
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
            {
#line 128
            sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)format,
                    int_time);
            }
          }
        }
      }
    }
  }
#line 131
  return (buffer);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fm.c"
static void maybe_sleep(struct tuner  const  *tuner , char const   *wait_time ) 
{ 
  char message[81] ;
  int int_wait_time ;
  char *tmp ;

  {
  {
#line 140
  int_wait_time = convert_time(wait_time);
  }
#line 142
  if (int_wait_time > 0) {
    {
#line 144
    tmp = format_time(message, wait_time);
#line 144
    printf((char const   */* __restrict  */)"Sleeping for %s\n", tmp);
#line 145
    tuner_sleep(tuner, int_wait_time);
    }
  } else
#line 146
  if (int_wait_time == 0) {
    {
#line 148
    printf((char const   */* __restrict  */)"Sleeping forever...CTRL-C exits\n");
    }
    {
#line 149
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 150
      pause();
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fm.c"
static void usage___0(void) 
{ 


  {
  {
#line 157
  printf((char const   */* __restrict  */)"fmtools fm version %s\n\n", "2.0.7");
#line 158
  printf((char const   */* __restrict  */)"usage: %s [-h] [-o] [-q] [-d <dev>] [-t <tuner>] [-T none|forever|time] <freq>|on|off [<volume>]\n\n",
         program_name);
#line 161
  printf((char const   */* __restrict  */)"A small controller for Video for Linux radio devices.\n\n");
#line 162
  printf((char const   */* __restrict  */)"  -h         display this help\n");
#line 163
  printf((char const   */* __restrict  */)"  -o         override frequency range limits of card\n");
#line 164
  printf((char const   */* __restrict  */)"  -q         quiet mode\n");
#line 165
  printf((char const   */* __restrict  */)"  -d <dev>   select device (default: /dev/radio0)\n");
#line 166
  printf((char const   */* __restrict  */)"  -t <tuner> select tuner (default: 0)\n");
#line 167
  printf((char const   */* __restrict  */)"  -T <time>  after setting frequency, sleep for some time\n             (default: none; -=forever)\n");
#line 169
  printf((char const   */* __restrict  */)"  <freq>     frequency in MHz (i.e. 94.3)\n");
#line 170
  printf((char const   */* __restrict  */)"  on         turn radio on\n");
#line 171
  printf((char const   */* __restrict  */)"  off        turn radio off (mute)\n");
#line 172
  printf((char const   */* __restrict  */)"  +          increase volume\n");
#line 173
  printf((char const   */* __restrict  */)"  -          decrease volume\n");
#line 174
  printf((char const   */* __restrict  */)"  <volume>   percentage (0-100)\n");
#line 175
  exit(0);
  }
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fm.c"
static void getconfig(char const   *fn , double *defaultvol , double *increment ,
                      char *wait_time ) 
{ 
  FILE *conf ;
  char buf[256] ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 185
  if (! fn) {
    {
#line 186
    tmp = getenv("HOME");
#line 186
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/.fmrc",
             tmp);
#line 187
    fn = (char const   *)(buf);
    }
  }
  {
#line 189
  conf = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 191
  if (! conf) {
#line 192
    return;
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 194
    tmp___4 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)conf);
    }
#line 194
    if (! tmp___4) {
#line 194
      goto while_break;
    }
    {
#line 195
    tmp___0 = strlen((char const   *)(buf));
#line 195
    buf[tmp___0 - 1UL] = (char)0;
#line 196
    tmp___1 = strncmp((char const   *)(buf), "VOL", (size_t )3);
    }
#line 196
    if (! tmp___1) {
      {
#line 197
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lf",
             defaultvol);
      }
    }
    {
#line 198
    tmp___2 = strncmp((char const   *)(buf), "INCR", (size_t )3);
    }
#line 198
    if (! tmp___2) {
      {
#line 199
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lf",
             increment);
      }
    }
    {
#line 200
    tmp___3 = strncmp((char const   *)(buf), "TIME", (size_t )4);
    }
#line 200
    if (! tmp___3) {
      {
#line 201
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %s",
             wait_time);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  fclose(conf);
  }
#line 205
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fm.c"
static void print_volume(struct tuner  const  *tuner ) 
{ 
  double tmp ;
  _Bool tmp___0 ;

  {
  {
#line 210
  tmp___0 = tuner_has_volume_control(tuner);
  }
#line 210
  if (tmp___0) {
    {
#line 211
    tmp = tuner_get_volume(tuner);
#line 211
    printf((char const   */* __restrict  */)" at %.2f%% volume", tmp);
    }
  } else {
    {
#line 213
    printf((char const   */* __restrict  */)" (radio does not support volume control)");
    }
  }
#line 214
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fm.c"
static void print_mute(struct tuner  const  *tuner ) 
{ 
  _Bool tmp ;

  {
  {
#line 219
  tmp = tuner_is_muted(tuner);
  }
#line 219
  if (tmp) {
    {
#line 220
    printf((char const   */* __restrict  */)" (radio is muted, use \"fm on\" to unmute)");
    }
  }
#line 221
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void query_control___0(struct tuner  const  *tuner , uint32_t id , struct v4l2_queryctrl *qc ) ;
#line 40
static int32_t get_control___0(struct tuner  const  *tuner , uint32_t id ) ;
#line 41
static void set_control___0(struct tuner  const  *tuner , uint32_t id , int32_t value ) ;
#line 42
static void query_tuner___0(struct tuner  const  *tuner , struct v4l2_tuner *vt ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void *xmalloc___0(size_t n ) 
{ 
  void *p ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 65
  if (n) {
#line 65
    tmp = n;
  } else {
#line 65
    tmp = (size_t )1;
  }
  {
#line 65
  tmp___0 = malloc(tmp);
#line 65
  p = tmp___0;
  }
#line 66
  if (! p) {
    {
#line 67
    fatal(0, "out of memory");
    }
  }
#line 68
  return (p);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void query_control___0(struct tuner  const  *tuner , uint32_t id , struct v4l2_queryctrl *qc ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 234
  memset((void *)qc, 0, sizeof(*qc));
#line 235
  qc->id = id;
  }
#line 236
  if (tuner->test) {
#line 237
    if (! (id == 9963781U)) {
      {
#line 237
      __assert_fail("id == ((0x00980000 | 0x900)+5)", "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c",
                    237U, "query_control");
      }
    }
#line 238
    if ((tuner->test)->volume) {
#line 239
      qc->minimum = 1000;
#line 240
      qc->maximum = 2000;
    }
  } else {
    {
#line 242
    tmp___2 = ioctl((int )tuner->fd, (unsigned long )(((3U << 30) | (unsigned int )(86 << 8)) | 36U) | (sizeof(struct v4l2_queryctrl ) << 16),
                    qc);
    }
#line 242
    if (! (tmp___2 != -1)) {
      {
#line 244
      tmp___0 = __errno_location();
      }
#line 244
      if (*tmp___0 == 25) {
        {
#line 247
        memset((void *)qc, 0, sizeof(*qc));
        }
      } else {
        {
#line 244
        tmp___1 = __errno_location();
        }
#line 244
        if (*tmp___1 == 22) {
          {
#line 247
          memset((void *)qc, 0, sizeof(*qc));
          }
        } else {
          {
#line 249
          tmp = __errno_location();
#line 249
          fatal(*tmp, "VIDIOC_QUERYCTRL");
          }
        }
      }
    }
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static int32_t get_control___0(struct tuner  const  *tuner , uint32_t id ) 
{ 
  struct v4l2_control control ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 258
  memset((void *)(& control), 0, sizeof(control));
#line 259
  control.id = id;
  }
#line 260
  if (tuner->test) {
#line 261
    if (id == 9963781U) {
#line 262
      control.value = (tuner->test)->volume;
    } else
#line 263
    if (id == 9963785U) {
#line 264
      control.value = (__s32 )(tuner->test)->mute;
    } else {
      {
#line 266
      abort();
      }
    }
  } else {
    {
#line 267
    tmp___0 = ioctl((int )tuner->fd, (unsigned long )(((3U << 30) | (unsigned int )(86 << 8)) | 27U) | (sizeof(struct v4l2_control ) << 16),
                    & control);
    }
#line 267
    if (tmp___0 == -1) {
      {
#line 268
      tmp = __errno_location();
#line 268
      fatal(*tmp, "VIDIOC_G_CTRL");
      }
    }
  }
#line 269
  return (control.value);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void set_control___0(struct tuner  const  *tuner , uint32_t id , int32_t value ) 
{ 
  struct v4l2_control control ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 277
  memset((void *)(& control), 0, sizeof(control));
#line 278
  control.id = id;
#line 279
  control.value = value;
  }
#line 280
  if (tuner->test) {
#line 281
    if (id == 9963785U) {
#line 282
      if (! (value == 0)) {
#line 282
        if (! (value == 1)) {
          {
#line 282
          __assert_fail("value == 0 || value == 1", "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c",
                        282U, "set_control");
          }
        }
      }
#line 283
      (tuner->test)->mute = (_Bool )value;
    } else
#line 284
    if (id == 9963781U) {
#line 285
      if (value >= 1000) {
#line 285
        if (! (value <= 2000)) {
          {
#line 285
          __assert_fail("value >= 1000 && value <= 2000", "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c",
                        285U, "set_control");
          }
        }
      } else {
        {
#line 285
        __assert_fail("value >= 1000 && value <= 2000", "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c",
                      285U, "set_control");
        }
      }
#line 286
      (tuner->test)->volume = value;
    } else {
      {
#line 288
      abort();
      }
    }
  } else {
    {
#line 290
    tmp___0 = ioctl((int )tuner->fd, (unsigned long )(((3U << 30) | (unsigned int )(86 << 8)) | 28U) | (sizeof(struct v4l2_control ) << 16),
                    & control);
    }
#line 290
    if (tmp___0 == -1) {
      {
#line 291
      tmp = __errno_location();
#line 291
      fatal(*tmp, "VIDIOC_S_CTRL");
      }
    }
  }
#line 292
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/fmtools-2.0.7/fmlib.c"
static void query_tuner___0(struct tuner  const  *tuner , struct v4l2_tuner *vt ) 
{ 
  int freq ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 297
  memset((void *)vt, 0, sizeof(*vt));
#line 298
  vt->index = (__u32 )tuner->index;
  }
#line 299
  if (tuner->test) {
#line 300
    freq = (tuner->test)->freq;
#line 301
    vt->rangelow = (__u32 )1424;
#line 302
    vt->rangehigh = (__u32 )1456;
#line 303
    if (freq == (int )((double )16 * 89.6 + .5)) {
#line 303
      vt->signal = 64000;
    } else {
#line 303
      if (freq == (int )((double )16 * 90.4 + .5)) {
#line 303
        tmp___0 = 50000;
      } else {
#line 303
        if (freq == (int )((double )16 * 90.5 + .5)) {
#line 303
          tmp = 40000;
        } else {
#line 303
          tmp = 1000;
        }
#line 303
        tmp___0 = tmp;
      }
#line 303
      vt->signal = tmp___0;
    }
  } else {
    {
#line 307
    tmp___2 = ioctl((int )tuner->fd, (unsigned long )(((3U << 30) | (unsigned int )(86 << 8)) | 29U) | (sizeof(struct v4l2_tuner ) << 16),
                    vt);
    }
#line 307
    if (tmp___2 == -1) {
      {
#line 308
      tmp___1 = __errno_location();
#line 308
      fatal(*tmp___1, "VIDIOC_G_TUNER");
      }
    }
  }
#line 309
  return;
}
}
