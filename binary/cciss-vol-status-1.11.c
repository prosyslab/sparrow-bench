/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/scsi/sg.h"
struct sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   unsigned char *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 44 "/usr/include/scsi/sg.h"
typedef struct sg_io_hdr sg_io_hdr_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 53 "/usr/include/linux/cciss_defs.h"
#pragma pack(1)
#line 56 "/usr/include/linux/cciss_defs.h"
struct __anonstruct_PeripDev_40 {
   __u8 Dev ;
   __u8 Bus : 6 ;
   __u8 Mode : 2 ;
};
#line 56 "/usr/include/linux/cciss_defs.h"
struct __anonstruct_LogDev_41 {
   __u8 DevLSB ;
   __u8 DevMSB : 6 ;
   __u8 Mode : 2 ;
};
#line 56 "/usr/include/linux/cciss_defs.h"
struct __anonstruct_LogUnit_42 {
   __u8 Dev : 5 ;
   __u8 Bus : 3 ;
   __u8 Targ : 6 ;
   __u8 Mode : 2 ;
};
#line 56 "/usr/include/linux/cciss_defs.h"
union _SCSI3Addr_struct {
   struct __anonstruct_PeripDev_40 PeripDev ;
   struct __anonstruct_LogDev_41 LogDev ;
   struct __anonstruct_LogUnit_42 LogUnit ;
};
#line 56 "/usr/include/linux/cciss_defs.h"
typedef union _SCSI3Addr_struct SCSI3Addr_struct;
#line 75 "/usr/include/linux/cciss_defs.h"
struct _PhysDevAddr_struct {
   __u32 TargetId : 24 ;
   __u32 Bus : 6 ;
   __u32 Mode : 2 ;
   SCSI3Addr_struct Target[2] ;
};
#line 75 "/usr/include/linux/cciss_defs.h"
typedef struct _PhysDevAddr_struct PhysDevAddr_struct;
#line 82 "/usr/include/linux/cciss_defs.h"
struct _LogDevAddr_struct {
   __u32 VolId : 30 ;
   __u32 Mode : 2 ;
   __u8 reserved[4] ;
};
#line 82 "/usr/include/linux/cciss_defs.h"
typedef struct _LogDevAddr_struct LogDevAddr_struct;
#line 88 "/usr/include/linux/cciss_defs.h"
union _LUNAddr_struct {
   __u8 LunAddrBytes[8] ;
   SCSI3Addr_struct SCSI3Lun[4] ;
   PhysDevAddr_struct PhysDev ;
   LogDevAddr_struct LogDev ;
};
#line 88 "/usr/include/linux/cciss_defs.h"
typedef union _LUNAddr_struct LUNAddr_struct;
#line 95 "/usr/include/linux/cciss_defs.h"
struct __anonstruct_Type_43 {
   __u8 Type : 3 ;
   __u8 Attribute : 3 ;
   __u8 Direction : 2 ;
};
#line 95 "/usr/include/linux/cciss_defs.h"
struct _RequestBlock_struct {
   __u8 CDBLen ;
   struct __anonstruct_Type_43 Type ;
   __u16 Timeout ;
   __u8 CDB[16] ;
};
#line 95 "/usr/include/linux/cciss_defs.h"
typedef struct _RequestBlock_struct RequestBlock_struct;
#line 106 "/usr/include/linux/cciss_defs.h"
struct __anonstruct_Common_Info_44 {
   __u8 Reserved[3] ;
   __u8 Type ;
   __u32 ErrorInfo ;
};
#line 106 "/usr/include/linux/cciss_defs.h"
struct __anonstruct_Invalid_Cmd_45 {
   __u8 Reserved[2] ;
   __u8 offense_size ;
   __u8 offense_num ;
   __u32 offense_value ;
};
#line 106 "/usr/include/linux/cciss_defs.h"
union _MoreErrInfo_struct {
   struct __anonstruct_Common_Info_44 Common_Info ;
   struct __anonstruct_Invalid_Cmd_45 Invalid_Cmd ;
};
#line 106 "/usr/include/linux/cciss_defs.h"
typedef union _MoreErrInfo_struct MoreErrInfo_struct;
#line 119 "/usr/include/linux/cciss_defs.h"
struct _ErrorInfo_struct {
   __u8 ScsiStatus ;
   __u8 SenseLen ;
   __u16 CommandStatus ;
   __u32 ResidualCnt ;
   MoreErrInfo_struct MoreErrInfo ;
   __u8 SenseInfo[32] ;
};
#line 119 "/usr/include/linux/cciss_defs.h"
typedef struct _ErrorInfo_struct ErrorInfo_struct;
#line 128
#pragma pack()
#line 11 "/usr/include/linux/cciss_ioctl.h"
struct _cciss_pci_info_struct {
   unsigned char bus ;
   unsigned char dev_fn ;
   unsigned short domain ;
   __u32 board_id ;
};
#line 11 "/usr/include/linux/cciss_ioctl.h"
typedef struct _cciss_pci_info_struct cciss_pci_info_struct;
#line 40 "/usr/include/linux/cciss_ioctl.h"
struct _IOCTL_Command_struct {
   LUNAddr_struct LUN_info ;
   RequestBlock_struct Request ;
   ErrorInfo_struct error_info ;
   __u16 buf_size ;
   __u8 *buf ;
};
#line 40 "/usr/include/linux/cciss_ioctl.h"
typedef struct _IOCTL_Command_struct IOCTL_Command_struct;
#line 113 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct smartarray_id_t {
   uint32_t board_id ;
   char *board_name ;
   int can_decode_drive_map ;
   int supports_sas ;
};
#line 197 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct cciss_bmic_addr_t {
   unsigned char logical_lun[8] ;
   unsigned char controller_lun[8] ;
   unsigned short bmic_drive_number ;
   unsigned char bmic_id_ctlr_data[100] ;
   unsigned char inq_pg_0x83_data[100] ;
   int tolerance_type ;
   int certain ;
};
#line 207 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct bmic_addr_t {
   unsigned char controller_lun[8] ;
   unsigned short bmic_drive_number ;
   int tolerance_type ;
};
#line 213 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct cciss_to_bmic_t {
   int naddrs ;
   struct cciss_bmic_addr_t addr[1024] ;
};
#line 235
#pragma pack(1)
#line 236 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct identify_logical_drive_status {
   unsigned char status ;
   uint32_t drive_failure_map ;
   unsigned char reserved[416] ;
   uint32_t blocks_left_to_recover ;
   unsigned char drive_rebuilding ;
   uint16_t remap_count[32] ;
   uint32_t replacement_drive_map ;
   uint32_t active_spare_map ;
   unsigned char spare_status ;
   unsigned char spare_to_replace_map[32] ;
   uint32_t replaced_marked_ok_map ;
   unsigned char media_exchanged ;
   unsigned char cache_failure ;
   unsigned char expand_failure ;
   unsigned char unit_flags ;
   uint16_t big_failure_map[8] ;
   uint16_t big_remap_cnt[128] ;
   uint16_t big_replace_map[8] ;
   uint16_t big_spare_map[8] ;
   unsigned char big_spare_replace_map[128] ;
   uint16_t big_replace_ok_map[8] ;
   unsigned char big_drive_rebuild ;
};
#line 260
#pragma pack()
#line 274
#pragma pack(1)
#line 276 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct identify_controller {
   unsigned char num_logical_drives ;
   uint32_t signature ;
   unsigned char running_firm_rev[4] ;
   unsigned char rom_firm_rev[4] ;
   unsigned char hardware_rev ;
   unsigned char reserved[4] ;
   uint32_t drive_present_bit_map ;
   uint32_t external_drive_bit_map ;
   uint32_t board_id ;
   unsigned char reserved2 ;
   uint32_t non_disk_map ;
   unsigned char reserved3[5] ;
   unsigned char marketing_revision ;
   unsigned char controller_flags ;
   unsigned char host_flags ;
   unsigned char expand_disable_code ;
   unsigned char scsi_chip_count ;
   uint32_t reserved5 ;
   uint32_t ctlr_clock ;
   unsigned char drives_per_scsi_bus ;
   uint16_t big_drive_present_map[8] ;
   uint16_t big_ext_drive_map[8] ;
   uint16_t big_non_disk_map[8] ;
   unsigned short task_flags ;
   unsigned char ICL_bus_map ;
   unsigned char redund_ctlr_modes_support ;
   unsigned char curr_redund_ctlr_mode ;
   unsigned char redund_ctlr_status ;
   unsigned char redund_op_failure_code ;
   unsigned char unsupported_nile_bus ;
   unsigned char host_i2c_autorev ;
   unsigned char cpld_revision ;
   unsigned char fibre_chip_count ;
   unsigned char daughterboard_type ;
   unsigned char reserved6[2] ;
   unsigned char access_module_status ;
   unsigned char features_supported[12] ;
   unsigned char bRecRomInactiveRev[4] ;
   unsigned char bRecRomFlags ;
   unsigned char bPciToPciBridgeStatus ;
   unsigned int ulReserved ;
   unsigned char bPercentWriteCache ;
   unsigned short usDaughterboardCacheSize ;
   unsigned char bCacheBatteryCount ;
   unsigned short usTotalMemorySize ;
   unsigned char bMoreControllerFlags ;
   unsigned char bXboardHostI2cAutorev ;
   unsigned char bBatteryPicRev ;
   unsigned char bDdffVersion[4] ;
   unsigned short usMaxLogicalUnits ;
   unsigned short usExtLogicalUnitCount ;
   unsigned short usMaxPhysicalDevices ;
   unsigned short usMaxPhyDrvPerLogicalUnit ;
   unsigned char bEnclosureCount ;
   unsigned char bExpanderCount ;
   unsigned short usOffsetToEDPbitmap ;
   unsigned short usOffsetToEEDPbitmap ;
   unsigned short usOffsetToENDbitmap ;
   unsigned char bInternalPortStatus[8] ;
   unsigned char bExternalPortStatus[8] ;
   unsigned int uiYetMoreControllerFlags ;
   unsigned char bLastLockup ;
   unsigned char bSlot ;
   unsigned short usBuildNum ;
   unsigned int uiMaxSafeFullStripeSize ;
   unsigned int uiTotalLength ;
   unsigned char bVendorID[8] ;
   unsigned char bProductID[16] ;
   unsigned char reserved7[288] ;
};
#line 363
#pragma pack()
#line 365
#pragma pack(1)
#line 366 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct identify_logical_drive {
   unsigned short block_len ;
   unsigned int num_blks ;
   unsigned short cylinders ;
   unsigned char heads ;
   unsigned char xsig ;
   unsigned char psectors ;
   unsigned short wpre ;
   unsigned char maxecc ;
   unsigned char drive_control ;
   unsigned short pcyls ;
   unsigned char pheads ;
   unsigned short landz ;
   unsigned char sector_per_track ;
   unsigned char check_sum ;
   unsigned char tolerance_type ;
   unsigned char resv1 ;
   unsigned char bios_disable_flg ;
   unsigned char resv2 ;
   unsigned int log_drv_id ;
   unsigned char log_drive_label[64] ;
   unsigned int big_blocks_available_lo ;
   unsigned int big_blocks_available_hi ;
   unsigned char unique_volume_id[16] ;
   unsigned char reserved[394] ;
};
#line 393
#pragma pack()
#line 396
#pragma pack(1)
#line 397 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct alarm_struct_t {
   uint8_t alarm_status ;
   uint8_t temp_status ;
   uint8_t valid_alarm_bits ;
   uint16_t alarm_count ;
   uint16_t specific_alarm_counts[8] ;
};
#line 397 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
typedef struct alarm_struct_t alarm_struct;
#line 405 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct inquiry_data_t {
   uint8_t peripheral_type ;
   uint8_t rmb ;
   uint8_t versions ;
   uint8_t misc ;
   uint8_t additional_length ;
   uint8_t reserved[2] ;
   uint8_t support_bits ;
   uint8_t vendor_id[8] ;
   uint8_t product_id[16] ;
   uint8_t product_revision[4] ;
};
#line 405 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
typedef struct inquiry_data_t inquiry_data;
#line 418 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct sense_bus_param_t {
   inquiry_data inquiry ;
   uint8_t inquiry_valid ;
   uint32_t installed_drive_map ;
   uint16_t hot_plug_count[32] ;
   uint8_t reserved1 ;
   uint8_t reserved2 ;
   alarm_struct alarm_data ;
   uint16_t connection_info ;
   uint8_t scsi_device_revision ;
   uint8_t fan_status ;
   uint8_t more_inquiry_data[64] ;
   uint32_t scsi_device_type ;
   uint32_t bus_bit_map ;
   uint8_t reserved3[8] ;
   uint8_t scsi_initiator_id ;
   uint8_t scsi_target_id ;
   uint8_t physical_port[2] ;
   uint16_t big_installed_drive_map[8] ;
   uint16_t big_bus_bit_map[8] ;
   uint16_t big_box_bit_map[8] ;
   uint8_t installed_box_map ;
   uint8_t more_connection_info ;
   uint8_t reserved4[2] ;
   char chassis_sn[40] ;
};
#line 418 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
typedef struct sense_bus_param_t sense_bus_param;
#line 446 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct identify_physical_device {
   uint8_t scsi_bus ;
   uint8_t scsi_id ;
   uint16_t block_size_in_bytes ;
   uint32_t total_blocks ;
   uint32_t reserved_blocks ;
   unsigned char drive_model[40] ;
   unsigned char drive_serial_no[40] ;
   unsigned char drive_fw_rev[8] ;
   uint8_t scsi_inquiry_byte_7 ;
   uint8_t reserved[2] ;
   uint8_t physical_drive_flags ;
   uint8_t more_physical_drive_flags ;
   uint8_t reserved2 ;
   uint8_t yet_more_physical_drive_flags ;
   uint8_t reserved3[5] ;
   unsigned char phys_connector[2] ;
   uint8_t phys_box_on_bus ;
   uint8_t phys_bay_in_box ;
};
#line 516
#pragma pack()
#line 530
#pragma pack(1)
#line 533 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct bmic_transfer_data {
   uint8_t memory_address_hi_dir ;
   uint16_t memory_address_lo ;
   uint16_t transfer_count ;
};
#line 539 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct bmic_cache_configuration {
   uint32_t posted_writes_drive_bit_map ;
   uint16_t mem_for_read_cache ;
   uint16_t mem_for_write_cache ;
   uint8_t disable_flag ;
   uint16_t offset_to_ecu_bitmap ;
   uint16_t offset_to_ecf_bitmap ;
   uint16_t offset_to_ercdu_bitmap ;
   uint8_t reserved1 ;
   uint32_t total_length ;
   uint16_t max_log_drv_supported ;
   uint8_t reserved2[10] ;
   uint32_t status ;
   uint16_t disable_code ;
   uint16_t total_memory_size ;
   uint16_t battery_count ;
   uint16_t good_battery_map ;
   uint16_t parity_read_errors ;
   uint16_t parity_write_errors ;
   struct bmic_transfer_data error_log[32] ;
   uint16_t failed_battery_map ;
   uint8_t daughter_board_attached ;
   uint32_t cache_failure_map ;
   uint8_t max_error_log_entries ;
   uint8_t nvarm_load_status ;
   uint8_t memory_size_shift_factor ;
   uint16_t non_battery_backed_memory_size ;
   uint8_t memory_state ;
   uint8_t cache_autorev ;
   uint16_t total_attached_memory ;
   uint8_t percent_read_cache ;
   uint8_t percent_write_cache ;
   uint8_t default_percent_read_cache ;
   uint8_t default_percent_write_cache ;
   uint8_t reserved[284] ;
};
#line 593
#pragma pack()
#line 1409 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct serial_number_map {
   char *device_node ;
   char serial_no[16] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 254 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
#line 324
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) alphasort)(struct dirent  const  **__e1 ,
                                                                                                  struct dirent  const  **__e2 )  __attribute__((__pure__)) ;
#line 98 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
_Bool everything_hunky_dory  =    (_Bool)1;
#line 99 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int persnickety  =    0;
#line 100 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int be_quiet  =    1;
#line 101 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int try_unknown_devices  =    0;
#line 102 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int exhaustive_search  =    0;
#line 103 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int debug  =    0;
#line 104 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int check_smart_data  =    0;
#line 105 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int verbose  =    0;
#line 113 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct smartarray_id_t smartarray_id[55]  = 
#line 113
  {      {(uint32_t )1081085457, (char *)"Smart Array 5300", 1, 0}, 
        {(uint32_t )1082134033, (char *)"Smart Array 5i", 1, 0}, 
        {(uint32_t )1082265105, (char *)"Smart Array 532", 1, 0}, 
        {(uint32_t )1082330641, (char *)"Smart Array 5312", 1, 0}, 
        {(uint32_t )1083837969, (char *)"Smart Array 641", 1, 0}, 
        {(uint32_t )1083903505, (char *)"Smart Array 642", 1, 0}, 
        {(uint32_t )1083969041, (char *)"Smart Array 6400", 1, 0}, 
        {(uint32_t )1084034577, (char *)"Smart Array 6400 EM", 1, 0}, 
        {(uint32_t )1083248145, (char *)"Smart Array 6i", 1, 0}, 
        {(uint32_t )1084100113, (char *)"Smart Array 6422", 1, 0}, 
        {(uint32_t )841289788, (char *)"Smart Array P600", 0, 1}, 
        {(uint32_t )842272828, (char *)"Smart Array P400", 0, 1}, 
        {(uint32_t )842338364, (char *)"Smart Array P400i", 0, 1}, 
        {(uint32_t )839979068, (char *)"Smart Array E200i", 0, 1}, 
        {(uint32_t )840044604, (char *)"Smart Array E200", 0, 1}, 
        {(uint32_t )840110140, (char *)"Smart Array E200i", 0, 1}, 
        {(uint32_t )840175676, (char *)"Smart Array E200i", 0, 1}, 
        {(uint32_t )840241212, (char *)"Smart Array E200i", 0, 1}, 
        {(uint32_t )841158716, (char *)"Smart Array P800", 0, 1}, 
        {(uint32_t )842469436, (char *)"Smart Array E500", 0, 1}, 
        {(uint32_t )842862652, (char *)"Smart Array P700m", 0, 1}, 
        {(uint32_t )843124796, (char *)"Smart Array P212", 0, 1}, 
        {(uint32_t )843255868, (char *)"Smart Array P410", 0, 1}, 
        {(uint32_t )843386940, (char *)"Smart Array P410i", 0, 1}, 
        {(uint32_t )843518012, (char *)"Smart Array P411", 0, 1}, 
        {(uint32_t )843649084, (char *)"Smart Array P812", 0, 1}, 
        {3759214097U, (char *)"HP MSA500", 1, 0}, 
        {3760197137U, (char *)"HP MSA500 G2", 1, 0}, 
        {3761245713U, (char *)"HP MSA20", 1, 0}, 
        {(uint32_t )823660604, (char *)"HP B110i", 0, 1}, 
        {(uint32_t )843714620, (char *)"Smart Array P712m", 0, 1}, 
        {(uint32_t )843780156, (char *)"Smart Array P711m", 0, 1}, 
        {(uint32_t )860885052, (char *)"Smart Array P222", 0, 1}, 
        {(uint32_t )860950588, (char *)"Smart Array P420", 0, 1}, 
        {(uint32_t )861016124, (char *)"Smart Array P421", 0, 1}, 
        {(uint32_t )861081660, (char *)"Smart Array P822", 0, 1}, 
        {(uint32_t )861147196, (char *)"Smart Array P420i", 0, 1}, 
        {(uint32_t )861212732, (char *)"Smart Array P220i", 0, 1}, 
        {(uint32_t )861278268, (char *)"Smart Array P721m", 0, 1}, 
        {(uint32_t )421531708, (char *)"Smart Array", 0, 1}, 
        {(uint32_t )421597244, (char *)"Smart Array", 0, 1}, 
        {(uint32_t )421662780, (char *)"Smart Array", 0, 1}, 
        {(uint32_t )421728316, (char *)"Smart Array", 0, 1}, 
        {(uint32_t )421793852, (char *)"Smart Array", 0, 1}, 
        {(uint32_t )421859388, (char *)"Smart Array", 0, 1}, 
        {(uint32_t )421924924, (char *)"Smart Array", 0, 1}, 
        {(uint32_t )422055996, (char *)"Smart Array", 0, 1}, 
        {(uint32_t )860688444, (char *)"Smart Array P822se", 0, 1}, 
        {(uint32_t )4527504, (char *)"Dynamic Smart Array B320i", 0, 1}, 
        {(uint32_t )4658576, (char *)"Dynamic Smart Array B320i", 0, 1}, 
        {(uint32_t )4724112, (char *)"Dynamic Smart Array B120i", 0, 1}, 
        {(uint32_t )7083408, (char *)"Dynamic Smart Array B120i", 0, 1}, 
        {(uint32_t )8656272, (char *)"Dynamic Smart Array B120i", 0, 1}, 
        {3759148561U, (char *)"MSA1000", 1, 0}, 
        {4294967295U, (char *)"Unknown Smart Array", 0, 1}};
#line 187 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static unsigned char *zero_lun  =    (unsigned char *)"\000\000\000\000\000\000\000\000";
#line 213 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
struct cciss_to_bmic_t cciss_to_bmic  ;
#line 222 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
unsigned char controller_lun_list[256][8]  ;
#line 223 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int busses_on_this_ctlr[256]  ;
#line 224 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int num_controllers  =    0;
#line 262 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
char const   *spare_drive_status_msg[6]  = {      "At least one spare drive designated",      "At least one spare drive activated and currently rebuilding",      "At least one activated on-line spare drive is completely rebuilt on this logical drive",      "At least one spare drive has failed", 
        "At least one spare drive activated",      "At least one spare drive remains available"};
#line 595 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
char *progname  =    (char *)"cciss_vol_status";
#line 597 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
void usage(void) 
{ 


  {
  {
#line 599
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: usage: %s [-p] [-q] [-v] [-u] [-x] /dev/cciss/c*d0 /dev/sg*\n",
          progname, progname);
#line 600
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -p  --persnickety          Complain about device nodes which can\'t be opened.\n");
#line 601
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -u  --try-unknown-devices  Allow interrogation of even unrecognized controllers\n");
#line 602
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                            (useful for brand new hardware.)\n");
#line 603
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -s  --smart                Report S.M.A.R.T. predictive failures. \n");
#line 604
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -v  --version              Print program version and exit.\n");
#line 605
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -V  --verbose              Print more info about controller and disks.\n");
#line 606
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -C  --copyright            Print copyright notice first.\n");
#line 607
  exit(-1);
  }
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void set_cdb_buffer_length(unsigned char *cdb , uint16_t buflen ) 
{ 


  {
#line 613
  *(cdb + 7) = (unsigned char )(((int )buflen >> 8) & 255);
#line 614
  *(cdb + 8) = (unsigned char )((int )buflen & 255);
#line 615
  return;
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void find_bus_target(struct identify_controller *id , int bmic_drive_number ,
                            int *bus , int *target ) 
{ 
  int big_map_support ;
  int drives_per_scsi_bus ;
  int tmp ;

  {
#line 623
  if (id->controller_flags) {
#line 623
    if (1 << 7) {
#line 623
      tmp = 1;
    } else {
#line 623
      tmp = 0;
    }
  } else {
#line 623
    tmp = 0;
  }
#line 623
  big_map_support = tmp;
#line 624
  drives_per_scsi_bus = (int )id->drives_per_scsi_bus;
#line 627
  if (! big_map_support) {
#line 627
    if (drives_per_scsi_bus == 0) {
#line 628
      drives_per_scsi_bus = 7;
    }
  }
#line 630
  if (drives_per_scsi_bus == 0) {
    {
#line 632
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Controller reports zero devices per scsi bus.  This is not reasonable. Exiting.\n");
#line 634
    exit(-1);
    }
  }
#line 636
  *bus = bmic_drive_number / drives_per_scsi_bus;
#line 637
  *target = bmic_drive_number % drives_per_scsi_bus;
#line 638
  return;
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void copy_drive_field(unsigned char *to , unsigned char *from , int limit ) 
{ 
  int i ;
  unsigned short const   **tmp ;

  {
#line 644
  i = 0;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (i < limit)) {
#line 644
      goto while_break;
    }
    {
#line 645
    tmp = __ctype_b_loc();
    }
#line 645
    if ((int const   )*(*tmp + (int )*(from + i)) & 16384) {
#line 646
      *(to + i) = *(from + i);
    } else
#line 645
    if ((int )*(from + i) == 0) {
#line 646
      *(to + i) = *(from + i);
    } else {
#line 648
      *(to + i) = (unsigned char )'?';
    }
#line 644
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 650
  *(to + limit) = (unsigned char )'\000';
#line 651
  return;
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void format_phys_drive_location(char *location , int bus , int target , int ctlrtype ,
                                       unsigned char *controller_lun , struct identify_physical_device *device_data ) 
{ 
  char tail[300] ;
  unsigned char model[sizeof(device_data->drive_model) + 1UL] ;
  unsigned char serial_no[sizeof(device_data->drive_serial_no) + 1UL] ;
  unsigned char fw_rev[sizeof(device_data->drive_fw_rev) + 1UL] ;

  {
#line 661
  if (smartarray_id[ctlrtype].can_decode_drive_map) {
#line 661
    if (device_data) {
      {
#line 662
      sprintf((char */* __restrict  */)location, (char const   */* __restrict  */)"    b%dt%d",
              bus, target);
      }
    } else
#line 661
    if (! controller_lun) {
      {
#line 662
      sprintf((char */* __restrict  */)location, (char const   */* __restrict  */)"    b%dt%d",
              bus, target);
      }
    } else {
      {
#line 664
      sprintf((char */* __restrict  */)location, (char const   */* __restrict  */)"        ");
      }
    }
  } else {
    {
#line 664
    sprintf((char */* __restrict  */)location, (char const   */* __restrict  */)"        ");
    }
  }
#line 665
  if (device_data) {
#line 665
    if (controller_lun) {
      {
#line 666
      copy_drive_field(model, device_data->drive_model, (int )sizeof(device_data->drive_model));
#line 667
      copy_drive_field(serial_no, device_data->drive_serial_no, (int )sizeof(device_data->drive_serial_no));
#line 668
      copy_drive_field(fw_rev, device_data->drive_fw_rev, (int )sizeof(device_data->drive_fw_rev));
#line 669
      sprintf((char */* __restrict  */)(tail), (char const   */* __restrict  */)" connector %c%c box %d bay %d %40s %40s %8s",
              (int )device_data->phys_connector[0], (int )device_data->phys_connector[1],
              (int )device_data->phys_box_on_bus, (int )device_data->phys_bay_in_box,
              model, serial_no, fw_rev);
      }
    } else {
      {
#line 676
      sprintf((char */* __restrict  */)(tail), (char const   */* __restrict  */)" connector ?? box ?? bay ?? %40s %40s %8s",
              "unknown-model", "unknown-serial-no", "unknown firmware rev");
      }
    }
  } else {
    {
#line 676
    sprintf((char */* __restrict  */)(tail), (char const   */* __restrict  */)" connector ?? box ?? bay ?? %40s %40s %8s",
            "unknown-model", "unknown-serial-no", "unknown firmware rev");
    }
  }
  {
#line 680
  strcat((char */* __restrict  */)location, (char const   */* __restrict  */)(tail));
  }
#line 681
  return;
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int bitisset(unsigned char *bitstring , int bit , int bitstringlength ) 
{ 
  int element ;
  int offset ;
  unsigned char or_val ;

  {
#line 689
  element = bit / 8;
#line 691
  if (element >= bitstringlength) {
    {
#line 692
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bug detected at %s:%d\n",
            "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c",
            692);
#line 693
    abort();
    }
  }
#line 696
  offset = bit % 8;
#line 697
  or_val = (unsigned char )(1 << offset);
#line 699
  return (((int )*(bitstring + element) & (int )or_val) != 0);
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int check_ioctl_results(char *filename , char *command , int rc , IOCTL_Command_struct *cmd ,
                               int ldrive_num ) 
{ 
  char numstring[120] ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 707
  if (debug) {
    {
#line 708
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CHK: %s: CommandStatus=%d\n",
            command, (int )cmd->error_info.CommandStatus);
    }
#line 710
    if ((int )cmd->error_info.CommandStatus == 1) {
      {
#line 711
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ScsiStatus = %d\n",
              (int )cmd->error_info.ScsiStatus);
      }
#line 712
      if ((int )cmd->error_info.ScsiStatus == 2) {
        {
#line 713
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Check condition, sense key = %d\n",
                (int )cmd->error_info.SenseInfo[2]);
        }
      }
    }
  }
  {
#line 717
  sprintf((char */* __restrict  */)(numstring), (char const   */* __restrict  */)" (logical drive number = %d)",
          ldrive_num);
  }
#line 719
  if (rc != 0) {
    {
#line 720
    tmp = __errno_location();
#line 720
    tmp___0 = strerror(*tmp);
#line 720
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s, %s ioctl failed, %s, returning -1\n",
            progname, filename, command, tmp___0);
    }
#line 722
    return (-1);
  }
#line 724
  if ((int )cmd->error_info.CommandStatus != 0) {
#line 724
    if ((int )cmd->error_info.CommandStatus != 2) {
#line 726
      if (debug) {
#line 727
        if (ldrive_num == -1) {
#line 727
          tmp___1 = "";
        } else {
#line 727
          tmp___1 = (char const   *)(numstring);
        }
        {
#line 727
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s%s, %s ioctl has Command Status=%d, returning -1\n",
                progname, filename, command, tmp___1, (int )cmd->error_info.CommandStatus);
        }
      }
#line 732
      return (-1);
    }
  }
#line 734
  return (0);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void setup_for_ioctl(IOCTL_Command_struct *cmd , unsigned char *lun , unsigned char *cdb ,
                            int cdblen , int write_direction , unsigned char *buf ,
                            int bufsize ) 
{ 


  {
  {
#line 750
  memset((void *)cmd, 0, sizeof(*cmd));
  }
#line 751
  if ((unsigned long )lun != (unsigned long )((void *)0)) {
    {
#line 752
    memcpy((void */* __restrict  */)(& cmd->LUN_info), (void const   */* __restrict  */)lun,
           (size_t )8);
    }
  }
#line 753
  cmd->Request.CDBLen = (__u8 )cdblen;
#line 754
  cmd->Request.Type.Type = (__u8 )0;
#line 755
  cmd->Request.Type.Attribute = (__u8 )4;
#line 756
  if (write_direction) {
#line 756
    cmd->Request.Type.Direction = (__u8 )1;
  } else {
#line 756
    cmd->Request.Type.Direction = (__u8 )2;
  }
  {
#line 757
  cmd->Request.Timeout = (__u16 )0;
#line 758
  memcpy((void */* __restrict  */)(cmd->Request.CDB), (void const   */* __restrict  */)cdb,
         (size_t )cdblen);
#line 759
  cmd->buf_size = (__u16 )bufsize;
#line 760
  cmd->buf = buf;
  }
#line 761
  return;
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void print_report_lun_data(char *title , int count_in_bytes , unsigned char *data ,
                                  _Bool extended ) 
{ 
  int i ;
  int lun_count ;
  int bytes_per_lun ;
  int lun ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 771
  if (extended) {
#line 771
    tmp = 1;
  } else {
#line 771
    tmp = 0;
  }
#line 771
  bytes_per_lun = 8 + tmp * 16;
#line 773
  if (extended) {
#line 773
    tmp___0 = 1;
  } else {
#line 773
    tmp___0 = 0;
  }
#line 773
  lun_count = count_in_bytes / (8 + tmp___0 * 16);
#line 775
  if (extended) {
#line 775
    tmp___1 = "(extended)";
  } else {
#line 775
    tmp___1 = "";
  }
  {
#line 775
  printf((char const   */* __restrict  */)"%s (%s)\n", title, tmp___1);
#line 776
  printf((char const   */* __restrict  */)"bytecount = %d, lun count = %d \n", count_in_bytes,
         lun_count);
#line 778
  lun = 0;
#line 779
  i = 0;
  }
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! (i < count_in_bytes)) {
#line 779
      goto while_break;
    }
#line 780
    if (i % bytes_per_lun == 0) {
      {
#line 781
      printf((char const   */* __restrict  */)"\n%d: ", lun);
      }
    }
    {
#line 782
    printf((char const   */* __restrict  */)"%02x", (int )*(data + (i - 8)));
#line 779
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 784
  printf((char const   */* __restrict  */)"\n\n");
  }
#line 785
  return;
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int do_report_luns(char *filename , int fd , int *count , unsigned char *lun ,
                          int physical , int extended_flags ) 
{ 
  IOCTL_Command_struct cmd ;
  int rc ;
  unsigned char cdb[16] ;
  unsigned int bufsize ;
  char *cmdname ;
  int becount ;
  _Bool extended ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  char const   *tmp___5 ;

  {
#line 796
  extended = (_Bool )(extended_flags & 3);
#line 798
  if (extended) {
#line 798
    tmp = 1;
  } else {
#line 798
    tmp = 0;
  }
  {
#line 798
  memset((void *)lun, 0, (size_t )(*count * (8 + tmp * 16)));
  }
#line 799
  if (extended) {
#line 799
    tmp___0 = 1;
  } else {
#line 799
    tmp___0 = 0;
  }
  {
#line 799
  bufsize = htonl((uint32_t )(*count * (8 + tmp___0 * 16)));
#line 800
  memset((void *)(cdb), 0, (size_t )16);
  }
#line 801
  if (physical) {
#line 801
    cdb[0] = (unsigned char)195;
  } else {
#line 801
    cdb[0] = (unsigned char)194;
  }
  {
#line 802
  cdb[1] = (unsigned char )extended_flags;
#line 803
  memcpy((void */* __restrict  */)(& cdb[6]), (void const   */* __restrict  */)(& bufsize),
         (size_t )4);
#line 805
  setup_for_ioctl(& cmd, zero_lun, cdb, 12, 0, lun, *count * 8);
#line 806
  rc = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(66 << 8)) | 11U) | (sizeof(IOCTL_Command_struct ) << 16),
             & cmd);
  }
#line 808
  if (physical) {
#line 809
    if (extended) {
#line 809
      cmdname = (char *)"REPORT_PHYSICAL (extended)";
    } else {
#line 809
      cmdname = (char *)"REPORT_PHYSICAL";
    }
  } else
#line 811
  if (extended) {
#line 811
    cmdname = (char *)"REPORT_LOGICAL (extended)";
  } else {
#line 811
    cmdname = (char *)"REPORT_LOGICAL";
  }
  {
#line 812
  tmp___1 = check_ioctl_results(filename, cmdname, rc, & cmd, -1);
  }
#line 812
  if (tmp___1 != 0) {
#line 812
    return (-1);
  }
  {
#line 817
  memcpy((void */* __restrict  */)(& becount), (void const   */* __restrict  */)lun,
         sizeof(becount));
#line 818
  tmp___2 = ntohl((uint32_t )becount);
  }
#line 818
  if (extended) {
#line 818
    tmp___3 = 1;
  } else {
#line 818
    tmp___3 = 0;
  }
#line 818
  *count = (int )(tmp___2 / (uint32_t )(8 + tmp___3 * 16));
#line 820
  if (debug) {
    {
#line 821
    tmp___4 = ntohl((uint32_t )becount);
    }
#line 821
    if (physical) {
#line 821
      tmp___5 = "Report physical luns";
    } else {
#line 821
      tmp___5 = "Report logical luns";
    }
    {
#line 821
    print_report_lun_data((char *)tmp___5, (int )tmp___4, lun, extended);
    }
  }
#line 823
  return (0);
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int do_bmic_id_logical_drive(char *filename , int fd , unsigned char *controller_lun ,
                                    int bmic_drive_number , unsigned char *buffer ) 
{ 
  IOCTL_Command_struct cmd ;
  unsigned char cdb[16] ;
  int rc ;
  int tmp ;

  {
  {
#line 834
  memset((void *)(cdb), 0, (size_t )16);
#line 835
  cdb[0] = (unsigned char)38;
#line 836
  cdb[1] = (unsigned char )(255 & bmic_drive_number);
#line 837
  cdb[6] = (unsigned char)16;
#line 838
  set_cdb_buffer_length(cdb, (uint16_t )512);
#line 839
  cdb[9] = (unsigned char )(bmic_drive_number >> 8 != 0);
#line 841
  setup_for_ioctl(& cmd, controller_lun, cdb, 16, 0, buffer, 512);
#line 842
  rc = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(66 << 8)) | 11U) | (sizeof(IOCTL_Command_struct ) << 16),
             & cmd);
#line 843
  tmp = check_ioctl_results(filename, (char *)"IDENTIFY_LOGICAL_DRIVE", rc, & cmd,
                            -1);
  }
#line 843
  if (tmp != 0) {
#line 843
    return (-1);
  }
#line 844
  return (0);
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int do_sense_cache_configuration(char *filename , int fd , unsigned char *controller_lun ,
                                        struct bmic_cache_configuration *cache_config ) 
{ 
  IOCTL_Command_struct cmd ;
  unsigned char cdb[16] ;
  int rc ;
  int tmp ;

  {
  {
#line 855
  memset((void *)(cdb), 0, (size_t )16);
#line 856
  cdb[0] = (unsigned char)38;
#line 857
  cdb[6] = (unsigned char)193;
#line 858
  set_cdb_buffer_length(cdb, (uint16_t )sizeof(*cache_config));
#line 860
  setup_for_ioctl(& cmd, controller_lun, cdb, 10, 0, (unsigned char *)cache_config,
                  (int )sizeof(*cache_config));
#line 863
  rc = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(66 << 8)) | 11U) | (sizeof(IOCTL_Command_struct ) << 16),
             & cmd);
#line 864
  tmp = check_ioctl_results(filename, (char *)"BMIC_SENSE_CACHE_CONFIGURATION", rc,
                            & cmd, -1);
  }
#line 864
  if (tmp != 0) {
#line 864
    return (-1);
  }
#line 866
  return (0);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int do_bmic_identify_physical_device(char *filename , int fd , unsigned char *controller_lun ,
                                            int bmic_drive_number , struct identify_physical_device *id_phys_device ) 
{ 
  IOCTL_Command_struct cmd ;
  int is_internal_controller ;
  uint8_t lunzero[8] ;
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 878
  memset((void *)(& cmd), 0, sizeof(cmd));
#line 879
  memset((void *)(lunzero), 0, sizeof(lunzero));
#line 881
  tmp = memcmp((void const   *)(lunzero), (void const   *)controller_lun, (size_t )8);
#line 881
  is_internal_controller = tmp == 0;
#line 883
  memcpy((void */* __restrict  */)(& cmd.LUN_info), (void const   */* __restrict  */)controller_lun,
         sizeof(cmd.LUN_info));
#line 884
  cmd.Request.CDBLen = (__u8 )10;
#line 885
  cmd.Request.CDB[0] = (__u8 )38;
  }
#line 886
  if (is_internal_controller) {
#line 887
    cmd.Request.CDB[2] = (__u8 )(bmic_drive_number & 255);
  } else {
#line 889
    cmd.Request.CDB[5] = (__u8 )(bmic_drive_number & 255);
  }
  {
#line 890
  cmd.Request.CDB[6] = (__u8 )21;
#line 891
  cmd.Request.CDB[9] = (__u8 )((bmic_drive_number >> 8) & 255);
#line 892
  set_cdb_buffer_length(cmd.Request.CDB, (uint16_t )sizeof(*id_phys_device));
#line 893
  cmd.Request.Type.Type = (__u8 )0;
#line 894
  cmd.Request.Type.Attribute = (__u8 )4;
#line 895
  cmd.Request.Type.Direction = (__u8 )2;
#line 896
  cmd.Request.Timeout = (__u16 )0;
#line 897
  cmd.buf = (__u8 *)((void *)id_phys_device);
#line 898
  cmd.buf_size = (__u16 )sizeof(*id_phys_device);
#line 900
  rc = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(66 << 8)) | 11U) | (sizeof(IOCTL_Command_struct ) << 16),
             & cmd);
#line 901
  tmp___0 = check_ioctl_results(filename, (char *)"IDENTIFY_PHYSICAL_DEVICE", rc,
                                & cmd, -1);
  }
#line 901
  if (tmp___0 != 0) {
#line 901
    return (-1);
  }
#line 902
  return (rc);
}
}
#line 906
static int do_sg_io(int fd , unsigned char *cdb , unsigned char cdblen , unsigned char *buffer ,
                    unsigned int buf_size , int direction ) ;
#line 908 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int do_sgio_bmic_identify_physical_device(int fd , int bmic_drive_number ,
                                                 struct identify_physical_device *id_phys_device ) 
{ 
  unsigned char cdb[16] ;
  uint8_t lunzero[8] ;
  int tmp ;

  {
  {
#line 914
  memset((void *)(lunzero), 0, sizeof(lunzero));
#line 916
  cdb[0] = (unsigned char)38;
#line 925
  cdb[2] = (unsigned char )(bmic_drive_number & 255);
#line 926
  cdb[5] = (unsigned char )(bmic_drive_number & 255);
#line 927
  cdb[6] = (unsigned char)21;
#line 928
  cdb[9] = (unsigned char )((bmic_drive_number >> 8) & 255);
#line 929
  set_cdb_buffer_length(cdb, (uint16_t )sizeof(id_phys_device));
#line 931
  tmp = do_sg_io(fd, cdb, (unsigned char)10, (unsigned char *)(& id_phys_device),
                 (unsigned int )sizeof(id_phys_device), -3);
  }
#line 931
  return (tmp);
}
}
#line 936
static int lookup_controller(uint32_t board_id ) ;
#line 937 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int id_ctlr_fd(char *filename , int fd , unsigned char *lun , struct identify_controller *id ) 
{ 
  int rc ;
  unsigned char cdb[16] ;
  IOCTL_Command_struct cmd ;
  int ctlrtype ;
  int tmp ;

  {
  {
#line 944
  memset((void *)id, 0, sizeof(*id));
#line 945
  memset((void *)(& cmd), 0, sizeof(cmd));
#line 946
  memset((void *)(cdb), 0, (size_t )16);
#line 947
  cdb[0] = (unsigned char)38;
#line 948
  cdb[6] = (unsigned char)17;
#line 949
  set_cdb_buffer_length(cdb, (uint16_t )sizeof(*id));
#line 951
  setup_for_ioctl(& cmd, lun, cdb, 10, 0, (unsigned char *)id, (int )sizeof(*id));
#line 952
  rc = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(66 << 8)) | 11U) | (sizeof(IOCTL_Command_struct ) << 16),
             & cmd);
#line 953
  tmp = check_ioctl_results(filename, (char *)"ID_CONTROLLER", rc, & cmd, -1);
  }
#line 953
  if (tmp != 0) {
#line 953
    return (-1);
  }
  {
#line 955
  ctlrtype = lookup_controller(id->board_id);
  }
#line 956
  if (ctlrtype == -1) {
    {
#line 957
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Warning: unknown controller type 0x%08x\n",
            progname, id->board_id);
#line 959
    everything_hunky_dory = (_Bool)0;
    }
  } else
#line 960
  if (ctlrtype == -1) {
#line 961
    id->drives_per_scsi_bus = (unsigned char)16;
#line 962
    id->scsi_chip_count = (unsigned char)8;
  } else
#line 960
  if (smartarray_id[ctlrtype].supports_sas) {
#line 961
    id->drives_per_scsi_bus = (unsigned char)16;
#line 962
    id->scsi_chip_count = (unsigned char)8;
  }
#line 968
  if ((int )id->drives_per_scsi_bus == 0) {
#line 969
    id->drives_per_scsi_bus = (unsigned char)7;
  }
#line 970
  return (0);
}
}
#line 973 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void show_disk_map(char *title , char *filename , int fd , struct identify_controller *id ,
                          unsigned char *controller_lun , int ctlrtype , unsigned char *bigmap ,
                          uint32_t smallmap ) 
{ 
  int bus ;
  int target ;
  int first_time ;
  int i ;
  int rc ;
  int big_map_support ;
  int ndisks ;
  int drives_per_scsi_bus ;
  struct identify_physical_device device_data ;
  char location[300] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct identify_physical_device *tmp___2 ;
  int tmp___3 ;

  {
#line 982
  ndisks = 0;
#line 987
  if (id->controller_flags) {
#line 987
    if (1 << 7) {
#line 987
      tmp = 1;
    } else {
#line 987
      tmp = 0;
    }
  } else {
#line 987
    tmp = 0;
  }
#line 987
  big_map_support = tmp;
#line 988
  drives_per_scsi_bus = (int )id->drives_per_scsi_bus;
#line 991
  if (! big_map_support) {
#line 991
    if (drives_per_scsi_bus == 0) {
#line 992
      drives_per_scsi_bus = 7;
    }
  }
#line 994
  if (drives_per_scsi_bus == 0) {
    {
#line 996
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Controller reports zero devices per scsi bus.  This is not reasonable. Exiting.\n");
#line 998
    exit(-1);
    }
  }
#line 1001
  first_time = 1;
#line 1002
  i = 0;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (big_map_support) {
#line 1002
      tmp___3 = 128;
    } else {
#line 1002
      tmp___3 = 16;
    }
#line 1002
    if (! (i < tmp___3)) {
#line 1002
      goto while_break;
    }
    {
#line 1003
    find_bus_target(id, i, & bus, & target);
    }
#line 1005
    if (big_map_support) {
      {
#line 1005
      tmp___1 = bitisset(bigmap, i, 16);
      }
#line 1005
      if (tmp___1) {
#line 1005
        goto _L;
      } else {
#line 1006
        goto __Cont;
      }
    } else
    _L: /* CIL Label */ 
#line 1008
    if (! big_map_support) {
      {
#line 1008
      tmp___0 = bitisset((unsigned char *)(& smallmap), i, (int )sizeof(smallmap));
      }
#line 1008
      if (! tmp___0) {
#line 1009
        goto __Cont;
      }
    }
    {
#line 1011
    rc = 0;
#line 1012
    memset((void *)(& device_data), 0, sizeof(device_data));
    }
#line 1014
    if (controller_lun) {
      {
#line 1016
      rc = do_bmic_identify_physical_device(filename, fd, controller_lun, i, & device_data);
      }
    } else {
      {
#line 1020
      rc = do_sgio_bmic_identify_physical_device(fd, i, & device_data);
      }
    }
#line 1022
    if (first_time) {
      {
#line 1023
      printf((char const   */* __restrict  */)"\n%s\n", title);
#line 1024
      first_time = 0;
      }
    }
#line 1027
    if (rc) {
#line 1027
      tmp___2 = (struct identify_physical_device *)((void *)0);
    } else {
#line 1027
      tmp___2 = & device_data;
    }
    {
#line 1027
    format_phys_drive_location(location, bus, target, ctlrtype, controller_lun, tmp___2);
#line 1029
    printf((char const   */* __restrict  */)"%s\n", location);
#line 1030
    ndisks ++;
    }
    __Cont: /* CIL Label */ 
#line 1002
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1032
  return;
}
}
#line 1034 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static char *decode_status[13]  = 
#line 1034
  {      (char *)"OK",      (char *)"FAILED",      (char *)"Not configured",      (char *)"Using interim recovery mode", 
        (char *)"Ready for recovery operation",      (char *)"Currently recovering",      (char *)"Wrong physical drive was replaced",      (char *)"A physical drive is not properly connected", 
        (char *)"Hardware is overheating",      (char *)"Hardware was overheated",      (char *)"Currently expannding",      (char *)"Not yet available", 
        (char *)"Queued for expansion"};
#line 1061 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void print_volume_status(char *file , int fd , int ctlrtype , unsigned char *controller_lun ,
                                int volume_number , struct identify_logical_drive_status *vs ,
                                struct identify_controller *id , int tolerance_type ,
                                int certain ) 
{ 
  unsigned int spare_bit ;
  unsigned int i ;
  unsigned int j ;
  unsigned int failed_drive_count ;
  char raid_level[100] ;
  char const   *tmp ;

  {
#line 1070
  if ((int )vs->status == 2) {
#line 1071
    if (debug) {
      {
#line 1072
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"volume %d not configured.\n",
              volume_number);
      }
    }
#line 1073
    return;
  }
#line 1076
  if ((int )vs->status != 0) {
#line 1077
    everything_hunky_dory = (_Bool)0;
  }
  {
#line 1080
  if (tolerance_type == 0) {
#line 1080
    goto case_0;
  }
#line 1082
  if (tolerance_type == 1) {
#line 1082
    goto case_1;
  }
#line 1084
  if (tolerance_type == 2) {
#line 1084
    goto case_2;
  }
#line 1086
  if (tolerance_type == 3) {
#line 1086
    goto case_3;
  }
#line 1088
  if (tolerance_type == 5) {
#line 1088
    goto case_5;
  }
#line 1090
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1080
  sprintf((char */* __restrict  */)(raid_level), (char const   */* __restrict  */)"RAID 0");
  }
#line 1081
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1082
  sprintf((char */* __restrict  */)(raid_level), (char const   */* __restrict  */)"RAID 4");
  }
#line 1083
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1084
  sprintf((char */* __restrict  */)(raid_level), (char const   */* __restrict  */)"RAID 1");
  }
#line 1085
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1086
  sprintf((char */* __restrict  */)(raid_level), (char const   */* __restrict  */)"RAID 5");
  }
#line 1087
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1088
  sprintf((char */* __restrict  */)(raid_level), (char const   */* __restrict  */)"RAID 6");
  }
#line 1089
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1091
  sprintf((char */* __restrict  */)(raid_level), (char const   */* __restrict  */)"(Unknown RAID level (tolerance_type = %d)",
          tolerance_type);
  }
#line 1093
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1096
  if (certain) {
#line 1096
    tmp = "";
  } else {
#line 1096
    tmp = "(?)";
  }
  {
#line 1096
  printf((char const   */* __restrict  */)"%s: (%s) %s Volume %d%s status: ", file,
         smartarray_id[ctlrtype].board_name, raid_level, volume_number, tmp);
  }
#line 1099
  if ((unsigned long )vs->status < sizeof(decode_status) / sizeof(decode_status[0])) {
    {
#line 1100
    printf((char const   */* __restrict  */)"%s. ", decode_status[vs->status]);
    }
  } else {
    {
#line 1102
    printf((char const   */* __restrict  */)"Unknown status %d.", (int )vs->status);
    }
  }
#line 1104
  spare_bit = 0U;
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    if (! ((unsigned long )spare_bit < sizeof(spare_drive_status_msg) / sizeof(spare_drive_status_msg[0]))) {
#line 1104
      goto while_break;
    }
#line 1105
    if (((int )vs->spare_status >> spare_bit) & 1) {
      {
#line 1106
      printf((char const   */* __restrict  */)"  %s.", spare_drive_status_msg[spare_bit]);
      }
    }
#line 1104
    spare_bit ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1115
  show_disk_map((char *)"  Failed drives:", file, fd, id, controller_lun, ctlrtype,
                (unsigned char *)(vs->big_failure_map), vs->drive_failure_map);
#line 1117
  show_disk_map((char *)"  \'Replacement\' drives:", file, fd, id, controller_lun,
                ctlrtype, (unsigned char *)(vs->big_replace_map), vs->replacement_drive_map);
#line 1119
  show_disk_map((char *)"  Drives currently substituted for by spares:", file, fd,
                id, controller_lun, ctlrtype, (unsigned char *)(vs->big_spare_map),
                vs->active_spare_map);
#line 1122
  printf((char const   */* __restrict  */)"\n");
#line 1130
  failed_drive_count = 0U;
#line 1131
  i = 0U;
  }
  {
#line 1131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1131
    if (! ((unsigned long )i < sizeof(vs->big_failure_map) / sizeof(vs->big_failure_map[0]))) {
#line 1131
      goto while_break___0;
    }
#line 1132
    if (vs->big_failure_map[i]) {
#line 1133
      j = 0U;
      {
#line 1133
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1133
        if (! ((unsigned long )j < sizeof(vs->big_failure_map[i]) * 8UL)) {
#line 1133
          goto while_break___1;
        }
#line 1134
        if ((1 << j) & (int )vs->big_failure_map[i]) {
#line 1135
          failed_drive_count ++;
        }
#line 1133
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1131
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1138
  if (failed_drive_count != 0U) {
    {
#line 1139
    everything_hunky_dory = (_Bool)0;
#line 1140
    printf((char const   */* __restrict  */)"    Total of %d failed physical drives detected on this logical drive.\n",
           failed_drive_count);
    }
  }
#line 1144
  return;
}
}
#line 1146 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int lookup_controller(uint32_t board_id ) 
{ 
  int i ;

  {
#line 1150
  i = 0;
  {
#line 1150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1150
    if (! (smartarray_id[i].board_id != 4294967295U)) {
#line 1150
      goto while_break;
    }
#line 1151
    if (smartarray_id[i].board_id == board_id) {
#line 1152
      return (i);
    }
#line 1150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1153
  if (try_unknown_devices) {
#line 1154
    return (i);
  }
#line 1155
  return (-1);
}
}
#line 1158 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void print_bus_status(char *file , int ctlrtype , int bus_number , sense_bus_param *bus_param ) 
{ 
  int alarms ;
  char status[240] ;
  char enclosure_name[17] ;
  char enclosure_sn[41] ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 1168
  if ((int )bus_param->inquiry_valid == 0) {
#line 1168
    return;
  }
  {
#line 1171
  strncpy((char */* __restrict  */)(enclosure_name), (char const   */* __restrict  */)((char *)(bus_param->inquiry.product_id)),
          (size_t )16);
#line 1172
  enclosure_name[16] = (char )'\000';
#line 1173
  i = 15;
  }
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! (i > 0)) {
#line 1173
      goto while_break;
    }
#line 1174
    if ((int )enclosure_name[i] == 32) {
#line 1175
      enclosure_name[i] = (char )'\000';
    } else {
#line 1177
      goto while_break;
    }
#line 1173
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1179
  i = 0;
  {
#line 1179
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1179
    if (! (i < 16)) {
#line 1179
      goto while_break___0;
    }
#line 1180
    if ((int )enclosure_name[i] != 32) {
#line 1181
      goto while_break___0;
    }
#line 1179
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1182
  strncpy((char */* __restrict  */)(enclosure_name), (char const   */* __restrict  */)(enclosure_name + i),
          (size_t )(16 - i));
#line 1187
  strncpy((char */* __restrict  */)(enclosure_sn), (char const   */* __restrict  */)(bus_param->chassis_sn),
          (size_t )40);
#line 1188
  enclosure_sn[41] = (char )'\000';
#line 1189
  i = 39;
  }
  {
#line 1189
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1189
    if (! (i > 0)) {
#line 1189
      goto while_break___1;
    }
#line 1190
    if ((int )enclosure_sn[i] == 32) {
#line 1191
      enclosure_sn[i] = (char )'\000';
    } else {
#line 1193
      goto while_break___1;
    }
#line 1189
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1195
  i = 0;
  {
#line 1195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1195
    if (! (i < 40)) {
#line 1195
      goto while_break___2;
    }
#line 1196
    if ((int )enclosure_sn[i] != 32) {
#line 1197
      goto while_break___2;
    }
#line 1195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1198
  strncpy((char */* __restrict  */)(enclosure_sn), (char const   */* __restrict  */)(enclosure_sn + i),
          (size_t )(40 - i));
#line 1201
  alarms = (int )bus_param->alarm_data.alarm_status & (int )bus_param->alarm_data.valid_alarm_bits;
  }
#line 1203
  if (alarms) {
#line 1204
    everything_hunky_dory = (_Bool)0;
#line 1206
    status[0] = (char )'\000';
#line 1207
    if (alarms & 1) {
      {
#line 1209
      tmp = strlen((char const   *)(status));
      }
#line 1209
      if (tmp > 0UL) {
        {
#line 1209
        strcat((char */* __restrict  */)(status), (char const   */* __restrict  */)", ");
        }
      }
      {
#line 1210
      strcat((char */* __restrict  */)(status), (char const   */* __restrict  */)"Fan failed");
      }
    }
#line 1212
    if (alarms & 2) {
      {
#line 1214
      tmp___0 = strlen((char const   *)(status));
      }
#line 1214
      if (tmp___0 > 0UL) {
        {
#line 1214
        strcat((char */* __restrict  */)(status), (char const   */* __restrict  */)", ");
        }
      }
      {
#line 1215
      strcat((char */* __restrict  */)(status), (char const   */* __restrict  */)"Temperature problem");
      }
    }
#line 1217
    if (alarms & 4) {
      {
#line 1219
      tmp___1 = strlen((char const   *)(status));
      }
#line 1219
      if (tmp___1 > 0UL) {
        {
#line 1219
        strcat((char */* __restrict  */)(status), (char const   */* __restrict  */)", ");
        }
      }
      {
#line 1220
      strcat((char */* __restrict  */)(status), (char const   */* __restrict  */)"Door alert");
      }
    }
#line 1222
    if (alarms & 8) {
      {
#line 1224
      tmp___2 = strlen((char const   *)(status));
      }
#line 1224
      if (tmp___2 > 0UL) {
        {
#line 1224
        strcat((char */* __restrict  */)(status), (char const   */* __restrict  */)", ");
        }
      }
      {
#line 1225
      strcat((char */* __restrict  */)(status), (char const   */* __restrict  */)"Power Supply Unit failed");
      }
    }
    {
#line 1227
    tmp___3 = strlen((char const   *)(status));
    }
#line 1227
    if (tmp___3 == 0UL) {
      {
#line 1228
      sprintf((char */* __restrict  */)(status), (char const   */* __restrict  */)"Unknown problem (alarm value: 0x%X, allowed: 0x%X)",
              (int )bus_param->alarm_data.alarm_status, (int )bus_param->alarm_data.valid_alarm_bits);
      }
    }
  } else {
    {
#line 1231
    strcpy((char */* __restrict  */)(status), (char const   */* __restrict  */)"OK");
    }
  }
  {
#line 1234
  printf((char const   */* __restrict  */)"%s: (%s) Enclosure %s (S/N: %s) on Bus %d, Physical Port %c%c status: %s.\n",
         file, smartarray_id[ctlrtype].board_name, enclosure_name, enclosure_sn, bus_number,
         (int )bus_param->physical_port[0], (int )bus_param->physical_port[1], status);
  }
#line 1238
  return;
}
}
#line 1242 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void setup_sgio(sg_io_hdr_t *sgio , unsigned char *cdb , unsigned char cdblen ,
                       unsigned char *databuffer , unsigned int databufferlen , unsigned char *sensebuffer ,
                       unsigned char sensebufferlen , int direction ) 
{ 


  {
#line 1249
  sgio->interface_id = 'S';
#line 1250
  sgio->dxfer_direction = direction;
#line 1251
  sgio->cmd_len = cdblen;
#line 1252
  sgio->mx_sb_len = sensebufferlen;
#line 1253
  sgio->iovec_count = (unsigned short)0;
#line 1254
  sgio->dxfer_len = databufferlen;
#line 1255
  sgio->dxferp = (void *)databuffer;
#line 1256
  sgio->cmdp = cdb;
#line 1257
  sgio->sbp = sensebuffer;
#line 1258
  sgio->timeout = 268435455U;
#line 1264
  sgio->flags = 0U;
#line 1265
  sgio->pack_id = 0;
#line 1266
  sgio->usr_ptr = (void *)0;
#line 1267
  sgio->status = (unsigned char)0;
#line 1268
  sgio->masked_status = (unsigned char)0;
#line 1269
  sgio->msg_status = (unsigned char)0;
#line 1270
  sgio->sb_len_wr = (unsigned char)0;
#line 1271
  sgio->host_status = (unsigned short)0;
#line 1272
  sgio->driver_status = (unsigned short)0;
#line 1273
  sgio->resid = 0;
#line 1274
  sgio->duration = 0U;
#line 1275
  sgio->info = 0U;
#line 1276
  return;
}
}
#line 1285 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int do_sg_io(int fd , unsigned char *cdb , unsigned char cdblen , unsigned char *buffer ,
                    unsigned int buf_size , int direction ) 
{ 
  int status ;
  sg_io_hdr_t sgio ;
  unsigned char sensebuffer[64] ;

  {
  {
#line 1292
  memset((void *)buffer, 0, (size_t )buf_size);
#line 1293
  memset((void *)(& sgio), 0, sizeof(sgio));
#line 1295
  setup_sgio(& sgio, cdb, cdblen, buffer, buf_size, sensebuffer, (unsigned char )sizeof(sensebuffer),
             direction);
#line 1298
  status = ioctl(fd, 8837UL, & sgio);
  }
#line 1300
  if (status == 0) {
#line 1300
    if ((int )sgio.host_status == 0) {
#line 1300
      if ((int )sgio.driver_status == 0) {
#line 1301
        if ((int )sgio.status == 0) {
#line 1304
          return (0);
        } else
#line 1301
        if ((int )sgio.status == 2) {
#line 1301
          if (((int )sensebuffer[2] & 15) == 0) {
#line 1304
            return (0);
          } else
#line 1301
          if (((int )sensebuffer[2] & 15) == 1) {
#line 1304
            return (0);
          }
        }
#line 1309
        return (-1);
      }
    }
  }
#line 1316
  return (-1);
}
}
#line 1319 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int do_inquiry(int fd , unsigned char inquiry_page , unsigned char *inquiry_buf ,
                      unsigned char buf_size ) 
{ 
  unsigned char cdb[6] ;
  int tmp ;

  {
  {
#line 1324
  memset((void *)inquiry_buf, 0, (size_t )buf_size);
#line 1325
  memset((void *)(cdb), 0, sizeof(cdb));
#line 1326
  cdb[0] = (unsigned char)18;
  }
#line 1327
  if ((int )inquiry_page != 0) {
#line 1328
    cdb[1] = (unsigned char)1;
  } else {
#line 1330
    cdb[1] = (unsigned char)0;
  }
  {
#line 1331
  cdb[2] = inquiry_page;
#line 1332
  cdb[4] = buf_size;
#line 1334
  tmp = do_sg_io(fd, cdb, (unsigned char)6, inquiry_buf, (unsigned int )buf_size,
                 -3);
  }
#line 1334
  return (tmp);
}
}
#line 1337 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int msa1000_passthru_ioctl(int fd , int cmd , void *buffer , int size , unsigned int log_unit ) 
{ 
  unsigned char sensebuffer[64] ;
  int direction ;
  unsigned char cdb[16] ;
  int cdblen ;
  int tmp ;

  {
  {
#line 1340
  direction = -3;
#line 1344
  memset((void *)(cdb), 0, sizeof(cdb));
#line 1345
  memset((void *)(sensebuffer), 0, (size_t )64);
  }
  {
#line 1348
  if (cmd == 18) {
#line 1348
    goto case_18;
  }
#line 1348
  if (cmd == 16) {
#line 1348
    goto case_18;
  }
#line 1357
  if (cmd == 17) {
#line 1357
    goto case_17;
  }
#line 1365
  goto switch_default;
  case_18: /* CIL Label */ 
  case_16: /* CIL Label */ 
  {
#line 1349
  cdb[0] = (unsigned char)38;
#line 1350
  cdb[1] = (unsigned char )log_unit;
#line 1351
  cdb[6] = (unsigned char )cmd;
#line 1352
  set_cdb_buffer_length(cdb, (uint16_t )size);
#line 1353
  direction = -3;
#line 1354
  cdblen = 10;
  }
#line 1355
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 1358
  cdb[0] = (unsigned char)38;
#line 1359
  cdb[6] = (unsigned char )cmd;
#line 1360
  set_cdb_buffer_length(cdb, (uint16_t )size);
#line 1361
  direction = -3;
#line 1362
  cdblen = 10;
  }
#line 1363
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1366
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"msa1000_passthru_ioctl: unknown command %d\n",
          cmd);
  }
#line 1367
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1369
  tmp = do_sg_io(fd, cdb, (unsigned char )cdblen, (unsigned char *)buffer, (unsigned int )size,
                 direction);
  }
#line 1369
  return (tmp);
}
}
#line 1372 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int is_msa1000(int fd ) 
{ 
  int status ;
  char std_inq[256] ;
  char *prod ;
  char *prod2 ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1376
  prod = (char *)"COMPAQ  MSA1000";
#line 1377
  prod2 = (char *)"MSA CONTROLLER";
#line 1379
  status = do_inquiry(fd, (unsigned char)0, (unsigned char *)(std_inq), (unsigned char)255);
  }
#line 1380
  if (status < 0) {
#line 1381
    return (0);
  }
  {
#line 1382
  tmp = strlen((char const   *)prod);
#line 1382
  tmp___0 = strncmp((char const   *)(std_inq + 8), (char const   *)prod, tmp);
  }
#line 1382
  if (tmp___0 == 0) {
#line 1383
    return (1);
  }
  {
#line 1384
  tmp___1 = strstr((char const   *)(std_inq + 8), (char const   *)prod2);
  }
#line 1384
  if ((unsigned long )tmp___1 != (unsigned long )((char *)0)) {
#line 1385
    return (1);
  }
#line 1386
  return (0);
}
}
#line 1389 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int is_smartarray_driver(int fd ) 
{ 
  struct _cciss_pci_info_struct pciinfo ;
  int tmp ;

  {
  {
#line 1404
  memset((void *)(& pciinfo), 0, sizeof(pciinfo));
#line 1405
  tmp = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(66 << 8)) | 1U) | (sizeof(cciss_pci_info_struct ) << 16),
              & pciinfo);
  }
#line 1405
  return (tmp == 0);
}
}
#line 1409 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static struct serial_number_map serial_no_map[2048]  ;
#line 1413 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int ncached_device_nodes  =    0;
#line 1415 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static char *lookup_cached_device_node(unsigned char *serial_no ) 
{ 
  int i ;
  int tmp ;

  {
#line 1418
  i = 0;
  {
#line 1418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1418
    if (! (i < ncached_device_nodes)) {
#line 1418
      goto while_break;
    }
    {
#line 1419
    tmp = memcmp((void const   *)serial_no, (void const   *)(serial_no_map[i].serial_no),
                 (size_t )16);
    }
#line 1419
    if (tmp == 0) {
#line 1420
      return (serial_no_map[i].device_node);
    }
#line 1418
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return ((char *)((void *)0));
}
}
#line 1425 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static char *lookup_cached_serialno(char *filename ) 
{ 
  int i ;
  int tmp ;

  {
#line 1428
  i = 0;
  {
#line 1428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1428
    if (! (i < ncached_device_nodes)) {
#line 1428
      goto while_break;
    }
    {
#line 1429
    tmp = strcmp((char const   *)filename, (char const   *)serial_no_map[i].device_node);
    }
#line 1429
    if (tmp == 0) {
#line 1430
      return (serial_no_map[i].serial_no);
    }
#line 1428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1432
  return ((char *)((void *)0));
}
}
#line 1435 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void cache_device_node(char *device_node , unsigned char *serial_no ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 1438
  i = 0;
  {
#line 1438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1438
    if (! (i < ncached_device_nodes)) {
#line 1438
      goto while_break;
    }
    {
#line 1439
    tmp = memcmp((void const   *)serial_no, (void const   *)(serial_no_map[i].serial_no),
                 (size_t )16);
    }
#line 1439
    if (tmp == 0) {
      {
#line 1439
      tmp___0 = strcmp((char const   *)device_node, (char const   *)serial_no_map[i].device_node);
      }
#line 1439
      if (tmp___0 == 0) {
#line 1442
        return;
      }
    }
#line 1438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1444
  if (i >= 2048) {
#line 1445
    return;
  }
  {
#line 1446
  ncached_device_nodes = i;
#line 1447
  memcpy((void */* __restrict  */)(serial_no_map[i].serial_no), (void const   */* __restrict  */)serial_no,
         (size_t )16);
#line 1448
  tmp___1 = strlen((char const   *)device_node);
#line 1448
  tmp___2 = malloc(tmp___1 + 1UL);
#line 1448
  serial_no_map[i].device_node = (char *)tmp___2;
#line 1449
  strcpy((char */* __restrict  */)serial_no_map[i].device_node, (char const   */* __restrict  */)device_node);
  }
#line 1450
  return;
}
}
#line 1452 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void free_device_node_cache(void) 
{ 
  int i ;

  {
#line 1455
  i = 0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! (i < ncached_device_nodes)) {
#line 1455
      goto while_break;
    }
#line 1456
    if (serial_no_map[i].device_node) {
      {
#line 1457
      free((void *)serial_no_map[i].device_node);
      }
    }
#line 1455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1458
  return;
}
}
#line 1460 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int scsi_device_scandir_filter(struct dirent  const  *d ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1464
  tmp = strlen((char const   *)(d->d_name));
#line 1464
  len = (int )tmp;
#line 1469
  tmp___0 = strncmp((char const   *)(d->d_name), "sd", (size_t )2);
  }
#line 1469
  if (tmp___0 != 0) {
#line 1470
    return (0);
  }
#line 1473
  if ((int )d->d_name[len - 1] <= 57) {
#line 1473
    if ((int )d->d_name[len - 1] >= 48) {
#line 1474
      return (0);
    }
  }
#line 1476
  return (1);
}
}
#line 1481 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static char *unknown_scsi_device  =    (char *)"/dev/???";
#line 1482 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void find_scsi_device_node(unsigned char *unique_volume_id , char **scsi_device_node ) 
{ 
  struct dirent **namelist ;
  int nents ;
  int rc ;
  int i ;
  int fd ;
  unsigned char buffer[64] ;
  char filename[1024] ;
  char *device_node ;
  size_t tmp ;
  void *tmp___0 ;
  char *sn ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1484
  namelist = (struct dirent **)((void *)0);
#line 1492
  device_node = lookup_cached_device_node(unique_volume_id);
  }
#line 1493
  if ((unsigned long )device_node != (unsigned long )((void *)0)) {
    {
#line 1494
    tmp = strlen((char const   *)device_node);
#line 1494
    tmp___0 = malloc(tmp + 1UL);
#line 1494
    *scsi_device_node = (char *)tmp___0;
#line 1495
    strcpy((char */* __restrict  */)*scsi_device_node, (char const   */* __restrict  */)device_node);
    }
#line 1496
    return;
  }
  {
#line 1500
  *scsi_device_node = unknown_scsi_device;
#line 1501
  nents = scandir((char const   */* __restrict  */)"/dev", (struct dirent ***/* __restrict  */)(& namelist),
                  & scsi_device_scandir_filter, (int (*)(struct dirent  const  ** ,
                                                         struct dirent  const  ** ))(& alphasort));
  }
#line 1502
  if (nents < 0) {
#line 1503
    return;
  }
#line 1505
  i = 0;
  {
#line 1505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1505
    if (! (i < nents)) {
#line 1505
      goto while_break;
    }
    {
#line 1507
    snprintf((char */* __restrict  */)(filename), (size_t )1023, (char const   */* __restrict  */)"/dev/%s",
             (*(namelist + i))->d_name);
#line 1510
    sn = lookup_cached_serialno(filename);
    }
#line 1511
    if ((unsigned long )sn != (unsigned long )((void *)0)) {
      {
#line 1513
      tmp___3 = memcmp((void const   *)sn, (void const   *)unique_volume_id, (size_t )16);
      }
#line 1513
      if (tmp___3 == 0) {
        {
#line 1514
        tmp___1 = strlen((char const   *)(filename));
#line 1514
        tmp___2 = malloc(tmp___1 + 1UL);
#line 1514
        *scsi_device_node = (char *)tmp___2;
#line 1515
        strcpy((char */* __restrict  */)*scsi_device_node, (char const   */* __restrict  */)(filename));
        }
#line 1516
        goto while_break;
      } else {
#line 1518
        goto __Cont;
      }
    }
    {
#line 1522
    fd = open((char const   *)(filename), 2);
    }
#line 1523
    if (fd < 0) {
#line 1524
      goto __Cont;
    }
    {
#line 1526
    rc = do_inquiry(fd, (unsigned char)131, buffer, (unsigned char )sizeof(buffer));
    }
#line 1527
    if (rc < 0) {
#line 1528
      goto next;
    }
    {
#line 1531
    cache_device_node(filename, & buffer[8]);
#line 1534
    tmp___6 = memcmp((void const   *)(& buffer[8]), (void const   *)unique_volume_id,
                     (size_t )16);
    }
#line 1534
    if (tmp___6 == 0) {
      {
#line 1535
      tmp___4 = strlen((char const   *)(filename));
#line 1535
      tmp___5 = malloc(tmp___4 + 1UL);
#line 1535
      *scsi_device_node = (char *)tmp___5;
#line 1536
      strcpy((char */* __restrict  */)*scsi_device_node, (char const   */* __restrict  */)(filename));
#line 1537
      close(fd);
      }
#line 1538
      goto while_break;
    }
    next: 
    {
#line 1541
    close(fd);
    }
    __Cont: /* CIL Label */ 
#line 1505
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1545
  i = 0;
  {
#line 1545
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1545
    if (! (i < nents)) {
#line 1545
      goto while_break___0;
    }
    {
#line 1546
    free((void *)*(namelist + i));
#line 1545
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1547
  free((void *)namelist);
  }
#line 1549
  return;
}
}
#line 1552 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void msa1000_logical_drive_status(char *file , int fd , unsigned int logical_drive ,
                                         struct identify_controller *id ) 
{ 
  int rc ;
  int ctlrtype ;
  struct identify_logical_drive_status ldstatus ;
  struct identify_logical_drive drive_id ;
  int tolerance_type ;
  char *scsi_device_node ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 1558
  tolerance_type = -1;
#line 1561
  memset((void *)(& drive_id), 0, sizeof(drive_id));
#line 1562
  rc = msa1000_passthru_ioctl(fd, 16, (void *)(& drive_id), (int )sizeof(drive_id),
                              logical_drive);
  }
#line 1564
  if (rc == 0) {
#line 1565
    tolerance_type = (int )drive_id.tolerance_type;
  }
  {
#line 1567
  memset((void *)(& ldstatus), 0, sizeof(ldstatus));
#line 1568
  rc = msa1000_passthru_ioctl(fd, 18, (void *)(& ldstatus), (int )sizeof(ldstatus),
                              logical_drive);
  }
#line 1570
  if (rc < 0) {
    {
#line 1571
    tmp = __errno_location();
#line 1571
    tmp___0 = strerror(*tmp);
#line 1571
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ioctl: logical drive: %d %s\n",
            progname, file, logical_drive, tmp___0);
    }
#line 1573
    return;
  }
  {
#line 1575
  ctlrtype = lookup_controller(id->board_id);
  }
#line 1576
  if (ctlrtype == -1) {
    {
#line 1577
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: Unknown controller, board_id = 0x%08x\n",
            progname, file, id->board_id);
    }
#line 1579
    return;
  }
  {
#line 1581
  find_scsi_device_node(drive_id.unique_volume_id, & scsi_device_node);
#line 1582
  print_volume_status(scsi_device_node, fd, ctlrtype, (unsigned char *)((void *)0),
                      (int )logical_drive, & ldstatus, id, tolerance_type, 1);
  }
#line 1584
  if ((unsigned long )scsi_device_node != (unsigned long )unknown_scsi_device) {
    {
#line 1585
    free((void *)scsi_device_node);
    }
  }
#line 1586
  return;
}
}
#line 1593 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int all_same(unsigned char *buf , unsigned int bufsize , unsigned char value ) 
{ 
  unsigned int i ;
  int rc ;

  {
#line 1598
  rc = 0;
#line 1599
  i = 0U;
  {
#line 1599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1599
    if (! (i < bufsize)) {
#line 1599
      goto while_break;
    }
#line 1600
    if ((int )*(buf + i) != (int )value) {
#line 1601
      return (0);
    }
#line 1599
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1603
  return (1);
}
}
#line 1606 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int do_cciss_inquiry(char *file , int fd , unsigned char *lun , unsigned char inquiry_page ,
                            unsigned char *inquiry_buf , unsigned char buf_size ) 
{ 
  IOCTL_Command_struct cmd ;
  unsigned char cdb[16] ;
  int status ;
  int tmp ;

  {
  {
#line 1616
  memset((void *)(& cmd), 0, sizeof(cmd));
#line 1617
  memset((void *)(cdb), 0, sizeof(cdb));
#line 1618
  cdb[0] = (unsigned char)18;
  }
#line 1619
  if (inquiry_page) {
#line 1619
    cdb[1] = (unsigned char)1;
  } else {
#line 1619
    cdb[1] = (unsigned char)0;
  }
  {
#line 1620
  cdb[2] = inquiry_page;
#line 1621
  cdb[4] = buf_size;
#line 1623
  setup_for_ioctl(& cmd, lun, cdb, 6, 0, inquiry_buf, (int )buf_size);
  }
#line 1625
  if (debug) {
    {
#line 1626
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getting inquiry page 0x%02x from LUN:0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
            (int )inquiry_page, (int )*(lun + 0), (int )*(lun + 1), (int )*(lun + 2),
            (int )*(lun + 3), (int )*(lun + 4), (int )*(lun + 5), (int )*(lun + 6),
            (int )*(lun + 7));
    }
  }
  {
#line 1631
  status = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(66 << 8)) | 11U) | (sizeof(IOCTL_Command_struct ) << 16),
                 & cmd);
#line 1632
  tmp = check_ioctl_results(file, (char *)"INQUIRY", status, & cmd, -1);
  }
#line 1632
  if (tmp != 0) {
#line 1632
    return (-1);
  }
#line 1633
  return (0);
}
}
#line 1636 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void append_internal_controller_lunid_to_extended_report_luns(unsigned char *data ,
                                                                     int *lun_count ) 
{ 
  int offset ;

  {
  {
#line 1639
  offset = 8 + *lun_count * 24;
#line 1641
  memset((void *)(data + offset), 0, (size_t )24);
#line 1642
  *(data + ((offset + 24) - 1)) = (unsigned char)12;
#line 1643
  (*lun_count) ++;
  }
#line 1644
  return;
}
}
#line 1646 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static unsigned char get_device_type(unsigned char *extended_report_luns_entry ) 
{ 


  {
#line 1648
  return (*(extended_report_luns_entry + 23));
}
}
#line 1713 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int init_cciss_to_bmic(char *file , int fd ) 
{ 
  struct identify_logical_drive id_logical_drive_data ;
  uint64_t lunlist[1025] ;
  int lun_count ;
  unsigned char physlunlist[24608] ;
  unsigned char buf[256] ;
  struct bmic_addr_t missed_drive[1025] ;
  int nmissed ;
  int nguessed ;
  int rc ;
  int i ;
  int j ;
  int k ;
  int m ;
  int ctlrtype ;
  unsigned char *x ;
  struct identify_controller id_ctlr_data ;
  int max_possible_drives ;
  int byteoffset ;
  unsigned char *this_lun_data ;
  unsigned char tmp ;
  int tmp___0 ;
  int m___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1724
  lun_count = 1024;
#line 1729
  nmissed = 0;
#line 1730
  nguessed = 0;
#line 1735
  memset((void *)(& cciss_to_bmic), 0, sizeof(cciss_to_bmic));
#line 1736
  memset((void *)(lunlist), 0, sizeof(lunlist));
#line 1737
  memset((void *)(physlunlist), 0, sizeof(physlunlist));
#line 1738
  memset((void *)(missed_drive), 0, sizeof(missed_drive));
#line 1741
  rc = do_report_luns(file, fd, & lun_count, (unsigned char *)(lunlist), 0, 0);
  }
#line 1742
  if (rc != 0) {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"do_report_luns(logical) failed.\n");
#line 1744
    everything_hunky_dory = (_Bool)0;
    }
#line 1745
    return (-1);
  }
#line 1748
  cciss_to_bmic.naddrs = lun_count;
#line 1751
  i = 0;
  {
#line 1751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1751
    if (! (i < cciss_to_bmic.naddrs)) {
#line 1751
      goto while_break;
    }
    {
#line 1752
    memcpy((void */* __restrict  */)(cciss_to_bmic.addr[i].logical_lun), (void const   */* __restrict  */)(& lunlist[i + 1]),
           (size_t )8);
    }
#line 1754
    if (debug) {
      {
#line 1755
      x = (unsigned char *)(& lunlist[i + 1]);
#line 1756
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d: ",
              i);
#line 1757
      j = 0;
      }
      {
#line 1757
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1757
        if (! (j < 8)) {
#line 1757
          goto while_break___0;
        }
        {
#line 1758
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
                (int )*(x + j));
#line 1757
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1759
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 1761
    memset((void *)(buf), 0, sizeof(buf));
#line 1764
    rc = do_cciss_inquiry(file, fd, cciss_to_bmic.addr[i].logical_lun, (unsigned char)131,
                          buf, (unsigned char)255);
    }
#line 1765
    if (rc != 0) {
      {
#line 1766
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"logical lun %d inquiry 0x83 failed, rc = %d.\n",
              i, rc);
      }
#line 1767
      goto __Cont;
    }
#line 1769
    if ((int )buf[7] != 16) {
      {
#line 1770
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: buf[7] is not 16!  Very unexpected...\n",
              progname);
      }
    }
    {
#line 1772
    memcpy((void */* __restrict  */)(& cciss_to_bmic.addr[i].inq_pg_0x83_data[0]),
           (void const   */* __restrict  */)(& buf[8]), (size_t )16);
    }
    __Cont: /* CIL Label */ 
#line 1751
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1776
  lun_count = 1024;
#line 1777
  rc = do_report_luns(file, fd, & lun_count, physlunlist, 1, 1 << 1);
  }
#line 1779
  if (rc != 0) {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: do_report_physical failed.\n",
            progname);
#line 1781
    everything_hunky_dory = (_Bool)0;
    }
#line 1782
    return (-1);
  }
  {
#line 1786
  append_internal_controller_lunid_to_extended_report_luns(physlunlist, & lun_count);
#line 1788
  memset((void *)(controller_lun_list[0]), 0, (size_t )8);
#line 1789
  num_controllers = 0;
#line 1791
  i = 0;
  }
  {
#line 1791
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1791
    if (! (i < lun_count)) {
#line 1791
      goto while_break___1;
    }
    {
#line 1794
    max_possible_drives = 0;
#line 1795
    byteoffset = 8 + i * 24;
#line 1797
    this_lun_data = & physlunlist[byteoffset];
#line 1800
    tmp = get_device_type(this_lun_data);
    }
#line 1800
    if ((int )tmp != 12) {
#line 1801
      if (debug) {
        {
#line 1802
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not a RAID controller, skipping.\n");
        }
      }
#line 1803
      goto __Cont___0;
    }
    {
#line 1809
    memset((void *)(& id_ctlr_data), 0, sizeof(id_ctlr_data));
#line 1810
    rc = id_ctlr_fd(file, fd, this_lun_data, & id_ctlr_data);
    }
#line 1811
    if (rc != 0) {
      {
#line 1812
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: do_id_ctlr on lun %d failed.\n",
              progname, i);
      }
#line 1813
      goto __Cont___0;
    }
#line 1820
    if ((int )id_ctlr_data.redund_ctlr_modes_support & 1) {
#line 1820
      goto _L;
    } else
#line 1820
    if ((int )id_ctlr_data.redund_ctlr_modes_support & 2) {
      _L: /* CIL Label */ 
#line 1820
      if (((int )id_ctlr_data.curr_redund_ctlr_mode & 3) != 0) {
#line 1820
        if (! ((int )id_ctlr_data.redund_ctlr_status & 4)) {
#line 1824
          if (debug) {
            {
#line 1825
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSkipping standby/secondary controller.\n");
            }
          }
#line 1826
          goto __Cont___0;
        }
      }
    }
    {
#line 1830
    memcpy((void */* __restrict  */)(controller_lun_list[num_controllers]), (void const   */* __restrict  */)this_lun_data,
           (size_t )8);
#line 1832
    busses_on_this_ctlr[num_controllers] = (int )id_ctlr_data.scsi_chip_count;
#line 1839
    ctlrtype = lookup_controller(id_ctlr_data.board_id);
    }
#line 1840
    if (ctlrtype == -1) {
#line 1841
      busses_on_this_ctlr[num_controllers] = 16;
    } else
#line 1840
    if (smartarray_id[ctlrtype].supports_sas) {
#line 1841
      busses_on_this_ctlr[num_controllers] = 16;
    }
#line 1843
    num_controllers ++;
#line 1845
    max_possible_drives = (int )id_ctlr_data.usMaxLogicalUnits;
#line 1846
    if (debug) {
      {
#line 1847
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: max possible drives is %d\n\n",
              progname, max_possible_drives);
      }
    }
#line 1850
    if (max_possible_drives > 512) {
      {
#line 1851
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: max possible drives reportedly %d > 512, very unexpected, exiting.\n",
              progname, max_possible_drives);
#line 1854
      exit(1);
      }
    }
#line 1857
    if (max_possible_drives == 0) {
#line 1858
      if (debug) {
        {
#line 1859
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"max_possible drives was zero, adjusting to 32.\n");
        }
      }
#line 1860
      max_possible_drives = 32;
    }
#line 1874
    j = 0;
    {
#line 1874
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1874
      if (! (j < max_possible_drives)) {
#line 1874
        goto while_break___2;
      }
      {
#line 1877
      memset((void *)(& id_logical_drive_data), 0, sizeof(id_logical_drive_data));
#line 1878
      rc = do_bmic_id_logical_drive(file, fd, this_lun_data, j, (unsigned char *)(& id_logical_drive_data));
      }
#line 1880
      if (rc != 0) {
        {
#line 1881
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: do_bmic_id_logical_drive failed for drive %d\n",
                progname, j);
        }
#line 1883
        goto __Cont___1;
      }
      {
#line 1887
      tmp___0 = all_same((unsigned char *)(& id_logical_drive_data), (unsigned int )sizeof(id_logical_drive_data),
                         (unsigned char)0);
      }
#line 1887
      if (tmp___0) {
#line 1889
        if (debug) {
          {
#line 1890
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"id_logical_drive_data is all zeroes, means there is no logical drive %d\n",
                  j);
          }
        }
#line 1892
        goto __Cont___1;
      }
#line 1895
      if (debug) {
        {
#line 1896
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Logical drive 0x%02x%02x%02x%02x%02x%02x%02x%02x:%d has unique id: 0x",
                (int )*(this_lun_data + 0), (int )*(this_lun_data + 1), (int )*(this_lun_data + 2),
                (int )*(this_lun_data + 3), (int )*(this_lun_data + 4), (int )*(this_lun_data + 5),
                (int )*(this_lun_data + 6), (int )*(this_lun_data + 7), j);
#line 1901
        m = 0;
        }
        {
#line 1901
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1901
          if (! (m < 16)) {
#line 1901
            goto while_break___3;
          }
          {
#line 1902
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
                  (int )id_logical_drive_data.unique_volume_id[m]);
#line 1901
          m ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1903
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSearching....\n");
        }
      }
#line 1907
      k = 0;
      {
#line 1907
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1907
        if (! (k < cciss_to_bmic.naddrs)) {
#line 1907
          goto while_break___4;
        }
#line 1913
        if (debug) {
          {
#line 1914
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    ");
#line 1915
          m___0 = 0;
          }
          {
#line 1915
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1915
            if (! (m___0 < 16)) {
#line 1915
              goto while_break___5;
            }
            {
#line 1916
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
                    (int )cciss_to_bmic.addr[k].inq_pg_0x83_data[m___0]);
#line 1915
            m___0 ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 1917
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
        {
#line 1920
        tmp___1 = memcmp((void const   *)(id_logical_drive_data.unique_volume_id),
                         (void const   *)(cciss_to_bmic.addr[k].inq_pg_0x83_data),
                         (size_t )16);
        }
#line 1920
        if (tmp___1 == 0) {
#line 1923
          if (debug) {
            {
#line 1924
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found!, k = %d\n",
                    k);
            }
          }
          {
#line 1925
          cciss_to_bmic.addr[k].bmic_drive_number = (unsigned short )j;
#line 1926
          memcpy((void */* __restrict  */)(cciss_to_bmic.addr[k].controller_lun),
                 (void const   */* __restrict  */)this_lun_data, (size_t )8);
#line 1928
          memcpy((void */* __restrict  */)(cciss_to_bmic.addr[k].bmic_id_ctlr_data),
                 (void const   */* __restrict  */)(id_logical_drive_data.unique_volume_id),
                 (size_t )16);
#line 1930
          cciss_to_bmic.addr[k].tolerance_type = (int )id_logical_drive_data.tolerance_type;
#line 1932
          cciss_to_bmic.addr[k].certain = 1;
          }
#line 1933
          goto while_break___4;
        }
#line 1907
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1936
      if (k == cciss_to_bmic.naddrs) {
#line 1937
        if (debug) {
          {
#line 1938
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Didn\'t find %d here.  Adding to missed drive list as bmic drive %d\n",
                  i, j);
          }
        }
        {
#line 1939
        memcpy((void */* __restrict  */)(missed_drive[nmissed].controller_lun), (void const   */* __restrict  */)this_lun_data,
               (size_t )8);
#line 1941
        missed_drive[nmissed].bmic_drive_number = (unsigned short )j;
#line 1942
        missed_drive[nmissed].tolerance_type = (int )id_logical_drive_data.tolerance_type;
#line 1943
        nmissed ++;
        }
      }
      __Cont___1: /* CIL Label */ 
#line 1874
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1955
    m = 0;
    {
#line 1955
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1955
      if (! (m < nmissed)) {
#line 1955
        goto while_break___6;
      }
#line 1956
      k = 0;
      {
#line 1956
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1956
        if (! (k < cciss_to_bmic.naddrs)) {
#line 1956
          goto while_break___7;
        }
        {
#line 1957
        tmp___2 = all_same(cciss_to_bmic.addr[k].bmic_id_ctlr_data, 16U, (unsigned char)0);
        }
#line 1957
        if (! tmp___2) {
#line 1958
          goto __Cont___2;
        }
#line 1960
        if (debug) {
          {
#line 1961
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mapping logical drive %d to bmic drive %d(%d)\n",
                  k, (int )missed_drive[m].bmic_drive_number, m);
          }
        }
        {
#line 1963
        memcpy((void */* __restrict  */)(cciss_to_bmic.addr[k].controller_lun), (void const   */* __restrict  */)(missed_drive[m].controller_lun),
               (size_t )8);
#line 1965
        cciss_to_bmic.addr[k].bmic_drive_number = missed_drive[m].bmic_drive_number;
#line 1967
        cciss_to_bmic.addr[k].tolerance_type = missed_drive[m].tolerance_type;
#line 1969
        memset((void *)(cciss_to_bmic.addr[k].bmic_id_ctlr_data), 255, (size_t )16);
#line 1971
        cciss_to_bmic.addr[k].certain = 0;
#line 1972
        nguessed ++;
        }
#line 1973
        goto while_break___7;
        __Cont___2: /* CIL Label */ 
#line 1956
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1955
      m ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 1791
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1985
  if (debug) {
    {
#line 1987
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n\n");
#line 1988
    i = 0;
    }
    {
#line 1988
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1988
      if (! (i < cciss_to_bmic.naddrs)) {
#line 1988
        goto while_break___8;
      }
      {
#line 1989
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"0x%02x%02x%02x%02x%02x%02x%02x%02x 0x%02x%02x%02x%02x%02x%02x%02x%02x %d\n",
              (int )cciss_to_bmic.addr[i].logical_lun[0], (int )cciss_to_bmic.addr[i].logical_lun[1],
              (int )cciss_to_bmic.addr[i].logical_lun[2], (int )cciss_to_bmic.addr[i].logical_lun[3],
              (int )cciss_to_bmic.addr[i].logical_lun[4], (int )cciss_to_bmic.addr[i].logical_lun[5],
              (int )cciss_to_bmic.addr[i].logical_lun[6], (int )cciss_to_bmic.addr[i].logical_lun[7],
              (int )cciss_to_bmic.addr[i].controller_lun[0], (int )cciss_to_bmic.addr[i].controller_lun[1],
              (int )cciss_to_bmic.addr[i].controller_lun[2], (int )cciss_to_bmic.addr[i].controller_lun[3],
              (int )cciss_to_bmic.addr[i].controller_lun[4], (int )cciss_to_bmic.addr[i].controller_lun[5],
              (int )cciss_to_bmic.addr[i].controller_lun[6], (int )cciss_to_bmic.addr[i].controller_lun[7],
              (int )cciss_to_bmic.addr[i].bmic_drive_number);
#line 1988
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 2009
  return (0);
}
}
#line 2012 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void setup_sense_bus_params_cmd(IOCTL_Command_struct *c , unsigned char *lunaddr ,
                                       unsigned char bus , sense_bus_param *bus_param ) 
{ 


  {
  {
#line 2016
  memset((void *)c, 0, sizeof(*c));
#line 2017
  memcpy((void */* __restrict  */)(& c->LUN_info), (void const   */* __restrict  */)lunaddr,
         (size_t )8);
#line 2018
  c->Request.CDBLen = (__u8 )10;
#line 2019
  c->Request.Type.Type = (__u8 )0;
#line 2020
  c->Request.Type.Attribute = (__u8 )4;
#line 2021
  c->Request.Type.Direction = (__u8 )2;
#line 2022
  c->Request.Timeout = (__u16 )0;
#line 2023
  c->Request.CDB[0] = (__u8 )38;
#line 2024
  c->Request.CDB[1] = (__u8 )0;
#line 2025
  c->Request.CDB[5] = bus;
#line 2026
  c->Request.CDB[6] = (__u8 )101;
#line 2027
  c->buf_size = (__u16 )sizeof(*bus_param);
#line 2028
  set_cdb_buffer_length(c->Request.CDB, c->buf_size);
#line 2029
  c->buf = (unsigned char *)bus_param;
  }
#line 2030
  return;
}
}
#line 2032 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void print_error_info(IOCTL_Command_struct *c ) 
{ 
  int i ;

  {
  {
#line 2035
  printf((char const   */* __restrict  */)"Error info:\n");
#line 2036
  printf((char const   */* __restrict  */)"CDB = ");
#line 2037
  i = 0;
  }
  {
#line 2037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2037
    if (! (i < 16)) {
#line 2037
      goto while_break;
    }
    {
#line 2038
    printf((char const   */* __restrict  */)"%02x ", (int )c->Request.CDB[i]);
#line 2037
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2039
  printf((char const   */* __restrict  */)"\n");
#line 2040
  printf((char const   */* __restrict  */)"CommandStatus = %d\n", (int )c->error_info.CommandStatus);
#line 2041
  printf((char const   */* __restrict  */)"ScsiStatus = %d\n", (int )c->error_info.ScsiStatus);
#line 2042
  printf((char const   */* __restrict  */)"SenseLen = %d\n", (int )c->error_info.SenseLen);
#line 2043
  printf((char const   */* __restrict  */)"ResidualCnt = %d\n", c->error_info.ResidualCnt);
#line 2044
  printf((char const   */* __restrict  */)"SenseInfo = ");
  }
#line 2045
  if ((int )c->error_info.SenseLen > 32) {
#line 2046
    c->error_info.SenseLen = (__u8 )32;
  }
#line 2047
  i = 0;
  {
#line 2047
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2047
    if (! (i < (int )c->error_info.SenseLen)) {
#line 2047
      goto while_break___0;
    }
    {
#line 2048
    printf((char const   */* __restrict  */)"%02x ", (int )c->error_info.SenseInfo[i]);
#line 2047
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2049
  printf((char const   */* __restrict  */)"\n\n");
  }
#line 2050
  return;
}
}
#line 2052 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int do_sense_bus_parameters(char *file , int fd , unsigned char *lunaddr , int ctlr ,
                            unsigned char bus , sense_bus_param *bus_param ) 
{ 
  IOCTL_Command_struct c ;
  int status ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 2058
  setup_sense_bus_params_cmd(& c, lunaddr, bus, bus_param);
  }
#line 2059
  if (debug) {
    {
#line 2060
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getting bus status for bus %d\n",
            (int )bus);
    }
  }
  {
#line 2062
  status = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(66 << 8)) | 11U) | (sizeof(IOCTL_Command_struct ) << 16),
                 & c);
  }
#line 2064
  if (status != 0) {
    {
#line 2065
    tmp = __errno_location();
#line 2065
    tmp___0 = strerror(*tmp);
#line 2065
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ioctl: controller: %d bus: %d %s\n",
            progname, file, ctlr, (int )bus, tmp___0);
#line 2068
    everything_hunky_dory = (_Bool)0;
    }
#line 2069
    return (-1);
  }
#line 2073
  if ((int )c.error_info.CommandStatus == 4) {
#line 2074
    return (-1);
  }
#line 2076
  if ((int )c.error_info.CommandStatus == 1) {
    {
#line 2077
    print_error_info(& c);
    }
  }
#line 2079
  if ((int )c.error_info.CommandStatus != 0) {
    {
#line 2080
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error getting status for %s controller: %d bus: %d: Commandstatus is %d\n",
            file, ctlr, (int )bus, (int )c.error_info.CommandStatus);
#line 2083
    everything_hunky_dory = (_Bool)0;
    }
#line 2084
    return (-1);
  }
#line 2086
  if (debug) {
    {
#line 2087
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Status for controller %d bus %d seems to be gettable.\n",
            ctlr, (int )bus);
    }
  }
#line 2089
  return (0);
}
}
#line 2092 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void check_fan_power_temp(char *file , int ctlrtype , int fd , int num_controllers___0 ) 
{ 
  int i ;
  int j ;
  sense_bus_param bus_param ;
  int tmp ;

  {
#line 2097
  i = 0;
  {
#line 2097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2097
    if (! (i < num_controllers___0)) {
#line 2097
      goto while_break;
    }
#line 2098
    j = 0;
    {
#line 2098
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2098
      if (! (j < busses_on_this_ctlr[i])) {
#line 2098
        goto while_break___0;
      }
      {
#line 2100
      memset((void *)(& bus_param), 0, sizeof(bus_param));
#line 2101
      tmp = do_sense_bus_parameters(file, fd, controller_lun_list[i], i, (unsigned char )j,
                                    & bus_param);
      }
#line 2101
      if (tmp != 0) {
#line 2103
        goto __Cont;
      }
      {
#line 2104
      print_bus_status(file, ctlrtype, j, & bus_param);
      }
      __Cont: /* CIL Label */ 
#line 2098
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2097
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2107
  return;
}
}
#line 2109 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static char *cache_disable_info[20]  = 
#line 2109
  {      (char *)"Temporary disable condition. Data was found in posted\nwrite memory, but the configuration signature in the\nposted write memory does not match the one stored in\nthe configuration data stored on the drives.  Therefore\nthe data cannot be written to the drives.  This disable\ncondition is also reported if the controller firmware is\nreplaced with one that is incompatible with the format of\ndata found in the posted write memory.\n\n",      (char *)"Temporary disable condition. Posted write operations have\nbeen disabled due to the fact that less than 75% of the\nbattery packs are at the sufficient voltage level.\n",      (char *)"Temporary disable condition. Posted write operations were\ndisabled by the user.\n",      (char *)"Temporary disable condition. The adapter does not currently\nhave sufficient resources to perform posted write operations.\n(e.g. drive rebuild operations are occurring, etc.)\n", 
        (char *)"Temporary disable condition:  The array accelerator board is\nnot attached.\n",      (char *)"Temporary disable condition:  The array accelerator memory is\nin use by an Expand operation that is queued up or in progress.\n",      (char *)"Temporary disable condition:  The array accelerator memory is\nin use by a Snapshot operation that is queued up or in progress.\n",      (char *)"Temporary disable condition: The batteries on the redundant\ncontroller are not at a sufficient charge level to support\nreliable posting of write data.\n", 
        (char *)"Temporary disable condition:  A cache size mismatch exists\nbetween the two controllers in a redundant environment.\n",      (char *)"Temporary disable condition:  A cache failure has been detected\nby the other controller in a redundant environment.\n",      (char *)"Temporary disable condition:  The cache has been disabled to\npenalize the user who has an RAID ADG volume configured but the\nADG Enabler Dongle is broken or missing.\n",      (char *)"Temporary disable condition: The cache has been disabled because\nSA 6400 EM Controller is configured as boot controller. This is\nnot a recommended configuration.  User is advised to migrate the\nboot volume to SA 6400 Controller and configure it as boot\ncontroller.\n", 
        (char *)"Temporary disable condition: The posted write cache has been\ndisabled in a flash-backed write cache module because the\ncapacitor charge is low.\n",      (char *)"Temporary disable condition: The posted write cache has been\ndisabled in a flash-backed write cache module because its\nflash memory is being erased.\n",      (char *)"",      (char *)"", 
        (char *)"Permanent disable condition. Data was found at reset\ninitialization in the posted write memory, however, the\nmirror data compare test failed resulting in that data being\nmarked as invalid. This is a possible data loss circumstance.\nThis disable condition only occurs on controllers with\nmirrored cache RAM (very very old controllers).  You won\342\200\231t see\nthis with any remotely recent controller.\n",      (char *)"Permanent disable condition.  Unrecoverable error reading data\nfrom the cache.  For mirrored caches, (very very old controllers)\nthis means that read parity errors were detected on both sides\nof the mirror.  For ECC protected caches, (non-ancient hardware)\nthis means an unrecoverable ECC read error occurred.  This is a\ndefinite data loss circumstance.\n",      (char *)"Permanent disable condition. Data could not be written to the\ncache memory.  This typically means that a parity error was\ndetected while writing data to the cache.  This could be caused\nby such things as an incomplete connection between the cache card\nand the controller.  This is not a data loss circumstance.\n",      (char *)"Permanent disable condition:  Configuration changes were made but\ncache configuration was not updated. (Note: This condition will\nnot occur except on very very old controllers.)\n"};
#line 2204 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void decode_cache_disable_code(unsigned short disable_code ) 
{ 
  int tmp ;

  {
#line 2209
  if ((unsigned long )disable_code >= sizeof(cache_disable_info) / sizeof(cache_disable_info[0])) {
    {
#line 2210
    printf((char const   */* __restrict  */)"           Unknown cache disable code: %d\n",
           (int )disable_code);
    }
#line 2212
    return;
  }
  {
#line 2215
  tmp = strcmp((char const   *)cache_disable_info[disable_code], "");
  }
#line 2215
  if (tmp == 0) {
    {
#line 2216
    printf((char const   */* __restrict  */)"           Unknown cache disable code: %d\n",
           (int )disable_code);
    }
#line 2218
    return;
  }
  {
#line 2221
  printf((char const   */* __restrict  */)"           %s", cache_disable_info[disable_code]);
  }
#line 2222
  return;
}
}
#line 2224 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void print_cache_config_status(struct bmic_cache_configuration *cache_config ,
                                      uint32_t cache_config_status_bit , char *message ) 
{ 


  {
#line 2228
  if (! (cache_config->status & cache_config_status_bit)) {
#line 2229
    return;
  }
  {
#line 2230
  printf((char const   */* __restrict  */)"   %s\n", message);
  }
#line 2233
  if (cache_config_status_bit & (unsigned int )((1 << 1) | (1 << 2))) {
    {
#line 2235
    decode_cache_disable_code(cache_config->disable_code);
    }
  }
#line 2236
  return;
}
}
#line 2238 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void check_one_nonvolatile_cache_status(char *file , int ctlrtype , int instance ,
                                               struct bmic_cache_configuration *cache_config ) 
{ 
  uint32_t trouble ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 2241
  trouble = (uint32_t )(((((((((1 << 1) | (1 << 2)) | (1 << 4)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 14)) | (1 << 15));
#line 2258
  if (! (trouble & cache_config->status)) {
#line 2259
    if (! verbose) {
#line 2260
      return;
    }
  } else {
#line 2262
    everything_hunky_dory = (_Bool)0;
  }
  {
#line 2265
  printf((char const   */* __restrict  */)"%s(%s:%d): Non-Volatile Cache status:\n",
         file, smartarray_id[ctlrtype].board_name, instance);
  }
#line 2269
  if ((int )cache_config->disable_flag == 0) {
#line 2269
    tmp = "Yes";
  } else {
#line 2269
    tmp = "No";
  }
  {
#line 2269
  printf((char const   */* __restrict  */)"%35s: %s\n", "Cache configured", tmp);
  }
#line 2271
  if (cache_config->disable_flag) {
#line 2272
    return;
  }
  {
#line 2274
  printf((char const   */* __restrict  */)"%35s: %hu MiB\n", "Read cache memory",
         (int )cache_config->mem_for_read_cache);
#line 2275
  printf((char const   */* __restrict  */)"%35s: %hu MiB\n", "Write cache memory",
         (int )cache_config->mem_for_write_cache);
  }
#line 2276
  if (cache_config->status & 1U) {
#line 2276
    tmp___0 = "Yes";
  } else {
#line 2276
    tmp___0 = "No";
  }
  {
#line 2276
  printf((char const   */* __restrict  */)"%35s: %s\n", "Write cache enabled", tmp___0);
#line 2278
  print_cache_config_status(cache_config, (uint32_t )(1 << 1), (char *)"Write cache temporarily disabled");
#line 2281
  print_cache_config_status(cache_config, (uint32_t )(1 << 2), (char *)"Write Cache permanently disabled");
#line 2284
  print_cache_config_status(cache_config, (uint32_t )(1 << 4), (char *)"Possible data loss on last reset");
#line 2287
  print_cache_config_status(cache_config, (uint32_t )(1 << 8), (char *)"Cache contains unflushed data:");
#line 2290
  print_cache_config_status(cache_config, (uint32_t )(1 << 9), (char *)"Cache dirty limit reached");
#line 2293
  print_cache_config_status(cache_config, (uint32_t )(1 << 10), (char *)"Excessive ECC errors detected:");
#line 2296
  print_cache_config_status(cache_config, (uint32_t )(1 << 11), (char *)"Non power related data loss");
#line 2299
  print_cache_config_status(cache_config, (uint32_t )(1 << 12), (char *)"Auto-reconfigured on last reset");
#line 2302
  print_cache_config_status(cache_config, (uint32_t )(1 << 13), (char *)"Redundant controller data flushed on reset");
#line 2305
  print_cache_config_status(cache_config, (uint32_t )(1 << 14), (char *)"HW problem with battery enable");
#line 2308
  print_cache_config_status(cache_config, (uint32_t )(1 << 15), (char *)"CPLD battery backed write cache incompatibility");
#line 2311
  print_cache_config_status(cache_config, (uint32_t )(1 << 16), (char *)"Flash backed cache present");
#line 2314
  print_cache_config_status(cache_config, (uint32_t )(1 << 30), (char *)"Permanent disable condition detected");
  }
#line 2317
  return;
}
}
#line 2319 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void check_nonvolatile_cache_status(char *file , int ctlrtype , int fd , int num_controllers___0 ) 
{ 
  int i ;
  struct bmic_cache_configuration cache_config ;
  int tmp ;

  {
#line 2324
  i = 0;
  {
#line 2324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2324
    if (! (i < num_controllers___0)) {
#line 2324
      goto while_break;
    }
    {
#line 2327
    memset((void *)(& cache_config), 0, sizeof(cache_config));
#line 2328
    tmp = do_sense_cache_configuration(file, fd, controller_lun_list[i], & cache_config);
    }
#line 2328
    if (tmp != 0) {
      {
#line 2330
      everything_hunky_dory = (_Bool)0;
#line 2331
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%s(%d): cannot get non-volatile cache configuration\n",
              progname, file, i);
      }
#line 2333
      goto __Cont;
    }
    {
#line 2335
    check_one_nonvolatile_cache_status(file, ctlrtype, i, & cache_config);
    }
    __Cont: /* CIL Label */ 
#line 2324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2337
  return;
}
}
#line 2339 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int msa1000_status(char *file , int fd ) 
{ 
  int i ;
  int rc ;
  int numluns ;
  struct identify_controller id ;

  {
  {
#line 2344
  rc = msa1000_passthru_ioctl(fd, 17, (void *)(& id), (int )sizeof(id), 0U);
  }
#line 2345
  if (rc < 0) {
    {
#line 2346
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: Can\'t identify controller, id = 0x%08x.\n",
            progname, file, id.board_id);
    }
#line 2348
    if (persnickety) {
#line 2349
      everything_hunky_dory = (_Bool)0;
    }
#line 2350
    return (-1);
  }
#line 2352
  numluns = (int )id.num_logical_drives;
#line 2353
  i = 0;
  {
#line 2353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2353
    if (! (i < numluns)) {
#line 2353
      goto while_break;
    }
    {
#line 2354
    msa1000_logical_drive_status(file, fd, (unsigned int )i, & id);
#line 2353
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2357
  close(fd);
  }
#line 2358
  return (0);
}
}
#line 2361 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int cciss_device_type_is_correct(char *file , int fd ) 
{ 
  int rc ;
  struct stat statbuf ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 2367
  rc = fstat(fd, & statbuf);
  }
#line 2368
  if (rc < 0) {
    {
#line 2369
    tmp = __errno_location();
#line 2369
    tmp___0 = strerror(*tmp);
#line 2369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot stat %s: %s\n",
            progname, file, tmp___0);
    }
#line 2371
    if (persnickety) {
#line 2372
      everything_hunky_dory = (_Bool)0;
    }
#line 2373
    return (-1);
  }
#line 2384
  if (! ((statbuf.st_mode & 61440U) == 24576U)) {
    {
#line 2385
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is not a %s device.\n",
            progname, file, "block");
    }
#line 2387
    if (persnickety) {
#line 2388
      everything_hunky_dory = (_Bool)0;
    }
#line 2389
    return (-1);
  }
#line 2391
  return (0);
}
}
#line 2394 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void cciss_logical_drive_status(char *file , int fd , struct identify_controller *id ,
                                       int ctlrtype , int volume_number , int is_scsi ) 
{ 
  IOCTL_Command_struct c ;
  struct identify_logical_drive_status ldstatus ;
  int status ;
  char *scsi_device_node ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 2403
  memset((void *)(& c), 0, sizeof(c));
#line 2404
  memset((void *)(& ldstatus), 0, sizeof(ldstatus));
#line 2405
  memcpy((void */* __restrict  */)(& c.LUN_info), (void const   */* __restrict  */)(cciss_to_bmic.addr[volume_number].controller_lun),
         (size_t )8);
#line 2407
  c.Request.CDBLen = (__u8 )10;
#line 2408
  c.Request.Type.Type = (__u8 )0;
#line 2409
  c.Request.Type.Attribute = (__u8 )4;
#line 2410
  c.Request.Type.Direction = (__u8 )2;
#line 2411
  c.Request.Timeout = (__u16 )0;
#line 2412
  c.Request.CDB[0] = (__u8 )38;
#line 2413
  c.Request.CDB[1] = (__u8 )((int )cciss_to_bmic.addr[volume_number].bmic_drive_number & 255);
#line 2414
  c.Request.CDB[6] = (__u8 )18;
#line 2415
  c.buf_size = (__u16 )sizeof(ldstatus);
#line 2416
  set_cdb_buffer_length(c.Request.CDB, c.buf_size);
#line 2417
  c.Request.CDB[9] = (__u8 )(((int )cciss_to_bmic.addr[volume_number].bmic_drive_number >> 8) & 255);
#line 2418
  c.buf = (unsigned char *)(& ldstatus);
  }
#line 2420
  if (debug) {
    {
#line 2421
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getting logical drive status for drive %d\n",
            volume_number);
    }
  }
  {
#line 2423
  status = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(66 << 8)) | 11U) | (sizeof(IOCTL_Command_struct ) << 16),
                 & c);
  }
#line 2424
  if (status != 0) {
    {
#line 2425
    tmp = __errno_location();
#line 2425
    tmp___0 = strerror(*tmp);
#line 2425
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ioctl: logical drive: %d %s\n",
            progname, file, volume_number, tmp___0);
#line 2428
    everything_hunky_dory = (_Bool)0;
    }
#line 2429
    return;
  }
#line 2431
  if ((int )c.error_info.CommandStatus != 0) {
    {
#line 2432
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error getting status for %s volume %d: Commandstatus is %d\n",
            file, volume_number, (int )c.error_info.CommandStatus);
#line 2435
    everything_hunky_dory = (_Bool)0;
    }
#line 2436
    return;
  } else
#line 2438
  if (debug) {
    {
#line 2439
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Status for logical drive %d seems to be gettable.\n",
            volume_number);
    }
  }
#line 2442
  scsi_device_node = file;
#line 2443
  if (is_scsi) {
    {
#line 2444
    find_scsi_device_node(cciss_to_bmic.addr[volume_number].bmic_id_ctlr_data, & scsi_device_node);
    }
  } else {
#line 2447
    scsi_device_node = file;
  }
  {
#line 2448
  print_volume_status(scsi_device_node, fd, ctlrtype, cciss_to_bmic.addr[volume_number].controller_lun,
                      volume_number, & ldstatus, id, cciss_to_bmic.addr[volume_number].tolerance_type,
                      cciss_to_bmic.addr[volume_number].certain);
  }
#line 2453
  return;
}
}
#line 2455 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
__inline static int bmic_supports_big_maps(struct identify_controller *id ) 
{ 
  int tmp ;

  {
#line 2457
  if (id->controller_flags) {
#line 2457
    if (1 << 7) {
#line 2457
      tmp = 1;
    } else {
#line 2457
      tmp = 0;
    }
  } else {
#line 2457
    tmp = 0;
  }
#line 2457
  return (tmp);
}
}
#line 2460 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int bmic_next_disk_bits(uint8_t *bits , int bitmapsize , int disk ) 
{ 
  int i ;
  int tmp ;

  {
#line 2463
  i = disk + 1;
  {
#line 2463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2463
    if (! (i < bitmapsize)) {
#line 2463
      goto while_break;
    }
    {
#line 2464
    tmp = bitisset(bits, i, bitmapsize);
    }
#line 2464
    if (tmp) {
#line 2465
      return (i);
    }
#line 2463
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2466
  return (-1);
}
}
#line 2469 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
__inline static int bmic_next_phy_disk(struct identify_controller *id , int bmic_drive_number ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2471
  tmp___1 = bmic_supports_big_maps(id);
  }
#line 2471
  if (tmp___1) {
    {
#line 2472
    tmp = bmic_next_disk_bits((uint8_t *)(id->big_drive_present_map), 128, bmic_drive_number);
    }
#line 2472
    return (tmp);
  } else {
    {
#line 2474
    tmp___0 = bmic_next_disk_bits((uint8_t *)(& id->drive_present_bit_map), 32, bmic_drive_number);
    }
#line 2474
    return (tmp___0);
  }
}
}
#line 2493 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void check_physical_drive(char *file , int fd , unsigned char *controller_lun ,
                                 struct identify_controller *id , int bmic_drive_number ) 
{ 
  int rc ;
  int bus ;
  int target ;
  struct identify_physical_device device_data ;
  char location[1000] ;
  int ctlrtype ;
  char status[100] ;
  struct identify_physical_device *tmp ;
  int tmp___0 ;

  {
  {
#line 2497
  rc = 0;
#line 2503
  ctlrtype = lookup_controller(id->board_id);
#line 2506
  rc = 0;
#line 2507
  memset((void *)(& device_data), 0, sizeof(device_data));
  }
#line 2509
  if (controller_lun) {
    {
#line 2511
    rc = do_bmic_identify_physical_device(file, fd, controller_lun, bmic_drive_number,
                                          & device_data);
    }
  } else {
    {
#line 2515
    rc = do_sgio_bmic_identify_physical_device(fd, bmic_drive_number, & device_data);
    }
  }
#line 2517
  if (rc) {
    {
#line 2518
    printf((char const   */* __restrict  */)"Cannot get device information for %s: controller: 0x%02x%02x%02x%02x%02x%02x%02x%02x bmic drive number: %d\n",
           file, (int )*(controller_lun + 0), (int )*(controller_lun + 1), (int )*(controller_lun + 2),
           (int )*(controller_lun + 3), (int )*(controller_lun + 4), (int )*(controller_lun + 5),
           (int )*(controller_lun + 6), (int )*(controller_lun + 7), bmic_drive_number);
#line 2524
    everything_hunky_dory = (_Bool)0;
    }
#line 2525
    return;
  }
  {
#line 2528
  find_bus_target(id, bmic_drive_number, & bus, & target);
  }
#line 2529
  if (rc) {
#line 2529
    tmp = (struct identify_physical_device *)((void *)0);
  } else {
#line 2529
    tmp = & device_data;
  }
  {
#line 2529
  format_phys_drive_location(location, bus, target, ctlrtype, controller_lun, tmp);
#line 2531
  sprintf((char */* __restrict  */)(status), (char const   */* __restrict  */)"OK");
  }
#line 2534
  if (! ((int )device_data.more_physical_drive_flags & 1)) {
#line 2535
    goto print_data;
  }
#line 2536
  if (! ((int )device_data.more_physical_drive_flags & 4)) {
#line 2537
    goto print_data;
  }
#line 2538
  if ((int )device_data.more_physical_drive_flags & 2) {
    {
#line 2539
    everything_hunky_dory = (_Bool)0;
#line 2540
    sprintf((char */* __restrict  */)(status), (char const   */* __restrict  */)"S.M.A.R.T. predictive failure.");
    }
  }
  print_data: 
  {
#line 2543
  tmp___0 = strcmp((char const   *)(status), "OK");
  }
#line 2543
  if (tmp___0 == 0) {
#line 2543
    if (! verbose) {
#line 2544
      return;
    }
  }
  {
#line 2545
  printf((char const   */* __restrict  */)"%s %s\n", location, status);
  }
#line 2546
  return;
}
}
#line 2548 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void check_ctlr_physical_drives(char *file , int fd , unsigned char *controller_lun ) 
{ 
  int i ;
  int rc ;
  struct identify_controller id ;
  int physical_drive_count ;

  {
  {
#line 2553
  physical_drive_count = 0;
#line 2555
  rc = id_ctlr_fd(file, fd, controller_lun, & id);
  }
#line 2556
  if (rc != 0) {
    {
#line 2557
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot identify controller 0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
            file, (int )*(controller_lun + 0), (int )*(controller_lun + 1), (int )*(controller_lun + 2),
            (int )*(controller_lun + 3), (int )*(controller_lun + 4), (int )*(controller_lun + 5),
            (int )*(controller_lun + 6), (int )*(controller_lun + 7));
#line 2561
    everything_hunky_dory = (_Bool)0;
    }
#line 2562
    return;
  }
  {
#line 2565
  i = bmic_next_phy_disk(& id, -1);
  }
  {
#line 2565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2565
    if (! (i != -1)) {
#line 2565
      goto while_break;
    }
    {
#line 2566
    physical_drive_count ++;
#line 2565
    i = bmic_next_phy_disk(& id, i);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2568
  if (verbose) {
    {
#line 2569
    printf((char const   */* __restrict  */)"  Physical drives: %d\n", physical_drive_count);
    }
  }
  {
#line 2572
  i = bmic_next_phy_disk(& id, -1);
  }
  {
#line 2572
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2572
    if (! (i != -1)) {
#line 2572
      goto while_break___0;
    }
    {
#line 2573
    check_physical_drive(file, fd, controller_lun, & id, i);
#line 2572
    i = bmic_next_phy_disk(& id, i);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2574
  return;
}
}
#line 2576 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void check_physical_drives(char *file , int fd ) 
{ 
  int i ;

  {
#line 2580
  if (! check_smart_data) {
#line 2580
    if (! verbose) {
#line 2581
      return;
    }
  }
#line 2583
  i = 0;
  {
#line 2583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2583
    if (! (i < num_controllers)) {
#line 2583
      goto while_break;
    }
    {
#line 2584
    check_ctlr_physical_drives(file, fd, controller_lun_list[i]);
#line 2583
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2585
  return;
}
}
#line 2587 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void print_controller_info(struct identify_controller *id , int ctlrtype ) 
{ 


  {
#line 2589
  if (! verbose) {
#line 2590
    return;
  }
  {
#line 2592
  printf((char const   */* __restrict  */)"Controller: %s\n", smartarray_id[ctlrtype].board_name);
#line 2593
  printf((char const   */* __restrict  */)"  Board ID: 0x%08x\n", id->board_id);
#line 2594
  printf((char const   */* __restrict  */)"  Logical drives: %hu\n", (int )id->usExtLogicalUnitCount);
#line 2595
  printf((char const   */* __restrict  */)"  Running firmware: %c%c%c%c\n", (int )id->running_firm_rev[0],
         (int )id->running_firm_rev[1], (int )id->running_firm_rev[2], (int )id->running_firm_rev[3]);
#line 2598
  printf((char const   */* __restrict  */)"  ROM firmware: %c%c%c%c\n", (int )id->rom_firm_rev[0],
         (int )id->rom_firm_rev[1], (int )id->rom_firm_rev[2], (int )id->rom_firm_rev[3]);
  }
#line 2601
  return;
}
}
#line 2603 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static int cciss_status(char *file ) 
{ 
  int fd ;
  int i ;
  int rc ;
  struct identify_controller id ;
  int ctlrtype ;
  int bus ;
  int is_scsi ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2610
  is_scsi = 0;
#line 2612
  fd = open((char const   *)file, 2);
  }
#line 2613
  if (fd < 0) {
    {
#line 2614
    tmp___1 = __errno_location();
    }
#line 2614
    if (*tmp___1 != 6) {
      {
#line 2615
      tmp = __errno_location();
#line 2615
      tmp___0 = strerror(*tmp);
#line 2615
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: open %s: %s\n",
              progname, file, tmp___0);
      }
    } else
#line 2614
    if (persnickety) {
      {
#line 2615
      tmp = __errno_location();
#line 2615
      tmp___0 = strerror(*tmp);
#line 2615
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: open %s: %s\n",
              progname, file, tmp___0);
      }
    }
#line 2617
    if (persnickety) {
#line 2618
      everything_hunky_dory = (_Bool)0;
    }
#line 2619
    return (-1);
  }
  {
#line 2624
  rc = ioctl(fd, 21382UL, & bus);
  }
#line 2625
  if (rc == 0) {
    {
#line 2626
    is_scsi = 1;
#line 2628
    tmp___3 = is_msa1000(fd);
    }
#line 2628
    if (tmp___3) {
      {
#line 2629
      tmp___2 = msa1000_status(file, fd);
      }
#line 2629
      return (tmp___2);
    }
    {
#line 2631
    tmp___4 = is_smartarray_driver(fd);
    }
#line 2631
    if (! tmp___4) {
      {
#line 2632
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: Unknown SCSI device.\n",
              progname, file);
      }
#line 2633
      if (persnickety) {
#line 2634
        everything_hunky_dory = (_Bool)0;
      }
      {
#line 2635
      close(fd);
      }
#line 2636
      return (-1);
    }
  } else {
    {
#line 2640
    tmp___5 = cciss_device_type_is_correct(file, fd);
    }
#line 2640
    if (tmp___5 != 0) {
#line 2641
      return (-1);
    }
  }
  {
#line 2644
  rc = id_ctlr_fd(file, fd, zero_lun, & id);
  }
#line 2645
  if (rc < 0) {
#line 2646
    if (persnickety) {
#line 2647
      everything_hunky_dory = (_Bool)0;
    }
#line 2648
    return (-1);
  }
  {
#line 2652
  ctlrtype = lookup_controller(id.board_id);
  }
#line 2653
  if (ctlrtype == -1) {
    {
#line 2654
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: Unknown controller, board_id = 0x%08x\n",
            progname, file, id.board_id);
    }
#line 2656
    if (persnickety) {
#line 2657
      everything_hunky_dory = (_Bool)0;
    }
#line 2658
    return (-1);
  }
  {
#line 2661
  print_controller_info(& id, ctlrtype);
#line 2664
  rc = init_cciss_to_bmic(file, fd);
  }
#line 2665
  if (rc != 0) {
    {
#line 2666
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Internal error, could not construct CISS to BMIC mapping.\n",
            progname);
#line 2668
    everything_hunky_dory = (_Bool)0;
    }
#line 2669
    return (-1);
  }
#line 2672
  i = 0;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (! (i < cciss_to_bmic.naddrs)) {
#line 2672
      goto while_break;
    }
    {
#line 2673
    cciss_logical_drive_status(file, fd, & id, ctlrtype, i, is_scsi);
#line 2672
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2675
  check_physical_drives(file, fd);
#line 2678
  check_fan_power_temp(file, ctlrtype, fd, num_controllers);
#line 2679
  check_nonvolatile_cache_status(file, ctlrtype, fd, num_controllers);
#line 2680
  close(fd);
  }
#line 2681
  return (0);
}
}
#line 2684 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static void intro(void) 
{ 
  int tmp ;

  {
  {
#line 2686
  tmp = isatty(2);
  }
#line 2686
  if (tmp) {
#line 2686
    if (! be_quiet) {
      {
#line 2687
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s version %s,\nCopyright (C) 2007 Hewlett-Packard Development Company, L.P.\n",
              progname, "1.11");
#line 2690
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s comes with ABSOLUTELY NO WARRANTY.\n",
              progname);
#line 2691
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This is free software, and you are welcome to redistribute it\n");
#line 2692
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"under certain conditions.  ");
#line 2693
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"See the file \'COPYING\', which you \n");
#line 2694
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"should have received with this program, for details regarding\n");
#line 2695
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"the absence of warranty and the conditions for redistribution.\n\n");
#line 2696
      exit(0);
      }
    }
  }
#line 2698
  return;
}
}
#line 2700 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
static struct option longopts[9]  = 
#line 2700
  {      {"persnickety", 0, (int *)((void *)0), 'p'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"try-unknown-devices", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"exhaustive", 0, (int *)((void *)0), 'x'}, 
        {"smart", 0, (int *)((void *)0), 's'}, 
        {"copyright", 0, (int *)((void *)0), 'C'}, 
        {"verbose", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 2712 "/home/june/repo/benchmarks/collector/temp/cciss-vol-status-1.11/cciss_vol_status.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int opt ;

  {
  {
#line 2716
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2718
    opt = getopt_long(argc, (char * const  *)argv, "dpqusvVxC", (struct option  const  *)(longopts),
                      (int *)((void *)0));
    }
    {
#line 2720
    if (opt == 100) {
#line 2720
      goto case_100;
    }
#line 2722
    if (opt == 112) {
#line 2722
      goto case_112;
    }
#line 2724
    if (opt == 113) {
#line 2724
      goto case_113;
    }
#line 2726
    if (opt == 115) {
#line 2726
      goto case_115;
    }
#line 2728
    if (opt == 117) {
#line 2728
      goto case_117;
    }
#line 2730
    if (opt == 67) {
#line 2730
      goto case_67;
    }
#line 2733
    if (opt == 118) {
#line 2733
      goto case_118;
    }
#line 2742
    if (opt == 120) {
#line 2742
      goto case_120;
    }
#line 2745
    if (opt == 86) {
#line 2745
      goto case_86;
    }
#line 2748
    if (opt == 58) {
#line 2748
      goto case_58;
    }
#line 2748
    if (opt == 63) {
#line 2748
      goto case_58;
    }
#line 2750
    if (opt == -1) {
#line 2750
      goto case_neg_1;
    }
#line 2719
    goto switch_break;
    case_100: /* CIL Label */ 
#line 2720
    debug = 1;
#line 2721
    goto __Cont;
    case_112: /* CIL Label */ 
#line 2722
    persnickety = 1;
#line 2723
    goto __Cont;
    case_113: /* CIL Label */ 
#line 2724
    be_quiet = 1;
#line 2725
    goto __Cont;
    case_115: /* CIL Label */ 
#line 2726
    check_smart_data = 1;
#line 2727
    goto __Cont;
    case_117: /* CIL Label */ 
#line 2728
    try_unknown_devices = 1;
#line 2729
    goto __Cont;
    case_67: /* CIL Label */ 
    {
#line 2730
    be_quiet = 0;
#line 2731
    intro();
    }
#line 2732
    goto __Cont;
    case_118: /* CIL Label */ 
    {
#line 2733
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s version %s%s\n",
            progname, "1.11", "");
#line 2741
    exit(0);
    }
    case_120: /* CIL Label */ 
#line 2742
    exhaustive_search = 1;
#line 2744
    goto __Cont;
    case_86: /* CIL Label */ 
#line 2745
    verbose = 1;
#line 2746
    goto __Cont;
    case_58: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 2749
    usage();
    }
    case_neg_1: /* CIL Label */ 
#line 2751
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2716
    if (! (opt != -1)) {
#line 2716
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2755
  if (argc - optind < 1) {
    {
#line 2756
    usage();
    }
  }
  {
#line 2758
  intro();
#line 2760
  i = optind;
  }
  {
#line 2760
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2760
    if (! (i < argc)) {
#line 2760
      goto while_break___0;
    }
    {
#line 2761
    cciss_status(*(argv + i));
#line 2760
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2762
  free_device_node_cache();
#line 2763
  exit(! everything_hunky_dory);
  }
}
}
