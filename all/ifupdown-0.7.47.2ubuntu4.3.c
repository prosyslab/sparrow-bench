/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 6 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct address_family;
#line 6 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef struct address_family address_family;
#line 7
struct method;
#line 7 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef struct method method;
#line 8
struct conversion;
#line 8 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef struct conversion conversion;
#line 9
struct option_default;
#line 9 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef struct option_default option_default;
#line 10
struct interfaces_file;
#line 10 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef struct interfaces_file interfaces_file;
#line 11
struct allowup_defn;
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef struct allowup_defn allowup_defn;
#line 12
struct interface_defn;
#line 12 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef struct interface_defn interface_defn;
#line 13
struct variable;
#line 13 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef struct variable variable;
#line 14
struct mapping_defn;
#line 14 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef struct mapping_defn mapping_defn;
#line 15 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef int execfn(char *command );
#line 16 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
typedef int command_set(interface_defn *ifd , execfn *e );
#line 17 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct address_family {
   char *name ;
   int n_methods ;
   method *method ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct method {
   char *name ;
   command_set *up ;
   command_set *down ;
   conversion *conversions ;
   option_default *defaults ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct conversion {
   char *option ;
   char *newoption ;
   void (*fn)(interface_defn * , char ** , int  , char ** ) ;
   int argc ;
   char **argv ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct option_default {
   char *option ;
   char *value ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct interfaces_file {
   allowup_defn *allowups ;
   interface_defn *ifaces ;
   mapping_defn *mappings ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct allowup_defn {
   allowup_defn *next ;
   char *when ;
   int max_interfaces ;
   int n_interfaces ;
   char **interfaces ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct interface_defn {
   interface_defn *next ;
   char *logical_iface ;
   char *real_iface ;
   address_family *address_family ;
   method *method ;
   int automatic ;
   int max_options ;
   int n_options ;
   variable *option ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct variable {
   char *name ;
   char *value ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
struct mapping_defn {
   mapping_defn *next ;
   int max_matches ;
   int n_matches ;
   char **match ;
   char *script ;
   int max_mappings ;
   int n_mappings ;
   char **mapping ;
};
#line 185 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 185 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 569 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 569 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.h"
struct _dictionary_ {
   int n ;
   int size ;
   char **val ;
   char **key ;
   unsigned int *hash ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.h"
typedef struct _dictionary_ dictionary;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 41 "/usr/include/wordexp.h"
struct __anonstruct_wordexp_t_27 {
   size_t we_wordc ;
   char **we_wordv ;
   size_t we_offs ;
};
#line 41 "/usr/include/wordexp.h"
typedef struct __anonstruct_wordexp_t_27 wordexp_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 181 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
enum __anonenum_currently_processing_30 {
    NONE = 0,
    IFACE = 1,
    MAPPING = 2
} ;
#line 52 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
enum _line_status_ {
    LINE_UNPROCESSED = 0,
    LINE_ERROR = 1,
    LINE_EMPTY = 2,
    LINE_COMMENT = 3,
    LINE_SECTION = 4,
    LINE_VALUE = 5
} ;
#line 52 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
typedef enum _line_status_ line_status;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
int doit(char *str ) ;
#line 115
int execute_options(interface_defn *ifd , execfn *exec , char *opt ) ;
#line 116
int execute_scripts(interface_defn *ifd , execfn *exec , char *opt ) ;
#line 117
int iface_preup(interface_defn *iface ) ;
#line 118
int iface_postup(interface_defn *iface ) ;
#line 119
int iface_up(interface_defn *iface ) ;
#line 120
int iface_predown(interface_defn *iface ) ;
#line 121
int iface_postdown(interface_defn *iface ) ;
#line 122
int iface_down(interface_defn *iface ) ;
#line 123
int iface_list(interface_defn *iface ) ;
#line 124
int iface_query(interface_defn *iface ) ;
#line 125
int execute(char *command , interface_defn *ifd , execfn *exec ) ;
#line 126
int strncmpz(char *l___1 , char *r , size_t llen ) ;
#line 128
char *get_var(char *id , size_t idlen , interface_defn *ifd ) ;
#line 129
int var_true(char *id , interface_defn *ifd ) ;
#line 130
int var_set(char *id , interface_defn *ifd ) ;
#line 131
int var_set_anywhere(char *id , interface_defn *ifd ) ;
#line 132
int run_mapping(char *physical , char *logical , int len , mapping_defn *map ) ;
#line 134
_Bool make_pidfile_name(char *name , size_t size , char const   *command , interface_defn *ifd ) ;
#line 135
int no_act ;
#line 136
int verbose ;
#line 137
int run_scripts ;
#line 139
interfaces_file *defn ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 568
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *__path ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
extern char **environ ;
#line 13 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
static char **localenv  =    (char **)((void *)0);
#line 14
static int check(char *str ) ;
#line 15
static void set_environ(interface_defn *iface , char *mode , char *phase ) ;
#line 16
static char *setlocalenv(char *format , char *name , char *value ) ;
#line 17
static char *parse(char *command , interface_defn *ifd ) ;
#line 18
void addstr(char **buf , size_t *len , size_t *pos , char *str , size_t strlen___0 ) ;
#line 19
static int popen2(FILE **in , FILE **out , char *command  , ...) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
static int check(char *str ) 
{ 


  {
#line 22
  return ((unsigned long )str != (unsigned long )((void *)0));
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
static char *setlocalenv_nomangle(char *format , char *name , char *value ) 
{ 
  char *result ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 28
  tmp = strlen((char const   *)format);
#line 28
  tmp___0 = strlen((char const   *)name);
#line 28
  tmp___1 = strlen((char const   *)value);
#line 28
  tmp___2 = malloc(((tmp + tmp___0) + tmp___1) + 1UL);
#line 28
  result = (char *)tmp___2;
  }
#line 29
  if (! result) {
    {
#line 30
    perror("malloc");
#line 31
    exit(1);
    }
  }
  {
#line 34
  sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)format,
          name, value);
  }
#line 36
  return (result);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
static void set_environ(interface_defn *iface , char *mode , char *phase ) 
{ 
  char **environend ;
  char **envp ;
  int i ;
  char **ppch ;
  int n_recursion ;
  int tmp ;
  int n_env_entries ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char **tmp___5 ;
  char const   *tmp___6 ;
  char **tmp___7 ;
  int tmp___8 ;
  char piface[80] ;
  char *pch ;
  char *tmp___9 ;
  char **tmp___10 ;
  char **tmp___11 ;
  char **tmp___12 ;
  char **tmp___13 ;
  char **tmp___14 ;
  char **tmp___15 ;
  char **tmp___16 ;
  char **tmp___17 ;
  char **tmp___18 ;
  char const   *tmp___19 ;
  char **tmp___20 ;

  {
#line 47
  if ((unsigned long )localenv != (unsigned long )((void *)0)) {
#line 48
    ppch = localenv;
    {
#line 48
    while (1) {
      while_continue: /* CIL Label */ ;
#line 48
      if (! *ppch) {
#line 48
        goto while_break;
      }
      {
#line 49
      free((void *)*ppch);
#line 50
      *ppch = (char *)((void *)0);
#line 48
      ppch ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 52
    free((void *)localenv);
#line 53
    localenv = (char **)((void *)0);
    }
  }
#line 57
  n_recursion = 0;
#line 58
  envp = environ;
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 58
    if (! *envp) {
#line 58
      goto while_break___0;
    }
    {
#line 59
    tmp = strncmp((char const   *)*envp, "IFUPDOWN_", (size_t )9);
    }
#line 59
    if (tmp == 0) {
#line 60
      n_recursion ++;
    }
#line 58
    envp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 62
  n_env_entries = (iface->n_options + 10) + n_recursion;
#line 63
  tmp___0 = malloc(sizeof(*localenv) * (unsigned long )(n_env_entries + 1));
#line 63
  localenv = (char **)tmp___0;
#line 64
  environend = localenv;
#line 65
  *environend = (char *)((void *)0);
#line 67
  i = 0;
  }
  {
#line 67
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 67
    if (! (i < iface->n_options)) {
#line 67
      goto while_break___1;
    }
    {
#line 68
    tmp___1 = strcmp((char const   *)(iface->option + i)->name, "pre-up");
    }
#line 68
    if (tmp___1 == 0) {
#line 69
      goto __Cont;
    } else {
      {
#line 68
      tmp___2 = strcmp((char const   *)(iface->option + i)->name, "up");
      }
#line 68
      if (tmp___2 == 0) {
#line 69
        goto __Cont;
      } else {
        {
#line 68
        tmp___3 = strcmp((char const   *)(iface->option + i)->name, "down");
        }
#line 68
        if (tmp___3 == 0) {
#line 69
          goto __Cont;
        } else {
          {
#line 68
          tmp___4 = strcmp((char const   *)(iface->option + i)->name, "post-down");
          }
#line 68
          if (tmp___4 == 0) {
#line 69
            goto __Cont;
          }
        }
      }
    }
#line 72
    tmp___5 = environend;
#line 72
    environend ++;
#line 72
    if ((iface->option + i)->value) {
#line 72
      tmp___6 = (char const   *)(iface->option + i)->value;
    } else {
#line 72
      tmp___6 = "";
    }
    {
#line 72
    *tmp___5 = setlocalenv((char *)"IF_%s=%s", (iface->option + i)->name, (char *)tmp___6);
#line 74
    *environend = (char *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 67
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 77
  envp = environ;
  {
#line 77
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 77
    if (! *envp) {
#line 77
      goto while_break___2;
    }
    {
#line 78
    tmp___8 = strncmp((char const   *)*envp, "IFUPDOWN_", (size_t )9);
    }
#line 78
    if (tmp___8 == 0) {
      {
#line 79
      tmp___7 = environend;
#line 79
      environend ++;
#line 79
      *tmp___7 = strdup((char const   *)*envp);
      }
    }
#line 77
    envp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 82
  strncpy((char */* __restrict  */)(piface), (char const   */* __restrict  */)iface->real_iface,
          sizeof(piface));
#line 83
  piface[sizeof(piface) - 1UL] = (char )'\000';
#line 84
  tmp___9 = strchr((char const   *)(piface), '.');
#line 84
  pch = tmp___9;
  }
#line 85
  if (pch) {
    {
#line 86
    *pch = (char )'\000';
#line 87
    tmp___10 = environend;
#line 87
    environend ++;
#line 87
    *tmp___10 = setlocalenv_nomangle((char *)"IFUPDOWN_%s=%s", piface, (char *)"parent-lock");
#line 88
    *environend = (char *)((void *)0);
    }
  }
  {
#line 91
  tmp___11 = environend;
#line 91
  environend ++;
#line 91
  *tmp___11 = setlocalenv_nomangle((char *)"IFUPDOWN_%s=%s", iface->real_iface, phase);
#line 92
  *environend = (char *)((void *)0);
#line 94
  tmp___12 = environend;
#line 94
  environend ++;
#line 94
  *tmp___12 = setlocalenv((char *)"%s=%s", (char *)"IFACE", iface->real_iface);
#line 95
  *environend = (char *)((void *)0);
#line 97
  tmp___13 = environend;
#line 97
  environend ++;
#line 97
  *tmp___13 = setlocalenv((char *)"%s=%s", (char *)"LOGICAL", iface->logical_iface);
#line 98
  *environend = (char *)((void *)0);
#line 100
  tmp___14 = environend;
#line 100
  environend ++;
#line 100
  *tmp___14 = setlocalenv((char *)"%s=%s", (char *)"ADDRFAM", (iface->address_family)->name);
#line 101
  *environend = (char *)((void *)0);
#line 103
  tmp___15 = environend;
#line 103
  environend ++;
#line 103
  *tmp___15 = setlocalenv((char *)"%s=%s", (char *)"METHOD", (iface->method)->name);
#line 104
  *environend = (char *)((void *)0);
#line 106
  tmp___16 = environend;
#line 106
  environend ++;
#line 106
  *tmp___16 = setlocalenv((char *)"%s=%s", (char *)"MODE", mode);
#line 107
  *environend = (char *)((void *)0);
#line 109
  tmp___17 = environend;
#line 109
  environend ++;
#line 109
  *tmp___17 = setlocalenv((char *)"%s=%s", (char *)"PHASE", phase);
#line 110
  *environend = (char *)((void *)0);
#line 112
  tmp___18 = environend;
#line 112
  environend ++;
  }
#line 112
  if (verbose) {
#line 112
    tmp___19 = "1";
  } else {
#line 112
    tmp___19 = "0";
  }
  {
#line 112
  *tmp___18 = setlocalenv((char *)"%s=%s", (char *)"VERBOSITY", (char *)tmp___19);
#line 113
  *environend = (char *)((void *)0);
#line 115
  tmp___20 = environend;
#line 115
  environend ++;
#line 115
  *tmp___20 = setlocalenv((char *)"%s=%s", (char *)"PATH", (char *)"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin");
#line 116
  *environend = (char *)((void *)0);
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
static char *setlocalenv(char *format , char *name , char *value ) 
{ 
  char *result ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *here ;
  char *there ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 123
  tmp = strlen((char const   *)format);
#line 123
  tmp___0 = strlen((char const   *)name);
#line 123
  tmp___1 = strlen((char const   *)value);
#line 123
  tmp___2 = malloc(((tmp + tmp___0) + tmp___1) + 1UL);
#line 123
  result = (char *)tmp___2;
  }
#line 127
  if (! result) {
    {
#line 128
    perror("malloc");
#line 129
    exit(1);
    }
  }
  {
#line 132
  sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)format,
          name, value);
#line 137
  there = result;
#line 137
  here = there;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if ((int )*there != 61) {
#line 137
      if (! *there) {
#line 137
        goto while_break;
      }
    } else {
#line 137
      goto while_break;
    }
#line 138
    if ((int )*there == 45) {
#line 139
      *there = (char )'_';
    }
    {
#line 140
    tmp___4 = __ctype_b_loc();
    }
#line 140
    if ((int const   )*(*tmp___4 + (int )*there) & 1024) {
      {
#line 141
      tmp___3 = toupper((int )*there);
#line 141
      *there = (char )tmp___3;
      }
    }
    {
#line 143
    tmp___5 = __ctype_b_loc();
    }
#line 143
    if ((int const   )*(*tmp___5 + (int )*there) & 8) {
#line 144
      *here = *there;
#line 145
      here ++;
    } else
#line 143
    if ((int )*there == 95) {
#line 144
      *here = *there;
#line 145
      here ++;
    }
#line 137
    there ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  tmp___6 = strlen((char const   *)there);
#line 148
  memmove((void *)here, (void const   *)there, tmp___6 + 1UL);
  }
#line 151
  return (result);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int doit(char *str ) 
{ 
  _Bool ignore_status ;
  pid_t child ;
  int status ;
  union __anonunion_53 __constr_expr_0 ;
  union __anonunion_54 __constr_expr_1 ;

  {
#line 156
  if (! str) {
    {
#line 156
    __assert_fail("str", "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c",
                  156U, "doit");
    }
  }
#line 157
  ignore_status = (_Bool)0;
#line 158
  if ((int )*str == 45) {
#line 159
    ignore_status = (_Bool)1;
#line 160
    str ++;
  }
#line 163
  if (verbose) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            str);
    }
  } else
#line 163
  if (no_act) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            str);
    }
  }
#line 166
  if (! no_act) {
    {
#line 170
    fflush((FILE *)((void *)0));
#line 171
    setpgid(0, 0);
#line 172
    child = fork();
    }
    {
#line 173
    if (child == -1) {
#line 173
      goto case_neg_1;
    }
#line 175
    if (child == 0) {
#line 175
      goto case_0;
    }
#line 178
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 174
    return (0);
    case_0: /* CIL Label */ 
    {
#line 176
    execle("/bin/sh", "/bin/sh", "-c", str, (void *)0, localenv);
#line 177
    exit(127);
    }
    switch_default: /* CIL Label */ 
#line 179
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 181
    waitpid(child, & status, 0);
    }
#line 182
    if (ignore_status) {
#line 183
      return (1);
    }
#line 185
    __constr_expr_0.__in = status;
#line 185
    if ((__constr_expr_0.__i & 127) == 0) {
#line 185
      __constr_expr_1.__in = status;
#line 185
      if ((__constr_expr_1.__i & 65280) >> 8 != 0) {
#line 186
        return (0);
      }
    } else {
#line 186
      return (0);
    }
  }
#line 188
  return (1);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int execute_options(interface_defn *ifd , execfn *exec , char *opt ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 194
  i = 0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i < ifd->n_options)) {
#line 194
      goto while_break;
    }
    {
#line 195
    tmp___0 = strcmp((char const   *)(ifd->option + i)->name, (char const   *)opt);
    }
#line 195
    if (tmp___0 == 0) {
      {
#line 196
      tmp = (*exec)((ifd->option + i)->value);
      }
#line 196
      if (! tmp) {
#line 197
        return (0);
      }
    }
#line 194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return (1);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int execute_scripts(interface_defn *ifd , execfn *exec , char *opt ) 
{ 
  char buf[100] ;
  char const   *tmp ;

  {
#line 206
  if (! run_scripts) {
#line 207
    return (1);
  }
#line 210
  if (verbose) {
#line 210
    tmp = "--verbose";
  } else {
#line 210
    tmp = "";
  }
  {
#line 210
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"run-parts %s /etc/network/if-%s.d",
           tmp, opt);
#line 212
  (*exec)(buf);
  }
#line 214
  return (1);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int iface_preup(interface_defn *iface ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 219
  set_environ(iface, (char *)"start", (char *)"pre-up");
#line 220
  tmp = (*((iface->method)->up))(iface, & check);
  }
#line 220
  if (! tmp) {
#line 221
    return (-1);
  }
  {
#line 223
  tmp___0 = execute_options(iface, & doit, (char *)"pre-up");
  }
#line 223
  if (! tmp___0) {
#line 224
    return (0);
  }
  {
#line 225
  tmp___1 = execute_scripts(iface, & doit, (char *)"pre-up");
  }
#line 225
  if (! tmp___1) {
#line 226
    return (0);
  }
#line 228
  return (1);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int iface_postup(interface_defn *iface ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 233
  set_environ(iface, (char *)"start", (char *)"post-up");
#line 234
  tmp = (*((iface->method)->up))(iface, & doit);
  }
#line 234
  if (! tmp) {
#line 235
    return (0);
  }
  {
#line 237
  tmp___0 = execute_options(iface, & doit, (char *)"up");
  }
#line 237
  if (! tmp___0) {
#line 238
    return (0);
  }
  {
#line 239
  tmp___1 = execute_scripts(iface, & doit, (char *)"up");
  }
#line 239
  if (! tmp___1) {
#line 240
    return (0);
  }
#line 242
  return (1);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int iface_up(interface_defn *iface ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 247
  tmp = iface_preup(iface);
#line 247
  result = tmp;
  }
#line 248
  if (result != 1) {
#line 249
    return (result);
  }
  {
#line 250
  tmp___0 = iface_postup(iface);
  }
#line 250
  return (tmp___0);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int iface_predown(interface_defn *iface ) 
{ 
  char pidfilename[100] ;
  FILE *pidfile ;
  FILE *tmp ;
  int pid ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 255
  if (! no_act) {
    {
#line 257
    make_pidfile_name(pidfilename, sizeof(pidfilename), "ifup", iface);
#line 258
    tmp = fopen((char const   */* __restrict  */)(pidfilename), (char const   */* __restrict  */)"r");
#line 258
    pidfile = tmp;
    }
#line 259
    if (pidfile) {
      {
#line 261
      tmp___0 = fscanf((FILE */* __restrict  */)pidfile, (char const   */* __restrict  */)"%d",
                       & pid);
      }
#line 261
      if (tmp___0) {
#line 262
        if (verbose) {
          {
#line 263
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Terminating ifup (pid %d)\n",
                  pid);
          }
        }
        {
#line 265
        kill(- pid, 15);
        }
      }
      {
#line 267
      fclose(pidfile);
#line 268
      unlink((char const   *)(pidfilename));
      }
    }
  }
  {
#line 272
  set_environ(iface, (char *)"stop", (char *)"pre-down");
#line 273
  tmp___1 = (*((iface->method)->down))(iface, & check);
  }
#line 273
  if (! tmp___1) {
#line 274
    return (-1);
  }
  {
#line 276
  tmp___2 = execute_scripts(iface, & doit, (char *)"down");
  }
#line 276
  if (! tmp___2) {
#line 277
    return (0);
  }
  {
#line 278
  tmp___3 = execute_options(iface, & doit, (char *)"down");
  }
#line 278
  if (! tmp___3) {
#line 279
    return (0);
  }
#line 281
  return (1);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int iface_postdown(interface_defn *iface ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 286
  tmp = (*((iface->method)->down))(iface, & doit);
  }
#line 286
  if (! tmp) {
#line 287
    return (0);
  }
  {
#line 289
  set_environ(iface, (char *)"stop", (char *)"post-down");
#line 290
  tmp___0 = execute_scripts(iface, & doit, (char *)"post-down");
  }
#line 290
  if (! tmp___0) {
#line 291
    return (0);
  }
  {
#line 292
  tmp___1 = execute_options(iface, & doit, (char *)"post-down");
  }
#line 292
  if (! tmp___1) {
#line 293
    return (0);
  }
#line 295
  return (1);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int iface_down(interface_defn *iface ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 300
  tmp = iface_predown(iface);
#line 300
  result = tmp;
  }
#line 301
  if (result != 1) {
#line 302
    return (result);
  }
  {
#line 303
  tmp___0 = iface_postdown(iface);
  }
#line 303
  return (tmp___0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int iface_list(interface_defn *iface ) 
{ 


  {
  {
#line 308
  printf((char const   */* __restrict  */)"%s\n", iface->real_iface);
  }
#line 309
  return (0);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int iface_query(interface_defn *iface ) 
{ 
  int i ;

  {
#line 315
  i = 0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (i < iface->n_options)) {
#line 315
      goto while_break;
    }
    {
#line 316
    printf((char const   */* __restrict  */)"%s: %s\n", (iface->option + i)->name,
           (iface->option + i)->value);
#line 315
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return (0);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int execute(char *command , interface_defn *ifd , execfn *exec ) 
{ 
  char *out ;
  int ret ;

  {
  {
#line 326
  out = parse(command, ifd);
  }
#line 327
  if (! out) {
#line 328
    return (0);
  }
  {
#line 331
  ret = (*exec)(out);
#line 333
  free((void *)out);
  }
#line 334
  return (ret);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
static char *parse(char *command , interface_defn *ifd ) 
{ 
  char *result ;
  size_t pos ;
  size_t len ;
  size_t old_pos[10] ;
  unsigned int tmp ;
  int okay[10] ;
  unsigned int tmp___0 ;
  int opt_depth ;
  char *nextpercent ;
  size_t namelen ;
  char pat ;
  char rep ;
  char *varvalue ;
  int *tmp___1 ;
  char *position ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 339
  result = (char *)((void *)0);
#line 340
  pos = (size_t )0;
#line 340
  len = (size_t )0;
#line 341
  old_pos[0] = (size_t )0;
#line 341
  tmp = 1U;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (tmp >= 10U) {
#line 341
      goto while_break;
    }
#line 341
    old_pos[tmp] = 0UL;
#line 341
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  okay[0] = 1;
#line 342
  tmp___0 = 1U;
  {
#line 342
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 342
    if (tmp___0 >= 10U) {
#line 342
      goto while_break___0;
    }
#line 342
    okay[tmp___0] = 0;
#line 342
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 343
  opt_depth = 1;
  {
#line 345
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 345
    if (! *command) {
#line 345
      goto while_break___1;
    }
    {
#line 351
    if ((int )*command == 92) {
#line 351
      goto case_92;
    }
#line 360
    if ((int )*command == 91) {
#line 360
      goto case_91;
    }
#line 371
    if ((int )*command == 93) {
#line 371
      goto case_93;
    }
#line 384
    if ((int )*command == 37) {
#line 384
      goto case_37;
    }
#line 347
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 348
    addstr(& result, & len, & pos, command, (size_t )1);
#line 349
    command ++;
    }
#line 350
    goto switch_break;
    case_92: /* CIL Label */ 
#line 352
    if (*(command + 1)) {
      {
#line 353
      addstr(& result, & len, & pos, command + 1, (size_t )1);
#line 354
      command += 2;
      }
    } else {
      {
#line 356
      addstr(& result, & len, & pos, command, (size_t )1);
#line 357
      command ++;
      }
    }
#line 359
    goto switch_break;
    case_91: /* CIL Label */ 
#line 361
    if ((int )*(command + 1) == 91) {
#line 361
      if (opt_depth < 10) {
#line 362
        old_pos[opt_depth] = pos;
#line 363
        okay[opt_depth] = 1;
#line 364
        opt_depth ++;
#line 365
        command += 2;
      } else {
        {
#line 367
        addstr(& result, & len, & pos, (char *)"[", (size_t )1);
#line 368
        command ++;
        }
      }
    } else {
      {
#line 367
      addstr(& result, & len, & pos, (char *)"[", (size_t )1);
#line 368
      command ++;
      }
    }
#line 370
    goto switch_break;
    case_93: /* CIL Label */ 
#line 372
    if ((int )*(command + 1) == 93) {
#line 372
      if (opt_depth > 1) {
#line 373
        opt_depth --;
#line 374
        if (! okay[opt_depth]) {
#line 375
          pos = old_pos[opt_depth];
#line 376
          *(result + pos) = (char )'\000';
        }
#line 378
        command += 2;
      } else {
        {
#line 380
        addstr(& result, & len, & pos, (char *)"]", (size_t )1);
#line 381
        command ++;
        }
      }
    } else {
      {
#line 380
      addstr(& result, & len, & pos, (char *)"]", (size_t )1);
#line 381
      command ++;
      }
    }
#line 383
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 388
    pat = (char)0;
#line 388
    rep = (char)0;
#line 391
    command ++;
#line 392
    nextpercent = strchr((char const   *)command, '%');
#line 393
    namelen = (size_t )(nextpercent - command);
    }
#line 394
    if (! nextpercent) {
      {
#line 395
      tmp___1 = __errno_location();
#line 395
      *tmp___1 = 10000;
#line 396
      free((void *)result);
      }
#line 397
      return ((char *)((void *)0));
    }
#line 400
    if ((int )*(nextpercent - 4) == 47) {
#line 401
      pat = *(nextpercent - 3);
#line 402
      rep = *(nextpercent - 1);
#line 403
      namelen -= 4UL;
    }
    {
#line 406
    varvalue = get_var(command, namelen, ifd);
    }
#line 408
    if (varvalue) {
#line 409
      position = varvalue;
      {
#line 410
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 410
        if (! *position) {
#line 410
          goto while_break___2;
        }
#line 411
        if ((int )*position == (int )pat) {
#line 412
          *position = rep;
        }
#line 410
        position ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 415
      tmp___2 = strlen((char const   *)varvalue);
#line 415
      addstr(& result, & len, & pos, varvalue, tmp___2);
#line 416
      free((void *)varvalue);
      }
    } else {
#line 418
      if (opt_depth == 1) {
        {
#line 419
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing required variable: %.*s\n",
                namelen, command);
        }
      }
#line 421
      okay[opt_depth - 1] = 0;
    }
#line 424
    command = nextpercent + 1;
#line 426
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 431
  if (opt_depth > 1) {
    {
#line 432
    tmp___3 = __errno_location();
#line 432
    *tmp___3 = 10001;
#line 433
    free((void *)result);
    }
#line 434
    return ((char *)((void *)0));
  }
#line 437
  if (! okay[0]) {
    {
#line 438
    tmp___4 = __errno_location();
#line 438
    *tmp___4 = 10002;
#line 439
    free((void *)result);
    }
#line 440
    return ((char *)((void *)0));
  }
#line 443
  return (result);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
void addstr(char **buf , size_t *len , size_t *pos , char *str , size_t strlen___0 ) 
{ 
  char *newbuf ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 448
  if (! (*len >= *pos)) {
    {
#line 448
    __assert_fail("*len >= *pos", "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c",
                  448U, "addstr");
    }
  }
#line 449
  if (! (*len == 0UL)) {
#line 449
    if (! ((int )*(*buf + *pos) == 0)) {
      {
#line 449
      __assert_fail("*len == 0 || (*buf)[*pos] == \'\\0\'", "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c",
                    449U, "addstr");
      }
    }
  }
#line 451
  if (*pos + strlen___0 >= *len) {
    {
#line 453
    tmp = realloc((void *)*buf, (*len * 2UL + strlen___0) + 1UL);
#line 453
    newbuf = (char *)tmp;
    }
#line 454
    if (! newbuf) {
      {
#line 455
      perror("realloc");
#line 456
      exit(1);
      }
    }
#line 458
    *buf = newbuf;
#line 459
    *len = (*len * 2UL + strlen___0) + 1UL;
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    tmp___1 = strlen___0;
#line 462
    strlen___0 --;
#line 462
    if (! (tmp___1 >= 1UL)) {
#line 462
      goto while_break;
    }
#line 463
    tmp___0 = *pos;
#line 463
    (*pos) ++;
#line 463
    *(*buf + tmp___0) = *str;
#line 464
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  *(*buf + *pos) = (char )'\000';
#line 467
  return;
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int strncmpz(char *l___1 , char *r , size_t llen ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 471
  tmp = strncmp((char const   *)l___1, (char const   *)r, llen);
#line 471
  i = tmp;
  }
#line 472
  if (i == 0) {
#line 473
    return (- ((int )*(r + llen)));
  } else {
#line 475
    return (i);
  }
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
char *get_var(char *id , size_t idlen , interface_defn *ifd ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 482
  tmp___0 = strncmpz(id, (char *)"iface", idlen);
  }
#line 482
  if (tmp___0 == 0) {
    {
#line 483
    tmp = strdup((char const   *)ifd->real_iface);
    }
#line 483
    return (tmp);
  }
#line 487
  i = 0;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! (i < ifd->n_options)) {
#line 487
      goto while_break;
    }
    {
#line 488
    tmp___3 = strncmpz(id, (ifd->option + i)->name, idlen);
    }
#line 488
    if (tmp___3 == 0) {
#line 489
      if (! (ifd->option + i)->value) {
#line 490
        return ((char *)((void *)0));
      }
      {
#line 492
      tmp___2 = strlen((char const   *)(ifd->option + i)->value);
      }
#line 492
      if (tmp___2 > 0UL) {
        {
#line 493
        tmp___1 = strdup((char const   *)(ifd->option + i)->value);
        }
#line 493
        return (tmp___1);
      } else {
#line 495
        return ((char *)((void *)0));
      }
    }
#line 487
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  return ((char *)((void *)0));
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int var_true(char *id , interface_defn *ifd ) 
{ 
  char *varvalue ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 508
  tmp = strlen((char const   *)id);
#line 508
  varvalue = get_var(id, tmp, ifd);
  }
#line 509
  if (varvalue) {
    {
#line 510
    tmp___0 = atoi((char const   *)varvalue);
    }
#line 510
    if (tmp___0) {
      {
#line 514
      free((void *)varvalue);
      }
#line 515
      return (1);
    } else {
      {
#line 510
      tmp___1 = strcasecmp((char const   *)varvalue, "on");
      }
#line 510
      if (tmp___1 == 0) {
        {
#line 514
        free((void *)varvalue);
        }
#line 515
        return (1);
      } else {
        {
#line 510
        tmp___2 = strcasecmp((char const   *)varvalue, "true");
        }
#line 510
        if (tmp___2 == 0) {
          {
#line 514
          free((void *)varvalue);
          }
#line 515
          return (1);
        } else {
          {
#line 510
          tmp___3 = strcasecmp((char const   *)varvalue, "yes");
          }
#line 510
          if (tmp___3 == 0) {
            {
#line 514
            free((void *)varvalue);
            }
#line 515
            return (1);
          } else {
            {
#line 517
            free((void *)varvalue);
            }
#line 518
            return (0);
          }
        }
      }
    }
  } else {
#line 521
    return (0);
  }
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int var_set(char *id , interface_defn *ifd ) 
{ 
  char *varvalue ;
  size_t tmp ;

  {
  {
#line 528
  tmp = strlen((char const   *)id);
#line 528
  varvalue = get_var(id, tmp, ifd);
  }
#line 529
  if (varvalue) {
    {
#line 530
    free((void *)varvalue);
    }
#line 531
    return (1);
  } else {
#line 533
    return (0);
  }
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int var_set_anywhere(char *id , interface_defn *ifd ) 
{ 
  char *varvalue ;
  interface_defn *currif ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 542
  currif = defn->ifaces;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 542
    if (! currif) {
#line 542
      goto while_break;
    }
    {
#line 543
    tmp___0 = strcmp((char const   *)ifd->logical_iface, (char const   *)currif->logical_iface);
    }
#line 543
    if (tmp___0 == 0) {
      {
#line 544
      tmp = strlen((char const   *)id);
#line 544
      varvalue = get_var(id, tmp, currif);
      }
#line 545
      if (varvalue) {
        {
#line 546
        free((void *)varvalue);
        }
#line 547
        return (1);
      }
    }
#line 542
    currif = currif->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  return (0);
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
int run_mapping(char *physical , char *logical , int len , mapping_defn *map ) 
{ 
  FILE *in ;
  FILE *out ;
  int i ;
  int status ;
  pid_t pid ;
  char *pch ;
  size_t tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  union __anonunion_55 __constr_expr_2 ;
  union __anonunion_56 __constr_expr_3 ;

  {
  {
#line 560
  pid = popen2(& in, & out, map->script, physical, (void *)0);
  }
#line 561
  if (pid == 0) {
#line 562
    return (0);
  }
#line 564
  i = 0;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (i < map->n_mappings)) {
#line 564
      goto while_break;
    }
    {
#line 565
    fprintf((FILE */* __restrict  */)in, (char const   */* __restrict  */)"%s\n",
            *(map->mapping + i));
#line 564
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 567
  fclose(in);
#line 568
  waitpid(pid, & status, 0);
#line 569
  __constr_expr_2.__in = status;
  }
#line 569
  if ((__constr_expr_2.__i & 127) == 0) {
#line 569
    __constr_expr_3.__in = status;
#line 569
    if ((__constr_expr_3.__i & 65280) >> 8 == 0) {
      {
#line 570
      tmp___2 = fgets((char */* __restrict  */)logical, len, (FILE */* __restrict  */)out);
      }
#line 570
      if (tmp___2) {
        {
#line 571
        tmp = strlen((char const   *)logical);
#line 571
        pch = (logical + tmp) - 1;
        }
        {
#line 572
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 572
          if ((unsigned long )pch >= (unsigned long )logical) {
            {
#line 572
            tmp___1 = __ctype_b_loc();
            }
#line 572
            if (! ((int const   )*(*tmp___1 + (int )*pch) & 8192)) {
#line 572
              goto while_break___0;
            }
          } else {
#line 572
            goto while_break___0;
          }
#line 573
          tmp___0 = pch;
#line 573
          pch --;
#line 573
          *tmp___0 = (char )'\000';
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 576
  fclose(out);
  }
#line 578
  return (1);
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/execute.c"
static int popen2(FILE **in , FILE **out , char *command  , ...) 
{ 
  va_list ap ;
  char *argv[11] ;
  unsigned int tmp ;
  int argc ;
  int infd[2] ;
  int outfd[2] ;
  pid_t pid ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 584
  argv[0] = command;
#line 584
  tmp = 1U;
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 584
    if (tmp >= 11U) {
#line 584
      goto while_break;
    }
#line 584
    argv[tmp] = (char *)0;
#line 584
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 589
  argc = 1;
#line 590
  __builtin_va_start(ap, command);
  }
  {
#line 591
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 591
    if (argc < 10) {
      {
#line 591
      tmp___1 = __builtin_va_arg(ap, char *);
#line 591
      tmp___0 = tmp___1;
#line 591
      argv[argc] = tmp___0;
      }
#line 591
      if (! tmp___0) {
#line 591
        goto while_break___0;
      }
    } else {
#line 591
      goto while_break___0;
    }
#line 593
    argc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 595
  argv[argc] = (char *)((void *)0);
#line 596
  __builtin_va_end(ap);
#line 598
  tmp___2 = pipe((int *)(infd));
  }
#line 598
  if (tmp___2 != 0) {
#line 599
    return (0);
  }
  {
#line 600
  tmp___3 = pipe((int *)(outfd));
  }
#line 600
  if (tmp___3 != 0) {
    {
#line 601
    close(infd[0]);
#line 602
    close(infd[1]);
    }
#line 603
    return (0);
  }
  {
#line 606
  fflush((FILE *)((void *)0));
#line 607
  pid = fork();
  }
  {
#line 608
  if (pid == -1) {
#line 608
    goto case_neg_1;
  }
#line 614
  if (pid == 0) {
#line 614
    goto case_0;
  }
#line 625
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 609
  close(infd[0]);
#line 610
  close(infd[1]);
#line 611
  close(outfd[0]);
#line 612
  close(outfd[1]);
  }
#line 613
  return (0);
  case_0: /* CIL Label */ 
  {
#line 616
  chdir("/");
#line 617
  dup2(infd[0], 0);
#line 618
  dup2(outfd[1], 1);
#line 619
  close(infd[0]);
#line 620
  close(infd[1]);
#line 621
  close(outfd[0]);
#line 622
  close(outfd[1]);
#line 623
  execvp((char const   *)command, (char * const  *)(argv));
#line 624
  exit(127);
  }
  switch_default: /* CIL Label */ 
  {
#line 626
  *in = fdopen(infd[1], "w");
#line 627
  *out = fdopen(outfd[0], "r");
#line 628
  close(infd[0]);
#line 629
  close(outfd[1]);
  }
#line 630
  return (pid);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.h"
unsigned int dictionary_hash(char *key ) ;
#line 110
dictionary *dictionary_new(int size ) ;
#line 121
void dictionary_del(dictionary *d ) ;
#line 137
char *dictionary_get(dictionary *d , char *key , char *def ) ;
#line 166
int dictionary_set(dictionary *d , char *key , char *val ) ;
#line 179
void dictionary_unset(dictionary *d , char *key ) ;
#line 194
void dictionary_dump(dictionary *d , FILE *out ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.c"
static void *mem_double(void *ptr , int size ) 
{ 
  void *newptr ;

  {
  {
#line 71
  newptr = calloc((size_t )(2 * size), (size_t )1);
  }
#line 72
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 73
    return ((void *)0);
  }
  {
#line 75
  memcpy((void */* __restrict  */)newptr, (void const   */* __restrict  */)ptr, (size_t )size);
#line 76
  free(ptr);
  }
#line 77
  return (newptr);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.c"
static char *xstrdup(char *s ) 
{ 
  char *t ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 93
  if (! s) {
#line 94
    return ((char *)((void *)0));
  }
  {
#line 95
  tmp = strlen((char const   *)s);
#line 95
  tmp___0 = malloc(tmp + 1UL);
#line 95
  t = (char *)tmp___0;
  }
#line 96
  if (t) {
    {
#line 97
    strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)s);
    }
  }
#line 99
  return (t);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.c"
unsigned int dictionary_hash(char *key ) 
{ 
  int len ;
  unsigned int hash ;
  int i ;
  size_t tmp ;

  {
  {
#line 123
  tmp = strlen((char const   *)key);
#line 123
  len = (int )tmp;
#line 124
  hash = 0U;
#line 124
  i = 0;
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < len)) {
#line 124
      goto while_break;
    }
#line 125
    hash += (unsigned int )*(key + i);
#line 126
    hash += hash << 10;
#line 127
    hash ^= hash >> 6;
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  hash += hash << 3;
#line 130
  hash ^= hash >> 11;
#line 131
  hash += hash << 15;
#line 132
  return (hash);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.c"
dictionary *dictionary_new(int size ) 
{ 
  dictionary *d ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 151
  if (size < 128) {
#line 151
    size = 128;
  }
  {
#line 153
  tmp = calloc((size_t )1, sizeof(dictionary ));
#line 153
  d = (dictionary *)tmp;
  }
#line 153
  if (! d) {
#line 154
    return ((dictionary *)((void *)0));
  }
  {
#line 156
  d->size = size;
#line 157
  tmp___0 = calloc((size_t )size, sizeof(char *));
#line 157
  d->val = (char **)tmp___0;
#line 158
  tmp___1 = calloc((size_t )size, sizeof(char *));
#line 158
  d->key = (char **)tmp___1;
#line 159
  tmp___2 = calloc((size_t )size, sizeof(unsigned int ));
#line 159
  d->hash = (unsigned int *)tmp___2;
  }
#line 160
  return (d);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.c"
void dictionary_del(dictionary *d ) 
{ 
  int i ;

  {
#line 176
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 176
    return;
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < d->size)) {
#line 177
      goto while_break;
    }
#line 178
    if ((unsigned long )*(d->key + i) != (unsigned long )((void *)0)) {
      {
#line 179
      free((void *)*(d->key + i));
      }
    }
#line 180
    if ((unsigned long )*(d->val + i) != (unsigned long )((void *)0)) {
      {
#line 181
      free((void *)*(d->val + i));
      }
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  free((void *)d->val);
#line 184
  free((void *)d->key);
#line 185
  free((void *)d->hash);
#line 186
  free((void *)d);
  }
#line 187
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.c"
char *dictionary_get(dictionary *d , char *key , char *def ) 
{ 
  unsigned int hash ;
  int i ;
  int tmp ;

  {
  {
#line 209
  hash = dictionary_hash(key);
#line 210
  i = 0;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < d->size)) {
#line 210
      goto while_break;
    }
#line 211
    if ((unsigned long )*(d->key + i) == (unsigned long )((void *)0)) {
#line 212
      goto __Cont;
    }
#line 214
    if (hash == *(d->hash + i)) {
      {
#line 216
      tmp = strcmp((char const   *)key, (char const   *)*(d->key + i));
      }
#line 216
      if (! tmp) {
#line 217
        return (*(d->val + i));
      }
    }
    __Cont: /* CIL Label */ 
#line 210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (def);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.c"
int dictionary_set(dictionary *d , char *key , char *val ) 
{ 
  int i ;
  unsigned int hash ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 255
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 255
    return (-1);
  } else
#line 255
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 255
    return (-1);
  }
  {
#line 258
  hash = dictionary_hash(key);
  }
#line 260
  if (d->n > 0) {
#line 261
    i = 0;
    {
#line 261
    while (1) {
      while_continue: /* CIL Label */ ;
#line 261
      if (! (i < d->size)) {
#line 261
        goto while_break;
      }
#line 262
      if ((unsigned long )*(d->key + i) == (unsigned long )((void *)0)) {
#line 263
        goto __Cont;
      }
#line 264
      if (hash == *(d->hash + i)) {
        {
#line 265
        tmp___0 = strcmp((char const   *)key, (char const   *)*(d->key + i));
        }
#line 265
        if (! tmp___0) {
#line 267
          if ((unsigned long )*(d->val + i) != (unsigned long )((void *)0)) {
            {
#line 268
            free((void *)*(d->val + i));
            }
          }
#line 269
          if (val) {
            {
#line 269
            tmp = xstrdup(val);
#line 269
            *(d->val + i) = tmp;
            }
          } else {
#line 269
            *(d->val + i) = (char *)((void *)0);
          }
#line 271
          return (0);
        }
      }
      __Cont: /* CIL Label */ 
#line 261
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 278
  if (d->n == d->size) {
    {
#line 281
    tmp___1 = mem_double((void *)d->val, (int )((unsigned long )d->size * sizeof(char *)));
#line 281
    d->val = (char **)tmp___1;
#line 282
    tmp___2 = mem_double((void *)d->key, (int )((unsigned long )d->size * sizeof(char *)));
#line 282
    d->key = (char **)tmp___2;
#line 283
    tmp___3 = mem_double((void *)d->hash, (int )((unsigned long )d->size * sizeof(unsigned int )));
#line 283
    d->hash = (unsigned int *)tmp___3;
    }
#line 284
    if ((unsigned long )d->val == (unsigned long )((void *)0)) {
#line 286
      return (-1);
    } else
#line 284
    if ((unsigned long )d->key == (unsigned long )((void *)0)) {
#line 286
      return (-1);
    } else
#line 284
    if ((unsigned long )d->hash == (unsigned long )((void *)0)) {
#line 286
      return (-1);
    }
#line 289
    d->size *= 2;
  }
#line 293
  i = 0;
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 293
    if (! (i < d->size)) {
#line 293
      goto while_break___0;
    }
#line 294
    if ((unsigned long )*(d->key + i) == (unsigned long )((void *)0)) {
#line 296
      goto while_break___0;
    }
#line 293
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 300
  *(d->key + i) = xstrdup(key);
  }
#line 301
  if (val) {
    {
#line 301
    tmp___4 = xstrdup(val);
#line 301
    *(d->val + i) = tmp___4;
    }
  } else {
#line 301
    *(d->val + i) = (char *)((void *)0);
  }
#line 302
  *(d->hash + i) = hash;
#line 303
  (d->n) ++;
#line 304
  return (0);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.c"
void dictionary_unset(dictionary *d , char *key ) 
{ 
  unsigned int hash ;
  int i ;
  int tmp ;

  {
#line 323
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 324
    return;
  }
  {
#line 327
  hash = dictionary_hash(key);
#line 328
  i = 0;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < d->size)) {
#line 328
      goto while_break;
    }
#line 329
    if ((unsigned long )*(d->key + i) == (unsigned long )((void *)0)) {
#line 330
      goto __Cont;
    }
#line 332
    if (hash == *(d->hash + i)) {
      {
#line 334
      tmp = strcmp((char const   *)key, (char const   *)*(d->key + i));
      }
#line 334
      if (! tmp) {
#line 336
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ 
#line 328
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if (i >= d->size) {
#line 342
    return;
  }
  {
#line 344
  free((void *)*(d->key + i));
#line 345
  *(d->key + i) = (char *)((void *)0);
  }
#line 346
  if ((unsigned long )*(d->val + i) != (unsigned long )((void *)0)) {
    {
#line 347
    free((void *)*(d->val + i));
#line 348
    *(d->val + i) = (char *)((void *)0);
    }
  }
#line 350
  *(d->hash + i) = 0U;
#line 351
  (d->n) --;
#line 352
  return;
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/dictionary.c"
void dictionary_dump(dictionary *d , FILE *out ) 
{ 
  int i ;
  char const   *tmp ;

  {
#line 371
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 371
    return;
  } else
#line 371
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 371
    return;
  }
#line 372
  if (d->n < 1) {
    {
#line 373
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"empty dictionary\n");
    }
#line 374
    return;
  }
#line 376
  i = 0;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < d->size)) {
#line 376
      goto while_break;
    }
#line 377
    if (*(d->key + i)) {
#line 378
      if (*(d->val + i)) {
#line 378
        tmp = (char const   *)*(d->val + i);
      } else {
#line 378
        tmp = "UNDEF";
      }
      {
#line 378
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%20s\t[%s]\n",
              *(d->key + i), tmp);
      }
    }
#line 376
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
address_family *addr_fams[6] ;
#line 141
address_family addr_inet ;
#line 142
address_family addr_inet6 ;
#line 143
address_family addr_ipx ;
#line 144
address_family addr_can ;
#line 145
address_family addr_meta ;
#line 4 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/addrfam.c"
address_family *addr_fams[6]  = {      & addr_inet,      & addr_inet6,      & addr_ipx,      & addr_can, 
        & addr_meta,      (address_family *)((void *)0)};
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.h"
unsigned int mylinuxver(void) ;
#line 2
unsigned int mylinux(int maj___0 , int rev___0 , int min___0 ) ;
#line 5
int execable(char *program ) ;
#line 9
int _iface_has(char *iface , char *delims ) ;
#line 10
void cleanup_hwaddress(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                       int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ) ;
#line 11
void make_hex_address(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                      int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ) ;
#line 12
void compute_v4_addr(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                     int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ) ;
#line 13
void compute_v4_mask(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                     int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ) ;
#line 14
void compute_v4_broadcast(interface_defn *ifd , char **pparam , int argc  __attribute__((__unused__)) ,
                          char **argv  __attribute__((__unused__)) ) ;
#line 15
void set_preferred_lft(interface_defn *ifd , char **pparam , int argc  __attribute__((__unused__)) ,
                       char **argv  __attribute__((__unused__)) ) ;
#line 16
void get_token(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
               int argc , char **argv ) ;
#line 17
void to_decimal(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                int argc , char **argv ) ;
#line 18
void map_value(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
               int argc , char **argv ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
static int maj  =    -1;
#line 12 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
static int rev  =    0;
#line 12 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
static int min  =    0;
#line 10 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
unsigned int mylinuxver(void) 
{ 
  struct utsname u ;
  char *pch ;
  unsigned int tmp ;

  {
#line 14
  if (maj == -1) {
    {
#line 17
    uname(& u);
#line 18
    maj = atoi((char const   *)(u.release));
#line 19
    pch = strchr((char const   *)(u.release), '.');
    }
#line 20
    if (pch) {
      {
#line 21
      rev = atoi((char const   *)(pch + 1));
#line 22
      pch = strchr((char const   *)(pch + 1), '.');
      }
#line 23
      if (pch) {
        {
#line 24
        min = atoi((char const   *)(pch + 1));
        }
      }
    }
  }
  {
#line 29
  tmp = mylinux(maj, rev, min);
  }
#line 29
  return (tmp);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
unsigned int mylinux(int maj___0 , int rev___0 , int min___0 ) 
{ 


  {
#line 34
  return ((unsigned int )((min___0 | (rev___0 << 10)) | (maj___0 << 13)));
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
int _iface_has(char *iface , char *delims ) 
{ 
  char _iface[80] ;
  void *token ;
  char *tmp ;

  {
  {
#line 46
  strncpy((char */* __restrict  */)(_iface), (char const   */* __restrict  */)iface,
          sizeof(_iface));
#line 47
  _iface[sizeof(_iface) - 1UL] = (char)0;
#line 48
  strtok((char */* __restrict  */)(_iface), (char const   */* __restrict  */)delims);
#line 49
  tmp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)delims);
#line 49
  token = (void *)tmp;
  }
#line 50
  return ((unsigned long )token != (unsigned long )((void *)0));
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
int execable(char *program ) 
{ 
  struct stat buf ;
  int tmp ;

  {
  {
#line 57
  tmp = stat((char const   */* __restrict  */)program, (struct stat */* __restrict  */)(& buf));
  }
#line 57
  if (0 == tmp) {
#line 58
    if ((buf.st_mode & 61440U) == 32768U) {
#line 58
      if (64U & buf.st_mode) {
#line 59
        return (1);
      }
    }
  }
#line 61
  return (0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
void cleanup_hwaddress(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                       int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ) 
{ 
  char *rest ;
  char *space ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 66
  rest = *pparam;
#line 68
  tmp = strchr((char const   *)rest, ' ');
#line 68
  space = tmp;
  }
#line 70
  if ((unsigned long )space == (unsigned long )((void *)0)) {
#line 71
    return;
  }
  {
#line 73
  *space = (char )'\000';
#line 74
  tmp___1 = strcasecmp((char const   *)rest, "ether");
  }
#line 74
  if (tmp___1 == 0) {
    {
#line 76
    tmp___0 = strlen((char const   *)(space + 1));
#line 76
    memmove((void *)rest, (void const   *)(space + 1), tmp___0 + 1UL);
    }
  } else {
    {
#line 74
    tmp___2 = strcasecmp((char const   *)rest, "ax25");
    }
#line 74
    if (tmp___2 == 0) {
      {
#line 76
      tmp___0 = strlen((char const   *)(space + 1));
#line 76
      memmove((void *)rest, (void const   *)(space + 1), tmp___0 + 1UL);
      }
    } else {
      {
#line 74
      tmp___3 = strcasecmp((char const   *)rest, "ARCnet");
      }
#line 74
      if (tmp___3 == 0) {
        {
#line 76
        tmp___0 = strlen((char const   *)(space + 1));
#line 76
        memmove((void *)rest, (void const   *)(space + 1), tmp___0 + 1UL);
        }
      } else {
        {
#line 74
        tmp___4 = strcasecmp((char const   *)rest, "netrom");
        }
#line 74
        if (tmp___4 == 0) {
          {
#line 76
          tmp___0 = strlen((char const   *)(space + 1));
#line 76
          memmove((void *)rest, (void const   *)(space + 1), tmp___0 + 1UL);
          }
        } else {
#line 78
          *space = (char )' ';
        }
      }
    }
  }
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
void make_hex_address(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                      int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ) 
{ 
  char addrcomp[4] ;
  int maxlen ;
  size_t tmp ;
  int ret ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 85
  tmp = strlen("0000:0000");
#line 85
  maxlen = (int )tmp;
#line 87
  tmp___0 = sscanf((char const   */* __restrict  */)*pparam, (char const   */* __restrict  */)"%3hhu.%3hhu.%3hhu.%3hhu",
                   & addrcomp[0], & addrcomp[1], & addrcomp[2], & addrcomp[3]);
#line 87
  ret = tmp___0;
  }
#line 90
  if (ret != 4) {
#line 91
    return;
  }
  {
#line 93
  tmp___1 = realloc((void *)*pparam, (size_t )(maxlen + 1));
#line 93
  *pparam = (char *)tmp___1;
  }
#line 94
  if ((unsigned long )*pparam == (unsigned long )((void *)0)) {
#line 95
    return;
  }
  {
#line 96
  snprintf((char */* __restrict  */)*pparam, (size_t )(maxlen + 1), (char const   */* __restrict  */)"%.2hhx%.2hhx:%.2hhx%.2hhx",
           (int )addrcomp[0], (int )addrcomp[1], (int )addrcomp[2], (int )addrcomp[3]);
  }
#line 97
  return;
}
}
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
void compute_v4_addr(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                     int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ) 
{ 
  char s[34] ;
  char *token ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 104
  strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)*pparam,
          sizeof(s));
#line 105
  s[sizeof(s) - 1UL] = (char)0;
#line 107
  tmp = strtok((char */* __restrict  */)(s), (char const   */* __restrict  */)"/");
#line 107
  token = tmp;
  }
#line 108
  if (! token) {
#line 109
    return;
  }
  {
#line 111
  tmp___0 = strlen((char const   *)token);
#line 111
  tmp___1 = realloc((void *)*pparam, tmp___0 + 1UL);
#line 111
  *pparam = (char *)tmp___1;
  }
#line 112
  if ((unsigned long )*pparam == (unsigned long )((void *)0)) {
#line 113
    return;
  }
  {
#line 114
  strcpy((char */* __restrict  */)*pparam, (char const   */* __restrict  */)token);
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
void compute_v4_mask(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                     int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ) 
{ 
  char s[34] ;
  char *token ;
  char *tmp ;
  uint8_t addr[sizeof(struct in_addr )] ;
  struct in_addr mask ;
  int tmp___0 ;
  int maskwidth ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 120
  strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)*pparam,
          sizeof(s));
#line 121
  s[sizeof(s) - 1UL] = (char)0;
#line 123
  tmp = strtok((char */* __restrict  */)(s), (char const   */* __restrict  */)"/");
#line 123
  token = tmp;
  }
#line 124
  if (! token) {
#line 125
    return;
  }
  {
#line 129
  tmp___0 = inet_pton(2, (char const   */* __restrict  */)token, (void */* __restrict  */)(& addr));
  }
#line 129
  if (tmp___0 != 1) {
#line 130
    return;
  }
  {
#line 131
  token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
#line 132
  maskwidth = -1;
  }
#line 133
  if (! token) {
#line 134
    if ((int )addr[0] <= 127) {
#line 135
      maskwidth = 8;
    } else
#line 136
    if ((int )addr[0] >= 128) {
#line 136
      if ((int )addr[0] <= 191) {
#line 137
        maskwidth = 16;
      } else {
#line 136
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 138
    if ((int )addr[0] >= 192) {
#line 138
      if ((int )addr[0] <= 223) {
#line 139
        maskwidth = 24;
      } else {
#line 141
        maskwidth = 32;
      }
    } else {
#line 141
      maskwidth = 32;
    }
  } else {
    {
#line 144
    tmp___1 = inet_pton(2, (char const   */* __restrict  */)token, (void */* __restrict  */)(& mask));
    }
    {
#line 145
    if (tmp___1 == -1) {
#line 145
      goto case_neg_1;
    }
#line 148
    if (tmp___1 == 0) {
#line 148
      goto case_0;
    }
#line 144
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 146
    return;
    case_0: /* CIL Label */ 
    {
#line 149
    tmp___2 = sscanf((char const   */* __restrict  */)token, (char const   */* __restrict  */)"%d",
                     & maskwidth);
    }
#line 149
    if (tmp___2 != 1) {
#line 150
      return;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 153
  if (maskwidth != -1) {
    {
#line 154
    mask.s_addr = htonl((uint32_t )(~ ((1L << (32 - maskwidth)) - 1L)));
    }
  }
  {
#line 157
  tmp___3 = inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(s),
                      (socklen_t )sizeof(s));
  }
#line 157
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 158
    return;
  }
  {
#line 159
  tmp___4 = strlen((char const   *)(s));
#line 159
  tmp___5 = realloc((void *)*pparam, tmp___4 + 1UL);
#line 159
  *pparam = (char *)tmp___5;
  }
#line 160
  if ((unsigned long )*pparam == (unsigned long )((void *)0)) {
#line 161
    return;
  }
  {
#line 162
  strcpy((char */* __restrict  */)*pparam, (char const   */* __restrict  */)(s));
  }
#line 163
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
void compute_v4_broadcast(interface_defn *ifd , char **pparam , int argc  __attribute__((__unused__)) ,
                          char **argv  __attribute__((__unused__)) ) 
{ 
  int tmp ;
  int tmp___0 ;
  struct in_addr addr ;
  struct in_addr mask ;
  char *s ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int r ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  uint32_t tmp___9 ;
  char buffer[17] ;
  char const   *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;

  {
  {
#line 168
  tmp = strcmp((char const   *)*pparam, "+");
  }
#line 168
  if (tmp) {
    {
#line 168
    tmp___0 = strcmp((char const   *)*pparam, "-");
    }
#line 168
    if (tmp___0) {
#line 169
      return;
    }
  }
  {
#line 174
  tmp___1 = strlen("address");
#line 174
  tmp___2 = get_var((char *)"address", tmp___1, ifd);
#line 174
  s = tmp___2;
  }
#line 175
  if (! s) {
#line 176
    return;
  }
  {
#line 177
  tmp___3 = inet_pton(2, (char const   */* __restrict  */)s, (void */* __restrict  */)(& addr));
#line 177
  r = tmp___3;
#line 178
  free((void *)s);
  }
#line 179
  if (r != 1) {
#line 180
    return;
  }
  {
#line 182
  tmp___4 = strlen("netmask");
#line 182
  s = get_var((char *)"netmask", tmp___4, ifd);
  }
#line 183
  if (! s) {
#line 184
    return;
  }
  {
#line 185
  r = inet_pton(2, (char const   */* __restrict  */)s, (void */* __restrict  */)(& mask));
#line 186
  free((void *)s);
  }
#line 187
  if (r != 1) {
#line 188
    return;
  }
  {
#line 190
  tmp___9 = htonl(4294967294U);
  }
#line 190
  if (mask.s_addr != tmp___9) {
    {
#line 191
    tmp___5 = strcmp((char const   *)*pparam, "+");
    }
#line 191
    if (! tmp___5) {
#line 192
      addr.s_addr |= ~ mask.s_addr;
    }
    {
#line 195
    tmp___6 = strcmp((char const   *)*pparam, "-");
    }
#line 195
    if (! tmp___6) {
#line 196
      addr.s_addr &= mask.s_addr;
    }
  } else {
    {
#line 199
    tmp___7 = strcmp((char const   *)*pparam, "+");
    }
#line 199
    if (! tmp___7) {
#line 200
      addr.s_addr = 4294967295U;
    }
    {
#line 203
    tmp___8 = strcmp((char const   *)*pparam, "-");
    }
#line 203
    if (! tmp___8) {
#line 204
      addr.s_addr = (in_addr_t )0;
    }
  }
  {
#line 209
  tmp___10 = inet_ntop(2, (void const   */* __restrict  */)(& addr), (char */* __restrict  */)(buffer),
                       (socklen_t )sizeof(buffer));
  }
#line 209
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 210
    return;
  }
  {
#line 211
  tmp___11 = strlen((char const   *)(buffer));
#line 211
  tmp___12 = realloc((void *)*pparam, tmp___11 + 1UL);
#line 211
  *pparam = (char *)tmp___12;
  }
#line 212
  if ((unsigned long )*pparam == (unsigned long )((void *)0)) {
#line 213
    return;
  }
  {
#line 214
  strcpy((char */* __restrict  */)*pparam, (char const   */* __restrict  */)(buffer));
  }
#line 215
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
void set_preferred_lft(interface_defn *ifd , char **pparam , int argc  __attribute__((__unused__)) ,
                       char **argv  __attribute__((__unused__)) ) 
{ 
  char s[2] ;
  void *tmp ;
  int tmp___0 ;

  {
#line 219
  if (! ifd->real_iface) {
#line 220
    return;
  }
  {
#line 221
  tmp___0 = _iface_has(ifd->real_iface, (char *)":");
  }
#line 221
  if (tmp___0) {
    {
#line 222
    s[0] = (char )'0';
#line 222
    s[1] = (char )'\000';
#line 223
    tmp = realloc((void *)*pparam, sizeof(s));
#line 223
    *pparam = (char *)tmp;
    }
#line 224
    if ((unsigned long )*pparam == (unsigned long )((void *)0)) {
#line 225
      return;
    }
    {
#line 226
    strcpy((char */* __restrict  */)*pparam, (char const   */* __restrict  */)(s));
    }
  }
#line 228
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
void get_token(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
               int argc , char **argv ) 
{ 
  int token_no ;
  char *s ;
  char *tmp ;
  char *token ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 232
  if (argc == 0) {
#line 233
    return;
  }
#line 236
  if (argc == 1) {
#line 237
    token_no = 0;
  } else {
    {
#line 239
    token_no = atoi((char const   *)*(argv + 1));
    }
  }
  {
#line 242
  tmp = strdup((char const   *)*pparam);
#line 242
  s = tmp;
#line 243
  tmp___0 = strtok((char */* __restrict  */)s, (char const   */* __restrict  */)*(argv + 0));
#line 243
  token = tmp___0;
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (token_no > 0)) {
#line 244
      goto while_break;
    }
    {
#line 245
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)*(argv + 0));
#line 246
    token_no --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  if (token) {
    {
#line 249
    strcpy((char */* __restrict  */)*pparam, (char const   */* __restrict  */)token);
    }
  } else
#line 251
  if (argc == 3) {
    {
#line 252
    tmp___1 = strlen((char const   *)*(argv + 2));
#line 252
    tmp___2 = realloc((void *)*pparam, tmp___1 + 1UL);
#line 252
    *pparam = (char *)tmp___2;
    }
#line 253
    if ((unsigned long )*pparam == (unsigned long )((void *)0)) {
#line 254
      return;
    }
    {
#line 255
    strcpy((char */* __restrict  */)*pparam, (char const   */* __restrict  */)*(argv + 2));
    }
  }
  {
#line 258
  free((void *)s);
  }
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
void to_decimal(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
                int argc , char **argv ) 
{ 
  int base ;
  char *result ;
  long value ;
  long tmp ;
  size_t tmp___0 ;

  {
#line 263
  base = 10;
#line 265
  if (argc == 1) {
    {
#line 266
    base = atoi((char const   *)*(argv + 0));
    }
  }
  {
#line 270
  tmp = strtol((char const   */* __restrict  */)*pparam, (char **/* __restrict  */)(& result),
               base);
#line 270
  value = tmp;
  }
#line 271
  if ((unsigned long )result == (unsigned long )*pparam) {
#line 272
    return;
  }
  {
#line 274
  tmp___0 = strlen((char const   *)*pparam);
#line 274
  snprintf((char */* __restrict  */)*pparam, tmp___0 + 1UL, (char const   */* __restrict  */)"%ld",
           value);
  }
#line 275
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/archlinux.c"
void map_value(interface_defn *ifd  __attribute__((__unused__)) , char **pparam ,
               int argc , char **argv ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 279
  if (argc < 2) {
#line 280
    return;
  }
#line 283
  if (argc == 2) {
    {
#line 284
    tmp = atoi((char const   *)*pparam);
    }
#line 284
    if (tmp) {
#line 284
      tmp___3 = 1;
    } else {
      {
#line 284
      tmp___0 = strcasecmp((char const   *)*pparam, "on");
      }
#line 284
      if (tmp___0 == 0) {
#line 284
        tmp___3 = 1;
      } else {
        {
#line 284
        tmp___1 = strcasecmp((char const   *)*pparam, "true");
        }
#line 284
        if (tmp___1 == 0) {
#line 284
          tmp___3 = 1;
        } else {
          {
#line 284
          tmp___2 = strcasecmp((char const   *)*pparam, "yes");
          }
#line 284
          if (tmp___2 == 0) {
#line 284
            tmp___3 = 1;
          } else {
#line 284
            tmp___3 = 0;
          }
        }
      }
    }
#line 284
    value = tmp___3;
  }
#line 286
  if (value < argc) {
#line 286
    if ((unsigned long )*(argv + value) != (unsigned long )((void *)0)) {
      {
#line 287
      tmp___4 = strlen((char const   *)*(argv + value));
#line 287
      tmp___5 = realloc((void *)*pparam, tmp___4 + 1UL);
#line 287
      *pparam = (char *)tmp___5;
      }
#line 288
      if ((unsigned long )*pparam == (unsigned long )((void *)0)) {
#line 289
        return;
      }
      {
#line 290
      strcpy((char */* __restrict  */)*pparam, (char const   */* __restrict  */)*(argv + value));
      }
    } else {
#line 286
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 292
    tmp___6 = realloc((void *)*pparam, (size_t )1);
#line 292
    *pparam = (char *)tmp___6;
    }
#line 293
    if ((unsigned long )*pparam == (unsigned long )((void *)0)) {
#line 294
      return;
    }
#line 295
    *(*(pparam + 0)) = (char)0;
  }
#line 297
  return;
}
}
#line 830 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
variable *set_variable(char *filename , char *name , char *value , variable **var ,
                       int *n_vars , int *max_vars ) ;
#line 109
void convert_variables(char *filename , conversion *conversions , interface_defn *ifd ) ;
#line 111
interfaces_file *read_interfaces(char *filename ) ;
#line 112
interfaces_file *read_interfaces_defn(interfaces_file *defn___0 , char *filename ) ;
#line 113
allowup_defn *find_allowup(interfaces_file *defn___0 , char *name ) ;
#line 138
_Bool no_loopback ;
#line 26 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dirname)(char *__path ) ;
#line 62 "/usr/include/wordexp.h"
extern int wordexp(char const   * __restrict  __words , wordexp_t * __restrict  __pwordexp ,
                   int __flags ) ;
#line 66
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) wordfree)(wordexp_t *__wordexp ) ;
#line 254 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
#line 324
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) alphasort)(struct dirent  const  **__e1 ,
                                                                                                  struct dirent  const  **__e2 )  __attribute__((__pure__)) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
static int get_line(char **result , size_t *result_len , FILE *f , int *line ) ;
#line 14
static char *next_word(char *buf , char *word , int maxlen ) ;
#line 15
static address_family *get_address_family(address_family **af , char *name ) ;
#line 16
static method *get_method(address_family *af , char *name ) ;
#line 17
allowup_defn *get_allowup(allowup_defn **allowups , char *name ) ;
#line 19
allowup_defn *add_allow_up(char *filename , int line , allowup_defn *allow_up , char *iface_name ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
variable *set_variable(char *filename , char *name , char *value , variable **var ,
                       int *n_vars , int *max_vars ) 
{ 
  _Bool dont_update ;
  size_t len ;
  size_t tmp ;
  int j ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  variable *new_var ;
  void *tmp___5 ;

  {
  {
#line 29
  dont_update = (_Bool)0;
#line 31
  tmp = strlen((char const   *)name);
#line 31
  len = tmp;
  }
#line 33
  if ((int )*(name + (len - 1UL)) == 63) {
#line 34
    dont_update = (_Bool)1;
#line 35
    len --;
  }
  {
#line 37
  tmp___1 = strcmp((char const   *)name, "pre-up");
  }
#line 37
  if (tmp___1 != 0) {
    {
#line 37
    tmp___2 = strcmp((char const   *)name, "up");
    }
#line 37
    if (tmp___2 != 0) {
      {
#line 37
      tmp___3 = strcmp((char const   *)name, "down");
      }
#line 37
      if (tmp___3 != 0) {
        {
#line 37
        tmp___4 = strcmp((char const   *)name, "post-down");
        }
#line 37
        if (tmp___4 != 0) {
#line 39
          j = 0;
          {
#line 39
          while (1) {
            while_continue: /* CIL Label */ ;
#line 39
            if (! (j < *n_vars)) {
#line 39
              goto while_break;
            }
            {
#line 40
            tmp___0 = strncmpz(name, (*var + j)->name, len);
            }
#line 40
            if (tmp___0 == 0) {
#line 41
              if (dont_update) {
#line 42
                return ((variable *)((void *)0));
              }
#line 45
              if ((unsigned long )(*var + j)->value == (unsigned long )value) {
#line 46
                return (*var + j);
              }
              {
#line 49
              free((void *)(*var + j)->value);
#line 50
              (*var + j)->value = strdup((char const   *)value);
              }
#line 51
              if (! (*var + j)->value) {
                {
#line 52
                perror((char const   *)filename);
                }
#line 53
                return ((variable *)((void *)0));
              }
#line 56
              return (*var + j);
            }
#line 39
            j ++;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 61
  if (*n_vars >= *max_vars) {
    {
#line 63
    *max_vars += 10;
#line 64
    tmp___5 = realloc((void *)*var, sizeof(variable ) * (unsigned long )*max_vars);
#line 64
    new_var = (variable *)tmp___5;
    }
#line 65
    if ((unsigned long )new_var == (unsigned long )((void *)0)) {
      {
#line 66
      perror((char const   *)filename);
      }
#line 67
      return ((variable *)((void *)0));
    }
#line 69
    *var = new_var;
  }
  {
#line 72
  (*var + *n_vars)->name = strndup((char const   *)name, len);
#line 73
  (*var + *n_vars)->value = strdup((char const   *)value);
  }
#line 75
  if (! (*var + *n_vars)->name) {
    {
#line 76
    perror((char const   *)filename);
    }
#line 77
    return ((variable *)((void *)0));
  }
#line 80
  if (! (*var + *n_vars)->value) {
    {
#line 81
    perror((char const   *)filename);
    }
#line 82
    return ((variable *)((void *)0));
  }
#line 85
  (*n_vars) ++;
#line 86
  return (*var + (*n_vars - 1));
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
void convert_variables(char *filename , conversion *conversions , interface_defn *ifd ) 
{ 
  conversion *c ;
  variable *o ;
  variable *tmp ;
  int tmp___0 ;
  int j ;
  variable *o___0 ;
  variable *tmp___1 ;
  variable *o___1 ;
  int tmp___2 ;

  {
#line 92
  c = conversions;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (c) {
#line 92
      if (c->option) {
#line 92
        if (! c->fn) {
#line 92
          goto while_break;
        }
      } else {
#line 92
        goto while_break;
      }
    } else {
#line 92
      goto while_break;
    }
    {
#line 93
    tmp___0 = strcmp((char const   *)c->option, "iface");
    }
#line 93
    if (tmp___0 == 0) {
#line 94
      if (c->newoption) {
        {
#line 95
        tmp = set_variable(filename, c->newoption, ifd->real_iface, & ifd->option,
                           & ifd->n_options, & ifd->max_options);
#line 95
        o = tmp;
        }
#line 97
        if (o) {
          {
#line 98
          (*(c->fn))(ifd, & o->value, c->argc, c->argv);
          }
        }
#line 99
        goto __Cont;
      }
    }
#line 104
    j = 0;
    {
#line 104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 104
      if (! (j < ifd->n_options)) {
#line 104
        goto while_break___0;
      }
      {
#line 105
      tmp___2 = strcmp((char const   *)(ifd->option + j)->name, (char const   *)c->option);
      }
#line 105
      if (tmp___2 == 0) {
#line 106
        if (c->newoption) {
          {
#line 107
          tmp___1 = set_variable(filename, c->newoption, (ifd->option + j)->value,
                                 & ifd->option, & ifd->n_options, & ifd->max_options);
#line 107
          o___0 = tmp___1;
          }
#line 109
          if (o___0) {
            {
#line 110
            (*(c->fn))(ifd, & o___0->value, c->argc, c->argv);
            }
          }
        } else {
          {
#line 112
          o___1 = ifd->option + j;
#line 113
          (*(c->fn))(ifd, & o___1->value, c->argc, c->argv);
          }
        }
      }
#line 104
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 92
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
interfaces_file *read_interfaces(char *filename ) 
{ 
  interfaces_file *defn___0 ;
  void *tmp ;
  interface_defn *lo_if ;
  void *tmp___0 ;
  interface_defn __constr_expr_4 ;
  char *tmp___1 ;
  method *tmp___2 ;
  allowup_defn *tmp___3 ;
  interfaces_file *tmp___4 ;

  {
  {
#line 124
  tmp = malloc(sizeof(interfaces_file ));
#line 124
  defn___0 = (interfaces_file *)tmp;
  }
#line 125
  if ((unsigned long )defn___0 == (unsigned long )((void *)0)) {
#line 126
    return ((interfaces_file *)((void *)0));
  }
#line 128
  defn___0->allowups = (allowup_defn *)((void *)0);
#line 129
  defn___0->mappings = (mapping_defn *)((void *)0);
#line 130
  defn___0->ifaces = (interface_defn *)((void *)0);
#line 132
  if (! no_loopback) {
    {
#line 133
    tmp___0 = malloc(sizeof(interface_defn ));
#line 133
    lo_if = (interface_defn *)tmp___0;
    }
#line 134
    if (! lo_if) {
      {
#line 136
      perror((char const   *)filename);
      }
#line 137
      return ((interfaces_file *)((void *)0));
    }
    {
#line 140
    tmp___1 = strdup("lo");
#line 140
    tmp___2 = get_method(& addr_inet, (char *)"loopback");
#line 140
    __constr_expr_4.next = (interface_defn *)((void *)0);
#line 140
    __constr_expr_4.logical_iface = tmp___1;
#line 140
    __constr_expr_4.real_iface = (char *)0;
#line 140
    __constr_expr_4.address_family = & addr_inet;
#line 140
    __constr_expr_4.method = tmp___2;
#line 140
    __constr_expr_4.automatic = 0;
#line 140
    __constr_expr_4.max_options = 0;
#line 140
    __constr_expr_4.n_options = 0;
#line 140
    __constr_expr_4.option = (variable *)((void *)0);
#line 140
    *lo_if = __constr_expr_4;
#line 150
    defn___0->ifaces = lo_if;
#line 152
    tmp___3 = get_allowup(& defn___0->allowups, (char *)"auto");
#line 152
    add_allow_up((char *)"/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c",
                 152, tmp___3, lo_if->logical_iface);
    }
  }
  {
#line 154
  tmp___4 = read_interfaces_defn(defn___0, filename);
  }
#line 154
  return (tmp___4);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
static int directory_filter(struct dirent  const  *d ) 
{ 
  char const   *p ;

  {
#line 160
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 161
    return (0);
  } else
#line 160
  if ((unsigned long )(d->d_name) == (unsigned long )((void *)0)) {
#line 161
    return (0);
  }
#line 163
  p = (char const   *)(d->d_name);
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! *p) {
#line 163
      goto while_break;
    }
#line 164
    if ((int const   )*p >= 97) {
#line 164
      if (! ((int const   )*p <= 122)) {
#line 164
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 164
    if ((int const   )*p >= 65) {
#line 164
      if (! ((int const   )*p <= 90)) {
#line 164
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 164
    if ((int const   )*p >= 48) {
#line 164
      if (! ((int const   )*p <= 57)) {
#line 164
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 164
    if (! ((int const   )*p == 95)) {
#line 164
      if (! ((int const   )*p == 45)) {
#line 168
        return (0);
      }
    }
#line 163
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return (1);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
interfaces_file *read_interfaces_defn(interfaces_file *defn___0 , char *filename ) 
{ 
  FILE *f ;
  int line ;
  char *buf ;
  size_t buf_len ;
  interface_defn *currif ;
  mapping_defn *currmap ;
  enum __anonenum_currently_processing_30 currently_processing ;
  char firstword[80] ;
  char *rest ;
  void *tmp ;
  char **tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  mapping_defn **where ;
  char *filename_dup ;
  char *tmp___3 ;
  char *dir ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t l___1 ;
  size_t tmp___6 ;
  char *pattern ;
  size_t s ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t s___0 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  wordexp_t p ;
  char **w ;
  size_t i ;
  int fail ;
  int tmp___11 ;
  char *filename_dup___0 ;
  char *tmp___12 ;
  char *dir___0 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t l___2 ;
  size_t tmp___15 ;
  char *pattern___0 ;
  size_t s___1 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  size_t s___2 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  wordexp_t p___0 ;
  char **w___0 ;
  size_t i___0 ;
  int fail___0 ;
  int tmp___20 ;
  struct dirent **namelist ;
  int n ;
  int tmp___21 ;
  int j ;
  size_t ll ;
  size_t tmp___22 ;
  size_t s___3 ;
  size_t tmp___23 ;
  char *name ;
  void *tmp___24 ;
  char iface_name[80] ;
  char address_family_name[80] ;
  char method_name[80] ;
  void *tmp___25 ;
  interface_defn **where___0 ;
  allowup_defn *auto_ups ;
  allowup_defn *tmp___26 ;
  allowup_defn *tmp___27 ;
  allowup_defn *allow_ups ;
  allowup_defn *tmp___28 ;
  allowup_defn *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int i___1 ;
  size_t tmp___32 ;
  size_t l___3 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  void *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  char **opt ;
  void *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  size_t tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;

  {
  {
#line 177
  buf = (char *)((void *)0);
#line 178
  buf_len = (size_t )0;
#line 179
  currif = (interface_defn *)((void *)0);
#line 180
  currmap = (mapping_defn *)((void *)0);
#line 181
  currently_processing = (enum __anonenum_currently_processing_30 )0;
#line 185
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 186
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 187
    return ((interfaces_file *)((void *)0));
  }
#line 188
  line = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 190
    tmp___52 = get_line(& buf, & buf_len, f, & line);
    }
#line 190
    if (! tmp___52) {
#line 190
      goto while_break;
    }
    {
#line 191
    rest = next_word(buf, firstword, 80);
    }
#line 192
    if ((unsigned long )rest == (unsigned long )((void *)0)) {
#line 193
      goto while_continue;
    }
    {
#line 195
    tmp___51 = strcmp((char const   *)(firstword), "mapping");
    }
#line 195
    if (tmp___51 == 0) {
      {
#line 196
      tmp = malloc(sizeof(mapping_defn ));
#line 196
      currmap = (mapping_defn *)tmp;
      }
#line 197
      if ((unsigned long )currmap == (unsigned long )((void *)0)) {
        {
#line 198
        perror((char const   *)filename);
        }
#line 199
        return ((interfaces_file *)((void *)0));
      }
#line 201
      currmap->max_matches = 0;
#line 202
      currmap->n_matches = 0;
#line 203
      currmap->match = (char **)((void *)0);
      {
#line 205
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 205
        rest = next_word(rest, firstword, 80);
        }
#line 205
        if (! rest) {
#line 205
          goto while_break___0;
        }
#line 206
        if (currmap->max_matches == currmap->n_matches) {
          {
#line 208
          currmap->max_matches = currmap->max_matches * 2 + 1;
#line 209
          tmp___1 = realloc((void *)currmap->match, sizeof(*tmp___0) * (unsigned long )currmap->max_matches);
#line 209
          tmp___0 = (char **)tmp___1;
          }
#line 210
          if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
            {
#line 211
            currmap->max_matches = (currmap->max_matches - 1) / 2;
#line 212
            perror((char const   *)filename);
            }
#line 213
            return ((interfaces_file *)((void *)0));
          }
#line 215
          currmap->match = tmp___0;
        }
        {
#line 218
        tmp___2 = currmap->n_matches;
#line 218
        (currmap->n_matches) ++;
#line 218
        *(currmap->match + tmp___2) = strdup((char const   *)(firstword));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 220
      currmap->script = (char *)((void *)0);
#line 222
      currmap->max_mappings = 0;
#line 223
      currmap->n_mappings = 0;
#line 224
      currmap->mapping = (char **)((void *)0);
#line 226
      where = & defn___0->mappings;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 227
        if (! ((unsigned long )*where != (unsigned long )((void *)0))) {
#line 227
          goto while_break___1;
        }
#line 228
        where = & (*where)->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 230
      *where = currmap;
#line 231
      currmap->next = (mapping_defn *)((void *)0);
#line 233
      currently_processing = (enum __anonenum_currently_processing_30 )2;
    } else {
      {
#line 234
      tmp___50 = strcmp((char const   *)(firstword), "source");
      }
#line 234
      if (tmp___50 == 0) {
        {
#line 235
        tmp___3 = strdup((char const   *)filename);
#line 235
        filename_dup = tmp___3;
        }
#line 236
        if ((unsigned long )filename_dup == (unsigned long )((void *)0)) {
          {
#line 237
          perror((char const   *)filename);
          }
#line 238
          return ((interfaces_file *)((void *)0));
        }
        {
#line 240
        tmp___4 = dirname(filename_dup);
#line 240
        tmp___5 = strdup((char const   *)tmp___4);
#line 240
        dir = tmp___5;
        }
#line 241
        if ((unsigned long )dir == (unsigned long )((void *)0)) {
          {
#line 242
          perror((char const   *)filename);
          }
#line 243
          return ((interfaces_file *)((void *)0));
        }
        {
#line 245
        free((void *)filename_dup);
#line 247
        tmp___6 = strlen((char const   *)dir);
#line 247
        l___1 = tmp___6;
        }
#line 249
        if ((int )*(rest + 0) == 47) {
          {
#line 250
          tmp___7 = strlen((char const   *)rest);
#line 250
          s = tmp___7 + 1UL;
#line 251
          tmp___8 = malloc(s);
#line 251
          pattern = (char *)tmp___8;
          }
#line 252
          if ((unsigned long )pattern == (unsigned long )((void *)0)) {
            {
#line 253
            perror((char const   *)filename);
            }
#line 254
            return ((interfaces_file *)((void *)0));
          }
#line 256
          *(pattern + 0) = (char )'\000';
        } else {
          {
#line 258
          tmp___9 = strlen((char const   *)rest);
#line 258
          s___0 = (l___1 + tmp___9) + 2UL;
#line 259
          tmp___10 = malloc(s___0);
#line 259
          pattern = (char *)tmp___10;
          }
#line 260
          if ((unsigned long )pattern == (unsigned long )((void *)0)) {
            {
#line 261
            perror((char const   *)filename);
            }
#line 262
            return ((interfaces_file *)((void *)0));
          }
          {
#line 264
          *(pattern + 0) = (char )'\000';
#line 265
          strcat((char */* __restrict  */)pattern, (char const   */* __restrict  */)dir);
#line 266
          strcat((char */* __restrict  */)pattern, (char const   */* __restrict  */)"/");
          }
        }
        {
#line 268
        strcat((char */* __restrict  */)pattern, (char const   */* __restrict  */)rest);
#line 273
        tmp___11 = wordexp((char const   */* __restrict  */)pattern, (wordexp_t */* __restrict  */)(& p),
                           4);
#line 273
        fail = tmp___11;
        }
#line 274
        if (! fail) {
#line 275
          w = p.we_wordv;
#line 276
          i = (size_t )0;
          {
#line 276
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 276
            if (! (i < p.we_wordc)) {
#line 276
              goto while_break___2;
            }
#line 277
            if (verbose) {
              {
#line 278
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing file %s\n",
                      *(w + i));
              }
            }
            {
#line 280
            read_interfaces_defn(defn___0, *(w + i));
#line 276
            i ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 282
          wordfree(& p);
          }
        }
        {
#line 284
        free((void *)pattern);
#line 285
        free((void *)dir);
#line 286
        currently_processing = (enum __anonenum_currently_processing_30 )0;
        }
      } else {
        {
#line 287
        tmp___48 = strlen("source-dir");
#line 287
        tmp___49 = strncmp((char const   *)(firstword), "source-dir", tmp___48);
        }
#line 287
        if (tmp___49 == 0) {
          {
#line 288
          tmp___12 = strdup((char const   *)filename);
#line 288
          filename_dup___0 = tmp___12;
          }
#line 289
          if ((unsigned long )filename_dup___0 == (unsigned long )((void *)0)) {
            {
#line 290
            perror((char const   *)filename);
            }
#line 291
            return ((interfaces_file *)((void *)0));
          }
          {
#line 293
          tmp___13 = dirname(filename_dup___0);
#line 293
          tmp___14 = strdup((char const   *)tmp___13);
#line 293
          dir___0 = tmp___14;
          }
#line 294
          if ((unsigned long )dir___0 == (unsigned long )((void *)0)) {
            {
#line 295
            perror((char const   *)filename);
            }
#line 296
            return ((interfaces_file *)((void *)0));
          }
          {
#line 298
          free((void *)filename_dup___0);
#line 300
          tmp___15 = strlen((char const   *)dir___0);
#line 300
          l___2 = tmp___15;
          }
#line 302
          if ((int )*(rest + 0) == 47) {
            {
#line 303
            tmp___16 = strlen((char const   *)rest);
#line 303
            s___1 = tmp___16 + 1UL;
#line 304
            tmp___17 = malloc(s___1);
#line 304
            pattern___0 = (char *)tmp___17;
            }
#line 305
            if ((unsigned long )pattern___0 == (unsigned long )((void *)0)) {
              {
#line 306
              perror((char const   *)filename);
              }
#line 307
              return ((interfaces_file *)((void *)0));
            }
#line 309
            *(pattern___0 + 0) = (char )'\000';
          } else {
            {
#line 311
            tmp___18 = strlen((char const   *)rest);
#line 311
            s___2 = (l___2 + tmp___18) + 2UL;
#line 312
            tmp___19 = malloc(s___2);
#line 312
            pattern___0 = (char *)tmp___19;
            }
#line 313
            if ((unsigned long )pattern___0 == (unsigned long )((void *)0)) {
              {
#line 314
              perror((char const   *)filename);
              }
#line 315
              return ((interfaces_file *)((void *)0));
            }
            {
#line 317
            *(pattern___0 + 0) = (char )'\000';
#line 318
            strcat((char */* __restrict  */)pattern___0, (char const   */* __restrict  */)dir___0);
#line 319
            strcat((char */* __restrict  */)pattern___0, (char const   */* __restrict  */)"/");
            }
          }
          {
#line 321
          strcat((char */* __restrict  */)pattern___0, (char const   */* __restrict  */)rest);
#line 326
          tmp___20 = wordexp((char const   */* __restrict  */)pattern___0, (wordexp_t */* __restrict  */)(& p___0),
                             4);
#line 326
          fail___0 = tmp___20;
          }
#line 327
          if (! fail___0) {
#line 328
            w___0 = p___0.we_wordv;
#line 329
            i___0 = (size_t )0;
            {
#line 329
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 329
              if (! (i___0 < p___0.we_wordc)) {
#line 329
                goto while_break___3;
              }
              {
#line 331
              tmp___21 = scandir((char const   */* __restrict  */)*(w___0 + i___0),
                                 (struct dirent ***/* __restrict  */)(& namelist),
                                 & directory_filter, (int (*)(struct dirent  const  ** ,
                                                              struct dirent  const  ** ))(& alphasort));
#line 331
              n = tmp___21;
              }
#line 332
              if (n >= 0) {
#line 333
                if (verbose) {
                  {
#line 334
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading directory %s\n",
                          *(w___0 + i___0));
                  }
                }
                {
#line 338
                tmp___22 = strlen((char const   *)*(w___0 + i___0));
#line 338
                ll = tmp___22;
#line 339
                j = 0;
                }
                {
#line 339
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 339
                  if (! (j < n)) {
#line 339
                    goto while_break___4;
                  }
                  {
#line 340
                  tmp___23 = strlen((char const   *)((*(namelist + j))->d_name));
#line 340
                  s___3 = (ll + tmp___23) + 2UL;
#line 341
                  tmp___24 = malloc(s___3);
#line 341
                  name = (char *)tmp___24;
                  }
#line 342
                  if ((unsigned long )name == (unsigned long )((void *)0)) {
                    {
#line 343
                    perror((char const   *)filename);
                    }
#line 344
                    return ((interfaces_file *)((void *)0));
                  }
                  {
#line 346
                  *(name + 0) = (char )'\000';
#line 347
                  strcat((char */* __restrict  */)name, (char const   */* __restrict  */)*(w___0 + i___0));
#line 348
                  strcat((char */* __restrict  */)name, (char const   */* __restrict  */)"/");
#line 349
                  strcat((char */* __restrict  */)name, (char const   */* __restrict  */)((*(namelist + j))->d_name));
                  }
#line 351
                  if (verbose) {
                    {
#line 352
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing file %s\n",
                            name);
                    }
                  }
                  {
#line 354
                  read_interfaces_defn(defn___0, name);
#line 355
                  free((void *)name);
#line 339
                  j ++;
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
                {
#line 357
                free((void *)namelist);
                }
              }
#line 329
              i___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 360
            wordfree(& p___0);
            }
          }
          {
#line 362
          free((void *)pattern___0);
#line 363
          free((void *)dir___0);
#line 364
          currently_processing = (enum __anonenum_currently_processing_30 )0;
          }
        } else {
          {
#line 365
          tmp___47 = strcmp((char const   *)(firstword), "iface");
          }
#line 365
          if (tmp___47 == 0) {
            {
#line 371
            tmp___25 = malloc(sizeof(interface_defn ));
#line 371
            currif = (interface_defn *)tmp___25;
            }
#line 372
            if (! currif) {
              {
#line 373
              perror((char const   *)filename);
              }
#line 374
              return ((interfaces_file *)((void *)0));
            }
            {
#line 377
            rest = next_word(rest, iface_name, 80);
#line 378
            rest = next_word(rest, address_family_name, 80);
#line 379
            rest = next_word(rest, method_name, 80);
            }
#line 381
            if ((unsigned long )rest == (unsigned long )((void *)0)) {
              {
#line 382
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: too few parameters for iface line\n",
                      filename, line);
              }
#line 383
              return ((interfaces_file *)((void *)0));
            }
#line 386
            if ((int )*(rest + 0) != 0) {
              {
#line 387
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: too many parameters for iface line\n",
                      filename, line);
              }
#line 388
              return ((interfaces_file *)((void *)0));
            }
            {
#line 391
            currif->logical_iface = strdup((char const   *)(iface_name));
            }
#line 392
            if (! currif->logical_iface) {
              {
#line 393
              perror((char const   *)filename);
              }
#line 394
              return ((interfaces_file *)((void *)0));
            }
            {
#line 396
            currif->address_family = get_address_family(addr_fams, address_family_name);
            }
#line 397
            if (! currif->address_family) {
              {
#line 398
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: unknown address type\n",
                      filename, line);
              }
#line 399
              return ((interfaces_file *)((void *)0));
            }
            {
#line 401
            currif->method = get_method(currif->address_family, method_name);
            }
#line 402
            if (! currif->method) {
              {
#line 403
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: unknown method\n",
                      filename, line);
              }
#line 404
              return ((interfaces_file *)((void *)0));
            }
#line 406
            currif->automatic = 1;
#line 407
            currif->max_options = 0;
#line 408
            currif->n_options = 0;
#line 409
            currif->option = (variable *)((void *)0);
#line 412
            where___0 = & defn___0->ifaces;
            {
#line 413
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 413
              if (! ((unsigned long )*where___0 != (unsigned long )((void *)0))) {
#line 413
                goto while_break___5;
              }
#line 414
              where___0 = & (*where___0)->next;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 417
            *where___0 = currif;
#line 418
            currif->next = (interface_defn *)((void *)0);
#line 421
            currently_processing = (enum __anonenum_currently_processing_30 )1;
          } else {
            {
#line 422
            tmp___46 = strcmp((char const   *)(firstword), "auto");
            }
#line 422
            if (tmp___46 == 0) {
              {
#line 423
              tmp___26 = get_allowup(& defn___0->allowups, (char *)"auto");
#line 423
              auto_ups = tmp___26;
              }
#line 424
              if (! auto_ups) {
                {
#line 425
                perror((char const   *)filename);
                }
#line 426
                return ((interfaces_file *)((void *)0));
              }
              {
#line 428
              while (1) {
                while_continue___6: /* CIL Label */ ;
                {
#line 428
                rest = next_word(rest, firstword, 80);
                }
#line 428
                if (! rest) {
#line 428
                  goto while_break___6;
                }
                {
#line 429
                tmp___27 = add_allow_up(filename, line, auto_ups, firstword);
                }
#line 429
                if (! tmp___27) {
#line 430
                  return ((interfaces_file *)((void *)0));
                }
              }
              while_break___6: /* CIL Label */ ;
              }
#line 432
              currently_processing = (enum __anonenum_currently_processing_30 )0;
            } else {
              {
#line 433
              tmp___44 = strncmp((char const   *)(firstword), "allow-", (size_t )6);
              }
#line 433
              if (tmp___44 == 0) {
                {
#line 433
                tmp___45 = strlen((char const   *)(firstword));
                }
#line 433
                if (tmp___45 > 6UL) {
                  {
#line 434
                  tmp___28 = get_allowup(& defn___0->allowups, firstword + 6);
#line 434
                  allow_ups = tmp___28;
                  }
#line 435
                  if (! allow_ups) {
                    {
#line 436
                    perror((char const   *)filename);
                    }
#line 437
                    return ((interfaces_file *)((void *)0));
                  }
                  {
#line 439
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
                    {
#line 439
                    rest = next_word(rest, firstword, 80);
                    }
#line 439
                    if (! rest) {
#line 439
                      goto while_break___7;
                    }
                    {
#line 440
                    tmp___29 = add_allow_up(filename, line, allow_ups, firstword);
                    }
#line 440
                    if (! tmp___29) {
#line 441
                      return ((interfaces_file *)((void *)0));
                    }
                  }
                  while_break___7: /* CIL Label */ ;
                  }
#line 443
                  currently_processing = (enum __anonenum_currently_processing_30 )0;
                } else {
#line 433
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
                {
#line 446
                if ((unsigned int )currently_processing == 1U) {
#line 446
                  goto case_1;
                }
#line 480
                if ((unsigned int )currently_processing == 2U) {
#line 480
                  goto case_2;
                }
#line 507
                goto switch_default;
                case_1: /* CIL Label */ 
                {
#line 447
                tmp___30 = strcmp((char const   *)(firstword), "post-up");
                }
#line 447
                if (tmp___30 == 0) {
                  {
#line 448
                  strcpy((char */* __restrict  */)(firstword), (char const   */* __restrict  */)"up");
                  }
                }
                {
#line 450
                tmp___31 = strcmp((char const   *)(firstword), "pre-down");
                }
#line 450
                if (tmp___31 == 0) {
                  {
#line 451
                  strcpy((char */* __restrict  */)(firstword), (char const   */* __restrict  */)"down");
                  }
                }
                {
#line 456
                tmp___32 = strlen((char const   *)rest);
                }
#line 456
                if (tmp___32 == 0UL) {
                  {
#line 457
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: option with empty value\n",
                          filename, line);
                  }
#line 458
                  return ((interfaces_file *)((void *)0));
                }
                {
#line 461
                tmp___37 = strcmp((char const   *)(firstword), "pre-up");
                }
#line 461
                if (tmp___37 != 0) {
                  {
#line 461
                  tmp___38 = strcmp((char const   *)(firstword), "up");
                  }
#line 461
                  if (tmp___38 != 0) {
                    {
#line 461
                    tmp___39 = strcmp((char const   *)(firstword), "down");
                    }
#line 461
                    if (tmp___39 != 0) {
                      {
#line 461
                      tmp___40 = strcmp((char const   *)(firstword), "post-down");
                      }
#line 461
                      if (tmp___40 != 0) {
#line 462
                        i___1 = 0;
                        {
#line 462
                        while (1) {
                          while_continue___8: /* CIL Label */ ;
#line 462
                          if (! (i___1 < currif->n_options)) {
#line 462
                            goto while_break___8;
                          }
                          {
#line 463
                          tmp___36 = strcmp((char const   *)(currif->option + i___1)->name,
                                            (char const   *)(firstword));
                          }
#line 463
                          if (tmp___36 == 0) {
                            {
#line 464
                            tmp___33 = strlen((char const   *)(currif->option + i___1)->value);
#line 464
                            l___3 = tmp___33;
#line 465
                            tmp___34 = strlen((char const   *)rest);
#line 465
                            tmp___35 = realloc((void *)(currif->option + i___1)->value,
                                               (l___3 + tmp___34) + 2UL);
#line 465
                            (currif->option + i___1)->value = (char *)tmp___35;
                            }
#line 466
                            if (! (currif->option + i___1)->value) {
                              {
#line 467
                              perror((char const   *)filename);
                              }
#line 468
                              return ((interfaces_file *)((void *)0));
                            }
                            {
#line 471
                            *((currif->option + i___1)->value + l___3) = (char )'\n';
#line 472
                            strcpy((char */* __restrict  */)((currif->option + i___1)->value + (l___3 + 1UL)),
                                   (char const   */* __restrict  */)rest);
#line 473
                            rest = (currif->option + i___1)->value;
                            }
                          }
#line 462
                          i___1 ++;
                        }
                        while_break___8: /* CIL Label */ ;
                        }
                      }
                    }
                  }
                }
                {
#line 478
                set_variable(filename, firstword, rest, & currif->option, & currif->n_options,
                             & currif->max_options);
                }
#line 479
                goto switch_break;
                case_2: /* CIL Label */ 
                {
#line 481
                tmp___43 = strcmp((char const   *)(firstword), "script");
                }
#line 481
                if (tmp___43 == 0) {
#line 482
                  if ((unsigned long )currmap->script != (unsigned long )((void *)0)) {
                    {
#line 483
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: duplicate script in mapping\n",
                            filename, line);
                    }
#line 484
                    return ((interfaces_file *)((void *)0));
                  } else {
                    {
#line 486
                    currmap->script = strdup((char const   *)rest);
                    }
                  }
                } else {
                  {
#line 488
                  tmp___42 = strcmp((char const   *)(firstword), "map");
                  }
#line 488
                  if (tmp___42 == 0) {
#line 489
                    if (currmap->max_mappings == currmap->n_mappings) {
                      {
#line 491
                      currmap->max_mappings = currmap->max_mappings * 2 + 1;
#line 492
                      tmp___41 = realloc((void *)currmap->mapping, sizeof(*opt) * (unsigned long )currmap->max_mappings);
#line 492
                      opt = (char **)tmp___41;
                      }
#line 493
                      if ((unsigned long )opt == (unsigned long )((void *)0)) {
                        {
#line 494
                        perror((char const   *)filename);
                        }
#line 495
                        return ((interfaces_file *)((void *)0));
                      }
#line 497
                      currmap->mapping = opt;
                    }
                    {
#line 499
                    *(currmap->mapping + currmap->n_mappings) = strdup((char const   *)rest);
#line 500
                    (currmap->n_mappings) ++;
                    }
                  } else {
                    {
#line 502
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: misplaced option\n",
                            filename, line);
                    }
#line 503
                    return ((interfaces_file *)((void *)0));
                  }
                }
#line 505
                goto switch_break;
                switch_default: /* CIL Label */ 
                {
#line 508
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: misplaced option\n",
                        filename, line);
                }
#line 509
                return ((interfaces_file *)((void *)0));
                switch_break: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 513
  tmp___53 = ferror(f);
  }
#line 513
  if (tmp___53 != 0) {
    {
#line 514
    perror((char const   *)filename);
    }
#line 515
    return ((interfaces_file *)((void *)0));
  }
  {
#line 518
  fclose(f);
#line 519
  line = -1;
  }
#line 521
  return (defn___0);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
static int get_line(char **result , size_t *result_len , FILE *f , int *line ) 
{ 
  size_t pos ;
  char *newstr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int first ;
  unsigned short const   **tmp___4 ;
  char *newstr___0 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;

  {
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    pos = (size_t )0;
    {
#line 530
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 531
      if (*result_len - pos < 10UL) {
        {
#line 532
        tmp = realloc((void *)*result, *result_len * 2UL + 80UL);
#line 532
        newstr = (char *)tmp;
        }
#line 533
        if ((unsigned long )newstr == (unsigned long )((void *)0)) {
#line 534
          return (0);
        }
#line 536
        *result = newstr;
#line 537
        *result_len = *result_len * 2UL + 80UL;
      }
      {
#line 539
      tmp___2 = fgets((char */* __restrict  */)(*result + pos), (int )(*result_len - pos),
                      (FILE */* __restrict  */)f);
      }
#line 539
      if (! tmp___2) {
        {
#line 540
        tmp___0 = ferror(f);
        }
#line 540
        if (tmp___0 == 0) {
#line 540
          if (pos == 0UL) {
#line 541
            return (0);
          }
        }
        {
#line 542
        tmp___1 = ferror(f);
        }
#line 542
        if (tmp___1 != 0) {
#line 543
          return (0);
        }
      }
      {
#line 545
      tmp___3 = strlen((char const   *)(*result + pos));
#line 545
      pos += tmp___3;
      }
#line 530
      if (pos == *result_len - 1UL) {
#line 530
        if (! ((int )*(*result + (pos - 1UL)) != 10)) {
#line 530
          goto while_break___0;
        }
      } else {
#line 530
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 548
    if (pos != 0UL) {
#line 548
      if ((int )*(*result + (pos - 1UL)) == 10) {
#line 549
        pos --;
#line 549
        *(*result + pos) = (char )'\000';
      }
    }
#line 552
    (*line) ++;
#line 554
    if (! ((int )*(*result + pos) == 0)) {
      {
#line 554
      __assert_fail("(*result)[pos] == \'\\0\'", "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c",
                    554U, "get_line");
      }
    }
#line 556
    first = 0;
    {
#line 557
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 557
      tmp___4 = __ctype_b_loc();
      }
#line 557
      if ((int const   )*(*tmp___4 + (int )*(*result + first)) & 8192) {
#line 557
        if (! *(*result + first)) {
#line 557
          goto while_break___1;
        }
      } else {
#line 557
        goto while_break___1;
      }
#line 558
      first ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 561
    memmove((void *)*result, (void const   *)(*result + first), (pos - (size_t )first) + 1UL);
#line 562
    pos -= (size_t )first;
    }
#line 528
    if (! ((int )*(*result + 0) == 35)) {
#line 528
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 566
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 566
    if (pos) {
#line 566
      if (! ((int )*(*result + (pos - 1UL)) == 92)) {
#line 566
        goto while_break___2;
      }
    } else {
#line 566
      goto while_break___2;
    }
#line 567
    pos --;
#line 567
    *(*result + pos) = (char )'\000';
    {
#line 568
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 569
      if (*result_len - pos < 10UL) {
        {
#line 570
        tmp___5 = realloc((void *)*result, *result_len * 2UL + 80UL);
#line 570
        newstr___0 = (char *)tmp___5;
        }
#line 571
        if ((unsigned long )newstr___0 == (unsigned long )((void *)0)) {
#line 572
          return (0);
        }
#line 574
        *result = newstr___0;
#line 575
        *result_len = *result_len * 2UL + 80UL;
      }
      {
#line 577
      tmp___8 = fgets((char */* __restrict  */)(*result + pos), (int )(*result_len - pos),
                      (FILE */* __restrict  */)f);
      }
#line 577
      if (! tmp___8) {
        {
#line 578
        tmp___6 = ferror(f);
        }
#line 578
        if (tmp___6 == 0) {
#line 578
          if (pos == 0UL) {
#line 579
            return (0);
          }
        }
        {
#line 580
        tmp___7 = ferror(f);
        }
#line 580
        if (tmp___7 != 0) {
#line 581
          return (0);
        }
      }
      {
#line 583
      tmp___9 = strlen((char const   *)(*result + pos));
#line 583
      pos += tmp___9;
      }
#line 568
      if (pos == *result_len - 1UL) {
#line 568
        if (! ((int )*(*result + (pos - 1UL)) != 10)) {
#line 568
          goto while_break___3;
        }
      } else {
#line 568
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 586
    if (pos != 0UL) {
#line 586
      if ((int )*(*result + (pos - 1UL)) == 10) {
#line 587
        pos --;
#line 587
        *(*result + pos) = (char )'\000';
      }
    }
#line 590
    (*line) ++;
#line 592
    if (! ((int )*(*result + pos) == 0)) {
      {
#line 592
      __assert_fail("(*result)[pos] == \'\\0\'", "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c",
                    592U, "get_line");
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 595
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 595
    if (pos) {
      {
#line 595
      tmp___10 = __ctype_b_loc();
      }
#line 595
      if (! ((int const   )*(*tmp___10 + (int )*(*result + (pos - 1UL))) & 8192)) {
#line 595
        goto while_break___4;
      }
    } else {
#line 595
      goto while_break___4;
    }
#line 596
    pos --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 598
  *(*result + pos) = (char )'\000';
#line 600
  return (1);
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
static char *next_word(char *buf , char *word , int maxlen ) 
{ 
  char *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 605
  if (! buf) {
#line 606
    return ((char *)((void *)0));
  }
#line 607
  if (! *buf) {
#line 608
    return ((char *)((void *)0));
  }
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 610
    tmp___1 = __ctype_b_loc();
    }
#line 610
    if ((int const   )*(*tmp___1 + (int )*buf) & 8192) {
#line 610
      goto while_break;
    } else
#line 610
    if (! *buf) {
#line 610
      goto while_break;
    }
#line 611
    tmp___0 = maxlen;
#line 611
    maxlen --;
#line 611
    if (tmp___0 > 1) {
#line 612
      tmp = word;
#line 612
      word ++;
#line 612
      *tmp = *buf;
    }
#line 613
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  if (maxlen > 0) {
#line 616
    *word = (char )'\000';
  }
  {
#line 618
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 618
    tmp___2 = __ctype_b_loc();
    }
#line 618
    if ((int const   )*(*tmp___2 + (int )*buf) & 8192) {
#line 618
      if (! *buf) {
#line 618
        goto while_break___0;
      }
    } else {
#line 618
      goto while_break___0;
    }
#line 619
    buf ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 621
  return (buf);
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
static address_family *get_address_family(address_family **af , char *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 627
  i = 0;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! *(af + i)) {
#line 627
      goto while_break;
    }
    {
#line 628
    tmp = strcmp((char const   *)(*(af + i))->name, (char const   *)name);
    }
#line 628
    if (tmp == 0) {
#line 629
      return (*(af + i));
    }
#line 627
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  return ((address_family *)((void *)0));
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
static method *get_method(address_family *af , char *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 638
  i = 0;
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (! (i < af->n_methods)) {
#line 638
      goto while_break;
    }
    {
#line 639
    tmp = strcmp((char const   *)(af->method + i)->name, (char const   *)name);
    }
#line 639
    if (tmp == 0) {
#line 640
      return (af->method + i);
    }
#line 638
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  return ((method *)((void *)0));
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
allowup_defn *get_allowup(allowup_defn **allowups , char *name ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 648
    if (! *allowups) {
#line 648
      goto while_break;
    }
    {
#line 649
    tmp = strcmp((char const   *)(*allowups)->when, (char const   *)name);
    }
#line 649
    if (tmp == 0) {
#line 650
      goto while_break;
    }
#line 648
    allowups = & (*allowups)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  if ((unsigned long )*allowups == (unsigned long )((void *)0)) {
    {
#line 653
    tmp___0 = malloc(sizeof(allowup_defn ));
#line 653
    *allowups = (allowup_defn *)tmp___0;
    }
#line 654
    if ((unsigned long )*allowups == (unsigned long )((void *)0)) {
#line 655
      return ((allowup_defn *)((void *)0));
    }
    {
#line 656
    (*allowups)->when = strdup((char const   *)name);
#line 657
    (*allowups)->next = (allowup_defn *)((void *)0);
#line 658
    (*allowups)->max_interfaces = 0;
#line 659
    (*allowups)->n_interfaces = 0;
#line 660
    (*allowups)->interfaces = (char **)((void *)0);
    }
  }
#line 662
  return (*allowups);
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
allowup_defn *find_allowup(interfaces_file *defn___0 , char *name ) 
{ 
  allowup_defn *allowups ;
  int tmp ;

  {
#line 667
  allowups = defn___0->allowups;
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    if (! allowups) {
#line 668
      goto while_break;
    }
    {
#line 669
    tmp = strcmp((char const   *)allowups->when, (char const   *)name);
    }
#line 669
    if (tmp == 0) {
#line 670
      goto while_break;
    }
#line 668
    allowups = allowups->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 672
  return (allowups);
}
}
#line 675 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/config.c"
allowup_defn *add_allow_up(char *filename , int line , allowup_defn *allow_up , char *iface_name ) 
{ 
  int i ;
  int tmp ;
  char **tmp___0 ;
  void *tmp___1 ;

  {
#line 680
  i = 0;
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    if (! (i < allow_up->n_interfaces)) {
#line 680
      goto while_break;
    }
    {
#line 681
    tmp = strcmp((char const   *)iface_name, (char const   *)*(allow_up->interfaces + i));
    }
#line 681
    if (tmp == 0) {
#line 682
      return (allow_up);
    }
#line 680
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (allow_up->n_interfaces == allow_up->max_interfaces) {
    {
#line 688
    allow_up->max_interfaces *= 2;
#line 689
    (allow_up->max_interfaces) ++;
#line 690
    tmp___1 = realloc((void *)allow_up->interfaces, sizeof(*tmp___0) * (unsigned long )allow_up->max_interfaces);
#line 690
    tmp___0 = (char **)tmp___1;
    }
#line 691
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 692
      perror((char const   *)filename);
      }
#line 693
      return ((allowup_defn *)((void *)0));
    }
#line 695
    allow_up->interfaces = tmp___0;
  }
  {
#line 698
  *(allow_up->interfaces + allow_up->n_interfaces) = strdup((char const   *)iface_name);
#line 699
  (allow_up->n_interfaces) ++;
  }
#line 700
  return (allow_up);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static option_default _loopback_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static conversion _loopback_conv[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 14 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _loopback_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 15
  tmp___0 = strcmp(ifd->logical_iface, "lo");
  }
#line 15
  if (tmp___0) {
    _L: /* CIL Label */ 
    {
#line 16
    tmp = execute((char *)"ip link set dev %iface% up", ifd, exec);
    }
#line 16
    if (! tmp) {
#line 16
      return (0);
    }
  } else
#line 15
  if (! (! no_loopback)) {
#line 15
    goto _L;
  }
#line 18
  return (1);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _loopback_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 21
  tmp___0 = strcmp(ifd->logical_iface, "lo");
  }
#line 21
  if (tmp___0) {
    _L: /* CIL Label */ 
    {
#line 22
    tmp = execute((char *)"ip link set dev %iface% down", ifd, exec);
    }
#line 22
    if (! tmp) {
#line 22
      return (0);
    }
  } else
#line 21
  if (! (! no_loopback)) {
#line 21
    goto _L;
  }
#line 24
  return (1);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static option_default _static_default[2]  = {      {(char *)"broadcast", (char *)"+"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
#line 30 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static conversion _static_conv[5]  = {      {(char *)"hwaddress", (char *)((void *)0), & cleanup_hwaddress, 0, (char **)((void *)0)}, 
        {(char *)"address",
      (char *)"netmask?", & compute_v4_mask, 0, (char **)((void *)0)}, 
        {(char *)"address", (char *)((void *)0), & compute_v4_addr, 0, (char **)((void *)0)}, 
        {(char *)"broadcast",
      (char *)((void *)0), & compute_v4_broadcast, 0, (char **)((void *)0)}, 
        {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 37 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _static_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  tmp = execute((char *)"ip addr add %address%[[/%netmask%]] [[broadcast %broadcast%]] \t[[peer %pointopoint%]] [[scope %scope%]] dev %iface% label %iface%",
                ifd, exec);
  }
#line 39
  if (! tmp) {
#line 39
    return (0);
  }
  {
#line 42
  tmp___0 = execute((char *)"ip link set dev %iface% [[mtu %mtu%]] [[address %hwaddress%]] up",
                    ifd, exec);
  }
#line 42
  if (! tmp___0) {
#line 42
    return (0);
  }
  {
#line 45
  tmp___1 = execute((char *)"[[ ip route add default via %gateway% [[metric %metric%]] dev %iface% ]]",
                    ifd, exec);
  }
#line 45
  if (! tmp___1) {
#line 45
    return (0);
  }
#line 47
  return (1);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _static_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 51
  tmp = execute((char *)"[[ ip route del default via %gateway% [[metric %metric%]] dev %iface% 2>&1 1>/dev/null || true ]]",
                ifd, exec);
  }
#line 51
  if (! tmp) {
#line 51
    return (0);
  }
  {
#line 54
  tmp___0 = execute((char *)"ip -4 addr flush dev %iface% label %iface%", ifd, exec);
  }
#line 54
  if (! tmp___0) {
#line 54
    return (0);
  }
  {
#line 56
  tmp___2 = _iface_has(ifd->real_iface, (char *)":.");
  }
#line 56
  if (! tmp___2) {
    {
#line 57
    tmp___1 = execute((char *)"ip link set dev %iface% down", ifd, exec);
    }
#line 57
    if (! tmp___1) {
#line 57
      return (0);
    }
  }
#line 59
  return (1);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static option_default _manual_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 64 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static conversion _manual_conv[2]  = {      {(char *)"hwaddress", (char *)((void *)0), & cleanup_hwaddress, 0, (char **)((void *)0)}, 
        {(char *)((void *)0),
      (char *)((void *)0), (void (*)(interface_defn * , char ** , int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 68 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _manual_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 70
  tmp = execute((char *)"ip link set dev %iface% [[mtu %mtu%]] [[address %hwaddress%]] up",
                ifd, exec);
  }
#line 70
  if (! tmp) {
#line 70
    return (0);
  }
#line 72
  return (1);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _manual_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 75
  tmp___0 = _iface_has(ifd->real_iface, (char *)":.");
  }
#line 75
  if (! tmp___0) {
    {
#line 76
    tmp = execute((char *)"ip link set dev %iface% down", ifd, exec);
    }
#line 76
    if (! tmp) {
#line 76
      return (0);
    }
  }
#line 78
  return (1);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static option_default _dhcp_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 83 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static conversion _dhcp_conv[2]  = {      {(char *)"hwaddress", (char *)((void *)0), & cleanup_hwaddress, 0, (char **)((void *)0)}, 
        {(char *)((void *)0),
      (char *)((void *)0), (void (*)(interface_defn * , char ** , int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 87 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _dhcp_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 89
  tmp = execute((char *)"[[ip link set dev %iface% address %hwaddress%]]", ifd, exec);
  }
#line 89
  if (! tmp) {
#line 89
    return (0);
  }
  {
#line 91
  tmp___13 = execable((char *)"/sbin/dhclient");
  }
#line 91
  if (tmp___13) {
    {
#line 92
    tmp___0 = execute((char *)"dhclient -1 -v -pf /run/dhclient.%iface%.pid -lf /var/lib/dhcp/dhclient.%iface%.leases %iface% \t[[-e IF_METRIC=%metric%]]",
                      ifd, exec);
    }
#line 92
    if (! tmp___0) {
#line 92
      return (0);
    }
  } else {
    {
#line 94
    tmp___12 = execable((char *)"/sbin/dhclient3");
    }
#line 94
    if (tmp___12) {
      {
#line 95
      tmp___1 = execute((char *)"dhclient3 -pf /run/dhclient.%iface%.pid -lf /var/lib/dhcp3/dhclient.%iface%.leases %iface% \t[[-e IF_METRIC=%metric%]]",
                        ifd, exec);
      }
#line 95
      if (! tmp___1) {
#line 95
        return (0);
      }
    } else {
      {
#line 97
      tmp___9 = execable((char *)"/sbin/pump");
      }
#line 97
      if (tmp___9) {
        {
#line 97
        tmp___10 = mylinuxver();
#line 97
        tmp___11 = mylinux(2, 1, 100);
        }
#line 97
        if (tmp___10 >= tmp___11) {
          {
#line 98
          tmp___2 = execute((char *)"pump -i %iface% [[-h %hostname%]] [[-l %leasehours%]]",
                            ifd, exec);
          }
#line 98
          if (! tmp___2) {
#line 98
            return (0);
          }
        } else {
#line 97
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 100
        tmp___6 = execable((char *)"/sbin/udhcpc");
        }
#line 100
        if (tmp___6) {
          {
#line 100
          tmp___7 = mylinuxver();
#line 100
          tmp___8 = mylinux(2, 2, 0);
          }
#line 100
          if (tmp___7 >= tmp___8) {
            {
#line 101
            tmp___3 = execute((char *)"udhcpc -n -p /run/udhcpc.%iface%.pid -i %iface% [[-H %hostname%]]            [[-c %client%]]",
                              ifd, exec);
            }
#line 101
            if (! tmp___3) {
#line 101
              return (0);
            }
          } else {
#line 100
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 103
          tmp___5 = execable((char *)"/sbin/dhcpcd");
          }
#line 103
          if (tmp___5) {
            {
#line 104
            tmp___4 = execute((char *)"dhcpcd [[-h %hostname%]] [[-i %vendor%]] [[-I %client%]]            [[-l %leasetime%]] %iface%",
                              ifd, exec);
            }
#line 104
            if (! tmp___4) {
#line 104
              return (0);
            }
          }
        }
      }
    }
  }
#line 106
  return (1);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _dhcp_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 109
  tmp___10 = execable((char *)"/sbin/dhclient");
  }
#line 109
  if (tmp___10) {
    {
#line 110
    tmp = execute((char *)"dhclient -v -r -pf /run/dhclient.%iface%.pid -lf /var/lib/dhcp/dhclient.%iface%.leases %iface%",
                  ifd, exec);
    }
#line 110
    if (! tmp) {
#line 110
      return (0);
    }
  } else {
    {
#line 112
    tmp___9 = execable((char *)"/sbin/dhclient3");
    }
#line 112
    if (tmp___9) {
      {
#line 113
      tmp___0 = execute((char *)"dhclient3 -r -pf /run/dhclient.%iface%.pid -lf /var/lib/dhcp3/dhclient.%iface%.leases %iface%",
                        ifd, exec);
      }
#line 113
      if (! tmp___0) {
#line 113
        return (0);
      }
    } else {
      {
#line 115
      tmp___6 = execable((char *)"/sbin/pump");
      }
#line 115
      if (tmp___6) {
        {
#line 115
        tmp___7 = mylinuxver();
#line 115
        tmp___8 = mylinux(2, 1, 100);
        }
#line 115
        if (tmp___7 >= tmp___8) {
          {
#line 116
          tmp___1 = execute((char *)"pump -i %iface% -r", ifd, exec);
          }
#line 116
          if (! tmp___1) {
#line 116
            return (0);
          }
        } else {
#line 115
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 118
        tmp___5 = execable((char *)"/sbin/udhcpc");
        }
#line 118
        if (tmp___5) {
          {
#line 119
          tmp___2 = execute((char *)"kill -USR2 $(cat /run/udhcpc.%iface%.pid); kill -TERM $(cat /run/udhcpc.%iface%.pid)",
                            ifd, exec);
          }
#line 119
          if (! tmp___2) {
#line 119
            return (0);
          }
        } else {
          {
#line 121
          tmp___4 = execable((char *)"/sbin/dhcpcd");
          }
#line 121
          if (tmp___4) {
            {
#line 122
            tmp___3 = execute((char *)"dhcpcd -k %iface%", ifd, exec);
            }
#line 122
            if (! tmp___3) {
#line 122
              return (0);
            }
          }
        }
      }
    }
  }
  {
#line 124
  tmp___12 = _iface_has(ifd->real_iface, (char *)":.");
  }
#line 124
  if (! tmp___12) {
    {
#line 125
    tmp___11 = execute((char *)"ip link set dev %iface% down", ifd, exec);
    }
#line 125
    if (! tmp___11) {
#line 125
      return (0);
    }
  }
#line 127
  return (1);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static option_default _bootp_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 132 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static conversion _bootp_conv[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 135 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _bootp_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 137
  tmp = execute((char *)"bootpc [[--bootfile %bootfile%]] --dev %iface% [[--server %server%]]            [[--hwaddr %hwaddr%]] --returniffail --serverbcast",
                ifd, exec);
  }
#line 137
  if (! tmp) {
#line 137
    return (0);
  }
#line 139
  return (1);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _bootp_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 142
  tmp___1 = execable((char *)"/sbin/ip");
  }
#line 142
  if (tmp___1) {
    {
#line 142
    tmp___2 = _iface_has(ifd->real_iface, (char *)":.");
    }
#line 142
    if (tmp___2) {
#line 142
      goto _L;
    } else {
      {
#line 143
      tmp = execute((char *)"ip link set dev %iface% down", ifd, exec);
      }
#line 143
      if (! tmp) {
#line 143
        return (0);
      }
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 146
    tmp___0 = execute((char *)"ifconfig %iface% down", ifd, exec);
    }
#line 146
    if (! tmp___0) {
#line 146
      return (0);
    }
  }
#line 148
  return (1);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static option_default _tunnel_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 153 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static conversion _tunnel_conv[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 156 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _tunnel_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 158
  tmp = execute((char *)"ip tunnel add %iface% mode %mode% remote %endpoint% [[local %local%]]        [[ttl %ttl%]]",
                ifd, exec);
  }
#line 158
  if (! tmp) {
#line 158
    return (0);
  }
  {
#line 161
  tmp___0 = execute((char *)"ip link set %iface% up [[mtu %mtu%]]", ifd, exec);
  }
#line 161
  if (! tmp___0) {
#line 161
    return (0);
  }
  {
#line 164
  tmp___1 = execute((char *)"ip addr add %address%/%netmask% dev %iface% [[peer %dstaddr%]]",
                    ifd, exec);
  }
#line 164
  if (! tmp___1) {
#line 164
    return (0);
  }
  {
#line 167
  tmp___2 = execute((char *)"[[ ip route add default via %gateway% ]]", ifd, exec);
  }
#line 167
  if (! tmp___2) {
#line 167
    return (0);
  }
#line 169
  return (1);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _tunnel_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 173
  tmp = execute((char *)"ip tunnel del %iface%", ifd, exec);
  }
#line 173
  if (! tmp) {
#line 173
    return (0);
  }
#line 175
  return (1);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static option_default _ppp_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 180 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static conversion _ppp_conv[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 183 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _ppp_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 185
  tmp = execute((char *)"pon [[%provider%]] [[unit %unit%]] [[%options%]]", ifd, exec);
  }
#line 185
  if (! tmp) {
#line 185
    return (0);
  }
#line 187
  return (1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _ppp_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 191
  tmp = execute((char *)"poff [[%provider%]]", ifd, exec);
  }
#line 191
  if (! tmp) {
#line 191
    return (0);
  }
#line 193
  return (1);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static option_default _wvdial_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 198 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static conversion _wvdial_conv[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 201 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _wvdial_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 203
  tmp = execute((char *)"/sbin/start-stop-daemon --start -x /usr/bin/wvdial                       -p /run/wvdial.%iface%.pid -b -m -- [[ %provider% ]]",
                ifd, exec);
  }
#line 203
  if (! tmp) {
#line 203
    return (0);
  }
#line 205
  return (1);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _wvdial_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 209
  tmp = execute((char *)"/sbin/start-stop-daemon --stop -x /usr/bin/wvdial                       -p /run/wvdial.%iface%.pid -s 2",
                ifd, exec);
  }
#line 209
  if (! tmp) {
#line 209
    return (0);
  }
#line 211
  return (1);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static option_default _ipv4ll_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 216 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static conversion _ipv4ll_conv[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 219 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _ipv4ll_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 221
  tmp = execute((char *)"/usr/sbin/avahi-autoipd -D %iface%", ifd, exec);
  }
#line 221
  if (! tmp) {
#line 221
    return (0);
  }
#line 223
  return (1);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static int _ipv4ll_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 227
  tmp = execute((char *)"/usr/sbin/avahi-autoipd --kill %iface%", ifd, exec);
  }
#line 227
  if (! tmp) {
#line 227
    return (0);
  }
#line 229
  return (1);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
static method methods[9]  = 
#line 231
  {      {(char *)"tunnel", & _tunnel_up, & _tunnel_down, _tunnel_conv, _tunnel_default}, 
        {(char *)"wvdial",
      & _wvdial_up, & _wvdial_down, _wvdial_conv, _wvdial_default}, 
        {(char *)"ipv4ll", & _ipv4ll_up, & _ipv4ll_down, _ipv4ll_conv, _ipv4ll_default}, 
        {(char *)"loopback",
      & _loopback_up, & _loopback_down, _loopback_conv, _loopback_default}, 
        {(char *)"bootp", & _bootp_up, & _bootp_down, _bootp_conv, _bootp_default}, 
        {(char *)"manual", & _manual_up, & _manual_down, _manual_conv, _manual_default}, 
        {(char *)"dhcp",
      & _dhcp_up, & _dhcp_down, _dhcp_conv, _dhcp_default}, 
        {(char *)"static", & _static_up, & _static_down, _static_conv, _static_default}, 
        {(char *)"ppp",
      & _ppp_up, & _ppp_down, _ppp_conv, _ppp_default}};
#line 279 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet.c"
address_family addr_inet  =    {(char *)"inet", (int )(sizeof(methods) / sizeof(struct method )), methods};
#line 8 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static option_default _auto_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static conversion _auto_conv[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 14 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _auto_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 16
  tmp = execute((char *)"modprobe -q net-pf-10 > /dev/null 2>&1 || true # ignore failure.",
                ifd, exec);
  }
#line 16
  if (! tmp) {
#line 16
    return (0);
  }
  {
#line 19
  tmp___0 = execute((char *)"[[sysctl -q -e -w net.ipv6.conf.%iface/.//%.use_tempaddr=%privext%]]",
                    ifd, exec);
  }
#line 19
  if (! tmp___0) {
#line 19
    return (0);
  }
  {
#line 22
  tmp___1 = execute((char *)"sysctl -q -e -w net.ipv6.conf.%iface/.//%.accept_ra=1",
                    ifd, exec);
  }
#line 22
  if (! tmp___1) {
#line 22
    return (0);
  }
  {
#line 25
  tmp___2 = execute((char *)"sysctl -q -e -w net.ipv6.conf.%iface/.//%.autoconf=1",
                    ifd, exec);
  }
#line 25
  if (! tmp___2) {
#line 25
    return (0);
  }
  {
#line 28
  tmp___3 = execute((char *)"ip link set dev %iface% up", ifd, exec);
  }
#line 28
  if (! tmp___3) {
#line 28
    return (0);
  }
  {
#line 30
  tmp___5 = var_true((char *)"dhcp", ifd);
  }
#line 30
  if (tmp___5) {
    {
#line 30
    tmp___6 = execable((char *)"/sbin/dhclient");
    }
#line 30
    if (tmp___6) {
      {
#line 31
      tmp___4 = execute((char *)"dhclient -1 -6 -S -pf /run/dhclient6.%iface%.pid -lf /var/lib/dhcp/dhclient6.%iface%.leases %iface%",
                        ifd, exec);
      }
#line 31
      if (! tmp___4) {
#line 31
        return (0);
      }
    }
  }
#line 33
  return (1);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _auto_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 37
  tmp = execute((char *)"ip -6 addr flush dev %iface% scope global", ifd, exec);
  }
#line 37
  if (! tmp) {
#line 37
    return (0);
  }
  {
#line 39
  tmp___1 = _iface_has(ifd->real_iface, (char *)":.");
  }
#line 39
  if (! tmp___1) {
    {
#line 40
    tmp___0 = execute((char *)"ip link set dev %iface% down", ifd, exec);
    }
#line 40
    if (! tmp___0) {
#line 40
      return (0);
    }
  }
#line 42
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static option_default _loopback_default___0[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 47 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static conversion _loopback_conv___0[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 50 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _loopback_up___0(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 51
  tmp___0 = strcmp(ifd->logical_iface, "lo");
  }
#line 51
  if (tmp___0) {
    _L: /* CIL Label */ 
    {
#line 52
    tmp = execute((char *)"-ip link set dev %iface% up 2>/dev/null", ifd, exec);
    }
#line 52
    if (! tmp) {
#line 52
      return (0);
    }
  } else
#line 51
  if (! (! no_loopback)) {
#line 51
    goto _L;
  }
  {
#line 54
  tmp___2 = strcmp(ifd->logical_iface, "lo");
  }
#line 54
  if (tmp___2) {
    _L___0: /* CIL Label */ 
    {
#line 55
    tmp___1 = execute((char *)"-ip addr add dev %iface% ::1 2>/dev/null", ifd, exec);
    }
#line 55
    if (! tmp___1) {
#line 55
      return (0);
    }
  } else
#line 54
  if (! (! no_loopback)) {
#line 54
    goto _L___0;
  }
#line 57
  return (1);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _loopback_down___0(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 60
  tmp___0 = strcmp(ifd->logical_iface, "lo");
  }
#line 60
  if (tmp___0) {
    _L: /* CIL Label */ 
    {
#line 61
    tmp = execute((char *)"-ip addr del dev %iface% ::1 2>/dev/null", ifd, exec);
    }
#line 61
    if (! tmp) {
#line 61
      return (0);
    }
  } else
#line 60
  if (! (! no_loopback)) {
#line 60
    goto _L;
  }
  {
#line 63
  tmp___2 = strcmp(ifd->logical_iface, "lo");
  }
#line 63
  if (tmp___2) {
    _L___0: /* CIL Label */ 
    {
#line 64
    tmp___1 = execute((char *)"-ip link set dev %iface% down 2>/dev/null", ifd, exec);
    }
#line 64
    if (! tmp___1) {
#line 64
      return (0);
    }
  } else
#line 63
  if (! (! no_loopback)) {
#line 63
    goto _L___0;
  }
#line 66
  return (1);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static option_default _static_default___0[5]  = {      {(char *)"autoconf", (char *)"0"}, 
        {(char *)"preferred-lifetime", (char *)""}, 
        {(char *)"dad-attempts", (char *)"60"}, 
        {(char *)"dad-interval", (char *)"0.1"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
#line 75 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static char *__constr_expr_5[3]  = {      (char *)"/",      (char *)"1",      (char *)""};
#line 75 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static char *__constr_expr_6[3]  = {      (char *)"/",      (char *)"0",      (char *)""};
#line 75 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static conversion _static_conv___0[5]  = {      {(char *)"hwaddress", (char *)((void *)0), & cleanup_hwaddress, 0, (char **)((void *)0)}, 
        {(char *)"preferred-lifetime",
      (char *)((void *)0), & set_preferred_lft, 0, (char **)((void *)0)}, 
        {(char *)"address", (char *)"netmask?", & get_token, 3, __constr_expr_5}, 
        {(char *)"address", (char *)((void *)0), & get_token, 3, __constr_expr_6}, 
        {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 82 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _static_up___0(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 84
  tmp = execute((char *)"modprobe -q net-pf-10 > /dev/null 2>&1 || true # ignore failure.",
                ifd, exec);
  }
#line 84
  if (! tmp) {
#line 84
    return (0);
  }
  {
#line 87
  tmp___0 = execute((char *)"[[sysctl -q -e -w net.ipv6.conf.%iface/.//%.use_tempaddr=%privext%]]",
                    ifd, exec);
  }
#line 87
  if (! tmp___0) {
#line 87
    return (0);
  }
  {
#line 90
  tmp___1 = execute((char *)"[[sysctl -q -e -w net.ipv6.conf.%iface/.//%.accept_ra=%accept_ra%]]",
                    ifd, exec);
  }
#line 90
  if (! tmp___1) {
#line 90
    return (0);
  }
  {
#line 93
  tmp___2 = execute((char *)"[[sysctl -q -e -w net.ipv6.conf.%iface/.//%.autoconf=%autoconf%]]",
                    ifd, exec);
  }
#line 93
  if (! tmp___2) {
#line 93
    return (0);
  }
  {
#line 96
  tmp___3 = execute((char *)"ip link set dev %iface% [[mtu %mtu%]] [[address %hwaddress%]] up",
                    ifd, exec);
  }
#line 96
  if (! tmp___3) {
#line 96
    return (0);
  }
  {
#line 99
  tmp___4 = execute((char *)"ip -6 addr add %address%[[/%netmask%]] [[scope %scope%]] dev %iface% [[preferred_lft %preferred-lifetime%]]",
                    ifd, exec);
  }
#line 99
  if (! tmp___4) {
#line 99
    return (0);
  }
  {
#line 102
  tmp___5 = execute((char *)"[[ ip -6 route add default via %gateway% dev %iface% ]]",
                    ifd, exec);
  }
#line 102
  if (! tmp___5) {
#line 102
    return (0);
  }
  {
#line 104
  tmp___7 = execable((char *)"/lib/ifupdown/settle-dad.sh");
  }
#line 104
  if (tmp___7) {
    {
#line 105
    tmp___6 = execute((char *)"/lib/ifupdown/settle-dad.sh", ifd, exec);
    }
#line 105
    if (! tmp___6) {
#line 105
      return (0);
    }
  }
#line 107
  return (1);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _static_down___0(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 111
  tmp = execute((char *)"ip -6 addr flush dev %iface% scope global", ifd, exec);
  }
#line 111
  if (! tmp) {
#line 111
    return (0);
  }
  {
#line 113
  tmp___1 = _iface_has(ifd->real_iface, (char *)":.");
  }
#line 113
  if (! tmp___1) {
    {
#line 114
    tmp___0 = execute((char *)"ip link set dev %iface% down", ifd, exec);
    }
#line 114
    if (! tmp___0) {
#line 114
      return (0);
    }
  }
#line 116
  return (1);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static option_default _manual_default___0[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 121 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static conversion _manual_conv___0[2]  = {      {(char *)"hwaddress", (char *)((void *)0), & cleanup_hwaddress, 0, (char **)((void *)0)}, 
        {(char *)((void *)0),
      (char *)((void *)0), (void (*)(interface_defn * , char ** , int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 125 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _manual_up___0(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 127
  tmp = execute((char *)"ip link set dev %iface% [[mtu %mtu%]] [[address %hwaddress%]] up",
                ifd, exec);
  }
#line 127
  if (! tmp) {
#line 127
    return (0);
  }
#line 129
  return (1);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _manual_down___0(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 132
  tmp___0 = _iface_has(ifd->real_iface, (char *)":.");
  }
#line 132
  if (! tmp___0) {
    {
#line 133
    tmp = execute((char *)"ip link set dev %iface% down", ifd, exec);
    }
#line 133
    if (! tmp) {
#line 133
      return (0);
    }
  }
#line 135
  return (1);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static option_default _dhcp_default___0[2]  = {      {(char *)"accept_ra", (char *)"0"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
#line 141 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static conversion _dhcp_conv___0[2]  = {      {(char *)"hwaddress", (char *)((void *)0), & cleanup_hwaddress, 0, (char **)((void *)0)}, 
        {(char *)((void *)0),
      (char *)((void *)0), (void (*)(interface_defn * , char ** , int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 145 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _dhcp_up___0(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 147
  tmp = execute((char *)"modprobe -q net-pf-10 > /dev/null 2>&1 || true # ignore failure.",
                ifd, exec);
  }
#line 147
  if (! tmp) {
#line 147
    return (0);
  }
  {
#line 150
  tmp___0 = execute((char *)"[[sysctl -q -e -w net.ipv6.conf.%iface/.//%.accept_ra=%accept_ra%]]",
                    ifd, exec);
  }
#line 150
  if (! tmp___0) {
#line 150
    return (0);
  }
  {
#line 153
  tmp___1 = execute((char *)"[[sysctl -q -e -w net.ipv6.conf.%iface/.//%.autoconf=%autoconf%]]",
                    ifd, exec);
  }
#line 153
  if (! tmp___1) {
#line 153
    return (0);
  }
  {
#line 156
  tmp___2 = execute((char *)"ip link set dev %iface% [[address %hwaddress%]] up",
                    ifd, exec);
  }
#line 156
  if (! tmp___2) {
#line 156
    return (0);
  }
  {
#line 158
  tmp___4 = execable((char *)"/sbin/dhclient");
  }
#line 158
  if (tmp___4) {
    {
#line 159
    tmp___3 = execute((char *)"dhclient -1 -6 -pf /run/dhclient6.%iface%.pid -lf /var/lib/dhcp/dhclient6.%iface%.leases %iface%",
                      ifd, exec);
    }
#line 159
    if (! tmp___3) {
#line 159
      return (0);
    }
  }
#line 161
  return (1);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _dhcp_down___0(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 164
  tmp___0 = execable((char *)"/sbin/dhclient");
  }
#line 164
  if (tmp___0) {
    {
#line 165
    tmp = execute((char *)"dhclient -6 -r -pf /run/dhclient6.%iface%.pid -lf /var/lib/dhcp/dhclient6.%iface%.leases %iface%",
                  ifd, exec);
    }
#line 165
    if (! tmp) {
#line 165
      return (0);
    }
  }
  {
#line 167
  tmp___2 = _iface_has(ifd->real_iface, (char *)":.");
  }
#line 167
  if (! tmp___2) {
    {
#line 168
    tmp___1 = execute((char *)"ip link set dev %iface% down", ifd, exec);
    }
#line 168
    if (! tmp___1) {
#line 168
      return (0);
    }
  }
#line 170
  return (1);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static option_default _v4tunnel_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 175 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static conversion _v4tunnel_conv[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 178 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _v4tunnel_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 180
  tmp = execute((char *)"modprobe -q net-pf-10 > /dev/null 2>&1 || true # ignore failure.",
                ifd, exec);
  }
#line 180
  if (! tmp) {
#line 180
    return (0);
  }
  {
#line 183
  tmp___0 = execute((char *)"ip tunnel add %iface% mode sit remote %endpoint% [[local %local%]]        [[ttl %ttl%]]",
                    ifd, exec);
  }
#line 183
  if (! tmp___0) {
#line 183
    return (0);
  }
  {
#line 186
  tmp___1 = execute((char *)"ip link set %iface% up [[mtu %mtu%]]", ifd, exec);
  }
#line 186
  if (! tmp___1) {
#line 186
    return (0);
  }
  {
#line 189
  tmp___2 = execute((char *)"[[ ip addr add %address%[[/%netmask%]] dev %iface% ]]",
                    ifd, exec);
  }
#line 189
  if (! tmp___2) {
#line 189
    return (0);
  }
  {
#line 192
  tmp___3 = execute((char *)"[[ ip route add %gateway% dev %iface% ]]", ifd, exec);
  }
#line 192
  if (! tmp___3) {
#line 192
    return (0);
  }
  {
#line 195
  tmp___4 = execute((char *)"[[ ip route add ::/0 via %gateway% dev %iface% ]]", ifd,
                    exec);
  }
#line 195
  if (! tmp___4) {
#line 195
    return (0);
  }
#line 197
  return (1);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _v4tunnel_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 201
  tmp = execute((char *)"ip tunnel del %iface%", ifd, exec);
  }
#line 201
  if (! tmp) {
#line 201
    return (0);
  }
#line 203
  return (1);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static option_default _6to4_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 208 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static conversion _6to4_conv[2]  = {      {(char *)"local", (char *)"hexaddress", & make_hex_address, 0, (char **)((void *)0)}, 
        {(char *)((void *)0),
      (char *)((void *)0), (void (*)(interface_defn * , char ** , int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 212 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _6to4_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 214
  tmp = execute((char *)"modprobe -q net-pf-10 > /dev/null 2>&1 || true # ignore failure.",
                ifd, exec);
  }
#line 214
  if (! tmp) {
#line 214
    return (0);
  }
  {
#line 217
  tmp___0 = execute((char *)"ip tunnel add %iface% mode sit remote any local %local%        [[ttl %ttl%]]",
                    ifd, exec);
  }
#line 217
  if (! tmp___0) {
#line 217
    return (0);
  }
  {
#line 220
  tmp___1 = execute((char *)"ip link set %iface% up [[mtu %mtu%]]", ifd, exec);
  }
#line 220
  if (! tmp___1) {
#line 220
    return (0);
  }
  {
#line 223
  tmp___2 = execute((char *)"ip addr add 2002:%hexaddress%::1/16 dev %iface%", ifd,
                    exec);
  }
#line 223
  if (! tmp___2) {
#line 223
    return (0);
  }
  {
#line 226
  tmp___3 = execute((char *)"ip route add 2000::/3 via ::192.88.99.1 dev %iface%",
                    ifd, exec);
  }
#line 226
  if (! tmp___3) {
#line 226
    return (0);
  }
#line 228
  return (1);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static int _6to4_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 232
  tmp = execute((char *)"ip -6 route flush dev %iface%", ifd, exec);
  }
#line 232
  if (! tmp) {
#line 232
    return (0);
  }
  {
#line 235
  tmp___0 = execute((char *)"ip link set dev %iface% down", ifd, exec);
  }
#line 235
  if (! tmp___0) {
#line 235
    return (0);
  }
  {
#line 238
  tmp___1 = execute((char *)"ip tunnel del %iface%", ifd, exec);
  }
#line 238
  if (! tmp___1) {
#line 238
    return (0);
  }
#line 240
  return (1);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
static method methods___0[7]  = {      {(char *)"manual", & _manual_up___0, & _manual_down___0, _manual_conv___0, _manual_default___0}, 
        {(char *)"auto",
      & _auto_up, & _auto_down, _auto_conv, _auto_default}, 
        {(char *)"dhcp", & _dhcp_up___0, & _dhcp_down___0, _dhcp_conv___0, _dhcp_default___0}, 
        {(char *)"6to4",
      & _6to4_up, & _6to4_down, _6to4_conv, _6to4_default}, 
        {(char *)"static", & _static_up___0, & _static_down___0, _static_conv___0, _static_default___0}, 
        {(char *)"v4tunnel",
      & _v4tunnel_up, & _v4tunnel_down, _v4tunnel_conv, _v4tunnel_default}, 
        {(char *)"loopback", & _loopback_up___0, & _loopback_down___0, _loopback_conv___0,
      _loopback_default___0}};
#line 280 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/inet6.c"
address_family addr_inet6  =    {(char *)"inet6", (int )(sizeof(methods___0) / sizeof(struct method )), methods___0};
#line 8 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
static option_default _static_default___1[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
static conversion _static_conv___1[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 14 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
static int _static_up___1(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 16
  tmp = execute((char *)"ipx_interface add %iface% %frame% %netnum%", ifd, exec);
  }
#line 16
  if (! tmp) {
#line 16
    return (0);
  }
#line 18
  return (1);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
static int _static_down___1(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 22
  tmp = execute((char *)"ipx_interface del %iface% %frame%", ifd, exec);
  }
#line 22
  if (! tmp) {
#line 22
    return (0);
  }
#line 24
  return (1);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
static option_default _dynamic_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 29 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
static conversion _dynamic_conv[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 32 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
static int _dynamic_up(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = execute((char *)"ipx_interface add %iface% %frame%", ifd, exec);
  }
#line 34
  if (! tmp) {
#line 34
    return (0);
  }
#line 36
  return (1);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
static int _dynamic_down(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 40
  tmp = execute((char *)"ipx_interface del %iface% %frame%", ifd, exec);
  }
#line 40
  if (! tmp) {
#line 40
    return (0);
  }
#line 42
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
static method methods___1[2]  = {      {(char *)"dynamic", & _dynamic_up, & _dynamic_down, _dynamic_conv, _dynamic_default}, 
        {(char *)"static",
      & _static_up___1, & _static_down___1, _static_conv___1, _static_default___1}};
#line 57 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/ipx.c"
address_family addr_ipx  =    {(char *)"ipx", (int )(sizeof(methods___1) / sizeof(struct method )), methods___1};
#line 140 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
address_family addr_link ;
#line 8 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static option_default _none_default[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static char *__constr_expr_7[3]  = {      (char *)".",      (char *)"0",      (char *)""};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static char *__constr_expr_8[3]  = {      (char *)".",      (char *)"1",      (char *)""};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static char *__constr_expr_9[3]  = {      (char *)":",      (char *)"0",      (char *)""};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static char *__constr_expr_10[3]  = {      (char *)":",      (char *)"0",      (char *)""};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static char *__constr_expr_11[1]  = {      (char *)"10"};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static conversion _none_conv[6]  = {      {(char *)"iface", (char *)"link", & get_token, 3, __constr_expr_7}, 
        {(char *)"iface", (char *)"vlan_id0", & get_token, 3, __constr_expr_8}, 
        {(char *)"iface", (char *)"iface0", & get_token, 3, __constr_expr_9}, 
        {(char *)"vlan_id0", (char *)"vlan_id1", & get_token, 3, __constr_expr_10}, 
        {(char *)"vlan_id1", (char *)"vlan_id", & to_decimal, 1, __constr_expr_11}, 
        {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 19 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static int _none_up(interface_defn *ifd , execfn *exec ) 
{ 


  {
#line 20
  return (1);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static int _none_down(interface_defn *ifd , execfn *exec ) 
{ 


  {
#line 23
  return (1);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
static method methods___2[1]  = {      {(char *)"none", & _none_up, & _none_down, _none_conv, _none_default}};
#line 33 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/link.c"
address_family addr_link  =    {(char *)"link", (int )(sizeof(methods___2) / sizeof(struct method )), methods___2};
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.h"
int iniparser_getnsec(dictionary *d ) ;
#line 103
char *iniparser_getsecname(dictionary *d , int n ) ;
#line 118
void iniparser_dump_ini(dictionary *d , FILE *f ) ;
#line 133
void iniparser_dump(dictionary *d , FILE *f ) ;
#line 150
char *iniparser_getstring(dictionary *d , char const   *key , char *def ) ;
#line 179
int iniparser_getint(dictionary *d , char const   *key , int notfound ) ;
#line 194
double iniparser_getdouble(dictionary *d , char *key , double notfound ) ;
#line 228
int iniparser_getboolean(dictionary *d , char const   *key , int notfound ) ;
#line 257
void iniparser_unset(dictionary *ini , char *entry ) ;
#line 271
int iniparser_find_entry(dictionary *ini , char *entry ) ;
#line 287
dictionary *iniparser_load(char const   *ininame ) ;
#line 300
void iniparser_freedict(dictionary *d ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
static char l[1025]  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
static char *strlwc(char const   *s ) 
{ 
  int i ;
  int tmp ;

  {
#line 78
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 78
    return ((char *)((void *)0));
  }
  {
#line 79
  memset((void *)(l), 0, (size_t )1025);
#line 80
  i = 0;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (*(s + i)) {
#line 81
      if (! (i < 1024)) {
#line 81
        goto while_break;
      }
    } else {
#line 81
      goto while_break;
    }
    {
#line 82
    tmp = tolower((int )*(s + i));
#line 82
    l[i] = (char )tmp;
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  l[1024] = (char)0;
#line 86
  return (l);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
static char l___0[1025]  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
static char *strstrip(char *s ) 
{ 
  char *last ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 108
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 108
    return ((char *)((void *)0));
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 110
    tmp = __ctype_b_loc();
    }
#line 110
    if ((int const   )*(*tmp + (int )*s) & 8192) {
#line 110
      if (! *s) {
#line 110
        goto while_break;
      }
    } else {
#line 110
      goto while_break;
    }
#line 110
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 111
  memset((void *)(l___0), 0, (size_t )1025);
#line 112
  strcpy((char */* __restrict  */)(l___0), (char const   */* __restrict  */)s);
#line 113
  tmp___0 = strlen((char const   *)(l___0));
#line 113
  last = l___0 + tmp___0;
  }
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    if (! ((unsigned long )last > (unsigned long )(l___0))) {
#line 114
      goto while_break___0;
    }
    {
#line 115
    tmp___1 = __ctype_b_loc();
    }
#line 115
    if (! ((int const   )*(*tmp___1 + (int )*(last - 1)) & 8192)) {
#line 116
      goto while_break___0;
    }
#line 117
    last --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 119
  *last = (char)0;
#line 120
  return (l___0);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
int iniparser_getnsec(dictionary *d ) 
{ 
  int i ;
  int nsec ;
  char *tmp ;

  {
#line 146
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 146
    return (-1);
  }
#line 147
  nsec = 0;
#line 148
  i = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i < d->size)) {
#line 148
      goto while_break;
    }
#line 149
    if ((unsigned long )*(d->key + i) == (unsigned long )((void *)0)) {
#line 150
      goto __Cont;
    }
    {
#line 151
    tmp = strchr((char const   *)*(d->key + i), ':');
    }
#line 151
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 152
      nsec ++;
    }
    __Cont: /* CIL Label */ 
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return (nsec);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
char *iniparser_getsecname(dictionary *d , int n ) 
{ 
  int i ;
  int foundsec ;
  char *tmp ;

  {
#line 177
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 177
    return ((char *)((void *)0));
  } else
#line 177
  if (n < 0) {
#line 177
    return ((char *)((void *)0));
  }
#line 178
  foundsec = 0;
#line 179
  i = 0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < d->size)) {
#line 179
      goto while_break;
    }
#line 180
    if ((unsigned long )*(d->key + i) == (unsigned long )((void *)0)) {
#line 181
      goto __Cont;
    }
    {
#line 182
    tmp = strchr((char const   *)*(d->key + i), ':');
    }
#line 182
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 183
      foundsec ++;
#line 184
      if (foundsec > n) {
#line 185
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ 
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (foundsec <= n) {
#line 189
    return ((char *)((void *)0));
  }
#line 191
  return (*(d->key + i));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
void iniparser_dump(dictionary *d , FILE *f ) 
{ 
  int i ;

  {
#line 211
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 211
    return;
  } else
#line 211
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 211
    return;
  }
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i < d->size)) {
#line 212
      goto while_break;
    }
#line 213
    if ((unsigned long )*(d->key + i) == (unsigned long )((void *)0)) {
#line 214
      goto __Cont;
    }
#line 215
    if ((unsigned long )*(d->val + i) != (unsigned long )((void *)0)) {
      {
#line 216
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"[%s]=[%s]\n",
              *(d->key + i), *(d->val + i));
      }
    } else {
      {
#line 218
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"[%s]=UNDEF\n",
              *(d->key + i));
      }
    }
    __Cont: /* CIL Label */ 
#line 212
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
void iniparser_dump_ini(dictionary *d , FILE *f ) 
{ 
  int i ;
  int j ;
  char keym[1025] ;
  int nsec ;
  char *secname ;
  int seclen ;
  size_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 243
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 243
    return;
  } else
#line 243
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 243
    return;
  }
  {
#line 245
  nsec = iniparser_getnsec(d);
  }
#line 246
  if (nsec < 1) {
#line 248
    i = 0;
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
#line 248
      if (! (i < d->size)) {
#line 248
        goto while_break;
      }
#line 249
      if ((unsigned long )*(d->key + i) == (unsigned long )((void *)0)) {
#line 250
        goto __Cont;
      }
      {
#line 251
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s = %s\n",
              *(d->key + i), *(d->val + i));
      }
      __Cont: /* CIL Label */ 
#line 248
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 253
    return;
  }
#line 255
  i = 0;
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 255
    if (! (i < nsec)) {
#line 255
      goto while_break___0;
    }
    {
#line 256
    secname = iniparser_getsecname(d, i);
#line 257
    tmp = strlen((char const   *)secname);
#line 257
    seclen = (int )tmp;
#line 258
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n[%s]\n",
            secname);
#line 259
    sprintf((char */* __restrict  */)(keym), (char const   */* __restrict  */)"%s:",
            secname);
#line 260
    j = 0;
    }
    {
#line 260
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 260
      if (! (j < d->size)) {
#line 260
        goto while_break___1;
      }
#line 261
      if ((unsigned long )*(d->key + j) == (unsigned long )((void *)0)) {
#line 262
        goto __Cont___0;
      }
      {
#line 263
      tmp___1 = strncmp((char const   *)*(d->key + j), (char const   *)(keym), (size_t )(seclen + 1));
      }
#line 263
      if (! tmp___1) {
#line 264
        if (*(d->val + j)) {
#line 264
          tmp___0 = (char const   *)*(d->val + j);
        } else {
#line 264
          tmp___0 = "";
        }
        {
#line 264
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%-30s = %s\n",
                (*(d->key + j) + seclen) + 1, tmp___0);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 260
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 255
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 271
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 272
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
char *iniparser_getstring(dictionary *d , char const   *key , char *def ) 
{ 
  char *lc_key ;
  char *sval ;

  {
#line 295
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 296
    return (def);
  } else
#line 295
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 296
    return (def);
  }
  {
#line 298
  lc_key = strlwc(key);
#line 299
  sval = dictionary_get(d, lc_key, def);
  }
#line 300
  return (sval);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
int iniparser_getint(dictionary *d , char const   *key , int notfound ) 
{ 
  char *str ;
  long tmp ;

  {
  {
#line 334
  str = iniparser_getstring(d, key, (char *)-1);
  }
#line 335
  if ((unsigned long )str == (unsigned long )((char *)-1)) {
#line 335
    return (notfound);
  }
  {
#line 336
  tmp = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
               0);
  }
#line 336
  return ((int )tmp);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
double iniparser_getdouble(dictionary *d , char *key , double notfound ) 
{ 
  char *str ;
  double tmp ;

  {
  {
#line 356
  str = iniparser_getstring(d, (char const   *)key, (char *)-1);
  }
#line 357
  if ((unsigned long )str == (unsigned long )((char *)-1)) {
#line 357
    return (notfound);
  }
  {
#line 358
  tmp = atof((char const   *)str);
  }
#line 358
  return (tmp);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
int iniparser_getboolean(dictionary *d , char const   *key , int notfound ) 
{ 
  char *c ;
  int ret ;

  {
  {
#line 398
  c = iniparser_getstring(d, key, (char *)-1);
  }
#line 399
  if ((unsigned long )c == (unsigned long )((char *)-1)) {
#line 399
    return (notfound);
  }
#line 400
  if ((int )*(c + 0) == 121) {
#line 401
    ret = 1;
  } else
#line 400
  if ((int )*(c + 0) == 89) {
#line 401
    ret = 1;
  } else
#line 400
  if ((int )*(c + 0) == 49) {
#line 401
    ret = 1;
  } else
#line 400
  if ((int )*(c + 0) == 116) {
#line 401
    ret = 1;
  } else
#line 400
  if ((int )*(c + 0) == 84) {
#line 401
    ret = 1;
  } else
#line 402
  if ((int )*(c + 0) == 110) {
#line 403
    ret = 0;
  } else
#line 402
  if ((int )*(c + 0) == 78) {
#line 403
    ret = 0;
  } else
#line 402
  if ((int )*(c + 0) == 48) {
#line 403
    ret = 0;
  } else
#line 402
  if ((int )*(c + 0) == 102) {
#line 403
    ret = 0;
  } else
#line 402
  if ((int )*(c + 0) == 70) {
#line 403
    ret = 0;
  } else {
#line 405
    ret = notfound;
  }
#line 407
  return (ret);
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
int iniparser_find_entry(dictionary *ini , char *entry ) 
{ 
  int found ;
  char *tmp ;

  {
  {
#line 427
  found = 0;
#line 428
  tmp = iniparser_getstring(ini, (char const   *)entry, (char *)-1);
  }
#line 428
  if ((unsigned long )tmp != (unsigned long )((char *)-1)) {
#line 429
    found = 1;
  }
#line 431
  return (found);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
int iniparser_set(dictionary *ini , char *entry , char *val ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 449
  tmp = strlwc((char const   *)entry);
#line 449
  tmp___0 = dictionary_set(ini, tmp, val);
  }
#line 449
  return (tmp___0);
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
void iniparser_unset(dictionary *ini , char *entry ) 
{ 
  char *tmp ;

  {
  {
#line 464
  tmp = strlwc((char const   *)entry);
#line 464
  dictionary_unset(ini, tmp);
  }
#line 465
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
static line_status iniparser_line(char *input_line , char *section , char *key , char *value ) 
{ 
  line_status sta ;
  char line[1025] ;
  int len ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 487
  tmp = strstrip(input_line);
#line 487
  strcpy((char */* __restrict  */)(line), (char const   */* __restrict  */)tmp);
#line 488
  tmp___0 = strlen((char const   *)(line));
#line 488
  len = (int )tmp___0;
#line 490
  sta = (line_status )0;
  }
#line 491
  if (len < 1) {
#line 493
    sta = (line_status )2;
  } else
#line 494
  if ((int )line[0] == 35) {
#line 496
    sta = (line_status )3;
  } else
#line 497
  if ((int )line[0] == 91) {
#line 497
    if ((int )line[len - 1] == 93) {
      {
#line 499
      sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"[%[^]]",
             section);
#line 500
      tmp___1 = strstrip(section);
#line 500
      strcpy((char */* __restrict  */)section, (char const   */* __restrict  */)tmp___1);
#line 501
      tmp___2 = strlwc((char const   *)section);
#line 501
      strcpy((char */* __restrict  */)section, (char const   */* __restrict  */)tmp___2);
#line 502
      sta = (line_status )4;
      }
    } else {
#line 497
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 503
    tmp___12 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%[^=] = \"%[^\"]\"",
                      key, value);
    }
#line 503
    if (tmp___12 == 2) {
#line 503
      goto _L___0;
    } else {
      {
#line 503
      tmp___13 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%[^=] = \'%[^\']\'",
                        key, value);
      }
#line 503
      if (tmp___13 == 2) {
#line 503
        goto _L___0;
      } else {
        {
#line 503
        tmp___14 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%[^=] = %[^;#]",
                          key, value);
        }
#line 503
        if (tmp___14 == 2) {
          _L___0: /* CIL Label */ 
          {
#line 507
          tmp___3 = strstrip(key);
#line 507
          strcpy((char */* __restrict  */)key, (char const   */* __restrict  */)tmp___3);
#line 508
          tmp___4 = strlwc((char const   *)key);
#line 508
          strcpy((char */* __restrict  */)key, (char const   */* __restrict  */)tmp___4);
#line 509
          tmp___5 = strstrip(value);
#line 509
          strcpy((char */* __restrict  */)value, (char const   */* __restrict  */)tmp___5);
#line 514
          tmp___6 = strcmp((char const   *)value, "\"\"");
          }
#line 514
          if (tmp___6) {
            {
#line 514
            tmp___7 = strcmp((char const   *)value, "\'\'");
            }
#line 514
            if (! tmp___7) {
#line 515
              *(value + 0) = (char)0;
            }
          } else {
#line 515
            *(value + 0) = (char)0;
          }
#line 517
          sta = (line_status )5;
        } else {
          {
#line 518
          tmp___10 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%[^=] = %[;#]",
                            key, value);
          }
#line 518
          if (tmp___10 == 2) {
#line 518
            goto _L;
          } else {
            {
#line 518
            tmp___11 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%[^=] %[=]",
                              key, value);
            }
#line 518
            if (tmp___11 == 2) {
              _L: /* CIL Label */ 
              {
#line 526
              tmp___8 = strstrip(key);
#line 526
              strcpy((char */* __restrict  */)key, (char const   */* __restrict  */)tmp___8);
#line 527
              tmp___9 = strlwc((char const   *)key);
#line 527
              strcpy((char */* __restrict  */)key, (char const   */* __restrict  */)tmp___9);
#line 528
              *(value + 0) = (char)0;
#line 529
              sta = (line_status )5;
              }
            } else {
#line 532
              sta = (line_status )1;
            }
          }
        }
      }
    }
  }
#line 534
  return (sta);
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
dictionary *iniparser_load(char const   *ininame ) 
{ 
  FILE *in ;
  char line[1025] ;
  char section[1025] ;
  char key[1025] ;
  char tmp[1025] ;
  char val[1025] ;
  int last ;
  int len ;
  int lineno ;
  int errs ;
  dictionary *dict ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  line_status tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 561
  last = 0;
#line 563
  lineno = 0;
#line 564
  errs = 0;
#line 568
  in = fopen((char const   */* __restrict  */)ininame, (char const   */* __restrict  */)"r");
  }
#line 568
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 569
    return ((dictionary *)((void *)0));
  }
  {
#line 572
  dict = dictionary_new(0);
  }
#line 573
  if (! dict) {
    {
#line 574
    fclose(in);
    }
#line 575
    return ((dictionary *)((void *)0));
  }
  {
#line 578
  memset((void *)(line), 0, (size_t )1024);
#line 579
  memset((void *)(section), 0, (size_t )1024);
#line 580
  memset((void *)(key), 0, (size_t )1024);
#line 581
  memset((void *)(val), 0, (size_t )1024);
#line 582
  last = 0;
  }
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 584
    tmp___3 = fgets((char */* __restrict  */)(line + last), 1024 - last, (FILE */* __restrict  */)in);
    }
#line 584
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 584
      goto while_break;
    }
    {
#line 585
    lineno ++;
#line 586
    tmp___0 = strlen((char const   *)(line));
#line 586
    len = (int )tmp___0 - 1;
    }
#line 588
    if ((int )line[len] != 10) {
      {
#line 589
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iniparser: input line too long in %s (%d)\n",
              ininame, lineno);
#line 593
      dictionary_del(dict);
#line 594
      fclose(in);
      }
#line 595
      return ((dictionary *)((void *)0));
    }
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (len >= 0) {
#line 598
        if (! ((int )line[len] == 10)) {
          {
#line 598
          tmp___1 = __ctype_b_loc();
          }
#line 598
          if (! ((int const   )*(*tmp___1 + (int )line[len]) & 8192)) {
#line 598
            goto while_break___0;
          }
        }
      } else {
#line 598
        goto while_break___0;
      }
#line 600
      line[len] = (char)0;
#line 601
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 604
    if ((int )line[len] == 92) {
#line 606
      last = len;
#line 607
      goto while_continue;
    } else {
#line 609
      last = 0;
    }
    {
#line 611
    tmp___2 = iniparser_line(line, section, key, val);
    }
    {
#line 613
    if ((unsigned int )tmp___2 == 3U) {
#line 613
      goto case_3;
    }
#line 613
    if ((unsigned int )tmp___2 == 2U) {
#line 613
      goto case_3;
    }
#line 616
    if ((unsigned int )tmp___2 == 4U) {
#line 616
      goto case_4;
    }
#line 620
    if ((unsigned int )tmp___2 == 5U) {
#line 620
      goto case_5;
    }
#line 625
    if ((unsigned int )tmp___2 == 1U) {
#line 625
      goto case_1;
    }
#line 633
    goto switch_default;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 614
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 617
    errs = dictionary_set(dict, section, (char *)((void *)0));
    }
#line 618
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 621
    sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"%s:%s",
            section, key);
#line 622
    errs = dictionary_set(dict, tmp, val);
    }
#line 623
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 626
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iniparser: syntax error in %s (%d):\n",
            ininame, lineno);
#line 629
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-> %s\n",
            line);
#line 630
    errs ++;
    }
#line 631
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 634
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 636
    memset((void *)(line), 0, (size_t )1024);
#line 637
    last = 0;
    }
#line 638
    if (errs < 0) {
      {
#line 639
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iniparser: memory allocation failure\n");
      }
#line 640
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  if (errs) {
    {
#line 644
    dictionary_del(dict);
#line 645
    dict = (dictionary *)((void *)0);
    }
  }
  {
#line 647
  fclose(in);
  }
#line 648
  return (dict);
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/iniparser.c"
void iniparser_freedict(dictionary *d ) 
{ 


  {
  {
#line 664
  dictionary_del(d);
  }
#line 665
  return;
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/meta.c"
static option_default _none_default___0[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/meta.c"
static conversion _none_conv___0[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 14 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/meta.c"
static int _none_up___0(interface_defn *ifd , execfn *exec ) 
{ 


  {
#line 15
  return (1);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/meta.c"
static int _none_down___0(interface_defn *ifd , execfn *exec ) 
{ 


  {
#line 18
  return (1);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/meta.c"
static method methods___3[1]  = {      {(char *)"none", & _none_up___0, & _none_down___0, _none_conv___0, _none_default___0}};
#line 28 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/meta.c"
address_family addr_meta  =    {(char *)"meta", (int )(sizeof(methods___3) / sizeof(struct method )), methods___3};
#line 8 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/can.c"
static option_default _static_default___2[1]  = {      {(char *)((void *)0), (char *)((void *)0)}};
#line 11 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/can.c"
static conversion _static_conv___2[1]  = {      {(char *)((void *)0), (char *)((void *)0), (void (*)(interface_defn * , char ** ,
                                                          int  , char ** ))((void *)0),
      0, (char **)((void *)0)}};
#line 14 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/can.c"
static int _static_up___2(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 16
  tmp = execute((char *)"ip link set %iface% type can bitrate %bitrate%", ifd, exec);
  }
#line 16
  if (! tmp) {
#line 16
    return (0);
  }
  {
#line 19
  tmp___0 = execute((char *)"[[ ip link set %iface% type can loopback %loopback% ]]",
                    ifd, exec);
  }
#line 19
  if (! tmp___0) {
#line 19
    return (0);
  }
  {
#line 22
  tmp___1 = execute((char *)"[[ ip link set %iface% type can listen-only %listenonly% ]]",
                    ifd, exec);
  }
#line 22
  if (! tmp___1) {
#line 22
    return (0);
  }
  {
#line 25
  tmp___2 = execute((char *)"[[ ip link set %iface% type can triple-sampling %triple% ]]",
                    ifd, exec);
  }
#line 25
  if (! tmp___2) {
#line 25
    return (0);
  }
  {
#line 28
  tmp___3 = execute((char *)"[[ ip link set %iface% type can one-shot %oneshot% ]]",
                    ifd, exec);
  }
#line 28
  if (! tmp___3) {
#line 28
    return (0);
  }
  {
#line 31
  tmp___4 = execute((char *)"[[ ip link set %iface% type can berr-reporting %berr% ]]",
                    ifd, exec);
  }
#line 31
  if (! tmp___4) {
#line 31
    return (0);
  }
  {
#line 34
  tmp___5 = execute((char *)"ip link set %iface% up", ifd, exec);
  }
#line 34
  if (! tmp___5) {
#line 34
    return (0);
  }
#line 36
  return (1);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/can.c"
static int _static_down___2(interface_defn *ifd , execfn *exec ) 
{ 
  int tmp ;

  {
  {
#line 40
  tmp = execute((char *)"ip link set %iface% down", ifd, exec);
  }
#line 40
  if (! tmp) {
#line 40
    return (0);
  }
#line 42
  return (1);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/can.c"
static method methods___4[1]  = {      {(char *)"static", & _static_up___2, & _static_down___2, _static_conv___2, _static_default___2}};
#line 52 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/can.c"
address_family addr_can  =    {(char *)"can", (int )(sizeof(methods___4) / sizeof(struct method )), methods___4};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
void sanitize_file_name(char *name ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/header.h"
interfaces_file *defn  ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 1016 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
int no_act  =    0;
#line 17 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
int run_scripts  =    1;
#line 18 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
int verbose  =    0;
#line 19 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
_Bool no_loopback  =    (_Bool)0;
#line 20 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
char lockfile[27]  = 
#line 20
  {      (char )'/',      (char )'r',      (char )'u',      (char )'n', 
        (char )'/',      (char )'n',      (char )'e',      (char )'t', 
        (char )'w',      (char )'o',      (char )'r',      (char )'k', 
        (char )'/',      (char )'.',      (char )'i',      (char )'f', 
        (char )'s',      (char )'t',      (char )'a',      (char )'t', 
        (char )'e',      (char )'.',      (char )'l',      (char )'o', 
        (char )'c',      (char )'k',      (char )'\000'};
#line 21 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
char statefile[21]  = 
#line 21
  {      (char )'/',      (char )'r',      (char )'u',      (char )'n', 
        (char )'/',      (char )'n',      (char )'e',      (char )'t', 
        (char )'w',      (char )'o',      (char )'r',      (char )'k', 
        (char )'/',      (char )'i',      (char )'f',      (char )'s', 
        (char )'t',      (char )'a',      (char )'t',      (char )'e', 
        (char )'\000'};
#line 22 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
char tmpstatefile[26]  = 
#line 22
  {      (char )'/',      (char )'r',      (char )'u',      (char )'n', 
        (char )'/',      (char )'n',      (char )'e',      (char )'t', 
        (char )'w',      (char )'o',      (char )'r',      (char )'k', 
        (char )'/',      (char )'.',      (char )'i',      (char )'f', 
        (char )'s',      (char )'t',      (char )'a',      (char )'t', 
        (char )'e',      (char )'.',      (char )'t',      (char )'m', 
        (char )'p',      (char )'\000'};
#line 23 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
char *nm_system_settings  =    (char *)"/etc/NetworkManager/NetworkManager.conf";
#line 25
_Bool match_patterns(char *string , int argc , char **argv ) ;
#line 26
static void usage(char *execname ) ;
#line 27
static void help(char *execname , int (*cmds)(interface_defn * ) ) ;
#line 28
static void version(char *execname ) ;
#line 29
static int auto_disabled(void) ;
#line 31
static void read_all_state(char const   *argv0 , char ***ifaces , int *n_ifaces ) ;
#line 32
static void update_state(char const   *argv0 , char const   *iface , char const   *state ,
                         FILE *lock_fp ) ;
#line 33
static int lock_fd(int fd ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static int initialized  =    0;
#line 37 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static int auto_up_disabled  =    0;
#line 35 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static int auto_disabled(void) 
{ 
  dictionary *ini_dict ;
  int managed ;
  int tmp ;

  {
#line 39
  if (! initialized) {
    {
#line 41
    initialized = 1;
#line 43
    ini_dict = iniparser_load((char const   *)nm_system_settings);
    }
#line 44
    if (ini_dict) {
      {
#line 45
      tmp = iniparser_getboolean(ini_dict, "ifupdown:managed", 0);
#line 45
      managed = tmp;
      }
#line 46
      if (managed) {
#line 46
        auto_up_disabled = 1;
      } else {
#line 46
        auto_up_disabled = 0;
      }
      {
#line 47
      iniparser_freedict(ini_dict);
#line 48
      ini_dict = (dictionary *)0;
      }
    } else {
#line 50
      auto_up_disabled = 0;
    }
  }
#line 54
  return (auto_up_disabled);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
_Bool match_patterns(char *string , int argc , char **argv ) 
{ 
  int i ;
  int tmp ;

  {
#line 59
  if (! argc) {
#line 60
    return ((_Bool)0);
  } else
#line 59
  if (! argv) {
#line 60
    return ((_Bool)0);
  } else
#line 59
  if (! string) {
#line 60
    return ((_Bool)0);
  }
#line 62
  i = 0;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (i < argc)) {
#line 62
      goto while_break;
    }
    {
#line 63
    tmp = fnmatch((char const   *)*(argv + i), (char const   *)string, 0);
    }
#line 63
    if (tmp == 0) {
#line 64
      return ((_Bool)1);
    }
#line 62
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return ((_Bool)0);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static void usage(char *execname ) 
{ 


  {
  {
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Use --help for help\n",
          execname);
#line 73
  exit(1);
  }
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static void version(char *execname ) 
{ 


  {
  {
#line 78
  printf((char const   */* __restrict  */)"%s version 0.7\n", execname);
#line 79
  printf((char const   */* __restrict  */)"Copyright (c) 1999-2009 Anthony Towns\n");
#line 80
  printf((char const   */* __restrict  */)"Copyright (c) 2010-2013 Andrew Shadura\n\n");
#line 81
  printf((char const   */* __restrict  */)"This program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or (at\nyour option) any later version.\n");
#line 87
  exit(0);
  }
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static void help(char *execname , int (*cmds)(interface_defn * ) ) 
{ 


  {
  {
#line 92
  printf((char const   */* __restrict  */)"Usage: %s <options> <ifaces...>\n", execname);
  }
#line 93
  if ((unsigned long )cmds == (unsigned long )(& iface_list)) {
    {
#line 96
    printf((char const   */* __restrict  */)"       %s <options> --list\n", execname);
#line 97
    printf((char const   */* __restrict  */)"       %s --state <ifaces...>\n", execname);
    }
  } else
#line 93
  if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
    {
#line 96
    printf((char const   */* __restrict  */)"       %s <options> --list\n", execname);
#line 97
    printf((char const   */* __restrict  */)"       %s --state <ifaces...>\n", execname);
    }
  }
  {
#line 99
  printf((char const   */* __restrict  */)"\n");
#line 100
  printf((char const   */* __restrict  */)"Options:\n");
#line 101
  printf((char const   */* __restrict  */)"\t-h, --help\t\tthis help\n");
#line 102
  printf((char const   */* __restrict  */)"\t-V, --version\t\tcopyright and version information\n");
#line 103
  printf((char const   */* __restrict  */)"\t-a, --all\t\tprocess all interfaces marked \"auto\"\n");
#line 104
  printf((char const   */* __restrict  */)"\t--allow CLASS\t\tignore non-\"allow-CLASS\" interfaces\n");
#line 105
  printf((char const   */* __restrict  */)"\t-i, --interfaces FILE\tuse FILE for interface definitions\n");
#line 106
  printf((char const   */* __restrict  */)"\t-X, --exclude PATTERN\texclude interfaces from the list of\n\t\t\t\tinterfaces to operate on by a PATTERN\n");
  }
#line 107
  if (! ((unsigned long )cmds == (unsigned long )(& iface_list))) {
#line 107
    if (! ((unsigned long )cmds == (unsigned long )(& iface_query))) {
      {
#line 109
      printf((char const   */* __restrict  */)"\t-n, --no-act\t\tprint out what would happen, but don\'t do it\n");
      }
    }
  }
  {
#line 110
  printf((char const   */* __restrict  */)"\t\t\t\t(note that this option doesn\'t disable mappings)\n");
#line 111
  printf((char const   */* __restrict  */)"\t-v, --verbose\t\tprint out what would happen before doing it\n");
#line 112
  printf((char const   */* __restrict  */)"\t-o OPTION=VALUE\t\tset OPTION to VALUE as though it were in\n");
#line 113
  printf((char const   */* __restrict  */)"\t\t\t\t/etc/network/interfaces\n");
#line 114
  printf((char const   */* __restrict  */)"\t--no-mappings\t\tdon\'t run any mappings\n");
#line 115
  printf((char const   */* __restrict  */)"\t--no-scripts\t\tdon\'t run any hook scripts\n");
#line 116
  printf((char const   */* __restrict  */)"\t--no-loopback\t\tdon\'t act specially on the loopback device\n");
  }
#line 117
  if (! ((unsigned long )cmds == (unsigned long )(& iface_list))) {
#line 117
    if (! ((unsigned long )cmds == (unsigned long )(& iface_query))) {
      {
#line 119
      printf((char const   */* __restrict  */)"\t--force\t\t\tforce de/configuration\n");
      }
    }
  }
#line 120
  if ((unsigned long )cmds == (unsigned long )(& iface_list)) {
    {
#line 123
    printf((char const   */* __restrict  */)"\t--list\t\t\tlist all matching known interfaces\n");
#line 124
    printf((char const   */* __restrict  */)"\t--state\t\t\tshow the state of specified interfaces\n");
    }
  } else
#line 120
  if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
    {
#line 123
    printf((char const   */* __restrict  */)"\t--list\t\t\tlist all matching known interfaces\n");
#line 124
    printf((char const   */* __restrict  */)"\t--state\t\t\tshow the state of specified interfaces\n");
    }
  }
  {
#line 126
  exit(0);
  }
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
FILE *lock_state(char const   *argv0 ) 
{ 
  FILE *lock_fp ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int flags ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 131
  if (no_act) {
#line 131
    tmp = "r";
  } else {
#line 131
    tmp = "a+";
  }
  {
#line 131
  lock_fp = fopen((char const   */* __restrict  */)(lockfile), (char const   */* __restrict  */)tmp);
  }
#line 132
  if ((unsigned long )lock_fp == (unsigned long )((void *)0)) {
#line 133
    if (! no_act) {
      {
#line 134
      tmp___0 = __errno_location();
#line 134
      tmp___1 = strerror(*tmp___0);
#line 134
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to open lockfile %s: %s\n",
              argv0, lockfile, tmp___1);
#line 135
      exit(1);
      }
    } else {
#line 137
      return ((FILE *)((void *)0));
    }
  }
  {
#line 143
  tmp___4 = fileno(lock_fp);
#line 143
  flags = fcntl(tmp___4, 1);
  }
#line 143
  if (flags < 0) {
    {
#line 144
    tmp___2 = __errno_location();
#line 144
    tmp___3 = strerror(*tmp___2);
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to set FD_CLOEXEC on lockfile %s: %s\n",
            argv0, lockfile, tmp___3);
#line 145
    exit(1);
    }
  } else {
    {
#line 143
    tmp___5 = fileno(lock_fp);
#line 143
    tmp___6 = fcntl(tmp___5, 2, flags | 1);
    }
#line 143
    if (tmp___6 < 0) {
      {
#line 144
      tmp___2 = __errno_location();
#line 144
      tmp___3 = strerror(*tmp___2);
#line 144
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to set FD_CLOEXEC on lockfile %s: %s\n",
              argv0, lockfile, tmp___3);
#line 145
      exit(1);
      }
    }
  }
  {
#line 148
  tmp___9 = fileno(lock_fp);
#line 148
  tmp___10 = lock_fd(tmp___9);
  }
#line 148
  if (tmp___10 < 0) {
#line 149
    if (! no_act) {
      {
#line 150
      tmp___7 = __errno_location();
#line 150
      tmp___8 = strerror(*tmp___7);
#line 150
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to lock lockfile %s: %s\n",
              argv0, lockfile, tmp___8);
#line 151
      exit(1);
      }
    }
  }
#line 155
  return (lock_fp);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static char *strip(char *buf ) 
{ 
  char *pch ;
  size_t tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 159
  tmp = strlen((char const   *)buf);
#line 159
  pch = (buf + tmp) - 1;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if ((unsigned long )pch > (unsigned long )buf) {
      {
#line 160
      tmp___1 = __ctype_b_loc();
      }
#line 160
      if (! ((int const   )*(*tmp___1 + (int )*pch) & 8192)) {
#line 160
        goto while_break;
      }
    } else {
#line 160
      goto while_break;
    }
#line 161
    tmp___0 = pch;
#line 161
    pch --;
#line 161
    *tmp___0 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 163
    tmp___2 = __ctype_b_loc();
    }
#line 163
    if (! ((int const   )*(*tmp___2 + (int )*buf) & 8192)) {
#line 163
      goto while_break___0;
    }
#line 164
    buf ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 166
  return (buf);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static FILE *lock_interface(char const   *argv0 , char const   *iface , char **state ) 
{ 
  size_t tmp ;
  char *filename ;
  unsigned long __lengthoffilename ;
  void *tmp___0 ;
  FILE *lock_fp ;
  char const   *tmp___1 ;
  FILE *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int flags ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct flock lock ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char buf[80] ;
  char *p ;
  char *tmp___21 ;
  char *tmp___22 ;

  {
  {
#line 170
  tmp = strlen(iface);
#line 170
  __lengthoffilename = (sizeof(statefile) + tmp) + 2UL;
#line 170
  tmp___0 = __builtin_alloca(sizeof(*filename) * __lengthoffilename);
#line 170
  filename = (char *)tmp___0;
#line 171
  snprintf((char */* __restrict  */)filename, sizeof(*filename) * __lengthoffilename,
           (char const   */* __restrict  */)"%s.%s", statefile, iface);
  }
#line 173
  if (no_act) {
#line 173
    tmp___1 = "r";
  } else {
#line 173
    tmp___1 = "a+";
  }
  {
#line 173
  tmp___2 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)tmp___1);
#line 173
  lock_fp = tmp___2;
  }
#line 175
  if ((unsigned long )lock_fp == (unsigned long )((void *)0)) {
#line 176
    if (! no_act) {
      {
#line 177
      tmp___3 = __errno_location();
#line 177
      tmp___4 = strerror(*tmp___3);
#line 177
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to open lockfile %s: %s\n",
              argv0, filename, tmp___4);
#line 178
      exit(1);
      }
    } else {
#line 180
      return ((FILE *)((void *)0));
    }
  }
  {
#line 184
  tmp___5 = fileno(lock_fp);
#line 184
  tmp___6 = fcntl(tmp___5, 1);
#line 184
  flags = tmp___6;
  }
#line 186
  if (flags < 0) {
    {
#line 187
    tmp___7 = __errno_location();
#line 187
    tmp___8 = strerror(*tmp___7);
#line 187
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to set FD_CLOEXEC on lockfile %s: %s\n",
            argv0, filename, tmp___8);
#line 188
    exit(1);
    }
  } else {
    {
#line 186
    tmp___9 = fileno(lock_fp);
#line 186
    tmp___10 = fcntl(tmp___9, 2, flags | 1);
    }
#line 186
    if (tmp___10 < 0) {
      {
#line 187
      tmp___7 = __errno_location();
#line 187
      tmp___8 = strerror(*tmp___7);
#line 187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to set FD_CLOEXEC on lockfile %s: %s\n",
              argv0, filename, tmp___8);
#line 188
      exit(1);
      }
    }
  }
  {
#line 191
  lock.l_type = (short)1;
#line 191
  lock.l_whence = (short)0;
#line 191
  lock.l_start = 0L;
#line 191
  lock.l_len = 0L;
#line 191
  lock.l_pid = 0;
#line 193
  tmp___19 = fileno(lock_fp);
#line 193
  tmp___20 = fcntl(tmp___19, 6, & lock);
  }
#line 193
  if (tmp___20 < 0) {
    {
#line 194
    tmp___17 = __errno_location();
    }
#line 194
    if (*tmp___17 == 13) {
#line 194
      goto _L;
    } else {
      {
#line 194
      tmp___18 = __errno_location();
      }
#line 194
      if (*tmp___18 == 11) {
        _L: /* CIL Label */ 
        {
#line 195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: waiting for lock on %s\n",
                argv0, filename);
#line 196
        tmp___13 = fileno(lock_fp);
#line 196
        tmp___14 = fcntl(tmp___13, 7, & lock);
        }
#line 196
        if (tmp___14 < 0) {
#line 197
          if (! no_act) {
            {
#line 198
            tmp___11 = __errno_location();
#line 198
            tmp___12 = strerror(*tmp___11);
#line 198
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to lock lockfile %s: %s\n",
                    argv0, filename, tmp___12);
#line 199
            exit(1);
            }
          }
        }
      } else
#line 202
      if (! no_act) {
        {
#line 203
        tmp___15 = __errno_location();
#line 203
        tmp___16 = strerror(*tmp___15);
#line 203
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to lock lockfile %s: %s\n",
                argv0, filename, tmp___16);
#line 204
        exit(1);
        }
      }
    }
  }
#line 208
  if (state) {
    {
#line 210
    tmp___21 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)lock_fp);
#line 210
    p = tmp___21;
    }
#line 211
    if (p) {
      {
#line 212
      p = strip(buf);
      }
#line 213
      if (*p) {
        {
#line 213
        tmp___22 = strdup((char const   *)p);
#line 213
        *state = tmp___22;
        }
      } else {
#line 213
        *state = (char *)((void *)0);
      }
    } else {
#line 215
      *state = (char *)((void *)0);
    }
  }
#line 219
  return (lock_fp);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static void read_all_state(char const   *argv0 , char ***ifaces , int *n_ifaces ) 
{ 
  int i ;
  FILE *lock_fp ;
  FILE *state_fp ;
  char buf[80] ;
  char *p ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int flags ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *pch ;
  size_t tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  void *tmp___10 ;
  char *temp ;

  {
  {
#line 294
  lock_fp = lock_state(argv0);
  }
#line 296
  if (no_act) {
#line 296
    tmp = "r";
  } else {
#line 296
    tmp = "a+";
  }
  {
#line 296
  state_fp = fopen((char const   */* __restrict  */)(statefile), (char const   */* __restrict  */)tmp);
  }
#line 297
  if ((unsigned long )state_fp == (unsigned long )((void *)0)) {
#line 298
    if (! no_act) {
      {
#line 299
      tmp___0 = __errno_location();
#line 299
      tmp___1 = strerror(*tmp___0);
#line 299
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to open statefile %s: %s\n",
              argv0, statefile, tmp___1);
#line 300
      exit(1);
      }
    } else {
#line 302
      goto noact;
    }
  }
#line 306
  if (! no_act) {
    {
#line 309
    tmp___4 = fileno(state_fp);
#line 309
    flags = fcntl(tmp___4, 1);
    }
#line 309
    if (flags < 0) {
      {
#line 310
      tmp___2 = __errno_location();
#line 310
      tmp___3 = strerror(*tmp___2);
#line 310
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to set FD_CLOEXEC on statefile %s: %s\n",
              argv0, statefile, tmp___3);
#line 311
      exit(1);
      }
    } else {
      {
#line 309
      tmp___5 = fileno(state_fp);
#line 309
      tmp___6 = fcntl(tmp___5, 2, flags | 1);
      }
#line 309
      if (tmp___6 < 0) {
        {
#line 310
        tmp___2 = __errno_location();
#line 310
        tmp___3 = strerror(*tmp___2);
#line 310
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to set FD_CLOEXEC on statefile %s: %s\n",
                argv0, statefile, tmp___3);
#line 311
        exit(1);
        }
      }
    }
  }
#line 315
  *n_ifaces = 0;
#line 316
  *ifaces = (char **)((void *)0);
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 318
    p = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)state_fp);
    }
#line 318
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 318
      goto while_break;
    }
    {
#line 321
    tmp___7 = strlen((char const   *)(buf));
#line 321
    pch = (buf + tmp___7) - 1;
    }
    {
#line 322
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 322
      if ((unsigned long )pch > (unsigned long )(buf)) {
        {
#line 322
        tmp___8 = __ctype_b_loc();
        }
#line 322
        if (! ((int const   )*(*tmp___8 + (int )*pch) & 8192)) {
#line 322
          goto while_break___0;
        }
      } else {
#line 322
        goto while_break___0;
      }
#line 323
      pch --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 324
    *(pch + 1) = (char )'\000';
#line 326
    pch = buf;
    {
#line 327
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 327
      tmp___9 = __ctype_b_loc();
      }
#line 327
      if (! ((int const   )*(*tmp___9 + (int )*pch) & 8192)) {
#line 327
        goto while_break___1;
      }
#line 328
      pch ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 330
    (*n_ifaces) ++;
#line 331
    tmp___10 = realloc((void *)*ifaces, sizeof(*(*ifaces)) * (unsigned long )*n_ifaces);
#line 331
    *ifaces = (char **)tmp___10;
#line 332
    *(*ifaces + (*n_ifaces - 1)) = strdup((char const   *)pch);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  i = 0;
  {
#line 335
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 335
    if (! (i < *n_ifaces / 2)) {
#line 335
      goto while_break___2;
    }
#line 336
    temp = *(*ifaces + i);
#line 337
    *(*ifaces + i) = *(*ifaces + ((*n_ifaces - i) - 1));
#line 338
    *(*ifaces + ((*n_ifaces - i) - 1)) = temp;
#line 335
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  noact: 
#line 342
  if ((unsigned long )state_fp != (unsigned long )((void *)0)) {
    {
#line 343
    fclose(state_fp);
#line 344
    state_fp = (FILE *)((void *)0);
    }
  }
#line 347
  if ((unsigned long )lock_fp != (unsigned long )((void *)0)) {
    {
#line 348
    fclose(lock_fp);
#line 349
    lock_fp = (FILE *)((void *)0);
    }
  }
#line 351
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static void update_state(char const   *argv0 , char const   *iface , char const   *state ,
                         FILE *lock_fp ) 
{ 
  FILE *tmp_fp ;
  FILE *state_fp ;
  char buf[80] ;
  char *p ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int flags ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *pch ;
  size_t tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;

  {
#line 361
  if (lock_fp) {
    {
#line 362
    rewind(lock_fp);
#line 363
    tmp = fileno(lock_fp);
#line 363
    ftruncate(tmp, (__off_t )0);
    }
#line 364
    if (state) {
#line 364
      tmp___0 = state;
    } else {
#line 364
      tmp___0 = "";
    }
    {
#line 364
    fprintf((FILE */* __restrict  */)lock_fp, (char const   */* __restrict  */)"%s\n",
            tmp___0);
#line 365
    fflush(lock_fp);
    }
  }
  {
#line 368
  lock_fp = lock_state(argv0);
  }
#line 370
  if (no_act) {
#line 370
    tmp___1 = "r";
  } else {
#line 370
    tmp___1 = "a+";
  }
  {
#line 370
  state_fp = fopen((char const   */* __restrict  */)(statefile), (char const   */* __restrict  */)tmp___1);
  }
#line 371
  if ((unsigned long )state_fp == (unsigned long )((void *)0)) {
#line 372
    if (! no_act) {
      {
#line 373
      tmp___2 = __errno_location();
#line 373
      tmp___3 = strerror(*tmp___2);
#line 373
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to open statefile %s: %s\n",
              argv0, statefile, tmp___3);
#line 374
      exit(1);
      }
    } else {
#line 376
      goto noact;
    }
  }
#line 380
  if (! no_act) {
    {
#line 383
    tmp___6 = fileno(state_fp);
#line 383
    flags = fcntl(tmp___6, 1);
    }
#line 383
    if (flags < 0) {
      {
#line 384
      tmp___4 = __errno_location();
#line 384
      tmp___5 = strerror(*tmp___4);
#line 384
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to set FD_CLOEXEC on statefile %s: %s\n",
              argv0, statefile, tmp___5);
#line 385
      exit(1);
      }
    } else {
      {
#line 383
      tmp___7 = fileno(state_fp);
#line 383
      tmp___8 = fcntl(tmp___7, 2, flags | 1);
      }
#line 383
      if (tmp___8 < 0) {
        {
#line 384
        tmp___4 = __errno_location();
#line 384
        tmp___5 = strerror(*tmp___4);
#line 384
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to set FD_CLOEXEC on statefile %s: %s\n",
                argv0, statefile, tmp___5);
#line 385
        exit(1);
        }
      }
    }
    {
#line 388
    tmp___11 = fileno(state_fp);
#line 388
    tmp___12 = lock_fd(tmp___11);
    }
#line 388
    if (tmp___12 < 0) {
      {
#line 389
      tmp___9 = __errno_location();
#line 389
      tmp___10 = strerror(*tmp___9);
#line 389
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to lock statefile %s: %s\n",
              argv0, statefile, tmp___10);
#line 390
      exit(1);
      }
    }
  }
#line 394
  if (no_act) {
#line 395
    goto noact;
  }
  {
#line 397
  tmp_fp = fopen((char const   */* __restrict  */)(tmpstatefile), (char const   */* __restrict  */)"w");
  }
#line 398
  if ((unsigned long )tmp_fp == (unsigned long )((void *)0)) {
    {
#line 399
    tmp___13 = __errno_location();
#line 399
    tmp___14 = strerror(*tmp___13);
#line 399
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to open temporary statefile %s: %s\n",
            argv0, tmpstatefile, tmp___14);
#line 400
    exit(1);
    }
  }
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 403
    p = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)state_fp);
    }
#line 403
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 403
      goto while_break;
    }
    {
#line 406
    tmp___15 = strlen((char const   *)(buf));
#line 406
    pch = (buf + tmp___15) - 1;
    }
    {
#line 407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 407
      if ((unsigned long )pch > (unsigned long )(buf)) {
        {
#line 407
        tmp___16 = __ctype_b_loc();
        }
#line 407
        if (! ((int const   )*(*tmp___16 + (int )*pch) & 8192)) {
#line 407
          goto while_break___0;
        }
      } else {
#line 407
        goto while_break___0;
      }
#line 408
      pch --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 409
    *(pch + 1) = (char )'\000';
#line 411
    pch = buf;
    {
#line 412
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 412
      tmp___17 = __ctype_b_loc();
      }
#line 412
      if (! ((int const   )*(*tmp___17 + (int )*pch) & 8192)) {
#line 412
        goto while_break___1;
      }
#line 413
      pch ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 415
    tmp___19 = strlen(iface);
#line 415
    tmp___20 = strncmp(iface, (char const   *)pch, tmp___19);
    }
#line 415
    if (tmp___20 == 0) {
      {
#line 416
      tmp___18 = strlen(iface);
      }
#line 416
      if ((int )*(pch + tmp___18) == 61) {
#line 417
        if ((unsigned long )state != (unsigned long )((void *)0)) {
          {
#line 418
          fprintf((FILE */* __restrict  */)tmp_fp, (char const   */* __restrict  */)"%s=%s\n",
                  iface, state);
#line 419
          state = (char const   *)((void *)0);
          }
        }
#line 422
        goto while_continue;
      }
    }
    {
#line 426
    fprintf((FILE */* __restrict  */)tmp_fp, (char const   */* __restrict  */)"%s\n",
            pch);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  if ((unsigned long )state != (unsigned long )((void *)0)) {
    {
#line 430
    fprintf((FILE */* __restrict  */)tmp_fp, (char const   */* __restrict  */)"%s=%s\n",
            iface, state);
    }
  }
  {
#line 432
  fclose(tmp_fp);
#line 433
  tmp___23 = rename((char const   *)(tmpstatefile), (char const   *)(statefile));
  }
#line 433
  if (tmp___23) {
    {
#line 434
    tmp___21 = __errno_location();
#line 434
    tmp___22 = strerror(*tmp___21);
#line 434
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to overwrite statefile %s: %s\n",
            argv0, statefile, tmp___22);
#line 435
    exit(1);
    }
  }
  noact: 
#line 439
  if ((unsigned long )state_fp != (unsigned long )((void *)0)) {
    {
#line 440
    fclose(state_fp);
#line 441
    state_fp = (FILE *)((void *)0);
    }
  }
#line 444
  if ((unsigned long )lock_fp != (unsigned long )((void *)0)) {
    {
#line 445
    fclose(lock_fp);
#line 446
    lock_fp = (FILE *)((void *)0);
    }
  }
#line 448
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
static int lock_fd(int fd ) 
{ 
  struct flock lock ;
  int tmp ;

  {
  {
#line 454
  lock.l_type = (short)1;
#line 455
  lock.l_whence = (short)0;
#line 456
  lock.l_start = (__off_t )0;
#line 457
  lock.l_len = (__off_t )0;
#line 459
  tmp = fcntl(fd, 7, & lock);
  }
#line 459
  if (tmp < 0) {
#line 460
    return (-1);
  }
#line 463
  return (0);
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
void sanitize_file_name(char *name ) 
{ 


  {
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    if (! *name) {
#line 468
      goto while_break;
    }
#line 469
    if ((int )*name == 47) {
#line 470
      *name = (char )'.';
    }
#line 468
    name ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  return;
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
_Bool make_pidfile_name(char *name , size_t size , char const   *command , interface_defn *ifd ) 
{ 
  char *iface ;
  char *tmp ;
  int n ;
  int tmp___0 ;

  {
  {
#line 478
  tmp = strdup((char const   *)ifd->real_iface);
#line 478
  iface = tmp;
  }
#line 479
  if (! iface) {
#line 480
    return ((_Bool)0);
  }
  {
#line 482
  sanitize_file_name(iface);
#line 484
  tmp___0 = snprintf((char */* __restrict  */)name, size, (char const   */* __restrict  */)"/run/network/%s-%s.pid",
                     command, iface);
#line 484
  n = tmp___0;
  }
#line 485
  if (n < 0) {
    {
#line 486
    free((void *)iface);
    }
#line 487
    return ((_Bool)0);
  } else
#line 485
  if ((size_t )n >= size) {
    {
#line 486
    free((void *)iface);
    }
#line 487
    return ((_Bool)0);
  }
#line 490
  return ((_Bool)1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c"
int main(int argc , char **argv ) 
{ 
  int (*cmds)(interface_defn * ) ;
  struct option long_opts[16] ;
  int do_all ;
  int run_mappings ;
  int force ;
  int list ;
  _Bool state_query ;
  char *allow_class ;
  char *interfaces ;
  char **excludeint ;
  int excludeints ;
  variable *option ;
  int n_options ;
  int max_options ;
  int n_target_ifaces ;
  char **target_iface ;
  int i ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *command ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int c ;
  void *tmp___7 ;
  char *filename ;
  char *name ;
  char *tmp___8 ;
  char *val ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char **up_ifaces ;
  int n_up_ifaces ;
  _Bool ret ;
  int i___0 ;
  int j ;
  size_t l___1 ;
  size_t tmp___13 ;
  _Bool found ;
  int tmp___14 ;
  allowup_defn *autos ;
  char const   *tmp___15 ;
  allowup_defn *tmp___16 ;
  int tmp___17 ;
  interface_defn meta_iface ;
  int okay ;
  FILE *lock ;
  FILE *plock ;
  int i___1 ;
  char iface[80] ;
  char liface[80] ;
  char *current_state ;
  char *pch ;
  char envname[160] ;
  char *envval ;
  char *tmp___18 ;
  char piface[80] ;
  char *envval___0 ;
  char *tmp___19 ;
  int i___2 ;
  allowup_defn *allowup ;
  allowup_defn *tmp___20 ;
  int tmp___21 ;
  _Bool tmp___22 ;
  _Bool have_mapping ;
  mapping_defn *currmap ;
  int i___3 ;
  int tmp___23 ;
  interface_defn *currif ;
  int okay___0 ;
  int failed ;
  int tmp___24 ;
  mapping_defn *currmap___0 ;
  int i___4 ;
  int tmp___25 ;
  interface_defn link___0 ;
  int tmp___26 ;
  option_default *o ;
  int j___0 ;
  int found___0 ;
  int tmp___27 ;
  int i___5 ;
  int j___1 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char const   *tmp___33 ;
  char pidfilename[100] ;
  char *command___0 ;
  FILE *pidfile ;
  FILE *tmp___34 ;
  __pid_t tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  interface_defn link___1 ;
  int tmp___40 ;
  int okay___1 ;

  {
#line 495
  cmds = (int (*)(interface_defn * ))((void *)0);
#line 496
  long_opts[0].name = "help";
#line 496
  long_opts[0].has_arg = 0;
#line 496
  long_opts[0].flag = (int *)((void *)0);
#line 496
  long_opts[0].val = 'h';
#line 496
  long_opts[1].name = "version";
#line 496
  long_opts[1].has_arg = 0;
#line 496
  long_opts[1].flag = (int *)((void *)0);
#line 496
  long_opts[1].val = 'V';
#line 496
  long_opts[2].name = "verbose";
#line 496
  long_opts[2].has_arg = 0;
#line 496
  long_opts[2].flag = (int *)((void *)0);
#line 496
  long_opts[2].val = 'v';
#line 496
  long_opts[3].name = "all";
#line 496
  long_opts[3].has_arg = 0;
#line 496
  long_opts[3].flag = (int *)((void *)0);
#line 496
  long_opts[3].val = 'a';
#line 496
  long_opts[4].name = "allow";
#line 496
  long_opts[4].has_arg = 1;
#line 496
  long_opts[4].flag = (int *)((void *)0);
#line 496
  long_opts[4].val = 3;
#line 496
  long_opts[5].name = "interfaces";
#line 496
  long_opts[5].has_arg = 1;
#line 496
  long_opts[5].flag = (int *)((void *)0);
#line 496
  long_opts[5].val = 'i';
#line 496
  long_opts[6].name = "exclude";
#line 496
  long_opts[6].has_arg = 1;
#line 496
  long_opts[6].flag = (int *)((void *)0);
#line 496
  long_opts[6].val = 'X';
#line 496
  long_opts[7].name = "no-act";
#line 496
  long_opts[7].has_arg = 0;
#line 496
  long_opts[7].flag = (int *)((void *)0);
#line 496
  long_opts[7].val = 'n';
#line 496
  long_opts[8].name = "no-mappings";
#line 496
  long_opts[8].has_arg = 0;
#line 496
  long_opts[8].flag = (int *)((void *)0);
#line 496
  long_opts[8].val = 1;
#line 496
  long_opts[9].name = "no-scripts";
#line 496
  long_opts[9].has_arg = 0;
#line 496
  long_opts[9].flag = (int *)((void *)0);
#line 496
  long_opts[9].val = 4;
#line 496
  long_opts[10].name = "no-loopback";
#line 496
  long_opts[10].has_arg = 0;
#line 496
  long_opts[10].flag = (int *)((void *)0);
#line 496
  long_opts[10].val = 5;
#line 496
  long_opts[11].name = "force";
#line 496
  long_opts[11].has_arg = 0;
#line 496
  long_opts[11].flag = (int *)((void *)0);
#line 496
  long_opts[11].val = 2;
#line 496
  long_opts[12].name = "option";
#line 496
  long_opts[12].has_arg = 1;
#line 496
  long_opts[12].flag = (int *)((void *)0);
#line 496
  long_opts[12].val = 'o';
#line 496
  long_opts[13].name = "list";
#line 496
  long_opts[13].has_arg = 0;
#line 496
  long_opts[13].flag = (int *)((void *)0);
#line 496
  long_opts[13].val = 'l';
#line 496
  long_opts[14].name = "state";
#line 496
  long_opts[14].has_arg = 0;
#line 496
  long_opts[14].flag = (int *)((void *)0);
#line 496
  long_opts[14].val = 6;
#line 496
  long_opts[15].name = (char const   *)0;
#line 496
  long_opts[15].has_arg = 0;
#line 496
  long_opts[15].flag = (int *)0;
#line 496
  long_opts[15].val = 0;
#line 514
  do_all = 0;
#line 515
  run_mappings = 1;
#line 516
  force = 0;
#line 517
  list = 0;
#line 518
  state_query = (_Bool)0;
#line 519
  allow_class = (char *)((void *)0);
#line 520
  interfaces = (char *)"/etc/network/interfaces";
#line 521
  excludeint = (char **)((void *)0);
#line 522
  excludeints = 0;
#line 523
  option = (variable *)((void *)0);
#line 524
  n_options = 0;
#line 525
  max_options = 0;
#line 531
  i = 0;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! (i <= 2)) {
#line 531
      goto while_break;
    }
    {
#line 532
    tmp___3 = fcntl(i, 1);
    }
#line 532
    if (tmp___3 == -1) {
      {
#line 533
      tmp___1 = __errno_location();
      }
#line 533
      if (*tmp___1 == 9) {
        {
#line 533
        tmp___2 = open("/dev/null", 0);
        }
#line 533
        if (tmp___2 == -1) {
          {
#line 534
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fd %d not available; aborting\n",
                  *(argv + 0), i);
#line 535
          exit(2);
          }
        } else {
#line 533
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 536
        tmp___0 = __errno_location();
        }
#line 536
        if (*tmp___0 == 9) {
          {
#line 537
          tmp = __errno_location();
#line 537
          *tmp = 0;
          }
        } else {
          {
#line 540
          perror((char const   *)*(argv + 0));
#line 541
          exit(2);
          }
        }
      }
    }
#line 531
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 550
  command = strrchr((char const   *)*(argv + 0), '/');
  }
#line 550
  if (command) {
#line 551
    command ++;
  } else {
#line 553
    command = *(argv + 0);
  }
  {
#line 555
  tmp___6 = strcmp((char const   *)command, "ifup");
  }
#line 555
  if (tmp___6 == 0) {
#line 556
    cmds = & iface_up;
  } else {
    {
#line 557
    tmp___5 = strcmp((char const   *)command, "ifdown");
    }
#line 557
    if (tmp___5 == 0) {
#line 558
      cmds = & iface_down;
    } else {
      {
#line 559
      tmp___4 = strcmp((char const   *)command, "ifquery");
      }
#line 559
      if (tmp___4 == 0) {
#line 560
        cmds = & iface_query;
#line 561
        no_act = 1;
      } else {
        {
#line 563
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This command should be called as ifup, ifdown, or ifquery\n");
#line 564
        exit(1);
        }
      }
    }
  }
  {
#line 567
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 569
    c = getopt_long(argc, (char * const  *)argv, "X:s:i:o:hVvnal", (struct option  const  *)(long_opts),
                    (int *)((void *)0));
    }
#line 570
    if (c == -1) {
#line 571
      goto while_break___0;
    }
    {
#line 574
    if (c == 105) {
#line 574
      goto case_105;
    }
#line 577
    if (c == 118) {
#line 577
      goto case_118;
    }
#line 580
    if (c == 97) {
#line 580
      goto case_97;
    }
#line 583
    if (c == 3) {
#line 583
      goto case_3;
    }
#line 586
    if (c == 110) {
#line 586
      goto case_110;
    }
#line 591
    if (c == 1) {
#line 591
      goto case_1;
    }
#line 594
    if (c == 4) {
#line 594
      goto case_4;
    }
#line 597
    if (c == 5) {
#line 597
      goto case_5;
    }
#line 600
    if (c == 2) {
#line 600
      goto case_2;
    }
#line 605
    if (c == 88) {
#line 605
      goto case_88;
    }
#line 616
    if (c == 111) {
#line 616
      goto case_111;
    }
#line 638
    if (c == 108) {
#line 638
      goto case_108;
    }
#line 644
    if (c == 104) {
#line 644
      goto case_104;
    }
#line 647
    if (c == 86) {
#line 647
      goto case_86;
    }
#line 650
    if (c == 6) {
#line 650
      goto case_6;
    }
#line 656
    goto switch_default;
    case_105: /* CIL Label */ 
    {
#line 575
    interfaces = strdup((char const   *)optarg);
    }
#line 576
    goto switch_break;
    case_118: /* CIL Label */ 
#line 578
    verbose = 1;
#line 579
    goto switch_break;
    case_97: /* CIL Label */ 
#line 581
    do_all = 1;
#line 582
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 584
    allow_class = strdup((char const   *)optarg);
    }
#line 585
    goto switch_break;
    case_110: /* CIL Label */ 
#line 587
    if ((unsigned long )cmds == (unsigned long )(& iface_list)) {
      {
#line 588
      usage(*(argv + 0));
      }
    } else
#line 587
    if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
      {
#line 588
      usage(*(argv + 0));
      }
    }
#line 589
    no_act = 1;
#line 590
    goto switch_break;
    case_1: /* CIL Label */ 
#line 592
    run_mappings = 0;
#line 593
    goto switch_break;
    case_4: /* CIL Label */ 
#line 595
    run_scripts = 0;
#line 596
    goto switch_break;
    case_5: /* CIL Label */ 
#line 598
    no_loopback = (_Bool)1;
#line 599
    goto switch_break;
    case_2: /* CIL Label */ 
#line 601
    if ((unsigned long )cmds == (unsigned long )(& iface_list)) {
      {
#line 602
      usage(*(argv + 0));
      }
    } else
#line 601
    if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
      {
#line 602
      usage(*(argv + 0));
      }
    }
#line 603
    force = 1;
#line 604
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 607
    excludeints ++;
#line 608
    tmp___7 = realloc((void *)excludeint, (unsigned long )excludeints * sizeof(char *));
#line 608
    excludeint = (char **)tmp___7;
    }
#line 609
    if ((unsigned long )excludeint == (unsigned long )((void *)0)) {
      {
#line 610
      filename = *(argv + 0);
#line 611
      perror((char const   *)filename);
      }
#line 612
      return ((int )((void *)0));
    }
    {
#line 614
    *(excludeint + (excludeints - 1)) = strdup((char const   *)optarg);
    }
#line 615
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 618
    tmp___8 = strdup((char const   *)optarg);
#line 618
    name = tmp___8;
#line 619
    tmp___9 = strchr((char const   *)name, '=');
#line 619
    val = tmp___9;
    }
#line 620
    if ((unsigned long )val == (unsigned long )((void *)0)) {
      {
#line 621
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in --option \"%s\" -- no \"=\" character\n",
              optarg);
#line 622
      exit(1);
      }
    }
    {
#line 624
    tmp___10 = val;
#line 624
    val ++;
#line 624
    *tmp___10 = (char )'\000';
#line 626
    tmp___11 = strcmp((char const   *)name, "post-up");
    }
#line 626
    if (tmp___11 == 0) {
      {
#line 627
      strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)"up");
      }
    }
    {
#line 629
    tmp___12 = strcmp((char const   *)name, "pre-down");
    }
#line 629
    if (tmp___12 == 0) {
      {
#line 630
      strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)"down");
      }
    }
    {
#line 633
    set_variable(*(argv + 0), name, val, & option, & n_options, & max_options);
#line 634
    free((void *)name);
    }
#line 636
    goto switch_break;
    case_108: /* CIL Label */ 
#line 639
    if (! ((unsigned long )cmds == (unsigned long )(& iface_query))) {
      {
#line 640
      usage(*(argv + 0));
      }
    }
#line 641
    list = 1;
#line 642
    cmds = & iface_list;
#line 643
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 645
    help(*(argv + 0), cmds);
    }
#line 646
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 648
    version(*(argv + 0));
    }
#line 649
    goto switch_break;
    case_6: /* CIL Label */ 
#line 652
    if ((unsigned long )cmds != (unsigned long )(& iface_query)) {
      {
#line 653
      usage(*(argv + 0));
      }
    }
#line 654
    state_query = (_Bool)1;
#line 655
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 657
    usage(*(argv + 0));
    }
#line 658
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 662
  if (state_query) {
    {
#line 665
    read_all_state((char const   *)*(argv + 0), & up_ifaces, & n_up_ifaces);
#line 666
    target_iface = argv + optind;
#line 667
    n_target_ifaces = argc - optind;
#line 668
    ret = (_Bool)1;
    }
#line 671
    if (n_target_ifaces == 0) {
#line 672
      i___0 = 0;
      {
#line 672
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 672
        if (! (i___0 < n_up_ifaces)) {
#line 672
          goto while_break___1;
        }
        {
#line 673
        puts((char const   *)*(up_ifaces + i___0));
#line 672
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 677
      j = 0;
      {
#line 677
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 677
        if (! (j < n_target_ifaces)) {
#line 677
          goto while_break___2;
        }
        {
#line 678
        tmp___13 = strlen((char const   *)*(target_iface + j));
#line 678
        l___1 = tmp___13;
#line 679
        found = (_Bool)0;
#line 680
        i___0 = 0;
        }
        {
#line 680
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 680
          if (! (i___0 < n_up_ifaces)) {
#line 680
            goto while_break___3;
          }
          {
#line 681
          tmp___14 = strncmp((char const   *)*(target_iface + j), (char const   *)*(up_ifaces + i___0),
                             l___1);
          }
#line 681
          if (tmp___14 == 0) {
#line 682
            if ((int )*(*(up_ifaces + i___0) + l___1) == 61) {
              {
#line 683
              puts((char const   *)*(up_ifaces + i___0));
#line 684
              found = (_Bool)1;
              }
#line 685
              goto while_break___3;
            }
          }
#line 680
          i___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 689
        ret = (_Bool )((int )ret & (int )found);
#line 677
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 692
    exit(! ret);
    }
  }
#line 695
  if (argc - optind > 0) {
#line 695
    if (do_all) {
      {
#line 696
      usage(*(argv + 0));
      }
    } else
#line 695
    if (list) {
      {
#line 696
      usage(*(argv + 0));
      }
    }
  }
#line 698
  if (argc - optind == 0) {
#line 698
    if (! do_all) {
#line 698
      if (! list) {
        {
#line 699
        usage(*(argv + 0));
        }
      }
    }
  }
#line 701
  if (do_all) {
#line 701
    if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
      {
#line 702
      usage(*(argv + 0));
      }
    }
  }
  {
#line 705
  defn = read_interfaces(interfaces);
  }
#line 706
  if (! defn) {
    {
#line 707
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: couldn\'t read interfaces file \"%s\"\n",
            *(argv + 0), interfaces);
#line 708
    exit(1);
    }
  }
#line 711
  if (do_all) {
#line 711
    goto _L___1;
  } else
#line 711
  if (list) {
    _L___1: /* CIL Label */ 
#line 712
    if ((unsigned long )cmds == (unsigned long )(& iface_list)) {
#line 712
      goto _L___0;
    } else
#line 712
    if ((unsigned long )cmds == (unsigned long )(& iface_up)) {
      _L___0: /* CIL Label */ 
#line 714
      if (allow_class) {
#line 714
        tmp___15 = (char const   *)allow_class;
      } else {
#line 714
        tmp___15 = "auto";
      }
      {
#line 714
      tmp___16 = find_allowup(defn, (char *)tmp___15);
#line 714
      autos = tmp___16;
      }
#line 715
      if (autos) {
#line 715
        target_iface = autos->interfaces;
      } else {
#line 715
        target_iface = (char **)((void *)0);
      }
#line 716
      if (autos) {
#line 716
        n_target_ifaces = autos->n_interfaces;
      } else {
#line 716
        n_target_ifaces = 0;
      }
    } else
#line 717
    if ((unsigned long )cmds == (unsigned long )(& iface_down)) {
      {
#line 718
      read_all_state((char const   *)*(argv + 0), & target_iface, & n_target_ifaces);
      }
    } else {
      {
#line 719
      tmp___17 = auto_disabled();
      }
#line 719
      if (tmp___17 != 0) {
        {
#line 720
        printf((char const   */* __restrict  */)"WARNING: ifup -a is disabled in favour of NetworkManager.\n  Set ifupdown:managed=false in /etc/NetworkManager/NetworkManager.conf.\n");
#line 722
        exit(0);
        }
      } else {
        {
#line 724
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t tell if interfaces are going up or down\n",
                *(argv + 0));
#line 725
        exit(1);
        }
      }
    }
  } else {
#line 728
    target_iface = argv + optind;
#line 729
    n_target_ifaces = argc - optind;
  }
#line 731
  meta_iface.next = (interface_defn *)((void *)0);
#line 731
  meta_iface.logical_iface = (char *)0;
#line 731
  meta_iface.real_iface = (char *)"--all";
#line 731
  meta_iface.address_family = & addr_meta;
#line 731
  meta_iface.method = addr_meta.method + 0;
#line 731
  meta_iface.automatic = 1;
#line 731
  meta_iface.max_options = 0;
#line 731
  meta_iface.n_options = 0;
#line 731
  meta_iface.option = (variable *)((void *)0);
#line 742
  if (do_all) {
#line 743
    if (allow_class) {
#line 743
      meta_iface.logical_iface = allow_class;
    } else {
#line 743
      meta_iface.logical_iface = (char *)"auto";
    }
#line 745
    okay = 1;
#line 746
    if ((unsigned long )cmds == (unsigned long )(& iface_up)) {
      {
#line 747
      okay = iface_preup(& meta_iface);
      }
    }
#line 749
    if ((unsigned long )cmds == (unsigned long )(& iface_down)) {
      {
#line 750
      okay = iface_predown(& meta_iface);
      }
    }
#line 752
    if (! okay) {
      {
#line 753
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: pre-%s script failed.\n",
              *(argv + 0), *(argv + 0) + 2);
#line 754
      exit(1);
      }
    }
  }
#line 758
  lock = (FILE *)((void *)0);
#line 759
  plock = (FILE *)((void *)0);
#line 763
  i___1 = 0;
  {
#line 763
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 763
    if (! (i___1 < n_target_ifaces)) {
#line 763
      goto while_break___4;
    }
#line 764
    if (lock) {
      {
#line 765
      fclose(lock);
#line 766
      lock = (FILE *)((void *)0);
      }
    }
    {
#line 769
    current_state = (char *)((void *)0);
#line 772
    strncpy((char */* __restrict  */)(iface), (char const   */* __restrict  */)*(target_iface + i___1),
            sizeof(iface));
#line 773
    iface[sizeof(iface) - 1UL] = (char )'\000';
#line 776
    pch = strchr((char const   *)(iface), '=');
    }
#line 776
    if (pch) {
      {
#line 777
      *pch = (char )'\000';
#line 778
      strncpy((char */* __restrict  */)(liface), (char const   */* __restrict  */)(pch + 1),
              sizeof(liface));
#line 779
      liface[sizeof(liface) - 1UL] = (char )'\000';
      }
    } else {
      {
#line 781
      strncpy((char */* __restrict  */)(liface), (char const   */* __restrict  */)(iface),
              sizeof(liface));
#line 782
      liface[sizeof(liface) - 1UL] = (char )'\000';
      }
    }
    {
#line 788
    snprintf((char */* __restrict  */)(envname), sizeof(envname), (char const   */* __restrict  */)"IFUPDOWN_%s",
             iface);
#line 789
    tmp___18 = getenv((char const   *)(envname));
#line 789
    envval = tmp___18;
    }
#line 790
    if (envval) {
      {
#line 791
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: recursion detected for interface %s in %s phase\n",
              *(argv + 0), iface, envval);
      }
#line 792
      goto __Cont;
    }
    {
#line 798
    strncpy((char */* __restrict  */)(piface), (char const   */* __restrict  */)(iface),
            sizeof(piface));
#line 799
    pch = strchr((char const   *)(piface), '.');
    }
#line 799
    if (pch) {
      {
#line 800
      *pch = (char )'\000';
#line 801
      snprintf((char */* __restrict  */)(envname), sizeof(envname), (char const   */* __restrict  */)"IFUPDOWN_%s",
               piface);
#line 802
      tmp___19 = getenv((char const   *)(envname));
#line 802
      envval___0 = tmp___19;
      }
#line 803
      if (envval___0) {
        {
#line 804
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: recursion detected for parent interface %s in %s phase\n",
                *(argv + 0), piface, envval___0);
        }
#line 805
        return (0);
      }
      {
#line 808
      plock = lock_interface((char const   *)*(argv + 0), (char const   *)(piface),
                             (char **)((void *)0));
      }
    }
    {
#line 811
    lock = lock_interface((char const   *)*(argv + 0), (char const   *)(iface), & current_state);
    }
#line 813
    if (! force) {
#line 815
      if ((unsigned long )cmds == (unsigned long )(& iface_up)) {
#line 816
        if ((unsigned long )current_state != (unsigned long )((void *)0)) {
#line 817
          if (! do_all) {
            {
#line 818
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: interface %s already configured\n",
                    *(argv + 0), iface);
            }
          }
#line 820
          goto __Cont;
        }
      } else
#line 822
      if ((unsigned long )cmds == (unsigned long )(& iface_down)) {
#line 823
        if ((unsigned long )current_state == (unsigned long )((void *)0)) {
#line 824
          if (! do_all) {
            {
#line 825
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: interface %s not configured\n",
                    *(argv + 0), iface);
            }
          }
#line 827
          goto __Cont;
        }
        {
#line 829
        strncpy((char */* __restrict  */)(liface), (char const   */* __restrict  */)current_state,
                (size_t )80);
#line 830
        liface[79] = (char)0;
        }
      } else
#line 831
      if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
#line 832
        if ((unsigned long )current_state != (unsigned long )((void *)0)) {
          {
#line 833
          strncpy((char */* __restrict  */)(liface), (char const   */* __restrict  */)current_state,
                  (size_t )80);
#line 834
          liface[79] = (char)0;
#line 835
          run_mappings = 0;
          }
        }
      } else
#line 838
      if (! ((unsigned long )cmds == (unsigned long )(& iface_list))) {
#line 838
        if (! ((unsigned long )cmds == (unsigned long )(& iface_query))) {
          {
#line 840
          __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c",
                        840U, "main");
          }
        }
      }
    }
#line 845
    if ((unsigned long )allow_class != (unsigned long )((void *)0)) {
      {
#line 848
      tmp___20 = find_allowup(defn, allow_class);
#line 848
      allowup = tmp___20;
      }
#line 849
      if ((unsigned long )allowup == (unsigned long )((void *)0)) {
#line 850
        goto __Cont;
      }
#line 852
      i___2 = 0;
      {
#line 852
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 852
        if (! (i___2 < allowup->n_interfaces)) {
#line 852
          goto while_break___5;
        }
        {
#line 853
        tmp___21 = strcmp((char const   *)*(allowup->interfaces + i___2), (char const   *)(iface));
        }
#line 853
        if (tmp___21 == 0) {
#line 854
          goto while_break___5;
        }
#line 852
        i___2 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 856
      if (i___2 >= allowup->n_interfaces) {
#line 857
        goto __Cont;
      }
    }
#line 861
    if (excludeints != 0) {
      {
#line 861
      tmp___22 = match_patterns(iface, excludeints, excludeint);
      }
#line 861
      if (tmp___22) {
#line 862
        goto __Cont;
      }
    }
#line 864
    have_mapping = (_Bool)0;
#line 865
    if ((unsigned long )cmds == (unsigned long )(& iface_up)) {
#line 865
      if (run_mappings) {
#line 865
        goto _L___2;
      } else {
#line 865
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 865
    if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
      _L___2: /* CIL Label */ 
#line 868
      currmap = defn->mappings;
      {
#line 868
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 868
        if (! currmap) {
#line 868
          goto while_break___6;
        }
#line 870
        i___3 = 0;
        {
#line 870
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 870
          if (! (i___3 < currmap->n_matches)) {
#line 870
            goto while_break___7;
          }
          {
#line 871
          tmp___23 = fnmatch((char const   *)*(currmap->match + i___3), (char const   *)(liface),
                             0);
          }
#line 871
          if (tmp___23 != 0) {
#line 872
            goto __Cont___0;
          }
#line 873
          if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
#line 873
            if (! run_mappings) {
#line 874
              if (verbose) {
                {
#line 875
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not running mapping scripts for %s\n",
                        liface);
                }
              }
#line 877
              have_mapping = (_Bool)1;
#line 878
              goto while_break___7;
            }
          }
#line 880
          if (verbose) {
            {
#line 881
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Running mapping script %s on %s\n",
                    currmap->script, liface);
            }
          }
          {
#line 883
          run_mapping(iface, liface, (int )sizeof(liface), currmap);
          }
#line 884
          goto while_break___7;
          __Cont___0: /* CIL Label */ 
#line 870
          i___3 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 868
        currmap = currmap->next;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 892
    okay___0 = 0;
#line 893
    failed = 0;
#line 896
    if ((unsigned long )cmds == (unsigned long )(& iface_up)) {
#line 897
      if ((unsigned long )current_state == (unsigned long )((void *)0)) {
#line 897
        goto _L___4;
      } else
#line 897
      if (no_act) {
        _L___4: /* CIL Label */ 
#line 898
        if (failed == 1) {
          {
#line 899
          printf((char const   */* __restrict  */)"Failed to bring up %s.\n", liface);
#line 900
          update_state((char const   *)*(argv + 0), (char const   *)(iface), (char const   *)((void *)0),
                       lock);
          }
        } else {
          {
#line 902
          update_state((char const   *)*(argv + 0), (char const   *)(iface), (char const   *)(liface),
                       lock);
          }
        }
      } else {
        {
#line 905
        update_state((char const   *)*(argv + 0), (char const   *)(iface), (char const   *)(liface),
                     lock);
        }
      }
    } else
#line 907
    if ((unsigned long )cmds == (unsigned long )(& iface_down)) {
      {
#line 908
      update_state((char const   *)*(argv + 0), (char const   *)(iface), (char const   *)((void *)0),
                   lock);
      }
    } else
#line 909
    if (! ((unsigned long )cmds == (unsigned long )(& iface_list))) {
#line 909
      if (! ((unsigned long )cmds == (unsigned long )(& iface_query))) {
        {
#line 911
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c",
                      911U, "main");
        }
      }
    }
#line 915
    if ((unsigned long )cmds == (unsigned long )(& iface_list)) {
#line 916
      currif = defn->ifaces;
      {
#line 916
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 916
        if (! currif) {
#line 916
          goto while_break___8;
        }
        {
#line 917
        tmp___24 = strcmp((char const   *)(liface), (char const   *)currif->logical_iface);
        }
#line 917
        if (tmp___24 == 0) {
#line 918
          okay___0 = 1;
        }
#line 916
        currif = currif->next;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 921
      if (! okay___0) {
#line 923
        currmap___0 = defn->mappings;
        {
#line 923
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 923
          if (! currmap___0) {
#line 923
            goto while_break___9;
          }
#line 925
          i___4 = 0;
          {
#line 925
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 925
            if (! (i___4 < currmap___0->n_matches)) {
#line 925
              goto while_break___10;
            }
            {
#line 926
            tmp___25 = fnmatch((char const   *)*(currmap___0->match + i___4), (char const   *)(liface),
                               0);
            }
#line 926
            if (tmp___25 != 0) {
#line 927
              goto __Cont___1;
            }
#line 928
            okay___0 = 1;
#line 929
            goto while_break___10;
            __Cont___1: /* CIL Label */ 
#line 925
            i___4 ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 923
          currmap___0 = currmap___0->next;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 933
      if (okay___0) {
        {
#line 934
        currif = defn->ifaces;
#line 935
        currif->real_iface = iface;
#line 936
        (*cmds)(currif);
#line 937
        currif->real_iface = (char *)((void *)0);
        }
      }
#line 939
      okay___0 = 0;
#line 940
      goto __Cont;
    }
#line 943
    currif = defn->ifaces;
    {
#line 943
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 943
      if (! currif) {
#line 943
        goto while_break___11;
      }
      {
#line 944
      tmp___39 = strcmp((char const   *)(liface), (char const   *)currif->logical_iface);
      }
#line 944
      if (tmp___39 == 0) {
#line 945
        if (! okay___0) {
#line 945
          if ((unsigned long )cmds == (unsigned long )(& iface_up)) {
            {
#line 946
            link___0.next = (interface_defn *)0;
#line 946
            link___0.logical_iface = liface;
#line 946
            link___0.real_iface = iface;
#line 946
            link___0.address_family = & addr_link;
#line 946
            link___0.method = addr_link.method + 0;
#line 946
            link___0.automatic = 0;
#line 946
            link___0.max_options = 0;
#line 946
            link___0.n_options = 0;
#line 946
            link___0.option = (variable *)((void *)0);
#line 955
            convert_variables(*(argv + 0), (link___0.method)->conversions, & link___0);
#line 957
            tmp___26 = (*((link___0.method)->up))(& link___0, & doit);
            }
#line 957
            if (! tmp___26) {
#line 958
              goto while_break___11;
            }
#line 959
            if (link___0.option) {
              {
#line 960
              free((void *)link___0.option);
              }
            }
          }
        }
#line 962
        okay___0 = 1;
#line 966
        o = (currif->method)->defaults;
        {
#line 966
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 966
          if (o) {
#line 966
            if (o->option) {
#line 966
              if (! o->value) {
#line 966
                goto while_break___12;
              }
            } else {
#line 966
              goto while_break___12;
            }
          } else {
#line 966
            goto while_break___12;
          }
#line 968
          found___0 = 0;
#line 969
          j___0 = 0;
          {
#line 969
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 969
            if (! (j___0 < currif->n_options)) {
#line 969
              goto while_break___13;
            }
            {
#line 970
            tmp___27 = strcmp((char const   *)(currif->option + j___0)->name, (char const   *)o->option);
            }
#line 970
            if (tmp___27 == 0) {
#line 971
              found___0 = 1;
#line 972
              goto while_break___13;
            }
#line 969
            j___0 ++;
          }
          while_break___13: /* CIL Label */ ;
          }
#line 975
          if (! found___0) {
            {
#line 976
            set_variable(*(argv + 0), o->option, o->value, & currif->option, & currif->n_options,
                         & currif->max_options);
            }
          }
#line 966
          o ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 983
        i___5 = 0;
        {
#line 983
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 983
          if (! (i___5 < n_options)) {
#line 983
            goto while_break___14;
          }
#line 984
          if ((int )*((option + i___5)->value + 0) == 0) {
            {
#line 986
            tmp___29 = strcmp((char const   *)(option + i___5)->name, "pre-up");
            }
#line 986
            if (tmp___29 != 0) {
              {
#line 986
              tmp___30 = strcmp((char const   *)(option + i___5)->name, "up");
              }
#line 986
              if (tmp___30 != 0) {
                {
#line 986
                tmp___31 = strcmp((char const   *)(option + i___5)->name, "down");
                }
#line 986
                if (tmp___31 != 0) {
                  {
#line 986
                  tmp___32 = strcmp((char const   *)(option + i___5)->name, "post-down");
                  }
#line 986
                  if (tmp___32 != 0) {
#line 989
                    j___1 = 0;
                    {
#line 989
                    while (1) {
                      while_continue___15: /* CIL Label */ ;
#line 989
                      if (! (j___1 < currif->n_options)) {
#line 989
                        goto while_break___15;
                      }
                      {
#line 990
                      tmp___28 = strcmp((char const   *)(currif->option + j___1)->name,
                                        (char const   *)(option + i___5)->name);
                      }
#line 990
                      if (tmp___28 == 0) {
#line 991
                        (currif->n_options) --;
#line 992
                        goto while_break___15;
                      }
#line 989
                      j___1 ++;
                    }
                    while_break___15: /* CIL Label */ ;
                    }
                    {
#line 995
                    while (1) {
                      while_continue___16: /* CIL Label */ ;
#line 995
                      if (! (j___1 < currif->n_options)) {
#line 995
                        goto while_break___16;
                      }
#line 996
                      (option + j___1)->name = (option + (j___1 + 1))->name;
#line 997
                      (option + j___1)->value = (option + (j___1 + 1))->value;
#line 995
                      j___1 ++;
                    }
                    while_break___16: /* CIL Label */ ;
                    }
                  }
                }
              }
            }
          } else {
            {
#line 1005
            set_variable(*(argv + 0), (option + i___5)->name, (option + i___5)->value,
                         & currif->option, & currif->n_options, & currif->max_options);
            }
          }
#line 983
          i___5 ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        {
#line 1011
        currif->real_iface = iface;
#line 1014
        convert_variables(*(argv + 0), (currif->method)->conversions, currif);
        }
#line 1018
        if (verbose) {
#line 1019
          if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
#line 1019
            tmp___33 = "Querying";
          } else {
#line 1019
            tmp___33 = "Configuring";
          }
          {
#line 1019
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s interface %s=%s (%s)\n",
                  tmp___33, iface, liface, (currif->address_family)->name);
          }
        }
        {
#line 1025
        command___0 = strrchr((char const   *)*(argv + 0), '/');
        }
#line 1025
        if (command___0) {
#line 1026
          command___0 ++;
        } else {
#line 1028
          command___0 = *(argv + 0);
        }
        {
#line 1030
        make_pidfile_name(pidfilename, sizeof(pidfilename), (char const   *)command___0,
                          currif);
        }
#line 1033
        if (! no_act) {
          {
#line 1034
          tmp___34 = fopen((char const   */* __restrict  */)(pidfilename), (char const   */* __restrict  */)"w");
#line 1034
          pidfile = tmp___34;
          }
#line 1035
          if (pidfile) {
            {
#line 1036
            tmp___35 = getpid();
#line 1036
            fprintf((FILE */* __restrict  */)pidfile, (char const   */* __restrict  */)"%d",
                    tmp___35);
#line 1037
            fclose(pidfile);
            }
          } else {
            {
#line 1039
            tmp___36 = __errno_location();
#line 1039
            tmp___37 = strerror(*tmp___36);
#line 1039
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to open pid file %s: %s\n",
                    command___0, pidfilename, tmp___37);
            }
          }
        }
        {
#line 1044
        tmp___38 = (*cmds)(currif);
        }
        {
#line 1045
        if (tmp___38 == -1) {
#line 1045
          goto case_neg_1;
        }
#line 1049
        if (tmp___38 == 0) {
#line 1049
          goto case_0;
        }
#line 1053
        if (tmp___38 == 1) {
#line 1053
          goto case_1___0;
        }
#line 1057
        goto switch_default___0;
        case_neg_1: /* CIL Label */ 
        {
#line 1046
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing required configuration variables for interface %s/%s.\n",
                liface, (currif->address_family)->name);
#line 1047
        failed = 1;
        }
#line 1048
        goto switch_break___0;
        case_0: /* CIL Label */ 
#line 1050
        failed = 1;
#line 1051
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
#line 1054
        failed = 0;
#line 1055
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 1058
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected value when configuring interface %s/%s; considering it failed.\n",
                liface, (currif->address_family)->name);
#line 1059
        failed = 1;
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 1063
        if (! no_act) {
          {
#line 1064
          unlink((char const   *)(pidfilename));
          }
        }
#line 1068
        currif->real_iface = (char *)((void *)0);
#line 1070
        if (failed) {
#line 1071
          goto while_break___11;
        }
      }
#line 943
      currif = currif->next;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1077
    if (okay___0) {
#line 1077
      if ((unsigned long )cmds == (unsigned long )(& iface_down)) {
        {
#line 1078
        link___1.next = (interface_defn *)0;
#line 1078
        link___1.logical_iface = liface;
#line 1078
        link___1.real_iface = iface;
#line 1078
        link___1.address_family = & addr_link;
#line 1078
        link___1.method = addr_link.method + 0;
#line 1078
        link___1.automatic = 0;
#line 1078
        link___1.max_options = 0;
#line 1078
        link___1.n_options = 0;
#line 1078
        link___1.option = (variable *)((void *)0);
#line 1087
        convert_variables(*(argv + 0), (link___1.method)->conversions, & link___1);
#line 1089
        tmp___40 = (*((link___1.method)->down))(& link___1, & doit);
        }
#line 1089
        if (! tmp___40) {
#line 1090
          goto while_break___4;
        }
#line 1091
        if (link___1.option) {
          {
#line 1092
          free((void *)link___1.option);
          }
        }
      }
    }
#line 1095
    if (! okay___0) {
#line 1095
      if ((unsigned long )cmds == (unsigned long )(& iface_query)) {
#line 1096
        if (! run_mappings) {
#line 1097
          if (have_mapping) {
#line 1098
            okay___0 = 1;
          }
        }
#line 1101
        if (! okay___0) {
          {
#line 1102
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown interface %s\n",
                  iface);
          }
#line 1103
          return (1);
        }
      }
    }
#line 1107
    if (! okay___0) {
#line 1107
      if (! force) {
        {
#line 1108
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring unknown interface %s=%s.\n",
                iface, liface);
#line 1109
        update_state((char const   *)*(argv + 0), (char const   *)(iface), (char const   *)((void *)0),
                     lock);
        }
      } else {
#line 1107
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 1112
    if ((unsigned long )cmds == (unsigned long )(& iface_up)) {
#line 1113
      if ((unsigned long )current_state == (unsigned long )((void *)0)) {
#line 1113
        goto _L___5;
      } else
#line 1113
      if (no_act) {
        _L___5: /* CIL Label */ 
#line 1114
        if (failed == 1) {
          {
#line 1115
          printf((char const   */* __restrict  */)"Failed to bring up %s.\n", liface);
#line 1116
          update_state((char const   *)*(argv + 0), (char const   *)(iface), (char const   *)((void *)0),
                       lock);
          }
        } else {
          {
#line 1118
          update_state((char const   *)*(argv + 0), (char const   *)(iface), (char const   *)(liface),
                       lock);
          }
        }
      } else {
        {
#line 1121
        update_state((char const   *)*(argv + 0), (char const   *)(iface), (char const   *)(liface),
                     lock);
        }
      }
    } else
#line 1123
    if ((unsigned long )cmds == (unsigned long )(& iface_down)) {
      {
#line 1124
      update_state((char const   *)*(argv + 0), (char const   *)(iface), (char const   *)((void *)0),
                   lock);
      }
    } else
#line 1125
    if (! ((unsigned long )cmds == (unsigned long )(& iface_list))) {
#line 1125
      if (! ((unsigned long )cmds == (unsigned long )(& iface_query))) {
        {
#line 1127
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/ifupdown-0.7.47.2ubuntu4.3/main.c",
                      1127U, "main");
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 763
    i___1 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1135
  if (lock) {
    {
#line 1136
    fclose(lock);
#line 1137
    lock = (FILE *)((void *)0);
    }
  }
#line 1140
  if (plock) {
    {
#line 1141
    fclose(plock);
#line 1142
    plock = (FILE *)((void *)0);
    }
  }
#line 1145
  if (do_all) {
#line 1146
    okay___1 = 1;
#line 1147
    if ((unsigned long )cmds == (unsigned long )(& iface_up)) {
      {
#line 1148
      okay___1 = iface_postup(& meta_iface);
      }
    }
#line 1150
    if ((unsigned long )cmds == (unsigned long )(& iface_down)) {
      {
#line 1151
      okay___1 = iface_postdown(& meta_iface);
      }
    }
#line 1153
    if (! okay___1) {
      {
#line 1154
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: post-%s script failed.\n",
              *(argv + 0), *(argv + 0) + 2);
#line 1155
      exit(1);
      }
    }
  }
#line 1159
  return (0);
}
}
