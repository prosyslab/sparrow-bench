/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 39 "/usr/include/linux/usbdevice_fs.h"
struct usbdevfs_ctrltransfer {
   __u8 bRequestType ;
   __u8 bRequest ;
   __u16 wValue ;
   __u16 wIndex ;
   __u16 wLength ;
   __u32 timeout ;
   void *data ;
};
#line 439 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
enum __anonenum_ram_mode_27 {
    _undef = 0,
    internal_only = 1,
    skip_internal = 2,
    skip_external = 3
} ;
#line 439 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
typedef enum __anonenum_ram_mode_27 ram_mode;
#line 446 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
struct ram_poke_context {
   int device ;
   ram_mode mode ;
   unsigned int total ;
   unsigned int count ;
};
#line 616 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
struct eeprom_poke_context {
   int device ;
   unsigned short ee_addr ;
   int last ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 803 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.h"
int ezusb_load_ram(int fd , char const   *path , int fx2 , int stage ) ;
#line 47
int ezusb_load_eeprom(int dev , char const   *path , char const   *type , int config ) ;
#line 56
int verbose ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/main.c"
static int dosyslog  =    0;
#line 74
void ( /* format attribute */ /* format attribute */  logerror)(char const   *format 
                                                                , ...) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/main.c"
void ( /* format attribute */ /* format attribute */  logerror)(char const   *format 
                                                                , ...) 
{ 
  va_list ap ;

  {
  {
#line 80
  __builtin_va_start(ap, format);
  }
#line 82
  if (dosyslog) {
    {
#line 83
    vsyslog(3, format, ap);
    }
  } else {
    {
#line 85
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             ap);
    }
  }
  {
#line 86
  __builtin_va_end(ap);
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/main.c"
int main(int argc , char **argv ) 
{ 
  char const   *link_path ;
  char const   *ihex_path ;
  char const   *device_path ;
  char *tmp ;
  char const   *type ;
  char const   *stage1 ;
  mode_t mode ;
  int opt ;
  int config ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int fd ;
  int tmp___7 ;
  int status ;
  int fx2 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int rc ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int rc___0 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 91
  link_path = (char const   *)0;
#line 92
  ihex_path = (char const   *)0;
#line 93
  tmp = getenv("DEVNAME");
#line 93
  device_path = (char const   *)tmp;
#line 94
  type = (char const   *)0;
#line 95
  stage1 = (char const   *)0;
#line 96
  mode = (mode_t )0;
#line 98
  config = -1;
  }
#line 100
  if (! device_path) {
    {
#line 101
    tmp___0 = getenv("DEVICE");
#line 101
    device_path = (char const   *)tmp___0;
    }
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    opt = getopt(argc, (char * const  *)argv, "2vV?D:I:L:c:lm:s:t:");
    }
#line 103
    if (! (opt != -1)) {
#line 103
      goto while_break;
    }
    {
#line 106
    if (opt == 50) {
#line 106
      goto case_50;
    }
#line 110
    if (opt == 68) {
#line 110
      goto case_68;
    }
#line 114
    if (opt == 73) {
#line 114
      goto case_73;
    }
#line 118
    if (opt == 76) {
#line 118
      goto case_76;
    }
#line 122
    if (opt == 86) {
#line 122
      goto case_86;
    }
#line 126
    if (opt == 99) {
#line 126
      goto case_99;
    }
#line 134
    if (opt == 108) {
#line 134
      goto case_108;
    }
#line 139
    if (opt == 109) {
#line 139
      goto case_109;
    }
#line 144
    if (opt == 115) {
#line 144
      goto case_115;
    }
#line 148
    if (opt == 116) {
#line 148
      goto case_116;
    }
#line 160
    if (opt == 118) {
#line 160
      goto case_118;
    }
#line 165
    goto switch_default;
    case_50: /* CIL Label */ 
#line 107
    type = "fx2";
#line 108
    goto switch_break;
    case_68: /* CIL Label */ 
#line 111
    device_path = (char const   *)optarg;
#line 112
    goto switch_break;
    case_73: /* CIL Label */ 
#line 115
    ihex_path = (char const   *)optarg;
#line 116
    goto switch_break;
    case_76: /* CIL Label */ 
#line 119
    link_path = (char const   *)optarg;
#line 120
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 123
    puts("Mar  3 2016 (development)");
    }
#line 124
    return (0);
    case_99: /* CIL Label */ 
    {
#line 127
    tmp___1 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)0,
                      0);
#line 127
    config = (int )tmp___1;
    }
#line 128
    if (config < 0) {
      {
#line 129
      logerror("illegal config byte: %s\n", optarg);
      }
#line 130
      goto usage;
    } else
#line 128
    if (config > 255) {
      {
#line 129
      logerror("illegal config byte: %s\n", optarg);
      }
#line 130
      goto usage;
    }
#line 132
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 135
    openlog((char const   *)*(argv + 0), 50, 1 << 3);
#line 136
    dosyslog = 1;
    }
#line 137
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 140
    tmp___2 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)0,
                      0);
#line 140
    mode = (mode_t )tmp___2;
#line 141
    mode &= 511U;
    }
#line 142
    goto switch_break;
    case_115: /* CIL Label */ 
#line 145
    stage1 = (char const   *)optarg;
#line 146
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 149
    tmp___3 = strcmp((char const   *)optarg, "an21");
    }
#line 149
    if (tmp___3) {
      {
#line 149
      tmp___4 = strcmp((char const   *)optarg, "fx");
      }
#line 149
      if (tmp___4) {
        {
#line 149
        tmp___5 = strcmp((char const   *)optarg, "fx2");
        }
#line 149
        if (tmp___5) {
          {
#line 149
          tmp___6 = strcmp((char const   *)optarg, "fx2lp");
          }
#line 149
          if (tmp___6) {
            {
#line 154
            logerror("illegal microcontroller type: %s\n", optarg);
            }
#line 155
            goto usage;
          }
        }
      }
    }
#line 157
    type = (char const   *)optarg;
#line 158
    goto switch_break;
    case_118: /* CIL Label */ 
#line 161
    verbose ++;
#line 162
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 166
    goto usage;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  if (config >= 0) {
#line 171
    if ((unsigned long )type == (unsigned long )((char const   *)0)) {
      {
#line 172
      logerror("must specify microcontroller type %s", "to write EEPROM!\n");
      }
#line 174
      goto usage;
    }
#line 176
    if (! stage1) {
      {
#line 177
      logerror("need 2nd stage loader and firmware %s", "to write EEPROM!\n");
      }
#line 179
      goto usage;
    } else
#line 176
    if (! ihex_path) {
      {
#line 177
      logerror("need 2nd stage loader and firmware %s", "to write EEPROM!\n");
      }
#line 179
      goto usage;
    }
#line 181
    if (link_path) {
      {
#line 182
      logerror("links and modes not set up when writing EEPROM\n");
      }
#line 183
      goto usage;
    } else
#line 181
    if (mode) {
      {
#line 182
      logerror("links and modes not set up when writing EEPROM\n");
      }
#line 183
      goto usage;
    }
  }
#line 187
  if (! device_path) {
    {
#line 188
    logerror("no device specified!\n");
    }
    usage: 
    {
#line 190
    fputs((char const   */* __restrict  */)"usage: ", (FILE */* __restrict  */)stderr);
#line 191
    fputs((char const   */* __restrict  */)*(argv + 0), (FILE */* __restrict  */)stderr);
#line 192
    fputs((char const   */* __restrict  */)" [-vV] [-l] [-t type] [-D devpath]\n",
          (FILE */* __restrict  */)stderr);
#line 193
    fputs((char const   */* __restrict  */)"\t\t[-I firmware_hexfile] ", (FILE */* __restrict  */)stderr);
#line 194
    fputs((char const   */* __restrict  */)"[-s loader] [-c config_byte]\n", (FILE */* __restrict  */)stderr);
#line 195
    fputs((char const   */* __restrict  */)"\t\t[-L link] [-m mode]\n", (FILE */* __restrict  */)stderr);
#line 196
    fputs((char const   */* __restrict  */)"... [-D devpath] overrides DEVNAME= and DEVICE= in env\n",
          (FILE */* __restrict  */)stderr);
#line 197
    fputs((char const   */* __restrict  */)"... device types:  one of an21, fx, fx2, fx2lp\n",
          (FILE */* __restrict  */)stderr);
#line 198
    fputs((char const   */* __restrict  */)"... at least one of -I, -L, -m is required\n",
          (FILE */* __restrict  */)stderr);
    }
#line 199
    return (-1);
  }
#line 202
  if (ihex_path) {
    {
#line 203
    tmp___7 = open(device_path, 2);
#line 203
    fd = tmp___7;
    }
#line 207
    if (fd == -1) {
      {
#line 208
      tmp___8 = __errno_location();
#line 208
      tmp___9 = strerror(*tmp___8);
#line 208
      logerror("%s : %s\n", tmp___9, device_path);
      }
#line 209
      return (-1);
    }
#line 212
    if ((unsigned long )type == (unsigned long )((char const   *)0)) {
#line 213
      type = "fx";
#line 214
      fx2 = 0;
    } else {
      {
#line 215
      tmp___11 = strcmp(type, "fx2lp");
      }
#line 215
      if (tmp___11 == 0) {
#line 216
        fx2 = 2;
      } else {
        {
#line 218
        tmp___10 = strcmp(type, "fx2");
#line 218
        fx2 = tmp___10 == 0;
        }
      }
    }
#line 220
    if (verbose) {
      {
#line 221
      logerror("microcontroller type: %s\n", type);
      }
    }
#line 223
    if (stage1) {
#line 225
      if (verbose) {
        {
#line 226
        logerror("1st stage:  load 2nd stage loader\n");
        }
      }
      {
#line 227
      status = ezusb_load_ram(fd, stage1, fx2, 0);
      }
#line 228
      if (status != 0) {
#line 229
        return (status);
      }
#line 232
      if (config >= 0) {
        {
#line 233
        status = ezusb_load_eeprom(fd, ihex_path, type, config);
        }
      } else {
        {
#line 235
        status = ezusb_load_ram(fd, ihex_path, fx2, 1);
        }
      }
#line 236
      if (status != 0) {
#line 237
        return (status);
      }
    } else {
#line 240
      if (verbose) {
        {
#line 241
        logerror("single stage:  load on-chip memory\n");
        }
      }
      {
#line 242
      status = ezusb_load_ram(fd, ihex_path, fx2, 0);
      }
#line 243
      if (status != 0) {
#line 244
        return (status);
      }
    }
  }
#line 252
  if (link_path) {
    {
#line 253
    tmp___12 = unlink(link_path);
#line 253
    rc = tmp___12;
#line 254
    rc = symlink(device_path, link_path);
    }
#line 255
    if (rc == -1) {
      {
#line 256
      tmp___13 = __errno_location();
#line 256
      tmp___14 = strerror(*tmp___13);
#line 256
      logerror("%s : %s\n", tmp___14, link_path);
      }
#line 257
      return (-1);
    }
  }
#line 261
  if (mode != 0U) {
    {
#line 262
    tmp___15 = chmod(device_path, mode);
#line 262
    rc___0 = tmp___15;
    }
#line 263
    if (rc___0 == -1) {
      {
#line 264
      tmp___16 = __errno_location();
#line 264
      tmp___17 = strerror(*tmp___16);
#line 264
      logerror("%s : %s\n", tmp___17, link_path);
      }
#line 265
      return (-1);
    }
  }
#line 269
  if (! ihex_path) {
#line 269
    if (! link_path) {
#line 269
      if (! mode) {
        {
#line 270
        logerror("missing request! (firmware, link, or mode)\n");
        }
#line 271
        return (-1);
      }
    }
  }
#line 274
  return (0);
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.h"
int verbose  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
static int fx_is_external(unsigned short addr , size_t len ) 
{ 


  {
#line 70
  if ((int )addr <= 6975) {
#line 71
    return ((size_t )addr + len > 6976UL);
  }
#line 77
  return (1);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
static int fx2_is_external(unsigned short addr , size_t len ) 
{ 


  {
#line 87
  if ((int )addr <= 8191) {
#line 88
    return ((size_t )addr + len > 8192UL);
  } else
#line 91
  if ((int )addr >= 57344) {
#line 91
    if ((int )addr <= 57855) {
#line 92
      return ((size_t )addr + len > 57856UL);
    } else {
#line 96
      return (1);
    }
  } else {
#line 96
    return (1);
  }
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
static int fx2lp_is_external(unsigned short addr , size_t len ) 
{ 


  {
#line 106
  if ((int )addr <= 16383) {
#line 107
    return ((size_t )addr + len > 16384UL);
  } else
#line 110
  if ((int )addr >= 57344) {
#line 110
    if ((int )addr <= 57855) {
#line 111
      return ((size_t )addr + len > 57856UL);
    } else {
#line 115
      return (1);
    }
  } else {
#line 115
    return (1);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
__inline static int ctrl_msg(int device , unsigned char requestType , unsigned char request ,
                             unsigned short value , unsigned short index___0 , unsigned char *data ,
                             size_t length ) 
{ 
  struct usbdevfs_ctrltransfer ctrl ;
  int tmp ;

  {
#line 147
  if (length > 65535UL) {
    {
#line 148
    logerror("length too big\n");
    }
#line 149
    return (-22);
  }
  {
#line 153
  ctrl.bRequestType = requestType;
#line 154
  ctrl.bRequest = request;
#line 155
  ctrl.wValue = value;
#line 156
  ctrl.wLength = (unsigned short )length;
#line 157
  ctrl.wIndex = index___0;
#line 160
  ctrl.data = (void *)data;
#line 162
  ctrl.timeout = (__u32 )10000;
#line 164
  tmp = ioctl(device, (unsigned long )((3U << 30) | (unsigned int )(85 << 8)) | (sizeof(struct usbdevfs_ctrltransfer ) << 16),
              & ctrl);
  }
#line 164
  return (tmp);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
static int ezusb_read(int device , char *label , unsigned char opcode , unsigned short addr ,
                      unsigned char *data , size_t len ) 
{ 
  int status ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 194
  if (verbose) {
    {
#line 195
    logerror("%s, addr 0x%04x len %4zd (0x%04zx)\n", label, (int )addr, len, len);
    }
  }
  {
#line 196
  status = ctrl_msg(device, (unsigned char )(128 | (2 << 5)), opcode, addr, (unsigned short)0,
                    data, len);
  }
#line 200
  if ((size_t )status != len) {
#line 201
    if (status < 0) {
      {
#line 202
      tmp = __errno_location();
#line 202
      tmp___0 = strerror(*tmp);
#line 202
      logerror("%s: %s\n", label, tmp___0);
      }
    } else {
      {
#line 204
      logerror("%s ==> %d\n", label, status);
      }
    }
  }
#line 206
  return (status);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
static int ezusb_write(int device , char *label , unsigned char opcode , unsigned short addr ,
                       unsigned char const   *data , size_t len ) 
{ 
  int status ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 222
  if (verbose) {
    {
#line 223
    logerror("%s, addr 0x%04x len %4zd (0x%04zx)\n", label, (int )addr, len, len);
    }
  }
  {
#line 224
  status = ctrl_msg(device, (unsigned char )(2 << 5), opcode, addr, (unsigned short)0,
                    (unsigned char *)data, len);
  }
#line 228
  if ((size_t )status != len) {
#line 229
    if (status < 0) {
      {
#line 230
      tmp = __errno_location();
#line 230
      tmp___0 = strerror(*tmp);
#line 230
      logerror("%s: %s\n", label, tmp___0);
      }
    } else {
      {
#line 232
      logerror("%s ==> %d\n", label, status);
      }
    }
  }
#line 234
  return (status);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
static int ezusb_cpucs(int device , unsigned short addr , int doRun ) 
{ 
  int status ;
  unsigned char data ;
  int tmp ;
  char const   *tmp___0 ;
  char *mesg ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 247
  if (doRun) {
#line 247
    tmp = 0;
  } else {
#line 247
    tmp = 1;
  }
#line 247
  data = (unsigned char )tmp;
#line 249
  if (verbose) {
#line 250
    if (data) {
#line 250
      tmp___0 = "stop CPU";
    } else {
#line 250
      tmp___0 = "reset CPU";
    }
    {
#line 250
    logerror("%s\n", tmp___0);
    }
  }
  {
#line 251
  status = ctrl_msg(device, (unsigned char )(2 << 5), (unsigned char)160, addr, (unsigned short)0,
                    & data, (size_t )1);
  }
#line 256
  if (status != 1) {
#line 257
    mesg = (char *)"can\'t modify CPUCS";
#line 258
    if (status < 0) {
      {
#line 259
      tmp___1 = __errno_location();
#line 259
      tmp___2 = strerror(*tmp___1);
#line 259
      logerror("%s: %s\n", mesg, tmp___2);
      }
    } else {
      {
#line 261
      logerror("%s\n", mesg);
      }
    }
#line 262
    return (0);
  } else {
#line 264
    return (1);
  }
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
__inline static int ezusb_get_eeprom_type(int fd , unsigned char *data ) 
{ 
  int tmp ;

  {
  {
#line 274
  tmp = ezusb_read(fd, (char *)"get EEPROM size", (unsigned char)165, (unsigned short)0,
                   data, (size_t )1);
  }
#line 274
  return (tmp);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
int parse_ihex(FILE *image , void *context , int (*is_external)(unsigned short addr ,
                                                                size_t len ) , int (*poke)(void *context ,
                                                                                           unsigned short addr ,
                                                                                           int external ,
                                                                                           unsigned char const   *data ,
                                                                                           size_t len ) ) 
{ 
  unsigned char data[1023] ;
  unsigned short data_addr ;
  size_t data_len ;
  int rc ;
  int first_line ;
  int external ;
  char buf[512] ;
  char *cp ;
  char tmp ;
  char type ;
  size_t len ;
  unsigned int idx ;
  unsigned int off ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 304
  data_addr = (unsigned short)0;
#line 305
  data_len = (size_t )0;
#line 307
  first_line = 1;
#line 308
  external = 0;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 326
    cp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)image);
    }
#line 327
    if ((unsigned long )cp == (unsigned long )((char *)0)) {
      {
#line 328
      logerror("EOF without EOF record!\n");
      }
#line 329
      goto while_break;
    }
#line 333
    if ((int )buf[0] == 35) {
#line 334
      goto __Cont;
    }
#line 336
    if ((int )buf[0] != 58) {
      {
#line 337
      logerror("not an ihex record: %s", buf);
      }
#line 338
      return (-2);
    }
    {
#line 342
    cp = strchr((char const   *)(buf), '\n');
    }
#line 343
    if (cp) {
#line 344
      *cp = (char)0;
    }
#line 346
    if (verbose >= 3) {
      {
#line 347
      logerror("** LINE: %s\n", buf);
      }
    }
    {
#line 350
    tmp = buf[3];
#line 351
    buf[3] = (char)0;
#line 352
    len = strtoul((char const   */* __restrict  */)(buf + 1), (char **/* __restrict  */)0,
                  16);
#line 353
    buf[3] = tmp;
#line 356
    tmp = buf[7];
#line 357
    buf[7] = (char)0;
#line 358
    tmp___0 = strtoul((char const   */* __restrict  */)(buf + 3), (char **/* __restrict  */)0,
                      16);
#line 358
    off = (unsigned int )tmp___0;
#line 359
    buf[7] = tmp;
    }
#line 362
    if (first_line) {
#line 363
      data_addr = (unsigned short )off;
#line 364
      first_line = 0;
    }
    {
#line 368
    tmp = buf[9];
#line 369
    buf[9] = (char)0;
#line 370
    tmp___1 = strtoul((char const   */* __restrict  */)(buf + 7), (char **/* __restrict  */)0,
                      16);
#line 370
    type = (char )tmp___1;
#line 371
    buf[9] = tmp;
    }
#line 374
    if ((int )type == 1) {
#line 375
      if (verbose >= 2) {
        {
#line 376
        logerror("EOF on hexfile\n");
        }
      }
#line 377
      goto while_break;
    }
#line 380
    if ((int )type != 0) {
      {
#line 381
      logerror("unsupported record type: %u\n", (int )type);
      }
#line 382
      return (-3);
    }
    {
#line 385
    tmp___2 = strlen((char const   *)(buf));
    }
#line 385
    if (len * 2UL + 11UL > tmp___2) {
      {
#line 386
      logerror("record too short?\n");
      }
#line 387
      return (-4);
    }
#line 397
    if (data_len != 0UL) {
#line 397
      if ((size_t )off != (size_t )data_addr + data_len) {
#line 397
        goto _L;
      } else
#line 397
      if (data_len + len > sizeof(data)) {
        _L: /* CIL Label */ 
#line 401
        if (is_external) {
          {
#line 402
          external = (*is_external)(data_addr, data_len);
          }
        }
        {
#line 403
        rc = (*poke)(context, data_addr, external, (unsigned char const   *)(data),
                     data_len);
        }
#line 404
        if (rc < 0) {
#line 405
          return (-1);
        }
#line 406
        data_addr = (unsigned short )off;
#line 407
        data_len = (size_t )0;
      }
    }
#line 411
    idx = 0U;
#line 411
    cp = buf + 9;
    {
#line 411
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 411
      if (! ((size_t )idx < len)) {
#line 411
        goto while_break___0;
      }
      {
#line 412
      tmp = *(cp + 2);
#line 413
      *(cp + 2) = (char)0;
#line 414
      tmp___3 = strtoul((char const   */* __restrict  */)cp, (char **/* __restrict  */)0,
                        16);
#line 414
      data[data_len + (size_t )idx] = (unsigned char )tmp___3;
#line 415
      *(cp + 2) = tmp;
#line 411
      idx ++;
#line 411
      cp += 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 417
    data_len += len;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  if (data_len != 0UL) {
#line 423
    if (is_external) {
      {
#line 424
      external = (*is_external)(data_addr, data_len);
      }
    }
    {
#line 425
    rc = (*poke)(context, data_addr, external, (unsigned char const   *)(data), data_len);
    }
#line 426
    if (rc < 0) {
#line 427
      return (-1);
    }
  }
#line 429
  return (0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
static int ram_poke(void *context , unsigned short addr , int external , unsigned char const   *data ,
                    size_t len ) 
{ 
  struct ram_poke_context *ctx ;
  int rc ;
  unsigned int retry ;
  int *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 461
  ctx = (struct ram_poke_context *)context;
#line 463
  retry = 0U;
  {
#line 466
  if ((unsigned int )ctx->mode == 1U) {
#line 466
    goto case_1;
  }
#line 473
  if ((unsigned int )ctx->mode == 2U) {
#line 473
    goto case_2;
  }
#line 482
  if ((unsigned int )ctx->mode == 3U) {
#line 482
    goto case_3;
  }
#line 491
  goto switch_default;
  case_1: /* CIL Label */ 
#line 467
  if (external) {
    {
#line 468
    logerror("can\'t write %zd bytes external memory at 0x%04x\n", len, (int )addr);
    }
#line 470
    return (-22);
  }
#line 472
  goto switch_break;
  case_2: /* CIL Label */ 
#line 474
  if (! external) {
#line 475
    if (verbose >= 2) {
      {
#line 476
      logerror("SKIP on-chip RAM, %zd bytes at 0x%04x\n", len, (int )addr);
      }
    }
#line 479
    return (0);
  }
#line 481
  goto switch_break;
  case_3: /* CIL Label */ 
#line 483
  if (external) {
#line 484
    if (verbose >= 2) {
      {
#line 485
      logerror("SKIP external RAM, %zd bytes at 0x%04x\n", len, (int )addr);
      }
    }
#line 488
    return (0);
  }
#line 490
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 492
  logerror("bug\n");
  }
#line 493
  return (-33);
  switch_break: /* CIL Label */ ;
  }
#line 496
  ctx->total = (unsigned int )((size_t )ctx->total + len);
#line 497
  (ctx->count) ++;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (external) {
#line 502
      tmp___0 = 163;
    } else {
#line 502
      tmp___0 = 160;
    }
#line 502
    if (external) {
#line 502
      tmp___1 = "write external";
    } else {
#line 502
      tmp___1 = "write on-chip";
    }
    {
#line 502
    rc = ezusb_write(ctx->device, (char *)tmp___1, (unsigned char )tmp___0, addr,
                     data, len);
    }
#line 502
    if (rc < 0) {
#line 502
      if (! (retry < 5U)) {
#line 502
        goto while_break;
      }
    } else {
#line 502
      goto while_break;
    }
    {
#line 507
    tmp = __errno_location();
    }
#line 507
    if (*tmp != 110) {
#line 508
      goto while_break;
    }
#line 509
    retry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  if (rc < 0) {
    {
#line 511
    tmp___2 = __errno_location();
#line 511
    tmp___3 = - *tmp___2;
    }
  } else {
#line 511
    tmp___3 = 0;
  }
#line 511
  return (tmp___3);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
int ezusb_load_ram(int fd , char const   *path , int fx2 , int stage ) 
{ 
  FILE *image ;
  unsigned short cpucs_addr ;
  int (*is_external)(unsigned short off , size_t len ) ;
  struct ram_poke_context ctx ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 536
  image = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 537
  if ((unsigned long )image == (unsigned long )((FILE *)0)) {
    {
#line 538
    logerror("%s: unable to open for input.\n", path);
    }
#line 539
    return (-2);
  } else
#line 540
  if (verbose) {
    {
#line 541
    logerror("open RAM hexfile image %s\n", path);
    }
  }
#line 544
  if (fx2 == 2) {
#line 545
    cpucs_addr = (unsigned short)58880;
#line 546
    is_external = & fx2lp_is_external;
  } else
#line 547
  if (fx2) {
#line 548
    cpucs_addr = (unsigned short)58880;
#line 549
    is_external = & fx2_is_external;
  } else {
#line 551
    cpucs_addr = (unsigned short)32658;
#line 552
    is_external = & fx_is_external;
  }
#line 556
  if (! stage) {
    {
#line 557
    ctx.mode = (ram_mode )1;
#line 560
    tmp = ezusb_cpucs(fd, cpucs_addr, 0);
    }
#line 560
    if (! tmp) {
#line 561
      return (-1);
    }
  } else {
#line 565
    ctx.mode = (ram_mode )2;
#line 568
    if (verbose) {
      {
#line 569
      logerror("2nd stage:  write external memory\n");
      }
    }
  }
  {
#line 573
  ctx.device = fd;
#line 574
  ctx.count = 0U;
#line 574
  ctx.total = ctx.count;
#line 575
  status = parse_ihex(image, (void *)(& ctx), is_external, & ram_poke);
  }
#line 576
  if (status < 0) {
    {
#line 577
    logerror("unable to download %s\n", path);
    }
#line 578
    return (status);
  }
#line 582
  if (stage) {
    {
#line 583
    ctx.mode = (ram_mode )3;
#line 586
    tmp___0 = ezusb_cpucs(fd, cpucs_addr, 0);
    }
#line 586
    if (! tmp___0) {
#line 587
      return (-1);
    }
    {
#line 590
    rewind(image);
    }
#line 591
    if (verbose) {
      {
#line 592
      logerror("2nd stage:  write on-chip memory\n");
      }
    }
    {
#line 593
    status = parse_ihex(image, (void *)(& ctx), is_external, & ram_poke);
    }
#line 594
    if (status < 0) {
      {
#line 595
      logerror("unable to completely download %s\n", path);
      }
#line 596
      return (status);
    }
  }
#line 600
  if (verbose) {
    {
#line 601
    logerror("... WROTE: %d bytes, %d segments, avg %d\n", ctx.total, ctx.count, ctx.total / ctx.count);
    }
  }
  {
#line 605
  tmp___1 = ezusb_cpucs(fd, cpucs_addr, 1);
  }
#line 605
  if (! tmp___1) {
#line 606
    return (-1);
  }
#line 608
  return (0);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
static int eeprom_poke(void *context , unsigned short addr , int external , unsigned char const   *data ,
                       size_t len ) 
{ 
  struct eeprom_poke_context *ctx ;
  int rc ;
  unsigned char header[4] ;

  {
#line 629
  ctx = (struct eeprom_poke_context *)context;
#line 633
  if (external) {
    {
#line 634
    logerror("EEPROM can\'t init %zd bytes external memory at 0x%04x\n", len, (int )addr);
    }
#line 637
    return (-22);
  }
#line 640
  if (len > 1023UL) {
    {
#line 641
    logerror("not fragmenting %zd bytes\n", len);
    }
#line 642
    return (-33);
  }
#line 650
  header[0] = (unsigned char )(len >> 8);
#line 651
  header[1] = (unsigned char )len;
#line 652
  header[2] = (unsigned char )((int )addr >> 8);
#line 653
  header[3] = (unsigned char )addr;
#line 654
  if (ctx->last) {
#line 655
    header[0] = (unsigned char )((int )header[0] | 128);
  }
  {
#line 656
  rc = ezusb_write(ctx->device, (char *)"write EEPROM segment header", (unsigned char)162,
                   ctx->ee_addr, (unsigned char const   *)(header), (size_t )4);
  }
#line 656
  if (rc < 0) {
#line 659
    return (rc);
  }
  {
#line 662
  rc = ezusb_write(ctx->device, (char *)"write EEPROM segment", (unsigned char)162,
                   (unsigned short )((int )ctx->ee_addr + 4), data, len);
  }
#line 662
  if (rc < 0) {
#line 665
    return (rc);
  }
#line 668
  ctx->ee_addr = (unsigned short )((size_t )ctx->ee_addr + (4UL + len));
#line 670
  return (0);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/fxload-0.0.20081013/ezusb.c"
int ezusb_load_eeprom(int dev , char const   *path , char const   *type , int config ) 
{ 
  FILE *image ;
  unsigned short cpucs_addr ;
  int (*is_external)(unsigned short off , size_t len ) ;
  struct eeprom_poke_context ctx ;
  int status ;
  unsigned char value ;
  unsigned char first_byte ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 690
  tmp = ezusb_get_eeprom_type(dev, & value);
  }
#line 690
  if (tmp != 1) {
    {
#line 691
    logerror("don\'t see a large enough EEPROM\n");
    }
#line 692
    return (-1);
  } else
#line 690
  if ((int )value != 1) {
    {
#line 691
    logerror("don\'t see a large enough EEPROM\n");
    }
#line 692
    return (-1);
  }
  {
#line 695
  image = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 696
  if ((unsigned long )image == (unsigned long )((FILE *)0)) {
    {
#line 697
    logerror("%s: unable to open for input.\n", path);
    }
#line 698
    return (-2);
  } else
#line 699
  if (verbose) {
    {
#line 700
    logerror("open EEPROM hexfile image %s\n", path);
    }
  }
#line 702
  if (verbose) {
    {
#line 703
    logerror("2nd stage:  write boot EEPROM\n");
    }
  }
  {
#line 706
  tmp___10 = strcmp("fx2", type);
  }
#line 706
  if (tmp___10 == 0) {
#line 707
    first_byte = (unsigned char)194;
#line 708
    cpucs_addr = (unsigned short)58880;
#line 709
    is_external = & fx2_is_external;
#line 710
    ctx.ee_addr = (unsigned short)8;
#line 711
    config &= 79;
#line 712
    if (config & 1) {
#line 712
      tmp___0 = 400;
    } else {
#line 712
      tmp___0 = 100;
    }
#line 712
    if (config & 64) {
#line 712
      tmp___1 = "dis";
    } else {
#line 712
      tmp___1 = "";
    }
    {
#line 712
    logerror("FX2:  config = 0x%02x, %sconnected, I2C = %d KHz\n", config, tmp___1,
             tmp___0);
    }
  } else {
    {
#line 722
    tmp___9 = strcmp("fx2lp", type);
    }
#line 722
    if (tmp___9 == 0) {
#line 723
      first_byte = (unsigned char)194;
#line 724
      cpucs_addr = (unsigned short)58880;
#line 725
      is_external = & fx2lp_is_external;
#line 726
      ctx.ee_addr = (unsigned short)8;
#line 727
      config &= 79;
#line 728
      if (config & 1) {
#line 728
        tmp___2 = 400;
      } else {
#line 728
        tmp___2 = 100;
      }
#line 728
      if (config & 64) {
#line 728
        tmp___3 = "dis";
      } else {
#line 728
        tmp___3 = "";
      }
      {
#line 728
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FX2LP:  config = 0x%02x, %sconnected, I2C = %d KHz\n",
              config, tmp___3, tmp___2);
      }
    } else {
      {
#line 734
      tmp___8 = strcmp("fx", type);
      }
#line 734
      if (tmp___8 == 0) {
#line 735
        first_byte = (unsigned char)182;
#line 736
        cpucs_addr = (unsigned short)32658;
#line 737
        is_external = & fx_is_external;
#line 738
        ctx.ee_addr = (unsigned short)9;
#line 739
        config &= 7;
#line 740
        if (config & 1) {
#line 740
          tmp___4 = 400;
        } else {
#line 740
          tmp___4 = 100;
        }
#line 740
        if (config & 2) {
#line 740
          tmp___5 = " inverted";
        } else {
#line 740
          tmp___5 = "";
        }
#line 740
        if (config & 4) {
#line 740
          tmp___6 = 48;
        } else {
#line 740
          tmp___6 = 24;
        }
        {
#line 740
        logerror("FX:  config = 0x%02x, %d MHz%s, I2C = %d KHz\n", config, tmp___6,
                 tmp___5, tmp___4);
        }
      } else {
        {
#line 748
        tmp___7 = strcmp("an21", type);
        }
#line 748
        if (tmp___7 == 0) {
          {
#line 749
          first_byte = (unsigned char)178;
#line 750
          cpucs_addr = (unsigned short)32658;
#line 751
          is_external = & fx_is_external;
#line 752
          ctx.ee_addr = (unsigned short)7;
#line 753
          config = 0;
#line 754
          logerror("AN21xx:  no EEPROM config byte\n");
          }
        } else {
          {
#line 757
          logerror("?? Unrecognized microcontroller type %s ??\n", type);
          }
#line 758
          return (-1);
        }
      }
    }
  }
  {
#line 764
  value = (unsigned char)0;
#line 765
  status = ezusb_write(dev, (char *)"mark EEPROM as unbootable", (unsigned char)162,
                       (unsigned short)0, (unsigned char const   *)(& value), sizeof(value));
  }
#line 767
  if (status < 0) {
#line 768
    return (status);
  }
  {
#line 771
  ctx.device = dev;
#line 772
  ctx.last = 0;
#line 773
  status = parse_ihex(image, (void *)(& ctx), is_external, & eeprom_poke);
  }
#line 774
  if (status < 0) {
    {
#line 775
    logerror("unable to write EEPROM %s\n", path);
    }
#line 776
    return (status);
  }
  {
#line 780
  value = (unsigned char)0;
#line 781
  ctx.last = 1;
#line 782
  status = eeprom_poke((void *)(& ctx), cpucs_addr, 0, (unsigned char const   *)(& value),
                       sizeof(value));
  }
#line 783
  if (status < 0) {
    {
#line 784
    logerror("unable to append reset to EEPROM %s\n", path);
    }
#line 785
    return (status);
  }
  {
#line 789
  tmp___11 = strcmp("an21", type);
  }
#line 789
  if (tmp___11 != 0) {
    {
#line 790
    value = (unsigned char )config;
#line 791
    status = ezusb_write(dev, (char *)"write config byte", (unsigned char)162, (unsigned short)7,
                         (unsigned char const   *)(& value), sizeof(value));
    }
#line 793
    if (status < 0) {
#line 794
      return (status);
    }
  }
  {
#line 798
  tmp___12 = strcmp("fx", type);
  }
#line 798
  if (tmp___12 == 0) {
    {
#line 799
    value = (unsigned char)0;
#line 800
    status = ezusb_write(dev, (char *)"write reserved byte", (unsigned char)162, (unsigned short)8,
                         (unsigned char const   *)(& value), sizeof(value));
    }
#line 802
    if (status < 0) {
#line 803
      return (status);
    }
  }
  {
#line 807
  status = ezusb_write(dev, (char *)"write EEPROM type byte", (unsigned char)162,
                       (unsigned short)0, (unsigned char const   *)(& first_byte),
                       sizeof(first_byte));
  }
#line 809
  if (status < 0) {
#line 810
    return (status);
  }
#line 816
  return (0);
}
}
