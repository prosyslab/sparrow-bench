/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.h"
struct harddrive_entry {
   char *regexp ;
   short attribute_id ;
   char *description ;
   unsigned char unit ;
   struct harddrive_entry *next ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
typedef __u16 u16;
#line 37
enum e_bustype {
    ERROR = 0,
    BUS_UNKNOWN = 1,
    BUS_SATA = 2,
    BUS_ATA = 3,
    BUS_SCSI = 4,
    BUS_TYPE_MAX = 5
} ;
#line 38
enum e_gettemp {
    GETTEMP_ERROR = 0,
    GETTEMP_NOT_APPLICABLE = 1,
    GETTEMP_UNKNOWN = 2,
    GETTEMP_KNOWN = 3,
    GETTEMP_NOSENSOR = 4,
    GETTEMP_DRIVE_SLEEP = 5
} ;
#line 54 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
struct disk {
   struct disk *next ;
   int fd ;
   char const   *drive ;
   char const   *model ;
   enum e_bustype type ;
   int value ;
   struct harddrive_entry *db_entry ;
   char errormsg[128] ;
   enum e_gettemp ret ;
   time_t last_time ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
struct bustype {
   char *name ;
   int (*probe)(int  ) ;
   char const   *(*model)(int  ) ;
   enum e_gettemp (*get_temperature)(struct disk * ) ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
enum __anonenum_unit_64 {
    DEFAULT = 0,
    CELSIUS = 1,
    FAHRENHEIT = 2
} ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
enum e_powermode {
    PWM_UNKNOWN = 0,
    PWM_ACTIVE = 1,
    PWM_SLEEPING = 2,
    PWM_STANDBY = 3
} ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_29 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_29 regmatch_t;
#line 25 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/atacmds.h"
enum e_powermode;
#line 44 "/usr/include/scsi/sg.h"
struct sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   unsigned char *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_14 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_14 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_34 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_36 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_37 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_38 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_39 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_32 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_33 _kill ;
   struct __anonstruct__timer_34 _timer ;
   struct __anonstruct__rt_35 _rt ;
   struct __anonstruct__sigchld_36 _sigchld ;
   struct __anonstruct__sigfault_37 _sigfault ;
   struct __anonstruct__sigpoll_38 _sigpoll ;
   struct __anonstruct__sigsys_39 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_31 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_32 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_31 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_51 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_51 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h"
typedef struct sigaltstack stack_t;
#line 31 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 92 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
#line 99 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 104 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t padding[24] ;
};
#line 121 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 124 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_mcontext_t_55 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 124 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_mcontext_t_55 mcontext_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext {
   unsigned long uc_flags ;
   struct ucontext *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   __sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_13 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_13 fd_set;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/utf8.h"
char *degree_sign(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/utf8.c"
static char *iconv_from_utf8_to_locale(char const   *string , char const   *fallback_string ) 
{ 
  size_t buffer_inc ;
  char const   *charset ;
  iconv_t cd ;
  size_t nconv ;
  char *dest_buffer ;
  char *old_dest_buffer ;
  char *dest_buffer_ptr ;
  char *src_buffer ;
  char *src_buffer_ptr ;
  size_t dest_buffer_size ;
  size_t dest_buffer_size_left ;
  size_t src_buffer_size ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 37
  buffer_inc = (size_t )80;
#line 53
  setlocale(6, "");
#line 54
  tmp = nl_langinfo(14);
#line 54
  charset = (char const   *)tmp;
#line 57
  cd = iconv_open(charset, "UTF-8");
  }
#line 58
  if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
    {
#line 59
    tmp___0 = strdup(fallback_string);
    }
#line 59
    return (tmp___0);
  }
  {
#line 62
  dest_buffer_size_left = buffer_inc;
#line 62
  dest_buffer_size = dest_buffer_size_left;
#line 63
  tmp___1 = malloc(dest_buffer_size);
#line 63
  dest_buffer = (char *)tmp___1;
#line 63
  dest_buffer_ptr = dest_buffer;
#line 64
  src_buffer = strdup(string);
#line 64
  src_buffer_ptr = src_buffer;
#line 65
  tmp___2 = strlen((char const   *)src_buffer);
#line 65
  src_buffer_size = tmp___2 + 1UL;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (src_buffer_size != 0UL)) {
#line 68
      goto while_break;
    }
    {
#line 70
    nconv = iconv(cd, (char **/* __restrict  */)(& src_buffer_ptr), (size_t */* __restrict  */)(& src_buffer_size),
                  (char **/* __restrict  */)(& dest_buffer_ptr), (size_t */* __restrict  */)(& dest_buffer_size_left));
    }
#line 71
    if (nconv == 0xffffffffffffffffUL) {
      {
#line 73
      tmp___3 = __errno_location();
      }
#line 73
      if (*tmp___3 != 7) {
#line 74
        goto iconv_error;
      }
      {
#line 77
      dest_buffer_size += buffer_inc;
#line 78
      dest_buffer_size_left = buffer_inc;
#line 79
      old_dest_buffer = dest_buffer;
#line 80
      tmp___4 = realloc((void *)dest_buffer, dest_buffer_size);
#line 80
      dest_buffer = (char *)tmp___4;
      }
#line 81
      if ((unsigned long )dest_buffer == (unsigned long )((void *)0)) {
#line 82
        goto iconv_error;
      }
#line 83
      dest_buffer_ptr = dest_buffer + (dest_buffer_ptr - old_dest_buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  iconv_close(cd);
#line 87
  free((void *)src_buffer);
#line 88
  tmp___5 = realloc((void *)dest_buffer, dest_buffer_size - dest_buffer_size_left);
#line 88
  dest_buffer = (char *)tmp___5;
  }
#line 89
  return (dest_buffer);
  iconv_error: 
  {
#line 92
  iconv_close(cd);
  }
#line 93
  if ((unsigned long )dest_buffer != (unsigned long )((void *)0)) {
    {
#line 94
    free((void *)dest_buffer);
    }
  }
  {
#line 95
  free((void *)src_buffer);
#line 96
  tmp___6 = strdup(fallback_string);
  }
#line 96
  return (tmp___6);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/utf8.c"
char *degree_sign(void) 
{ 
  unsigned char str[3] ;
  char *tmp ;

  {
  {
#line 101
  str[0] = (unsigned char)194;
#line 101
  str[1] = (unsigned char)176;
#line 101
  str[2] = (unsigned char)0;
#line 103
  tmp = iconv_from_utf8_to_locale((char const   *)(str), " \000");
  }
#line 103
  return (tmp);
}
}
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
int debug ;
#line 79
int wakeup ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/satacmds.h"
int sata_pass_thru(int device , unsigned char *cmd , unsigned char *buffer ) ;
#line 23
void sata_fixstring(unsigned char *s , int bytecount ) ;
#line 24
int sata_enable_smart(int device ) ;
#line 25
int sata_get_smart_values(int device , unsigned char *buff ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.h"
int scsi_inquiry(int device , unsigned char *buffer ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/sata.c"
static int sata_probe(int device ) 
{ 
  int bus_num ;
  unsigned char cmd[4] ;
  unsigned char identify[512] ;
  char buf[36] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 58
  cmd[0] = (unsigned char)236;
#line 58
  cmd[1] = (unsigned char)0;
#line 58
  cmd[2] = (unsigned char)0;
#line 58
  cmd[3] = (unsigned char)1;
#line 67
  tmp = ioctl(device, 21382UL, & bus_num);
  }
#line 67
  if (tmp) {
#line 68
    return (0);
  }
  {
#line 71
  tmp___1 = scsi_inquiry(device, (unsigned char *)(buf));
  }
#line 71
  if (tmp___1) {
#line 72
    return (0);
  } else {
    {
#line 73
    tmp___0 = strncmp((char const   *)(buf + 8), "ATA ", (size_t )4);
    }
#line 73
    if (tmp___0) {
#line 74
      return (0);
    }
  }
  {
#line 77
  tmp___2 = sata_pass_thru(device, cmd, identify);
  }
#line 77
  if (tmp___2 != 0) {
#line 78
    return (0);
  } else {
#line 80
    return (1);
  }
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/sata.c"
static char const   *sata_model(int device ) 
{ 
  unsigned char cmd[4] ;
  unsigned char identify[512] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 84
  cmd[0] = (unsigned char)236;
#line 84
  cmd[1] = (unsigned char)0;
#line 84
  cmd[2] = (unsigned char)0;
#line 84
  cmd[3] = (unsigned char)1;
#line 87
  if (device == -1) {
    {
#line 88
    tmp = gettext("unknown");
#line 88
    tmp___0 = strdup((char const   *)tmp);
    }
#line 88
    return ((char const   *)tmp___0);
  } else {
    {
#line 87
    tmp___2 = sata_pass_thru(device, cmd, identify);
    }
#line 87
    if (tmp___2) {
      {
#line 88
      tmp = gettext("unknown");
#line 88
      tmp___0 = strdup((char const   *)tmp);
      }
#line 88
      return ((char const   *)tmp___0);
    } else {
      {
#line 91
      sata_fixstring(identify + 54, 24);
#line 92
      tmp___1 = strdup((char const   *)(identify + 54));
      }
#line 92
      return ((char const   *)tmp___1);
    }
  }
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/sata.c"
static unsigned char *sata_search_temperature(unsigned char const   *smart_data ,
                                              int attribute_id ) 
{ 
  int i___0 ;
  int n ;
  char *tmp ;

  {
#line 99
  n = 3;
#line 100
  i___0 = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (debug) {
#line 101
      goto _L;
    } else
#line 101
    if ((int const   )*(smart_data + n) != (int const   )attribute_id) {
      _L: /* CIL Label */ 
#line 101
      if (! (i___0 < 30)) {
#line 101
        goto while_break;
      }
    } else {
#line 101
      goto while_break;
    }
#line 102
    if (debug) {
#line 102
      if (*(smart_data + n)) {
        {
#line 103
        tmp = gettext("field(%d)\t = %d\n");
#line 103
        printf((char const   */* __restrict  */)tmp, (int const   )*(smart_data + n),
               (int const   )*((smart_data + n) + 3));
        }
      }
    }
#line 105
    n += 12;
#line 106
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  if (i___0 >= 30) {
#line 110
    return ((unsigned char *)((void *)0));
  } else {
#line 112
    return ((unsigned char *)(smart_data + n));
  }
}
}
#line 127
enum e_powermode ata_get_powermode(int device ) ;
#line 115 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/sata.c"
static enum e_gettemp sata_get_temperature(struct disk *dsk ) 
{ 
  unsigned char values[512] ;
  unsigned char *field ;
  int i___0 ;
  u16 *p ;
  int tmp ;
  enum e_gettemp ret ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  u16 __x ;

  {
#line 121
  if ((int )(dsk->db_entry)->attribute_id == 0) {
    {
#line 122
    close(dsk->fd);
#line 123
    dsk->fd = -1;
    }
#line 124
    return ((enum e_gettemp )4);
  }
  {
#line 127
  tmp = (int )ata_get_powermode(dsk->fd);
  }
  {
#line 129
  if (tmp == 2) {
#line 129
    goto case_2;
  }
#line 129
  if (tmp == 3) {
#line 129
    goto case_2;
  }
#line 134
  goto switch_default;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 130
  if (! wakeup) {
#line 131
    return ((enum e_gettemp )5);
  }
  switch_default: /* CIL Label */ 
#line 135
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 139
  tmp___4 = sata_enable_smart(dsk->fd);
  }
#line 139
  if (tmp___4 != 0) {
    {
#line 141
    tmp___3 = __errno_location();
    }
#line 141
    if (*tmp___3 == 5) {
      {
#line 142
      tmp___0 = gettext("S.M.A.R.T. not available");
#line 142
      snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)tmp___0);
#line 143
      ret = (enum e_gettemp )1;
      }
    } else {
      {
#line 147
      tmp___1 = __errno_location();
#line 147
      tmp___2 = strerror(*tmp___1);
#line 147
      snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)"%s",
               tmp___2);
#line 148
      ret = (enum e_gettemp )0;
      }
    }
    {
#line 150
    close(dsk->fd);
#line 151
    dsk->fd = -1;
    }
#line 152
    return (ret);
  }
  {
#line 155
  tmp___7 = sata_get_smart_values(dsk->fd, values);
  }
#line 155
  if (tmp___7) {
    {
#line 156
    tmp___5 = __errno_location();
#line 156
    tmp___6 = strerror(*tmp___5);
#line 156
    snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)"%s",
             tmp___6);
#line 157
    close(dsk->fd);
#line 158
    dsk->fd = -1;
    }
#line 159
    return ((enum e_gettemp )0);
  }
#line 162
  p = (u16 *)(values);
#line 163
  i___0 = 0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i___0 < 256)) {
#line 163
      goto while_break;
    }
#line 164
    __x = *(p + i___0);
#line 164
    *(p + i___0) = (u16 )((((int )__x & 255) << 8) | (((int )__x & 65280) >> 8));
#line 163
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  field = sata_search_temperature((unsigned char const   *)(values), (int )(dsk->db_entry)->attribute_id);
  }
#line 170
  if (field) {
#line 171
    dsk->value = (int )*(field + 3);
  }
#line 173
  if (dsk->db_entry) {
#line 173
    if (dsk->value != -1) {
#line 174
      return ((enum e_gettemp )3);
    } else {
#line 176
      return ((enum e_gettemp )2);
    }
  } else {
#line 176
    return ((enum e_gettemp )2);
  }
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/sata.c"
struct bustype sata_bus  =    {(char *)"SATA", & sata_probe, & sata_model, & sata_get_temperature};
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.h"
struct harddrive_entry *is_a_supported_drive(char const   *model ) ;
#line 35
void display_supported_drives(void) ;
#line 36
void load_database(char const   *filename ) ;
#line 37
void free_database(void) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
struct bustype *bus[5]  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
int tcp_daemon  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
int debug  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
int quiet  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
int wakeup  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
int af_hint  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
int foreground  ;
#line 80
char separator ;
#line 81 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
long portnum  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
long syslog_interval  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.h"
char *listen_addr  ;
#line 84
int value_to_unit(struct disk *dsk ) ;
#line 85
char get_unit(struct disk *dsk ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/ata.h"
struct bustype ata_bus ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsi.h"
struct bustype scsi_bus ;
#line 19 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.h"
void backtrace_sigsegv(void) ;
#line 20
void backtrace_sigbus(void) ;
#line 21
void backtrace_sigill(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.h"
void do_daemon_mode(struct disk *ldisks ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
char *database_path  =    (char *)"/usr/share/misc/hddtemp.db";
#line 75 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
char separator  =    (char )'|';
#line 78 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
int numeric  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
static enum __anonenum_unit_64 unit  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
static void init_bus_types(void) 
{ 


  {
#line 86
  bus[2] = & sata_bus;
#line 87
  bus[3] = & ata_bus;
#line 88
  bus[4] = & scsi_bus;
#line 89
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
int value_to_unit(struct disk *dsk ) 
{ 


  {
  {
#line 96
  if ((unsigned int )unit == 1U) {
#line 96
    goto case_1;
  }
#line 100
  if ((unsigned int )unit == 2U) {
#line 100
    goto case_2;
  }
#line 103
  goto switch_default;
  case_1: /* CIL Label */ 
#line 97
  if ((int )(dsk->db_entry)->unit == 70) {
#line 98
    return ((int )(((double )dsk->value - 32.0) / 1.8));
  }
#line 99
  goto switch_break;
  case_2: /* CIL Label */ 
#line 101
  if ((int )(dsk->db_entry)->unit == 67) {
#line 102
    return ((int )((double )dsk->value * 1.8 + 32.0));
  }
  switch_default: /* CIL Label */ 
#line 104
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 107
  return (dsk->value);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
char get_unit(struct disk *dsk ) 
{ 


  {
  {
#line 112
  if ((unsigned int )unit == 1U) {
#line 112
    goto case_1;
  }
#line 114
  if ((unsigned int )unit == 2U) {
#line 114
    goto case_2;
  }
#line 116
  goto switch_default;
  case_1: /* CIL Label */ 
#line 113
  return ((char )'C');
  case_2: /* CIL Label */ 
#line 115
  return ((char )'F');
  switch_default: /* CIL Label */ 
#line 117
  return ((char )(dsk->db_entry)->unit);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
static enum e_bustype probe_bus_type(struct disk *dsk ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 126
  tmp___1 = (*((bus[2])->probe))(dsk->fd);
  }
#line 126
  if (tmp___1) {
#line 127
    return ((enum e_bustype )2);
  } else {
    {
#line 128
    tmp___0 = (*((bus[3])->probe))(dsk->fd);
    }
#line 128
    if (tmp___0) {
#line 129
      return ((enum e_bustype )3);
    } else {
      {
#line 130
      tmp = (*((bus[4])->probe))(dsk->fd);
      }
#line 130
      if (tmp) {
#line 131
        return ((enum e_bustype )4);
      } else {
#line 133
        return ((enum e_bustype )1);
      }
    }
  }
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
static void display_temperature(struct disk *dsk ) 
{ 
  enum e_gettemp ret ;
  char *degree ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 155
  if ((unsigned int )dsk->type != 0U) {
#line 155
    if (debug) {
      {
#line 156
      tmp = gettext("\n================= hddtemp %s ==================\nModel: %s\n\n");
#line 156
      printf((char const   */* __restrict  */)tmp, "0.3-beta15", dsk->model);
      }
    }
  }
#line 161
  if ((unsigned int )dsk->type == 0U) {
    {
#line 165
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            dsk->drive, dsk->errormsg);
    }
#line 166
    return;
  } else
#line 161
  if ((unsigned long )(bus[dsk->type])->get_temperature == (unsigned long )((void *)0)) {
    {
#line 165
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            dsk->drive, dsk->errormsg);
    }
#line 166
    return;
  } else {
    {
#line 161
    ret = (*((bus[dsk->type])->get_temperature))(dsk);
    }
#line 161
    if ((unsigned int )ret == 0U) {
      {
#line 165
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              dsk->drive, dsk->errormsg);
      }
#line 166
      return;
    }
  }
#line 169
  if (debug) {
#line 170
    return;
  }
  {
#line 172
  degree = degree_sign();
  }
  {
#line 174
  if ((unsigned int )ret == 0U) {
#line 174
    goto case_0;
  }
#line 177
  if ((unsigned int )ret == 1U) {
#line 177
    goto case_1;
  }
#line 185
  if ((unsigned int )ret == 2U) {
#line 185
    goto case_2;
  }
#line 200
  if ((unsigned int )ret == 3U) {
#line 200
    goto case_3;
  }
#line 214
  if ((unsigned int )ret == 5U) {
#line 214
    goto case_5;
  }
#line 222
  if ((unsigned int )ret == 4U) {
#line 222
    goto case_4;
  }
#line 229
  goto switch_default;
  case_0: /* CIL Label */ 
#line 176
  goto switch_break;
  case_1: /* CIL Label */ 
#line 179
  if (numeric) {
#line 179
    if (quiet) {
      {
#line 180
      printf((char const   */* __restrict  */)"0\n");
      }
    } else {
      {
#line 182
      printf((char const   */* __restrict  */)"%s: %s: %s\n", dsk->drive, dsk->model,
             dsk->errormsg);
      }
    }
  } else {
    {
#line 182
    printf((char const   */* __restrict  */)"%s: %s: %s\n", dsk->drive, dsk->model,
           dsk->errormsg);
    }
  }
#line 184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 187
  if (! quiet) {
    {
#line 188
    tmp___0 = gettext("WARNING: Drive %s doesn\'t seem to have a temperature sensor.\nWARNING: This doesn\'t mean it hasn\'t got one.\nWARNING: If you are sure it has one, please contact me (hddtemp@guzu.net).\nWARNING: See --help, --debug and --drivebase options.\n");
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            dsk->drive);
    }
  }
#line 194
  if (numeric) {
#line 194
    if (quiet) {
      {
#line 195
      printf((char const   */* __restrict  */)"0\n");
      }
    } else {
      {
#line 197
      tmp___1 = gettext("%s: %s:  no sensor\n");
#line 197
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              dsk->drive, dsk->model);
      }
    }
  } else {
    {
#line 197
    tmp___1 = gettext("%s: %s:  no sensor\n");
#line 197
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            dsk->drive, dsk->model);
    }
  }
#line 199
  goto switch_break;
  case_3: /* CIL Label */ 
#line 202
  if (! numeric) {
    {
#line 203
    tmp___2 = get_unit(dsk);
#line 203
    tmp___3 = value_to_unit(dsk);
#line 203
    printf((char const   */* __restrict  */)"%s: %s: %d%s%c\n", dsk->drive, dsk->model,
           tmp___3, degree, (int )tmp___2);
    }
  } else {
    {
#line 211
    tmp___4 = value_to_unit(dsk);
#line 211
    printf((char const   */* __restrict  */)"%d\n", tmp___4);
    }
  }
#line 213
  goto switch_break;
  case_5: /* CIL Label */ 
#line 216
  if (numeric) {
#line 216
    if (quiet) {
      {
#line 217
      printf((char const   */* __restrict  */)"0\n");
      }
    } else {
      {
#line 219
      tmp___5 = gettext("%s: %s: drive is sleeping\n");
#line 219
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              dsk->drive, dsk->model);
      }
    }
  } else {
    {
#line 219
    tmp___5 = gettext("%s: %s: drive is sleeping\n");
#line 219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            dsk->drive, dsk->model);
    }
  }
#line 221
  goto switch_break;
  case_4: /* CIL Label */ 
#line 223
  if (numeric) {
#line 223
    if (quiet) {
      {
#line 224
      printf((char const   */* __restrict  */)"0\n");
      }
    } else {
      {
#line 226
      tmp___6 = gettext("%s: %s:  drive supported, but it doesn\'t have a temperature sensor.\n");
#line 226
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              dsk->drive, dsk->model);
      }
    }
  } else {
    {
#line 226
    tmp___6 = gettext("%s: %s:  drive supported, but it doesn\'t have a temperature sensor.\n");
#line 226
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            dsk->drive, dsk->model);
    }
  }
#line 228
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 230
  tmp___7 = gettext("ERROR: %s: %s: unknown returned status\n");
#line 230
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
          dsk->drive, dsk->model);
  }
#line 231
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 233
  free((void *)degree);
  }
#line 234
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
void do_direct_mode(struct disk *ldisks ) 
{ 
  struct disk *dsk ;
  char *tmp ;

  {
#line 240
  dsk = ldisks;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! dsk) {
#line 240
      goto while_break;
    }
    {
#line 241
    display_temperature(dsk);
#line 240
    dsk = dsk->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  if (debug) {
    {
#line 245
    tmp = gettext("\nIf one of the field value seems to match the temperature, be sure to read\nthe hddtemp man page before sending a report (section REPORT). Thanks.\n");
#line 245
    printf((char const   */* __restrict  */)tmp);
    }
  }
#line 250
  return;
}
}
#line 275
int main(int argc , char **argv ) ;
#line 275 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
static struct option long_options[16]  = 
#line 275
  {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"daemon", 0, (int *)((void *)0), 'd'}, 
        {"drivebase", 0, (int *)((void *)0), 'b'}, 
        {"debug", 0, (int *)((void *)0), 'D'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"foreground", 0, (int *)((void *)0), 'F'}, 
        {"listen", 1, (int *)((void *)0), 'l'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"port", 1, (int *)((void *)0), 'p'}, 
        {"separator", 1, (int *)((void *)0), 's'}, 
        {"numeric", 0, (int *)((void *)0), 'n'}, 
        {"unit", 1, (int *)((void *)0), 'u'}, 
        {"syslog", 1, (int *)((void *)0), 'S'}, 
        {"wake-up", 0, (int *)((void *)0), 'w'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 253 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c"
int main(int argc , char **argv ) 
{ 
  int i___0 ;
  int c ;
  int lindex ;
  int db_loaded ;
  int ret ;
  int show_db ;
  struct disk *ldisks ;
  char *tmp ;
  char *end ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *end___0 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct disk *dsk ;
  void *tmp___8 ;
  char *p ;
  char *q ;
  int j ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  struct harddrive_entry *dbe ;
  void *tmp___16 ;

  {
  {
#line 254
  lindex = 0;
#line 254
  db_loaded = 0;
#line 255
  ret = 0;
#line 259
  backtrace_sigsegv();
#line 260
  backtrace_sigill();
#line 261
  backtrace_sigbus();
#line 263
  setlocale(6, "");
#line 264
  bindtextdomain("hddtemp", "/usr/local/share/locale");
#line 265
  textdomain("hddtemp");
#line 267
  foreground = 0;
#line 267
  syslog_interval = (long )foreground;
#line 267
  af_hint = (int )syslog_interval;
#line 267
  wakeup = af_hint;
#line 267
  quiet = wakeup;
#line 267
  numeric = quiet;
#line 267
  debug = numeric;
#line 267
  show_db = debug;
#line 268
  unit = (enum __anonenum_unit_64 )0;
#line 269
  portnum = 7634L;
#line 270
  listen_addr = (char *)((void *)0);
#line 273
  optind = 0;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 294
    c = getopt_long(argc, (char * const  *)argv, "bDdf:l:hp:qs:u:vnw46FS:", (struct option  const  *)(long_options),
                    & lindex);
    }
#line 295
    if (c == -1) {
#line 296
      goto while_break;
    }
    {
#line 299
    if (c == 113) {
#line 299
      goto case_113;
    }
#line 302
    if (c == 52) {
#line 302
      goto case_52;
    }
#line 305
    if (c == 54) {
#line 305
      goto case_54;
    }
#line 308
    if (c == 98) {
#line 308
      goto case_98;
    }
#line 311
    if (c == 100) {
#line 311
      goto case_100;
    }
#line 314
    if (c == 68) {
#line 314
      goto case_68;
    }
#line 317
    if (c == 102) {
#line 317
      goto case_102;
    }
#line 320
    if (c == 115) {
#line 320
      goto case_115;
    }
#line 327
    if (c == 112) {
#line 327
      goto case_112;
    }
#line 339
    if (c == 117) {
#line 339
      goto case_117;
    }
#line 351
    if (c == 108) {
#line 351
      goto case_108;
    }
#line 355
    if (c == 104) {
#line 355
      goto case_104;
    }
#line 355
    if (c == 63) {
#line 355
      goto case_104;
    }
#line 386
    if (c == 118) {
#line 386
      goto case_118;
    }
#line 390
    if (c == 110) {
#line 390
      goto case_110;
    }
#line 393
    if (c == 119) {
#line 393
      goto case_119;
    }
#line 396
    if (c == 83) {
#line 396
      goto case_83;
    }
#line 408
    if (c == 70) {
#line 408
      goto case_70___0;
    }
#line 411
    goto switch_default;
    case_113: /* CIL Label */ 
#line 300
    quiet = 1;
#line 301
    goto switch_break;
    case_52: /* CIL Label */ 
#line 303
    af_hint = 2;
#line 304
    goto switch_break;
    case_54: /* CIL Label */ 
#line 306
    af_hint = 10;
#line 307
    goto switch_break;
    case_98: /* CIL Label */ 
#line 309
    show_db = 1;
#line 310
    goto switch_break;
    case_100: /* CIL Label */ 
#line 312
    tcp_daemon = 1;
#line 313
    goto switch_break;
    case_68: /* CIL Label */ 
#line 315
    debug = 1;
#line 316
    goto switch_break;
    case_102: /* CIL Label */ 
#line 318
    database_path = optarg;
#line 319
    goto switch_break;
    case_115: /* CIL Label */ 
#line 321
    separator = *(optarg + 0);
#line 322
    if ((int )separator == 0) {
      {
#line 323
      tmp = gettext("ERROR: invalid separator.\n");
#line 323
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 324
      exit(1);
      }
    }
#line 326
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 329
    end = (char *)((void *)0);
#line 331
    portnum = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& end),
                     10);
#line 333
    tmp___1 = __errno_location();
    }
#line 333
    if (*tmp___1 == 34) {
      {
#line 334
      tmp___0 = gettext("ERROR: invalid port number.\n");
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 335
      exit(1);
      }
    } else
#line 333
    if ((unsigned long )end == (unsigned long )optarg) {
      {
#line 334
      tmp___0 = gettext("ERROR: invalid port number.\n");
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 335
      exit(1);
      }
    } else
#line 333
    if ((int )*end != 0) {
      {
#line 334
      tmp___0 = gettext("ERROR: invalid port number.\n");
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 335
      exit(1);
      }
    } else
#line 333
    if (portnum < 1L) {
      {
#line 334
      tmp___0 = gettext("ERROR: invalid port number.\n");
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 335
      exit(1);
      }
    }
#line 338
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 342
    if ((int )*optarg == 67) {
#line 342
      goto case_67;
    }
#line 342
    if ((int )*optarg == 99) {
#line 342
      goto case_67;
    }
#line 346
    if ((int )*optarg == 70) {
#line 346
      goto case_70;
    }
#line 346
    if ((int )*optarg == 102) {
#line 346
      goto case_70;
    }
#line 340
    goto switch_break___0;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
#line 343
    unit = (enum __anonenum_unit_64 )1;
#line 344
    goto switch_break___0;
    case_70: /* CIL Label */ 
    case_102___0: /* CIL Label */ 
#line 347
    unit = (enum __anonenum_unit_64 )2;
#line 348
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 350
    goto switch_break;
    case_108: /* CIL Label */ 
#line 352
    listen_addr = optarg;
#line 353
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 356
    tmp___2 = gettext(" Usage: hddtemp [OPTIONS] [TYPE:]DISK1 [[TYPE:]DISK2]...\n\n   hddtemp displays the temperature of drives supplied in argument.\n   Drives must support S.M.A.R.T.\n\n  TYPE could be SATA, PATA or SCSI. If omitted hddtemp will try to guess.\n\n  -b   --drivebase   :  display database file content that allow hddtemp to\n                        recognize supported drives.\n  -D   --debug       :  display various S.M.A.R.T. fields and their values.\n                        Useful to find a value that seems to match the\n                        temperature and/or to send me a report.\n                        (done for every drive supplied).\n  -d   --daemon      :  run hddtemp in TCP/IP daemon mode (port %d by default.)\n  -f   --file=FILE   :  specify database file to use.\n  -F   --foreground  :  don\'t daemonize, stay in foreground.\n  -l   --listen=addr :  listen on a specific interface (in TCP/IP daemon mode).\n  -n   --numeric     :  print only the temperature.\n  -p   --port=#      :  port to listen to (in TCP/IP daemon mode).\n  -s   --separator=C :  separator to use between fields (in TCP/IP daemon mode).\n  -S   --syslog=s    :  log temperature to syslog every s seconds.\n  -u   --unit=[C|F]  :  force output temperature either in Celsius or Fahrenheit.\n  -q   --quiet       :  do not check if the drive is supported.\n  -v   --version     :  display hddtemp version number.\n  -w   --wake-up     :  wake-up the drive if need.\n  -4                 :  listen on IPv4 sockets only.\n  -6                 :  listen on IPv6 sockets only.\n\nReport bugs or new drives to <hddtemp@guzu.net>.\n");
#line 356
    printf((char const   */* __restrict  */)tmp___2, 7634);
    }
    case_118: /* CIL Label */ 
    {
#line 387
    tmp___3 = gettext("hddtemp version %s\n");
#line 387
    printf((char const   */* __restrict  */)tmp___3, "0.3-beta15");
#line 388
    exit(0);
    }
#line 389
    goto switch_break;
    case_110: /* CIL Label */ 
#line 391
    numeric = 1;
#line 392
    goto switch_break;
    case_119: /* CIL Label */ 
#line 394
    wakeup = 1;
#line 395
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 398
    end___0 = (char *)((void *)0);
#line 400
    syslog_interval = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& end___0),
                             10);
#line 402
    tmp___5 = __errno_location();
    }
#line 402
    if (*tmp___5 == 34) {
      {
#line 403
      tmp___4 = gettext("ERROR: invalid interval.\n");
#line 403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
#line 404
      exit(1);
      }
    } else
#line 402
    if ((unsigned long )end___0 == (unsigned long )optarg) {
      {
#line 403
      tmp___4 = gettext("ERROR: invalid interval.\n");
#line 403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
#line 404
      exit(1);
      }
    } else
#line 402
    if ((int )*end___0 != 0) {
      {
#line 403
      tmp___4 = gettext("ERROR: invalid interval.\n");
#line 403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
#line 404
      exit(1);
      }
    } else
#line 402
    if (syslog_interval < 1L) {
      {
#line 403
      tmp___4 = gettext("ERROR: invalid interval.\n");
#line 403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
#line 404
      exit(1);
      }
    }
#line 407
    goto switch_break;
    case_70___0: /* CIL Label */ 
#line 409
    foreground = 1;
#line 410
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 412
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  if (show_db) {
    {
#line 417
    load_database((char const   *)database_path);
#line 418
    display_supported_drives();
#line 419
    exit(0);
    }
  }
#line 422
  if (argc - optind <= 0) {
    {
#line 423
    tmp___6 = gettext("Too few arguments: you must specify one drive, at least.\n");
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6);
#line 424
    exit(1);
    }
  }
#line 427
  if (debug) {
#line 429
    quiet = 1;
  }
#line 432
  if (debug) {
#line 432
    if (tcp_daemon) {
      {
#line 433
      tmp___7 = gettext("ERROR: can\'t use --debug and --daemon or --syslog options together.\n");
#line 433
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7);
#line 434
      exit(1);
      }
    } else
#line 432
    if (syslog_interval != 0L) {
      {
#line 433
      tmp___7 = gettext("ERROR: can\'t use --debug and --daemon or --syslog options together.\n");
#line 433
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7);
#line 434
      exit(1);
      }
    }
  }
  {
#line 437
  init_bus_types();
#line 440
  ldisks = (struct disk *)((void *)0);
#line 441
  i___0 = argc - 1;
  }
  {
#line 441
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 441
    if (! (i___0 >= optind)) {
#line 441
      goto while_break___0;
    }
    {
#line 442
    tmp___8 = malloc(sizeof(struct disk ));
#line 442
    dsk = (struct disk *)tmp___8;
    }
#line 445
    if (! dsk) {
      {
#line 445
      __assert_fail("dsk", "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/hddtemp.c",
                    445U, "main");
      }
    }
    {
#line 447
    memset((void *)dsk, 0, sizeof(*dsk));
#line 449
    p = strchr((char const   *)*(argv + i___0), ':');
    }
#line 450
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 451
      dsk->drive = (char const   *)*(argv + i___0);
    } else {
#line 457
      q = *(argv + i___0);
      {
#line 457
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 457
        if (! ((unsigned long )q != (unsigned long )p)) {
#line 457
          goto while_break___1;
        }
        {
#line 458
        tmp___9 = toupper((int )*q);
#line 458
        *q = (char )tmp___9;
#line 457
        q ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 461
      j = 0;
      {
#line 461
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 461
        if (! (j < 5)) {
#line 461
          goto while_break___2;
        }
#line 462
        if (bus[j]) {
#line 462
          if ((bus[j])->name) {
            {
#line 462
            tmp___10 = strncmp((char const   *)(bus[j])->name, (char const   *)*(argv + i___0),
                               (size_t )((p - *(argv + i___0)) - 1L));
            }
#line 462
            if (tmp___10 == 0) {
#line 466
              dsk->type = (enum e_bustype )j;
#line 467
              goto while_break___2;
            }
          }
        }
#line 461
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 471
      dsk->drive = (char const   *)(p + 1);
    }
    {
#line 474
    dsk->next = ldisks;
#line 475
    ldisks = dsk;
#line 477
    tmp___11 = __errno_location();
#line 477
    *tmp___11 = 0;
#line 478
    dsk->errormsg[0] = (char )'\000';
#line 479
    tmp___14 = open(dsk->drive, 2048);
#line 479
    dsk->fd = tmp___14;
    }
#line 479
    if (tmp___14 < 0) {
      {
#line 480
      tmp___12 = __errno_location();
#line 480
      tmp___13 = strerror(*tmp___12);
#line 480
      snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)"open: %s\n",
               tmp___13);
#line 481
      dsk->type = (enum e_bustype )0;
#line 482
      ret = 1;
      }
#line 483
      goto __Cont;
    }
#line 486
    if (! dsk->type) {
      {
#line 487
      dsk->type = probe_bus_type(dsk);
      }
    }
#line 490
    if ((unsigned int )dsk->type == 1U) {
      {
#line 491
      tmp___15 = gettext("ERROR: %s: can\'t determine bus type (or this bus type is unknown)\n");
#line 491
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              dsk->drive);
#line 493
      ldisks = dsk->next;
#line 494
      free((void *)dsk);
#line 495
      ret = 1;
      }
#line 496
      goto __Cont;
    }
    {
#line 499
    dsk->model = (*((bus[dsk->type])->model))(dsk->fd);
#line 500
    dsk->value = -1;
    }
#line 501
    if ((unsigned int )dsk->type != 4U) {
#line 504
      if (! db_loaded) {
        {
#line 505
        load_database((char const   *)database_path);
#line 506
        db_loaded = 1;
        }
      }
      {
#line 509
      tmp___16 = malloc(sizeof(struct harddrive_entry ));
#line 509
      dsk->db_entry = (struct harddrive_entry *)tmp___16;
#line 510
      dbe = is_a_supported_drive(dsk->model);
      }
#line 511
      if (dbe) {
        {
#line 512
        memcpy((void */* __restrict  */)dsk->db_entry, (void const   */* __restrict  */)dbe,
               sizeof(struct harddrive_entry ));
        }
      } else {
#line 514
        (dsk->db_entry)->regexp = (char *)"";
#line 515
        (dsk->db_entry)->description = (char *)"";
#line 516
        (dsk->db_entry)->attribute_id = (short)194;
#line 517
        (dsk->db_entry)->unit = (unsigned char )'C';
#line 518
        (dsk->db_entry)->next = (struct harddrive_entry *)((void *)0);
      }
    }
    __Cont: /* CIL Label */ 
#line 441
    i___0 --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 523
  free_database();
  }
#line 524
  if (tcp_daemon) {
    {
#line 525
    do_daemon_mode(ldisks);
    }
  } else
#line 524
  if (syslog_interval != 0L) {
    {
#line 525
    do_daemon_mode(ldisks);
    }
  } else {
    {
#line 528
    do_direct_mode(ldisks);
    }
  }
#line 531
  return (ret);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/atacmds.h"
int ata_enable_smart(int device ) ;
#line 23
int ata_get_smart_values(int device , unsigned char *buff ) ;
#line 24
unsigned char *ata_search_temperature(unsigned char const   *smart_data , int attribute_id ) ;
#line 26
int ata_get_packet(int device ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/ata.c"
static char sbuff[512]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/ata.c"
static int ata_probe(int device ) 
{ 
  int tmp ;

  {
#line 58
  if (device == -1) {
#line 59
    return (0);
  } else {
    {
#line 58
    tmp = ioctl(device, 781UL, sbuff);
    }
#line 58
    if (tmp) {
#line 59
      return (0);
    } else {
#line 61
      return (1);
    }
  }
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/ata.c"
static char const   *ata_model(int device ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 65
  if (device == -1) {
    {
#line 66
    tmp = gettext("unknown");
#line 66
    tmp___0 = strdup((char const   *)tmp);
    }
#line 66
    return ((char const   *)tmp___0);
  } else {
    {
#line 65
    tmp___2 = ioctl(device, 781UL, sbuff);
    }
#line 65
    if (tmp___2) {
      {
#line 66
      tmp = gettext("unknown");
#line 66
      tmp___0 = strdup((char const   *)tmp);
      }
#line 66
      return ((char const   *)tmp___0);
    } else {
      {
#line 68
      tmp___1 = strdup((char const   *)((char *)((u16 *)(sbuff) + 27)));
      }
#line 68
      return ((char const   *)tmp___1);
    }
  }
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/ata.c"
static enum e_gettemp ata_get_temperature(struct disk *dsk ) 
{ 
  unsigned char values[512] ;
  unsigned char *field ;
  int i___0 ;
  u16 *p ;
  char *tmp ;
  int tmp___0 ;
  enum e_powermode tmp___1 ;
  enum e_gettemp ret ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  u16 __x ;

  {
#line 78
  if ((int )(dsk->db_entry)->attribute_id == 0) {
    {
#line 79
    close(dsk->fd);
#line 80
    dsk->fd = -1;
    }
#line 81
    return ((enum e_gettemp )4);
  }
  {
#line 84
  tmp___0 = ata_get_packet(dsk->fd);
  }
#line 84
  if (tmp___0) {
    {
#line 85
    tmp = gettext("S.M.A.R.T. not available");
#line 85
    snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)tmp);
    }
#line 86
    return ((enum e_gettemp )1);
  }
  {
#line 89
  tmp___1 = ata_get_powermode(dsk->fd);
  }
  {
#line 91
  if ((unsigned int )tmp___1 == 2U) {
#line 91
    goto case_2;
  }
#line 91
  if ((unsigned int )tmp___1 == 3U) {
#line 91
    goto case_2;
  }
#line 96
  goto switch_default;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 92
  if (! wakeup) {
#line 93
    return ((enum e_gettemp )5);
  }
  switch_default: /* CIL Label */ 
#line 97
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___6 = ata_enable_smart(dsk->fd);
  }
#line 101
  if (tmp___6 != 0) {
    {
#line 103
    tmp___5 = __errno_location();
    }
#line 103
    if (*tmp___5 == 5) {
      {
#line 104
      tmp___2 = gettext("S.M.A.R.T. not available");
#line 104
      snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)tmp___2);
#line 105
      ret = (enum e_gettemp )1;
      }
    } else {
      {
#line 109
      tmp___3 = __errno_location();
#line 109
      tmp___4 = strerror(*tmp___3);
#line 109
      snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)"%s",
               tmp___4);
#line 110
      ret = (enum e_gettemp )0;
      }
    }
    {
#line 112
    close(dsk->fd);
#line 113
    dsk->fd = -1;
    }
#line 114
    return (ret);
  }
  {
#line 117
  tmp___9 = ata_get_smart_values(dsk->fd, values);
  }
#line 117
  if (tmp___9) {
    {
#line 118
    tmp___7 = __errno_location();
#line 118
    tmp___8 = strerror(*tmp___7);
#line 118
    snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)"%s",
             tmp___8);
#line 119
    close(dsk->fd);
#line 120
    dsk->fd = -1;
    }
#line 121
    return ((enum e_gettemp )0);
  }
#line 124
  p = (u16 *)(values);
#line 125
  i___0 = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i___0 < 256)) {
#line 125
      goto while_break;
    }
#line 126
    __x = *(p + i___0);
#line 126
    *(p + i___0) = (u16 )((((int )__x & 255) << 8) | (((int )__x & 65280) >> 8));
#line 125
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  field = ata_search_temperature((unsigned char const   *)(values), (int )(dsk->db_entry)->attribute_id);
  }
#line 145
  if (field) {
#line 146
    dsk->value = (int )*(field + 3);
  }
#line 148
  if (dsk->value != -1) {
#line 149
    return ((enum e_gettemp )3);
  } else {
#line 151
    return ((enum e_gettemp )2);
  }
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/ata.c"
struct bustype ata_bus  =    {(char *)"PATA", & ata_probe, & ata_model, & ata_get_temperature};
#line 28 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.h"
int scsi_SG_IO(int device , unsigned char *cdb , int cdb_len , unsigned char *buffer ,
               int buffer_len , unsigned char *sense , unsigned char sense_len , int dxfer_direction ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/satacmds.c"
int sata_pass_thru(int device , unsigned char *cmd , unsigned char *buffer ) 
{ 
  unsigned char cdb[16] ;
  unsigned char sense[32] ;
  int dxfer_direction ;
  int ret ;

  {
  {
#line 59
  memset((void *)(cdb), 0, sizeof(cdb));
#line 60
  cdb[0] = (unsigned char)133;
  }
#line 61
  if (*(cmd + 3)) {
#line 62
    cdb[1] = (unsigned char )(4 << 1);
#line 63
    cdb[2] = (unsigned char)46;
#line 64
    dxfer_direction = -3;
  } else {
#line 66
    cdb[1] = (unsigned char )(3 << 1);
#line 67
    cdb[2] = (unsigned char)32;
#line 68
    dxfer_direction = -1;
  }
#line 70
  cdb[4] = *(cmd + 2);
#line 71
  if ((int )*(cmd + 0) == 176) {
#line 72
    cdb[6] = *(cmd + 3);
#line 73
    cdb[8] = *(cmd + 1);
#line 74
    cdb[10] = (unsigned char)79;
#line 75
    cdb[12] = (unsigned char)194;
  } else {
#line 78
    cdb[6] = *(cmd + 1);
  }
  {
#line 79
  cdb[14] = *(cmd + 0);
#line 81
  ret = scsi_SG_IO(device, cdb, (int )sizeof(cdb), buffer, (int )*(cmd + 3) * 512,
                   sense, (unsigned char )sizeof(sense), dxfer_direction);
  }
#line 84
  if ((int )sense[0] != 114) {
#line 85
    return (1);
  } else {
#line 87
    return (ret);
  }
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/satacmds.c"
void sata_fixstring(unsigned char *s , int bytecount ) 
{ 
  unsigned char *p ;
  unsigned char *end ;
  unsigned short *pp ;
  unsigned short __v ;
  unsigned short __x ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 95
  p = s;
#line 96
  end = s + (bytecount & -2);
#line 99
  p = end;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! ((unsigned long )p != (unsigned long )s)) {
#line 99
      goto while_break;
    }
#line 100
    p -= 2;
#line 100
    pp = (unsigned short *)p;
#line 101
    __x = *pp;
#line 101
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 101
    *pp = __v;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if ((unsigned long )s != (unsigned long )end) {
#line 105
      if (! ((int )*s == 32)) {
#line 105
        goto while_break___0;
      }
    } else {
#line 105
      goto while_break___0;
    }
#line 106
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 108
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 108
    if ((unsigned long )s != (unsigned long )end) {
#line 108
      if (! *s) {
#line 108
        goto while_break___1;
      }
    } else {
#line 108
      goto while_break___1;
    }
#line 109
    tmp___0 = s;
#line 109
    s ++;
#line 109
    if ((int )*tmp___0 != 32) {
#line 110
      tmp = p;
#line 110
      p ++;
#line 110
      *tmp = *(s - 1);
    } else
#line 109
    if ((unsigned long )s != (unsigned long )end) {
#line 109
      if (*s) {
#line 109
        if ((int )*s != 32) {
#line 110
          tmp = p;
#line 110
          p ++;
#line 110
          *tmp = *(s - 1);
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 113
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )p != (unsigned long )end)) {
#line 113
      goto while_break___2;
    }
#line 114
    tmp___1 = p;
#line 114
    p ++;
#line 114
    *tmp___1 = (unsigned char )'\000';
  }
  while_break___2: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/satacmds.c"
int sata_enable_smart(int device ) 
{ 
  unsigned char cmd[4] ;
  int tmp ;

  {
  {
#line 118
  cmd[0] = (unsigned char)176;
#line 118
  cmd[1] = (unsigned char)0;
#line 118
  cmd[2] = (unsigned char)216;
#line 118
  cmd[3] = (unsigned char)0;
#line 120
  tmp = sata_pass_thru(device, cmd, (unsigned char *)((void *)0));
  }
#line 120
  return (tmp);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/satacmds.c"
int sata_get_smart_values(int device , unsigned char *buff ) 
{ 
  unsigned char cmd[4] ;
  int tmp ;

  {
  {
#line 124
  cmd[0] = (unsigned char)176;
#line 124
  cmd[1] = (unsigned char)0;
#line 124
  cmd[2] = (unsigned char)208;
#line 124
  cmd[3] = (unsigned char)1;
#line 126
  tmp = sata_pass_thru(device, cmd, buff);
  }
#line 126
  return (tmp);
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.c"
static struct harddrive_entry *supported_drives  =    (struct harddrive_entry *)((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.c"
struct harddrive_entry **last_entry  =    & supported_drives;
#line 49 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.c"
struct harddrive_entry *is_a_supported_drive(char const   *model ) 
{ 
  struct harddrive_entry *p ;
  regex_t preg ;
  regmatch_t pmatch ;
  int tmp ;
  int tmp___0 ;

  {
#line 52
  if ((unsigned long )model == (unsigned long )((void *)0)) {
#line 53
    return ((struct harddrive_entry *)((void *)0));
  }
#line 55
  p = supported_drives;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! p) {
#line 55
      goto while_break;
    }
    {
#line 59
    tmp = regcomp((regex_t */* __restrict  */)(& preg), (char const   */* __restrict  */)p->regexp,
                  1);
    }
#line 59
    if (tmp) {
      {
#line 60
      exit(-2);
      }
    }
    {
#line 62
    tmp___0 = regexec((regex_t const   */* __restrict  */)(& preg), (char const   */* __restrict  */)model,
                      (size_t )1, (regmatch_t */* __restrict  */)(& pmatch), 0);
    }
#line 62
    if (tmp___0 == 0) {
#line 63
      return (p);
    }
#line 55
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return ((struct harddrive_entry *)((void *)0));
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.c"
static char const   *extract_string(char **string ) 
{ 
  char *str ;

  {
#line 73
  if ((int )*(*string) != 34) {
#line 74
    return ((char const   *)((void *)0));
  } else {
#line 76
    (*string) ++;
  }
#line 78
  str = *string;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! *str) {
#line 80
      goto while_break;
    }
    {
#line 82
    if ((int )*str == 34) {
#line 82
      goto case_34;
    }
#line 85
    if ((int )*str == 92) {
#line 85
      goto case_92;
    }
#line 81
    goto switch_break;
    case_34: /* CIL Label */ 
#line 83
    return ((char const   *)str);
#line 84
    goto switch_break;
    case_92: /* CIL Label */ 
#line 86
    str ++;
#line 87
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 80
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return ((char const   *)((void *)0));
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.c"
void display_supported_drives(void) 
{ 
  unsigned char *tabs ;
  unsigned char *line ;
  struct harddrive_entry *p ;
  int max ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 99
  max = 0;
#line 100
  p = supported_drives;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! p) {
#line 100
      goto while_break;
    }
    {
#line 101
    tmp = strlen((char const   *)p->regexp);
#line 101
    len = (int )tmp;
    }
#line 102
    if (len > max) {
#line 103
      max = len;
    }
#line 100
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  len = max / 8 + 1;
#line 106
  tmp___0 = malloc((size_t )(len + 1));
#line 106
  tabs = (unsigned char *)tmp___0;
#line 107
  memset((void *)tabs, '\t', (size_t )len);
#line 108
  *(tabs + len) = (unsigned char )'\000';
#line 110
  len = (max / 8 + 1) * 8;
#line 111
  tmp___1 = malloc((size_t )(len + 1));
#line 111
  line = (unsigned char *)tmp___1;
#line 112
  memset((void *)line, '-', (size_t )len);
#line 113
  *(line + len) = (unsigned char )'\000';
#line 115
  tmp___2 = gettext("\nRegexp%s| Value | Description\n------%s---------------------\n");
#line 115
  printf((char const   */* __restrict  */)tmp___2, tabs, line);
#line 119
  p = supported_drives;
  }
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    if (! p) {
#line 119
      goto while_break___0;
    }
    {
#line 120
    tmp___3 = strlen((char const   *)p->regexp);
#line 120
    len = (int )tmp___3;
#line 121
    tmp___4 = gettext("%s%s| %5d | %s\n");
#line 121
    printf((char const   */* __restrict  */)tmp___4, p->regexp, tabs + len / 8, (int )p->attribute_id,
           p->description);
#line 119
    p = p->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 127
  printf((char const   */* __restrict  */)"\n");
  }
#line 128
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.c"
static int parse_db_line(char *line ) 
{ 
  char const   *regexp ;
  char const   *description ;
  struct harddrive_entry *new_entry ;
  unsigned short value ;
  char unit___0 ;
  char *p ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 139
  tmp = strspn((char const   *)line, " \t");
#line 139
  line += tmp;
  }
#line 140
  if ((int )*line == 35) {
#line 141
    return (0);
  } else
#line 140
  if ((int )*line == 0) {
#line 141
    return (0);
  }
  {
#line 144
  tmp___0 = extract_string(& line);
#line 144
  p = (char *)tmp___0;
  }
#line 145
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 146
    return (1);
  } else
#line 145
  if ((int )*p == 0) {
#line 146
    return (1);
  }
  {
#line 148
  *p = (char )'\000';
#line 149
  regexp = (char const   *)line;
#line 150
  line = p + 1;
#line 153
  tmp___1 = strspn((char const   *)line, " \t");
#line 153
  line += tmp___1;
  }
#line 154
  if (! *line) {
#line 155
    return (1);
  }
#line 157
  p = line;
#line 158
  value = (unsigned short)0;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if ((int )*p >= 48) {
#line 159
      if (! ((int )*p <= 57)) {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
#line 160
    value = (unsigned short )((10 * (int )value + (int )*p) - 48);
#line 161
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  if ((int )*p == 0) {
#line 164
    return (1);
  } else
#line 163
  if ((int )*p != 32) {
#line 163
    if ((int )*p != 9) {
#line 164
      return (1);
    }
  }
  {
#line 165
  line = p;
#line 168
  tmp___2 = strspn((char const   *)line, " \t");
#line 168
  line += tmp___2;
  }
#line 169
  if (! *line) {
#line 170
    return (1);
  }
#line 172
  if ((int )*line != 67) {
#line 172
    if ((int )*line != 70) {
#line 173
      return (1);
    } else {
#line 172
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 172
  if ((int )*(line + 1) != 32) {
#line 172
    if ((int )*(line + 1) != 9) {
#line 173
      return (1);
    }
  }
  {
#line 175
  tmp___3 = line;
#line 175
  line ++;
#line 175
  unit___0 = *tmp___3;
#line 178
  tmp___4 = strspn((char const   *)line, " \t");
#line 178
  line += tmp___4;
  }
#line 179
  if (! *line) {
#line 180
    return (1);
  }
  {
#line 182
  tmp___5 = extract_string(& line);
#line 182
  p = (char *)tmp___5;
  }
#line 183
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 184
    return (1);
  }
  {
#line 186
  description = (char const   *)line;
#line 187
  *p = (char )'\000';
#line 190
  tmp___6 = malloc(sizeof(struct harddrive_entry ));
#line 190
  new_entry = (struct harddrive_entry *)tmp___6;
  }
#line 191
  if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
    {
#line 192
    perror("malloc");
#line 193
    exit(-1);
    }
  }
  {
#line 196
  new_entry->regexp = strdup(regexp);
#line 197
  new_entry->description = strdup(description);
#line 198
  new_entry->attribute_id = (short )value;
#line 199
  new_entry->unit = (unsigned char )unit___0;
#line 200
  new_entry->next = (struct harddrive_entry *)((void *)0);
#line 201
  *last_entry = new_entry;
#line 202
  last_entry = & new_entry->next;
  }
#line 204
  return (0);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.c"
void free_database(void) 
{ 
  struct harddrive_entry *p ;
  struct harddrive_entry *q ;

  {
#line 210
  p = supported_drives;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! p) {
#line 212
      goto while_break;
    }
#line 215
    if (p->regexp) {
      {
#line 216
      free((void *)p->regexp);
      }
    }
#line 218
    if (p->description) {
      {
#line 219
      free((void *)p->description);
      }
    }
    {
#line 221
    q = p;
#line 222
    p = p->next;
#line 223
    free((void *)q);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/db.c"
void load_database(char const   *filename ) 
{ 
  char buff[1024] ;
  char *p ;
  char *s ;
  char *e ;
  char *ee ;
  int fd ;
  int n ;
  int rest ;
  int numline ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 233
  tmp = __errno_location();
#line 233
  *tmp = 0;
#line 234
  fd = open(filename, 0);
  }
#line 235
  if (fd == -1) {
    {
#line 236
    tmp___0 = __errno_location();
#line 236
    tmp___1 = strerror(*tmp___0);
#line 236
    tmp___2 = gettext("hddtemp: can\'t open %1$s: %2$s\n");
#line 236
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            filename, tmp___1);
#line 237
    exit(2);
    }
  }
#line 240
  numline = 0;
#line 241
  rest = 1024;
#line 242
  p = buff;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    tmp___7 = read(fd, (void *)p, (size_t )rest);
#line 243
    n = (int )tmp___7;
    }
#line 243
    if (! (n > 0)) {
#line 243
      goto while_break;
    }
#line 244
    s = buff;
#line 245
    ee = p + n;
    {
#line 246
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 246
      tmp___5 = memchr((void const   *)s, '\n', (size_t )(ee - s));
#line 246
      e = (char *)tmp___5;
      }
#line 246
      if (! e) {
#line 246
        goto while_break___0;
      }
      {
#line 247
      *e = (char )'\000';
#line 248
      numline ++;
#line 249
      tmp___4 = parse_db_line(s);
      }
#line 249
      if (tmp___4) {
        {
#line 250
        tmp___3 = gettext("ERROR: syntax error at line %1$d in %2$s\n");
#line 250
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
                numline, filename);
#line 251
        exit(2);
        }
      }
#line 253
      s = e + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    if ((unsigned long )s == (unsigned long )(buff)) {
      {
#line 257
      tmp___6 = gettext("  ERROR: line exceed %1$d characters in %2$s.\n");
#line 257
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              1024, filename);
#line 258
      close(fd);
#line 259
      exit(2);
      }
    }
    {
#line 262
    memmove((void *)(buff), (void const   *)s, (size_t )(ee - s));
#line 264
    rest = (int )(1024L - (ee - s));
#line 265
    p = buff + (ee - s);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  close(fd);
  }
#line 269
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/atacmds.c"
int ata_enable_smart(int device ) 
{ 
  unsigned char cmd[4] ;
  int tmp ;

  {
  {
#line 45
  cmd[0] = (unsigned char)176;
#line 45
  cmd[1] = (unsigned char)0;
#line 45
  cmd[2] = (unsigned char)216;
#line 45
  cmd[3] = (unsigned char)0;
#line 47
  tmp = ioctl(device, 799UL, cmd);
  }
#line 47
  return (tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/atacmds.c"
int ata_get_smart_values(int device , unsigned char *buff ) 
{ 
  unsigned char cmd[516] ;
  unsigned int tmp ;
  int ret ;

  {
#line 51
  cmd[0] = (unsigned char)176;
#line 51
  cmd[1] = (unsigned char)0;
#line 51
  cmd[2] = (unsigned char)208;
#line 51
  cmd[3] = (unsigned char)1;
#line 51
  tmp = 4U;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (tmp >= 516U) {
#line 51
      goto while_break;
    }
#line 51
    cmd[tmp] = (unsigned char)0;
#line 51
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  ret = ioctl(device, 799UL, cmd);
  }
#line 55
  if (ret) {
#line 56
    return (ret);
  }
  {
#line 57
  memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)(cmd + 4),
         (size_t )512);
  }
#line 58
  return (0);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/atacmds.c"
unsigned char *ata_search_temperature(unsigned char const   *smart_data , int attribute_id ) 
{ 
  int i___0 ;
  int n ;
  char *tmp ;

  {
#line 64
  n = 3;
#line 65
  i___0 = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (debug) {
#line 66
      goto _L;
    } else
#line 66
    if ((int const   )*(smart_data + n) != (int const   )attribute_id) {
      _L: /* CIL Label */ 
#line 66
      if (! (i___0 < 30)) {
#line 66
        goto while_break;
      }
    } else {
#line 66
      goto while_break;
    }
#line 67
    if (debug) {
#line 67
      if (*(smart_data + n)) {
        {
#line 68
        tmp = gettext("field(%d)\t = %d\t(0x%02x)\n");
#line 68
        printf((char const   */* __restrict  */)tmp, (int )*(smart_data + n), (int )*((smart_data + n) + 3),
               (int const   )*((smart_data + n) + 3));
        }
      }
    }
#line 73
    n += 12;
#line 74
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (i___0 >= 30) {
#line 78
    return ((unsigned char *)((void *)0));
  } else {
#line 80
    return ((unsigned char *)(smart_data + n));
  }
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/atacmds.c"
enum e_powermode ata_get_powermode(int device ) 
{ 
  unsigned char args[4] ;
  enum e_powermode state ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 90
  args[0] = (unsigned char)229;
#line 90
  args[1] = (unsigned char)0;
#line 90
  args[2] = (unsigned char)0;
#line 90
  args[3] = (unsigned char)0;
#line 91
  state = (enum e_powermode )0;
#line 100
  tmp___0 = ioctl(device, 799UL, & args);
  }
#line 100
  if (tmp___0) {
#line 100
    args[0] = (unsigned char)152;
#line 100
    if (args[0]) {
      {
#line 100
      tmp___1 = ioctl(device, 799UL, & args);
      }
#line 100
      if (tmp___1) {
        {
#line 104
        tmp = __errno_location();
        }
#line 104
        if (*tmp != 5) {
#line 105
          state = (enum e_powermode )0;
        } else
#line 104
        if ((int )args[0] != 0) {
#line 105
          state = (enum e_powermode )0;
        } else
#line 104
        if ((int )args[1] != 0) {
#line 105
          state = (enum e_powermode )0;
        } else {
#line 107
          state = (enum e_powermode )2;
        }
      } else {
#line 100
        goto _L___0;
      }
    } else {
#line 100
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 109
  if ((int )args[2] == 255) {
#line 109
    state = (enum e_powermode )1;
  } else {
#line 109
    state = (enum e_powermode )3;
  }
#line 112
  return (state);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/atacmds.c"
int ata_get_packet(int device ) 
{ 
  unsigned short buf[256] ;
  int tmp ;

  {
  {
#line 117
  tmp = ioctl(device, 781UL, buf);
  }
#line 117
  if (tmp) {
#line 120
    return (0);
  } else
#line 117
  if ((int )buf[0] & 32768) {
#line 118
    return (1);
  } else {
#line 120
    return (0);
  }
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.h"
int scsi_modesense(int device , unsigned char pagenum , unsigned char *buffer , int buffer_len ) ;
#line 31
int scsi_modeselect(int device , char *buffer ) ;
#line 32
int scsi_logsense(int device , int pagenum , unsigned char *buffer , int buffer_len ) ;
#line 33
int scsi_smartsupport(int device ) ;
#line 34
int scsi_smartDEXCPTdisable(int device ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
static void scsi_fixstring(unsigned char *s , int bytecount ) 
{ 
  unsigned char *p ;
  unsigned char *end ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 52
  p = s;
#line 53
  end = s + bytecount;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if ((unsigned long )s != (unsigned long )end) {
#line 56
      if (! ((int )*s == 32)) {
#line 56
        goto while_break;
      }
    } else {
#line 56
      goto while_break;
    }
#line 57
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 59
    if ((unsigned long )s != (unsigned long )end) {
#line 59
      if (! *s) {
#line 59
        goto while_break___0;
      }
    } else {
#line 59
      goto while_break___0;
    }
#line 60
    tmp___0 = s;
#line 60
    s ++;
#line 60
    if ((int )*tmp___0 != 32) {
#line 61
      tmp = p;
#line 61
      p ++;
#line 61
      *tmp = *(s - 1);
    } else
#line 60
    if ((unsigned long )s != (unsigned long )end) {
#line 60
      if (*s) {
#line 60
        if ((int )*s != 32) {
#line 61
          tmp = p;
#line 61
          p ++;
#line 61
          *tmp = *(s - 1);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 64
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 64
    if (! ((unsigned long )p != (unsigned long )end)) {
#line 64
      goto while_break___1;
    }
#line 65
    tmp___1 = p;
#line 65
    p ++;
#line 65
    *tmp___1 = (unsigned char )'\000';
  }
  while_break___1: /* CIL Label */ ;
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
int scsi_SG_IO(int device , unsigned char *cdb , int cdb_len , unsigned char *buffer ,
               int buffer_len , unsigned char *sense , unsigned char sense_len , int dxfer_direction ) 
{ 
  struct sg_io_hdr io_hdr ;
  int tmp ;

  {
  {
#line 71
  memset((void *)(& io_hdr), 0, sizeof(struct sg_io_hdr ));
#line 72
  io_hdr.interface_id = 'S';
#line 73
  io_hdr.cmdp = cdb;
#line 74
  io_hdr.cmd_len = (unsigned char )cdb_len;
#line 75
  io_hdr.dxfer_len = (unsigned int )buffer_len;
#line 76
  io_hdr.dxferp = (void *)buffer;
#line 77
  io_hdr.mx_sb_len = sense_len;
#line 78
  io_hdr.sbp = sense;
#line 79
  io_hdr.dxfer_direction = dxfer_direction;
#line 80
  io_hdr.timeout = 3000U;
#line 82
  tmp = ioctl(device, 8837UL, & io_hdr);
  }
#line 82
  return (tmp);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
int scsi_SEND_COMMAND(int device , unsigned char *cdb , int cdb_len , unsigned char *buffer ,
                      int buffer_len , int dxfer_direction ) 
{ 
  unsigned char buf[2048] ;
  unsigned int inbufsize ;
  unsigned int outbufsize ;
  unsigned int ret ;
  int tmp ;

  {
  {
#line 91
  if (dxfer_direction == -3) {
#line 91
    goto case_neg_3;
  }
#line 95
  if (dxfer_direction == -2) {
#line 95
    goto case_neg_2;
  }
#line 99
  goto switch_default;
  case_neg_3: /* CIL Label */ 
#line 92
  inbufsize = 0U;
#line 93
  outbufsize = (unsigned int )buffer_len;
#line 94
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 96
  inbufsize = (unsigned int )buffer_len;
#line 97
  outbufsize = 0U;
#line 98
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 100
  inbufsize = 0U;
#line 101
  outbufsize = 0U;
#line 102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 104
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(& inbufsize),
         sizeof(inbufsize));
#line 105
  memcpy((void */* __restrict  */)(buf + sizeof(inbufsize)), (void const   */* __restrict  */)(& outbufsize),
         sizeof(outbufsize));
#line 106
  memcpy((void */* __restrict  */)((buf + sizeof(inbufsize)) + sizeof(outbufsize)),
         (void const   */* __restrict  */)cdb, (size_t )cdb_len);
#line 107
  memcpy((void */* __restrict  */)(((buf + sizeof(inbufsize)) + sizeof(outbufsize)) + cdb_len),
         (void const   */* __restrict  */)buffer, (size_t )buffer_len);
#line 109
  tmp = ioctl(device, 1UL, buf);
#line 109
  ret = (unsigned int )tmp;
#line 111
  memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)((buf + sizeof(inbufsize)) + sizeof(outbufsize)),
         (size_t )buffer_len);
  }
#line 113
  return ((int )ret);
}
}
#line 118
int scsi_command(int device , unsigned char *cdb , int cdb_len , unsigned char *buffer ,
                 int buffer_len , int dxfer_direction ) ;
#line 118 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
static int SG_IO_supported  =    -1;
#line 116 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
int scsi_command(int device , unsigned char *cdb , int cdb_len , unsigned char *buffer ,
                 int buffer_len , int dxfer_direction ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 121
  if (SG_IO_supported == 1) {
    {
#line 122
    tmp = scsi_SG_IO(device, cdb, cdb_len, buffer, buffer_len, (unsigned char *)((void *)0),
                     (unsigned char)0, dxfer_direction);
    }
#line 122
    return (tmp);
  } else
#line 123
  if (SG_IO_supported == 0) {
    {
#line 124
    tmp___0 = scsi_SEND_COMMAND(device, cdb, cdb_len, buffer, buffer_len, dxfer_direction);
    }
#line 124
    return (tmp___0);
  } else {
    {
#line 126
    ret = scsi_SG_IO(device, cdb, cdb_len, buffer, buffer_len, (unsigned char *)((void *)0),
                     (unsigned char)0, dxfer_direction);
    }
#line 127
    if (ret == 0) {
#line 128
      SG_IO_supported = 1;
#line 129
      return (ret);
    } else {
      {
#line 131
      SG_IO_supported = 0;
#line 132
      tmp___1 = scsi_SEND_COMMAND(device, cdb, cdb_len, buffer, buffer_len, dxfer_direction);
      }
#line 132
      return (tmp___1);
    }
  }
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
int scsi_inquiry(int device , unsigned char *buffer ) 
{ 
  unsigned char cdb[6] ;
  int tmp ;

  {
  {
#line 141
  memset((void *)(cdb), 0, sizeof(cdb));
#line 142
  cdb[0] = (unsigned char)18;
#line 143
  cdb[4] = (unsigned char)36;
#line 146
  tmp = scsi_command(device, cdb, (int )sizeof(cdb), buffer, (int )cdb[4], -3);
  }
#line 146
  if (tmp != 0) {
#line 147
    return (1);
  } else {
    {
#line 149
    scsi_fixstring(buffer + 8, 24);
#line 150
    *(buffer + 32) = (unsigned char)0;
    }
#line 151
    return (0);
  }
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
int scsi_modesense(int device , unsigned char pagenum , unsigned char *buffer , int buffer_len ) 
{ 
  unsigned char cdb[6] ;
  int ret ;

  {
  {
#line 159
  memset((void *)(cdb), 0, sizeof(cdb));
#line 160
  cdb[0] = (unsigned char)26;
#line 161
  cdb[2] = pagenum;
#line 162
  cdb[4] = (unsigned char)255;
#line 164
  ret = scsi_command(device, cdb, (int )sizeof(cdb), buffer, buffer_len, -3);
  }
#line 165
  if (ret == 0) {
#line 166
    if ((int )*(buffer + 3) + 5 > (int )*(buffer + 0)) {
#line 167
      return (-1);
    }
  }
#line 169
  return (ret);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
int scsi_modeselect(int device , char *buffer ) 
{ 
  unsigned char cdb[6] ;
  int tmp ;

  {
  {
#line 175
  memset((void *)(cdb), 0, sizeof(cdb));
#line 176
  cdb[0] = (unsigned char)21;
#line 177
  cdb[1] = (unsigned char)17;
#line 178
  cdb[4] = (unsigned char )((int )*(buffer + 0) + 1);
#line 180
  memset((void *)buffer, 0, (size_t )12);
#line 181
  *(buffer + 3) = (char)8;
#line 182
  *(buffer + 10) = (char)2;
#line 183
  *(buffer + 12) = (char )((int )*(buffer + 12) & 63);
#line 185
  tmp = scsi_command(device, cdb, (int )sizeof(cdb), (unsigned char *)buffer, (int )cdb[4],
                     -2);
  }
#line 185
  return (tmp);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
int scsi_logsense(int device , int pagenum , unsigned char *buffer , int buffer_len ) 
{ 
  unsigned char cdb[10] ;
  int tmp ;

  {
  {
#line 191
  memset((void *)(cdb), 0, sizeof(cdb));
#line 192
  cdb[0] = (unsigned char)77;
#line 193
  cdb[2] = (unsigned char )(64 | pagenum);
#line 194
  cdb[7] = (unsigned char)4;
#line 196
  tmp = scsi_command(device, cdb, (int )sizeof(cdb), buffer, buffer_len, -3);
  }
#line 196
  return (tmp);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
int scsi_smartsupport(int device ) 
{ 
  unsigned char buf[255] ;
  int tmp ;

  {
  {
#line 202
  tmp = scsi_modesense(device, (unsigned char)28, buf, (int )sizeof(buf));
  }
#line 202
  if (tmp != 0) {
#line 203
    return (0);
  } else {
#line 205
    return (((int )buf[14] & 8) == 0);
  }
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsicmds.c"
int scsi_smartDEXCPTdisable(int device ) 
{ 
  unsigned char buf[255] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 211
  tmp = scsi_modesense(device, (unsigned char)28, buf, (int )sizeof(buf));
  }
#line 211
  if (tmp != 0) {
#line 212
    return (1);
  }
#line 214
  if ((int )buf[14] & 8) {
    {
#line 215
    buf[14] = (unsigned char )((int )buf[14] & 247);
#line 216
    buf[15] = (unsigned char)4;
#line 217
    tmp___0 = scsi_modeselect(device, (char *)(buf));
    }
#line 217
    return (tmp___0);
  } else {
#line 220
    return (0);
  }
}
}
#line 27 "/usr/include/execinfo.h"
extern int ( __attribute__((__nonnull__(1))) backtrace)(void **__array , int __size ) ;
#line 32
extern  __attribute__((__nothrow__)) char **( __attribute__((__nonnull__(1), __leaf__)) backtrace_symbols)(void * const  *__array ,
                                                                                                           int __size ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 620 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
static struct ucontext *puc  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
static void *btinfo[64]  ;
#line 47
void backtrace_handler(int n , siginfo_t *ist , void *extra ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
static char **messages  =    (char **)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
static size_t btsize  =    (size_t )0;
#line 49 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
static size_t i  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
static char *strerr  =    (char *)"???";
#line 51 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
static FILE *fstrm  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
static char btpath[4096]  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
void backtrace_handler(int n , siginfo_t *ist , void *extra ) 
{ 
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;

  {
  {
#line 55
  tmp = getpid();
#line 55
  snprintf((char */* __restrict  */)(btpath), (size_t )4096, (char const   */* __restrict  */)"/tmp/hddtemp.backtrace.%d.XXXXXX",
           tmp);
#line 56
  tmp___0 = mkstemp(btpath);
#line 56
  fstrm = fdopen(tmp___0, "w");
  }
#line 56
  if ((unsigned long )fstrm == (unsigned long )((void *)0)) {
#line 57
    return;
  }
#line 61
  puc = (struct ucontext *)extra;
  {
#line 63
  if (n == 11) {
#line 63
    goto case_11;
  }
#line 73
  if (n == 4) {
#line 73
    goto case_4;
  }
#line 89
  if (n == 7) {
#line 89
    goto case_7___0;
  }
#line 62
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 65
  if (ist->si_code == 1) {
#line 65
    goto case_1;
  }
#line 66
  if (ist->si_code == 2) {
#line 66
    goto case_2;
  }
#line 64
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 65
  strerr = (char *)"SEGV_MAPERR";
  case_2: /* CIL Label */ 
#line 66
  strerr = (char *)"SEGV_ACCERR";
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 68
  fprintf((FILE */* __restrict  */)fstrm, (char const   */* __restrict  */)"=== SEGFAULT (%s) : invalid access to %p, in %p\n",
          strerr, ist->_sifields._sigfault.si_addr, (void *)puc->uc_mcontext.gregs[16]);
  }
#line 72
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 75
  if (ist->si_code == 1) {
#line 75
    goto case_1___0;
  }
#line 76
  if (ist->si_code == 2) {
#line 76
    goto case_2___0;
  }
#line 77
  if (ist->si_code == 3) {
#line 77
    goto case_3;
  }
#line 78
  if (ist->si_code == 4) {
#line 78
    goto case_4___0;
  }
#line 79
  if (ist->si_code == 5) {
#line 79
    goto case_5;
  }
#line 80
  if (ist->si_code == 6) {
#line 80
    goto case_6;
  }
#line 81
  if (ist->si_code == 7) {
#line 81
    goto case_7;
  }
#line 82
  if (ist->si_code == 8) {
#line 82
    goto case_8;
  }
#line 74
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
#line 75
  strerr = (char *)"ILL_ILLOPC";
  case_2___0: /* CIL Label */ 
#line 76
  strerr = (char *)"ILL_ILLOPN";
  case_3: /* CIL Label */ 
#line 77
  strerr = (char *)"ILL_ILLADR";
  case_4___0: /* CIL Label */ 
#line 78
  strerr = (char *)"ILL_ILLTRP";
  case_5: /* CIL Label */ 
#line 79
  strerr = (char *)"ILL_PRVOPC";
  case_6: /* CIL Label */ 
#line 80
  strerr = (char *)"ILL_PRVREG";
  case_7: /* CIL Label */ 
#line 81
  strerr = (char *)"ILL_COPROC";
  case_8: /* CIL Label */ 
#line 82
  strerr = (char *)"ILL_BADSTK";
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 84
  fprintf((FILE */* __restrict  */)fstrm, (char const   */* __restrict  */)"=== ILLEGAL INSTR (%s) : invalid access to %p, in %p\n",
          strerr, ist->_sifields._sigfault.si_addr, (void *)puc->uc_mcontext.gregs[16]);
  }
#line 88
  goto switch_break;
  case_7___0: /* CIL Label */ 
  {
#line 91
  if (ist->si_code == 1) {
#line 91
    goto case_1___1;
  }
#line 92
  if (ist->si_code == 2) {
#line 92
    goto case_2___1;
  }
#line 93
  if (ist->si_code == 3) {
#line 93
    goto case_3___0;
  }
#line 90
  goto switch_break___2;
  case_1___1: /* CIL Label */ 
#line 91
  strerr = (char *)"BUS_ADRALN";
  case_2___1: /* CIL Label */ 
#line 92
  strerr = (char *)"BUS_ADRERR";
  case_3___0: /* CIL Label */ 
#line 93
  strerr = (char *)"BUS_OBJERR";
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 95
  fprintf((FILE */* __restrict  */)fstrm, (char const   */* __restrict  */)"=== BUS ERROR (%p) : invalid access to %p, in %p\n",
          strerr, ist->_sifields._sigfault.si_addr, (void *)puc->uc_mcontext.gregs[16]);
  }
#line 99
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 101
  fflush(fstrm);
#line 117
  tmp___1 = backtrace(btinfo, 64);
#line 117
  btsize = (size_t )tmp___1;
#line 118
  btinfo[1] = (void *)puc->uc_mcontext.gregs[16];
#line 120
  messages = backtrace_symbols((void * const  *)(btinfo), (int )btsize);
#line 122
  i = (size_t )1;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < btsize)) {
#line 122
      goto while_break;
    }
    {
#line 125
    tmp___2 = getpid();
#line 125
    fprintf((FILE */* __restrict  */)fstrm, (char const   */* __restrict  */)"[%d] #%zu: %s\n",
            tmp___2, i, *(messages + i));
#line 122
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  fflush(fstrm);
#line 127
  fclose(fstrm);
  }
#line 132
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
void backtrace_sigsegv(void) 
{ 
  struct sigaction sigst ;
  int tmp ;

  {
  {
#line 137
  sigst.__sigaction_handler.sa_sigaction = & backtrace_handler;
#line 138
  sigemptyset(& sigst.sa_mask);
#line 139
  sigaddset(& sigst.sa_mask, 4);
#line 140
  sigaddset(& sigst.sa_mask, 7);
#line 141
  sigst.sa_flags = -2147483644;
#line 143
  tmp = sigaction(11, (struct sigaction  const  */* __restrict  */)(& sigst), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 143
  if (tmp == -1) {
    {
#line 144
    perror("sigaction");
    }
  }
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
void backtrace_sigbus(void) 
{ 
  struct sigaction sigst ;
  int tmp ;

  {
  {
#line 150
  sigst.__sigaction_handler.sa_sigaction = & backtrace_handler;
#line 151
  sigemptyset(& sigst.sa_mask);
#line 152
  sigaddset(& sigst.sa_mask, 4);
#line 153
  sigaddset(& sigst.sa_mask, 11);
#line 154
  sigst.sa_flags = -2147483644;
#line 156
  tmp = sigaction(7, (struct sigaction  const  */* __restrict  */)(& sigst), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 156
  if (tmp == -1) {
    {
#line 157
    perror("sigaction");
    }
  }
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/backtrace.c"
void backtrace_sigill(void) 
{ 
  struct sigaction sigst ;
  int tmp ;

  {
  {
#line 163
  sigst.__sigaction_handler.sa_sigaction = & backtrace_handler;
#line 164
  sigemptyset(& sigst.sa_mask);
#line 165
  sigaddset(& sigst.sa_mask, 11);
#line 166
  sigaddset(& sigst.sa_mask, 7);
#line 167
  sigst.sa_flags = -2147483644;
#line 169
  tmp = sigaction(4, (struct sigaction  const  */* __restrict  */)(& sigst), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 169
  if (tmp == -1) {
    {
#line 170
    perror("sigaction");
    }
  }
#line 171
  return;
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 195
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) difftime)(time_t __time1 ,
                                                                                  time_t __time0 )  __attribute__((__const__)) ;
#line 199
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
int sks_serv_num  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
int *sks_serv  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
int stop_daemon  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
void daemon_open_sockets(void) 
{ 
  struct addrinfo *all_ai ;
  struct addrinfo hints ;
  struct addrinfo *resp ;
  char portbuf[10] ;
  int on ;
  int ret ;
  char const   *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 65
  on = 1;
#line 68
  memset((void *)(& hints), 0, sizeof(hints));
#line 69
  hints.ai_family = af_hint;
#line 70
  hints.ai_socktype = 1;
#line 71
  hints.ai_flags = 1;
#line 72
  snprintf((char */* __restrict  */)(portbuf), sizeof(portbuf), (char const   */* __restrict  */)"%ld",
           portnum);
#line 73
  ret = getaddrinfo((char const   */* __restrict  */)listen_addr, (char const   */* __restrict  */)(portbuf),
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& all_ai));
  }
#line 74
  if (ret != 0) {
    {
#line 75
    tmp = gai_strerror(ret);
#line 75
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo: %s\n",
            tmp);
#line 76
    exit(1);
    }
  }
#line 80
  sks_serv_num = 0;
#line 80
  resp = all_ai;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! resp) {
#line 80
      goto while_break;
    }
#line 81
    sks_serv_num ++;
#line 80
    resp = resp->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  tmp___0 = malloc(sizeof(int ) * (unsigned long )sks_serv_num);
#line 82
  sks_serv = (int *)tmp___0;
  }
#line 83
  if (! sks_serv) {
    {
#line 84
    perror("malloc");
#line 85
    freeaddrinfo(all_ai);
#line 86
    exit(1);
    }
  }
#line 92
  sks_serv_num = 0;
#line 92
  resp = all_ai;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! resp) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    *(sks_serv + sks_serv_num) = socket(resp->ai_family, resp->ai_socktype, resp->ai_protocol);
    }
#line 94
    if (*(sks_serv + sks_serv_num) == -1) {
#line 96
      goto __Cont;
    }
    {
#line 99
    setsockopt(*(sks_serv + sks_serv_num), 1, 2, (void const   *)(& on), (socklen_t )sizeof(on));
#line 102
    tmp___1 = bind(*(sks_serv + sks_serv_num), (struct sockaddr  const  *)resp->ai_addr,
                   resp->ai_addrlen);
    }
#line 102
    if (tmp___1 < 0) {
      {
#line 104
      close(*(sks_serv + sks_serv_num));
      }
#line 105
      goto __Cont;
    }
    {
#line 109
    tmp___2 = listen(*(sks_serv + sks_serv_num), 5);
    }
#line 109
    if (tmp___2 == -1) {
      {
#line 110
      perror("listen");
#line 111
      sks_serv_num --;
      }
      {
#line 111
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 111
        if (! (sks_serv_num > 0)) {
#line 111
          goto while_break___1;
        }
        {
#line 112
        close(*(sks_serv + sks_serv_num));
#line 111
        sks_serv_num --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 113
      freeaddrinfo(all_ai);
#line 114
      free((void *)sks_serv);
#line 115
      exit(1);
      }
    }
#line 118
    sks_serv_num ++;
    __Cont: /* CIL Label */ 
#line 92
    resp = resp->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 121
  if (sks_serv_num == 0) {
    {
#line 122
    perror("socket");
#line 123
    free((void *)sks_serv);
#line 124
    freeaddrinfo(all_ai);
#line 125
    exit(1);
    }
  }
  {
#line 128
  freeaddrinfo(all_ai);
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
void daemon_update(struct disk *ldisks , int nocache ) 
{ 
  struct disk *dsk ;
  time_t tmp ;
  double tmp___0 ;

  {
#line 134
  dsk = ldisks;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! dsk) {
#line 134
      goto while_break;
    }
#line 135
    if (nocache) {
#line 135
      goto _L;
    } else {
      {
#line 135
      tmp = time((time_t *)((void *)0));
#line 135
      tmp___0 = difftime(tmp, dsk->last_time);
      }
#line 135
      if (tmp___0 > 60.0) {
        _L: /* CIL Label */ 
#line 136
        dsk->value = -1;
#line 138
        if ((unsigned int )dsk->type == 0U) {
#line 139
          dsk->ret = (enum e_gettemp )0;
        } else {
          {
#line 141
          dsk->ret = (*((bus[dsk->type])->get_temperature))(dsk);
          }
        }
        {
#line 143
        time(& dsk->last_time);
        }
      }
    }
#line 134
    dsk = dsk->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
void daemon_close_sockets(void) 
{ 
  int i___0 ;

  {
#line 151
  i___0 = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i___0 < sks_serv_num)) {
#line 151
      goto while_break;
    }
    {
#line 152
    close(*(sks_serv + i___0));
#line 151
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
void daemon_send_msg(struct disk *ldisks , int cfd ) 
{ 
  struct disk *dsk ;
  char msg[128] ;
  int n ;
  char tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 158
  daemon_update(ldisks, 0);
#line 160
  dsk = ldisks;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! dsk) {
#line 160
      goto while_break;
    }
    {
#line 165
    if ((unsigned int )dsk->ret == 1U) {
#line 165
      goto case_1;
    }
#line 171
    if ((unsigned int )dsk->ret == 2U) {
#line 171
      goto case_2;
    }
#line 177
    if ((unsigned int )dsk->ret == 3U) {
#line 177
      goto case_3;
    }
#line 184
    if ((unsigned int )dsk->ret == 4U) {
#line 184
      goto case_4;
    }
#line 190
    if ((unsigned int )dsk->ret == 5U) {
#line 190
      goto case_5;
    }
#line 197
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 166
    n = snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s%c%s%cNA%c*",
                 dsk->drive, (int )separator, dsk->model, (int )separator, (int )separator);
    }
#line 170
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 172
    n = snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s%c%s%cUNK%c*",
                 dsk->drive, (int )separator, dsk->model, (int )separator, (int )separator);
    }
#line 176
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 178
    tmp = get_unit(dsk);
#line 178
    tmp___0 = value_to_unit(dsk);
#line 178
    n = snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s%c%s%c%d%c%c",
                 dsk->drive, (int )separator, dsk->model, (int )separator, tmp___0,
                 (int )separator, (int )tmp);
    }
#line 183
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 185
    n = snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s%c%s%cNOS%c*",
                 dsk->drive, (int )separator, dsk->model, (int )separator, (int )separator);
    }
#line 189
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 191
    n = snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s%c%s%cSLP%c*",
                 dsk->drive, (int )separator, dsk->model, (int )separator, (int )separator);
    }
#line 195
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 198
    if (dsk->model) {
#line 198
      tmp___1 = dsk->model;
    } else {
#line 198
      tmp___1 = "???";
    }
    {
#line 198
    n = snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s%c%s%cERR%c*",
                 dsk->drive, (int )separator, tmp___1, (int )separator, (int )separator);
    }
#line 202
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 204
    write(cfd, (void const   *)(& separator), (size_t )1);
#line 205
    write(cfd, (void const   *)(& msg), (size_t )n);
#line 206
    write(cfd, (void const   *)(& separator), (size_t )1);
#line 160
    dsk = dsk->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
void daemon_syslog(struct disk *ldisks ) 
{ 
  struct disk *dsk ;
  char tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 214
  daemon_update(ldisks, 1);
#line 216
  dsk = ldisks;
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! dsk) {
#line 216
      goto while_break;
    }
    {
#line 218
    if ((unsigned int )dsk->ret == 3U) {
#line 218
      goto case_3;
    }
#line 225
    if ((unsigned int )dsk->ret == 5U) {
#line 225
      goto case_5;
    }
#line 231
    if ((unsigned int )dsk->ret == 2U) {
#line 231
      goto case_2;
    }
#line 231
    if ((unsigned int )dsk->ret == 4U) {
#line 231
      goto case_2;
    }
#line 236
    if ((unsigned int )dsk->ret == 1U) {
#line 236
      goto case_1;
    }
#line 242
    goto switch_default;
    case_3: /* CIL Label */ 
    {
#line 219
    tmp = get_unit(dsk);
#line 219
    tmp___0 = value_to_unit(dsk);
#line 219
    syslog(6, "%s: %s: %d %c", dsk->drive, dsk->model, tmp___0, (int )tmp);
    }
#line 224
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 226
    tmp___1 = gettext("%s: %s: drive is sleeping");
#line 226
    syslog(4, (char const   *)tmp___1, dsk->drive, dsk->model);
    }
#line 229
    goto switch_break;
    case_2: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 232
    tmp___2 = gettext("%s: %s: no sensor");
#line 232
    syslog(4, (char const   *)tmp___2, dsk->drive, dsk->model);
    }
#line 235
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 237
    syslog(3, "%s: %s: %s", dsk->drive, dsk->model, dsk->errormsg);
    }
#line 241
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 244
    syslog(3, "%s: %s", dsk->drive, dsk->errormsg);
    }
#line 247
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 216
    dsk = dsk->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
void daemon_stop(int n ) 
{ 


  {
#line 253
  stop_daemon = 1;
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/daemon.c"
void do_daemon_mode(struct disk *ldisks ) 
{ 
  struct disk *dsk ;
  int cfd ;
  int i___0 ;
  int ret ;
  int maxfd ;
  struct tm *time_st ;
  fd_set deffds ;
  time_t next_time ;
  __pid_t tmp ;
  __pid_t tmp___0 ;
  int __d0 ;
  int __d1 ;
  fd_set fds ;
  struct timeval tv ;
  time_t current_time ;
  time_t tmp___1 ;
  struct sockaddr_storage caddr ;
  socklen_t sz_caddr ;

  {
#line 264
  if (! foreground) {
    {
#line 265
    tmp = fork();
    }
    {
#line 266
    if (tmp == -1) {
#line 266
      goto case_neg_1;
    }
#line 270
    if (tmp == 0) {
#line 270
      goto case_0;
    }
#line 272
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 267
    perror("fork");
#line 268
    exit(2);
    }
#line 269
    goto switch_break;
    case_0: /* CIL Label */ 
#line 271
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 273
    exit(0);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 276
    setsid();
#line 278
    tmp___0 = fork();
    }
    {
#line 279
    if (tmp___0 == -1) {
#line 279
      goto case_neg_1___0;
    }
#line 283
    if (tmp___0 == 0) {
#line 283
      goto case_0___0;
    }
#line 285
    goto switch_default___0;
    case_neg_1___0: /* CIL Label */ 
    {
#line 280
    perror("fork");
#line 281
    exit(2);
    }
#line 282
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 284
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 286
    exit(0);
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 289
  chdir("/");
#line 290
  umask((__mode_t )0);
#line 293
  close(0);
#line 294
  close(1);
#line 295
  close(2);
  }
#line 297
  if (tcp_daemon) {
    {
#line 298
    daemon_open_sockets();
    }
  }
#line 300
  if (syslog_interval > 0L) {
    {
#line 301
    openlog("hddtemp", 1, 3 << 3);
    }
  }
#line 304
  i___0 = 0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i___0 <= 65)) {
#line 304
      goto while_break;
    }
    {
#line 308
    if (i___0 == 4) {
#line 308
      goto case_4;
    }
#line 308
    if (i___0 == 7) {
#line 308
      goto case_4;
    }
#line 308
    if (i___0 == 11) {
#line 308
      goto case_4;
    }
#line 310
    if (i___0 == 13) {
#line 310
      goto case_13;
    }
#line 313
    goto switch_default___1;
    case_4: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 309
    goto switch_break___1;
    case_13: /* CIL Label */ 
    {
#line 311
    signal(13, (void (*)(int  ))1);
    }
#line 312
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 314
    signal(i___0, & daemon_stop);
    }
#line 315
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 304
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 320
  next_time = time((time_t *)((void *)0));
#line 321
  dsk = ldisks;
  }
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! dsk) {
#line 321
      goto while_break___0;
    }
    {
#line 322
    time(& dsk->last_time);
#line 323
    time_st = gmtime((time_t const   *)(& dsk->last_time));
#line 324
    (time_st->tm_year) --;
#line 325
    dsk->last_time = mktime(time_st);
#line 321
    dsk = dsk->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 329
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 329
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& deffds.__fds_bits[0]): "memory");
#line 329
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 330
  maxfd = -1;
#line 332
  i___0 = 0;
  {
#line 332
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 332
    if (! (i___0 < sks_serv_num)) {
#line 332
      goto while_break___2;
    }
#line 333
    deffds.__fds_bits[*(sks_serv + i___0) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(sks_serv + i___0) % (8 * (int )sizeof(__fd_mask ));
#line 335
    if (maxfd < *(sks_serv + i___0)) {
#line 336
      maxfd = *(sks_serv + i___0);
    }
#line 332
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 340
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 340
    if (! (stop_daemon == 0)) {
#line 340
      goto while_break___3;
    }
#line 342
    fds = deffds;
#line 344
    if (syslog_interval > 0L) {
      {
#line 349
      current_time = time((time_t *)((void *)0));
      }
#line 350
      if (next_time > current_time) {
#line 351
        tv.tv_sec = next_time - current_time;
      } else {
#line 353
        tv.tv_sec = (__time_t )0;
      }
      {
#line 354
      tv.tv_usec = (__suseconds_t )0;
#line 355
      ret = select(maxfd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
    } else {
      {
#line 358
      ret = select(maxfd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
    }
#line 360
    if (ret == -1) {
#line 361
      goto while_break___3;
    } else
#line 362
    if (ret == 0) {
#line 362
      if (syslog_interval > 0L) {
        {
#line 363
        daemon_syslog(ldisks);
#line 364
        tmp___1 = time((time_t *)((void *)0));
#line 364
        next_time = tmp___1 + syslog_interval;
        }
      } else {
#line 362
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 366
    if (tcp_daemon) {
#line 369
      sz_caddr = (socklen_t )sizeof(struct sockaddr_storage );
#line 371
      i___0 = 0;
      {
#line 371
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 371
        if (! (i___0 < sks_serv_num)) {
#line 371
          goto while_break___4;
        }
#line 372
        if ((fds.__fds_bits[*(sks_serv + i___0) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(sks_serv + i___0) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 373
          goto while_break___4;
        }
#line 371
        i___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 376
      if (i___0 == sks_serv_num) {
#line 377
        goto while_continue___3;
      }
      {
#line 379
      cfd = accept(*(sks_serv + i___0), (struct sockaddr */* __restrict  */)((struct sockaddr *)(& caddr)),
                   (socklen_t */* __restrict  */)(& sz_caddr));
      }
#line 379
      if (cfd == -1) {
#line 380
        goto while_continue___3;
      }
      {
#line 382
      daemon_send_msg(ldisks, cfd);
#line 384
      close(cfd);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 388
  if (tcp_daemon) {
    {
#line 389
    daemon_close_sockets();
    }
  }
#line 391
  if (syslog_interval > 0L) {
    {
#line 392
    closelog();
    }
  }
#line 393
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsi.c"
static int scsi_probe(int device ) 
{ 
  int bus_num ;
  int tmp ;

  {
  {
#line 54
  tmp = ioctl(device, 21382UL, & bus_num);
  }
#line 54
  if (tmp) {
#line 55
    return (0);
  } else {
#line 57
    return (1);
  }
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsi.c"
static char const   *scsi_model(int device ) 
{ 
  unsigned char buf[36] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 63
  tmp___2 = scsi_inquiry(device, buf);
  }
#line 63
  if (tmp___2 != 0) {
    {
#line 64
    tmp = gettext("unknown");
#line 64
    tmp___0 = strdup((char const   *)tmp);
    }
#line 64
    return ((char const   *)tmp___0);
  } else {
    {
#line 66
    tmp___1 = strdup((char const   *)(buf + 8));
    }
#line 66
    return ((char const   *)tmp___1);
  }
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsi.c"
static enum e_gettemp scsi_get_temperature(struct disk *dsk ) 
{ 
  int i___0 ;
  int tempPage ;
  unsigned char buffer[1024] ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 72
  tempPage = 0;
#line 78
  tmp = malloc(sizeof(struct harddrive_entry ));
#line 78
  dsk->db_entry = (struct harddrive_entry *)tmp;
  }
#line 79
  if ((unsigned long )dsk->db_entry == (unsigned long )((void *)0)) {
    {
#line 80
    perror("malloc");
#line 81
    exit(-1);
    }
  }
  {
#line 84
  (dsk->db_entry)->regexp = (char *)"";
#line 85
  (dsk->db_entry)->description = (char *)"";
#line 86
  (dsk->db_entry)->attribute_id = (short)0;
#line 87
  (dsk->db_entry)->unit = (unsigned char )'C';
#line 88
  (dsk->db_entry)->next = (struct harddrive_entry *)((void *)0);
#line 90
  tmp___1 = scsi_smartsupport(dsk->fd);
  }
#line 90
  if (tmp___1 == 0) {
    {
#line 91
    tmp___0 = gettext("S.M.A.R.T. not available");
#line 91
    snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)tmp___0);
#line 92
    close(dsk->fd);
#line 93
    dsk->fd = -1;
    }
#line 94
    return ((enum e_gettemp )1);
  }
  {
#line 100
  tmp___4 = scsi_smartDEXCPTdisable(dsk->fd);
  }
#line 100
  if (tmp___4 != 0) {
    {
#line 101
    tmp___2 = __errno_location();
#line 101
    tmp___3 = strerror(*tmp___2);
#line 101
    snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)"%s",
             tmp___3);
#line 102
    close(dsk->fd);
#line 103
    dsk->fd = -1;
    }
#line 104
    return ((enum e_gettemp )0);
  }
  {
#line 110
  tmp___8 = scsi_logsense(dsk->fd, 0, buffer, (int )sizeof(buffer));
  }
#line 110
  if (tmp___8 != 0) {
    {
#line 111
    tmp___5 = __errno_location();
#line 111
    tmp___6 = strerror(*tmp___5);
#line 111
    tmp___7 = gettext("log sense failed : %s");
#line 111
    snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)tmp___7,
             tmp___6);
#line 112
    close(dsk->fd);
#line 113
    dsk->fd = -1;
    }
#line 114
    return ((enum e_gettemp )0);
  }
#line 117
  i___0 = 4;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i___0 < (int )buffer[3] + 4)) {
#line 117
      goto while_break;
    }
#line 118
    if ((int )buffer[i___0] == 13) {
#line 119
      tempPage = 1;
#line 120
      goto while_break;
    }
#line 117
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  if (tempPage) {
    {
#line 128
    tmp___12 = scsi_logsense(dsk->fd, 13, buffer, (int )sizeof(buffer));
    }
#line 128
    if (tmp___12 != 0) {
      {
#line 129
      tmp___9 = __errno_location();
#line 129
      tmp___10 = strerror(*tmp___9);
#line 129
      tmp___11 = gettext("log sense failed : %s");
#line 129
      snprintf((char */* __restrict  */)(dsk->errormsg), (size_t )128, (char const   */* __restrict  */)tmp___11,
               tmp___10);
#line 130
      close(dsk->fd);
#line 131
      dsk->fd = -1;
      }
#line 132
      return ((enum e_gettemp )0);
    }
#line 135
    dsk->value = (int )buffer[9];
#line 137
    return ((enum e_gettemp )3);
  } else {
#line 139
    return ((enum e_gettemp )4);
  }
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/hddtemp-0.3-beta15/src/scsi.c"
struct bustype scsi_bus  =    {(char *)"SCSI", & scsi_probe, & scsi_model, & scsi_get_temperature};
