/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 11 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.h"
struct s_Cmdline {
   char bsizeP ;
   int bsize ;
   int bsizeC ;
   char vtP ;
   char vrP ;
   char vwP ;
   char ngrP ;
   char speedP ;
   double speed ;
   int speedC ;
   int argc ;
   char **argv ;
};
#line 11 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.h"
typedef struct s_Cmdline Cmdline;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.h"
char *Program ;
#line 37
Cmdline *parseCmdline(int argc , char **argv ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cpipe.c"
double TotalBytes  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cpipe.c"
double totalTin  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cpipe.c"
double totalTout  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cpipe.c"
char *scale(double v , char *buf ) 
{ 


  {
#line 51
  if (v > 1024.0 * 1024.0) {
#line 53
    if (v > (1024.0 * 1024.0) * 1024.0) {
      {
#line 54
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%6.1fG",
              v * (1.0 / ((1024.0 * 1024.0) * 1024.0)));
      }
    } else {
      {
#line 56
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%6.1fM",
              v * (1.0 / (1024.0 * 1024.0)));
      }
    }
  } else
#line 59
  if (v > 1024.0) {
    {
#line 60
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%6.1fk",
            v * (1.0 / 1024.0));
    }
  } else {
    {
#line 62
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%4.0f",
            v);
    }
  }
#line 65
  return (buf);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cpipe.c"
double deltaT(struct timeval *tin , struct timeval *tout ) 
{ 
  long usec ;
  double sec ;

  {
#line 78
  usec = tout->tv_usec - tin->tv_usec;
#line 79
  if (usec < 0L) {
#line 80
    sec = (double )((tout->tv_sec - tin->tv_sec) - 1L) + (double )(usec + 1000000L) * 1e-6;
  } else {
#line 82
    sec = (double )(tout->tv_sec - tin->tv_sec) + (double )usec * 1e-6;
  }
#line 84
  return (sec);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cpipe.c"
ssize_t readBuffer(char *buf , size_t length , int show , int nonblock , int *eof ) 
{ 
  size_t totalBytes ;
  ssize_t bytes ;
  struct timeval tin ;
  struct timeval tout ;
  double dt ;
  char txt1[40] ;
  char txt2[40] ;
  char txt3[40] ;
  int flags ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 101
  flags = fcntl(0, 3);
#line 102
  fcntl(0, 4, flags & -2049);
#line 104
  gettimeofday((struct timeval */* __restrict  */)(& tin), (__timezone_ptr_t )((void *)0));
#line 105
  totalBytes = (size_t )0;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (totalBytes < length)) {
#line 105
      goto while_break;
    }
    {
#line 106
    bytes = read(0, (void *)buf, length - totalBytes);
    }
#line 107
    if (0L == bytes) {
#line 107
      *eof = 1;
#line 107
      goto while_break;
    }
#line 108
    if (bytes > 0L) {
#line 109
      if (nonblock) {
        {
#line 109
        fcntl(0, 4, flags | 2048);
        }
      }
#line 110
      goto __Cont;
    }
    {
#line 112
    tmp = __errno_location();
    }
#line 112
    if (*tmp == 11) {
#line 114
      goto while_break;
    }
    {
#line 116
    tmp___0 = __errno_location();
    }
#line 116
    if (*tmp___0 == 4) {
#line 118
      bytes = (ssize_t )0;
#line 119
      goto __Cont;
    }
    {
#line 123
    tmp___1 = __errno_location();
#line 123
    tmp___2 = strerror(*tmp___1);
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error reading stdin because `%s\'\n",
            Program, tmp___2);
#line 125
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 105
    totalBytes += (size_t )bytes;
#line 105
    buf += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  gettimeofday((struct timeval */* __restrict  */)(& tout), (__timezone_ptr_t )((void *)0));
#line 129
  TotalBytes += (double )totalBytes;
  }
#line 130
  if (show) {
    {
#line 131
    dt = deltaT(& tin, & tout);
#line 132
    totalTin += dt;
#line 133
    tmp___3 = scale(TotalBytes, txt3);
#line 133
    tmp___4 = scale(TotalBytes / totalTin, txt2);
#line 133
    tmp___5 = scale((double )totalBytes / dt, txt1);
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  in: %7.3fms at %7sB/s (%7sB/s avg) %7sB",
            1e3 * dt, tmp___5, tmp___4, tmp___3);
    }
#line 139
    if (totalBytes < length) {
      {
#line 140
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   (bsize=%lu)\n",
              totalBytes);
      }
    } else {
      {
#line 142
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 145
  return ((ssize_t )totalBytes);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cpipe.c"
void writeBuffer(char *buf , size_t length , int show ) 
{ 
  size_t totalBytes ;
  ssize_t bytes ;
  struct timeval tin ;
  struct timeval tout ;
  double dt ;
  char txt1[40] ;
  char txt2[40] ;
  char txt3[40] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 157
  gettimeofday((struct timeval */* __restrict  */)(& tin), (__timezone_ptr_t )((void *)0));
#line 158
  totalBytes = (size_t )0;
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (totalBytes < length)) {
#line 158
      goto while_break;
    }
    {
#line 159
    bytes = write(1, (void const   *)buf, length - totalBytes);
    }
#line 160
    if (-1L == bytes) {
      {
#line 161
      tmp___1 = __errno_location();
      }
#line 161
      if (*tmp___1 != 4) {
        {
#line 161
        tmp___2 = __errno_location();
        }
#line 161
        if (*tmp___2 != 11) {
          {
#line 162
          tmp = __errno_location();
#line 162
          tmp___0 = strerror(*tmp);
#line 162
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error writing stdout because `%s\'\n",
                  Program, tmp___0);
#line 164
          exit(1);
          }
        } else {
#line 166
          bytes = (ssize_t )0;
        }
      } else {
#line 166
        bytes = (ssize_t )0;
      }
    }
#line 158
    totalBytes += (size_t )bytes;
#line 158
    buf += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  gettimeofday((struct timeval */* __restrict  */)(& tout), (__timezone_ptr_t )((void *)0));
  }
#line 171
  if (show) {
    {
#line 172
    dt = deltaT(& tin, & tout);
#line 173
    totalTout += dt;
#line 174
    tmp___3 = scale(TotalBytes, txt3);
#line 174
    tmp___4 = scale(TotalBytes / totalTout, txt2);
#line 174
    tmp___5 = scale((double )totalBytes / dt, txt1);
#line 174
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" out: %7.3fms at %7sB/s (%7sB/s avg) %7sB\n",
            1e3 * dt, tmp___5, tmp___4, tmp___3);
    }
  }
#line 181
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cpipe.c"
int main(int argc , char **argv ) 
{ 
  Cmdline *cmd___0 ;
  char *buf ;
  int count ;
  int eof ;
  struct timeval tstart ;
  struct timeval tin ;
  struct timeval tnow ;
  char txt1[40] ;
  char txt2[40] ;
  char txt3[40] ;
  double calib ;
  void *tmp ;
  double dt ;
  double dtAll ;
  double delay ;
  ssize_t tmp___0 ;
  struct timespec sleeptime ;
  double factor ;
  double tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 192
  calib = 0.98;
#line 195
  cmd___0 = parseCmdline(argc, argv);
#line 197
  cmd___0->bsize = (int )((double )cmd___0->bsize * 1024.0);
  }
#line 198
  if (cmd___0->speedP) {
#line 198
    cmd___0->speed *= 1024.0;
  }
#line 200
  if (cmd___0->ngrP) {
    {
#line 202
    fcntl(0, 4, 2048);
    }
  }
  {
#line 205
  tmp = malloc((size_t )cmd___0->bsize);
#line 205
  buf = (char *)tmp;
  }
#line 206
  if (! buf) {
    {
#line 207
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot allocate buffer of length `%d\', out of memory\n",
            Program, cmd___0->bsize);
#line 210
    exit(1);
    }
  }
  {
#line 213
  TotalBytes = 0.0;
#line 214
  totalTin = 0.0;
#line 215
  totalTout = 0.0;
#line 217
  gettimeofday((struct timeval */* __restrict  */)(& tstart), (__timezone_ptr_t )((void *)0));
#line 218
  count = cmd___0->bsize;
#line 218
  eof = 0;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (! eof)) {
#line 218
      goto while_break;
    }
    {
#line 222
    gettimeofday((struct timeval */* __restrict  */)(& tin), (__timezone_ptr_t )((void *)0));
#line 223
    tmp___0 = readBuffer(buf, (size_t )cmd___0->bsize, (int )cmd___0->vrP, (int )cmd___0->ngrP,
                         & eof);
#line 223
    count = (int )tmp___0;
#line 224
    writeBuffer(buf, (size_t )count, (int )cmd___0->vwP);
#line 225
    gettimeofday((struct timeval */* __restrict  */)(& tnow), (__timezone_ptr_t )((void *)0));
#line 226
    dt = deltaT(& tin, & tnow);
#line 234
    delay = (double )count / cmd___0->speed - dt;
    }
#line 237
    if (cmd___0->speedP) {
#line 237
      if (delay > (double )0) {
        {
#line 240
        delay *= calib;
#line 241
        sleeptime.tv_sec = (time_t )delay;
#line 242
        tmp___1 = floor(delay);
#line 242
        sleeptime.tv_nsec = (__syscall_slong_t )(1e9 * (delay - tmp___1));
#line 243
        tmp___2 = nanosleep((struct timespec  const  *)(& sleeptime), (struct timespec *)((void *)0));
        }
#line 243
        if (0 == tmp___2) {
          {
#line 245
          gettimeofday((struct timeval */* __restrict  */)(& tnow), (__timezone_ptr_t )((void *)0));
#line 246
          dt = deltaT(& tin, & tnow);
#line 253
          factor = ((double )count / dt) / cmd___0->speed;
#line 254
          calib += 0.125 * (factor * calib - calib);
          }
        }
      }
    }
    {
#line 258
    dtAll = deltaT(& tstart, & tnow);
    }
#line 260
    if (cmd___0->vtP) {
      {
#line 261
      tmp___3 = scale(TotalBytes, txt3);
#line 261
      tmp___4 = scale(TotalBytes / dtAll, txt2);
#line 261
      tmp___5 = scale((double )count / dt, txt1);
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"thru: %7.3fms at %7sB/s (%7sB/s avg) %7sB\n",
              1e3 * dt, tmp___5, tmp___4, tmp___3);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return (0);
}
}
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.h"
char *Program  ;
#line 36
void usage(void) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
static Cmdline cmd  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
     {(char)1, 128, 1, (char)0, (char)0, (char)0, (char)0, (char)0, (double )0, 0, 0,
    (char **)0};
#line 62 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
static void checkFloatConversion(double v , char *option , char *arg ) 
{ 
  char *err ;
  int *tmp ;
  double tmp___0 ;
  int *tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  {
#line 65
  err = (char *)((void *)0);
#line 67
  tmp___1 = __errno_location();
  }
#line 67
  if (*tmp___1 == 34) {
#line 67
    if (v != 0.0) {
#line 69
      err = (char *)"large";
    } else {
#line 67
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 67
    tmp___2 = __builtin_huge_val();
    }
#line 67
    if (v < tmp___2) {
      {
#line 67
      tmp___3 = __builtin_huge_val();
      }
#line 67
      if (v > - tmp___3) {
#line 67
        if (v < 0.0) {
#line 67
          tmp___4 = - v;
        } else {
#line 67
          tmp___4 = v;
        }
#line 67
        if (tmp___4 > (double )3.40282346638528859812e+38F) {
#line 69
          err = (char *)"large";
        } else {
#line 67
          goto _L___1;
        }
      } else {
#line 67
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 70
      tmp = __errno_location();
      }
#line 70
      if (*tmp == 34) {
#line 70
        if (v == 0.0) {
#line 72
          err = (char *)"small";
        } else {
#line 70
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 70
      if (v != 0.0) {
#line 70
        if (v < 0.0) {
#line 70
          tmp___0 = - v;
        } else {
#line 70
          tmp___0 = v;
        }
#line 70
        if (tmp___0 < (double )1.17549435082228750797e-38F) {
#line 72
          err = (char *)"small";
        }
      }
    }
  }
#line 74
  if (err) {
    {
#line 75
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to %s to represent\n",
            Program, arg, option, err);
#line 78
    exit(1);
    }
  }
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getIntOpt(int argc , char **argv , int i , int *value , int force ) 
{ 
  char *end ;
  long v ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;

  {
#line 88
  i ++;
#line 88
  if (i >= argc) {
#line 88
    goto nothingFound;
  }
  {
#line 90
  tmp = __errno_location();
#line 90
  *tmp = 0;
#line 91
  v = strtol((char const   */* __restrict  */)*(argv + i), (char **/* __restrict  */)(& end),
             0);
  }
#line 94
  if ((unsigned long )end == (unsigned long )*(argv + i)) {
#line 94
    goto nothingFound;
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    tmp___0 = __ctype_b_loc();
    }
#line 97
    if (! ((int const   )*(*tmp___0 + (int )*end) & 8192)) {
#line 97
      goto while_break;
    }
#line 97
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (*end) {
#line 98
    goto nothingFound;
  }
  {
#line 101
  tmp___1 = __errno_location();
  }
#line 101
  if (*tmp___1 == 34) {
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to large to represent\n",
            Program, *(argv + i), *(argv + (i - 1)));
#line 105
    exit(1);
    }
  } else
#line 101
  if (v > 2147483647L) {
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to large to represent\n",
            Program, *(argv + i), *(argv + (i - 1)));
#line 105
    exit(1);
    }
  } else
#line 101
  if (v < (-0x7FFFFFFF-1)) {
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to large to represent\n",
            Program, *(argv + i), *(argv + (i - 1)));
#line 105
    exit(1);
    }
  }
#line 107
  *value = (int )v;
#line 109
  return (i);
  nothingFound: 
#line 112
  if (! force) {
#line 112
    return (i - 1);
  }
  {
#line 114
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: missing or malformed integer value after option `%s\'\n",
          Program, *(argv + (i - 1)));
#line 117
  exit(1);
  }
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getIntOpts(int argc , char **argv , int i , int **values , int cmin , int cmax ) 
{ 
  int alloced ;
  int used ;
  char *end ;
  long v ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int *tmp___3 ;

  {
#line 133
  if (i + cmin >= argc) {
    {
#line 134
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' wants at least %d parameters\n",
            Program, *(argv + i), cmin);
#line 137
    exit(1);
    }
  }
  {
#line 144
  alloced = cmin + 4;
#line 145
  tmp = calloc((size_t )alloced, sizeof(int ));
#line 145
  *values = (int *)tmp;
  }
#line 146
  if (! *values) {
    outMem: 
    {
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory while parsing option `%s\'\n",
            Program, *(argv + i));
#line 151
    exit(1);
    }
  }
#line 154
  used = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (cmax == -1) {
#line 154
      goto _L;
    } else
#line 154
    if (used < cmax) {
      _L: /* CIL Label */ 
#line 154
      if (! ((used + i) + 1 < argc)) {
#line 154
        goto while_break;
      }
    } else {
#line 154
      goto while_break;
    }
#line 155
    if (used == alloced) {
      {
#line 156
      alloced += 8;
#line 157
      tmp___0 = realloc((void *)*values, (unsigned long )alloced * sizeof(int ));
#line 157
      *values = (int *)tmp___0;
      }
#line 158
      if (! *values) {
#line 158
        goto outMem;
      }
    }
    {
#line 161
    tmp___1 = __errno_location();
#line 161
    *tmp___1 = 0;
#line 162
    v = strtol((char const   */* __restrict  */)*(argv + ((used + i) + 1)), (char **/* __restrict  */)(& end),
               0);
    }
#line 165
    if ((unsigned long )end == (unsigned long )*(argv + ((used + i) + 1))) {
#line 165
      goto while_break;
    }
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )*end) & 8192)) {
#line 168
        goto while_break___0;
      }
#line 168
      end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 169
    if (*end) {
#line 169
      goto while_break;
    }
    {
#line 172
    tmp___3 = __errno_location();
    }
#line 172
    if (*tmp___3 == 34) {
      {
#line 173
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to large to represent\n",
              Program, *(argv + ((i + used) + 1)), *(argv + i));
#line 176
      exit(1);
      }
    } else
#line 172
    if (v > 2147483647L) {
      {
#line 173
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to large to represent\n",
              Program, *(argv + ((i + used) + 1)), *(argv + i));
#line 176
      exit(1);
      }
    } else
#line 172
    if (v < (-0x7FFFFFFF-1)) {
      {
#line 173
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to large to represent\n",
              Program, *(argv + ((i + used) + 1)), *(argv + i));
#line 176
      exit(1);
      }
    }
#line 179
    *(*values + used) = (int )v;
#line 154
    used ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if (used < cmin) {
    {
#line 184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of `%s\' should be an integer value\n",
            Program, *(argv + ((i + used) + 1)), *(argv + i));
#line 188
    exit(1);
    }
  }
#line 191
  return (i + used);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getLongOpt(int argc , char **argv , int i , long *value , int force ) 
{ 
  char *end ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;

  {
#line 200
  i ++;
#line 200
  if (i >= argc) {
#line 200
    goto nothingFound;
  }
  {
#line 202
  tmp = __errno_location();
#line 202
  *tmp = 0;
#line 203
  *value = strtol((char const   */* __restrict  */)*(argv + i), (char **/* __restrict  */)(& end),
                  0);
  }
#line 206
  if ((unsigned long )end == (unsigned long )*(argv + i)) {
#line 206
    goto nothingFound;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    tmp___0 = __ctype_b_loc();
    }
#line 209
    if (! ((int const   )*(*tmp___0 + (int )*end) & 8192)) {
#line 209
      goto while_break;
    }
#line 209
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (*end) {
#line 210
    goto nothingFound;
  }
  {
#line 213
  tmp___1 = __errno_location();
  }
#line 213
  if (*tmp___1 == 34) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to large to represent\n",
            Program, *(argv + i), *(argv + (i - 1)));
#line 217
    exit(1);
    }
  }
#line 219
  return (i);
  nothingFound: 
#line 223
  if (! force) {
#line 223
    return (i - 1);
  }
  {
#line 225
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: missing or malformed value after option `%s\'\n",
          Program, *(argv + (i - 1)));
#line 228
  exit(1);
  }
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getLongOpts(int argc , char **argv , int i , long **values , int cmin , int cmax ) 
{ 
  int alloced ;
  int used ;
  char *end ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int *tmp___3 ;

  {
#line 244
  if (i + cmin >= argc) {
    {
#line 245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' wants at least %d parameters\n",
            Program, *(argv + i), cmin);
#line 248
    exit(1);
    }
  }
  {
#line 255
  alloced = cmin + 4;
#line 256
  tmp = calloc((size_t )alloced, sizeof(long ));
#line 256
  *values = (long *)tmp;
  }
#line 257
  if (! *values) {
    outMem: 
    {
#line 259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory while parsing option `%s\'\n",
            Program, *(argv + i));
#line 262
    exit(1);
    }
  }
#line 265
  used = 0;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (cmax == -1) {
#line 265
      goto _L;
    } else
#line 265
    if (used < cmax) {
      _L: /* CIL Label */ 
#line 265
      if (! ((used + i) + 1 < argc)) {
#line 265
        goto while_break;
      }
    } else {
#line 265
      goto while_break;
    }
#line 266
    if (used == alloced) {
      {
#line 267
      alloced += 8;
#line 268
      tmp___0 = realloc((void *)*values, (unsigned long )alloced * sizeof(long ));
#line 268
      *values = (long *)tmp___0;
      }
#line 269
      if (! *values) {
#line 269
        goto outMem;
      }
    }
    {
#line 272
    tmp___1 = __errno_location();
#line 272
    *tmp___1 = 0;
#line 273
    *(*values + used) = strtol((char const   */* __restrict  */)*(argv + ((used + i) + 1)),
                               (char **/* __restrict  */)(& end), 0);
    }
#line 276
    if ((unsigned long )end == (unsigned long )*(argv + ((used + i) + 1))) {
#line 276
      goto while_break;
    }
    {
#line 279
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 279
      tmp___2 = __ctype_b_loc();
      }
#line 279
      if (! ((int const   )*(*tmp___2 + (int )*end) & 8192)) {
#line 279
        goto while_break___0;
      }
#line 279
      end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    if (*end) {
#line 280
      goto while_break;
    }
    {
#line 283
    tmp___3 = __errno_location();
    }
#line 283
    if (*tmp___3 == 34) {
      {
#line 284
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to large to represent\n",
              Program, *(argv + ((i + used) + 1)), *(argv + i));
#line 287
      exit(1);
      }
    }
#line 265
    used ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  if (used < cmin) {
    {
#line 293
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of `%s\' should be an integer value\n",
            Program, *(argv + ((i + used) + 1)), *(argv + i));
#line 297
    exit(1);
    }
  }
#line 300
  return (i + used);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getFloatOpt(int argc , char **argv , int i , float *value , int force ) 
{ 
  char *end ;
  double v ;
  int *tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 310
  i ++;
#line 310
  if (i >= argc) {
#line 310
    goto nothingFound;
  }
  {
#line 312
  tmp = __errno_location();
#line 312
  *tmp = 0;
#line 313
  v = strtod((char const   */* __restrict  */)*(argv + i), (char **/* __restrict  */)(& end));
  }
#line 316
  if ((unsigned long )end == (unsigned long )*(argv + i)) {
#line 316
    goto nothingFound;
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 319
    tmp___0 = __ctype_b_loc();
    }
#line 319
    if (! ((int const   )*(*tmp___0 + (int )*end) & 8192)) {
#line 319
      goto while_break;
    }
#line 319
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  if (*end) {
#line 320
    goto nothingFound;
  }
  {
#line 323
  checkFloatConversion(v, *(argv + (i - 1)), *(argv + i));
#line 325
  *value = (float )v;
  }
#line 327
  return (i);
  nothingFound: 
#line 330
  if (! force) {
#line 330
    return (i - 1);
  }
  {
#line 332
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: missing or malformed float value after option `%s\'\n",
          Program, *(argv + (i - 1)));
#line 335
  exit(1);
  }
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getFloatOpts(int argc , char **argv , int i , float **values , int cmin , int cmax ) 
{ 
  int alloced ;
  int used ;
  char *end ;
  double v ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 353
  if (i + cmin >= argc) {
    {
#line 354
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' wants at least %d parameters\n",
            Program, *(argv + i), cmin);
#line 357
    exit(1);
    }
  }
  {
#line 363
  alloced = cmin + 4;
#line 364
  tmp = calloc((size_t )alloced, sizeof(float ));
#line 364
  *values = (float *)tmp;
  }
#line 365
  if (! *values) {
    outMem: 
    {
#line 367
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory while parsing option `%s\'\n",
            Program, *(argv + i));
#line 370
    exit(1);
    }
  }
#line 373
  used = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (cmax == -1) {
#line 373
      goto _L;
    } else
#line 373
    if (used < cmax) {
      _L: /* CIL Label */ 
#line 373
      if (! ((used + i) + 1 < argc)) {
#line 373
        goto while_break;
      }
    } else {
#line 373
      goto while_break;
    }
#line 374
    if (used == alloced) {
      {
#line 375
      alloced += 8;
#line 376
      tmp___0 = realloc((void *)*values, (unsigned long )alloced * sizeof(float ));
#line 376
      *values = (float *)tmp___0;
      }
#line 377
      if (! *values) {
#line 377
        goto outMem;
      }
    }
    {
#line 380
    tmp___1 = __errno_location();
#line 380
    *tmp___1 = 0;
#line 381
    v = strtod((char const   */* __restrict  */)*(argv + ((used + i) + 1)), (char **/* __restrict  */)(& end));
    }
#line 384
    if ((unsigned long )end == (unsigned long )*(argv + ((used + i) + 1))) {
#line 384
      goto while_break;
    }
    {
#line 387
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 387
      tmp___2 = __ctype_b_loc();
      }
#line 387
      if (! ((int const   )*(*tmp___2 + (int )*end) & 8192)) {
#line 387
        goto while_break___0;
      }
#line 387
      end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 388
    if (*end) {
#line 388
      goto while_break;
    }
    {
#line 391
    checkFloatConversion(v, *(argv + i), *(argv + ((i + used) + 1)));
#line 393
    *(*values + used) = (float )v;
#line 373
    used ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  if (used < cmin) {
    {
#line 397
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of `%s\' should be a floating-point value\n",
            Program, *(argv + ((i + used) + 1)), *(argv + i));
#line 401
    exit(1);
    }
  }
#line 404
  return (i + used);
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getDoubleOpt(int argc , char **argv , int i , double *value , int force ) 
{ 
  char *end ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;

  {
#line 413
  i ++;
#line 413
  if (i >= argc) {
#line 413
    goto nothingFound;
  }
  {
#line 415
  tmp = __errno_location();
#line 415
  *tmp = 0;
#line 416
  *value = strtod((char const   */* __restrict  */)*(argv + i), (char **/* __restrict  */)(& end));
  }
#line 419
  if ((unsigned long )end == (unsigned long )*(argv + i)) {
#line 419
    goto nothingFound;
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 422
    tmp___0 = __ctype_b_loc();
    }
#line 422
    if (! ((int const   )*(*tmp___0 + (int )*end) & 8192)) {
#line 422
      goto while_break;
    }
#line 422
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  if (*end) {
#line 423
    goto nothingFound;
  }
  {
#line 426
  tmp___2 = __errno_location();
  }
#line 426
  if (*tmp___2 == 34) {
#line 427
    if (*value == 0.0) {
#line 427
      tmp___1 = "small";
    } else {
#line 427
      tmp___1 = "large";
    }
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to %s to represent\n",
            Program, *(argv + i), *(argv + (i - 1)), tmp___1);
#line 431
    exit(1);
    }
  }
#line 434
  return (i);
  nothingFound: 
#line 437
  if (! force) {
#line 437
    return (i - 1);
  }
  {
#line 439
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: missing or malformed value after option `%s\'\n",
          Program, *(argv + (i - 1)));
#line 442
  exit(1);
  }
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getDoubleOpts(int argc , char **argv , int i , double **values , int cmin , int cmax ) 
{ 
  int alloced ;
  int used ;
  char *end ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;

  {
#line 459
  if (i + cmin >= argc) {
    {
#line 460
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' wants at least %d parameters\n",
            Program, *(argv + i), cmin);
#line 463
    exit(1);
    }
  }
  {
#line 469
  alloced = cmin + 4;
#line 470
  tmp = calloc((size_t )alloced, sizeof(double ));
#line 470
  *values = (double *)tmp;
  }
#line 471
  if (! *values) {
    outMem: 
    {
#line 473
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory while parsing option `%s\'\n",
            Program, *(argv + i));
#line 476
    exit(1);
    }
  }
#line 479
  used = 0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (cmax == -1) {
#line 479
      goto _L;
    } else
#line 479
    if (used < cmax) {
      _L: /* CIL Label */ 
#line 479
      if (! ((used + i) + 1 < argc)) {
#line 479
        goto while_break;
      }
    } else {
#line 479
      goto while_break;
    }
#line 480
    if (used == alloced) {
      {
#line 481
      alloced += 8;
#line 482
      tmp___0 = realloc((void *)*values, (unsigned long )alloced * sizeof(double ));
#line 482
      *values = (double *)tmp___0;
      }
#line 483
      if (! *values) {
#line 483
        goto outMem;
      }
    }
    {
#line 486
    tmp___1 = __errno_location();
#line 486
    *tmp___1 = 0;
#line 487
    *(*values + used) = strtod((char const   */* __restrict  */)*(argv + ((used + i) + 1)),
                               (char **/* __restrict  */)(& end));
    }
#line 490
    if ((unsigned long )end == (unsigned long )*(argv + ((used + i) + 1))) {
#line 490
      goto while_break;
    }
    {
#line 493
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 493
      tmp___2 = __ctype_b_loc();
      }
#line 493
      if (! ((int const   )*(*tmp___2 + (int )*end) & 8192)) {
#line 493
        goto while_break___0;
      }
#line 493
      end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 494
    if (*end) {
#line 494
      goto while_break;
    }
    {
#line 497
    tmp___4 = __errno_location();
    }
#line 497
    if (*tmp___4 == 34) {
#line 498
      if (*(*values + used) == 0.0) {
#line 498
        tmp___3 = "small";
      } else {
#line 498
        tmp___3 = "large";
      }
      {
#line 498
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of option `%s\' to %s to represent\n",
              Program, *(argv + ((i + used) + 1)), *(argv + i), tmp___3);
#line 502
      exit(1);
      }
    }
#line 479
    used ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  if (used < cmin) {
    {
#line 508
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter `%s\' of `%s\' should be a double value\n",
            Program, *(argv + ((i + used) + 1)), *(argv + i));
#line 512
    exit(1);
    }
  }
#line 515
  return (i + used);
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getStringOpt(int argc , char **argv , int i , char **value , int force ) 
{ 


  {
#line 525
  i ++;
#line 526
  if (i >= argc) {
#line 527
    if (force) {
      {
#line 528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: missing string after option `%s\'\n",
              Program, *(argv + (i - 1)));
#line 530
      exit(1);
      }
    }
#line 532
    return (i - 1);
  }
#line 535
  if (! force) {
#line 535
    if ((int )*(*(argv + i) + 0) == 45) {
#line 535
      return (i - 1);
    }
  }
#line 536
  *value = *(argv + i);
#line 537
  return (i);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
int getStringOpts(int argc , char **argv , int i , char ***values , int cmin , int cmax ) 
{ 
  int alloced ;
  int used ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 552
  if (i + cmin >= argc) {
    {
#line 553
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' wants at least %d parameters\n",
            Program, *(argv + i), cmin);
#line 556
    exit(1);
    }
  }
  {
#line 559
  alloced = cmin + 4;
#line 561
  tmp = calloc((size_t )alloced, sizeof(char *));
#line 561
  *values = (char **)tmp;
  }
#line 562
  if (! *values) {
    outMem: 
    {
#line 564
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory during parsing of option `%s\'\n",
            Program, *(argv + i));
#line 567
    exit(1);
    }
  }
#line 570
  used = 0;
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (cmax == -1) {
#line 570
      goto _L;
    } else
#line 570
    if (used < cmax) {
      _L: /* CIL Label */ 
#line 570
      if (! ((used + i) + 1 < argc)) {
#line 570
        goto while_break;
      }
    } else {
#line 570
      goto while_break;
    }
#line 571
    if (used == alloced) {
      {
#line 572
      alloced += 8;
#line 573
      tmp___0 = realloc((void *)*values, (unsigned long )alloced * sizeof(char *));
#line 573
      *values = (char **)tmp___0;
      }
#line 574
      if (! *values) {
#line 574
        goto outMem;
      }
    }
#line 577
    if (used >= cmin) {
#line 577
      if ((int )*(*(argv + ((used + i) + 1)) + 0) == 45) {
#line 577
        goto while_break;
      }
    }
#line 578
    *(*values + used) = *(argv + ((used + i) + 1));
#line 570
    used ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  if (used < cmin) {
    {
#line 582
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: less than %d parameters for option `%s\', only %d found\n",
            Program, cmin, *(argv + i), used);
#line 585
    exit(1);
    }
  }
#line 588
  return (i + used);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
void checkIntLower(char *opt , int *values , int count , int max ) 
{ 
  int i ;

  {
#line 597
  i = 0;
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 597
    if (! (i < count)) {
#line 597
      goto while_break;
    }
#line 598
    if (*(values + i) <= max) {
#line 598
      goto __Cont;
    }
    {
#line 599
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter %d of option `%s\' greater than max=%d\n",
            Program, i + 1, opt, max);
#line 602
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 597
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
void checkIntHigher(char *opt , int *values , int count , int min ) 
{ 
  int i ;

  {
#line 612
  i = 0;
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 612
    if (! (i < count)) {
#line 612
      goto while_break;
    }
#line 613
    if (*(values + i) >= min) {
#line 613
      goto __Cont;
    }
    {
#line 614
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter %d of option `%s\' smaller than min=%d\n",
            Program, i + 1, opt, min);
#line 617
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 612
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return;
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
void checkLongLower(char *opt , long *values , int count , long max ) 
{ 
  int i ;

  {
#line 627
  i = 0;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (i < count)) {
#line 627
      goto while_break;
    }
#line 628
    if (*(values + i) <= max) {
#line 628
      goto __Cont;
    }
    {
#line 629
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter %d of option `%s\' greater than max=%ld\n",
            Program, i + 1, opt, max);
#line 632
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 627
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  return;
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
void checkLongHigher(char *opt , long *values , int count , long min ) 
{ 
  int i ;

  {
#line 642
  i = 0;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (! (i < count)) {
#line 642
      goto while_break;
    }
#line 643
    if (*(values + i) >= min) {
#line 643
      goto __Cont;
    }
    {
#line 644
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter %d of option `%s\' smaller than min=%ld\n",
            Program, i + 1, opt, min);
#line 647
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 642
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  return;
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
void checkFloatLower(char *opt , float *values , int count , float max ) 
{ 
  int i ;

  {
#line 657
  i = 0;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! (i < count)) {
#line 657
      goto while_break;
    }
#line 658
    if (*(values + i) <= max) {
#line 658
      goto __Cont;
    }
    {
#line 659
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter %d of option `%s\' greater than max=%f\n",
            Program, i + 1, opt, (double )max);
#line 662
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 657
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  return;
}
}
#line 667 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
void checkFloatHigher(char *opt , float *values , int count , float min ) 
{ 
  int i ;

  {
#line 672
  i = 0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! (i < count)) {
#line 672
      goto while_break;
    }
#line 673
    if (*(values + i) >= min) {
#line 673
      goto __Cont;
    }
    {
#line 674
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter %d of option `%s\' smaller than min=%f\n",
            Program, i + 1, opt, (double )min);
#line 677
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 672
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
void checkDoubleLower(char *opt , double *values , int count , double max ) 
{ 
  int i ;

  {
#line 687
  i = 0;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! (i < count)) {
#line 687
      goto while_break;
    }
#line 688
    if (*(values + i) <= max) {
#line 688
      goto __Cont;
    }
    {
#line 689
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter %d of option `%s\' greater than max=%f\n",
            Program, i + 1, opt, max);
#line 692
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 687
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  return;
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
void checkDoubleHigher(char *opt , double *values , int count , double min ) 
{ 
  int i ;

  {
#line 702
  i = 0;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    if (! (i < count)) {
#line 702
      goto while_break;
    }
#line 703
    if (*(values + i) >= min) {
#line 703
      goto __Cont;
    }
    {
#line 704
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: parameter %d of option `%s\' smaller than min=%f\n",
            Program, i + 1, opt, min);
#line 707
    exit(1);
    }
    __Cont: /* CIL Label */ 
#line 702
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
void usage(void) 
{ 


  {
  {
#line 715
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "   [-b bsize] [-vt] [-vr] [-vw] [-ngr] [-s speed]\n");
#line 716
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "      copy stdin to stdout while counting bytes and reporting progress\n");
#line 717
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "      -b: buffer size in kB\n");
#line 718
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "          1 int value between 1 and oo\n");
#line 719
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "          default: `128\'\n");
#line 720
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "     -vt: show throughput\n");
#line 721
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "     -vr: show read-times\n");
#line 722
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "     -vw: show write-times\n");
#line 723
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "    -ngr: non-greedy read. Don\'t enforce a full buffer\n");
#line 724
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "          on read before starting to write\n");
#line 725
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "      -s: throughput speed limit in kB/s\n");
#line 726
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "          1 double value between 1 and oo\n");
#line 727
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "  version: 3.0.1\n");
#line 728
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "  ");
#line 729
  exit(1);
  }
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/cpipe-3.0.1/cmdline.c"
Cmdline *parseCmdline(int argc , char **argv ) 
{ 
  int i ;
  int keep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int keep___0 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 737
  Program = *(argv + 0);
#line 738
  i = 1;
#line 738
  cmd.argc = 1;
  {
#line 738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 738
    if (! (i < argc)) {
#line 738
      goto while_break;
    }
    {
#line 739
    tmp = strcmp("-b", (char const   *)*(argv + i));
    }
#line 739
    if (0 == tmp) {
      {
#line 740
      keep = i;
#line 741
      cmd.bsizeP = (char)1;
#line 742
      i = getIntOpt(argc, argv, i, & cmd.bsize, 1);
#line 743
      cmd.bsizeC = i - keep;
#line 744
      checkIntHigher((char *)"-b", & cmd.bsize, cmd.bsizeC, 1);
      }
#line 745
      goto __Cont;
    }
    {
#line 748
    tmp___0 = strcmp("-vt", (char const   *)*(argv + i));
    }
#line 748
    if (0 == tmp___0) {
#line 749
      cmd.vtP = (char)1;
#line 750
      goto __Cont;
    }
    {
#line 753
    tmp___1 = strcmp("-vr", (char const   *)*(argv + i));
    }
#line 753
    if (0 == tmp___1) {
#line 754
      cmd.vrP = (char)1;
#line 755
      goto __Cont;
    }
    {
#line 758
    tmp___2 = strcmp("-vw", (char const   *)*(argv + i));
    }
#line 758
    if (0 == tmp___2) {
#line 759
      cmd.vwP = (char)1;
#line 760
      goto __Cont;
    }
    {
#line 763
    tmp___3 = strcmp("-ngr", (char const   *)*(argv + i));
    }
#line 763
    if (0 == tmp___3) {
#line 764
      cmd.ngrP = (char)1;
#line 765
      goto __Cont;
    }
    {
#line 768
    tmp___4 = strcmp("-s", (char const   *)*(argv + i));
    }
#line 768
    if (0 == tmp___4) {
      {
#line 769
      keep___0 = i;
#line 770
      cmd.speedP = (char)1;
#line 771
      i = getDoubleOpt(argc, argv, i, & cmd.speed, 1);
#line 772
      cmd.speedC = i - keep___0;
#line 773
      checkDoubleHigher((char *)"-s", & cmd.speed, cmd.speedC, (double )1);
      }
#line 774
      goto __Cont;
    }
#line 777
    if ((int )*(*(argv + i) + 0) == 45) {
      {
#line 778
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: unknown option `%s\'\n\n",
              Program, *(argv + i));
#line 780
      usage();
      }
    }
#line 782
    tmp___5 = cmd.argc;
#line 782
    (cmd.argc) ++;
#line 782
    *(argv + tmp___5) = *(argv + i);
    __Cont: /* CIL Label */ 
#line 738
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  cmd.argv = argv + 1;
#line 789
  (cmd.argc) --;
#line 791
  if (cmd.argc > 0) {
    {
#line 792
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: There are %d arguments not associated with any option\n",
            Program, cmd.argc);
#line 794
    exit(1);
    }
  }
#line 796
  return (& cmd);
}
}
