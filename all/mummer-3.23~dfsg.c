/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 40 "../libbasedir/types.h"
typedef unsigned char Uchar;
#line 57 "../libbasedir/types.h"
typedef unsigned int Uint;
#line 17 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/symboldef.h"
typedef Uchar SYMBOL;
#line 35 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
typedef Uint *Bref;
#line 81 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
struct Suffixtreetype {
   Uint textlen ;
   Uint *leaftab ;
   Uint *branchtab ;
   Uint *rootchildren ;
   SYMBOL *text ;
   SYMBOL *sentinel ;
   Uint nextfreeleafnum ;
   Uint headnodedepth ;
   Uint insertnode ;
   Uint insertprev ;
   Uint smallnotcompleted ;
   Uint nextfreebranchnum ;
   Uint onsuccpath ;
   Uint currentdepth ;
   Uint branchnodeoffset ;
   Uint alphasize ;
   Uint maxbranchdepth ;
   Uint largenode ;
   Uint smallnode ;
   Uint *setlink ;
   Uint *nextfreeleafptr ;
   Uint *chainstart ;
   Uint *nextfreebranch ;
   Uint *headnode ;
   Uint currentbranchtabsize ;
   Uint *firstnotallocated ;
   Uint *nonmaximal ;
   Uint *leafcounts ;
   unsigned char setatnewleaf ;
   SYMBOL *headstart ;
   SYMBOL *headend ;
   SYMBOL *tailptr ;
};
#line 147 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
typedef struct Suffixtreetype Suffixtree;
#line 58 "../libbasedir/types.h"
typedef int Sint;
#line 259 "../libbasedir/types.h"
struct __anonstruct_Listtype_29 {
   Uint start ;
   Uint length ;
};
#line 259 "../libbasedir/types.h"
typedef struct __anonstruct_Listtype_29 Listtype;
#line 268 "../libbasedir/types.h"
typedef Listtype Stringtype;
#line 23 "../streesrc/streetyp.h"
struct __anonstruct_Reference_39 {
   unsigned char toleaf ;
   Uint *address ;
};
#line 23 "../streesrc/streetyp.h"
typedef struct __anonstruct_Reference_39 Reference;
#line 157 "../streesrc/streetyp.h"
struct __anonstruct_Location_42 {
   Stringtype locstring ;
   Bref previousnode ;
   SYMBOL *firstptr ;
   Uint edgelen ;
   Uint remain ;
   Reference nextnode ;
};
#line 157 "../streesrc/streetyp.h"
typedef struct __anonstruct_Location_42 Location;
#line 208 "../streesrc/streetyp.h"
struct __anonstruct_Pathinfo_45 {
   Uint depth ;
   Uint headposition ;
   Bref ref ;
};
#line 208 "../streesrc/streetyp.h"
typedef struct __anonstruct_Pathinfo_45 Pathinfo;
#line 214 "../streesrc/streetyp.h"
struct __anonstruct_ArrayPathinfo_46 {
   Pathinfo *spacePathinfo ;
   Uint allocatedPathinfo ;
   Uint nextfreePathinfo ;
};
#line 214 "../streesrc/streetyp.h"
typedef struct __anonstruct_ArrayPathinfo_46 ArrayPathinfo;
#line 63 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
struct __anonstruct_Nodeinfo_52 {
   Uint querycommondepth ;
   unsigned char onmaxpath ;
};
#line 63 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
typedef struct __anonstruct_Nodeinfo_52 Nodeinfo;
#line 74 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
struct __anonstruct_ArrayNodeinfo_53 {
   Nodeinfo *spaceNodeinfo ;
   Uint allocatedNodeinfo ;
   Uint nextfreeNodeinfo ;
};
#line 74 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
typedef struct __anonstruct_ArrayNodeinfo_53 ArrayNodeinfo;
#line 81 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
struct __anonstruct_Maxmatchinfo_54 {
   Suffixtree *stree ;
   ArrayNodeinfo commondepthstack ;
   ArrayPathinfo matchpath ;
   Location maxloc ;
   Uchar *query ;
   Uchar *querysuffix ;
   Uint querylen ;
   Uint queryseqnum ;
   Uint minmatchlength ;
   Uint depthofpreviousmaxloc ;
   Sint (*processmatch)(void * , Uint  , Uint  , Uint  , Uint  ) ;
   void *processinfo ;
};
#line 81 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
typedef struct __anonstruct_Maxmatchinfo_54 Maxmatchinfo;
#line 68 "../libbasedir/types.h"
typedef unsigned long Showuint;
#line 80 "../libbasedir/types.h"
typedef long Scaninteger;
#line 134 "../libbasedir/types.h"
typedef int Argctype;
#line 138 "../libbasedir/optdesc.h"
struct __anonstruct_OptionDescription_30 {
   char *optname ;
   char *description ;
   Uint optval ;
   unsigned char isalreadyset ;
   unsigned char declared ;
};
#line 138 "../libbasedir/optdesc.h"
typedef struct __anonstruct_OptionDescription_30 OptionDescription;
#line 45 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatdef.h"
struct __anonstruct_MMcallinfo_44 {
   unsigned char showstring ;
   unsigned char reversecomplement ;
   unsigned char forward ;
   unsigned char fourcolumn ;
   unsigned char showreversepositions ;
   unsigned char showsequencelengths ;
   unsigned char matchnucleotidesonly ;
   unsigned char cmaxmatch ;
   unsigned char cmumcand ;
   unsigned char cmum ;
   Uint minmatchlength ;
   Uint numofqueryfiles ;
   char program[4097] ;
   char subjectfile[4097] ;
   char queryfilelist[32][4097] ;
};
#line 45 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatdef.h"
typedef struct __anonstruct_MMcallinfo_44 MMcallinfo;
#line 128 "../libbasedir/arraydef.h"
struct __anonstruct_ArrayUint_33 {
   Uint *spaceUint ;
   Uint allocatedUint ;
   Uint nextfreeUint ;
};
#line 128 "../libbasedir/arraydef.h"
typedef struct __anonstruct_ArrayUint_33 ArrayUint;
#line 149 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
struct __anonstruct_ArrayBref_40 {
   Bref *spaceBref ;
   Uint allocatedBref ;
   Uint nextfreeBref ;
};
#line 149 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
typedef struct __anonstruct_ArrayBref_40 ArrayBref;
#line 86 "../libbasedir/types.h"
typedef int Ctypeargumenttype;
#line 98 "../libbasedir/types.h"
typedef int Fputcfirstargtype;
#line 237 "../libbasedir/types.h"
struct __anonstruct_PairUint_26 {
   Uint uint0 ;
   Uint uint1 ;
};
#line 237 "../libbasedir/types.h"
typedef struct __anonstruct_PairUint_26 PairUint;
#line 125 "../libbasedir/arraydef.h"
struct __anonstruct_ArrayUchar_32 {
   Uchar *spaceUchar ;
   Uint allocatedUchar ;
   Uint nextfreeUchar ;
};
#line 125 "../libbasedir/arraydef.h"
typedef struct __anonstruct_ArrayUchar_32 ArrayUchar;
#line 137 "../libbasedir/arraydef.h"
typedef ArrayUint ArrayPosition;
#line 138 "../libbasedir/arraydef.h"
typedef ArrayUchar ArrayCharacters;
#line 87 "../libbasedir/multidef.h"
struct __anonstruct_Multiseq_40 {
   ArrayPosition markpos ;
   Uint *startdesc ;
   Uint numofsequences ;
   Uint totallength ;
   ArrayCharacters descspace ;
   Uchar *sequence ;
   Uchar *rcsequence ;
   Uchar *originalsequence ;
};
#line 87 "../libbasedir/multidef.h"
typedef struct __anonstruct_Multiseq_40 Multiseq;
#line 24 "../libbasedir/mumcand.h"
struct __anonstruct_MUMcandidate_43 {
   Uint mumlength ;
   Uint dbstart ;
   Uint queryseq ;
   Uint querystart ;
};
#line 24 "../libbasedir/mumcand.h"
typedef struct __anonstruct_MUMcandidate_43 MUMcandidate;
#line 37 "../libbasedir/mumcand.h"
struct __anonstruct_ArrayMUMcandidate_44 {
   MUMcandidate *spaceMUMcandidate ;
   Uint allocatedMUMcandidate ;
   Uint nextfreeMUMcandidate ;
};
#line 37 "../libbasedir/mumcand.h"
typedef struct __anonstruct_ArrayMUMcandidate_44 ArrayMUMcandidate;
#line 36 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
struct __anonstruct_Matchprocessinfo_55 {
   Suffixtree stree ;
   Multiseq *subjectmultiseq ;
   Multiseq querymultiseq ;
   ArrayMUMcandidate mumcandtab ;
   Uint minmatchlength ;
   Uint maxdesclength ;
   Uint currentquerylen ;
   unsigned char showstring ;
   unsigned char showsequencelengths ;
   unsigned char showreversepositions ;
   unsigned char forward ;
   unsigned char fourcolumn ;
   unsigned char reversecomplement ;
   unsigned char cmumcand ;
   unsigned char cmum ;
   unsigned char currentisrcmatch ;
};
#line 36 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
typedef struct __anonstruct_Matchprocessinfo_55 Matchprocessinfo;
#line 36 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
typedef Uint *Lref;
#line 216 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
struct __anonstruct_DFSstate_46 {
   unsigned char secondtime ;
   ArrayBref stack ;
};
#line 216 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
typedef struct __anonstruct_DFSstate_46 DFSstate;
#line 43 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
struct __anonstruct_Branchinfo_39 {
   Uint headposition ;
   Uint depth ;
   Bref suffixlink ;
   Reference firstchild ;
   Reference branchbrother ;
};
#line 43 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
typedef struct __anonstruct_Branchinfo_39 Branchinfo;
#line 59 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
typedef Reference Leafinfo;
#line 195 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
struct __anonstruct_Simpleloc_42 {
   Uint remain ;
   Uint textpos ;
   Reference nextnode ;
};
#line 195 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
typedef struct __anonstruct_Simpleloc_42 Simpleloc;
#line 202 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
struct __anonstruct_ArraySimpleloc_43 {
   Simpleloc *spaceSimpleloc ;
   Uint allocatedSimpleloc ;
   Uint nextfreeSimpleloc ;
};
#line 202 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streetyp.h"
typedef struct __anonstruct_ArraySimpleloc_43 ArraySimpleloc;
#line 16 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c"
struct __anonstruct_Countstate_53 {
   Suffixtree *stree ;
   ArrayUint countstack ;
};
#line 16 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c"
typedef struct __anonstruct_Countstate_53 Countstate;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 86 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
void oversuccsstree(Suffixtree *stree , Bref bnode , void (*processleaf___1)(Suffixtree * ,
                                                                             Uint  ,
                                                                             void * ) ,
                    void (*processbranch)(Suffixtree * , Bref  , void * ) , void *info ) ;
#line 31 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/oversucc.c"
void oversuccsstree(Suffixtree *stree , Bref bnode , void (*processleaf___1)(Suffixtree * ,
                                                                             Uint  ,
                                                                             void * ) ,
                    void (*processbranch)(Suffixtree * , Bref  , void * ) , void *info ) 
{ 
  Uint leafindex ;
  Uint node ;
  Uint *btptr ;

  {
#line 38
  node = *bnode & ((1U << ((1U << 5) - 1U)) - 1U);
#line 39
  if ((unsigned long )processleaf___1 != (unsigned long )((void *)0)) {
#line 41
    if ((unsigned long )processbranch != (unsigned long )((void *)0)) {
      {
#line 43
      while (1) {
        while_continue: /* CIL Label */ ;
#line 43
        if (! (! (node & (1U << ((1U << 5) - 1U))))) {
#line 43
          goto while_break;
        }
#line 43
        if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
          {
#line 43
          leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 43
          (*processleaf___1)(stree, leafindex, info);
#line 43
          node = *(stree->leaftab + leafindex);
          }
        } else {
          {
#line 43
          btptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 43
          (*processbranch)(stree, btptr, info);
#line 43
          node = *(btptr + 1);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 46
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 46
        if (! (! (node & (1U << ((1U << 5) - 1U))))) {
#line 46
          goto while_break___0;
        }
#line 46
        if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
          {
#line 46
          leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 46
          (*processleaf___1)(stree, leafindex, info);
#line 46
          node = *(stree->leaftab + leafindex);
          }
        } else {
#line 46
          btptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 46
          node = *(btptr + 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 50
  if ((unsigned long )processbranch != (unsigned long )((void *)0)) {
    {
#line 52
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 52
      if (! (! (node & (1U << ((1U << 5) - 1U))))) {
#line 52
        goto while_break___1;
      }
#line 52
      if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 52
        leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 52
        node = *(stree->leaftab + leafindex);
      } else {
        {
#line 52
        btptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 52
        (*processbranch)(stree, btptr, info);
#line 52
        node = *(btptr + 1);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"processleaf and processbranch are both undefined\n");
#line 56
    exit(1);
    }
  }
#line 59
  return;
}
}
#line 20 "../libbasedir/spacedef.h"
extern void *allocandusespaceviaptr(char *file , Uint line , void *ptr , Uint size ,
                                    Uint number ) ;
#line 24
extern void freespaceviaptr(char *file , Uint line , void *ptr ) ;
#line 48 "../streesrc/streeproto.h"
SYMBOL *scanprefixfromnodestree(Suffixtree *stree , Location *loc , Bref btptr , SYMBOL *left ,
                                SYMBOL *right , Uint rescanlength ) ;
#line 51
SYMBOL *scanprefixstree(Suffixtree *stree , Location *outloc , Location *inloc , SYMBOL *left ,
                        SYMBOL *right , Uint rescanlength ) ;
#line 61
SYMBOL *findprefixpathstree(Suffixtree *stree , ArrayPathinfo *path , Location *outloc ,
                            Location *inloc , SYMBOL *left , SYMBOL *right , Uint rescanlength ) ;
#line 70
void linklocstree(Suffixtree *stree , Location *outloc , Location *inloc ) ;
#line 74
Sint depthfirststree(Suffixtree *stree , Reference *startnode , Sint (*processleaf___1)(Uint  ,
                                                                                        Bref  ,
                                                                                        void * ) ,
                     unsigned char (*processbranch1___1)(Bref  , void * ) , Sint (*processbranch2___1)(Bref  ,
                                                                                                       void * ) ,
                     unsigned char (*stoptraversal)(void * ) , void *stopinfo , void *info ) ;
#line 203 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
static Sint processleaf(Uint leafindex , Bref lcpnode , void *info ) 
{ 
  Maxmatchinfo *maxmatchinfo ;
  Uint lcplength ;
  Nodeinfo *father ;
  Sint tmp ;

  {
#line 205
  maxmatchinfo = (Maxmatchinfo *)info;
#line 208
  if (leafindex == 0U) {
#line 208
    goto _L;
  } else
#line 208
  if ((unsigned long )maxmatchinfo->query == (unsigned long )maxmatchinfo->querysuffix) {
#line 208
    goto _L;
  } else
#line 208
  if ((int )*((maxmatchinfo->stree)->text + (leafindex - 1U)) != (int )*(maxmatchinfo->querysuffix - 1)) {
    _L: /* CIL Label */ 
#line 215
    if (maxmatchinfo->commondepthstack.nextfreeNodeinfo == 0U) {
#line 218
      lcplength = maxmatchinfo->maxloc.locstring.length;
    } else {
#line 221
      father = (maxmatchinfo->commondepthstack.spaceNodeinfo + maxmatchinfo->commondepthstack.nextfreeNodeinfo) - 1;
#line 223
      if (father->onmaxpath) {
#line 223
        if ((Uint )(maxmatchinfo->maxloc.nextnode.address - (maxmatchinfo->stree)->leaftab) == leafindex) {
#line 227
          lcplength = maxmatchinfo->maxloc.locstring.length;
        } else {
#line 230
          lcplength = father->querycommondepth;
        }
      } else {
#line 230
        lcplength = father->querycommondepth;
      }
    }
    {
#line 233
    tmp = (*(maxmatchinfo->processmatch))(maxmatchinfo->processinfo, lcplength, leafindex,
                                          maxmatchinfo->queryseqnum, (Uint )(maxmatchinfo->querysuffix - maxmatchinfo->query));
    }
#line 233
    if (tmp != 0) {
#line 241
      return (-1);
    }
  }
#line 244
  return (0);
}
}
#line 252 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
static void inheritfrompath(ArrayPathinfo *matchpath , Location *maxloc , Nodeinfo *stacktop ,
                            Bref nodeptr , Uint accessindex , Uint inheritdepth ) 
{ 


  {
#line 259
  if (accessindex > matchpath->nextfreePathinfo) {
#line 261
    stacktop->onmaxpath = (unsigned char)0;
#line 262
    stacktop->querycommondepth = inheritdepth;
  } else
#line 265
  if (accessindex == matchpath->nextfreePathinfo) {
#line 267
    if (maxloc->remain == 0U) {
#line 269
      if ((unsigned long )maxloc->nextnode.address == (unsigned long )nodeptr) {
#line 271
        stacktop->onmaxpath = (unsigned char)1;
#line 272
        stacktop->querycommondepth = maxloc->locstring.length;
      } else {
#line 275
        stacktop->onmaxpath = (unsigned char)0;
#line 276
        stacktop->querycommondepth = inheritdepth;
      }
    } else {
#line 280
      stacktop->onmaxpath = (unsigned char)0;
#line 281
      if ((unsigned long )maxloc->nextnode.address == (unsigned long )nodeptr) {
#line 283
        stacktop->querycommondepth = maxloc->locstring.length;
      } else {
#line 286
        stacktop->querycommondepth = inheritdepth;
      }
    }
  } else
#line 291
  if ((unsigned long )(matchpath->spacePathinfo + accessindex)->ref == (unsigned long )nodeptr) {
#line 293
    stacktop->onmaxpath = (unsigned char)1;
#line 294
    stacktop->querycommondepth = (matchpath->spacePathinfo + accessindex)->depth;
  } else {
#line 298
    stacktop->onmaxpath = (unsigned char)0;
#line 299
    stacktop->querycommondepth = inheritdepth;
  }
#line 303
  return;
}
}
#line 320 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
static unsigned char processbranch1(Bref nodeptr , void *info ) 
{ 
  Maxmatchinfo *maxmatchinfo ;
  Nodeinfo *stacktop ;
  Nodeinfo *father ;
  void *tmp ;
  Uint tmp___0 ;

  {
#line 322
  maxmatchinfo = (Maxmatchinfo *)info;
#line 325
  if (maxmatchinfo->commondepthstack.nextfreeNodeinfo >= maxmatchinfo->commondepthstack.allocatedNodeinfo) {
    {
#line 325
    maxmatchinfo->commondepthstack.allocatedNodeinfo += 32U;
#line 325
    tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c",
                                 (Uint )325, (void *)maxmatchinfo->commondepthstack.spaceNodeinfo,
                                 (Uint )sizeof(Nodeinfo ), maxmatchinfo->commondepthstack.allocatedNodeinfo);
#line 325
    maxmatchinfo->commondepthstack.spaceNodeinfo = (Nodeinfo *)tmp;
    }
  }
#line 325
  tmp___0 = maxmatchinfo->commondepthstack.nextfreeNodeinfo;
#line 325
  (maxmatchinfo->commondepthstack.nextfreeNodeinfo) ++;
#line 325
  stacktop = maxmatchinfo->commondepthstack.spaceNodeinfo + tmp___0;
#line 328
  if ((unsigned long )stacktop == (unsigned long )maxmatchinfo->commondepthstack.spaceNodeinfo) {
    {
#line 330
    inheritfrompath(& maxmatchinfo->matchpath, & maxmatchinfo->maxloc, stacktop, nodeptr,
                    (Uint )0, maxmatchinfo->minmatchlength);
    }
  } else {
#line 338
    father = stacktop - 1;
#line 339
    if (father->onmaxpath) {
      {
#line 341
      inheritfrompath(& maxmatchinfo->matchpath, & maxmatchinfo->maxloc, stacktop,
                      nodeptr, maxmatchinfo->commondepthstack.nextfreeNodeinfo - 1U,
                      father->querycommondepth);
      }
    } else {
#line 349
      stacktop->onmaxpath = (unsigned char)0;
#line 350
      stacktop->querycommondepth = father->querycommondepth;
    }
  }
#line 356
  return ((unsigned char)1);
}
}
#line 368 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
static Sint processbranch2(Bref nodeptr , void *info ) 
{ 
  Maxmatchinfo *maxmatchinfo ;

  {
#line 370
  maxmatchinfo = (Maxmatchinfo *)info;
#line 372
  (maxmatchinfo->commondepthstack.nextfreeNodeinfo) --;
#line 373
  return (0);
}
}
#line 392 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
static Sint enumeratemaxmatches(Maxmatchinfo *maxmatchinfo , Location *ploc ) 
{ 
  Uint rescanprefixlength ;
  Sint tmp ;
  Sint tmp___0 ;

  {
#line 397
  maxmatchinfo->matchpath.nextfreePathinfo = (Uint )0;
#line 398
  if (maxmatchinfo->depthofpreviousmaxloc > 1U) {
#line 400
    rescanprefixlength = maxmatchinfo->depthofpreviousmaxloc - 1U;
  } else {
#line 403
    rescanprefixlength = (Uint )0;
  }
  {
#line 405
  findprefixpathstree(maxmatchinfo->stree, & maxmatchinfo->matchpath, & maxmatchinfo->maxloc,
                      ploc, maxmatchinfo->querysuffix + maxmatchinfo->minmatchlength,
                      (maxmatchinfo->query + maxmatchinfo->querylen) - 1, rescanprefixlength);
#line 414
  maxmatchinfo->depthofpreviousmaxloc = maxmatchinfo->maxloc.locstring.length;
#line 417
  maxmatchinfo->commondepthstack.nextfreeNodeinfo = (Uint )0;
  }
#line 418
  if (ploc->nextnode.toleaf) {
    {
#line 420
    tmp = processleaf((Uint )(ploc->nextnode.address - (maxmatchinfo->stree)->leaftab),
                      (Bref )((void *)0), (void *)maxmatchinfo);
    }
#line 420
    if (tmp != 0) {
#line 423
      return (-1);
    }
  } else {
    {
#line 427
    processbranch1(ploc->nextnode.address, (void *)maxmatchinfo);
#line 428
    tmp___0 = depthfirststree(maxmatchinfo->stree, & ploc->nextnode, & processleaf,
                              & processbranch1, & processbranch2, (unsigned char (*)(void * ))((void *)0),
                              (void *)0, (void *)maxmatchinfo);
    }
#line 428
    if (tmp___0 != 0) {
#line 437
      return (-2);
    }
  }
#line 440
  return (0);
}
}
#line 459 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c"
Sint findmaxmatches(Suffixtree *stree , Uint minmatchlength , Sint (*processmatch)(void * ,
                                                                                   Uint  ,
                                                                                   Uint  ,
                                                                                   Uint  ,
                                                                                   Uint  ) ,
                    void *processinfo , Uchar *query , Uint querylen , Uint queryseqnum ) 
{ 
  Uchar *querysubstringend ;
  Location ploc ;
  Maxmatchinfo maxmatchinfo ;
  Sint tmp ;
  int tmp___0 ;
  Sint tmp___1 ;
  int tmp___2 ;

  {
#line 476
  if (querylen < minmatchlength) {
#line 478
    return (0);
  }
  {
#line 480
  maxmatchinfo.stree = stree;
#line 481
  maxmatchinfo.commondepthstack.spaceNodeinfo = (Nodeinfo *)((void *)0);
#line 481
  maxmatchinfo.commondepthstack.nextfreeNodeinfo = (Uint )0;
#line 481
  maxmatchinfo.commondepthstack.allocatedNodeinfo = maxmatchinfo.commondepthstack.nextfreeNodeinfo;
#line 482
  maxmatchinfo.matchpath.spacePathinfo = (Pathinfo *)((void *)0);
#line 482
  maxmatchinfo.matchpath.nextfreePathinfo = (Uint )0;
#line 482
  maxmatchinfo.matchpath.allocatedPathinfo = maxmatchinfo.matchpath.nextfreePathinfo;
#line 483
  maxmatchinfo.query = query;
#line 483
  maxmatchinfo.querysuffix = maxmatchinfo.query;
#line 484
  maxmatchinfo.querylen = querylen;
#line 485
  maxmatchinfo.minmatchlength = minmatchlength;
#line 486
  maxmatchinfo.queryseqnum = queryseqnum;
#line 487
  maxmatchinfo.processmatch = processmatch;
#line 488
  maxmatchinfo.processinfo = processinfo;
#line 489
  querysubstringend = (query + minmatchlength) - 1;
#line 490
  scanprefixfromnodestree(stree, & ploc, stree->branchtab, query, querysubstringend,
                          (Uint )0);
#line 492
  maxmatchinfo.depthofpreviousmaxloc = ploc.locstring.length;
  }
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! ((unsigned long )querysubstringend < (unsigned long )((query + querylen) - 1))) {
#line 493
      goto while_break;
    }
#line 499
    if (ploc.locstring.length >= minmatchlength) {
      {
#line 499
      tmp = enumeratemaxmatches(& maxmatchinfo, & ploc);
      }
#line 499
      if (tmp != 0) {
#line 502
        return (-1);
      }
    }
#line 504
    if (ploc.locstring.length == 0U) {
#line 504
      tmp___0 = 1;
    } else {
#line 504
      tmp___0 = 0;
    }
#line 504
    if (tmp___0) {
      {
#line 506
      scanprefixfromnodestree(stree, & ploc, stree->branchtab, maxmatchinfo.querysuffix + 1,
                              querysubstringend + 1, (Uint )0);
      }
    } else {
      {
#line 512
      linklocstree(stree, & ploc, & ploc);
#line 513
      scanprefixstree(stree, & ploc, & ploc, (maxmatchinfo.querysuffix + ploc.locstring.length) + 1,
                      querysubstringend + 1, (Uint )0);
      }
    }
#line 493
    (maxmatchinfo.querysuffix) ++;
#line 493
    querysubstringend ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 521
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 521
    if (ploc.locstring.length == 0U) {
#line 521
      tmp___2 = 1;
    } else {
#line 521
      tmp___2 = 0;
    }
#line 521
    if (tmp___2) {
#line 521
      goto while_break___0;
    } else
#line 521
    if (! (ploc.locstring.length >= minmatchlength)) {
#line 521
      goto while_break___0;
    }
    {
#line 523
    tmp___1 = enumeratemaxmatches(& maxmatchinfo, & ploc);
    }
#line 523
    if (tmp___1 != 0) {
#line 525
      return (-2);
    }
    {
#line 527
    linklocstree(stree, & ploc, & ploc);
#line 528
    (maxmatchinfo.querysuffix) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 532
  if ((unsigned long )maxmatchinfo.commondepthstack.spaceNodeinfo != (unsigned long )((void *)0)) {
#line 532
    if ((unsigned long )maxmatchinfo.commondepthstack.spaceNodeinfo != (unsigned long )((void *)0)) {
      {
#line 532
      freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c",
                      (Uint )532, (void *)maxmatchinfo.commondepthstack.spaceNodeinfo);
#line 532
      maxmatchinfo.commondepthstack.spaceNodeinfo = (Nodeinfo *)((void *)0);
      }
    }
  }
#line 533
  if ((unsigned long )maxmatchinfo.matchpath.spacePathinfo != (unsigned long )((void *)0)) {
#line 533
    if ((unsigned long )maxmatchinfo.matchpath.spacePathinfo != (unsigned long )((void *)0)) {
      {
#line 533
      freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmaxmat.c",
                      (Uint )533, (void *)maxmatchinfo.matchpath.spacePathinfo);
#line 533
      maxmatchinfo.matchpath.spacePathinfo = (Pathinfo *)((void *)0);
      }
    }
  }
#line 534
  return (0);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 21 "../libbasedir/errordef.h"
extern char *messagespace(void) ;
#line 22
extern Sint maxerrormsg(void) ;
#line 52 "../libbasedir/protodef.h"
extern void initoptions(OptionDescription *options , Uint numofoptions ) ;
#line 53
extern Sint addoption(OptionDescription *options , Uint numofoptions , Uint optnum ,
                      char *optname , char *optdesc ) ;
#line 55
extern Sint procoption(OptionDescription *opt , Uint numofopt , char *optstring ) ;
#line 56
extern void showoptions(FILE *outfp , char *program , OptionDescription *opt , Uint numofopt ) ;
#line 65
extern Sint safestringcopy(char *dest , char *source , Sint maxlen ) ;
#line 67 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c"
static void makeleastlengthtext(char *spacefortext ) 
{ 


  {
  {
#line 69
  sprintf((char */* __restrict  */)spacefortext, (char const   */* __restrict  */)"set the minimum length of a match\nif not set, the default value is %lu",
          (Showuint )20);
  }
#line 72
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c"
static void showusage(char *program , OptionDescription *options , Uint numofoptions ) 
{ 


  {
  {
#line 82
  printf((char const   */* __restrict  */)"Usage: %s [options] <reference-file> <query-files>\n\nFind and output (to stdout) the positions and length of all\nsufficiently long maximal matches of a substring in\n<query-file> and <reference-file>\n\n",
         program);
#line 86
  printf((char const   */* __restrict  */)"Options:\n");
#line 87
  showoptions(stdout, program, options, numofoptions);
  }
#line 88
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c"
Sint parsemaxmatoptions(MMcallinfo *mmcallinfo , Argctype argc , char **argv ) 
{ 
  OptionDescription options[14] ;
  Sint optval ;
  Uint argnum ;
  Scaninteger readint ;
  char leastlengthtext[129] ;
  Sint tmp ;
  Sint tmp___0 ;
  Sint tmp___1 ;
  Sint tmp___2 ;
  Sint tmp___3 ;
  Sint tmp___4 ;
  Sint tmp___5 ;
  Sint tmp___6 ;
  Sint tmp___7 ;
  Sint tmp___8 ;
  Sint tmp___9 ;
  Sint tmp___10 ;
  Sint tmp___11 ;
  Sint tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  Sint tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  Sint tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  Sint tmp___22 ;
  Sint tmp___23 ;
  Sint tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  Sint tmp___27 ;
  Sint tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  Sint tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  Sint tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  Sint tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  Sint tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  Sint tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  Sint tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  Sint tmp___49 ;

  {
  {
#line 107
  initoptions(& options[0], (Uint )14);
#line 108
  tmp = addoption(& options[0], (Uint )14, (Uint )0, (char *)"-mum", (char *)"compute maximal matches that are unique in both sequences");
  }
#line 108
  if (tmp != 0) {
#line 108
    return (-1);
  }
  {
#line 110
  tmp___0 = addoption(& options[0], (Uint )14, (Uint )2, (char *)"-mumreference",
                      (char *)"compute maximal matches that are unique in the reference-\nsequence but not necessarily in the query-sequence (default)");
  }
#line 110
  if (tmp___0 != 0) {
#line 110
    return (-1);
  }
  {
#line 113
  tmp___1 = addoption(& options[0], (Uint )14, (Uint )1, (char *)"-mumcand", (char *)"same as -mumreference");
  }
#line 113
  if (tmp___1 != 0) {
#line 113
    return (-1);
  }
  {
#line 115
  tmp___2 = addoption(& options[0], (Uint )14, (Uint )3, (char *)"-maxmatch", (char *)"compute all maximal matches regardless of their uniqueness");
  }
#line 115
  if (tmp___2 != 0) {
#line 115
    return (-1);
  }
  {
#line 117
  tmp___3 = addoption(& options[0], (Uint )14, (Uint )4, (char *)"-n", (char *)"match only the characters a, c, g, or t\nthey can be in upper or in lower case");
  }
#line 117
  if (tmp___3 != 0) {
#line 117
    return (-1);
  }
  {
#line 120
  makeleastlengthtext(& leastlengthtext[0]);
#line 121
  tmp___4 = addoption(& options[0], (Uint )14, (Uint )5, (char *)"-l", & leastlengthtext[0]);
  }
#line 121
  if (tmp___4 != 0) {
#line 121
    return (-1);
  }
  {
#line 122
  tmp___5 = addoption(& options[0], (Uint )14, (Uint )6, (char *)"-b", (char *)"compute forward and reverse complement matches");
  }
#line 122
  if (tmp___5 != 0) {
#line 122
    return (-1);
  }
  {
#line 124
  tmp___6 = addoption(& options[0], (Uint )14, (Uint )7, (char *)"-r", (char *)"only compute reverse complement matches");
  }
#line 124
  if (tmp___6 != 0) {
#line 124
    return (-1);
  }
  {
#line 126
  tmp___7 = addoption(& options[0], (Uint )14, (Uint )8, (char *)"-s", (char *)"show the matching substrings");
  }
#line 126
  if (tmp___7 != 0) {
#line 126
    return (-1);
  }
  {
#line 128
  tmp___8 = addoption(& options[0], (Uint )14, (Uint )9, (char *)"-c", (char *)"report the query-position of a reverse complement match\nrelative to the original query sequence");
  }
#line 128
  if (tmp___8 != 0) {
#line 128
    return (-1);
  }
  {
#line 131
  tmp___9 = addoption(& options[0], (Uint )14, (Uint )10, (char *)"-F", (char *)"force 4 column output format regardless of the number of\nreference sequence inputs");
  }
#line 131
  if (tmp___9 != 0) {
#line 131
    return (-1);
  }
  {
#line 134
  tmp___10 = addoption(& options[0], (Uint )14, (Uint )11, (char *)"-L", (char *)"show the length of the query sequences on the header line");
  }
#line 134
  if (tmp___10 != 0) {
#line 134
    return (-1);
  }
  {
#line 136
  tmp___11 = addoption(& options[0], (Uint )14, (Uint )12, (char *)"-h", (char *)"show possible options");
  }
#line 136
  if (tmp___11 != 0) {
#line 136
    return (-1);
  }
  {
#line 138
  tmp___12 = addoption(& options[0], (Uint )14, (Uint )13, (char *)"-help", (char *)"show possible options");
  }
#line 138
  if (tmp___12 != 0) {
#line 138
    return (-1);
  }
#line 140
  mmcallinfo->showstring = (unsigned char)0;
#line 141
  mmcallinfo->reversecomplement = (unsigned char)0;
#line 142
  mmcallinfo->forward = (unsigned char)1;
#line 143
  mmcallinfo->showreversepositions = (unsigned char)0;
#line 144
  mmcallinfo->fourcolumn = (unsigned char)0;
#line 145
  mmcallinfo->showsequencelengths = (unsigned char)0;
#line 146
  mmcallinfo->matchnucleotidesonly = (unsigned char)0;
#line 147
  mmcallinfo->cmum = (unsigned char)0;
#line 148
  mmcallinfo->cmumcand = (unsigned char)0;
#line 149
  mmcallinfo->cmaxmatch = (unsigned char)0;
#line 150
  mmcallinfo->minmatchlength = (Uint )20;
#line 152
  if (argc == 1) {
    {
#line 154
    showusage(*(argv + 0), & options[0], (Uint )14);
    }
#line 155
    return (1);
  }
#line 158
  argnum = 1U;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (argnum < (Uint )argc) {
#line 158
      if (! ((int )*(*(argv + argnum) + 0) == 45)) {
#line 158
        goto while_break;
      }
    } else {
#line 158
      goto while_break;
    }
    {
#line 161
    optval = procoption(options, (Uint )14, *(argv + argnum));
    }
#line 162
    if (optval < 0) {
#line 164
      return (-1);
    }
    {
#line 168
    if (optval == 8) {
#line 168
      goto case_8;
    }
#line 171
    if (optval == 6) {
#line 171
      goto case_6;
    }
#line 174
    if (optval == 9) {
#line 174
      goto case_9;
    }
#line 177
    if (optval == 5) {
#line 177
      goto case_5;
    }
#line 193
    if (optval == 10) {
#line 193
      goto case_10;
    }
#line 196
    if (optval == 11) {
#line 196
      goto case_11;
    }
#line 199
    if (optval == 4) {
#line 199
      goto case_4;
    }
#line 202
    if (optval == 7) {
#line 202
      goto case_7;
    }
#line 206
    if (optval == 3) {
#line 206
      goto case_3;
    }
#line 210
    if (optval == 1) {
#line 210
      goto case_1;
    }
#line 210
    if (optval == 2) {
#line 210
      goto case_1;
    }
#line 213
    if (optval == 0) {
#line 213
      goto case_0;
    }
#line 217
    if (optval == 13) {
#line 217
      goto case_13;
    }
#line 217
    if (optval == 12) {
#line 217
      goto case_13;
    }
#line 166
    goto switch_break;
    case_8: /* CIL Label */ 
#line 169
    mmcallinfo->showstring = (unsigned char)1;
#line 170
    goto switch_break;
    case_6: /* CIL Label */ 
#line 172
    mmcallinfo->reversecomplement = (unsigned char)1;
#line 173
    goto switch_break;
    case_9: /* CIL Label */ 
#line 175
    mmcallinfo->showreversepositions = (unsigned char)1;
#line 176
    goto switch_break;
    case_5: /* CIL Label */ 
#line 178
    argnum ++;
#line 179
    if (argnum > (Uint )(argc - 2)) {
      {
#line 181
      tmp___13 = messagespace();
#line 181
      tmp___14 = sprintf((char */* __restrict  */)tmp___13, (char const   */* __restrict  */)"missing argument for option %s",
                         options[5].optname);
#line 181
      tmp___15 = maxerrormsg();
      }
#line 181
      if (tmp___14 >= tmp___15) {
        {
#line 181
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                (Showuint )182);
#line 181
        exit(1);
        }
      }
#line 183
      return (-2);
    }
    {
#line 185
    tmp___19 = sscanf((char const   */* __restrict  */)*(argv + argnum), (char const   */* __restrict  */)"%ld",
                      & readint);
    }
#line 185
    if (tmp___19 != 1) {
#line 185
      goto _L;
    } else
#line 185
    if (readint <= 0L) {
      _L: /* CIL Label */ 
      {
#line 187
      tmp___16 = messagespace();
#line 187
      tmp___17 = sprintf((char */* __restrict  */)tmp___16, (char const   */* __restrict  */)"argument %s for option %s is not a positive integer",
                         *(argv + argnum), options[5].optname);
#line 187
      tmp___18 = maxerrormsg();
      }
#line 187
      if (tmp___17 >= tmp___18) {
        {
#line 187
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                (Showuint )188);
#line 187
        exit(1);
        }
      }
#line 189
      return (-3);
    }
#line 191
    mmcallinfo->minmatchlength = (Uint )readint;
#line 192
    goto switch_break;
    case_10: /* CIL Label */ 
#line 194
    mmcallinfo->fourcolumn = (unsigned char)1;
#line 195
    goto switch_break;
    case_11: /* CIL Label */ 
#line 197
    mmcallinfo->showsequencelengths = (unsigned char)1;
#line 198
    goto switch_break;
    case_4: /* CIL Label */ 
#line 200
    mmcallinfo->matchnucleotidesonly = (unsigned char)1;
#line 201
    goto switch_break;
    case_7: /* CIL Label */ 
#line 203
    mmcallinfo->forward = (unsigned char)0;
#line 204
    mmcallinfo->reversecomplement = (unsigned char)1;
#line 205
    goto switch_break;
    case_3: /* CIL Label */ 
#line 207
    mmcallinfo->cmaxmatch = (unsigned char)1;
#line 208
    goto switch_break;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 211
    mmcallinfo->cmumcand = (unsigned char)1;
#line 212
    goto switch_break;
    case_0: /* CIL Label */ 
#line 214
    mmcallinfo->cmum = (unsigned char)1;
#line 215
    goto switch_break;
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    {
#line 218
    showusage(*(argv + 0), & options[0], (Uint )14);
    }
#line 219
    return (1);
    switch_break: /* CIL Label */ ;
    }
#line 158
    argnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (argnum > (Uint )(argc - 2)) {
    {
#line 224
    tmp___20 = messagespace();
#line 224
    tmp___21 = sprintf((char */* __restrict  */)tmp___20, (char const   */* __restrict  */)"missing file arguments");
#line 224
    tmp___22 = maxerrormsg();
    }
#line 224
    if (tmp___21 >= tmp___22) {
      {
#line 224
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
              (Showuint )224);
#line 224
      exit(1);
      }
    }
#line 225
    return (-4);
  }
  {
#line 227
  tmp___23 = safestringcopy(& mmcallinfo->program[0], *(argv + 0), 4096);
  }
#line 227
  if (tmp___23 != 0) {
#line 229
    return (-5);
  }
  {
#line 231
  tmp___24 = safestringcopy(& mmcallinfo->subjectfile[0], *(argv + argnum), 4096);
  }
#line 231
  if (tmp___24 != 0) {
#line 233
    return (-6);
  }
#line 235
  argnum ++;
#line 235
  mmcallinfo->numofqueryfiles = (Uint )0;
  {
#line 235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 235
    if (! (argnum < (Uint )argc)) {
#line 235
      goto while_break___0;
    }
#line 238
    if (mmcallinfo->numofqueryfiles >= 32U) {
      {
#line 240
      tmp___25 = messagespace();
#line 240
      tmp___26 = sprintf((char */* __restrict  */)tmp___25, (char const   */* __restrict  */)"too many query files, maximal number is %lu",
                         (Showuint )32);
#line 240
      tmp___27 = maxerrormsg();
      }
#line 240
      if (tmp___26 >= tmp___27) {
        {
#line 240
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                (Showuint )241);
#line 240
        exit(1);
        }
      }
#line 242
      return (-7);
    }
    {
#line 244
    tmp___28 = safestringcopy(& mmcallinfo->queryfilelist[mmcallinfo->numofqueryfiles][0],
                              *(argv + argnum), 4096);
    }
#line 244
    if (tmp___28 != 0) {
#line 248
      return (-8);
    }
#line 235
    (mmcallinfo->numofqueryfiles) ++;
#line 235
    argnum ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 254
  if (options[0].isalreadyset) {
#line 254
    if (options[1].isalreadyset) {
      {
#line 254
      tmp___29 = messagespace();
#line 254
      tmp___30 = sprintf((char */* __restrict  */)tmp___29, (char const   */* __restrict  */)"option %s and option %s exclude each other",
                         options[0].optname, options[1].optname);
#line 254
      tmp___31 = maxerrormsg();
      }
#line 254
      if (tmp___30 >= tmp___31) {
        {
#line 254
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                (Showuint )254);
#line 254
        exit(1);
        }
      }
#line 254
      return (-1);
    }
  }
#line 255
  if (options[0].isalreadyset) {
#line 255
    if (options[2].isalreadyset) {
      {
#line 255
      tmp___32 = messagespace();
#line 255
      tmp___33 = sprintf((char */* __restrict  */)tmp___32, (char const   */* __restrict  */)"option %s and option %s exclude each other",
                         options[0].optname, options[2].optname);
#line 255
      tmp___34 = maxerrormsg();
      }
#line 255
      if (tmp___33 >= tmp___34) {
        {
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                (Showuint )255);
#line 255
        exit(1);
        }
      }
#line 255
      return (-1);
    }
  }
#line 256
  if (options[0].isalreadyset) {
#line 256
    if (options[3].isalreadyset) {
      {
#line 256
      tmp___35 = messagespace();
#line 256
      tmp___36 = sprintf((char */* __restrict  */)tmp___35, (char const   */* __restrict  */)"option %s and option %s exclude each other",
                         options[0].optname, options[3].optname);
#line 256
      tmp___37 = maxerrormsg();
      }
#line 256
      if (tmp___36 >= tmp___37) {
        {
#line 256
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                (Showuint )256);
#line 256
        exit(1);
        }
      }
#line 256
      return (-1);
    }
  }
#line 257
  if (options[1].isalreadyset) {
#line 257
    if (options[3].isalreadyset) {
      {
#line 257
      tmp___38 = messagespace();
#line 257
      tmp___39 = sprintf((char */* __restrict  */)tmp___38, (char const   */* __restrict  */)"option %s and option %s exclude each other",
                         options[1].optname, options[3].optname);
#line 257
      tmp___40 = maxerrormsg();
      }
#line 257
      if (tmp___39 >= tmp___40) {
        {
#line 257
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                (Showuint )257);
#line 257
        exit(1);
        }
      }
#line 257
      return (-1);
    }
  }
#line 258
  if (options[2].isalreadyset) {
#line 258
    if (options[3].isalreadyset) {
      {
#line 258
      tmp___41 = messagespace();
#line 258
      tmp___42 = sprintf((char */* __restrict  */)tmp___41, (char const   */* __restrict  */)"option %s and option %s exclude each other",
                         options[2].optname, options[3].optname);
#line 258
      tmp___43 = maxerrormsg();
      }
#line 258
      if (tmp___42 >= tmp___43) {
        {
#line 258
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                (Showuint )258);
#line 258
        exit(1);
        }
      }
#line 258
      return (-1);
    }
  }
#line 259
  if (mmcallinfo->cmaxmatch) {
#line 261
    mmcallinfo->cmum = (unsigned char)0;
#line 262
    mmcallinfo->cmumcand = (unsigned char)0;
  } else
#line 264
  if (! mmcallinfo->cmum) {
#line 270
    mmcallinfo->cmumcand = (unsigned char)1;
  }
#line 275
  if (options[6].isalreadyset) {
#line 275
    if (options[7].isalreadyset) {
      {
#line 275
      tmp___44 = messagespace();
#line 275
      tmp___45 = sprintf((char */* __restrict  */)tmp___44, (char const   */* __restrict  */)"option %s and option %s exclude each other",
                         options[6].optname, options[7].optname);
#line 275
      tmp___46 = maxerrormsg();
      }
#line 275
      if (tmp___45 >= tmp___46) {
        {
#line 275
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                (Showuint )275);
#line 275
        exit(1);
        }
      }
#line 275
      return (-1);
    }
  }
#line 279
  if (options[9].isalreadyset) {
#line 279
    if (! options[6].isalreadyset) {
#line 279
      if (! options[7].isalreadyset) {
        {
#line 279
        tmp___47 = messagespace();
#line 279
        tmp___48 = sprintf((char */* __restrict  */)tmp___47, (char const   */* __restrict  */)"option %s requires either option %s or %s",
                           options[9].optname, options[6].optname, options[7].optname);
#line 279
        tmp___49 = maxerrormsg();
        }
#line 279
        if (tmp___48 >= tmp___49) {
          {
#line 279
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                  "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatopt.c",
                  (Showuint )280);
#line 279
          exit(1);
          }
        }
#line 279
        return (-1);
      }
    }
  }
#line 281
  return (0);
}
}
#line 79 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
Sint makeleaflist(Suffixtree *stree , ArrayUint *leaflist , Reference *start ) ;
#line 27 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.c"
Sint depthfirststree(Suffixtree *stree , Reference *startnode , Sint (*processleaf___1)(Uint  ,
                                                                                        Bref  ,
                                                                                        void * ) ,
                     unsigned char (*processbranch1___1)(Bref  , void * ) , Sint (*processbranch2___1)(Bref  ,
                                                                                                       void * ) ,
                     unsigned char (*stoptraversal)(void * ) , void *stopinfo , void *info ) 
{ 
  unsigned char godown ;
  unsigned char readyforpop ;
  Uint child ;
  Uint brotherval ;
  Bref lcpnode ;
  Reference currentnode ;
  ArrayBref stack ;
  Sint tmp ;
  unsigned char tmp___0 ;
  void *tmp___1 ;
  Uint tmp___2 ;
  unsigned char tmp___3 ;
  Sint tmp___4 ;
  void *tmp___5 ;
  Uint tmp___6 ;
  unsigned char tmp___7 ;
  Sint tmp___8 ;
  Sint tmp___9 ;
  void *tmp___10 ;
  Uint tmp___11 ;

  {
#line 33
  godown = (unsigned char)1;
#line 33
  readyforpop = (unsigned char)0;
#line 35
  lcpnode = (Bref )((void *)0);
#line 39
  if (startnode->toleaf) {
    {
#line 41
    tmp = (*processleaf___1)((Uint )(startnode->address - stree->leaftab), (Bref )((void *)0),
                             info);
    }
#line 41
    if (tmp != 0) {
#line 43
      return (-1);
    }
#line 45
    return (0);
  }
#line 47
  if ((unsigned long )stoptraversal != (unsigned long )((void *)0)) {
    {
#line 47
    tmp___0 = (*stoptraversal)(stopinfo);
    }
#line 47
    if (tmp___0) {
#line 49
      return (0);
    }
  }
#line 52
  currentnode.toleaf = (unsigned char)0;
#line 53
  currentnode.address = startnode->address;
#line 54
  stack.spaceBref = (Bref *)((void *)0);
#line 54
  stack.nextfreeBref = (Uint )0;
#line 54
  stack.allocatedBref = stack.nextfreeBref;
#line 55
  if (stack.nextfreeBref >= stack.allocatedBref) {
    {
#line 55
    stack.allocatedBref += 128U;
#line 55
    tmp___1 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.c",
                                     (Uint )55, (void *)stack.spaceBref, (Uint )sizeof(Bref ),
                                     stack.allocatedBref);
#line 55
    stack.spaceBref = (Bref *)tmp___1;
    }
  }
#line 55
  tmp___2 = stack.nextfreeBref;
#line 55
  (stack.nextfreeBref) ++;
#line 55
  *(stack.spaceBref + tmp___2) = currentnode.address;
#line 56
  if ((*(currentnode.address) & ((1U << ((1U << 5) - 1U)) - 1U)) & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 56
    currentnode.address = stree->leaftab + ((*(currentnode.address) & ((1U << ((1U << 5) - 1U)) - 1U)) & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 56
    currentnode.toleaf = (unsigned char)1;
  } else {
#line 56
    currentnode.address = stree->branchtab + ((*(currentnode.address) & ((1U << ((1U << 5) - 1U)) - 1U)) & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 56
    currentnode.toleaf = (unsigned char)0;
  }
#line 58 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.c"
  if ((unsigned long )processbranch1___1 == (unsigned long )((void *)0)) {
    {
#line 9
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11
      if ((unsigned long )stoptraversal != (unsigned long )((void *)0)) {
        {
#line 11
        tmp___3 = (*stoptraversal)(stopinfo);
        }
#line 11
        if (tmp___3) {
#line 13
          return (0);
        }
      }
#line 15
      if (currentnode.toleaf) {
        {
#line 20
        tmp___4 = (*processleaf___1)((Uint )(currentnode.address - stree->leaftab),
                                     lcpnode, info);
        }
#line 20
        if (tmp___4 != 0) {
#line 22
          return (-1);
        }
#line 24
        brotherval = *(currentnode.address);
#line 25
        if (brotherval & (1U << ((1U << 5) - 1U))) {
#line 27
          readyforpop = (unsigned char)1;
#line 28
          currentnode.toleaf = (unsigned char)0;
        } else {
#line 31
          if (brotherval & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 31
            currentnode.address = stree->leaftab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 31
            currentnode.toleaf = (unsigned char)1;
          } else {
#line 31
            currentnode.address = stree->branchtab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 31
            currentnode.toleaf = (unsigned char)0;
          }
#line 32
          lcpnode = *(stack.spaceBref + (stack.nextfreeBref - 1U));
        }
      } else
#line 36
      if (readyforpop) {
#line 38
        if (stack.nextfreeBref == 1U) {
#line 40
          goto while_break;
        }
#line 42
        (stack.nextfreeBref) --;
#line 46
        godown = (unsigned char)1;
#line 47
        brotherval = *(*(stack.spaceBref + stack.nextfreeBref) + 1);
#line 48
        if (! (brotherval & (1U << ((1U << 5) - 1U)))) {
#line 50
          if (brotherval & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 50
            currentnode.address = stree->leaftab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 50
            currentnode.toleaf = (unsigned char)1;
          } else {
#line 50
            currentnode.address = stree->branchtab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 50
            currentnode.toleaf = (unsigned char)0;
          }
#line 51
          lcpnode = *(stack.spaceBref + (stack.nextfreeBref - 1U));
#line 52
          readyforpop = (unsigned char)0;
        }
      } else
#line 59
      if (godown) {
#line 61
        if (stack.nextfreeBref >= stack.allocatedBref) {
          {
#line 61
          stack.allocatedBref += 128U;
#line 61
          tmp___5 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.gen",
                                           (Uint )61, (void *)stack.spaceBref, (Uint )sizeof(Bref ),
                                           stack.allocatedBref);
#line 61
          stack.spaceBref = (Bref *)tmp___5;
          }
        }
#line 61
        tmp___6 = stack.nextfreeBref;
#line 61
        (stack.nextfreeBref) ++;
#line 61
        *(stack.spaceBref + tmp___6) = currentnode.address;
#line 64
        child = *(currentnode.address) & ((1U << ((1U << 5) - 1U)) - 1U);
#line 65
        if (child & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 65
          currentnode.address = stree->leaftab + (child & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 65
          currentnode.toleaf = (unsigned char)1;
        } else {
#line 65
          currentnode.address = stree->branchtab + (child & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 65
          currentnode.toleaf = (unsigned char)0;
        }
      } else {
#line 68
        brotherval = *(currentnode.address + 1);
#line 69
        if (brotherval & (1U << ((1U << 5) - 1U))) {
#line 71
          readyforpop = (unsigned char)1;
        } else
#line 74
        if (brotherval & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 74
          currentnode.address = stree->leaftab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 74
          currentnode.toleaf = (unsigned char)1;
        } else {
#line 74
          currentnode.address = stree->branchtab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 74
          currentnode.toleaf = (unsigned char)0;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 9
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11
      if ((unsigned long )stoptraversal != (unsigned long )((void *)0)) {
        {
#line 11 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.gen"
        tmp___7 = (*stoptraversal)(stopinfo);
        }
#line 11
        if (tmp___7) {
#line 13
          return (0);
        }
      }
#line 15
      if (currentnode.toleaf) {
        {
#line 20
        tmp___8 = (*processleaf___1)((Uint )(currentnode.address - stree->leaftab),
                                     lcpnode, info);
        }
#line 20
        if (tmp___8 != 0) {
#line 22
          return (-1);
        }
#line 24
        brotherval = *(currentnode.address);
#line 25
        if (brotherval & (1U << ((1U << 5) - 1U))) {
#line 27
          readyforpop = (unsigned char)1;
#line 28
          currentnode.toleaf = (unsigned char)0;
        } else {
#line 31
          if (brotherval & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 31
            currentnode.address = stree->leaftab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 31
            currentnode.toleaf = (unsigned char)1;
          } else {
#line 31
            currentnode.address = stree->branchtab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 31
            currentnode.toleaf = (unsigned char)0;
          }
#line 32
          lcpnode = *(stack.spaceBref + (stack.nextfreeBref - 1U));
        }
      } else
#line 36
      if (readyforpop) {
#line 38
        if (stack.nextfreeBref == 1U) {
#line 40
          goto while_break___0;
        }
        {
#line 42
        (stack.nextfreeBref) --;
#line 46
        tmp___9 = (*processbranch2___1)(*(stack.spaceBref + stack.nextfreeBref), info);
        }
#line 46
        if (tmp___9 != 0) {
#line 46
          return (-2);
        }
#line 47
        brotherval = *(*(stack.spaceBref + stack.nextfreeBref) + 1);
#line 48
        if (! (brotherval & (1U << ((1U << 5) - 1U)))) {
#line 50
          if (brotherval & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 50
            currentnode.address = stree->leaftab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 50
            currentnode.toleaf = (unsigned char)1;
          } else {
#line 50
            currentnode.address = stree->branchtab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 50
            currentnode.toleaf = (unsigned char)0;
          }
#line 51
          lcpnode = *(stack.spaceBref + (stack.nextfreeBref - 1U));
#line 52
          readyforpop = (unsigned char)0;
        }
      } else {
        {
#line 58
        godown = (*processbranch1___1)(currentnode.address, info);
        }
#line 59
        if (godown) {
#line 61
          if (stack.nextfreeBref >= stack.allocatedBref) {
            {
#line 61
            stack.allocatedBref += 128U;
#line 61
            tmp___10 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.gen",
                                              (Uint )61, (void *)stack.spaceBref,
                                              (Uint )sizeof(Bref ), stack.allocatedBref);
#line 61
            stack.spaceBref = (Bref *)tmp___10;
            }
          }
#line 61
          tmp___11 = stack.nextfreeBref;
#line 61
          (stack.nextfreeBref) ++;
#line 61
          *(stack.spaceBref + tmp___11) = currentnode.address;
#line 64
          child = *(currentnode.address) & ((1U << ((1U << 5) - 1U)) - 1U);
#line 65
          if (child & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 65
            currentnode.address = stree->leaftab + (child & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 65
            currentnode.toleaf = (unsigned char)1;
          } else {
#line 65
            currentnode.address = stree->branchtab + (child & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 65
            currentnode.toleaf = (unsigned char)0;
          }
        } else {
#line 68
          brotherval = *(currentnode.address + 1);
#line 69
          if (brotherval & (1U << ((1U << 5) - 1U))) {
#line 71
            readyforpop = (unsigned char)1;
          } else
#line 74
          if (brotherval & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 74
            currentnode.address = stree->leaftab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 74
            currentnode.toleaf = (unsigned char)1;
          } else {
#line 74
            currentnode.address = stree->branchtab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 74
            currentnode.toleaf = (unsigned char)0;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 74
  if ((unsigned long )stack.spaceBref != (unsigned long )((void *)0)) {
#line 74
    if ((unsigned long )stack.spaceBref != (unsigned long )((void *)0)) {
      {
#line 74
      freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.c",
                      (Uint )74, (void *)stack.spaceBref);
#line 74
      stack.spaceBref = (Bref *)((void *)0);
      }
    }
  }
#line 75
  return (0);
}
}
#line 78 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.c"
static Sint insertinleaflist(Uint leafindex , Bref lcpnode , void *info ) 
{ 
  ArrayUint *leaflist ;
  void *tmp ;
  Uint tmp___0 ;

  {
#line 81
  leaflist = (ArrayUint *)info;
#line 84
  if (leaflist->nextfreeUint >= leaflist->allocatedUint) {
    {
#line 84
    leaflist->allocatedUint += 256U;
#line 84
    tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.c",
                                 (Uint )84, (void *)leaflist->spaceUint, (Uint )sizeof(Uint ),
                                 leaflist->allocatedUint);
#line 84
    leaflist->spaceUint = (Uint *)tmp;
    }
  }
#line 85
  tmp___0 = leaflist->nextfreeUint;
#line 85
  (leaflist->nextfreeUint) ++;
#line 85
  *(leaflist->spaceUint + tmp___0) = leafindex;
#line 86
  return (0);
}
}
#line 89 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/dfs.c"
Sint makeleaflist(Suffixtree *stree , ArrayUint *leaflist , Reference *start ) 
{ 
  Sint tmp ;

  {
  {
#line 91
  tmp = depthfirststree(stree, start, & insertinleaflist, (unsigned char (*)(Bref  ,
                                                                             void * ))((void *)0),
                        (Sint (*)(Bref  , void * ))((void *)0), (unsigned char (*)(void * ))((void *)0),
                        (void *)0, (void *)leaflist);
  }
#line 91
  if (tmp != 0) {
#line 94
    return (-1);
  }
#line 96
  return (0);
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 27 "../libbasedir/spacedef.h"
extern void *creatememorymap(char *file , Uint line , char *filename , unsigned char writemap ,
                             Uint *numofbytes ) ;
#line 22 "../libbasedir/protodef.h"
extern Sint mumuniqueinquery(void *processinfo , Sint (*processmum)(void * , Uint  ,
                                                                    Uint  , Uint  ,
                                                                    Uint  ) , ArrayMUMcandidate *mumcand ) ;
#line 26
extern double getruntime(void) ;
#line 45
extern void freemultiseq(Multiseq *multiseq ) ;
#line 46
extern Sint overallsequences(unsigned char rcmode , Multiseq *multiseq , void *applyinfo ,
                             Sint (*apply)(void * , Uint  , Uchar * , Uint  ) ) ;
#line 51
extern Sint pos2pospair(Multiseq *multiseq , PairUint *pos , Uint position ) ;
#line 23 "../streesrc/streeproto.h"
Sint constructprogressstree(Suffixtree *stree , SYMBOL *text , Uint textlen , void (*progress)(Uint  ,
                                                                                               void * ) ,
                            void (*finalprogress)(void * ) , void *info ) ;
#line 25
void freestree(Suffixtree *stree ) ;
#line 40
Uint getmaxtextlenstree(void) ;
#line 76 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
Sint findmumcandidates(Suffixtree *stree , Uint minmatchlength , Sint (*processmumcandidate)(void * ,
                                                                                             Uint  ,
                                                                                             Uint  ,
                                                                                             Uint  ,
                                                                                             Uint  ) ,
                       void *processinfo , Uchar *query , Uint querylen , Uint seqnum ) ;
#line 100
Sint scanmultiplefastafile(Multiseq *multiseq , char *filename , Uchar replacewildcardchar ,
                           Uchar *input , Uint inputlen ) ;
#line 198 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
static void wccSequence(Uchar *seq , Uint seqlen ) 
{ 
  Uchar *front ;
  Uchar *back ;
  Uchar tmp ;

  {
#line 201
  tmp = (Uchar )0;
#line 203
  front = seq;
#line 203
  back = (seq + seqlen) - 1;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! ((unsigned long )front <= (unsigned long )back)) {
#line 203
      goto while_break;
    }
#line 206
    if ((int )*front >= 251) {
#line 206
      tmp = *front;
    } else {
      {
#line 206
      if ((int )*front == 97) {
#line 206
        goto case_97;
      }
#line 206
      if ((int )*front == 99) {
#line 206
        goto case_99;
      }
#line 206
      if ((int )*front == 103) {
#line 206
        goto case_103;
      }
#line 206
      if ((int )*front == 116) {
#line 206
        goto case_116;
      }
#line 206
      if ((int )*front == 114) {
#line 206
        goto case_114;
      }
#line 206
      if ((int )*front == 121) {
#line 206
        goto case_121;
      }
#line 206
      if ((int )*front == 115) {
#line 206
        goto case_115;
      }
#line 206
      if ((int )*front == 119) {
#line 206
        goto case_119;
      }
#line 206
      if ((int )*front == 109) {
#line 206
        goto case_109;
      }
#line 206
      if ((int )*front == 107) {
#line 206
        goto case_107;
      }
#line 206
      if ((int )*front == 98) {
#line 206
        goto case_98;
      }
#line 206
      if ((int )*front == 100) {
#line 206
        goto case_100;
      }
#line 206
      if ((int )*front == 104) {
#line 206
        goto case_104;
      }
#line 206
      if ((int )*front == 118) {
#line 206
        goto case_118;
      }
#line 206
      goto switch_default;
      case_97: /* CIL Label */ 
#line 206
      tmp = (Uchar )'t';
#line 206
      goto switch_break;
      case_99: /* CIL Label */ 
#line 206
      tmp = (Uchar )'g';
#line 206
      goto switch_break;
      case_103: /* CIL Label */ 
#line 206
      tmp = (Uchar )'c';
#line 206
      goto switch_break;
      case_116: /* CIL Label */ 
#line 206
      tmp = (Uchar )'a';
#line 206
      goto switch_break;
      case_114: /* CIL Label */ 
#line 206
      tmp = (Uchar )'y';
#line 206
      goto switch_break;
      case_121: /* CIL Label */ 
#line 206
      tmp = (Uchar )'r';
#line 206
      goto switch_break;
      case_115: /* CIL Label */ 
#line 206
      tmp = (Uchar )'s';
#line 206
      goto switch_break;
      case_119: /* CIL Label */ 
#line 206
      tmp = (Uchar )'w';
#line 206
      goto switch_break;
      case_109: /* CIL Label */ 
#line 206
      tmp = (Uchar )'k';
#line 206
      goto switch_break;
      case_107: /* CIL Label */ 
#line 206
      tmp = (Uchar )'m';
#line 206
      goto switch_break;
      case_98: /* CIL Label */ 
#line 206
      tmp = (Uchar )'v';
#line 206
      goto switch_break;
      case_100: /* CIL Label */ 
#line 206
      tmp = (Uchar )'h';
#line 206
      goto switch_break;
      case_104: /* CIL Label */ 
#line 206
      tmp = (Uchar )'d';
#line 206
      goto switch_break;
      case_118: /* CIL Label */ 
#line 206
      tmp = (Uchar )'b';
#line 206
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 206
      tmp = (Uchar )'n';
#line 206
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 207
    if ((int )*back >= 251) {
#line 207
      *front = *back;
    } else {
      {
#line 207
      if ((int )*back == 97) {
#line 207
        goto case_97___0;
      }
#line 207
      if ((int )*back == 99) {
#line 207
        goto case_99___0;
      }
#line 207
      if ((int )*back == 103) {
#line 207
        goto case_103___0;
      }
#line 207
      if ((int )*back == 116) {
#line 207
        goto case_116___0;
      }
#line 207
      if ((int )*back == 114) {
#line 207
        goto case_114___0;
      }
#line 207
      if ((int )*back == 121) {
#line 207
        goto case_121___0;
      }
#line 207
      if ((int )*back == 115) {
#line 207
        goto case_115___0;
      }
#line 207
      if ((int )*back == 119) {
#line 207
        goto case_119___0;
      }
#line 207
      if ((int )*back == 109) {
#line 207
        goto case_109___0;
      }
#line 207
      if ((int )*back == 107) {
#line 207
        goto case_107___0;
      }
#line 207
      if ((int )*back == 98) {
#line 207
        goto case_98___0;
      }
#line 207
      if ((int )*back == 100) {
#line 207
        goto case_100___0;
      }
#line 207
      if ((int )*back == 104) {
#line 207
        goto case_104___0;
      }
#line 207
      if ((int )*back == 118) {
#line 207
        goto case_118___0;
      }
#line 207
      goto switch_default___0;
      case_97___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'t';
#line 207
      goto switch_break___0;
      case_99___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'g';
#line 207
      goto switch_break___0;
      case_103___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'c';
#line 207
      goto switch_break___0;
      case_116___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'a';
#line 207
      goto switch_break___0;
      case_114___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'y';
#line 207
      goto switch_break___0;
      case_121___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'r';
#line 207
      goto switch_break___0;
      case_115___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'s';
#line 207
      goto switch_break___0;
      case_119___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'w';
#line 207
      goto switch_break___0;
      case_109___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'k';
#line 207
      goto switch_break___0;
      case_107___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'m';
#line 207
      goto switch_break___0;
      case_98___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'v';
#line 207
      goto switch_break___0;
      case_100___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'h';
#line 207
      goto switch_break___0;
      case_104___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'d';
#line 207
      goto switch_break___0;
      case_118___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'b';
#line 207
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 207
      *front = (Uchar )'n';
#line 207
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 208
    *back = tmp;
#line 203
    front ++;
#line 203
    back --;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
static void showsequencedescription(Multiseq *multiseq , Uint maxdesclength , Uint seqnum ) 
{ 
  Uint i ;
  Uint desclength ;
  Uchar *desc ;
  unsigned short const   **tmp ;

  {
#line 220
  desclength = *(multiseq->startdesc + (seqnum + 1U)) - *(multiseq->startdesc + seqnum);
#line 221
  desc = multiseq->descspace.spaceUchar + *(multiseq->startdesc + seqnum);
#line 223
  i = (Uint )0;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i < desclength)) {
#line 223
      goto while_break;
    }
    {
#line 225
    tmp = __ctype_b_loc();
    }
#line 225
    if ((int const   )*(*tmp + (Ctypeargumenttype )*(desc + i)) & 8192) {
#line 227
      goto while_break;
    }
    {
#line 229
    putchar((Fputcfirstargtype )*(desc + i));
#line 223
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  if (desclength < maxdesclength) {
#line 233
    i = (Uint )0;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (i < maxdesclength - desclength)) {
#line 233
        goto while_break___0;
      }
      {
#line 235
      putchar(' ');
#line 233
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 238
  return;
}
}
#line 250 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
static void showsequenceheader(Multiseq *multiseq , unsigned char showsequencelengths ,
                               unsigned char currentisrcmatch , Uint seqnum , Uint seqlen ) 
{ 


  {
  {
#line 257
  printf((char const   */* __restrict  */)"%c ", '>');
#line 258
  showsequencedescription(multiseq, (Uint )0, seqnum);
  }
#line 259
  if (currentisrcmatch) {
    {
#line 261
    printf((char const   */* __restrict  */)" Reverse");
    }
  }
#line 263
  if (showsequencelengths) {
    {
#line 265
    printf((char const   */* __restrict  */)"  Len = %lu", (Showuint )seqlen);
    }
  }
  {
#line 267
  printf((char const   */* __restrict  */)"\n");
  }
#line 268
  return;
}
}
#line 279 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
static Sint showmaximalmatch(void *info , Uint matchlength , Uint subjectstart , Uint seqnum ,
                             Uint querystart ) 
{ 
  Matchprocessinfo *matchprocessinfo ;
  PairUint pp ;
  Sint tmp ;

  {
#line 285
  matchprocessinfo = (Matchprocessinfo *)info;
#line 287
  if ((matchprocessinfo->subjectmultiseq)->numofsequences == 1U) {
#line 287
    if (! matchprocessinfo->fourcolumn) {
      {
#line 291
      printf((char const   */* __restrict  */)"%8lu  ", (Showuint )(subjectstart + 1U));
      }
    } else {
#line 287
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 296
    tmp = pos2pospair(matchprocessinfo->subjectmultiseq, & pp, subjectstart);
    }
#line 296
    if (tmp != 0) {
#line 298
      return (-1);
    }
    {
#line 300
    printf((char const   */* __restrict  */)"  ");
#line 301
    showsequencedescription(matchprocessinfo->subjectmultiseq, matchprocessinfo->maxdesclength,
                            pp.uint0);
#line 304
    printf((char const   */* __restrict  */)"  %8lu  ", (Showuint )(pp.uint1 + 1U));
    }
  }
#line 306
  if (matchprocessinfo->currentisrcmatch) {
#line 306
    if (matchprocessinfo->showreversepositions) {
      {
#line 309
      printf((char const   */* __restrict  */)"%8lu  ", (Showuint )(matchprocessinfo->currentquerylen - querystart));
      }
    } else {
      {
#line 313
      printf((char const   */* __restrict  */)"%8lu  ", (Showuint )(querystart + 1U));
      }
    }
  } else {
    {
#line 313
    printf((char const   */* __restrict  */)"%8lu  ", (Showuint )(querystart + 1U));
    }
  }
  {
#line 315
  printf((char const   */* __restrict  */)"%8lu\n", (Showuint )matchlength);
  }
#line 316
  return (0);
}
}
#line 324 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
static Sint showseqandmaximalmatch(void *info , Uint matchlength , Uint subjectstart ,
                                   Uint seqnum , Uint querystart ) 
{ 
  Matchprocessinfo *matchprocessinfo ;
  char *tmp ;
  int tmp___0 ;
  Sint tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 330
  matchprocessinfo = (Matchprocessinfo *)info;
#line 332
  showmaximalmatch(info, matchlength, subjectstart, seqnum, querystart);
#line 337
  tmp___2 = fwrite((void const   */* __restrict  */)((matchprocessinfo->subjectmultiseq)->sequence + subjectstart),
                   sizeof(Uchar ), (size_t )matchlength, (FILE */* __restrict  */)stdout);
  }
#line 337
  if (tmp___2 != (size_t )matchlength) {
    {
#line 342
    tmp = messagespace();
#line 342
    tmp___0 = sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)"cannot output string of length %lu",
                      (Showuint )matchlength);
#line 342
    tmp___1 = maxerrormsg();
    }
#line 342
    if (tmp___0 >= tmp___1) {
      {
#line 342
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c",
              (Showuint )342);
#line 342
      exit(1);
      }
    }
#line 343
    return (-1);
  }
  {
#line 345
  printf((char const   */* __restrict  */)"\n");
  }
#line 346
  return (0);
}
}
#line 354 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
static Sint storeMUMcandidate(void *info , Uint matchlength , Uint subjectstart ,
                              Uint seqnum , Uint querystart ) 
{ 
  Matchprocessinfo *matchprocessinfo ;
  MUMcandidate *mumcandptr ;
  void *tmp ;
  Uint tmp___0 ;

  {
#line 360
  matchprocessinfo = (Matchprocessinfo *)info;
#line 368
  if (matchprocessinfo->mumcandtab.nextfreeMUMcandidate >= matchprocessinfo->mumcandtab.allocatedMUMcandidate) {
    {
#line 368
    matchprocessinfo->mumcandtab.allocatedMUMcandidate += 1024U;
#line 368
    tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c",
                                 (Uint )370, (void *)matchprocessinfo->mumcandtab.spaceMUMcandidate,
                                 (Uint )sizeof(MUMcandidate ), matchprocessinfo->mumcandtab.allocatedMUMcandidate);
#line 368
    matchprocessinfo->mumcandtab.spaceMUMcandidate = (MUMcandidate *)tmp;
    }
  }
#line 368
  tmp___0 = matchprocessinfo->mumcandtab.nextfreeMUMcandidate;
#line 368
  (matchprocessinfo->mumcandtab.nextfreeMUMcandidate) ++;
#line 368
  mumcandptr = matchprocessinfo->mumcandtab.spaceMUMcandidate + tmp___0;
#line 371
  mumcandptr->mumlength = matchlength;
#line 372
  mumcandptr->dbstart = subjectstart;
#line 373
  mumcandptr->queryseq = seqnum;
#line 374
  mumcandptr->querystart = querystart;
#line 375
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
static Sint findmaxmatchesonbothstrands(void *info , Uint seqnum , Uchar *query ,
                                        Uint querylen ) 
{ 
  Matchprocessinfo *matchprocessinfo ;
  Sint (*processmatch)(void * , Uint  , Uint  , Uint  , Uint  ) ;
  Sint (*findmatchfunction)(Suffixtree * , Uint  , Sint (*)(void * , Uint  , Uint  ,
                                                            Uint  , Uint  ) , void * ,
                            Uchar * , Uint  , Uint  ) ;
  Sint tmp ;
  Sint (*tmp___0)(void *info , Uint matchlength , Uint subjectstart , Uint seqnum ,
                  Uint querystart ) ;
  Sint tmp___1 ;
  Sint tmp___2 ;
  Sint (*tmp___3)(void *info , Uint matchlength , Uint subjectstart , Uint seqnum ,
                  Uint querystart ) ;
  Sint tmp___4 ;

  {
#line 388
  matchprocessinfo = (Matchprocessinfo *)info;
#line 392
  if (matchprocessinfo->cmum) {
#line 394
    processmatch = & storeMUMcandidate;
#line 395
    findmatchfunction = & findmumcandidates;
  } else {
#line 398
    if (matchprocessinfo->showstring) {
#line 400
      processmatch = & showseqandmaximalmatch;
    } else {
#line 403
      processmatch = & showmaximalmatch;
    }
#line 405
    if (matchprocessinfo->cmumcand) {
#line 407
      findmatchfunction = & findmumcandidates;
    } else {
#line 410
      findmatchfunction = & findmaxmatches;
    }
  }
#line 413
  matchprocessinfo->currentquerylen = querylen;
#line 414
  if (matchprocessinfo->forward) {
    {
#line 416
    showsequenceheader(& matchprocessinfo->querymultiseq, matchprocessinfo->showsequencelengths,
                       (unsigned char)0, seqnum, querylen);
#line 421
    matchprocessinfo->currentisrcmatch = (unsigned char)0;
#line 422
    tmp = (*findmatchfunction)(& matchprocessinfo->stree, matchprocessinfo->minmatchlength,
                               processmatch, info, query, querylen, seqnum);
    }
#line 422
    if (tmp != 0) {
#line 430
      return (-1);
    }
#line 432
    if (matchprocessinfo->cmum) {
#line 432
      if (matchprocessinfo->showstring) {
#line 432
        tmp___0 = & showseqandmaximalmatch;
      } else {
#line 432
        tmp___0 = & showmaximalmatch;
      }
      {
#line 432
      tmp___1 = mumuniqueinquery(info, tmp___0, & matchprocessinfo->mumcandtab);
      }
#line 432
      if (tmp___1 != 0) {
#line 432
        return (-2);
      }
#line 432
      matchprocessinfo->mumcandtab.nextfreeMUMcandidate = (Uint )0;
    }
  }
#line 434
  if (matchprocessinfo->reversecomplement) {
#line 436
    if (matchprocessinfo->cmum) {
#line 438
      matchprocessinfo->mumcandtab.nextfreeMUMcandidate = (Uint )0;
    }
    {
#line 440
    showsequenceheader(& matchprocessinfo->querymultiseq, matchprocessinfo->showsequencelengths,
                       (unsigned char)1, seqnum, querylen);
#line 445
    wccSequence(query, querylen);
#line 446
    matchprocessinfo->currentisrcmatch = (unsigned char)1;
#line 447
    tmp___2 = (*findmatchfunction)(& matchprocessinfo->stree, matchprocessinfo->minmatchlength,
                                   processmatch, info, query, querylen, seqnum);
    }
#line 447
    if (tmp___2 != 0) {
#line 455
      return (-2);
    }
#line 457
    if (matchprocessinfo->cmum) {
#line 457
      if (matchprocessinfo->showstring) {
#line 457
        tmp___3 = & showseqandmaximalmatch;
      } else {
#line 457
        tmp___3 = & showmaximalmatch;
      }
      {
#line 457
      tmp___4 = mumuniqueinquery(info, tmp___3, & matchprocessinfo->mumcandtab);
      }
#line 457
      if (tmp___4 != 0) {
#line 457
        return (-2);
      }
#line 457
      matchprocessinfo->mumcandtab.nextfreeMUMcandidate = (Uint )0;
    }
  }
#line 459
  return (0);
}
}
#line 462 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
static Sint getmaxdesclen(Multiseq *multiseq ) 
{ 
  Uint desclen ;
  Uint maxdesclen ;
  Uint seqnum ;
  char *tmp ;
  int tmp___0 ;
  Sint tmp___1 ;

  {
#line 465
  if (multiseq->numofsequences == 0U) {
    {
#line 467
    tmp = messagespace();
#line 467
    tmp___0 = sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)"multiple sequence contains 0 sequences");
#line 467
    tmp___1 = maxerrormsg();
    }
#line 467
    if (tmp___0 >= tmp___1) {
      {
#line 467
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c",
              (Showuint )467);
#line 467
      exit(1);
      }
    }
#line 468
    return (-1);
  }
#line 470
  maxdesclen = *(multiseq->startdesc + 1) - *(multiseq->startdesc + 0);
#line 471
  seqnum = 1U;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (seqnum < multiseq->numofsequences)) {
#line 471
      goto while_break;
    }
#line 473
    desclen = *(multiseq->startdesc + (seqnum + 1U)) - *(multiseq->startdesc + seqnum);
#line 474
    if (desclen > maxdesclen) {
#line 476
      maxdesclen = desclen;
    }
#line 471
    seqnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return ((Sint )maxdesclen);
}
}
#line 492 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c"
Sint procmaxmatches(MMcallinfo *mmcallinfo , Multiseq *subjectmultiseq ) 
{ 
  Matchprocessinfo matchprocessinfo ;
  Uint filenum ;
  Uint filelen ;
  Sint retcode ;
  Uchar *filecontent ;
  Uint tmp ;
  Sint tmp___0 ;
  double tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  Sint tmp___5 ;
  int tmp___6 ;
  Sint tmp___7 ;
  Sint tmp___8 ;

  {
  {
#line 499
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# construct suffix tree for sequence of length %lu\n",
          (Showuint )subjectmultiseq->totallength);
#line 501
  tmp = getmaxtextlenstree();
#line 501
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# (maximum reference length is %lu)\n",
          (Showuint )tmp);
#line 503
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# (maximum query length is %lu)\n",
          (Showuint )(~ ((Uint )0)));
#line 505
  tmp___0 = constructprogressstree(& matchprocessinfo.stree, subjectmultiseq->sequence,
                                   subjectmultiseq->totallength, (void (*)(Uint  ,
                                                                           void * ))((void *)0),
                                   (void (*)(void * ))((void *)0), (void *)0);
  }
#line 505
  if (tmp___0 != 0) {
#line 512
    return (-1);
  }
  {
#line 514
  tmp___1 = getruntime();
#line 514
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# CONSTRUCTIONTIME %s %s %.2f\n",
          & mmcallinfo->program[0], & mmcallinfo->subjectfile[0], tmp___1);
#line 517
  matchprocessinfo.subjectmultiseq = subjectmultiseq;
#line 518
  matchprocessinfo.minmatchlength = mmcallinfo->minmatchlength;
#line 519
  matchprocessinfo.showstring = mmcallinfo->showstring;
#line 520
  matchprocessinfo.showsequencelengths = mmcallinfo->showsequencelengths;
#line 521
  matchprocessinfo.showreversepositions = mmcallinfo->showreversepositions;
#line 522
  matchprocessinfo.forward = mmcallinfo->forward;
#line 523
  matchprocessinfo.fourcolumn = mmcallinfo->fourcolumn;
#line 524
  matchprocessinfo.cmum = mmcallinfo->cmum;
#line 525
  matchprocessinfo.cmumcand = mmcallinfo->cmumcand;
#line 526
  matchprocessinfo.reversecomplement = mmcallinfo->reversecomplement;
  }
#line 527
  if (mmcallinfo->cmum) {
#line 529
    matchprocessinfo.mumcandtab.spaceMUMcandidate = (MUMcandidate *)((void *)0);
#line 529
    matchprocessinfo.mumcandtab.nextfreeMUMcandidate = (Uint )0;
#line 529
    matchprocessinfo.mumcandtab.allocatedMUMcandidate = matchprocessinfo.mumcandtab.nextfreeMUMcandidate;
  }
  {
#line 531
  retcode = getmaxdesclen(subjectmultiseq);
  }
#line 532
  if (retcode < 0) {
#line 534
    return (-2);
  }
#line 536
  matchprocessinfo.maxdesclength = (Uint )retcode;
#line 537
  filenum = (Uint )0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (filenum < mmcallinfo->numofqueryfiles)) {
#line 537
      goto while_break;
    }
    {
#line 539
    tmp___2 = creatememorymap((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c",
                              (Uint )541, mmcallinfo->queryfilelist[filenum], (unsigned char)1,
                              & filelen);
#line 539
    filecontent = (Uchar *)tmp___2;
    }
#line 542
    if ((unsigned long )filecontent == (unsigned long )((void *)0)) {
#line 542
      goto _L;
    } else
#line 542
    if (filelen == 0U) {
      _L: /* CIL Label */ 
      {
#line 544
      tmp___3 = messagespace();
#line 544
      tmp___4 = sprintf((char */* __restrict  */)tmp___3, (char const   */* __restrict  */)"cannot open file \"%s\" or file \"%s\" is empty",
                        mmcallinfo->queryfilelist[filenum], mmcallinfo->queryfilelist[filenum]);
#line 544
      tmp___5 = maxerrormsg();
      }
#line 544
      if (tmp___4 >= tmp___5) {
        {
#line 544
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
                "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c",
                (Showuint )546);
#line 544
        exit(1);
        }
      }
#line 547
      return (-3);
    }
#line 549
    if (mmcallinfo->matchnucleotidesonly) {
#line 549
      tmp___6 = 251;
    } else {
#line 549
      tmp___6 = 0;
    }
    {
#line 549
    tmp___7 = scanmultiplefastafile(& matchprocessinfo.querymultiseq, mmcallinfo->queryfilelist[filenum],
                                    (Uchar )tmp___6, filecontent, filelen);
    }
#line 549
    if (tmp___7 != 0) {
#line 556
      return (-4);
    }
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# matching query-file \"%s\"\n# against subject-file \"%s\"\n",
            mmcallinfo->queryfilelist[filenum], mmcallinfo->subjectfile);
#line 562
    tmp___8 = overallsequences((unsigned char)0, & matchprocessinfo.querymultiseq,
                               (void *)(& matchprocessinfo), & findmaxmatchesonbothstrands);
    }
#line 562
    if (tmp___8 != 0) {
#line 567
      return (-5);
    }
    {
#line 569
    freemultiseq(& matchprocessinfo.querymultiseq);
#line 537
    filenum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  if (mmcallinfo->cmum) {
#line 573
    if ((unsigned long )matchprocessinfo.mumcandtab.spaceMUMcandidate != (unsigned long )((void *)0)) {
#line 573
      if ((unsigned long )matchprocessinfo.mumcandtab.spaceMUMcandidate != (unsigned long )((void *)0)) {
        {
#line 573
        freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/procmaxmat.c",
                        (Uint )573, (void *)matchprocessinfo.mumcandtab.spaceMUMcandidate);
#line 573
        matchprocessinfo.mumcandtab.spaceMUMcandidate = (MUMcandidate *)((void *)0);
        }
      }
    }
  }
  {
#line 575
  freestree(& matchprocessinfo.stree);
  }
#line 576
  return (0);
}
}
#line 92 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
Bref firstbranchingnode(Suffixtree *stree ) ;
#line 93
Bref nextbranchingnode(Suffixtree *stree , Bref bptr ) ;
#line 94
Lref firstleaf(Suffixtree *stree ) ;
#line 95
Lref nextleaf(Suffixtree *stree , Lref lptr ) ;
#line 96
Reference *firstnode(Suffixtree *stree , Reference *refspace ) ;
#line 97
Reference *nextnode(Suffixtree *stree , Reference *nref , Reference *refspace ) ;
#line 99
Reference *firstsucc(Suffixtree *stree , Bref bptr , Reference *refspace ) ;
#line 101
Reference *rightbrother(Suffixtree *stree , Reference *node ) ;
#line 102
Reference *firstnodedfs(Suffixtree *stree , DFSstate *dfsstate , Reference *current ) ;
#line 104
Reference *nextnodedfs(Suffixtree *stree , Reference *current , DFSstate *dfsstate ) ;
#line 32 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Bref firstbranchingnode(Suffixtree *stree ) 
{ 


  {
#line 34
  if ((unsigned long )stree->branchtab >= (unsigned long )stree->nextfreebranch) {
#line 36
    return ((Bref )((void *)0));
  }
#line 38
  return (stree->branchtab);
}
}
#line 47 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Bref nextbranchingnode(Suffixtree *stree , Bref bptr ) 
{ 
  Bref nodeptr ;

  {
#line 51
  if ((unsigned long )bptr < (unsigned long )stree->branchtab) {
#line 53
    return ((Bref )((void *)0));
  } else
#line 51
  if ((unsigned long )bptr >= (unsigned long )stree->nextfreebranch) {
#line 53
    return ((Bref )((void *)0));
  }
#line 55
  if (! (*bptr & (1U << ((1U << 5) - 1U)))) {
#line 57
    nodeptr = bptr + 5;
  } else {
#line 60
    nodeptr = bptr + 3;
  }
#line 62
  if ((unsigned long )nodeptr >= (unsigned long )stree->nextfreebranch) {
#line 64
    return ((Bref )((void *)0));
  }
#line 66
  return (nodeptr);
}
}
#line 73 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Lref firstleaf(Suffixtree *stree ) 
{ 


  {
#line 75
  return (stree->leaftab);
}
}
#line 84 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Lref nextleaf(Suffixtree *stree , Lref lptr ) 
{ 


  {
#line 86
  if ((unsigned long )lptr < (unsigned long )stree->leaftab) {
#line 88
    return ((Lref )((void *)0));
  } else
#line 86
  if ((unsigned long )lptr >= (unsigned long )(stree->leaftab + stree->textlen)) {
#line 88
    return ((Lref )((void *)0));
  }
#line 90
  return (lptr + 1);
}
}
#line 98 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Reference *firstnode(Suffixtree *stree , Reference *refspace ) 
{ 


  {
#line 100
  if ((unsigned long )stree->branchtab >= (unsigned long )stree->nextfreebranch) {
#line 102
    return ((Reference *)((void *)0));
  }
#line 104
  refspace->toleaf = (unsigned char)0;
#line 105
  refspace->address = stree->branchtab;
#line 106
  return (refspace);
}
}
#line 115 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Reference *nextnode(Suffixtree *stree , Reference *nref , Reference *refspace ) 
{ 
  Lref lptr ;
  Lref bptr ;

  {
#line 120
  if (nref->toleaf) {
    {
#line 122
    lptr = nextleaf(stree, nref->address);
    }
#line 123
    if ((unsigned long )lptr == (unsigned long )((void *)0)) {
#line 125
      return ((Reference *)((void *)0));
    }
#line 127
    refspace->toleaf = (unsigned char)1;
#line 128
    refspace->address = lptr;
  } else {
    {
#line 131
    bptr = nextbranchingnode(stree, nref->address);
    }
#line 132
    if ((unsigned long )bptr == (unsigned long )((void *)0)) {
      {
#line 134
      refspace->toleaf = (unsigned char)1;
#line 135
      refspace->address = firstleaf(stree);
      }
#line 136
      return ((Reference *)((void *)0));
    }
#line 138
    refspace->toleaf = (unsigned char)0;
#line 139
    refspace->address = bptr;
  }
#line 141
  return (refspace);
}
}
#line 144 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
static void int2ref(Suffixtree *stree , Reference *ref , Uint i ) 
{ 


  {
#line 146
  if (i & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 148
    ref->toleaf = (unsigned char)1;
#line 149
    ref->address = stree->leaftab + (i & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
  } else {
#line 152
    ref->toleaf = (unsigned char)0;
#line 153
    ref->address = stree->branchtab + (i & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
  }
#line 155
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Reference *firstsucc(Suffixtree *stree , Bref bptr , Reference *refspace ) 
{ 


  {
#line 164
  if ((unsigned long )bptr < (unsigned long )stree->branchtab) {
#line 166
    return ((Reference *)((void *)0));
  } else
#line 164
  if ((unsigned long )bptr >= (unsigned long )stree->nextfreebranch) {
#line 166
    return ((Reference *)((void *)0));
  }
  {
#line 168
  int2ref(stree, refspace, *bptr & ((1U << ((1U << 5) - 1U)) - 1U));
  }
#line 169
  return (refspace);
}
}
#line 177 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Reference *rightbrother(Suffixtree *stree , Reference *node ) 
{ 
  Uint brotherval ;

  {
#line 181
  if (node->toleaf) {
#line 183
    brotherval = *(node->address);
  } else {
#line 186
    brotherval = *(node->address + 1);
  }
#line 188
  if (brotherval & (1U << ((1U << 5) - 1U))) {
#line 190
    return ((Reference *)((void *)0));
  }
  {
#line 192
  int2ref(stree, node, brotherval);
  }
#line 193
  return (node);
}
}
#line 200 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Reference *firstnodedfs(Suffixtree *stree , DFSstate *dfsstate , Reference *current ) 
{ 
  Uint tmp ;
  void *tmp___0 ;
  Uint tmp___1 ;

  {
#line 203
  if (! current->toleaf) {
#line 205
    dfsstate->secondtime = (unsigned char)0;
#line 206
    dfsstate->stack.spaceBref = (Bref *)((void *)0);
#line 206
    tmp = (Uint )0;
#line 206
    dfsstate->stack.nextfreeBref = tmp;
#line 206
    dfsstate->stack.allocatedBref = tmp;
#line 207
    if (dfsstate->stack.nextfreeBref >= dfsstate->stack.allocatedBref) {
      {
#line 207
      dfsstate->stack.allocatedBref += 128U;
#line 207
      tmp___0 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c",
                                       (Uint )207, (void *)dfsstate->stack.spaceBref,
                                       (Uint )sizeof(Bref ), dfsstate->stack.allocatedBref);
#line 207
      dfsstate->stack.spaceBref = (Bref *)tmp___0;
      }
    }
#line 207
    tmp___1 = dfsstate->stack.nextfreeBref;
#line 207
    (dfsstate->stack.nextfreeBref) ++;
#line 207
    *(dfsstate->stack.spaceBref + tmp___1) = current->address;
#line 208
    if ((*(current->address) & ((1U << ((1U << 5) - 1U)) - 1U)) & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 208
      current->address = stree->leaftab + ((*(current->address) & ((1U << ((1U << 5) - 1U)) - 1U)) & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 208
      current->toleaf = (unsigned char)1;
    } else {
#line 208
      current->address = stree->branchtab + ((*(current->address) & ((1U << ((1U << 5) - 1U)) - 1U)) & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 208
      current->toleaf = (unsigned char)0;
#line 208
      dfsstate->secondtime = (unsigned char)0;
    }
  }
#line 210
  return (current);
}
}
#line 218 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c"
Reference *nextnodedfs(Suffixtree *stree , Reference *current , DFSstate *dfsstate ) 
{ 
  Uint child ;
  Uint brotherval ;
  Uint tmp ;
  Uint tmp___0 ;
  void *tmp___1 ;
  Uint tmp___2 ;

  {
#line 223
  if (current->toleaf) {
#line 225
    if (dfsstate->stack.nextfreeBref == 0U) {
#line 227
      return ((Reference *)((void *)0));
    }
#line 229
    brotherval = *(current->address);
#line 230
    if (brotherval & (1U << ((1U << 5) - 1U))) {
#line 232
      if (dfsstate->stack.nextfreeBref == 1U) {
#line 234
        dfsstate->stack.spaceBref = (Bref *)((void *)0);
#line 234
        tmp = (Uint )0;
#line 234
        dfsstate->stack.nextfreeBref = tmp;
#line 234
        dfsstate->stack.allocatedBref = tmp;
#line 235
        return ((Reference *)((void *)0));
      }
#line 237
      (dfsstate->stack.nextfreeBref) --;
#line 238
      current->address = *(dfsstate->stack.spaceBref + dfsstate->stack.nextfreeBref);
#line 239
      current->toleaf = (unsigned char)0;
#line 240
      dfsstate->secondtime = (unsigned char)1;
    } else
#line 243
    if (brotherval & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 243
      current->address = stree->leaftab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 243
      current->toleaf = (unsigned char)1;
    } else {
#line 243
      current->address = stree->branchtab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 243
      current->toleaf = (unsigned char)0;
#line 243
      dfsstate->secondtime = (unsigned char)0;
    }
  } else
#line 247
  if (dfsstate->secondtime) {
#line 249
    brotherval = *(current->address + 1);
#line 250
    if (brotherval & (1U << ((1U << 5) - 1U))) {
#line 252
      if (dfsstate->stack.nextfreeBref == 1U) {
#line 254
        dfsstate->stack.spaceBref = (Bref *)((void *)0);
#line 254
        tmp___0 = (Uint )0;
#line 254
        dfsstate->stack.nextfreeBref = tmp___0;
#line 254
        dfsstate->stack.allocatedBref = tmp___0;
#line 255
        return ((Reference *)((void *)0));
      }
#line 257
      (dfsstate->stack.nextfreeBref) --;
#line 258
      current->address = *(dfsstate->stack.spaceBref + dfsstate->stack.nextfreeBref);
#line 259
      current->toleaf = (unsigned char)0;
#line 260
      dfsstate->secondtime = (unsigned char)1;
    } else
#line 263
    if (brotherval & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 263
      current->address = stree->leaftab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 263
      current->toleaf = (unsigned char)1;
    } else {
#line 263
      current->address = stree->branchtab + (brotherval & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 263
      current->toleaf = (unsigned char)0;
#line 263
      dfsstate->secondtime = (unsigned char)0;
    }
  } else {
#line 267
    if (dfsstate->stack.nextfreeBref >= dfsstate->stack.allocatedBref) {
      {
#line 267
      dfsstate->stack.allocatedBref += 128U;
#line 267
      tmp___1 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/iterator.c",
                                       (Uint )267, (void *)dfsstate->stack.spaceBref,
                                       (Uint )sizeof(Bref ), dfsstate->stack.allocatedBref);
#line 267
      dfsstate->stack.spaceBref = (Bref *)tmp___1;
      }
    }
#line 267
    tmp___2 = dfsstate->stack.nextfreeBref;
#line 267
    (dfsstate->stack.nextfreeBref) ++;
#line 267
    *(dfsstate->stack.spaceBref + tmp___2) = current->address;
#line 270
    child = *(current->address) & ((1U << ((1U << 5) - 1U)) - 1U);
#line 271
    if (child & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 271
      current->address = stree->leaftab + (child & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 271
      current->toleaf = (unsigned char)1;
    } else {
#line 271
      current->address = stree->branchtab + (child & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 271
      current->toleaf = (unsigned char)0;
#line 271
      dfsstate->secondtime = (unsigned char)0;
    }
  }
#line 274
  return (current);
}
}
#line 37 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
void getbranchinfostree(Suffixtree *stree , Uint whichinfo , Branchinfo *branchinfo ,
                        Bref btptr ) ;
#line 68
void rescanstree(Suffixtree *stree , Location *loc , Bref btptr , SYMBOL *left , SYMBOL *right ) ;
#line 14 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/linkloc.c"
void rescanstree(Suffixtree *stree , Location *loc , Bref btptr , SYMBOL *left , SYMBOL *right ) 
{ 
  Uint *nodeptr ;
  Uint *largeptr ;
  Uint leafindex ;
  Uint nodedepth ;
  Uint node ;
  Uint distance ;
  Uint prefixlen ;
  Uint headposition ;
  Uint tmpnodedepth ;
  SYMBOL *lptr ;

  {
#line 17
  largeptr = (Uint *)((void *)0);
#line 17
  distance = (Uint )0;
#line 21
  lptr = left;
#line 22
  nodeptr = btptr;
#line 23
  if ((unsigned long )nodeptr == (unsigned long )stree->branchtab) {
#line 25
    nodedepth = (Uint )0;
#line 26
    headposition = (Uint )0;
  } else
#line 29
  if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 29
    if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 29
      distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 29
      nodedepth = stree->currentdepth + distance;
#line 29
      headposition = stree->nextfreeleafnum - distance;
    } else {
#line 29
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 29
  if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 29
    nodedepth = *(nodeptr + 2);
#line 29
    headposition = *(nodeptr + 3);
  } else {
#line 29
    distance = *(nodeptr + 2);
#line 29
    largeptr = nodeptr + distance * 3U;
#line 29
    nodedepth = *(largeptr + 2) + distance;
#line 29
    headposition = *(largeptr + 3) - distance;
  }
#line 31
  loc->nextnode.toleaf = (unsigned char)0;
#line 32
  loc->nextnode.address = nodeptr;
#line 33
  loc->locstring.start = headposition;
#line 34
  loc->locstring.length = nodedepth;
#line 35
  loc->remain = (Uint )0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if ((unsigned long )lptr > (unsigned long )right) {
#line 40
      return;
    }
#line 42
    if ((unsigned long )nodeptr == (unsigned long )stree->branchtab) {
#line 44
      node = *(stree->rootchildren + (Uint )*lptr);
#line 45
      prefixlen = (Uint )((right - lptr) + 1L);
#line 46
      if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 48
        leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 49
        loc->firstptr = stree->text + leafindex;
#line 50
        loc->previousnode = stree->branchtab;
#line 51
        loc->edgelen = (stree->textlen - leafindex) + 1U;
#line 52
        loc->remain = loc->edgelen - prefixlen;
#line 53
        loc->nextnode.toleaf = (unsigned char)1;
#line 54
        loc->nextnode.address = stree->leaftab + leafindex;
#line 55
        loc->locstring.start = leafindex;
#line 56
        loc->locstring.length = prefixlen;
#line 57
        return;
      }
#line 59
      nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 60
      if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 60
        if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 60
          distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 60
          headposition = stree->nextfreeleafnum - distance;
        } else {
#line 60
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 60
      if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 60
        headposition = *(nodeptr + 3);
      } else {
#line 60
        distance = *(nodeptr + 2);
#line 60
        largeptr = nodeptr + distance * 3U;
#line 60
        headposition = *(largeptr + 3) - distance;
      }
#line 61
      loc->firstptr = stree->text + headposition;
    } else {
#line 64
      node = *nodeptr & ((1U << ((1U << 5) - 1U)) - 1U);
      {
#line 65
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 67
        if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 69
          leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 70
          loc->firstptr = stree->text + (nodedepth + leafindex);
#line 71
          if ((int )*(loc->firstptr) == (int )*lptr) {
#line 73
            prefixlen = (Uint )((right - lptr) + 1L);
#line 74
            loc->previousnode = loc->nextnode.address;
#line 75
            loc->edgelen = (stree->textlen - (nodedepth + leafindex)) + 1U;
#line 76
            loc->remain = loc->edgelen - prefixlen;
#line 77
            loc->nextnode.toleaf = (unsigned char)1;
#line 78
            loc->nextnode.address = stree->leaftab + leafindex;
#line 79
            loc->locstring.start = leafindex;
#line 80
            loc->locstring.length = nodedepth + prefixlen;
#line 81
            return;
          }
#line 83
          node = *(stree->leaftab + leafindex);
        } else {
#line 86
          nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 87
          if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 87
            if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 87
              distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 87
              headposition = stree->nextfreeleafnum - distance;
            } else {
#line 87
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 87
          if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 87
            headposition = *(nodeptr + 3);
          } else {
#line 87
            distance = *(nodeptr + 2);
#line 87
            largeptr = nodeptr + distance * 3U;
#line 87
            headposition = *(largeptr + 3) - distance;
          }
#line 88
          loc->firstptr = stree->text + (nodedepth + headposition);
#line 89
          if ((int )*(loc->firstptr) == (int )*lptr) {
#line 91
            goto while_break___0;
          }
#line 93
          node = *(nodeptr + 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 97
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 97
      if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 97
        distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 97
        tmpnodedepth = stree->currentdepth + distance;
      } else {
#line 97
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 97
    if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 97
      tmpnodedepth = *(nodeptr + 2);
    } else {
#line 97
      distance = *(nodeptr + 2);
#line 97
      largeptr = nodeptr + distance * 3U;
#line 97
      tmpnodedepth = *(largeptr + 2) + distance;
    }
#line 98
    loc->edgelen = tmpnodedepth - nodedepth;
#line 99
    prefixlen = (Uint )((right - lptr) + 1L);
#line 100
    loc->previousnode = loc->nextnode.address;
#line 101
    loc->nextnode.toleaf = (unsigned char)0;
#line 102
    loc->nextnode.address = nodeptr;
#line 103
    loc->locstring.start = headposition;
#line 104
    loc->locstring.length = nodedepth + prefixlen;
#line 105
    if (loc->edgelen > prefixlen) {
#line 107
      loc->remain = loc->edgelen - prefixlen;
#line 108
      return;
    }
#line 110
    if (loc->edgelen == prefixlen) {
#line 112
      loc->remain = (Uint )0;
#line 113
      return;
    }
#line 115
    lptr += loc->edgelen;
#line 116
    nodedepth = tmpnodedepth;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 120 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/linkloc.c"
void linklocstree(Suffixtree *stree , Location *outloc , Location *inloc ) 
{ 
  Branchinfo branchinfo ;

  {
#line 124
  if (inloc->remain == 0U) {
    {
#line 126
    outloc->remain = (Uint )0;
#line 127
    outloc->nextnode.toleaf = (unsigned char)0;
#line 128
    getbranchinfostree(stree, 1U << 2, & branchinfo, inloc->nextnode.address);
#line 130
    outloc->nextnode.address = branchinfo.suffixlink;
#line 131
    outloc->locstring.start = inloc->locstring.start + 1U;
#line 132
    outloc->locstring.length = inloc->locstring.length - 1U;
    }
  } else
#line 135
  if ((unsigned long )inloc->previousnode == (unsigned long )stree->branchtab) {
    {
#line 137
    rescanstree(stree, outloc, stree->branchtab, inloc->firstptr + 1, (inloc->firstptr + (inloc->edgelen - inloc->remain)) - 1);
    }
  } else {
    {
#line 141
    getbranchinfostree(stree, 1U << 2, & branchinfo, inloc->previousnode);
#line 143
    rescanstree(stree, outloc, branchinfo.suffixlink, inloc->firstptr, (inloc->firstptr + (inloc->edgelen - inloc->remain)) - 1);
    }
  }
#line 148
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmumcand.c"
static Sint checkiflocationisMUMcand(Location *loc , Uchar *subjectseq , Uchar *querysuffix ,
                                     Uchar *query , Uint seqnum , Sint (*processmumcandidate)(void * ,
                                                                                              Uint  ,
                                                                                              Uint  ,
                                                                                              Uint  ,
                                                                                              Uint  ) ,
                                     void *processinfo ) 
{ 
  Sint tmp ;

  {
#line 90
  if (loc->remain > 0U) {
#line 90
    if (loc->nextnode.toleaf) {
#line 90
      if ((unsigned long )querysuffix == (unsigned long )query) {
#line 90
        goto _L;
      } else
#line 90
      if (loc->locstring.start == 0U) {
#line 90
        goto _L;
      } else
#line 90
      if ((int )*(querysuffix - 1) != (int )*(subjectseq + (loc->locstring.start - 1U))) {
        _L: /* CIL Label */ 
        {
#line 96
        tmp = (*processmumcandidate)(processinfo, loc->locstring.length, loc->locstring.start,
                                     seqnum, (Uint )(querysuffix - query));
        }
#line 96
        if (tmp != 0) {
#line 103
          return (-1);
        }
      }
    }
  }
#line 106
  return (0);
}
}
#line 142 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/findmumcand.c"
Sint findmumcandidates(Suffixtree *stree , Uint minmatchlength , Sint (*processmumcandidate)(void * ,
                                                                                             Uint  ,
                                                                                             Uint  ,
                                                                                             Uint  ,
                                                                                             Uint  ) ,
                       void *processinfo , Uchar *query , Uint querylen , Uint seqnum ) 
{ 
  Uchar *lptr ;
  Uchar *right ;
  Uchar *querysuffix ;
  Location loc ;
  Sint tmp ;
  int tmp___0 ;
  Sint tmp___1 ;
  int tmp___2 ;

  {
  {
#line 150
  right = (query + querylen) - 1;
#line 158
  lptr = scanprefixfromnodestree(stree, & loc, stree->branchtab, query, right, (Uint )0);
#line 160
  querysuffix = query;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! ((unsigned long )lptr != (unsigned long )((void *)0))) {
#line 160
      goto while_break;
    }
#line 163
    if (loc.locstring.length >= minmatchlength) {
      {
#line 163
      tmp = checkiflocationisMUMcand(& loc, stree->text, querysuffix, query, seqnum,
                                     processmumcandidate, processinfo);
      }
#line 163
      if (tmp != 0) {
#line 171
        return (-1);
      }
    }
#line 173
    if (loc.locstring.length == 0U) {
#line 173
      tmp___0 = 1;
    } else {
#line 173
      tmp___0 = 0;
    }
#line 173
    if (tmp___0) {
      {
#line 175
      lptr = scanprefixfromnodestree(stree, & loc, stree->branchtab, lptr + 1, right,
                                     (Uint )0);
      }
    } else {
      {
#line 180
      linklocstree(stree, & loc, & loc);
#line 181
      lptr = scanprefixstree(stree, & loc, & loc, lptr, right, (Uint )0);
      }
    }
#line 160
    querysuffix ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 185
    if (loc.locstring.length == 0U) {
#line 185
      tmp___2 = 1;
    } else {
#line 185
      tmp___2 = 0;
    }
#line 185
    if (tmp___2) {
#line 185
      goto while_break___0;
    } else
#line 185
    if (! (loc.locstring.length >= minmatchlength)) {
#line 185
      goto while_break___0;
    }
    {
#line 187
    tmp___1 = checkiflocationisMUMcand(& loc, stree->text, querysuffix, query, seqnum,
                                       processmumcandidate, processinfo);
    }
#line 187
    if (tmp___1 != 0) {
#line 195
      return (-2);
    }
    {
#line 197
    linklocstree(stree, & loc, & loc);
#line 198
    querysuffix ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 201
  return (0);
}
}
#line 25 "../libbasedir/protodef.h"
extern void initclock(void) ;
#line 40
extern void mmcheckspaceleak(void) ;
#line 43
extern Uint mmgetspacepeak(void) ;
#line 78
extern void checkspaceleak(void) ;
#line 80
extern Uint getspacepeak(void) ;
#line 71 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmat3.c"
Sint getmaxmatinput(Multiseq *subjectmultiseq , unsigned char matchnucleotidesonly ,
                    char *subjectfile ) ;
#line 88 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmat3.c"
int main(Argctype argc , char **argv ) 
{ 
  Sint retcode ;
  MMcallinfo mmcallinfo ;
  Multiseq subjectmultiseq ;
  char *tmp ;
  char *tmp___0 ;
  Sint tmp___1 ;
  char *tmp___2 ;
  Sint tmp___3 ;
  double tmp___4 ;
  Uint tmp___5 ;
  Uint tmp___6 ;

  {
  {
#line 95
  initclock();
#line 96
  retcode = parsemaxmatoptions(& mmcallinfo, argc, argv);
  }
#line 97
  if (retcode < 0) {
    {
#line 99
    tmp = messagespace();
#line 99
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            *(argv + 0), tmp);
    }
#line 99
    return (1);
  }
#line 101
  if (retcode == 1) {
    {
#line 103
    checkspaceleak();
#line 104
    mmcheckspaceleak();
    }
#line 105
    return (0);
  }
  {
#line 108
  tmp___1 = getmaxmatinput(& subjectmultiseq, mmcallinfo.matchnucleotidesonly, & mmcallinfo.subjectfile[0]);
  }
#line 108
  if (tmp___1 != 0) {
    {
#line 112
    tmp___0 = messagespace();
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            *(argv + 0), tmp___0);
    }
#line 112
    return (1);
  }
  {
#line 114
  tmp___3 = procmaxmatches(& mmcallinfo, & subjectmultiseq);
  }
#line 114
  if (tmp___3 != 0) {
    {
#line 116
    tmp___2 = messagespace();
#line 116
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            *(argv + 0), tmp___2);
    }
#line 116
    return (1);
  }
  {
#line 118
  freemultiseq(& subjectmultiseq);
#line 119
  checkspaceleak();
#line 120
  mmcheckspaceleak();
#line 121
  tmp___4 = getruntime();
#line 121
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# COMPLETETIME %s %s %.2f\n",
          *(argv + 0), & mmcallinfo.subjectfile[0], tmp___4);
#line 124
  tmp___5 = getspacepeak();
#line 124
  tmp___6 = mmgetspacepeak();
#line 124
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# SPACE %s %s %.2f\n",
          *(argv + 0), & mmcallinfo.subjectfile[0], (double )(tmp___5 + tmp___6) / (double )((1U << 20) - 1U));
  }
#line 127
  return (0);
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 20 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
Sint constructstree(Suffixtree *stree , SYMBOL *text , Uint textlen ) ;
#line 21
Sint constructmarkmaxstree(Suffixtree *stree , SYMBOL *text , Uint textlen ) ;
#line 22
Sint constructheadstree(Suffixtree *stree , SYMBOL *text , Uint textlen , void (*processhead)(Suffixtree * ,
                                                                                              Uint  ,
                                                                                              void * ) ,
                        void *processheadinfo ) ;
#line 100 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static void spaceforbranchtab(Suffixtree *stree ) 
{ 
  Uint tmpheadnode ;
  Uint tmpchainstart ;
  Uint extra ;
  void *tmp ;

  {
#line 104
  if ((unsigned long )stree->nextfreebranch >= (unsigned long )stree->firstnotallocated) {
#line 106
    tmpchainstart = (Uint )0;
#line 106
    extra = (Uint )(0.05 * (double )((stree->textlen + 1U) * 3U));
#line 109
    if (extra < 16U) {
#line 111
      extra = (Uint )48;
    }
#line 117
    stree->currentbranchtabsize += extra;
#line 118
    tmpheadnode = (Uint )(stree->headnode - stree->branchtab);
#line 119
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 121
      tmpchainstart = (Uint )(stree->chainstart - stree->branchtab);
    }
    {
#line 124
    tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c",
                                 (Uint )125, (void *)stree->branchtab, (Uint )sizeof(Uint ),
                                 stree->currentbranchtabsize);
#line 124
    stree->branchtab = (Uint *)tmp;
#line 126
    stree->nextfreebranch = stree->branchtab + stree->nextfreebranchnum;
#line 127
    stree->headnode = stree->branchtab + tmpheadnode;
    }
#line 128
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 130
      stree->chainstart = stree->branchtab + tmpchainstart;
    }
#line 132
    stree->firstnotallocated = (stree->branchtab + stree->currentbranchtabsize) - 5;
  }
#line 135
  return;
}
}
#line 369 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static Uint getlargelinkconstruction(Suffixtree *stree ) 
{ 
  SYMBOL secondchar ;

  {
#line 376
  if (stree->headnodedepth == 1U) {
#line 378
    return ((Uint )0);
  }
#line 380
  if (stree->headnodedepth == 2U) {
#line 382
    if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
#line 384
      secondchar = *(stree->tailptr - 1);
    } else {
#line 387
      secondchar = *(stree->tailptr - ((stree->headend - stree->headstart) + 2L));
    }
#line 389
    return (*(stree->rootchildren + (Uint )secondchar));
  }
#line 391
  return (*(stree->headnode + 4));
}
}
#line 405 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static void insertleaf(Suffixtree *stree ) 
{ 
  Uint *ptr ;
  Uint newleaf ;

  {
#line 410
  newleaf = stree->nextfreeleafnum | ((1U << ((1U << 5) - 1U)) >> 1);
#line 412
  if (stree->headnodedepth == 0U) {
#line 414
    if ((unsigned long )stree->tailptr != (unsigned long )stree->sentinel) {
#line 416
      *(stree->rootchildren + (Uint )*(stree->tailptr)) = newleaf;
#line 417
      *(stree->nextfreeleafptr) = (Uint )0;
    }
  } else
#line 423
  if (stree->insertprev == 4294967295U) {
#line 425
    *(stree->nextfreeleafptr) = *(stree->headnode) & ((1U << ((1U << 5) - 1U)) - 1U);
#line 426
    *(stree->headnode) = (*(stree->headnode) & (1U << ((1U << 5) - 1U))) | newleaf;
  } else
#line 429
  if (stree->insertprev & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 431
    ptr = stree->leaftab + (stree->insertprev & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 432
    *(stree->nextfreeleafptr) = *ptr;
#line 433
    *ptr = newleaf;
  } else {
#line 436
    ptr = stree->branchtab + (stree->insertprev & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 437
    *(stree->nextfreeleafptr) = *(ptr + 1);
#line 438
    *(ptr + 1) = newleaf;
  }
#line 443
  (stree->nextfreeleafnum) ++;
#line 444
  (stree->nextfreeleafptr) ++;
#line 445
  return;
}
}
#line 456 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static void insertbranchnode(Suffixtree *stree ) 
{ 
  Uint *ptr ;
  Uint *insertnodeptr ;
  Uint *insertleafptr ;
  Uint insertnodeptrbrother ;

  {
  {
#line 461
  spaceforbranchtab(stree);
  }
#line 462
  if (stree->headnodedepth == 0U) {
#line 464
    *(stree->rootchildren + (Uint )*(stree->headstart)) = stree->nextfreebranchnum;
#line 466
    *(stree->nextfreebranch + 1) = (Uint )0;
  } else
#line 471
  if (stree->insertprev == 4294967295U) {
#line 473
    *(stree->headnode) = (*(stree->headnode) & (1U << ((1U << 5) - 1U))) | stree->nextfreebranchnum;
  } else
#line 476
  if (stree->insertprev & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 478
    ptr = stree->leaftab + (stree->insertprev & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 479
    *ptr = stree->nextfreebranchnum;
  } else {
#line 482
    *((stree->branchtab + (stree->insertprev & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))))) + 1) = stree->nextfreebranchnum;
  }
#line 487
  if (stree->insertnode & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 490
    insertleafptr = stree->leaftab + (stree->insertnode & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 491
    if ((unsigned long )stree->tailptr == (unsigned long )stree->sentinel) {
#line 494
      *(stree->nextfreebranch) = stree->insertnode;
#line 494
      *(stree->nextfreebranch + 1) = *insertleafptr;
#line 496
      stree->setlink = stree->nextfreeleafptr;
#line 496
      stree->setatnewleaf = (unsigned char)1;
#line 497
      *insertleafptr = stree->nextfreeleafnum | ((1U << ((1U << 5) - 1U)) >> 1);
    } else
#line 491
    if ((int )*(stree->headend + 1) < (int )*(stree->tailptr)) {
#line 494
      *(stree->nextfreebranch) = stree->insertnode;
#line 494
      *(stree->nextfreebranch + 1) = *insertleafptr;
#line 496
      stree->setlink = stree->nextfreeleafptr;
#line 496
      stree->setatnewleaf = (unsigned char)1;
#line 497
      *insertleafptr = stree->nextfreeleafnum | ((1U << ((1U << 5) - 1U)) >> 1);
    } else {
#line 501
      *(stree->nextfreebranch) = stree->nextfreeleafnum | ((1U << ((1U << 5) - 1U)) >> 1);
#line 501
      *(stree->nextfreebranch + 1) = *insertleafptr;
#line 503
      *(stree->nextfreeleafptr) = stree->insertnode;
#line 504
      stree->setlink = insertleafptr;
#line 504
      stree->setatnewleaf = (unsigned char)0;
    }
  } else {
#line 509
    insertnodeptr = stree->branchtab + (stree->insertnode & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 510
    insertnodeptrbrother = *(insertnodeptr + 1);
#line 511
    if ((unsigned long )stree->tailptr == (unsigned long )stree->sentinel) {
#line 514
      *(stree->nextfreebranch) = stree->insertnode;
#line 514
      *(stree->nextfreebranch + 1) = insertnodeptrbrother;
#line 516
      stree->setlink = stree->nextfreeleafptr;
#line 516
      stree->setatnewleaf = (unsigned char)1;
#line 517
      *(insertnodeptr + 1) = stree->nextfreeleafnum | ((1U << ((1U << 5) - 1U)) >> 1);
    } else
#line 511
    if ((int )*(stree->headend + 1) < (int )*(stree->tailptr)) {
#line 514
      *(stree->nextfreebranch) = stree->insertnode;
#line 514
      *(stree->nextfreebranch + 1) = insertnodeptrbrother;
#line 516
      stree->setlink = stree->nextfreeleafptr;
#line 516
      stree->setatnewleaf = (unsigned char)1;
#line 517
      *(insertnodeptr + 1) = stree->nextfreeleafnum | ((1U << ((1U << 5) - 1U)) >> 1);
    } else {
#line 520
      *(stree->nextfreebranch) = stree->nextfreeleafnum | ((1U << ((1U << 5) - 1U)) >> 1);
#line 520
      *(stree->nextfreebranch + 1) = insertnodeptrbrother;
#line 522
      *(stree->nextfreeleafptr) = stree->insertnode;
#line 523
      stree->setlink = insertnodeptr + 1;
#line 523
      stree->setatnewleaf = (unsigned char)0;
    }
  }
#line 526
  *(stree->setlink) = 1U << ((1U << 5) - 1U);
#line 528
  stree->currentdepth = stree->headnodedepth + (Uint )((stree->headend - stree->headstart) + 1L);
#line 529
  *(stree->nextfreebranch + 2) = stree->currentdepth;
#line 529
  *(stree->nextfreebranch + 3) = stree->nextfreeleafnum;
#line 530
  if (stree->currentdepth > stree->maxbranchdepth) {
#line 530
    stree->maxbranchdepth = stree->currentdepth;
  }
#line 531
  (stree->nextfreeleafnum) ++;
#line 532
  (stree->nextfreeleafptr) ++;
#line 534
  return;
}
}
#line 544 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static void rescan(Suffixtree *stree ) 
{ 
  Uint *nodeptr ;
  Uint *largeptr ;
  Uint distance ;
  Uint node ;
  Uint prevnode ;
  Uint nodedepth ;
  Uint edgelen ;
  Uint wlen ;
  Uint leafindex ;
  Uint headposition ;
  SYMBOL headchar ;
  SYMBOL edgechar ;

  {
#line 546
  largeptr = (Uint *)((void *)0);
#line 546
  distance = (Uint )0;
#line 551
  if (stree->headnodedepth == 0U) {
#line 553
    headchar = *(stree->headstart);
#line 554
    node = *(stree->rootchildren + (Uint )headchar);
#line 555
    if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 557
      stree->insertnode = node;
#line 558
      return;
    }
#line 560
    nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 561
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 561
      if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 561
        distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 561
        nodedepth = stree->currentdepth + distance;
      } else {
#line 561
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 561
    if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 561
      nodedepth = *(nodeptr + 2);
    } else {
#line 561
      distance = *(nodeptr + 2);
#line 561
      largeptr = nodeptr + distance * 3U;
#line 561
      nodedepth = *(largeptr + 2) + distance;
    }
#line 562
    wlen = (Uint )((stree->headend - stree->headstart) + 1L);
#line 563
    if (nodedepth > wlen) {
#line 565
      stree->insertnode = node;
#line 566
      return;
    }
#line 568
    stree->headnode = nodeptr;
#line 569
    stree->headnodedepth = nodedepth;
#line 570
    if (nodedepth == wlen) {
#line 572
      stree->headend = (SYMBOL *)((void *)0);
#line 573
      return;
    }
#line 575
    stree->headstart += nodedepth;
  }
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    headchar = *(stree->headstart);
#line 580
    prevnode = ~ ((Uint )0);
#line 581
    node = *(stree->headnode) & ((1U << ((1U << 5) - 1U)) - 1U);
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 584
      if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 586
        leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 587
        edgechar = *(stree->text + (stree->headnodedepth + leafindex));
#line 588
        if ((int )edgechar == (int )headchar) {
#line 590
          stree->insertnode = node;
#line 591
          stree->insertprev = prevnode;
#line 592
          return;
        }
#line 594
        prevnode = node;
#line 595
        node = *(stree->leaftab + leafindex);
      } else {
#line 598
        nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 599
        if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 599
          if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 599
            distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 599
            headposition = stree->nextfreeleafnum - distance;
          } else {
#line 599
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 599
        if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 599
          headposition = *(nodeptr + 3);
        } else {
#line 599
          distance = *(nodeptr + 2);
#line 599
          largeptr = nodeptr + distance * 3U;
#line 599
          headposition = *(largeptr + 3) - distance;
        }
#line 600
        edgechar = *(stree->text + (stree->headnodedepth + headposition));
#line 601
        if ((int )edgechar == (int )headchar) {
#line 603
          goto while_break___0;
        }
#line 605
        prevnode = node;
#line 606
        node = *(nodeptr + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 610
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 610
      if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 610
        nodedepth = stree->currentdepth + distance;
      } else {
#line 610
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 610
    if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 610
      nodedepth = *(nodeptr + 2);
    } else {
#line 610
      nodedepth = *(largeptr + 2) + distance;
    }
#line 611
    edgelen = nodedepth - stree->headnodedepth;
#line 612
    wlen = (Uint )((stree->headend - stree->headstart) + 1L);
#line 613
    if (edgelen > wlen) {
#line 615
      stree->insertnode = node;
#line 616
      stree->insertprev = prevnode;
#line 617
      return;
    }
#line 619
    stree->headnode = nodeptr;
#line 620
    stree->headnodedepth = nodedepth;
#line 621
    if (edgelen == wlen) {
#line 623
      stree->headend = (SYMBOL *)((void *)0);
#line 624
      return;
    }
#line 626
    stree->headstart += edgelen;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 637 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static Uint taillcp(Suffixtree *stree , SYMBOL *start1 , SYMBOL *end1 ) 
{ 
  SYMBOL *ptr1 ;
  SYMBOL *ptr2 ;

  {
#line 639
  ptr1 = start1;
#line 639
  ptr2 = stree->tailptr + 1;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if ((unsigned long )ptr1 <= (unsigned long )end1) {
#line 640
      if ((unsigned long )ptr2 < (unsigned long )stree->sentinel) {
#line 640
        if (! ((int )*ptr1 == (int )*ptr2)) {
#line 640
          goto while_break;
        }
      } else {
#line 640
        goto while_break;
      }
    } else {
#line 640
      goto while_break;
    }
#line 642
    ptr1 ++;
#line 643
    ptr2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 645
  return ((Uint )(ptr1 - start1));
}
}
#line 653 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static void scanprefix(Suffixtree *stree ) 
{ 
  Uint *nodeptr ;
  Uint *largeptr ;
  Uint leafindex ;
  Uint nodedepth ;
  Uint edgelen ;
  Uint node ;
  Uint distance ;
  Uint prevnode ;
  Uint prefixlen ;
  Uint headposition ;
  SYMBOL *leftborder ;
  SYMBOL tailchar ;
  SYMBOL edgechar ;
  Uint tmp ;
  Uint tmp___0 ;
  Uint tmp___1 ;
  Uint tmp___2 ;

  {
#line 655
  nodeptr = (Uint *)((void *)0);
#line 655
  largeptr = (Uint *)((void *)0);
#line 655
  distance = (Uint )0;
#line 657
  leftborder = (SYMBOL *)((void *)0);
#line 657
  edgechar = (SYMBOL )0;
#line 660
  if (stree->headnodedepth == 0U) {
#line 662
    if ((unsigned long )stree->tailptr == (unsigned long )stree->sentinel) {
#line 664
      stree->headend = (SYMBOL *)((void *)0);
#line 665
      return;
    }
#line 667
    tailchar = *(stree->tailptr);
#line 668
    node = *(stree->rootchildren + (Uint )tailchar);
#line 668
    if (node == 4294967295U) {
#line 670
      stree->headend = (SYMBOL *)((void *)0);
#line 671
      return;
    }
#line 673
    if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
      {
#line 675
      leftborder = stree->text + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 676
      tmp = taillcp(stree, leftborder + 1, stree->sentinel - 1);
#line 676
      prefixlen = 1U + tmp;
#line 677
      stree->tailptr += prefixlen;
#line 678
      stree->headstart = leftborder;
#line 679
      stree->headend = leftborder + (prefixlen - 1U);
#line 680
      stree->insertnode = node;
      }
#line 681
      return;
    }
#line 683
    nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 684
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 684
      if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 684
        distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 684
        nodedepth = stree->currentdepth + distance;
#line 684
        headposition = stree->nextfreeleafnum - distance;
      } else {
#line 684
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 684
    if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 684
      nodedepth = *(nodeptr + 2);
#line 684
      headposition = *(nodeptr + 3);
    } else {
#line 684
      distance = *(nodeptr + 2);
#line 684
      largeptr = nodeptr + distance * 3U;
#line 684
      nodedepth = *(largeptr + 2) + distance;
#line 684
      headposition = *(largeptr + 3) - distance;
    }
    {
#line 685
    leftborder = stree->text + headposition;
#line 686
    tmp___0 = taillcp(stree, leftborder + 1, (leftborder + nodedepth) - 1);
#line 686
    prefixlen = 1U + tmp___0;
#line 687
    stree->tailptr += prefixlen;
    }
#line 688
    if (nodedepth > prefixlen) {
#line 690
      stree->headstart = leftborder;
#line 691
      stree->headend = leftborder + (prefixlen - 1U);
#line 692
      stree->insertnode = node;
#line 693
      return;
    }
#line 695
    stree->headnode = nodeptr;
#line 696
    stree->headnodedepth = nodedepth;
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    prevnode = ~ ((Uint )0);
#line 701
    node = *(stree->headnode) & ((1U << ((1U << 5) - 1U)) - 1U);
#line 702
    if ((unsigned long )stree->tailptr == (unsigned long )stree->sentinel) {
      {
#line 704
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 706
        prevnode = node;
#line 707
        if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 709
          node = *(stree->leaftab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)))));
        } else {
#line 712
          node = *((stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))))) + 1);
        }
#line 704
        if (! (! (node & (1U << ((1U << 5) - 1U))))) {
#line 704
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 715
      stree->insertnode = 1U << ((1U << 5) - 1U);
#line 716
      stree->insertprev = prevnode;
#line 717
      stree->headend = (SYMBOL *)((void *)0);
#line 718
      return;
    }
#line 720
    tailchar = *(stree->tailptr);
    {
#line 722
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 724
      if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 726
        leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 727
        leftborder = stree->text + (stree->headnodedepth + leafindex);
#line 728
        edgechar = *leftborder;
#line 728
        if ((int )edgechar >= (int )tailchar) {
#line 730
          goto while_break___1;
        }
#line 732
        prevnode = node;
#line 733
        node = *(stree->leaftab + leafindex);
      } else {
#line 736
        nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 737
        if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 737
          if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 737
            distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 737
            headposition = stree->nextfreeleafnum - distance;
          } else {
#line 737
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 737
        if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 737
          headposition = *(nodeptr + 3);
        } else {
#line 737
          distance = *(nodeptr + 2);
#line 737
          largeptr = nodeptr + distance * 3U;
#line 737
          headposition = *(largeptr + 3) - distance;
        }
#line 738
        leftborder = stree->text + (stree->headnodedepth + headposition);
#line 739
        edgechar = *leftborder;
#line 739
        if ((int )edgechar >= (int )tailchar) {
#line 741
          goto while_break___1;
        }
#line 743
        prevnode = node;
#line 744
        node = *(nodeptr + 1);
      }
#line 722
      if (! (! (node & (1U << ((1U << 5) - 1U))))) {
#line 722
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 747
    if (node & (1U << ((1U << 5) - 1U))) {
#line 749
      stree->insertprev = prevnode;
#line 750
      stree->headend = (SYMBOL *)((void *)0);
#line 751
      return;
    } else
#line 747
    if ((int )edgechar > (int )tailchar) {
#line 749
      stree->insertprev = prevnode;
#line 750
      stree->headend = (SYMBOL *)((void *)0);
#line 751
      return;
    }
#line 753
    if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
      {
#line 755
      tmp___1 = taillcp(stree, leftborder + 1, stree->sentinel - 1);
#line 755
      prefixlen = 1U + tmp___1;
#line 756
      stree->tailptr += prefixlen;
#line 757
      stree->headstart = leftborder;
#line 758
      stree->headend = leftborder + (prefixlen - 1U);
#line 759
      stree->insertnode = node;
#line 760
      stree->insertprev = prevnode;
      }
#line 761
      return;
    }
#line 763
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 763
      if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 763
        nodedepth = stree->currentdepth + distance;
      } else {
#line 763
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 763
    if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 763
      nodedepth = *(nodeptr + 2);
    } else {
#line 763
      nodedepth = *(largeptr + 2) + distance;
    }
    {
#line 764
    edgelen = nodedepth - stree->headnodedepth;
#line 765
    tmp___2 = taillcp(stree, leftborder + 1, (leftborder + edgelen) - 1);
#line 765
    prefixlen = 1U + tmp___2;
#line 766
    stree->tailptr += prefixlen;
    }
#line 767
    if (edgelen > prefixlen) {
#line 769
      stree->headstart = leftborder;
#line 770
      stree->headend = leftborder + (prefixlen - 1U);
#line 771
      stree->insertnode = node;
#line 772
      stree->insertprev = prevnode;
#line 773
      return;
    }
#line 775
    stree->headnode = nodeptr;
#line 776
    stree->headnodedepth = nodedepth;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 788 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static void completelarge(Suffixtree *stree ) 
{ 
  Uint distance ;
  Uint *backwards ;

  {
#line 793
  if (stree->smallnotcompleted > 0U) {
#line 795
    backwards = stree->nextfreebranch;
#line 796
    distance = (Uint )1;
    {
#line 796
    while (1) {
      while_continue: /* CIL Label */ ;
#line 796
      if (! (distance <= stree->smallnotcompleted)) {
#line 796
        goto while_break;
      }
#line 798
      backwards -= 3;
#line 799
      *(backwards + 2) = distance;
#line 799
      *backwards |= 1U << ((1U << 5) - 1U);
#line 796
      distance ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 801
    stree->smallnotcompleted = (Uint )0;
#line 802
    stree->chainstart = (Uint *)((void *)0);
  }
#line 804
  stree->nextfreebranch += 5;
#line 805
  stree->nextfreebranchnum += 5U;
#line 806
  (stree->largenode) ++;
#line 807
  return;
}
}
#line 815 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static void linkrootchildren(Suffixtree *stree ) 
{ 
  Uint *rcptr ;
  Uint *prevnodeptr ;
  Uint prev ;

  {
#line 817
  prev = ~ ((Uint )0);
#line 820
  stree->alphasize = (Uint )0;
#line 821
  rcptr = stree->rootchildren;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! ((unsigned long )rcptr <= (unsigned long )(stree->rootchildren + 255))) {
#line 821
      goto while_break;
    }
#line 824
    if (*rcptr != 4294967295U) {
#line 826
      (stree->alphasize) ++;
#line 827
      if (prev == 4294967295U) {
#line 829
        *(stree->branchtab) = (*(stree->branchtab) & (1U << ((1U << 5) - 1U))) | *rcptr;
      } else
#line 832
      if (prev & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 834
        *(stree->leaftab + (prev & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))))) = *rcptr;
      } else {
#line 837
        prevnodeptr = stree->branchtab + (prev & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 838
        *(prevnodeptr + 1) = *rcptr;
      }
#line 841
      prev = *rcptr;
    }
#line 821
    rcptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 844
  if (prev & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 846
    *(stree->leaftab + (prev & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))))) = stree->textlen | ((1U << ((1U << 5) - 1U)) >> 1);
  } else {
#line 849
    prevnodeptr = stree->branchtab + (prev & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 850
    *(prevnodeptr + 1) = stree->textlen | ((1U << ((1U << 5) - 1U)) >> 1);
  }
#line 852
  *(stree->leaftab + stree->textlen) = 1U << ((1U << 5) - 1U);
#line 853
  return;
}
}
#line 861 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
static void initSuffixtree(Suffixtree *stree , SYMBOL *text , Uint textlen ) 
{ 
  Uint i ;
  Uint *ptr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  SYMBOL *tmp___2 ;
  Uint *tmp___3 ;
  Uint tmp___4 ;
  Uint tmp___5 ;
  Uint tmp___6 ;

  {
#line 870
  stree->currentbranchtabsize = (Uint )(0.5 * (double )((textlen + 1U) * 3U));
#line 872
  if (stree->currentbranchtabsize < 16U) {
#line 874
    stree->currentbranchtabsize = (Uint )48;
  }
  {
#line 876
  tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c",
                               (Uint )876, (void *)0, (Uint )sizeof(Uint ), textlen + 2U);
#line 876
  stree->leaftab = (Uint *)tmp;
#line 877
  tmp___0 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c",
                                   (Uint )877, (void *)0, (Uint )sizeof(Uint ), (Uint )256);
#line 877
  stree->rootchildren = (Uint *)tmp___0;
#line 878
  tmp___1 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c",
                                   (Uint )878, (void *)0, (Uint )sizeof(Uint ), stree->currentbranchtabsize);
#line 878
  stree->branchtab = (Uint *)tmp___1;
#line 880
  tmp___2 = text;
#line 880
  stree->tailptr = tmp___2;
#line 880
  stree->text = tmp___2;
#line 881
  stree->textlen = textlen;
#line 882
  stree->sentinel = text + textlen;
#line 883
  stree->firstnotallocated = (stree->branchtab + stree->currentbranchtabsize) - 5;
#line 885
  tmp___3 = stree->branchtab;
#line 885
  stree->nextfreebranch = tmp___3;
#line 885
  stree->headnode = tmp___3;
#line 886
  stree->headend = (SYMBOL *)((void *)0);
#line 887
  tmp___4 = (Uint )0;
#line 887
  stree->maxbranchdepth = tmp___4;
#line 887
  stree->headnodedepth = tmp___4;
#line 888
  ptr = stree->rootchildren;
  }
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 888
    if (! ((unsigned long )ptr <= (unsigned long )(stree->rootchildren + 255))) {
#line 888
      goto while_break;
    }
#line 890
    *ptr = ~ ((Uint )0);
#line 888
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 892
  i = (Uint )0;
  {
#line 892
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 892
    if (! (i < 5U)) {
#line 892
      goto while_break___0;
    }
#line 894
    *(stree->branchtab + i) = (Uint )0;
#line 892
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 896
  stree->nextfreebranch = stree->branchtab;
#line 897
  stree->nextfreebranchnum = (Uint )0;
#line 898
  *(stree->nextfreebranch + 2) = (Uint )0;
#line 898
  *(stree->nextfreebranch + 3) = (Uint )0;
#line 899
  *(stree->nextfreebranch) = (1U << ((1U << 5) - 1U)) >> 1;
#line 899
  *(stree->nextfreebranch + 1) = (Uint )0;
#line 901
  *(stree->rootchildren + (Uint )*text) = (1U << ((1U << 5) - 1U)) >> 1;
#line 902
  *(stree->leaftab + 0) = (Uint )0;
#line 904
  stree->leafcounts = (Uint *)((void *)0);
#line 905
  stree->nextfreeleafnum = (Uint )1;
#line 906
  stree->nextfreeleafptr = stree->leaftab + 1;
#line 907
  stree->nextfreebranch = stree->branchtab + 5;
#line 908
  stree->nextfreebranchnum = (Uint )5;
#line 909
  tmp___5 = ~ ((Uint )0);
#line 909
  stree->insertprev = tmp___5;
#line 909
  stree->insertnode = tmp___5;
#line 910
  stree->smallnotcompleted = (Uint )0;
#line 911
  stree->chainstart = (Uint *)((void *)0);
#line 912
  tmp___6 = (Uint )0;
#line 912
  stree->smallnode = tmp___6;
#line 912
  stree->largenode = tmp___6;
#line 931
  return;
}
}
#line 933 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c"
void freestree(Suffixtree *stree ) 
{ 


  {
#line 935
  if ((unsigned long )stree->leaftab != (unsigned long )((void *)0)) {
    {
#line 935
    freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c",
                    (Uint )935, (void *)stree->leaftab);
#line 935
    stree->leaftab = (Uint *)((void *)0);
    }
  }
#line 936
  if ((unsigned long )stree->rootchildren != (unsigned long )((void *)0)) {
    {
#line 936
    freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c",
                    (Uint )936, (void *)stree->rootchildren);
#line 936
    stree->rootchildren = (Uint *)((void *)0);
    }
  }
#line 937
  if ((unsigned long )stree->branchtab != (unsigned long )((void *)0)) {
    {
#line 937
    freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c",
                    (Uint )937, (void *)stree->branchtab);
#line 937
    stree->branchtab = (Uint *)((void *)0);
    }
  }
#line 938
  if ((unsigned long )stree->nonmaximal != (unsigned long )((void *)0)) {
#line 940
    if ((unsigned long )stree->nonmaximal != (unsigned long )((void *)0)) {
      {
#line 940
      freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c",
                      (Uint )940, (void *)stree->nonmaximal);
#line 940
      stree->nonmaximal = (Uint *)((void *)0);
      }
    }
  }
#line 942
  if ((unsigned long )stree->leafcounts != (unsigned long )((void *)0)) {
#line 944
    if ((unsigned long )stree->leafcounts != (unsigned long )((void *)0)) {
      {
#line 944
      freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.c",
                      (Uint )944, (void *)stree->leafcounts);
#line 944
      stree->leafcounts = (Uint *)((void *)0);
      }
    }
  }
#line 946
  return;
}
}
#line 9 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.gen"
Sint constructstree(Suffixtree *stree , SYMBOL *text , Uint textlen ) 
{ 
  char *tmp ;
  int tmp___0 ;
  Sint tmp___1 ;
  Uint tmp___2 ;
  Uint tmp___3 ;

  {
#line 11
  stree->nonmaximal = (Uint *)((void *)0);
#line 13
  if (textlen > ((1U << ((1U << 5) - 1U)) - 1U) / 4U - 3U) {
    {
#line 13
    tmp = messagespace();
#line 13
    tmp___0 = sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)"suffix tree construction failed: textlen=%lu larger than maximal textlen=%lu",
                      (Showuint )textlen, (Showuint )(((1U << ((1U << 5) - 1U)) - 1U) / 4U - 3U));
#line 13
    tmp___1 = maxerrormsg();
    }
#line 13
    if (tmp___0 >= tmp___1) {
      {
#line 13
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.gen",
              (Showuint )13);
#line 13
      exit(1);
      }
    }
#line 13
    return (-1);
  }
  {
#line 17
  initSuffixtree(stree, text, textlen);
  }
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! ((unsigned long )stree->tailptr < (unsigned long )stree->sentinel)) {
#line 18
      if (! (stree->headnodedepth != 0U)) {
#line 18
        if (! ((unsigned long )stree->headend != (unsigned long )((void *)0))) {
#line 18
          goto while_break;
        }
      }
    }
#line 23
    if (stree->headnodedepth == 0U) {
#line 23
      if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
        {
#line 25
        (stree->tailptr) ++;
#line 26
        scanprefix(stree);
        }
      } else {
#line 23
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 29
    if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
#line 31
      if (! (*(stree->headnode) & (1U << ((1U << 5) - 1U)))) {
        {
#line 31
        tmp___2 = getlargelinkconstruction(stree);
#line 31
        stree->headnode = stree->branchtab + tmp___2;
        }
      } else {
#line 31
        stree->headnode += 3;
      }
      {
#line 31
      (stree->headnodedepth) --;
#line 32
      scanprefix(stree);
      }
    } else {
#line 35
      if (stree->headnodedepth == 0U) {
#line 37
        if ((unsigned long )stree->headstart == (unsigned long )stree->headend) {
#line 39
          stree->headend = (SYMBOL *)((void *)0);
        } else {
          {
#line 42
          (stree->headstart) ++;
#line 43
          rescan(stree);
          }
        }
      } else {
#line 47
        if (! (*(stree->headnode) & (1U << ((1U << 5) - 1U)))) {
          {
#line 47
          tmp___3 = getlargelinkconstruction(stree);
#line 47
          stree->headnode = stree->branchtab + tmp___3;
          }
        } else {
#line 47
          stree->headnode += 3;
        }
        {
#line 47
        (stree->headnodedepth) --;
#line 48
        rescan(stree);
        }
      }
#line 50
      if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
        {
#line 52
        *(stree->nextfreebranch + 4) = (Uint )(stree->headnode - stree->branchtab);
#line 53
        completelarge(stree);
#line 54
        scanprefix(stree);
        }
      } else
#line 57
      if (stree->smallnotcompleted == (1U << ((1U << 5) - 1U)) - 1U) {
        {
#line 62
        *(stree->nextfreebranch + 4) = stree->nextfreebranchnum + 5U;
#line 63
        completelarge(stree);
        }
      } else {
#line 66
        if ((unsigned long )stree->chainstart == (unsigned long )((void *)0)) {
#line 68
          stree->chainstart = stree->nextfreebranch;
        }
#line 70
        (stree->smallnotcompleted) ++;
#line 71
        stree->nextfreebranch += 3;
#line 72
        stree->nextfreebranchnum += 3U;
#line 73
        (stree->smallnode) ++;
      }
    }
#line 81
    if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
      {
#line 83
      insertleaf(stree);
      }
    } else {
      {
#line 86
      insertbranchnode(stree);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  stree->chainstart = (Uint *)((void *)0);
#line 91
  linkrootchildren(stree);
  }
#line 128
  return (0);
}
}
#line 9 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.gen"
Sint constructmarkmaxstree(Suffixtree *stree , SYMBOL *text , Uint textlen ) 
{ 
  Uint distance ;
  Uint headposition ;
  Uint *largeptr ;
  Uint tabsize ;
  Uint *tabptr ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  Sint tmp___2 ;
  Uint tmp___3 ;
  Uint tmp___4 ;

  {
  {
#line 11
  headposition = (Uint )0;
#line 11
  tabsize = 1U + ((textlen + 1U) >> 5);
#line 11
  tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.gen",
                               (Uint )11, (void *)0, (Uint )sizeof(Uint ), tabsize);
#line 11
  stree->nonmaximal = (Uint *)tmp;
#line 11
  tabptr = stree->nonmaximal;
  }
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11
    if (! ((unsigned long )tabptr < (unsigned long )(stree->nonmaximal + tabsize))) {
#line 11
      goto while_break;
    }
#line 11
    *tabptr = (Uint )0;
#line 11
    tabptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 13
  if (textlen > ((1U << ((1U << 5) - 1U)) - 1U) / 4U - 3U) {
    {
#line 13
    tmp___0 = messagespace();
#line 13
    tmp___1 = sprintf((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)"suffix tree construction failed: textlen=%lu larger than maximal textlen=%lu",
                      (Showuint )textlen, (Showuint )(((1U << ((1U << 5) - 1U)) - 1U) / 4U - 3U));
#line 13
    tmp___2 = maxerrormsg();
    }
#line 13
    if (tmp___1 >= tmp___2) {
      {
#line 13
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.gen",
              (Showuint )13);
#line 13
      exit(1);
      }
    }
#line 13
    return (-1);
  }
  {
#line 17
  initSuffixtree(stree, text, textlen);
  }
  {
#line 18
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 18
    if (! ((unsigned long )stree->tailptr < (unsigned long )stree->sentinel)) {
#line 18
      if (! (stree->headnodedepth != 0U)) {
#line 18
        if (! ((unsigned long )stree->headend != (unsigned long )((void *)0))) {
#line 18
          goto while_break___0;
        }
      }
    }
#line 23
    if (stree->headnodedepth == 0U) {
#line 23
      if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
        {
#line 25
        (stree->tailptr) ++;
#line 26
        scanprefix(stree);
        }
      } else {
#line 23
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 29
    if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
#line 31
      if (! (*(stree->headnode) & (1U << ((1U << 5) - 1U)))) {
        {
#line 31
        tmp___3 = getlargelinkconstruction(stree);
#line 31
        stree->headnode = stree->branchtab + tmp___3;
        }
      } else {
#line 31
        stree->headnode += 3;
      }
      {
#line 31
      (stree->headnodedepth) --;
#line 32
      scanprefix(stree);
      }
    } else {
#line 35
      if (stree->headnodedepth == 0U) {
#line 37
        if ((unsigned long )stree->headstart == (unsigned long )stree->headend) {
#line 39
          stree->headend = (SYMBOL *)((void *)0);
        } else {
          {
#line 42
          (stree->headstart) ++;
#line 43
          rescan(stree);
          }
        }
      } else {
#line 47
        if (! (*(stree->headnode) & (1U << ((1U << 5) - 1U)))) {
          {
#line 47
          tmp___4 = getlargelinkconstruction(stree);
#line 47
          stree->headnode = stree->branchtab + tmp___4;
          }
        } else {
#line 47
          stree->headnode += 3;
        }
        {
#line 47
        (stree->headnodedepth) --;
#line 48
        rescan(stree);
        }
      }
#line 50
      if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
#line 52
        *(stree->nextfreebranch + 4) = (Uint )(stree->headnode - stree->branchtab);
#line 53
        if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 53
          if ((unsigned long )stree->headnode >= (unsigned long )stree->chainstart) {
#line 53
            distance = 1U + (Uint )(stree->nextfreebranch - stree->headnode) / 3U;
#line 53
            headposition = stree->nextfreeleafnum - distance;
          } else {
#line 53
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 53
        if (! (*(stree->headnode) & (1U << ((1U << 5) - 1U)))) {
#line 53
          headposition = *(stree->headnode + 3);
        } else {
#line 53
          distance = *(stree->headnode + 2);
#line 53
          largeptr = stree->headnode + distance * 3U;
#line 53
          headposition = *(largeptr + 3) - distance;
        }
        {
#line 53
        *(stree->nonmaximal + (headposition >> 5)) |= (1U << ((1U << 5) - 1U)) >> (headposition & ((1U << 5) - 1U));
#line 53
        completelarge(stree);
#line 54
        scanprefix(stree);
        }
      } else
#line 57
      if (stree->smallnotcompleted == (1U << ((1U << 5) - 1U)) - 1U) {
        {
#line 62
        *(stree->nextfreebranch + 4) = stree->nextfreebranchnum + 5U;
#line 63
        *(stree->nonmaximal + (stree->nextfreeleafnum >> 5)) |= (1U << ((1U << 5) - 1U)) >> (stree->nextfreeleafnum & ((1U << 5) - 1U));
#line 63
        completelarge(stree);
        }
      } else {
#line 66
        if ((unsigned long )stree->chainstart == (unsigned long )((void *)0)) {
#line 68
          stree->chainstart = stree->nextfreebranch;
        }
#line 70
        (stree->smallnotcompleted) ++;
#line 71
        stree->nextfreebranch += 3;
#line 72
        stree->nextfreebranchnum += 3U;
#line 73
        (stree->smallnode) ++;
      }
    }
#line 81
    if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
      {
#line 83
      insertleaf(stree);
      }
    } else {
      {
#line 86
      insertbranchnode(stree);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 90
  stree->chainstart = (Uint *)((void *)0);
#line 91
  linkrootchildren(stree);
  }
#line 128
  return (0);
}
}
#line 9 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.gen"
Sint constructheadstree(Suffixtree *stree , SYMBOL *text , Uint textlen , void (*processhead)(Suffixtree * ,
                                                                                              Uint  ,
                                                                                              void * ) ,
                        void *processheadinfo ) 
{ 
  char *tmp ;
  int tmp___0 ;
  Sint tmp___1 ;
  Uint tmp___2 ;
  Uint tmp___3 ;

  {
#line 11
  stree->nonmaximal = (Uint *)((void *)0);
#line 13
  if (textlen > ((1U << ((1U << 5) - 1U)) - 1U) / 4U - 3U) {
    {
#line 13
    tmp = messagespace();
#line 13
    tmp___0 = sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)"suffix tree construction failed: textlen=%lu larger than maximal textlen=%lu",
                      (Showuint )textlen, (Showuint )(((1U << ((1U << 5) - 1U)) - 1U) / 4U - 3U));
#line 13
    tmp___1 = maxerrormsg();
    }
#line 13
    if (tmp___0 >= tmp___1) {
      {
#line 13
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.gen",
              (Showuint )13);
#line 13
      exit(1);
      }
    }
#line 13
    return (-1);
  }
  {
#line 17
  initSuffixtree(stree, text, textlen);
  }
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! ((unsigned long )stree->tailptr < (unsigned long )stree->sentinel)) {
#line 18
      if (! (stree->headnodedepth != 0U)) {
#line 18
        if (! ((unsigned long )stree->headend != (unsigned long )((void *)0))) {
#line 18
          goto while_break;
        }
      }
    }
#line 23
    if (stree->headnodedepth == 0U) {
#line 23
      if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
        {
#line 25
        (stree->tailptr) ++;
#line 26
        scanprefix(stree);
        }
      } else {
#line 23
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 29
    if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
#line 31
      if (! (*(stree->headnode) & (1U << ((1U << 5) - 1U)))) {
        {
#line 31
        tmp___2 = getlargelinkconstruction(stree);
#line 31
        stree->headnode = stree->branchtab + tmp___2;
        }
      } else {
#line 31
        stree->headnode += 3;
      }
      {
#line 31
      (stree->headnodedepth) --;
#line 32
      scanprefix(stree);
      }
    } else {
#line 35
      if (stree->headnodedepth == 0U) {
#line 37
        if ((unsigned long )stree->headstart == (unsigned long )stree->headend) {
#line 39
          stree->headend = (SYMBOL *)((void *)0);
        } else {
          {
#line 42
          (stree->headstart) ++;
#line 43
          rescan(stree);
          }
        }
      } else {
#line 47
        if (! (*(stree->headnode) & (1U << ((1U << 5) - 1U)))) {
          {
#line 47
          tmp___3 = getlargelinkconstruction(stree);
#line 47
          stree->headnode = stree->branchtab + tmp___3;
          }
        } else {
#line 47
          stree->headnode += 3;
        }
        {
#line 47
        (stree->headnodedepth) --;
#line 48
        rescan(stree);
        }
      }
#line 50
      if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
        {
#line 52
        *(stree->nextfreebranch + 4) = (Uint )(stree->headnode - stree->branchtab);
#line 53
        completelarge(stree);
#line 54
        scanprefix(stree);
        }
      } else
#line 57
      if (stree->smallnotcompleted == (1U << ((1U << 5) - 1U)) - 1U) {
        {
#line 62
        *(stree->nextfreebranch + 4) = stree->nextfreebranchnum + 5U;
#line 63
        completelarge(stree);
        }
      } else {
#line 66
        if ((unsigned long )stree->chainstart == (unsigned long )((void *)0)) {
#line 68
          stree->chainstart = stree->nextfreebranch;
        }
#line 70
        (stree->smallnotcompleted) ++;
#line 71
        stree->nextfreebranch += 3;
#line 72
        stree->nextfreebranchnum += 3U;
#line 73
        (stree->smallnode) ++;
      }
    }
    {
#line 79
    (*processhead)(stree, stree->nextfreeleafnum, processheadinfo);
    }
#line 81
    if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
      {
#line 83
      insertleaf(stree);
      }
    } else {
      {
#line 86
      insertbranchnode(stree);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  stree->chainstart = (Uint *)((void *)0);
#line 91
  linkrootchildren(stree);
  }
#line 128
  return (0);
}
}
#line 9 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.gen"
Sint constructprogressstree(Suffixtree *stree , SYMBOL *text , Uint textlen , void (*progress)(Uint  ,
                                                                                               void * ) ,
                            void (*finalprogress)(void * ) , void *info ) 
{ 
  Uint j ;
  Uint step ;
  Uint nextstep ;
  char *tmp ;
  int tmp___0 ;
  Sint tmp___1 ;
  Uint tmp___2 ;
  Uint tmp___3 ;

  {
#line 11
  j = (Uint )0;
#line 11
  stree->nonmaximal = (Uint *)((void *)0);
#line 11
  step = textlen / 100U;
#line 11
  if (textlen >= 100000U) {
#line 11
    nextstep = step;
  } else {
#line 11
    nextstep = textlen + 1U;
  }
#line 11
  if ((unsigned long )progress == (unsigned long )((void *)0)) {
#line 11
    if (textlen >= 100000U) {
      {
#line 11
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# process %lu characters per dot\n",
              (Showuint )textlen / 100UL);
      }
    }
  }
#line 13
  if (textlen > ((1U << ((1U << 5) - 1U)) - 1U) / 4U - 3U) {
    {
#line 13
    tmp = messagespace();
#line 13
    tmp___0 = sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)"suffix tree construction failed: textlen=%lu larger than maximal textlen=%lu",
                      (Showuint )textlen, (Showuint )(((1U << ((1U << 5) - 1U)) - 1U) / 4U - 3U));
#line 13
    tmp___1 = maxerrormsg();
    }
#line 13
    if (tmp___0 >= tmp___1) {
      {
#line 13
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/construct.gen",
              (Showuint )13);
#line 13
      exit(1);
      }
    }
#line 13
    return (-1);
  }
  {
#line 17
  initSuffixtree(stree, text, textlen);
  }
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! ((unsigned long )stree->tailptr < (unsigned long )stree->sentinel)) {
#line 18
      if (! (stree->headnodedepth != 0U)) {
#line 18
        if (! ((unsigned long )stree->headend != (unsigned long )((void *)0))) {
#line 18
          goto while_break;
        }
      }
    }
#line 21
    if (j == nextstep) {
#line 21
      if ((unsigned long )progress == (unsigned long )((void *)0)) {
#line 21
        if (nextstep == step) {
          {
#line 21
          fputc('#', stderr);
          }
        }
        {
#line 21
        fputc('.', stderr);
#line 21
        fflush(stdout);
        }
      } else {
        {
#line 21
        (*progress)(nextstep, info);
        }
      }
#line 21
      nextstep += step;
    }
#line 21
    j ++;
#line 23
    if (stree->headnodedepth == 0U) {
#line 23
      if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
        {
#line 25
        (stree->tailptr) ++;
#line 26
        scanprefix(stree);
        }
      } else {
#line 23
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 29
    if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
#line 31
      if (! (*(stree->headnode) & (1U << ((1U << 5) - 1U)))) {
        {
#line 31
        tmp___2 = getlargelinkconstruction(stree);
#line 31
        stree->headnode = stree->branchtab + tmp___2;
        }
      } else {
#line 31
        stree->headnode += 3;
      }
      {
#line 31
      (stree->headnodedepth) --;
#line 32
      scanprefix(stree);
      }
    } else {
#line 35
      if (stree->headnodedepth == 0U) {
#line 37
        if ((unsigned long )stree->headstart == (unsigned long )stree->headend) {
#line 39
          stree->headend = (SYMBOL *)((void *)0);
        } else {
          {
#line 42
          (stree->headstart) ++;
#line 43
          rescan(stree);
          }
        }
      } else {
#line 47
        if (! (*(stree->headnode) & (1U << ((1U << 5) - 1U)))) {
          {
#line 47
          tmp___3 = getlargelinkconstruction(stree);
#line 47
          stree->headnode = stree->branchtab + tmp___3;
          }
        } else {
#line 47
          stree->headnode += 3;
        }
        {
#line 47
        (stree->headnodedepth) --;
#line 48
        rescan(stree);
        }
      }
#line 50
      if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
        {
#line 52
        *(stree->nextfreebranch + 4) = (Uint )(stree->headnode - stree->branchtab);
#line 53
        completelarge(stree);
#line 54
        scanprefix(stree);
        }
      } else
#line 57
      if (stree->smallnotcompleted == (1U << ((1U << 5) - 1U)) - 1U) {
        {
#line 62
        *(stree->nextfreebranch + 4) = stree->nextfreebranchnum + 5U;
#line 63
        completelarge(stree);
        }
      } else {
#line 66
        if ((unsigned long )stree->chainstart == (unsigned long )((void *)0)) {
#line 68
          stree->chainstart = stree->nextfreebranch;
        }
#line 70
        (stree->smallnotcompleted) ++;
#line 71
        stree->nextfreebranch += 3;
#line 72
        stree->nextfreebranchnum += 3U;
#line 73
        (stree->smallnode) ++;
      }
    }
#line 81
    if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
      {
#line 83
      insertleaf(stree);
      }
    } else {
      {
#line 86
      insertbranchnode(stree);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  stree->chainstart = (Uint *)((void *)0);
#line 91
  linkrootchildren(stree);
  }
#line 127
  if (textlen >= 100000U) {
#line 127
    if ((unsigned long )finalprogress == (unsigned long )((void *)0)) {
      {
#line 127
      fputc('\n', stderr);
      }
    } else {
      {
#line 127
      (*finalprogress)(info);
      }
    }
  }
#line 128
  return (0);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 44 "../libbasedir/protodef.h"
extern void initmultiseq(Multiseq *multiseq ) ;
#line 80 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c"
Sint scanmultiplefastafile(Multiseq *multiseq , char *filename , Uchar replacewildcardchar ,
                           Uchar *input , Uint inputlen ) 
{ 
  Uchar *inputptr ;
  Uchar *newptr ;
  Uchar tmpchar ;
  Uint allocatedstartdesc ;
  unsigned char indesc ;
  unsigned char copydescription ;
  Uchar *tmp ;
  void *tmp___0 ;
  Uint tmp___1 ;
  void *tmp___2 ;
  Uint tmp___3 ;
  unsigned short const   **tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  Uint tmp___7 ;
  Uchar *tmp___8 ;
  int tmp___9 ;
  Uchar *tmp___10 ;
  unsigned short const   **tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  Sint tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  Sint tmp___18 ;

  {
  {
#line 89
  allocatedstartdesc = (Uint )0;
#line 90
  indesc = (unsigned char)0;
#line 90
  copydescription = (unsigned char)0;
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# reading input file \"%s\" ",
          filename);
#line 94
  initmultiseq(multiseq);
#line 95
  multiseq->originalsequence = (Uchar *)((void *)0);
#line 97
  tmp = input;
#line 97
  multiseq->sequence = tmp;
#line 97
  newptr = tmp;
#line 98
  inputptr = input;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((unsigned long )inputptr < (unsigned long )(input + inputlen))) {
#line 98
      goto while_break;
    }
#line 100
    if (indesc) {
#line 102
      if (copydescription) {
        {
#line 104
        tmp___4 = __ctype_b_loc();
        }
#line 104
        if ((int const   )*(*tmp___4 + (Ctypeargumenttype )*inputptr) & 8192) {
#line 106
          copydescription = (unsigned char)0;
#line 107
          if (multiseq->descspace.nextfreeUchar >= multiseq->descspace.allocatedUchar) {
            {
#line 107
            multiseq->descspace.allocatedUchar += 4096U;
#line 107
            tmp___0 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c",
                                             (Uint )110, (void *)multiseq->descspace.spaceUchar,
                                             (Uint )sizeof(Uchar ), multiseq->descspace.allocatedUchar);
#line 107
            multiseq->descspace.spaceUchar = (Uchar *)tmp___0;
            }
          }
#line 107
          tmp___1 = multiseq->descspace.nextfreeUchar;
#line 107
          (multiseq->descspace.nextfreeUchar) ++;
#line 107
          *(multiseq->descspace.spaceUchar + tmp___1) = (Uchar )'\n';
        } else {
#line 113
          if (multiseq->descspace.nextfreeUchar >= multiseq->descspace.allocatedUchar) {
            {
#line 113
            multiseq->descspace.allocatedUchar += 4096U;
#line 113
            tmp___2 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c",
                                             (Uint )116, (void *)multiseq->descspace.spaceUchar,
                                             (Uint )sizeof(Uchar ), multiseq->descspace.allocatedUchar);
#line 113
            multiseq->descspace.spaceUchar = (Uchar *)tmp___2;
            }
          }
#line 113
          tmp___3 = multiseq->descspace.nextfreeUchar;
#line 113
          (multiseq->descspace.nextfreeUchar) ++;
#line 113
          *(multiseq->descspace.spaceUchar + tmp___3) = *inputptr;
        }
      }
#line 119
      if ((int )*inputptr == 10) {
#line 121
        indesc = (unsigned char)0;
      }
    } else
#line 126
    if ((int )*inputptr == 62) {
#line 128
      if (multiseq->numofsequences >= allocatedstartdesc) {
        {
#line 128
        allocatedstartdesc += 128U;
#line 128
        tmp___5 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c",
                                         (Uint )128, (void *)multiseq->startdesc,
                                         (Uint )sizeof(Uint ), allocatedstartdesc);
#line 128
        multiseq->startdesc = (Uint *)tmp___5;
        }
      }
#line 128
      *(multiseq->startdesc + multiseq->numofsequences) = multiseq->descspace.nextfreeUchar;
#line 129
      if (multiseq->numofsequences > 0U) {
#line 131
        if (multiseq->markpos.nextfreeUint >= multiseq->markpos.allocatedUint) {
          {
#line 131
          multiseq->markpos.allocatedUint += 128U;
#line 131
          tmp___6 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c",
                                           (Uint )134, (void *)multiseq->markpos.spaceUint,
                                           (Uint )sizeof(Uint ), multiseq->markpos.allocatedUint);
#line 131
          multiseq->markpos.spaceUint = (Uint *)tmp___6;
          }
        }
#line 131
        tmp___7 = multiseq->markpos.nextfreeUint;
#line 131
        (multiseq->markpos.nextfreeUint) ++;
#line 131
        *(multiseq->markpos.spaceUint + tmp___7) = (Uint )(newptr - multiseq->sequence);
#line 136
        tmp___8 = newptr;
#line 136
        newptr ++;
#line 136
        *tmp___8 = (Uchar )255;
      }
#line 138
      (multiseq->numofsequences) ++;
#line 139
      indesc = (unsigned char)1;
#line 140
      copydescription = (unsigned char)1;
    } else {
      {
#line 144
      tmpchar = *inputptr;
#line 145
      tmp___11 = __ctype_b_loc();
      }
#line 145
      if (! ((int const   )*(*tmp___11 + (Ctypeargumenttype )tmpchar) & 8192)) {
        {
#line 147
        tmp___9 = tolower((Ctypeargumenttype )tmpchar);
#line 147
        tmpchar = (Uchar )tmp___9;
        }
#line 148
        if ((int )replacewildcardchar != 0) {
          {
#line 155
          if ((int )tmpchar == 116) {
#line 155
            goto case_116;
          }
#line 155
          if ((int )tmpchar == 103) {
#line 155
            goto case_116;
          }
#line 155
          if ((int )tmpchar == 99) {
#line 155
            goto case_116;
          }
#line 155
          if ((int )tmpchar == 97) {
#line 155
            goto case_116;
          }
#line 157
          goto switch_default;
          case_116: /* CIL Label */ 
          case_103: /* CIL Label */ 
          case_99: /* CIL Label */ 
          case_97: /* CIL Label */ 
#line 156
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 162
          tmpchar = replacewildcardchar;
          switch_break: /* CIL Label */ ;
          }
        }
#line 194
        tmp___10 = newptr;
#line 194
        newptr ++;
#line 194
        *tmp___10 = tmpchar;
      }
    }
#line 98
    inputptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  if (multiseq->numofsequences >= allocatedstartdesc) {
    {
#line 199
    allocatedstartdesc += 128U;
#line 199
    tmp___12 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c",
                                      (Uint )199, (void *)multiseq->startdesc, (Uint )sizeof(Uint ),
                                      allocatedstartdesc);
#line 199
    multiseq->startdesc = (Uint *)tmp___12;
    }
  }
#line 199
  *(multiseq->startdesc + multiseq->numofsequences) = multiseq->descspace.nextfreeUchar;
#line 200
  if (multiseq->numofsequences == 0U) {
    {
#line 202
    tmp___13 = messagespace();
#line 202
    tmp___14 = sprintf((char */* __restrict  */)tmp___13, (char const   */* __restrict  */)"no sequences in multiple fasta file");
#line 202
    tmp___15 = maxerrormsg();
    }
#line 202
    if (tmp___14 >= tmp___15) {
      {
#line 202
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c",
              (Showuint )202);
#line 202
      exit(1);
      }
    }
#line 203
    return (-2);
  }
#line 205
  multiseq->totallength = (Uint )(newptr - multiseq->sequence);
#line 206
  if (multiseq->totallength == 0U) {
    {
#line 208
    tmp___16 = messagespace();
#line 208
    tmp___17 = sprintf((char */* __restrict  */)tmp___16, (char const   */* __restrict  */)"empty sequence in multiple fasta file");
#line 208
    tmp___18 = maxerrormsg();
    }
#line 208
    if (tmp___17 >= tmp___18) {
      {
#line 208
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c",
              (Showuint )208);
#line 208
      exit(1);
      }
    }
#line 209
    return (-3);
  }
  {
#line 211
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"of length %lu\n",
          (Showuint )multiseq->totallength);
  }
#line 212
  return (0);
}
}
#line 227 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c"
Sint getmaxmatinput(Multiseq *subjectmultiseq , unsigned char matchnucleotidesonly ,
                    char *subjectfile ) 
{ 
  Uint filelen ;
  Uchar *filecontent ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  Sint tmp___2 ;
  int tmp___3 ;
  Sint tmp___4 ;

  {
  {
#line 234
  tmp = creatememorymap((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c",
                        (Uint )234, subjectfile, (unsigned char)1, & filelen);
#line 234
  filecontent = (Uchar *)tmp;
  }
#line 235
  if ((unsigned long )filecontent == (unsigned long )((void *)0)) {
#line 235
    goto _L;
  } else
#line 235
  if (filelen == 0U) {
    _L: /* CIL Label */ 
    {
#line 237
    tmp___0 = messagespace();
#line 237
    tmp___1 = sprintf((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)"cannot open file \"%s\" or file \"%s\" is empty",
                      subjectfile, subjectfile);
#line 237
    tmp___2 = maxerrormsg();
    }
#line 237
    if (tmp___1 >= tmp___2) {
      {
#line 237
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file %s, line %lu: space for errormessage too small\n",
              "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/mm3src/maxmatinp.c",
              (Showuint )238);
#line 237
      exit(1);
      }
    }
#line 239
    return (-1);
  }
#line 241
  if (matchnucleotidesonly) {
#line 241
    tmp___3 = 252;
  } else {
#line 241
    tmp___3 = 0;
  }
  {
#line 241
  tmp___4 = scanmultiplefastafile(subjectmultiseq, subjectfile, (Uchar )tmp___3, filecontent,
                                  filelen);
  }
#line 241
  if (tmp___4 != 0) {
#line 247
    return (-2);
  }
#line 254
  return (0);
}
}
#line 71 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
void showdepthtab(ArrayUint *dt ) ;
#line 72
void makedepthtabstree(ArrayUint *depthtab , Suffixtree *stree ) ;
#line 20 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/depthtab.c"
void showdepthtab(ArrayUint *dt ) 
{ 
  Uint i ;

  {
#line 24
  i = (Uint )0;
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! (i < dt->nextfreeUint)) {
#line 24
      goto while_break;
    }
#line 26
    if (*(dt->spaceUint + i) > 0U) {
      {
#line 28
      printf((char const   */* __restrict  */)"Depth %lu %lu\n", (Showuint )i, (Showuint )*(dt->spaceUint + i));
      }
    }
#line 24
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 31
  return;
}
}
#line 33 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/depthtab.c"
static void setdepthtab(ArrayUint *depthtab , Uint depth ) 
{ 
  Uint i ;
  void *tmp ;

  {
#line 37
  if (depth >= depthtab->allocatedUint) {
    {
#line 39
    tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/depthtab.c",
                                 (Uint )40, (void *)depthtab->spaceUint, (Uint )sizeof(Uint ),
                                 depth + 128U);
#line 39
    depthtab->spaceUint = (Uint *)tmp;
#line 41
    i = depthtab->allocatedUint;
    }
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 41
      if (! (i < depth + 128U)) {
#line 41
        goto while_break;
      }
#line 43
      *(depthtab->spaceUint + i) = (Uint )0;
#line 41
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    depthtab->allocatedUint = depth + 128U;
  }
#line 47
  if (depth + 1U > depthtab->nextfreeUint) {
#line 49
    depthtab->nextfreeUint = depth + 1U;
  }
#line 51
  (*(depthtab->spaceUint + depth)) ++;
#line 52
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/depthtab.c"
void makedepthtabstree(ArrayUint *depthtab , Suffixtree *stree ) 
{ 
  Uint depth ;
  Uint headposition ;
  Uint *btptr ;
  Uint *largeptr ;
  Uint distance ;

  {
#line 58
  btptr = stree->branchtab;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )btptr < (unsigned long )stree->nextfreebranch)) {
#line 59
      goto while_break;
    }
#line 61
    if (! (*btptr & (1U << ((1U << 5) - 1U)))) {
      {
#line 63
      depth = *(btptr + 2);
#line 64
      headposition = *(btptr + 3);
#line 65
      setdepthtab(depthtab, depth);
#line 66
      btptr += 5;
      }
    } else {
#line 69
      distance = *(btptr + 2);
#line 70
      largeptr = btptr + distance * 3U;
#line 71
      depth = *(largeptr + 2);
#line 72
      headposition = *(largeptr + 3);
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 73
        if (! (distance > 0U)) {
#line 73
          goto while_break___0;
        }
        {
#line 75
        setdepthtab(depthtab, depth + distance);
#line 76
        distance --;
#line 77
        btptr += 3;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 79
      setdepthtab(depthtab, depth);
#line 80
      btptr += 5;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
unsigned char exactlytwoleavesstree(Suffixtree *stree , PairUint *twoleaves , Bref start ) ;
#line 13 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/ex2leav.c"
unsigned char exactlytwoleavesstree(Suffixtree *stree , PairUint *twoleaves , Bref start ) 
{ 
  unsigned char firstleaffound ;
  Uint tmpval ;
  Uint node ;

  {
#line 15
  firstleaffound = (unsigned char)0;
#line 18
  node = *start & ((1U << ((1U << 5) - 1U)) - 1U);
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 21
    if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 23
      if (firstleaffound) {
#line 25
        twoleaves->uint1 = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 26
        if (twoleaves->uint0 > twoleaves->uint1) {
#line 28
          tmpval = twoleaves->uint1;
#line 29
          twoleaves->uint1 = twoleaves->uint0;
#line 30
          twoleaves->uint0 = tmpval;
        }
#line 34
        if (*(stree->leaftab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))))) & (1U << ((1U << 5) - 1U))) {
#line 36
          return ((unsigned char)1);
        }
#line 38
        return ((unsigned char)0);
      }
#line 40
      twoleaves->uint0 = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 42
      firstleaffound = (unsigned char)1;
#line 43
      node = *(stree->leaftab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)))));
    } else {
#line 47
      return ((unsigned char)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 33 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
Uint getlargelinkstree(Suffixtree *stree , Bref btptr , Uint depth ) ;
#line 36
void getleafinfostree(Suffixtree *stree , Leafinfo *leafinfo , Lref lptr ) ;
#line 39
void getheadstringstree(Suffixtree *stree , Stringtype *str ) ;
#line 41
void showpathstree(Suffixtree *stree , Bref bnode , void (*showchar)(SYMBOL  , void * ) ,
                   void *info ) ;
#line 45
void rootsucclocationsstree(Suffixtree *stree , ArraySimpleloc *ll ) ;
#line 46
void succlocationsstree(Suffixtree *stree , unsigned char nosentinel , Simpleloc *loc ,
                        ArraySimpleloc *ll ) ;
#line 90 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c"
Uint getlargelinkstree(Suffixtree *stree , Bref btptr , Uint depth ) 
{ 


  {
#line 92
  if (depth == 1U) {
#line 94
    return ((Uint )0);
  }
#line 96
  return (*(btptr + 4));
}
}
#line 100 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c"
static void int2ref___0(Suffixtree *stree , Reference *ref , Uint i ) 
{ 


  {
#line 102
  if (i & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 104
    ref->toleaf = (unsigned char)1;
#line 105
    ref->address = stree->leaftab + (i & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
  } else {
#line 108
    ref->toleaf = (unsigned char)0;
#line 109
    ref->address = stree->branchtab + (i & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
  }
#line 111
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c"
void getleafinfostree(Suffixtree *stree , Leafinfo *leafinfo , Lref lptr ) 
{ 
  Uint node ;

  {
#line 115
  node = *lptr;
#line 117
  if (node & (1U << ((1U << 5) - 1U))) {
#line 119
    leafinfo->address = (Uint *)((void *)0);
  } else {
    {
#line 122
    int2ref___0(stree, leafinfo, node);
    }
  }
#line 124
  return;
}
}
#line 126 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c"
void getbranchinfostree(Suffixtree *stree , Uint whichinfo , Branchinfo *branchinfo ,
                        Bref btptr ) 
{ 
  Uint which ;
  Uint node ;
  Uint distance ;
  Uint *largeptr ;
  Uint tmp ;

  {
#line 129
  which = whichinfo;
#line 131
  if (which & (1U << 2)) {
#line 133
    which |= 1U;
  }
#line 135
  if (which & (1U | (1U << 1))) {
#line 137
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 137
      if ((unsigned long )btptr >= (unsigned long )stree->chainstart) {
#line 139
        distance = (Uint )(stree->nextfreebranch - btptr) / 3U;
#line 140
        branchinfo->depth = stree->currentdepth + distance;
#line 141
        branchinfo->headposition = stree->nextfreeleafnum - distance;
      } else {
#line 137
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 144
    if (! (*btptr & (1U << ((1U << 5) - 1U)))) {
#line 146
      if (which & 1U) {
#line 148
        branchinfo->depth = *(btptr + 2);
      }
#line 150
      if (which & (1U << 1)) {
#line 152
        branchinfo->headposition = *(btptr + 3);
      }
    } else {
#line 156
      distance = *(btptr + 2);
#line 157
      largeptr = btptr + distance * 3U;
#line 158
      if (which & 1U) {
#line 160
        branchinfo->depth = *(largeptr + 2) + distance;
      }
#line 162
      if (which & (1U << 1)) {
#line 164
        branchinfo->headposition = *(largeptr + 3) - distance;
      }
    }
  }
#line 169
  if (which & (1U << 2)) {
#line 171
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 171
      if ((unsigned long )btptr >= (unsigned long )stree->chainstart) {
#line 174
        branchinfo->suffixlink = btptr + 3;
      } else {
#line 171
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 171
    if (! (! (*btptr & (1U << ((1U << 5) - 1U))))) {
#line 174
      branchinfo->suffixlink = btptr + 3;
    } else {
      {
#line 177
      tmp = getlargelinkstree(stree, btptr, branchinfo->depth);
#line 177
      branchinfo->suffixlink = stree->branchtab + tmp;
      }
    }
  }
#line 182
  if (which & (1U << 3)) {
    {
#line 184
    int2ref___0(stree, & branchinfo->firstchild, *btptr & ((1U << ((1U << 5) - 1U)) - 1U));
    }
  }
#line 186
  if (which & (1U << 4)) {
#line 188
    node = *(btptr + 1);
#line 189
    if (node & (1U << ((1U << 5) - 1U))) {
#line 191
      branchinfo->branchbrother.address = (Uint *)((void *)0);
    } else {
      {
#line 194
      int2ref___0(stree, & branchinfo->branchbrother, node);
      }
    }
  }
#line 197
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c"
void getheadstringstree(Suffixtree *stree , Stringtype *str ) 
{ 
  Branchinfo branchinfo ;
  Reference ref ;

  {
#line 204
  if ((unsigned long )stree->headend == (unsigned long )((void *)0)) {
#line 206
    str->length = stree->headnodedepth;
#line 207
    if (stree->headnodedepth > 0U) {
      {
#line 209
      getbranchinfostree(stree, 1U << 1, & branchinfo, stree->headnode);
#line 210
      str->start = branchinfo.headposition;
      }
    } else {
#line 213
      str->start = (Uint )0;
    }
  } else {
    {
#line 217
    str->length = stree->headnodedepth + (Uint )((stree->headend - stree->headstart) + 1L);
#line 218
    int2ref___0(stree, & ref, stree->insertnode);
    }
#line 219
    if (ref.toleaf) {
#line 221
      str->start = (Uint )(ref.address - stree->leaftab);
    } else {
      {
#line 224
      getbranchinfostree(stree, 1U << 1, & branchinfo, ref.address);
#line 225
      str->start = branchinfo.headposition;
      }
    }
  }
#line 228
  return;
}
}
#line 230 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c"
Uint getmaxtextlenstree(void) 
{ 


  {
#line 232
  return (((1U << ((1U << 5) - 1U)) - 1U) / 4U - 3U);
}
}
#line 235 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c"
void showpathstree(Suffixtree *stree , Bref bnode , void (*showchar)(SYMBOL  , void * ) ,
                   void *info ) 
{ 
  Branchinfo branchinfo ;
  Uint i ;

  {
  {
#line 241
  getbranchinfostree(stree, (1U << 1) | 1U, & branchinfo, bnode);
#line 242
  i = (Uint )0;
  }
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < branchinfo.depth)) {
#line 242
      goto while_break;
    }
    {
#line 244
    (*showchar)(*(stree->text + (branchinfo.headposition + i)), info);
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 303 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c"
void rootsucclocationsstree(Suffixtree *stree , ArraySimpleloc *ll ) 
{ 
  Uint headpos ;
  Uint leafindex ;
  Uint depth ;
  Uint distance ;
  Uint node ;
  Uint ch ;
  Uint *largeptr ;
  Uint *nodeptr ;
  Simpleloc *llptr ;
  void *tmp ;
  Uint tmp___0 ;

  {
#line 308
  if (ll->nextfreeSimpleloc >= ll->allocatedSimpleloc) {
    {
#line 308
    ll->allocatedSimpleloc += stree->alphasize + 1U;
#line 308
    tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c",
                                 (Uint )308, (void *)ll->spaceSimpleloc, (Uint )sizeof(Simpleloc ),
                                 ll->allocatedSimpleloc);
#line 308
    ll->spaceSimpleloc = (Simpleloc *)tmp;
    }
  }
#line 309
  ch = (Uint )0;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (ch <= 255U)) {
#line 309
      goto while_break;
    }
#line 311
    node = *(stree->rootchildren + ch);
#line 311
    if (node != 4294967295U) {
#line 313
      tmp___0 = ll->nextfreeSimpleloc;
#line 313
      (ll->nextfreeSimpleloc) ++;
#line 313
      llptr = ll->spaceSimpleloc + tmp___0;
#line 314
      if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 316
        leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 317
        llptr->textpos = leafindex;
#line 318
        llptr->remain = stree->textlen - leafindex;
#line 319
        llptr->nextnode.toleaf = (unsigned char)1;
#line 320
        llptr->nextnode.address = stree->leaftab + leafindex;
      } else {
#line 323
        nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 324
        if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 324
          if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 324
            distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 324
            depth = stree->currentdepth + distance;
#line 324
            headpos = stree->nextfreeleafnum - distance;
          } else {
#line 324
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 324
        if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 324
          depth = *(nodeptr + 2);
#line 324
          headpos = *(nodeptr + 3);
        } else {
#line 324
          distance = *(nodeptr + 2);
#line 324
          largeptr = nodeptr + distance * 3U;
#line 324
          depth = *(largeptr + 2) + distance;
#line 324
          headpos = *(largeptr + 3) - distance;
        }
#line 325
        llptr->textpos = headpos;
#line 326
        llptr->remain = depth - 1U;
#line 327
        llptr->nextnode.toleaf = (unsigned char)0;
#line 328
        llptr->nextnode.address = nodeptr;
      }
    }
#line 309
    ch ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c"
void succlocationsstree(Suffixtree *stree , unsigned char nosentinel , Simpleloc *loc ,
                        ArraySimpleloc *ll ) 
{ 
  Uint succdepth ;
  Uint succ ;
  Uint leafindex ;
  Uint distance ;
  Uint depth ;
  Uint headpos ;
  Uint remain ;
  Uint *succptr ;
  Uint *largeptr ;
  Uint *nodeptr ;
  Simpleloc *llptr ;
  void *tmp ;
  Uint tmp___0 ;
  Uint tmp___1 ;
  Uint tmp___2 ;

  {
#line 345
  ll->nextfreeSimpleloc = (Uint )0;
#line 346
  if (ll->nextfreeSimpleloc >= ll->allocatedSimpleloc) {
    {
#line 346
    ll->allocatedSimpleloc += stree->alphasize + 1U;
#line 346
    tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/access.c",
                                 (Uint )346, (void *)ll->spaceSimpleloc, (Uint )sizeof(Simpleloc ),
                                 ll->allocatedSimpleloc);
#line 346
    ll->spaceSimpleloc = (Simpleloc *)tmp;
    }
  }
#line 347
  if (loc->remain > 0U) {
#line 349
    if (nosentinel) {
#line 349
      if (loc->nextnode.toleaf) {
#line 349
        if (loc->remain <= 1U) {
#line 351
          return;
        }
      }
    }
#line 353
    tmp___0 = ll->nextfreeSimpleloc;
#line 353
    (ll->nextfreeSimpleloc) ++;
#line 353
    llptr = ll->spaceSimpleloc + tmp___0;
#line 354
    llptr->textpos = loc->textpos + 1U;
#line 355
    llptr->remain = loc->remain - 1U;
#line 356
    llptr->nextnode.address = loc->nextnode.address;
#line 357
    llptr->nextnode.toleaf = loc->nextnode.toleaf;
#line 359
    return;
  }
#line 361
  nodeptr = loc->nextnode.address;
#line 362
  if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 362
    if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 362
      distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 362
      depth = stree->currentdepth + distance;
    } else {
#line 362
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 362
  if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 362
    depth = *(nodeptr + 2);
  } else {
#line 362
    distance = *(nodeptr + 2);
#line 362
    largeptr = nodeptr + distance * 3U;
#line 362
    depth = *(largeptr + 2) + distance;
  }
#line 363
  succ = *nodeptr & ((1U << ((1U << 5) - 1U)) - 1U);
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (succ & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 368
      leafindex = succ & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 369
      remain = stree->textlen - (depth + leafindex);
#line 370
      if (! nosentinel) {
#line 370
        goto _L___0;
      } else
#line 370
      if (remain >= 1U) {
        _L___0: /* CIL Label */ 
#line 372
        tmp___1 = ll->nextfreeSimpleloc;
#line 372
        (ll->nextfreeSimpleloc) ++;
#line 372
        llptr = ll->spaceSimpleloc + tmp___1;
#line 373
        llptr->remain = remain;
#line 374
        llptr->textpos = depth + leafindex;
#line 375
        llptr->nextnode.address = stree->leaftab + leafindex;
#line 376
        llptr->nextnode.toleaf = (unsigned char)1;
      }
#line 379
      succ = *(stree->leaftab + leafindex);
    } else {
#line 382
      succptr = stree->branchtab + (succ & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 383
      if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 383
        if ((unsigned long )succptr >= (unsigned long )stree->chainstart) {
#line 383
          distance = 1U + (Uint )(stree->nextfreebranch - succptr) / 3U;
#line 383
          succdepth = stree->currentdepth + distance;
#line 383
          headpos = stree->nextfreeleafnum - distance;
        } else {
#line 383
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 383
      if (! (*succptr & (1U << ((1U << 5) - 1U)))) {
#line 383
        succdepth = *(succptr + 2);
#line 383
        headpos = *(succptr + 3);
      } else {
#line 383
        distance = *(succptr + 2);
#line 383
        largeptr = succptr + distance * 3U;
#line 383
        succdepth = *(largeptr + 2) + distance;
#line 383
        headpos = *(largeptr + 3) - distance;
      }
#line 384
      tmp___2 = ll->nextfreeSimpleloc;
#line 384
      (ll->nextfreeSimpleloc) ++;
#line 384
      llptr = ll->spaceSimpleloc + tmp___2;
#line 385
      llptr->textpos = depth + headpos;
#line 386
      llptr->remain = (succdepth - depth) - 1U;
#line 387
      llptr->nextnode.toleaf = (unsigned char)0;
#line 388
      llptr->nextnode.address = succptr;
#line 390
      succ = *(succptr + 1);
    }
#line 364
    if (! (! (succ & (1U << ((1U << 5) - 1U))))) {
#line 364
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
SYMBOL *findprefixpathfromnodestree(Suffixtree *stree , ArrayPathinfo *path , Location *loc ,
                                    Bref btptr , SYMBOL *left , SYMBOL *right , Uint rescanlength ) ;
#line 14 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/scanpref.c"
static Uint lcp(SYMBOL *start1 , SYMBOL *end1 , SYMBOL *start2 , SYMBOL *end2 ) 
{ 
  register SYMBOL *ptr1 ;
  register SYMBOL *ptr2 ;

  {
#line 16
  ptr1 = start1;
#line 16
  ptr2 = start2;
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if ((unsigned long )ptr1 <= (unsigned long )end1) {
#line 19
      if ((unsigned long )ptr2 <= (unsigned long )end2) {
#line 19
        if (! ((int )*ptr1 == (int )*ptr2)) {
#line 19
          goto while_break;
        }
      } else {
#line 19
        goto while_break;
      }
    } else {
#line 19
      goto while_break;
    }
#line 23
    ptr1 ++;
#line 24
    ptr2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return ((Uint )(ptr1 - start1));
}
}
#line 29 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/scanpref.c"
SYMBOL *scanprefixfromnodestree(Suffixtree *stree , Location *loc , Bref btptr , SYMBOL *left ,
                                SYMBOL *right , Uint rescanlength ) 
{ 
  Uint *nodeptr ;
  Uint *largeptr ;
  Uint leafindex ;
  Uint nodedepth ;
  Uint node ;
  Uint distance ;
  Uint prefixlen ;
  Uint headposition ;
  Uint tmpnodedepth ;
  Uint edgelen ;
  Uint remainingtoskip ;
  SYMBOL *lptr ;
  SYMBOL *leftborder ;
  SYMBOL firstchar ;
  SYMBOL edgechar ;
  Uint tmp ;
  Uint tmp___0 ;
  Uint tmp___1 ;
  Uint tmp___2 ;
  Uint tmp___3 ;
  Uint tmp___4 ;

  {
#line 33
  nodeptr = (Uint *)((void *)0);
#line 33
  largeptr = (Uint *)((void *)0);
#line 33
  distance = (Uint )0;
#line 36
  leftborder = (SYMBOL *)((void *)0);
#line 36
  edgechar = (SYMBOL )0;
#line 40
  lptr = left;
#line 41
  nodeptr = btptr;
#line 42
  if ((unsigned long )nodeptr == (unsigned long )stree->branchtab) {
#line 44
    nodedepth = (Uint )0;
#line 45
    headposition = (Uint )0;
  } else
#line 48
  if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 48
    if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 48
      distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 48
      nodedepth = stree->currentdepth + distance;
#line 48
      headposition = stree->nextfreeleafnum - distance;
    } else {
#line 48
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 48
  if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 48
    nodedepth = *(nodeptr + 2);
#line 48
    headposition = *(nodeptr + 3);
  } else {
#line 48
    distance = *(nodeptr + 2);
#line 48
    largeptr = nodeptr + distance * 3U;
#line 48
    nodedepth = *(largeptr + 2) + distance;
#line 48
    headposition = *(largeptr + 3) - distance;
  }
#line 50
  loc->nextnode.toleaf = (unsigned char)0;
#line 51
  loc->nextnode.address = nodeptr;
#line 52
  loc->locstring.start = headposition;
#line 53
  loc->locstring.length = nodedepth;
#line 54
  loc->remain = (Uint )0;
#line 55
  if (rescanlength <= nodedepth) {
#line 57
    remainingtoskip = (Uint )0;
  } else {
#line 60
    remainingtoskip = rescanlength - nodedepth;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if ((unsigned long )lptr > (unsigned long )right) {
#line 66
      return ((SYMBOL *)((void *)0));
    }
#line 68
    firstchar = *lptr;
#line 69
    if ((unsigned long )nodeptr == (unsigned long )stree->branchtab) {
#line 71
      node = *(stree->rootchildren + (Uint )firstchar);
#line 71
      if (node == 4294967295U) {
#line 73
        return (lptr);
      }
#line 75
      if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 77
        leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 78
        loc->firstptr = stree->text + leafindex;
#line 79
        if (remainingtoskip > 0U) {
          {
#line 81
          tmp = lcp(lptr + remainingtoskip, right, loc->firstptr + remainingtoskip,
                    stree->sentinel - 1);
#line 81
          prefixlen = remainingtoskip + tmp;
          }
        } else {
          {
#line 86
          tmp___0 = lcp(lptr + 1, right, loc->firstptr + 1, stree->sentinel - 1);
#line 86
          prefixlen = 1U + tmp___0;
          }
        }
#line 89
        loc->previousnode = stree->branchtab;
#line 90
        loc->edgelen = (stree->textlen - leafindex) + 1U;
#line 91
        loc->remain = loc->edgelen - prefixlen;
#line 92
        loc->nextnode.toleaf = (unsigned char)1;
#line 93
        loc->nextnode.address = stree->leaftab + leafindex;
#line 94
        loc->locstring.start = leafindex;
#line 95
        loc->locstring.length = prefixlen;
#line 96
        if (prefixlen == (Uint )((right - lptr) + 1L)) {
#line 98
          return ((SYMBOL *)((void *)0));
        }
#line 100
        return (lptr + prefixlen);
      }
#line 102
      nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 103
      if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 103
        if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 103
          distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 103
          headposition = stree->nextfreeleafnum - distance;
        } else {
#line 103
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 103
      if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 103
        headposition = *(nodeptr + 3);
      } else {
#line 103
        distance = *(nodeptr + 2);
#line 103
        largeptr = nodeptr + distance * 3U;
#line 103
        headposition = *(largeptr + 3) - distance;
      }
#line 104
      leftborder = stree->text + headposition;
    } else {
#line 107
      node = *nodeptr & ((1U << ((1U << 5) - 1U)) - 1U);
      {
#line 108
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 110
        if (node & (1U << ((1U << 5) - 1U))) {
#line 112
          return (lptr);
        }
#line 114
        if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 116
          leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 117
          leftborder = stree->text + (nodedepth + leafindex);
#line 118
          if ((unsigned long )leftborder == (unsigned long )stree->sentinel) {
#line 120
            return (lptr);
          }
#line 122
          edgechar = *leftborder;
#line 123
          if ((int )edgechar > (int )firstchar) {
#line 125
            return (lptr);
          }
#line 127
          if ((int )edgechar == (int )firstchar) {
#line 129
            if (remainingtoskip > 0U) {
              {
#line 131
              tmp___1 = lcp(lptr + remainingtoskip, right, leftborder + remainingtoskip,
                            stree->sentinel - 1);
#line 131
              prefixlen = remainingtoskip + tmp___1;
              }
            } else {
              {
#line 136
              tmp___2 = lcp(lptr + 1, right, leftborder + 1, stree->sentinel - 1);
#line 136
              prefixlen = 1U + tmp___2;
              }
            }
#line 139
            loc->firstptr = leftborder;
#line 140
            loc->previousnode = loc->nextnode.address;
#line 141
            loc->edgelen = (stree->textlen - (nodedepth + leafindex)) + 1U;
#line 142
            loc->remain = loc->edgelen - prefixlen;
#line 143
            loc->nextnode.toleaf = (unsigned char)1;
#line 144
            loc->nextnode.address = stree->leaftab + leafindex;
#line 145
            loc->locstring.start = leafindex;
#line 146
            loc->locstring.length = nodedepth + prefixlen;
#line 147
            if (prefixlen == (Uint )((right - lptr) + 1L)) {
#line 149
              return ((SYMBOL *)((void *)0));
            }
#line 151
            return (lptr + prefixlen);
          }
#line 153
          node = *(stree->leaftab + leafindex);
        } else {
#line 156
          nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 157
          if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 157
            if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 157
              distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 157
              headposition = stree->nextfreeleafnum - distance;
            } else {
#line 157
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 157
          if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 157
            headposition = *(nodeptr + 3);
          } else {
#line 157
            distance = *(nodeptr + 2);
#line 157
            largeptr = nodeptr + distance * 3U;
#line 157
            headposition = *(largeptr + 3) - distance;
          }
#line 158
          leftborder = stree->text + (nodedepth + headposition);
#line 159
          edgechar = *leftborder;
#line 160
          if ((int )edgechar > (int )firstchar) {
#line 162
            return (lptr);
          }
#line 164
          if ((int )edgechar == (int )firstchar) {
#line 166
            goto while_break___0;
          }
#line 168
          node = *(nodeptr + 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 172
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 172
      if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 172
        distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 172
        tmpnodedepth = stree->currentdepth + distance;
      } else {
#line 172
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 172
    if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 172
      tmpnodedepth = *(nodeptr + 2);
    } else {
#line 172
      distance = *(nodeptr + 2);
#line 172
      largeptr = nodeptr + distance * 3U;
#line 172
      tmpnodedepth = *(largeptr + 2) + distance;
    }
#line 173
    edgelen = tmpnodedepth - nodedepth;
#line 174
    if (remainingtoskip > 0U) {
#line 176
      if (remainingtoskip >= edgelen) {
#line 178
        prefixlen = edgelen;
#line 179
        remainingtoskip -= prefixlen;
      } else {
        {
#line 183
        tmp___3 = lcp(lptr + remainingtoskip, right, leftborder + remainingtoskip,
                      (leftborder + edgelen) - 1);
#line 183
        prefixlen = remainingtoskip + tmp___3;
#line 186
        remainingtoskip = (Uint )0;
        }
      }
    } else {
      {
#line 191
      tmp___4 = lcp(lptr + 1, right, leftborder + 1, (leftborder + edgelen) - 1);
#line 191
      prefixlen = 1U + tmp___4;
      }
    }
#line 194
    loc->nextnode.toleaf = (unsigned char)0;
#line 195
    loc->locstring.start = headposition;
#line 196
    loc->locstring.length = nodedepth + prefixlen;
#line 197
    if (prefixlen == edgelen) {
#line 199
      lptr += edgelen;
#line 200
      nodedepth += edgelen;
#line 201
      loc->nextnode.address = nodeptr;
#line 202
      loc->remain = (Uint )0;
    } else {
#line 205
      loc->firstptr = leftborder;
#line 206
      loc->previousnode = loc->nextnode.address;
#line 207
      loc->nextnode.address = nodeptr;
#line 208
      loc->edgelen = edgelen;
#line 209
      loc->remain = loc->edgelen - prefixlen;
#line 210
      if (prefixlen == (Uint )((right - lptr) + 1L)) {
#line 212
        return ((SYMBOL *)((void *)0));
      }
#line 214
      return (lptr + prefixlen);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 219 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/scanpref.c"
SYMBOL *scanprefixstree(Suffixtree *stree , Location *outloc , Location *inloc , SYMBOL *left ,
                        SYMBOL *right , Uint rescanlength ) 
{ 
  Uint prefixlen ;
  Uint remainingtoskip ;
  SYMBOL *tmp ;
  Uint tmp___0 ;
  Uint tmp___1 ;
  SYMBOL *tmp___2 ;

  {
#line 228
  if (inloc->remain == 0U) {
    {
#line 230
    tmp = scanprefixfromnodestree(stree, outloc, inloc->nextnode.address, left, right,
                                  rescanlength);
    }
#line 230
    return (tmp);
  }
#line 233
  if (rescanlength <= inloc->locstring.length) {
#line 235
    remainingtoskip = (Uint )0;
  } else {
#line 238
    remainingtoskip = rescanlength - inloc->locstring.length;
  }
#line 240
  if (inloc->nextnode.toleaf) {
#line 243
    if (remainingtoskip > 0U) {
      {
#line 245
      tmp___0 = lcp(left + remainingtoskip, right, (inloc->firstptr + (inloc->edgelen - inloc->remain)) + remainingtoskip,
                    stree->sentinel - 1);
#line 245
      prefixlen = remainingtoskip + tmp___0;
      }
    } else {
      {
#line 252
      prefixlen = lcp(left, right, inloc->firstptr + (inloc->edgelen - inloc->remain),
                      stree->sentinel - 1);
      }
    }
#line 256
    outloc->firstptr = inloc->firstptr;
#line 257
    outloc->edgelen = inloc->edgelen;
#line 258
    outloc->remain = inloc->remain - prefixlen;
#line 259
    outloc->previousnode = inloc->previousnode;
#line 260
    outloc->nextnode.toleaf = (unsigned char)1;
#line 261
    outloc->nextnode.address = inloc->nextnode.address;
#line 262
    outloc->locstring.start = (Uint )(inloc->nextnode.address - stree->leaftab);
#line 263
    outloc->locstring.length = inloc->locstring.length + prefixlen;
#line 264
    return (left + prefixlen);
  }
#line 266
  if (remainingtoskip > 0U) {
#line 268
    if (remainingtoskip >= inloc->remain) {
#line 270
      prefixlen = inloc->remain;
    } else {
      {
#line 273
      tmp___1 = lcp(left + remainingtoskip, right, (inloc->firstptr + (inloc->edgelen - inloc->remain)) + remainingtoskip,
                    (inloc->firstptr + inloc->edgelen) - 1);
#line 273
      prefixlen = remainingtoskip + tmp___1;
      }
    }
  } else {
    {
#line 281
    prefixlen = lcp(left, right, inloc->firstptr + (inloc->edgelen - inloc->remain),
                    (inloc->firstptr + inloc->edgelen) - 1);
    }
  }
#line 285
  if (prefixlen < inloc->remain) {
#line 287
    outloc->firstptr = inloc->firstptr;
#line 288
    outloc->edgelen = inloc->edgelen;
#line 289
    outloc->remain = inloc->remain - prefixlen;
#line 290
    outloc->previousnode = inloc->previousnode;
#line 291
    outloc->nextnode.toleaf = (unsigned char)0;
#line 292
    outloc->nextnode.address = inloc->nextnode.address;
#line 293
    outloc->locstring.start = inloc->locstring.start;
#line 294
    outloc->locstring.length = inloc->locstring.length + prefixlen;
#line 295
    return (left + prefixlen);
  }
  {
#line 297
  tmp___2 = scanprefixfromnodestree(stree, outloc, inloc->nextnode.address, left + prefixlen,
                                    right, rescanlength);
  }
#line 297
  return (tmp___2);
}
}
#line 301 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/scanpref.c"
SYMBOL *findprefixpathfromnodestree(Suffixtree *stree , ArrayPathinfo *path , Location *loc ,
                                    Bref btptr , SYMBOL *left , SYMBOL *right , Uint rescanlength ) 
{ 
  Uint *nodeptr ;
  Uint *largeptr ;
  Uint leafindex ;
  Uint nodedepth ;
  Uint edgelen ;
  Uint node ;
  Uint distance ;
  Uint prefixlen ;
  Uint headposition ;
  Uint remainingtoskip ;
  Uint tmpnodedepth ;
  SYMBOL *leftborder ;
  SYMBOL *lptr ;
  SYMBOL firstchar ;
  SYMBOL edgechar ;
  Uint tmp ;
  Uint tmp___0 ;
  Uint tmp___1 ;
  Uint tmp___2 ;
  Uint tmp___3 ;
  Uint tmp___4 ;
  void *tmp___5 ;

  {
#line 309
  nodeptr = (Uint *)((void *)0);
#line 309
  largeptr = (Uint *)((void *)0);
#line 309
  distance = (Uint )0;
#line 312
  leftborder = (SYMBOL *)((void *)0);
#line 312
  edgechar = (SYMBOL )0;
#line 314
  lptr = left;
#line 315
  nodeptr = btptr;
#line 316
  if ((unsigned long )nodeptr == (unsigned long )stree->branchtab) {
#line 318
    nodedepth = (Uint )0;
#line 319
    headposition = (Uint )0;
  } else
#line 322
  if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 322
    if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 322
      distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 322
      nodedepth = stree->currentdepth + distance;
#line 322
      headposition = stree->nextfreeleafnum - distance;
    } else {
#line 322
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 322
  if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 322
    nodedepth = *(nodeptr + 2);
#line 322
    headposition = *(nodeptr + 3);
  } else {
#line 322
    distance = *(nodeptr + 2);
#line 322
    largeptr = nodeptr + distance * 3U;
#line 322
    nodedepth = *(largeptr + 2) + distance;
#line 322
    headposition = *(largeptr + 3) - distance;
  }
#line 324
  loc->nextnode.toleaf = (unsigned char)0;
#line 325
  loc->nextnode.address = nodeptr;
#line 326
  loc->locstring.start = headposition;
#line 327
  loc->locstring.length = nodedepth;
#line 328
  loc->remain = (Uint )0;
#line 329
  if (rescanlength <= nodedepth) {
#line 331
    remainingtoskip = (Uint )0;
  } else {
#line 334
    remainingtoskip = rescanlength - nodedepth;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if ((unsigned long )lptr > (unsigned long )right) {
#line 340
      return ((SYMBOL *)((void *)0));
    }
#line 342
    firstchar = *lptr;
#line 343
    if ((unsigned long )nodeptr == (unsigned long )stree->branchtab) {
#line 345
      node = *(stree->rootchildren + (Uint )firstchar);
#line 345
      if (node == 4294967295U) {
#line 347
        return (lptr);
      }
#line 349
      if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 351
        leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 352
        loc->firstptr = stree->text + leafindex;
#line 353
        if (remainingtoskip > 0U) {
          {
#line 355
          tmp = lcp(lptr + remainingtoskip, right, loc->firstptr + remainingtoskip,
                    stree->sentinel - 1);
#line 355
          prefixlen = remainingtoskip + tmp;
          }
        } else {
          {
#line 360
          tmp___0 = lcp(lptr + 1, right, loc->firstptr + 1, stree->sentinel - 1);
#line 360
          prefixlen = 1U + tmp___0;
          }
        }
#line 363
        loc->previousnode = stree->branchtab;
#line 364
        loc->edgelen = (stree->textlen - leafindex) + 1U;
#line 365
        loc->remain = loc->edgelen - prefixlen;
#line 366
        loc->nextnode.toleaf = (unsigned char)1;
#line 367
        loc->nextnode.address = stree->leaftab + leafindex;
#line 368
        loc->locstring.start = leafindex;
#line 369
        loc->locstring.length = prefixlen;
#line 370
        if (prefixlen == (Uint )((right - lptr) + 1L)) {
#line 372
          return ((SYMBOL *)((void *)0));
        }
#line 374
        return (lptr + prefixlen);
      }
#line 376
      nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 377
      if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 377
        if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 377
          distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 377
          headposition = stree->nextfreeleafnum - distance;
        } else {
#line 377
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 377
      if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 377
        headposition = *(nodeptr + 3);
      } else {
#line 377
        distance = *(nodeptr + 2);
#line 377
        largeptr = nodeptr + distance * 3U;
#line 377
        headposition = *(largeptr + 3) - distance;
      }
#line 378
      leftborder = stree->text + headposition;
    } else {
#line 381
      node = *nodeptr & ((1U << ((1U << 5) - 1U)) - 1U);
      {
#line 382
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 384
        if (node & (1U << ((1U << 5) - 1U))) {
#line 386
          return (lptr);
        }
#line 388
        if (node & ((1U << ((1U << 5) - 1U)) >> 1)) {
#line 390
          leafindex = node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U)));
#line 391
          leftborder = stree->text + (nodedepth + leafindex);
#line 392
          if ((unsigned long )leftborder == (unsigned long )stree->sentinel) {
#line 394
            return (lptr);
          }
#line 396
          edgechar = *leftborder;
#line 397
          if ((int )edgechar > (int )firstchar) {
#line 399
            return (lptr);
          }
#line 401
          if ((int )edgechar == (int )firstchar) {
#line 403
            if (remainingtoskip > 0U) {
              {
#line 405
              tmp___1 = lcp(lptr + remainingtoskip, right, leftborder + remainingtoskip,
                            stree->sentinel - 1);
#line 405
              prefixlen = remainingtoskip + tmp___1;
              }
            } else {
              {
#line 410
              tmp___2 = lcp(lptr + 1, right, leftborder + 1, stree->sentinel - 1);
#line 410
              prefixlen = 1U + tmp___2;
              }
            }
#line 413
            loc->firstptr = leftborder;
#line 414
            loc->previousnode = loc->nextnode.address;
#line 415
            loc->edgelen = (stree->textlen - (nodedepth + leafindex)) + 1U;
#line 416
            loc->remain = loc->edgelen - prefixlen;
#line 417
            loc->nextnode.toleaf = (unsigned char)1;
#line 418
            loc->nextnode.address = stree->leaftab + leafindex;
#line 419
            loc->locstring.start = leafindex;
#line 420
            loc->locstring.length = nodedepth + prefixlen;
#line 421
            if (prefixlen == (Uint )((right - lptr) + 1L)) {
#line 423
              return ((SYMBOL *)((void *)0));
            }
#line 425
            return (lptr + prefixlen);
          }
#line 427
          node = *(stree->leaftab + leafindex);
        } else {
#line 430
          nodeptr = stree->branchtab + (node & ~ (((1U << ((1U << 5) - 1U)) >> 1) | (1U << ((1U << 5) - 1U))));
#line 431
          if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 431
            if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 431
              distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 431
              headposition = stree->nextfreeleafnum - distance;
            } else {
#line 431
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 431
          if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 431
            headposition = *(nodeptr + 3);
          } else {
#line 431
            distance = *(nodeptr + 2);
#line 431
            largeptr = nodeptr + distance * 3U;
#line 431
            headposition = *(largeptr + 3) - distance;
          }
#line 432
          leftborder = stree->text + (nodedepth + headposition);
#line 433
          edgechar = *leftborder;
#line 434
          if ((int )edgechar > (int )firstchar) {
#line 436
            return (lptr);
          }
#line 438
          if ((int )edgechar == (int )firstchar) {
#line 440
            goto while_break___0;
          }
#line 442
          node = *(nodeptr + 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 446
    if ((unsigned long )stree->chainstart != (unsigned long )((void *)0)) {
#line 446
      if ((unsigned long )nodeptr >= (unsigned long )stree->chainstart) {
#line 446
        distance = 1U + (Uint )(stree->nextfreebranch - nodeptr) / 3U;
#line 446
        tmpnodedepth = stree->currentdepth + distance;
      } else {
#line 446
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 446
    if (! (*nodeptr & (1U << ((1U << 5) - 1U)))) {
#line 446
      tmpnodedepth = *(nodeptr + 2);
    } else {
#line 446
      distance = *(nodeptr + 2);
#line 446
      largeptr = nodeptr + distance * 3U;
#line 446
      tmpnodedepth = *(largeptr + 2) + distance;
    }
#line 447
    edgelen = tmpnodedepth - nodedepth;
#line 448
    if (remainingtoskip > 0U) {
#line 450
      if (remainingtoskip >= edgelen) {
#line 452
        prefixlen = edgelen;
#line 453
        remainingtoskip -= prefixlen;
      } else {
        {
#line 457
        tmp___3 = lcp(lptr + remainingtoskip, right, leftborder + remainingtoskip,
                      (leftborder + edgelen) - 1);
#line 457
        prefixlen = remainingtoskip + tmp___3;
#line 460
        remainingtoskip = (Uint )0;
        }
      }
    } else {
      {
#line 465
      tmp___4 = lcp(lptr + 1, right, leftborder + 1, (leftborder + edgelen) - 1);
#line 465
      prefixlen = 1U + tmp___4;
      }
    }
#line 468
    loc->nextnode.toleaf = (unsigned char)0;
#line 469
    loc->locstring.start = headposition;
#line 470
    loc->locstring.length = nodedepth + prefixlen;
#line 471
    if (prefixlen == edgelen) {
#line 473
      lptr += edgelen;
#line 474
      nodedepth += edgelen;
#line 475
      loc->nextnode.address = nodeptr;
#line 476
      loc->remain = (Uint )0;
    } else {
#line 479
      loc->firstptr = leftborder;
#line 480
      loc->previousnode = loc->nextnode.address;
#line 481
      loc->nextnode.address = nodeptr;
#line 482
      loc->edgelen = edgelen;
#line 483
      loc->remain = loc->edgelen - prefixlen;
#line 484
      if (prefixlen == (Uint )((right - lptr) + 1L)) {
#line 486
        return ((SYMBOL *)((void *)0));
      }
#line 488
      return (lptr + prefixlen);
    }
#line 490
    if (path->nextfreePathinfo >= path->allocatedPathinfo) {
      {
#line 490
      path->allocatedPathinfo += 128U;
#line 490
      tmp___5 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/scanpref.c",
                                       (Uint )490, (void *)path->spacePathinfo, (Uint )sizeof(Pathinfo ),
                                       path->allocatedPathinfo);
#line 490
      path->spacePathinfo = (Pathinfo *)tmp___5;
      }
    }
#line 491
    (path->spacePathinfo + path->nextfreePathinfo)->ref = nodeptr;
#line 492
    (path->spacePathinfo + path->nextfreePathinfo)->depth = tmpnodedepth;
#line 493
    (path->spacePathinfo + path->nextfreePathinfo)->headposition = headposition;
#line 494
    (path->nextfreePathinfo) ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 498 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/scanpref.c"
SYMBOL *findprefixpathstree(Suffixtree *stree , ArrayPathinfo *path , Location *outloc ,
                            Location *inloc , SYMBOL *left , SYMBOL *right , Uint rescanlength ) 
{ 
  Uint prefixlen ;
  Uint remainingtoskip ;
  void *tmp ;
  SYMBOL *tmp___0 ;
  Uint tmp___1 ;
  Uint tmp___2 ;
  void *tmp___3 ;
  SYMBOL *tmp___4 ;

  {
#line 511
  if (inloc->remain == 0U) {
#line 513
    if (path->nextfreePathinfo >= path->allocatedPathinfo) {
      {
#line 513
      path->allocatedPathinfo += 128U;
#line 513
      tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/scanpref.c",
                                   (Uint )513, (void *)path->spacePathinfo, (Uint )sizeof(Pathinfo ),
                                   path->allocatedPathinfo);
#line 513
      path->spacePathinfo = (Pathinfo *)tmp;
      }
    }
    {
#line 514
    (path->spacePathinfo + path->nextfreePathinfo)->ref = inloc->nextnode.address;
#line 516
    (path->spacePathinfo + path->nextfreePathinfo)->depth = inloc->locstring.length;
#line 518
    (path->spacePathinfo + path->nextfreePathinfo)->headposition = inloc->locstring.start;
#line 520
    (path->nextfreePathinfo) ++;
#line 521
    tmp___0 = findprefixpathfromnodestree(stree, path, outloc, inloc->nextnode.address,
                                          left, right, rescanlength);
    }
#line 521
    return (tmp___0);
  }
#line 525
  if (rescanlength <= inloc->locstring.length) {
#line 527
    remainingtoskip = (Uint )0;
  } else {
#line 530
    remainingtoskip = rescanlength - inloc->locstring.length;
  }
#line 532
  if (inloc->nextnode.toleaf) {
#line 534
    if (remainingtoskip > 0U) {
      {
#line 536
      tmp___1 = lcp(left + remainingtoskip, right, (inloc->firstptr + (inloc->edgelen - inloc->remain)) + remainingtoskip,
                    stree->sentinel - 1);
#line 536
      prefixlen = remainingtoskip + tmp___1;
      }
    } else {
      {
#line 543
      prefixlen = lcp(left, right, inloc->firstptr + (inloc->edgelen - inloc->remain),
                      stree->sentinel - 1);
      }
    }
#line 547
    outloc->firstptr = inloc->firstptr;
#line 548
    outloc->edgelen = inloc->edgelen;
#line 549
    outloc->remain = inloc->remain - prefixlen;
#line 550
    outloc->previousnode = inloc->previousnode;
#line 551
    outloc->nextnode.toleaf = (unsigned char)1;
#line 552
    outloc->nextnode.address = inloc->nextnode.address;
#line 553
    outloc->locstring.start = (Uint )(inloc->nextnode.address - stree->leaftab);
#line 554
    outloc->locstring.length = inloc->locstring.length + prefixlen;
#line 555
    return (left + prefixlen);
  }
#line 557
  if (remainingtoskip > 0U) {
#line 559
    if (remainingtoskip >= inloc->remain) {
#line 561
      prefixlen = inloc->remain;
    } else {
      {
#line 564
      tmp___2 = lcp(left + remainingtoskip, right, (inloc->firstptr + (inloc->edgelen - inloc->remain)) + remainingtoskip,
                    (inloc->firstptr + inloc->edgelen) - 1);
#line 564
      prefixlen = remainingtoskip + tmp___2;
      }
    }
  } else {
    {
#line 572
    prefixlen = lcp(left, right, inloc->firstptr + (inloc->edgelen - inloc->remain),
                    (inloc->firstptr + inloc->edgelen) - 1);
    }
  }
#line 576
  if (prefixlen < inloc->remain) {
#line 578
    outloc->firstptr = inloc->firstptr;
#line 579
    outloc->edgelen = inloc->edgelen;
#line 580
    outloc->remain = inloc->remain - prefixlen;
#line 581
    outloc->previousnode = inloc->previousnode;
#line 582
    outloc->nextnode.toleaf = (unsigned char)0;
#line 583
    outloc->nextnode.address = inloc->nextnode.address;
#line 584
    outloc->locstring.start = inloc->locstring.start;
#line 585
    outloc->locstring.length = inloc->locstring.length + prefixlen;
#line 586
    return (left + prefixlen);
  }
#line 588
  if (path->nextfreePathinfo >= path->allocatedPathinfo) {
    {
#line 588
    path->allocatedPathinfo += 128U;
#line 588
    tmp___3 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/scanpref.c",
                                     (Uint )588, (void *)path->spacePathinfo, (Uint )sizeof(Pathinfo ),
                                     path->allocatedPathinfo);
#line 588
    path->spacePathinfo = (Pathinfo *)tmp___3;
    }
  }
  {
#line 589
  (path->spacePathinfo + path->nextfreePathinfo)->ref = inloc->nextnode.address;
#line 590
  (path->spacePathinfo + path->nextfreePathinfo)->depth = inloc->locstring.length + prefixlen;
#line 592
  (path->spacePathinfo + path->nextfreePathinfo)->headposition = inloc->locstring.start;
#line 594
  (path->nextfreePathinfo) ++;
#line 595
  tmp___4 = findprefixpathfromnodestree(stree, path, outloc, inloc->nextnode.address,
                                        left + prefixlen, right, rescanlength);
  }
#line 595
  return (tmp___4);
}
}
#line 90 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
Uint getleafcountstree(Suffixtree *stree , Bref nodeptr ) ;
#line 91
Sint addleafcountsstree(Suffixtree *stree ) ;
#line 22 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c"
static Sint processleaf___0(Uint leafnumber , Bref lcpnode , void *info ) 
{ 
  Countstate *cstate ;

  {
#line 25
  cstate = (Countstate *)info;
#line 27
  (*(cstate->countstack.spaceUint + (cstate->countstack.nextfreeUint - 1U))) ++;
#line 28
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c"
static unsigned char processbranch1___0(Bref nodeptr , void *info ) 
{ 
  Countstate *cstate ;
  void *tmp ;
  Uint tmp___0 ;

  {
#line 33
  cstate = (Countstate *)info;
#line 35
  if (cstate->countstack.nextfreeUint >= cstate->countstack.allocatedUint) {
    {
#line 35
    cstate->countstack.allocatedUint += 128U;
#line 35
    tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c",
                                 (Uint )35, (void *)cstate->countstack.spaceUint,
                                 (Uint )sizeof(Uint ), cstate->countstack.allocatedUint);
#line 35
    cstate->countstack.spaceUint = (Uint *)tmp;
    }
  }
#line 36
  tmp___0 = cstate->countstack.nextfreeUint;
#line 36
  (cstate->countstack.nextfreeUint) ++;
#line 36
  *(cstate->countstack.spaceUint + tmp___0) = (Uint )0;
#line 37
  return ((unsigned char)1);
}
}
#line 44 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c"
static Sint processbranch2___0(Bref nodeptr , void *info ) 
{ 
  Countstate *cstate ;
  Branchinfo branchinfo ;
  Uint *father ;

  {
  {
#line 46
  cstate = (Countstate *)info;
#line 50
  (cstate->countstack.nextfreeUint) --;
#line 51
  father = (cstate->countstack.spaceUint + cstate->countstack.nextfreeUint) - 1;
#line 52
  *father += *(father + 1);
#line 53
  getbranchinfostree(cstate->stree, 1U | (1U << 1), & branchinfo, nodeptr);
#line 62
  *((cstate->stree)->leafcounts + branchinfo.headposition) = *(father + 1);
#line 66
  *(father + 1) = (Uint )0;
  }
#line 67
  return (0);
}
}
#line 79 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c"
Uint getleafcountstree(Suffixtree *stree , Bref nodeptr ) 
{ 
  Branchinfo branchinfo ;

  {
  {
#line 90
  getbranchinfostree(stree, 1U << 1, & branchinfo, nodeptr);
  }
#line 91
  return (*(stree->leafcounts + branchinfo.headposition));
}
}
#line 139 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c"
Sint addleafcountsstree(Suffixtree *stree ) 
{ 
  Countstate cstate ;
  Reference rootref ;
  Uint i ;
  void *tmp ;
  void *tmp___0 ;
  Uint tmp___1 ;
  Sint tmp___2 ;

  {
#line 145
  cstate.stree = stree;
#line 146
  cstate.countstack.spaceUint = (Uint *)((void *)0);
#line 146
  cstate.countstack.nextfreeUint = (Uint )0;
#line 146
  cstate.countstack.allocatedUint = cstate.countstack.nextfreeUint;
#line 147
  if (cstate.countstack.nextfreeUint >= cstate.countstack.allocatedUint) {
    {
#line 147
    cstate.countstack.allocatedUint += 128U;
#line 147
    tmp = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c",
                                 (Uint )147, (void *)cstate.countstack.spaceUint,
                                 (Uint )sizeof(Uint ), cstate.countstack.allocatedUint);
#line 147
    cstate.countstack.spaceUint = (Uint *)tmp;
    }
  }
  {
#line 148
  tmp___0 = allocandusespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c",
                                   (Uint )148, (void *)0, (Uint )sizeof(Uint ), stree->nextfreeleafnum + 1U);
#line 148
  stree->leafcounts = (Uint *)tmp___0;
#line 149
  i = (Uint )0;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i <= stree->nextfreeleafnum)) {
#line 149
      goto while_break;
    }
#line 151
    *(stree->leafcounts + i) = (Uint )0;
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  tmp___1 = cstate.countstack.nextfreeUint;
#line 153
  (cstate.countstack.nextfreeUint) ++;
#line 153
  *(cstate.countstack.spaceUint + tmp___1) = (Uint )0;
#line 154
  rootref.toleaf = (unsigned char)0;
#line 155
  rootref.address = stree->branchtab;
#line 156
  tmp___2 = depthfirststree(stree, & rootref, & processleaf___0, & processbranch1___0,
                            & processbranch2___0, (unsigned char (*)(void * ))((void *)0),
                            (void *)0, (void *)(& cstate));
  }
#line 156
  if (tmp___2 != 0) {
#line 159
    return (-1);
  }
#line 162
  if ((unsigned long )cstate.countstack.spaceUint != (unsigned long )((void *)0)) {
#line 162
    if ((unsigned long )cstate.countstack.spaceUint != (unsigned long )((void *)0)) {
      {
#line 162
      freespaceviaptr((char *)"/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/addleafcount.c",
                      (Uint )162, (void *)cstate.countstack.spaceUint);
#line 162
      cstate.countstack.spaceUint = (Uint *)((void *)0);
      }
    }
  }
#line 166
  return (0);
}
}
#line 80 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/streeproto.h"
void overallstree(Suffixtree *stree , unsigned char skiproot , void (*processnode)(Suffixtree * ,
                                                                                   Bref  ,
                                                                                   Uint  ,
                                                                                   Uint  ,
                                                                                   void * ) ,
                  void *info ) ;
#line 83
void overmaximalstree(Suffixtree *stree , void (*processnode)(Suffixtree * , Bref  ,
                                                              Uint  , Uint  , void * ) ,
                      void *info ) ;
#line 14 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/overmax.c"
void overallstree(Suffixtree *stree , unsigned char skiproot , void (*processnode)(Suffixtree * ,
                                                                                   Bref  ,
                                                                                   Uint  ,
                                                                                   Uint  ,
                                                                                   void * ) ,
                  void *info ) 
{ 
  Uint depth ;
  Uint headposition ;
  Uint *btptr ;
  Uint *largeptr ;
  Uint distance ;

  {
#line 20
  if (skiproot) {
#line 22
    btptr = stree->branchtab + 5;
  } else {
#line 25
    btptr = stree->branchtab;
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! ((unsigned long )btptr < (unsigned long )stree->nextfreebranch)) {
#line 27
      goto while_break;
    }
#line 29
    if (! (*btptr & (1U << ((1U << 5) - 1U)))) {
      {
#line 31
      depth = *(btptr + 2);
#line 32
      headposition = *(btptr + 3);
#line 33
      (*processnode)(stree, btptr, depth, headposition, info);
#line 34
      btptr += 5;
      }
    } else {
#line 37
      distance = *(btptr + 2);
#line 38
      largeptr = btptr + distance * 3U;
#line 39
      depth = *(largeptr + 2);
#line 40
      headposition = *(largeptr + 3);
      {
#line 41
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 41
        if (! (distance > 0U)) {
#line 41
          goto while_break___0;
        }
        {
#line 43
        (*processnode)(stree, btptr, depth + distance, headposition - distance, info);
#line 44
        distance --;
#line 45
        btptr += 3;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 47
      (*processnode)(stree, btptr, depth, headposition, info);
#line 48
      btptr += 5;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/mummer-3.23~dfsg/src/kurtz/streesrc/overmax.c"
void overmaximalstree(Suffixtree *stree , void (*processnode)(Suffixtree * , Bref  ,
                                                              Uint  , Uint  , void * ) ,
                      void *info ) 
{ 
  Uint *btptr ;
  Uint *nextptr ;
  Uint *largeptr ;
  Uint depth ;
  Uint headposition ;
  Uint distance ;

  {
#line 59
  btptr = stree->branchtab + 5;
#line 60
  if ((unsigned long )stree->nonmaximal == (unsigned long )((void *)0)) {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stree->nonmaximal is NULL\n");
#line 63
    exit(1);
    }
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((unsigned long )btptr < (unsigned long )stree->nextfreebranch)) {
#line 65
      goto while_break;
    }
#line 67
    if (! (*btptr & (1U << ((1U << 5) - 1U)))) {
#line 69
      depth = *(btptr + 2);
#line 70
      headposition = *(btptr + 3);
#line 71
      nextptr = btptr + 5;
    } else {
#line 74
      distance = *(btptr + 2);
#line 75
      largeptr = btptr + distance * 3U;
#line 76
      depth = *(largeptr + 2) + distance;
#line 77
      headposition = *(largeptr + 3) - distance;
#line 78
      nextptr = largeptr + 5;
    }
#line 80
    if (! (*(stree->nonmaximal + (headposition >> 5)) & ((1U << ((1U << 5) - 1U)) >> (headposition & ((1U << 5) - 1U))))) {
      {
#line 84
      (*processnode)(stree, btptr, depth, headposition, info);
      }
    }
#line 86
    btptr = nextptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return;
}
}
