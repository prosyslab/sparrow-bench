/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 136 "/usr/include/stdint.h"
typedef unsigned long uintmax_t;
#line 26 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.h"
typedef enum strtol_error strtol_error;
#line 196 "./getopt.h"
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 27 "./unitypes.h"
typedef uint32_t ucs4_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef int wchar_t;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_23 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_22 {
   int __count ;
   union __anonunion___value_23 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_22 __mbstate_t;
#line 352 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int wint_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 161 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 100 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbiter.h"
struct mbiter_multi {
   char const   *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 195 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbiter.h"
typedef struct mbiter_multi mbi_iterator_t;
#line 134 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 56 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 66 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/striconv.c"
union __anonunion_tmp_21 {
   unsigned int align ;
   char buf[4096] ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef long ptrdiff_t;
#line 32 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 237
struct quoting_options;
#line 45 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 677 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 173 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbchar.h"
typedef struct mbchar mbchar_t;
#line 109 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 202 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 53 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/malloca.c"
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
#line 57 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/malloca.c"
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 135 "/usr/include/stdint.h"
typedef long intmax_t;
#line 43 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 55 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 57
struct hash_table;
#line 59 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.h"
typedef struct hash_table Hash_table;
#line 46 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 158 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 92 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 62 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt_int.h"
enum __ord {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 68 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __ord __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 485 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
struct option_list {
   struct rpl_option  const  *p ;
   struct option_list *next ;
};
#line 53 "/usr/include/wctype.h"
typedef unsigned long wctype_t;
#line 1034 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
struct patternlist {
   struct patternlist *next ;
   char str[1] ;
};
#line 1034 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
struct patternlist___0 {
   struct patternlist *next ;
   wchar_t str[1] ;
};
#line 40 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.h"
struct exclude;
#line 74 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
struct patopts {
   char const   *pattern ;
   int options ;
};
#line 82 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 89
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
#line 95 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
union __anonunion_v_31 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
#line 95 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_31 v ;
};
#line 108 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
struct exclude {
   struct exclude_segment *head ;
   struct exclude_segment *tail ;
};
#line 180 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 40 "/usr/include/bits/types.h"
typedef unsigned short __uint16_t;
#line 42 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 45 "/usr/include/bits/types.h"
typedef unsigned long __uint64_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 50 "/usr/include/bits/sigstack.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 50 "/usr/include/bits/sigstack.h"
typedef struct sigaltstack stack_t;
#line 33 "/usr/include/sys/ucontext.h"
typedef long greg_t;
#line 39 "/usr/include/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 94 "/usr/include/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
#line 101 "/usr/include/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 106 "/usr/include/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t padding[24] ;
};
#line 123 "/usr/include/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 126 "/usr/include/sys/ucontext.h"
struct __anonstruct_mcontext_t_36 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long __reserved1[8] ;
};
#line 126 "/usr/include/sys/ucontext.h"
typedef struct __anonstruct_mcontext_t_36 mcontext_t;
#line 135 "/usr/include/sys/ucontext.h"
struct ucontext {
   unsigned long uc_flags ;
   struct ucontext *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   __sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
};
#line 135 "/usr/include/sys/ucontext.h"
typedef struct ucontext ucontext_t;
#line 84 "/usr/include/sigsegv.h"
typedef ucontext_t *stackoverflow_context_t;
#line 133 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
union __anonunion_alternate_signal_stack_46 {
   char buffer[16384] ;
   long double ld ;
   long l ;
   void *p ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 131 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/system.h"
typedef ptrdiff_t lin;
#line 77 "../lib/regex.h"
typedef int regoff_t;
#line 78 "../lib/regex.h"
typedef int __re_idx_t;
#line 79 "../lib/regex.h"
typedef unsigned int __re_size_t;
#line 80 "../lib/regex.h"
typedef unsigned long __re_long_size_t;
#line 96 "../lib/regex.h"
typedef unsigned long reg_syntax_t;
#line 452 "../lib/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 524 "../lib/regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
enum changes {
    UNCHANGED = 0,
    OLD = 1,
    NEW = 2,
    CHANGED = 3
} ;
#line 50
enum output_style {
    OUTPUT_UNSPECIFIED = 0,
    OUTPUT_NORMAL = 1,
    OUTPUT_CONTEXT = 2,
    OUTPUT_UNIFIED = 3,
    OUTPUT_ED = 4,
    OUTPUT_FORWARD_ED = 5,
    OUTPUT_RCS = 6,
    OUTPUT_IFDEF = 7,
    OUTPUT_SDIFF = 8
} ;
#line 101
enum DIFF_white_space {
    IGNORE_NO_WHITE_SPACE = 0,
    IGNORE_TAB_EXPANSION = 1,
    IGNORE_TRAILING_SPACE = 2,
    IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE = 3,
    IGNORE_SPACE_CHANGE = 4,
    IGNORE_ALL_SPACE = 5
} ;
#line 225 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
struct change {
   struct change *link ;
   lin inserted ;
   lin deleted ;
   lin line0 ;
   lin line1 ;
   _Bool ignore ;
};
#line 239 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
struct file_data {
   int desc ;
   char const   *name ;
   struct stat stat ;
   uintmax_t *buffer ;
   size_t bufsize ;
   size_t buffered ;
   char const   **linbuf ;
   lin linbuf_base ;
   lin buffered_lines ;
   lin valid_lines ;
   lin alloc_lines ;
   char const   *prefix_end ;
   lin prefix_lines ;
   char const   *suffix_begin ;
   lin *equivs ;
   lin *undiscarded ;
   lin *realindexes ;
   lin nondiscarded_lines ;
   char *changed ;
   _Bool missing_newline ;
   _Bool eof ;
   lin equiv_max ;
};
#line 32 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
struct msg {
   struct msg *next ;
   char args[1] ;
};
#line 295 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 295 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 295 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
typedef size_t hash_value;
#line 40 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
struct equivclass {
   lin next ;
   hash_value hash ;
   char const   *line ;
   size_t length ;
};
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
struct group {
   struct file_data  const  *file ;
   lin from ;
   lin upto ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 311 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
struct comparison {
   struct file_data file[2] ;
   struct comparison  const  *parent ;
};
#line 32 "/usr/include/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 35 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 49 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/dir.c"
struct dirdata {
   size_t nnames ;
   char const   **names ;
   char *data ;
};
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 58 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
struct regexp_list {
   char *regexps ;
   size_t len ;
   size_t size ;
   _Bool multiple_regexps ;
   struct re_pattern_buffer *buf ;
};
#line 101 "../lib/diffseq.h"
struct context {
   lin const   *xvec ;
   lin const   *yvec ;
   lin *fdiag ;
   lin *bdiag ;
   _Bool heuristic ;
   lin too_expensive ;
};
#line 136 "../lib/diffseq.h"
struct partition {
   lin xmid ;
   lin ymid ;
   _Bool lo_minimal ;
   _Bool hi_minimal ;
};
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 309 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  __nptr ,
                                                         char ** __restrict  __endptr ,
                                                         int __base ) ;
#line 47 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.h"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 46 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c"
static strtol_error bkm_scale(uintmax_t *x , int scale_factor ) 
{ 


  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (uintmax_t )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c"
static strtol_error bkm_scale_by_power(uintmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 74 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  uintmax_t tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
      {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c",
                    83U, "xstrtoumax");
      }
    }
  } else {
    {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c",
                  83U, "xstrtoumax");
    }
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    tmp___0 = __ctype_b_loc();
    }
#line 91
    if (! ((int const   )*(*tmp___0 + (int )ch) & 8192)) {
#line 91
      goto while_break;
    }
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((strtol_error )4);
  }
  {
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtoumax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
  }
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
        {
#line 104
        tmp___2 = strchr(valid_suffixes, (int )*(*p));
        }
#line 104
        if (tmp___2) {
#line 105
          tmp = (uintmax_t )1;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
    {
#line 109
    tmp___4 = __errno_location();
    }
#line 109
    if (*tmp___4 != 0) {
      {
#line 111
      tmp___3 = __errno_location();
      }
#line 111
      if (*tmp___3 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
    {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
    }
#line 131
    if (! tmp___5) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 137
    tmp___6 = strchr(valid_suffixes, '0');
    }
#line 137
    if (tmp___6) {
      {
#line 148
      if ((int )*(*(p + 0) + 1) == 105) {
#line 148
        goto case_105;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 68) {
#line 154
        goto case_68;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 66) {
#line 154
        goto case_68;
      }
#line 146
      goto switch_break;
      case_105: /* CIL Label */ 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 163
    if ((int )*(*p) == 98) {
#line 163
      goto case_98;
    }
#line 167
    if ((int )*(*p) == 66) {
#line 167
      goto case_66___0;
    }
#line 171
    if ((int )*(*p) == 99) {
#line 171
      goto case_99;
    }
#line 175
    if ((int )*(*p) == 69) {
#line 175
      goto case_69;
    }
#line 180
    if ((int )*(*p) == 103) {
#line 180
      goto case_103;
    }
#line 180
    if ((int )*(*p) == 71) {
#line 180
      goto case_103;
    }
#line 185
    if ((int )*(*p) == 75) {
#line 185
      goto case_75;
    }
#line 185
    if ((int )*(*p) == 107) {
#line 185
      goto case_75;
    }
#line 190
    if ((int )*(*p) == 109) {
#line 190
      goto case_109;
    }
#line 190
    if ((int )*(*p) == 77) {
#line 190
      goto case_109;
    }
#line 194
    if ((int )*(*p) == 80) {
#line 194
      goto case_80;
    }
#line 199
    if ((int )*(*p) == 116) {
#line 199
      goto case_116;
    }
#line 199
    if ((int )*(*p) == 84) {
#line 199
      goto case_116;
    }
#line 203
    if ((int )*(*p) == 119) {
#line 203
      goto case_119;
    }
#line 207
    if ((int )*(*p) == 89) {
#line 207
      goto case_89;
    }
#line 211
    if ((int )*(*p) == 90) {
#line 211
      goto case_90;
    }
#line 215
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 164
    overflow = bkm_scale(& tmp, 512);
    }
#line 165
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 168
    overflow = bkm_scale(& tmp, 1024);
    }
#line 169
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 172
    overflow = (strtol_error )0;
#line 173
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 176
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
#line 177
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
#line 182
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
#line 187
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 191
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
#line 192
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
#line 196
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
#line 201
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale(& tmp, 2);
    }
#line 205
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
#line 209
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
#line 213
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 45 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 46 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c"
static strtol_error bkm_scale___0(unsigned long *x , int scale_factor ) 
{ 


  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (unsigned long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___0(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale___0(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 74 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
      {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c",
                    83U, "xstrtoul");
      }
    }
  } else {
    {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c",
                  83U, "xstrtoul");
    }
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    tmp___0 = __ctype_b_loc();
    }
#line 91
    if (! ((int const   )*(*tmp___0 + (int )ch) & 8192)) {
#line 91
      goto while_break;
    }
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((strtol_error )4);
  }
  {
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
        {
#line 104
        tmp___2 = strchr(valid_suffixes, (int )*(*p));
        }
#line 104
        if (tmp___2) {
#line 105
          tmp = 1UL;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
    {
#line 109
    tmp___4 = __errno_location();
    }
#line 109
    if (*tmp___4 != 0) {
      {
#line 111
      tmp___3 = __errno_location();
      }
#line 111
      if (*tmp___3 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
    {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
    }
#line 131
    if (! tmp___5) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 137
    tmp___6 = strchr(valid_suffixes, '0');
    }
#line 137
    if (tmp___6) {
      {
#line 148
      if ((int )*(*(p + 0) + 1) == 105) {
#line 148
        goto case_105;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 68) {
#line 154
        goto case_68;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 66) {
#line 154
        goto case_68;
      }
#line 146
      goto switch_break;
      case_105: /* CIL Label */ 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 163
    if ((int )*(*p) == 98) {
#line 163
      goto case_98;
    }
#line 167
    if ((int )*(*p) == 66) {
#line 167
      goto case_66___0;
    }
#line 171
    if ((int )*(*p) == 99) {
#line 171
      goto case_99;
    }
#line 175
    if ((int )*(*p) == 69) {
#line 175
      goto case_69;
    }
#line 180
    if ((int )*(*p) == 103) {
#line 180
      goto case_103;
    }
#line 180
    if ((int )*(*p) == 71) {
#line 180
      goto case_103;
    }
#line 185
    if ((int )*(*p) == 75) {
#line 185
      goto case_75;
    }
#line 185
    if ((int )*(*p) == 107) {
#line 185
      goto case_75;
    }
#line 190
    if ((int )*(*p) == 109) {
#line 190
      goto case_109;
    }
#line 190
    if ((int )*(*p) == 77) {
#line 190
      goto case_109;
    }
#line 194
    if ((int )*(*p) == 80) {
#line 194
      goto case_80;
    }
#line 199
    if ((int )*(*p) == 116) {
#line 199
      goto case_116;
    }
#line 199
    if ((int )*(*p) == 84) {
#line 199
      goto case_116;
    }
#line 203
    if ((int )*(*p) == 119) {
#line 203
      goto case_119;
    }
#line 207
    if ((int )*(*p) == 89) {
#line 207
      goto case_89;
    }
#line 211
    if ((int )*(*p) == 90) {
#line 211
      goto case_90;
    }
#line 215
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 164
    overflow = bkm_scale___0(& tmp, 512);
    }
#line 165
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 168
    overflow = bkm_scale___0(& tmp, 1024);
    }
#line 169
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 172
    overflow = (strtol_error )0;
#line 173
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 176
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
#line 177
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
#line 182
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
#line 187
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 191
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
#line 192
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
#line 196
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
#line 201
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale___0(& tmp, 2);
    }
#line 205
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
#line 209
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
#line 213
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 44 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 46 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c"
static strtol_error bkm_scale___1(long *x , int scale_factor ) 
{ 


  {
#line 49
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 52
    return ((strtol_error )1);
  }
#line 54
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807L;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___1(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = bkm_scale___1(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (err);
}
}
#line 74 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
      {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c",
                    83U, "xstrtol");
      }
    }
  } else {
    {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.c",
                  83U, "xstrtol");
    }
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
  {
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
        {
#line 104
        tmp___2 = strchr(valid_suffixes, (int )*(*p));
        }
#line 104
        if (tmp___2) {
#line 105
          tmp = 1L;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
    {
#line 109
    tmp___4 = __errno_location();
    }
#line 109
    if (*tmp___4 != 0) {
      {
#line 111
      tmp___3 = __errno_location();
      }
#line 111
      if (*tmp___3 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
    {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
    }
#line 131
    if (! tmp___5) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 137
    tmp___6 = strchr(valid_suffixes, '0');
    }
#line 137
    if (tmp___6) {
      {
#line 148
      if ((int )*(*(p + 0) + 1) == 105) {
#line 148
        goto case_105;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 68) {
#line 154
        goto case_68;
      }
#line 154
      if ((int )*(*(p + 0) + 1) == 66) {
#line 154
        goto case_68;
      }
#line 146
      goto switch_break;
      case_105: /* CIL Label */ 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 163
    if ((int )*(*p) == 98) {
#line 163
      goto case_98;
    }
#line 167
    if ((int )*(*p) == 66) {
#line 167
      goto case_66___0;
    }
#line 171
    if ((int )*(*p) == 99) {
#line 171
      goto case_99;
    }
#line 175
    if ((int )*(*p) == 69) {
#line 175
      goto case_69;
    }
#line 180
    if ((int )*(*p) == 103) {
#line 180
      goto case_103;
    }
#line 180
    if ((int )*(*p) == 71) {
#line 180
      goto case_103;
    }
#line 185
    if ((int )*(*p) == 75) {
#line 185
      goto case_75;
    }
#line 185
    if ((int )*(*p) == 107) {
#line 185
      goto case_75;
    }
#line 190
    if ((int )*(*p) == 109) {
#line 190
      goto case_109;
    }
#line 190
    if ((int )*(*p) == 77) {
#line 190
      goto case_109;
    }
#line 194
    if ((int )*(*p) == 80) {
#line 194
      goto case_80;
    }
#line 199
    if ((int )*(*p) == 116) {
#line 199
      goto case_116;
    }
#line 199
    if ((int )*(*p) == 84) {
#line 199
      goto case_116;
    }
#line 203
    if ((int )*(*p) == 119) {
#line 203
      goto case_119;
    }
#line 207
    if ((int )*(*p) == 89) {
#line 207
      goto case_89;
    }
#line 211
    if ((int )*(*p) == 90) {
#line 211
      goto case_90;
    }
#line 215
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 164
    overflow = bkm_scale___1(& tmp, 512);
    }
#line 165
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 168
    overflow = bkm_scale___1(& tmp, 1024);
    }
#line 169
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 172
    overflow = (strtol_error )0;
#line 173
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 176
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    }
#line 177
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 181
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    }
#line 182
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    }
#line 187
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 191
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    }
#line 192
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    }
#line 196
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    }
#line 201
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 204
    overflow = bkm_scale___1(& tmp, 2);
    }
#line 205
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 208
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    }
#line 209
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 212
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    }
#line 213
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 69 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol.h"
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct rpl_option  const  *long_options ,
                                                  char const   *arg ) ;
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 42 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exitfail.h"
int volatile   exit_failure ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 46 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct rpl_option  const  *long_options ,
                          char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *rpl_option ;
  char option_buffer[2] ;
  char *tmp ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument `%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument `%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument `%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    rpl_option = (char const   *)(option_buffer);
  } else {
#line 84
    rpl_option = (char const   *)(long_options + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, rpl_option, arg);
  }
#line 87
  return;
}
}
#line 91
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct rpl_option  const  *long_options ,
                                                  char const   *arg ) ;
#line 91 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct rpl_option  const  *long_options ,
                   char const   *arg ) 
{ 


  {
  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options, arg, (int )exit_failure);
#line 97
  abort();
  }
}
}
#line 23 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 181 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
#line 47 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 29 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 32
  tmp = strndup(string, n);
#line 32
  s = tmp;
  }
#line 33
  if (! s) {
    {
#line 34
    xalloc_die();
    }
  }
#line 35
  return (s);
}
}
#line 45 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstriconv.h"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
#line 57
char *xstr_cd_iconv(char const   *src , iconv_t cd ) ;
#line 69
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 47 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/striconv.h"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
#line 58
char *str_cd_iconv(char const   *src , iconv_t cd ) ;
#line 69
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstriconv.c"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) 
{ 
  int retval ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 35
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
#line 35
  retval = tmp;
  }
#line 37
  if (retval < 0) {
    {
#line 37
    tmp___0 = __errno_location();
    }
#line 37
    if (*tmp___0 == 12) {
      {
#line 38
      xalloc_die();
      }
    }
  }
#line 39
  return (retval);
}
}
#line 42 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstriconv.c"
char *xstr_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 45
  tmp = str_cd_iconv(src, cd);
#line 45
  result = tmp;
  }
#line 47
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___0 = __errno_location();
    }
#line 47
    if (*tmp___0 == 12) {
      {
#line 48
      xalloc_die();
      }
    }
  }
#line 49
  return (result);
}
}
#line 54 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xstriconv.c"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 57
  tmp = str_iconv(src, from_codeset, to_codeset);
#line 57
  result = tmp;
  }
#line 59
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 59
    tmp___0 = __errno_location();
    }
#line 59
    if (*tmp___0 == 12) {
      {
#line 60
      xalloc_die();
      }
    }
  }
#line 61
  return (result);
}
}
#line 49 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc.h"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 51
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 53
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 55
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 57
void *x2realloc(void *p , size_t *pn ) ;
#line 58
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 60
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 184 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 187
  n = *pn;
#line 189
  if (! p) {
#line 191
    if (! n) {
#line 199
      n = 128UL / s;
#line 200
      n += (size_t )(! n);
    }
  } else {
#line 209
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 210
      xalloc_die();
      }
    }
#line 211
    n += (n + 1UL) / 2UL;
  }
  {
#line 214
  *pn = n;
#line 215
  tmp = xrealloc(p, n * s);
  }
#line 215
  return (tmp);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 40 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 40 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 43
  tmp = malloc(n);
#line 43
  p = tmp;
  }
#line 44
  if (! p) {
#line 44
    if (n != 0UL) {
      {
#line 45
      xalloc_die();
      }
    }
  }
#line 46
  return (p);
}
}
#line 52
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 52 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 55
  if (! n) {
#line 55
    if (p) {
      {
#line 59
      free(p);
      }
#line 60
      return ((void *)0);
    }
  }
  {
#line 63
  p = realloc(p, n);
  }
#line 64
  if (! p) {
#line 64
    if (n) {
      {
#line 65
      xalloc_die();
      }
    }
  }
#line 66
  return (p);
}
}
#line 75 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 78
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 78
  return (tmp);
}
}
#line 85
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 85 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 88
  tmp = xmalloc(s);
#line 88
  tmp___0 = memset(tmp, 0, s);
  }
#line 88
  return (tmp___0);
}
}
#line 94
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 94 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 102
  p = calloc(n, s);
  }
#line 102
  if (! p) {
    {
#line 104
    xalloc_die();
    }
  }
#line 105
  return (p);
}
}
#line 112
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
#line 112 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 115
  tmp = xmalloc(s);
#line 115
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 115
  return (tmp___0);
}
}
#line 120
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 120 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 123
  tmp = strlen(string);
#line 123
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 123
  return ((char *)tmp___0);
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 2 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xfreopen.h"
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) ;
#line 19 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/stdio-safer.h"
FILE *freopen_safer(char const   *name , char const   *mode , FILE *f ) ;
#line 29 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xfreopen.c"
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) 
{ 
  char const   *f ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  FILE *tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 32
  tmp___11 = freopen_safer(filename, mode, fp);
  }
#line 32
  if (! tmp___11) {
#line 34
    if (filename) {
#line 34
      tmp___6 = filename;
    } else {
#line 34
      if ((unsigned long )fp == (unsigned long )stdin) {
        {
#line 34
        tmp = gettext("stdin");
#line 34
        tmp___5 = tmp;
        }
      } else {
#line 34
        if ((unsigned long )fp == (unsigned long )stdout) {
          {
#line 34
          tmp___0 = gettext("stdout");
#line 34
          tmp___4 = tmp___0;
          }
        } else {
#line 34
          if ((unsigned long )fp == (unsigned long )stderr) {
            {
#line 34
            tmp___1 = gettext("stderr");
#line 34
            tmp___3 = tmp___1;
            }
          } else {
            {
#line 34
            tmp___2 = gettext("unknown stream");
#line 34
            tmp___3 = tmp___2;
            }
          }
#line 34
          tmp___4 = tmp___3;
        }
#line 34
        tmp___5 = tmp___4;
      }
#line 34
      tmp___6 = (char const   *)tmp___5;
    }
    {
#line 34
    f = tmp___6;
#line 39
    tmp___7 = quote_n(1, mode);
#line 39
    tmp___8 = quote_n(0, f);
#line 39
    tmp___9 = gettext("failed to reopen %s with mode %s");
#line 39
    tmp___10 = __errno_location();
#line 39
    error((int )exit_failure, *tmp___10, (char const   *)tmp___9, tmp___8, tmp___7);
    }
  }
#line 42
  return;
}
}
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 43 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding ) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 22 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 25
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 25
  if (tmp == 0) {
#line 37
    return (1);
  } else {
    {
#line 25
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 25
    if (tmp___0 == 0) {
#line 37
      return (1);
    } else {
      {
#line 25
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 25
      if (tmp___1 == 0) {
#line 37
        return (1);
      } else {
        {
#line 25
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 25
        if (tmp___2 == 0) {
#line 37
          return (1);
        } else {
          {
#line 25
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 25
          if (tmp___3 == 0) {
#line 37
            return (1);
          } else {
            {
#line 25
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 25
            if (tmp___4 == 0) {
#line 37
              return (1);
            } else {
              {
#line 25
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 25
              if (tmp___5 == 0) {
#line 37
                return (1);
              } else {
                {
#line 25
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 25
                if (tmp___6 == 0) {
#line 37
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 38
  return (0);
}
}
#line 37 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/uniwidth/width.c"
static unsigned char const   nonspacing_table_data[1728]  = 
#line 37 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 282 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/uniwidth/width.c"
static signed char const   nonspacing_table_ind[240]  = 
#line 282
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 316 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ 
  int ind ;
  int tmp ;
  int tmp___0 ;

  {
#line 320
  if (uc >> 9 < 240U) {
#line 322
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 323
    if (ind >= 0) {
#line 324
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 326
        if (uc > 0U) {
#line 326
          if (uc < 160U) {
#line 327
            return (-1);
          } else {
#line 329
            return (0);
          }
        } else {
#line 329
          return (0);
        }
      }
    }
  } else
#line 332
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 334
    if (uc >= 917760U) {
#line 336
      if (uc <= 917999U) {
#line 337
        return (0);
      }
    } else {
#line 341
      if (uc >= 917536U) {
#line 341
        tmp = uc <= 917631U;
      } else {
#line 341
        tmp = uc == 917505U;
      }
#line 341
      if (tmp) {
#line 342
        return (0);
      }
    }
  }
#line 349
  if (uc >= 4352U) {
#line 349
    if (uc < 4448U) {
#line 363
      return (2);
    } else
#line 349
    if (uc >= 9001U) {
#line 349
      if (uc < 9003U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 349
    if (uc >= 11904U) {
#line 349
      if (uc < 42192U) {
#line 349
        if (! (uc == 12351U)) {
#line 349
          if (uc >= 19904U) {
#line 349
            if (uc < 19968U) {
#line 349
              goto _L___8;
            } else {
#line 363
              return (2);
            }
          } else {
#line 363
            return (2);
          }
        } else {
#line 349
          goto _L___8;
        }
      } else {
#line 349
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 349
    if (uc >= 44032U) {
#line 349
      if (uc < 55204U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 349
    if (uc >= 63744U) {
#line 349
      if (uc < 64256U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 349
    if (uc >= 65040U) {
#line 349
      if (uc < 65056U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 349
    if (uc >= 65072U) {
#line 349
      if (uc < 65136U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 349
    if (uc >= 65280U) {
#line 349
      if (uc < 65377U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 349
    if (uc >= 65504U) {
#line 349
      if (uc < 65511U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 349
    if (uc >= 131072U) {
#line 349
      if (uc <= 196607U) {
#line 363
        return (2);
      } else {
#line 349
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 349
    if (uc >= 196608U) {
#line 349
      if (uc <= 262143U) {
#line 363
        return (2);
      }
    }
  }
#line 366
  if (uc >= 161U) {
#line 366
    if (uc < 65377U) {
#line 366
      if (uc != 8361U) {
        {
#line 366
        tmp___0 = is_cjk_encoding(encoding);
        }
#line 366
        if (tmp___0) {
#line 368
          return (2);
        }
      }
    }
  }
#line 369
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 333 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 699
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2011);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *__cil_tmp10 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-diffutils@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU diffutils", "http://www.gnu.org/software/diffutils/");
#line 256
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 256
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 26 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 22 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 46 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___0 ) ;
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/anytostr.c"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___0 ) 
{ 
  char *p ;

  {
#line 36
  p = buf___0 + ((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL;
#line 37
  *p = (char)0;
#line 39
  if (i < 0UL) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48UL - i % 10UL);
#line 41
      i /= 10UL;
#line 41
      if (! (i != 0UL)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      p --;
#line 50
      *p = (char )(48UL + i % 10UL);
#line 49
      i /= 10UL;
#line 49
      if (! (i != 0UL)) {
#line 49
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 54
  return (p);
}
}
#line 22
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 45 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___0 ) ;
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/anytostr.c"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___0 ) 
{ 
  char *p ;

  {
#line 36
  p = buf___0 + ((sizeof(unsigned int ) * 8UL) * 146UL + 484UL) / 485UL;
#line 37
  *p = (char)0;
#line 39
  if (i < 0U) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48U - i % 10U);
#line 41
      i /= 10U;
#line 41
      if (! (i != 0U)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      p --;
#line 50
      *p = (char )(48U + i % 10U);
#line 49
      i /= 10U;
#line 49
      if (! (i != 0U)) {
#line 49
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 54
  return (p);
}
}
#line 308 "./unistr.h"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
#line 25 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/unistr/u8-uctomb-aux.c"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) 
{ 
  int count ;

  {
#line 30
  if (uc < 128U) {
#line 32
    return (-2);
  } else
#line 33
  if (uc < 2048U) {
#line 34
    count = 2;
  } else
#line 35
  if (uc < 65536U) {
#line 37
    if (uc < 55296U) {
#line 38
      count = 3;
    } else
#line 37
    if (uc >= 57344U) {
#line 38
      count = 3;
    } else {
#line 40
      return (-1);
    }
  } else
#line 50
  if (uc < 1114112U) {
#line 51
    count = 4;
  } else {
#line 54
    return (-1);
  }
#line 56
  if (n < count) {
#line 57
    return (-2);
  }
  {
#line 65
  if (count == 4) {
#line 65
    goto case_4;
  }
#line 66
  if (count == 3) {
#line 66
    goto case_3;
  }
#line 67
  if (count == 2) {
#line 67
    goto case_2;
  }
#line 59
  goto switch_break;
  case_4: /* CIL Label */ 
#line 65
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
#line 65
  uc >>= 6;
#line 65
  uc |= 65536U;
  case_3: /* CIL Label */ 
#line 66
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
#line 66
  uc >>= 6;
#line 66
  uc |= 2048U;
  case_2: /* CIL Label */ 
#line 67
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
#line 67
  uc >>= 6;
#line 67
  uc |= 192U;
#line 68
  *(s + 0) = (uint8_t )uc;
  switch_break: /* CIL Label */ ;
  }
#line 70
  return (count);
}
}
#line 286 "./unistr.h"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) ;
#line 25 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/unistr/u8-mbtoucr.c"
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) 
{ 
  uint8_t c ;

  {
#line 28
  c = (uint8_t )*s;
#line 30
  if ((int )c < 128) {
#line 32
    *puc = (ucs4_t )c;
#line 33
    return (1);
  } else
#line 35
  if ((int )c >= 194) {
#line 37
    if ((int )c < 224) {
#line 39
      if (n >= 2UL) {
#line 41
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 43
          *puc = ((unsigned int )((int )c & 31) << 6) | (unsigned int )((int const   )*(s + 1) ^ 128);
#line 45
          return (2);
        }
      } else {
#line 52
        *puc = (ucs4_t )65533;
#line 53
        return (-2);
      }
    } else
#line 56
    if ((int )c < 240) {
#line 58
      if (n >= 2UL) {
#line 60
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 60
          if ((int )c >= 225) {
#line 60
            goto _L___0;
          } else
#line 60
          if ((int const   )*(s + 1) >= 160) {
            _L___0: /* CIL Label */ 
#line 60
            if ((int )c != 237) {
#line 60
              goto _L;
            } else
#line 60
            if ((int const   )*(s + 1) < 160) {
              _L: /* CIL Label */ 
#line 64
              if (n >= 3UL) {
#line 66
                if (((int const   )*(s + 2) ^ 128) < 64) {
#line 68
                  *puc = (((unsigned int )((int )c & 15) << 12) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 2) ^ 128);
#line 71
                  return (3);
                }
              } else {
#line 78
                *puc = (ucs4_t )65533;
#line 79
                return (-2);
              }
            }
          }
        }
      } else {
#line 87
        *puc = (ucs4_t )65533;
#line 88
        return (-2);
      }
    } else
#line 91
    if ((int )c < 248) {
#line 93
      if (n >= 2UL) {
#line 95
        if (((int const   )*(s + 1) ^ 128) < 64) {
#line 95
          if ((int )c >= 241) {
#line 95
            goto _L___2;
          } else
#line 95
          if ((int const   )*(s + 1) >= 144) {
            _L___2: /* CIL Label */ 
#line 95
            if ((int )c < 244) {
#line 95
              goto _L___1;
            } else
#line 95
            if ((int )c == 244) {
#line 95
              if ((int const   )*(s + 1) < 144) {
                _L___1: /* CIL Label */ 
#line 102
                if (n >= 3UL) {
#line 104
                  if (((int const   )*(s + 2) ^ 128) < 64) {
#line 106
                    if (n >= 4UL) {
#line 108
                      if (((int const   )*(s + 3) ^ 128) < 64) {
#line 110
                        *puc = ((((unsigned int )((int )c & 7) << 18) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 12)) | ((unsigned int )((int const   )*(s + 2) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 3) ^ 128);
#line 114
                        return (4);
                      }
                    } else {
#line 121
                      *puc = (ucs4_t )65533;
#line 122
                      return (-2);
                    }
                  }
                } else {
#line 130
                  *puc = (ucs4_t )65533;
#line 131
                  return (-2);
                }
              }
            }
          }
        }
      } else {
#line 139
        *puc = (ucs4_t )65533;
#line 140
        return (-2);
      }
    }
  }
#line 285
  *puc = (ucs4_t )65533;
#line 286
  return (-1);
}
}
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/trim.h"
char *trim2(char const   *s , int how ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 359 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 147 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswspace(wint_t __wc ) ;
#line 305 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbchar.h"
unsigned int const   is_basic_table[8] ;
#line 307 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbchar.h"
__inline static _Bool is_basic(char c ) 
{ 


  {
#line 310
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 115 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbiter.h"
__inline static void mbiter_multi_next(struct mbiter_multi *iter ) 
{ 
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 118
  if (iter->next_done) {
#line 119
    return;
  }
#line 120
  if (iter->in_shift) {
#line 121
    goto with_shift;
  }
  {
#line 123
  tmp___1 = is_basic((char )*(iter->cur.ptr));
  }
#line 123
  if (tmp___1) {
#line 128
    iter->cur.bytes = (size_t )1;
#line 129
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 130
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 134
    tmp = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 134
    if (! tmp) {
      {
#line 134
      __assert_fail("mbsinit (&iter->state)", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbiter.h",
                    134U, "mbiter_multi_next");
      }
    }
#line 135
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 137
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              (size_t )(iter->limit - iter->cur.ptr), & iter->state);
    }
#line 139
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 142
      iter->cur.bytes = (size_t )1;
#line 143
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 147
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 150
      iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
#line 151
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 157
      if (iter->cur.bytes == 0UL) {
#line 160
        iter->cur.bytes = (size_t )1;
#line 161
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 161
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbiter.h",
                        161U, "mbiter_multi_next");
          }
        }
#line 162
        if (! (iter->cur.wc == 0)) {
          {
#line 162
          __assert_fail("iter->cur.wc == 0", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbiter.h",
                        162U, "mbiter_multi_next");
          }
        }
      }
      {
#line 164
      iter->cur.wc_valid = (_Bool)1;
#line 168
      tmp___0 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 168
      if (tmp___0) {
#line 169
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 172
  iter->next_done = (_Bool)1;
#line 173
  return;
}
}
#line 40 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/trim.c"
char *trim2(char const   *s , int how ) 
{ 
  char *d ;
  mbi_iterator_t i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned int state ;
  char *r ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *p ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;

  {
  {
#line 45
  d = strdup(s);
  }
#line 47
  if (! d) {
    {
#line 48
    xalloc_die();
    }
  }
  {
#line 50
  tmp___12 = __ctype_get_mb_cur_max();
  }
#line 50
  if (tmp___12 > 1UL) {
#line 55
    if (how != 0) {
      {
#line 57
      i.cur.ptr = (char const   *)d;
#line 57
      tmp = strlen((char const   *)d);
#line 57
      i.limit = i.cur.ptr + tmp;
#line 57
      i.in_shift = (_Bool)0;
#line 57
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 57
      i.next_done = (_Bool)0;
      }
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;
#line 59
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 59
          mbiter_multi_next(& i);
          }
#line 59
          if (i.cur.wc_valid) {
            {
#line 59
            tmp___0 = iswspace((wint_t )i.cur.wc);
            }
#line 59
            if (! tmp___0) {
#line 59
              goto while_break;
            }
          } else {
#line 59
            goto while_break;
          }
        } else {
#line 59
          goto while_break;
        }
#line 59
        i.cur.ptr += i.cur.bytes;
#line 59
        i.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 62
      tmp___1 = strlen(i.cur.ptr);
#line 62
      memmove((void *)d, (void const   *)i.cur.ptr, tmp___1 + 1UL);
      }
    }
#line 66
    if (how != 1) {
      {
#line 68
      state = 0U;
#line 71
      i.cur.ptr = (char const   *)d;
#line 71
      tmp___2 = strlen((char const   *)d);
#line 71
      i.limit = i.cur.ptr + tmp___2;
#line 71
      i.in_shift = (_Bool)0;
#line 71
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 71
      i.next_done = (_Bool)0;
      }
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 73
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          {
#line 73
          mbiter_multi_next(& i);
          }
        } else {
#line 73
          goto while_break___0;
        }
#line 75
        if (state == 0U) {
#line 75
          if (i.cur.wc_valid) {
            {
#line 75
            tmp___3 = iswspace((wint_t )i.cur.wc);
            }
#line 75
            if (tmp___3) {
#line 76
              goto __Cont;
            }
          }
        }
#line 78
        if (state == 0U) {
#line 78
          if (i.cur.wc_valid) {
            {
#line 78
            tmp___4 = iswspace((wint_t )i.cur.wc);
            }
#line 78
            if (! tmp___4) {
#line 80
              state = 1U;
#line 81
              goto __Cont;
            }
          } else {
#line 80
            state = 1U;
#line 81
            goto __Cont;
          }
        }
#line 84
        if (state == 1U) {
#line 84
          if (i.cur.wc_valid) {
            {
#line 84
            tmp___5 = iswspace((wint_t )i.cur.wc);
            }
#line 84
            if (! tmp___5) {
#line 85
              goto __Cont;
            }
          } else {
#line 85
            goto __Cont;
          }
        }
#line 87
        if (state == 1U) {
#line 87
          if (i.cur.wc_valid) {
            {
#line 87
            tmp___7 = iswspace((wint_t )i.cur.wc);
            }
#line 87
            if (tmp___7) {
#line 89
              state = 2U;
#line 90
              r = (char *)i.cur.ptr;
            } else {
#line 87
              goto _L;
            }
          } else {
#line 87
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 92
        if (state == 2U) {
#line 92
          if (i.cur.wc_valid) {
            {
#line 92
            tmp___6 = iswspace((wint_t )i.cur.wc);
            }
#line 92
            if (! tmp___6) {
#line 98
              state = 1U;
            }
          } else {
#line 98
            state = 1U;
          }
        } else {
#line 98
          state = 1U;
        }
        __Cont: /* CIL Label */ 
#line 73
        i.cur.ptr += i.cur.bytes;
#line 73
        i.next_done = (_Bool)0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 102
      if (state == 2U) {
#line 103
        *r = (char )'\000';
      }
    }
  } else {
#line 111
    if (how != 0) {
#line 113
      p = d;
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 113
        if (*p) {
          {
#line 113
          tmp___8 = __ctype_b_loc();
          }
#line 113
          if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*p)) & 8192)) {
#line 113
            goto while_break___1;
          }
        } else {
#line 113
          goto while_break___1;
        }
#line 113
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 116
      tmp___9 = strlen((char const   *)p);
#line 116
      memmove((void *)d, (void const   *)p, tmp___9 + 1UL);
      }
    }
#line 120
    if (how != 1) {
      {
#line 122
      tmp___10 = strlen((char const   *)d);
#line 122
      p = (d + tmp___10) - 1;
      }
      {
#line 122
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 122
        if ((unsigned long )p >= (unsigned long )d) {
          {
#line 122
          tmp___11 = __ctype_b_loc();
          }
#line 122
          if (! ((int const   )*(*tmp___11 + (int )((unsigned char )*p)) & 8192)) {
#line 122
            goto while_break___2;
          }
        } else {
#line 122
          goto while_break___2;
        }
#line 124
        *p = (char )'\000';
#line 122
        p --;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 128
  return (d);
}
}
#line 48 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 263 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 623 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 181 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/tempname.c"
static char const   letters[63]  = 
#line 181 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/tempname.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 202 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/tempname.c"
static uint64_t value  ;
#line 197 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ 
  int len ;
  char *XXXXXX ;
  uint64_t random_time_bits ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  struct stat st ;
  unsigned int attempts ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  struct timeval tv ;
  __pid_t tmp___3 ;
  uint64_t v ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 205
  fd = -1;
#line 206
  tmp = __errno_location();
#line 206
  save_errno = *tmp;
#line 222
  attempts = 238328U;
#line 225
  tmp___0 = strlen((char const   *)tmpl);
#line 225
  len = (int )tmp___0;
  }
#line 226
  if (len < 6 + suffixlen) {
    {
#line 228
    tmp___1 = __errno_location();
#line 228
    *tmp___1 = 22;
    }
#line 229
    return (-1);
  } else {
    {
#line 226
    tmp___2 = memcmp((void const   *)(tmpl + ((len - 6) - suffixlen)), (void const   *)"XXXXXX",
                     (size_t )6);
    }
#line 226
    if (tmp___2) {
      {
#line 228
      tmp___1 = __errno_location();
#line 228
      *tmp___1 = 22;
      }
#line 229
      return (-1);
    }
  }
  {
#line 233
  XXXXXX = tmpl + ((len - 6) - suffixlen);
#line 241
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 242
  random_time_bits = ((uint64_t )tv.tv_usec << 16) ^ (unsigned long )tv.tv_sec;
#line 245
  tmp___3 = getpid();
#line 245
  value += random_time_bits ^ (unsigned long )tmp___3;
#line 247
  count = 0U;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (count < attempts)) {
#line 247
      goto while_break;
    }
#line 249
    v = value;
#line 252
    *(XXXXXX + 0) = (char )letters[v % 62UL];
#line 253
    v /= 62UL;
#line 254
    *(XXXXXX + 1) = (char )letters[v % 62UL];
#line 255
    v /= 62UL;
#line 256
    *(XXXXXX + 2) = (char )letters[v % 62UL];
#line 257
    v /= 62UL;
#line 258
    *(XXXXXX + 3) = (char )letters[v % 62UL];
#line 259
    v /= 62UL;
#line 260
    *(XXXXXX + 4) = (char )letters[v % 62UL];
#line 261
    v /= 62UL;
#line 262
    *(XXXXXX + 5) = (char )letters[v % 62UL];
    {
#line 266
    if (kind == 0) {
#line 266
      goto case_0;
    }
#line 272
    if (kind == 1) {
#line 272
      goto case_1;
    }
#line 276
    if (kind == 2) {
#line 276
      goto case_2;
    }
#line 294
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 267
    fd = open((char const   *)tmpl, (((flags & -4) | 2) | 64) | 128, 384);
    }
#line 270
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 273
    fd = mkdir((char const   *)tmpl, (__mode_t )448);
    }
#line 274
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 281
    tmp___6 = lstat((char const   */* __restrict  */)tmpl, (struct stat */* __restrict  */)(& st));
    }
#line 281
    if (tmp___6 < 0) {
      {
#line 283
      tmp___5 = __errno_location();
      }
#line 283
      if (*tmp___5 == 2) {
        {
#line 285
        tmp___4 = __errno_location();
#line 285
        *tmp___4 = save_errno;
        }
#line 286
        return (0);
      } else {
#line 290
        return (-1);
      }
    }
#line 292
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 295
    __assert_fail("! \"invalid KIND in __gen_tempname\"", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/tempname.c",
                  295U, "gen_tempname");
#line 296
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 299
    if (fd >= 0) {
      {
#line 301
      tmp___7 = __errno_location();
#line 301
      *tmp___7 = save_errno;
      }
#line 302
      return (fd);
    } else {
      {
#line 304
      tmp___8 = __errno_location();
      }
#line 304
      if (*tmp___8 != 17) {
#line 305
        return (-1);
      }
    }
    __Cont: /* CIL Label */ 
#line 247
    value += 7777UL;
#line 247
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 309
  tmp___9 = __errno_location();
#line 309
  *tmp___9 = 17;
  }
#line 310
  return (-1);
}
}
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen ) ;
#line 94 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ 
  char const   *end ;
  void *tmp ;

  {
  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
  }
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1L));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 40 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/dirname.h"
size_t base_len(char const   *name ) ;
#line 42
char *last_component(char const   *name ) ;
#line 44
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 38 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 43
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 52
extern int iconv_close(iconv_t __cd ) ;
#line 45 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 45 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/striconv.c"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) 
{ 
  size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_21 tmp ;
  char const   *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const   *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;

  {
  {
#line 58
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 63
  count = (size_t )0;
#line 68
  inptr = src;
#line 69
  insize = srclen;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (insize > 0UL)) {
#line 71
      goto while_break;
    }
    {
#line 73
    outptr = tmp.buf;
#line 74
    outsize = (size_t )4096;
#line 75
    tmp___0 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& insize),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outsize));
#line 75
    res = tmp___0;
    }
#line 79
    if (res == 0xffffffffffffffffUL) {
      {
#line 81
      tmp___2 = __errno_location();
      }
#line 81
      if (! (*tmp___2 == 7)) {
        {
#line 83
        tmp___1 = __errno_location();
        }
#line 83
        if (*tmp___1 == 22) {
#line 84
          goto while_break;
        } else {
#line 86
          return (-1);
        }
      }
    }
#line 99
    count += (size_t )(outptr - tmp.buf);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  outptr___0 = tmp.buf;
#line 107
  outsize___0 = (size_t )4096;
#line 108
  tmp___3 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___0), (size_t */* __restrict  */)(& outsize___0));
#line 108
  res___0 = tmp___3;
  }
#line 110
  if (res___0 == 0xffffffffffffffffUL) {
#line 111
    return (-1);
  }
#line 112
  count += (size_t )(outptr___0 - tmp.buf);
#line 115
  length = count;
#line 119
  if (length == 0UL) {
#line 121
    *lengthp = (size_t )0;
#line 122
    return (0);
  }
#line 124
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
#line 124
    if (*lengthp >= length) {
#line 125
      result = *resultp;
    } else {
#line 124
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 128
    tmp___4 = malloc(length);
#line 128
    result = (char *)tmp___4;
    }
#line 129
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 131
      tmp___5 = __errno_location();
#line 131
      *tmp___5 = 12;
      }
#line 132
      return (-1);
    }
  }
  {
#line 141
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 146
  inptr___0 = src;
#line 147
  insize___0 = srclen;
#line 148
  outptr___1 = result;
#line 149
  outsize___1 = length;
  }
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! (insize___0 > 0UL)) {
#line 151
      goto while_break___0;
    }
    {
#line 153
    tmp___6 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr___0)), (size_t */* __restrict  */)(& insize___0),
                    (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 153
    res___1 = tmp___6;
    }
#line 157
    if (res___1 == 0xffffffffffffffffUL) {
      {
#line 159
      tmp___7 = __errno_location();
      }
#line 159
      if (*tmp___7 == 22) {
#line 160
        goto while_break___0;
      } else {
#line 162
        goto fail;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 181
  tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                  (char **/* __restrict  */)(& outptr___1), (size_t */* __restrict  */)(& outsize___1));
#line 181
  res___2 = tmp___8;
  }
#line 183
  if (res___2 == 0xffffffffffffffffUL) {
#line 184
    goto fail;
  }
#line 187
  if (outsize___1 != 0UL) {
    {
#line 188
    abort();
    }
  }
#line 191
  *resultp = result;
#line 192
  *lengthp = length;
#line 194
  return (0);
  fail: 
#line 198
  if ((unsigned long )result != (unsigned long )*resultp) {
    {
#line 200
    tmp___9 = __errno_location();
#line 200
    saved_errno = *tmp___9;
#line 201
    free((void *)result);
#line 202
    tmp___10 = __errno_location();
#line 202
    *tmp___10 = saved_errno;
    }
  }
#line 204
  return (-1);
}
}
#line 209 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/striconv.c"
char *str_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  size_t result_size ;
  size_t length ;
  char const   *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___0 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
  {
#line 258
  inptr = src;
#line 259
  tmp = strlen(src);
#line 259
  inbytes_remaining = tmp;
#line 264
  result_size = inbytes_remaining;
#line 266
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
  }
#line 267
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
#line 268
    result_size *= 16UL;
  }
  {
#line 270
  result_size ++;
#line 272
  tmp___0 = malloc(result_size);
#line 272
  result = (char *)tmp___0;
  }
#line 273
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 275
    tmp___1 = __errno_location();
#line 275
    *tmp___1 = 12;
    }
#line 276
    return ((char *)((void *)0));
  }
  {
#line 284
  iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
        (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
#line 289
  outptr = result;
#line 290
  outbytes_remaining = result_size - 1UL;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    tmp___2 = iconv(cd, (char **/* __restrict  */)((char **)(& inptr)), (size_t */* __restrict  */)(& inbytes_remaining),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 296
    res = tmp___2;
    }
#line 300
    if (res == 0xffffffffffffffffUL) {
      {
#line 302
      tmp___7 = __errno_location();
      }
#line 302
      if (*tmp___7 == 22) {
#line 303
        goto while_break;
      } else {
        {
#line 304
        tmp___6 = __errno_location();
        }
#line 304
        if (*tmp___6 == 7) {
#line 306
          used = (size_t )(outptr - result);
#line 307
          newsize = result_size * 2UL;
#line 310
          if (! (newsize > result_size)) {
            {
#line 312
            tmp___3 = __errno_location();
#line 312
            *tmp___3 = 12;
            }
#line 313
            goto failed;
          }
          {
#line 315
          tmp___4 = realloc((void *)result, newsize);
#line 315
          newresult = (char *)tmp___4;
          }
#line 316
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
            {
#line 318
            tmp___5 = __errno_location();
#line 318
            *tmp___5 = 12;
            }
#line 319
            goto failed;
          }
#line 321
          result = newresult;
#line 322
          result_size = newsize;
#line 323
          outptr = result + used;
#line 324
          outbytes_remaining = (result_size - 1UL) - used;
        } else {
#line 327
          goto failed;
        }
      }
    } else {
#line 330
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 339
    tmp___8 = iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
                    (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outbytes_remaining));
#line 339
    res___0 = tmp___8;
    }
#line 341
    if (res___0 == 0xffffffffffffffffUL) {
      {
#line 343
      tmp___12 = __errno_location();
      }
#line 343
      if (*tmp___12 == 7) {
#line 345
        used___0 = (size_t )(outptr - result);
#line 346
        newsize___0 = result_size * 2UL;
#line 349
        if (! (newsize___0 > result_size)) {
          {
#line 351
          tmp___9 = __errno_location();
#line 351
          *tmp___9 = 12;
          }
#line 352
          goto failed;
        }
        {
#line 354
        tmp___10 = realloc((void *)result, newsize___0);
#line 354
        newresult___0 = (char *)tmp___10;
        }
#line 355
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
          {
#line 357
          tmp___11 = __errno_location();
#line 357
          *tmp___11 = 12;
          }
#line 358
          goto failed;
        }
#line 360
        result = newresult___0;
#line 361
        result_size = newsize___0;
#line 362
        outptr = result + used___0;
#line 363
        outbytes_remaining = (result_size - 1UL) - used___0;
      } else {
#line 366
        goto failed;
      }
    } else {
#line 369
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 374
  tmp___13 = outptr;
#line 374
  outptr ++;
#line 374
  *tmp___13 = (char )'\000';
#line 376
  length = (size_t )(outptr - result);
#line 380
  if (length < result_size) {
    {
#line 382
    tmp___14 = realloc((void *)result, length);
#line 382
    smaller_result = (char *)tmp___14;
    }
#line 384
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
#line 385
      result = smaller_result;
    }
  }
#line 388
  return (result);
  failed: 
  {
#line 392
  tmp___15 = __errno_location();
#line 392
  saved_errno = *tmp___15;
#line 393
  free((void *)result);
#line 394
  tmp___16 = __errno_location();
#line 394
  *tmp___16 = saved_errno;
  }
#line 395
  return ((char *)((void *)0));
}
}
#line 403 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/striconv.c"
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int saved_errno___0 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 406
  if ((int const   )*src == 0) {
#line 406
    goto _L;
  } else {
    {
#line 406
    tmp___6 = c_strcasecmp(from_codeset, to_codeset);
    }
#line 406
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
      {
#line 408
      tmp = strdup(src);
#line 408
      result = tmp;
      }
#line 410
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        {
#line 411
        tmp___0 = __errno_location();
#line 411
        *tmp___0 = 12;
        }
      }
#line 412
      return (result);
    } else {
      {
#line 430
      cd = iconv_open(to_codeset, from_codeset);
      }
#line 431
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 432
        return ((char *)((void *)0));
      }
      {
#line 434
      result___0 = str_cd_iconv(src, cd);
      }
#line 436
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
        {
#line 439
        tmp___1 = __errno_location();
#line 439
        saved_errno = *tmp___1;
#line 440
        iconv_close(cd);
#line 441
        tmp___2 = __errno_location();
#line 441
        *tmp___2 = saved_errno;
        }
      } else {
        {
#line 445
        tmp___5 = iconv_close(cd);
        }
#line 445
        if (tmp___5 < 0) {
          {
#line 449
          tmp___3 = __errno_location();
#line 449
          saved_errno___0 = *tmp___3;
#line 450
          free((void *)result___0);
#line 451
          tmp___4 = __errno_location();
#line 451
          *tmp___4 = saved_errno___0;
          }
#line 452
          return ((char *)((void *)0));
        }
      }
#line 455
      return (result___0);
    }
  }
}
}
#line 193 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 199
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 29 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strftime.h"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 319 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    tmp___0 = len;
#line 323
    len --;
#line 323
    if (! (tmp___0 > 0UL)) {
#line 323
      goto while_break;
    }
    {
#line 324
    tmp = tolower((int )((unsigned char )*(src + len)));
#line 324
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return (dest);
}
}
#line 328 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    tmp___0 = len;
#line 332
    len --;
#line 332
    if (! (tmp___0 > 0UL)) {
#line 332
      goto while_break;
    }
    {
#line 333
    tmp = toupper((int )((unsigned char )*(src + len)));
#line 333
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  return (dest);
}
}
#line 375 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ 
  int big_enough_multiple_of_7 ;

  {
#line 381
  big_enough_multiple_of_7 = 378;
#line 382
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 423 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strftime.c"
static size_t strftime_case_(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                             struct tm  const  *tp , int ut , int ns ) 
{ 
  int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  struct tm copy ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___0[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  char const   *tmp___1 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___2 ;
  size_t _incr___0 ;
  size_t tmp___3 ;
  size_t _delta___0 ;
  size_t len ;
  size_t tmp___4 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___5 ;
  size_t _incr___1 ;
  size_t tmp___6 ;
  size_t _delta___1 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___11 ;
  size_t _incr___2 ;
  size_t tmp___12 ;
  size_t _delta___2 ;
  int century ;
  int tmp___13 ;
  int tmp___14 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___15 ;
  size_t _incr___3 ;
  size_t tmp___16 ;
  size_t _delta___3 ;
  int padding ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___17 ;
  size_t _incr___4 ;
  size_t tmp___18 ;
  size_t _delta___4 ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___19 ;
  size_t _incr___5 ;
  size_t tmp___20 ;
  size_t _delta___5 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___21 ;
  size_t _incr___6 ;
  size_t tmp___22 ;
  size_t _delta___6 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___23 ;
  size_t _incr___7 ;
  size_t tmp___24 ;
  size_t _delta___7 ;
  int j ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___25 ;
  size_t _incr___8 ;
  size_t tmp___26 ;
  size_t _delta___8 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___27 ;
  size_t _n___9 ;
  size_t _w___9 ;
  int tmp___28 ;
  size_t _incr___9 ;
  size_t tmp___29 ;
  size_t _delta___9 ;
  int year ;
  int tmp___30 ;
  int year_adjust ;
  int days ;
  int tmp___31 ;
  int tmp___32 ;
  int d___0 ;
  int tmp___33 ;
  int tmp___34 ;
  int yy ;
  int tmp___35 ;
  int yy___0 ;
  size_t _n___10 ;
  size_t tmp___36 ;
  size_t _w___10 ;
  int tmp___37 ;
  size_t _incr___10 ;
  size_t tmp___38 ;
  size_t _delta___10 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  size_t _n___11 ;
  size_t _w___11 ;
  int tmp___39 ;
  size_t _incr___11 ;
  size_t tmp___40 ;
  size_t _delta___11 ;
  void *__cil_tmp148 ;
  void *__cil_tmp149 ;
  void *__cil_tmp150 ;
  void *__cil_tmp151 ;
  void *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;

  {
#line 436
  hour12 = (int )tp->tm_hour;
#line 461
  i = (size_t )0;
#line 462
  p = s;
#line 473
  copy = *tp;
#line 474
  tp = (struct tm  const  *)(& copy);
#line 477
  zone = (char const   *)((void *)0);
#line 485
  zone = (char const   *)tp->tm_zone;
#line 503
  if (hour12 > 12) {
#line 504
    hour12 -= 12;
  } else
#line 506
  if (hour12 == 0) {
#line 507
    hour12 = 12;
  }
#line 509
  f = format;
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! ((int const   )*f != 0)) {
#line 509
      goto while_break;
    }
#line 511
    pad = 0;
#line 513
    digits = 0;
#line 527
    width = -1;
#line 528
    to_lowcase = (_Bool)0;
#line 529
    to_uppcase = upcase;
#line 531
    change_case = (_Bool)0;
#line 614
    if ((int const   )*f != 37) {
      {
#line 616
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 616
        _n = (size_t )1;
#line 616
        if (width < 0) {
#line 616
          tmp = 0;
        } else {
#line 616
          tmp = width;
        }
#line 616
        _w = (size_t )tmp;
#line 616
        if (_n < _w) {
#line 616
          tmp___0 = _w;
        } else {
#line 616
          tmp___0 = _n;
        }
#line 616
        _incr = tmp___0;
#line 616
        if (_incr >= maxsize - i) {
#line 616
          return ((size_t )0);
        }
#line 616
        if (p) {
#line 616
          if (digits == 0) {
#line 616
            if (_n < _w) {
#line 616
              _delta = (size_t )width - _n;
#line 616
              if (pad == 48) {
                {
#line 616
                memset((void *)p, '0', _delta);
#line 616
                p += _delta;
                }
              } else {
                {
#line 616
                memset((void *)p, ' ', _delta);
#line 616
                p += _delta;
                }
              }
            }
          }
#line 616
          *p = (char )*f;
#line 616
          p += _n;
        }
#line 616
        i += _incr;
#line 616
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 617
      goto __Cont;
    }
    {
#line 623
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 625
      f ++;
      {
#line 630
      if ((int const   )*f == 48) {
#line 630
        goto case_48;
      }
#line 630
      if ((int const   )*f == 45) {
#line 630
        goto case_48;
      }
#line 630
      if ((int const   )*f == 95) {
#line 630
        goto case_48;
      }
#line 635
      if ((int const   )*f == 94) {
#line 635
        goto case_94;
      }
#line 638
      if ((int const   )*f == 35) {
#line 638
        goto case_35;
      }
#line 642
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 631
      pad = (int )*f;
#line 632
      goto while_continue___1;
      case_94: /* CIL Label */ 
#line 636
      to_uppcase = (_Bool)1;
#line 637
      goto while_continue___1;
      case_35: /* CIL Label */ 
#line 639
      change_case = (_Bool)1;
#line 640
      goto while_continue___1;
      switch_default: /* CIL Label */ 
#line 643
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 645
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 649
    if ((unsigned int )*f - 48U <= 9U) {
#line 651
      width = 0;
      {
#line 652
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 654
        if (width > 214748364) {
#line 657
          width = 2147483647;
        } else
#line 654
        if (width == 214748364) {
#line 654
          if ((int const   )*f - 48 > 7) {
#line 657
            width = 2147483647;
          } else {
#line 660
            width *= 10;
#line 661
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 660
          width *= 10;
#line 661
          width += (int )((int const   )*f - 48);
        }
#line 663
        f ++;
#line 652
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 652
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 672
    if ((int const   )*f == 79) {
#line 672
      goto case_79;
    }
#line 672
    if ((int const   )*f == 69) {
#line 672
      goto case_79;
    }
#line 676
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 673
    tmp___1 = f;
#line 673
    f ++;
#line 673
    modifier = (int )*tmp___1;
#line 674
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 677
    modifier = 0;
#line 678
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 682
    format_char = (int )*f;
    {
#line 705
    if (format_char == 37) {
#line 705
      goto case_37;
    }
#line 711
    if (format_char == 97) {
#line 711
      goto case_97;
    }
#line 726
    if (format_char == 65) {
#line 726
      goto case_65;
    }
#line 742
    if (format_char == 104) {
#line 742
      goto case_104;
    }
#line 742
    if (format_char == 98) {
#line 742
      goto case_104;
    }
#line 757
    if (format_char == 66) {
#line 757
      goto case_66;
    }
#line 772
    if (format_char == 99) {
#line 772
      goto case_99;
    }
#line 831
    if (format_char == 67) {
#line 831
      goto case_67;
    }
#line 860
    if (format_char == 120) {
#line 860
      goto case_120;
    }
#line 873
    if (format_char == 68) {
#line 873
      goto case_68;
    }
#line 879
    if (format_char == 100) {
#line 879
      goto case_100;
    }
#line 885
    if (format_char == 101) {
#line 885
      goto case_101;
    }
#line 1011
    if (format_char == 70) {
#line 1011
      goto case_70;
    }
#line 1017
    if (format_char == 72) {
#line 1017
      goto case_72;
    }
#line 1023
    if (format_char == 73) {
#line 1023
      goto case_73;
    }
#line 1029
    if (format_char == 107) {
#line 1029
      goto case_107;
    }
#line 1035
    if (format_char == 108) {
#line 1035
      goto case_108;
    }
#line 1041
    if (format_char == 106) {
#line 1041
      goto case_106;
    }
#line 1047
    if (format_char == 77) {
#line 1047
      goto case_77;
    }
#line 1053
    if (format_char == 109) {
#line 1053
      goto case_109;
    }
#line 1060
    if (format_char == 78) {
#line 1060
      goto case_78;
    }
#line 1078
    if (format_char == 110) {
#line 1078
      goto case_110;
    }
#line 1082
    if (format_char == 80) {
#line 1082
      goto case_80;
    }
#line 1089
    if (format_char == 112) {
#line 1089
      goto case_112;
    }
#line 1102
    if (format_char == 82) {
#line 1102
      goto case_82;
    }
#line 1106
    if (format_char == 114) {
#line 1106
      goto case_114;
    }
#line 1117
    if (format_char == 83) {
#line 1117
      goto case_83;
    }
#line 1123
    if (format_char == 115) {
#line 1123
      goto case_115;
    }
#line 1150
    if (format_char == 88) {
#line 1150
      goto case_88;
    }
#line 1163
    if (format_char == 84) {
#line 1163
      goto case_84;
    }
#line 1167
    if (format_char == 116) {
#line 1167
      goto case_116;
    }
#line 1171
    if (format_char == 117) {
#line 1171
      goto case_117;
    }
#line 1174
    if (format_char == 85) {
#line 1174
      goto case_85;
    }
#line 1182
    if (format_char == 71) {
#line 1182
      goto case_71;
    }
#line 1182
    if (format_char == 103) {
#line 1182
      goto case_71;
    }
#line 1182
    if (format_char == 86) {
#line 1182
      goto case_71;
    }
#line 1238
    if (format_char == 87) {
#line 1238
      goto case_87;
    }
#line 1244
    if (format_char == 119) {
#line 1244
      goto case_119;
    }
#line 1250
    if (format_char == 89) {
#line 1250
      goto case_89;
    }
#line 1274
    if (format_char == 121) {
#line 1274
      goto case_121;
    }
#line 1297
    if (format_char == 90) {
#line 1297
      goto case_90;
    }
#line 1326
    if (format_char == 58) {
#line 1326
      goto case_58;
    }
#line 1336
    if (format_char == 122) {
#line 1336
      goto case_122;
    }
#line 1414
    if (format_char == 0) {
#line 1414
      goto case_0___0;
    }
#line 1417
    goto bad_format;
    case_37: /* CIL Label */ 
#line 706
    if (modifier != 0) {
#line 707
      goto bad_format;
    }
    {
#line 708
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 708
      _n___0 = (size_t )1;
#line 708
      if (width < 0) {
#line 708
        tmp___2 = 0;
      } else {
#line 708
        tmp___2 = width;
      }
#line 708
      _w___0 = (size_t )tmp___2;
#line 708
      if (_n___0 < _w___0) {
#line 708
        tmp___3 = _w___0;
      } else {
#line 708
        tmp___3 = _n___0;
      }
#line 708
      _incr___0 = tmp___3;
#line 708
      if (_incr___0 >= maxsize - i) {
#line 708
        return ((size_t )0);
      }
#line 708
      if (p) {
#line 708
        if (digits == 0) {
#line 708
          if (_n___0 < _w___0) {
#line 708
            _delta___0 = (size_t )width - _n___0;
#line 708
            if (pad == 48) {
              {
#line 708
              memset((void *)p, '0', _delta___0);
#line 708
              p += _delta___0;
              }
            } else {
              {
#line 708
              memset((void *)p, ' ', _delta___0);
#line 708
              p += _delta___0;
              }
            }
          }
        }
#line 708
        *p = (char )*f;
#line 708
        p += _n___0;
      }
#line 708
      i += _incr___0;
#line 708
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 709
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 712
    if (modifier != 0) {
#line 713
      goto bad_format;
    }
#line 714
    if (change_case) {
#line 716
      to_uppcase = (_Bool)1;
#line 717
      to_lowcase = (_Bool)0;
    }
#line 723
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 727
    if (modifier != 0) {
#line 728
      goto bad_format;
    }
#line 729
    if (change_case) {
#line 731
      to_uppcase = (_Bool)1;
#line 732
      to_lowcase = (_Bool)0;
    }
#line 738
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 743
    if (change_case) {
#line 745
      to_uppcase = (_Bool)1;
#line 746
      to_lowcase = (_Bool)0;
    }
#line 748
    if (modifier != 0) {
#line 749
      goto bad_format;
    }
#line 754
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 758
    if (modifier != 0) {
#line 759
      goto bad_format;
    }
#line 760
    if (change_case) {
#line 762
      to_uppcase = (_Bool)1;
#line 763
      to_lowcase = (_Bool)0;
    }
#line 769
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 773
    if (modifier == 79) {
#line 774
      goto bad_format;
    }
#line 783
    goto underlying_strftime;
    subformat: 
    {
#line 788
    tmp___4 = strftime_case_(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                             tp, ut, ns);
#line 788
    len = tmp___4;
    }
    {
#line 792
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 792
      _n___1 = len;
#line 792
      if (width < 0) {
#line 792
        tmp___5 = 0;
      } else {
#line 792
        tmp___5 = width;
      }
#line 792
      _w___1 = (size_t )tmp___5;
#line 792
      if (_n___1 < _w___1) {
#line 792
        tmp___6 = _w___1;
      } else {
#line 792
        tmp___6 = _n___1;
      }
#line 792
      _incr___1 = tmp___6;
#line 792
      if (_incr___1 >= maxsize - i) {
#line 792
        return ((size_t )0);
      }
#line 792
      if (p) {
#line 792
        if (digits == 0) {
#line 792
          if (_n___1 < _w___1) {
#line 792
            _delta___1 = (size_t )width - _n___1;
#line 792
            if (pad == 48) {
              {
#line 792
              memset((void *)p, '0', _delta___1);
#line 792
              p += _delta___1;
              }
            } else {
              {
#line 792
              memset((void *)p, ' ', _delta___1);
#line 792
              p += _delta___1;
              }
            }
          }
        }
        {
#line 792
        strftime_case_(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
#line 792
        p += _n___1;
        }
      }
#line 792
      i += _incr___1;
#line 792
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 797
    goto switch_break___1;
    underlying_strftime: 
#line 805
    u = ufmt;
#line 818
    tmp___7 = u;
#line 818
    u ++;
#line 818
    *tmp___7 = (char )' ';
#line 819
    tmp___8 = u;
#line 819
    u ++;
#line 819
    *tmp___8 = (char )'%';
#line 820
    if (modifier != 0) {
#line 821
      tmp___9 = u;
#line 821
      u ++;
#line 821
      *tmp___9 = (char )modifier;
    }
    {
#line 822
    tmp___10 = u;
#line 822
    u ++;
#line 822
    *tmp___10 = (char )format_char;
#line 823
    *u = (char )'\000';
#line 824
    len___0 = strftime((char */* __restrict  */)(ubuf), sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 825
    if (len___0 != 0UL) {
      {
#line 826
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 826
        _n___2 = len___0 - 1UL;
#line 826
        if (width < 0) {
#line 826
          tmp___11 = 0;
        } else {
#line 826
          tmp___11 = width;
        }
#line 826
        _w___2 = (size_t )tmp___11;
#line 826
        if (_n___2 < _w___2) {
#line 826
          tmp___12 = _w___2;
        } else {
#line 826
          tmp___12 = _n___2;
        }
#line 826
        _incr___2 = tmp___12;
#line 826
        if (_incr___2 >= maxsize - i) {
#line 826
          return ((size_t )0);
        }
#line 826
        if (p) {
#line 826
          if (digits == 0) {
#line 826
            if (_n___2 < _w___2) {
#line 826
              _delta___2 = (size_t )width - _n___2;
#line 826
              if (pad == 48) {
                {
#line 826
                memset((void *)p, '0', _delta___2);
#line 826
                p += _delta___2;
                }
              } else {
                {
#line 826
                memset((void *)p, ' ', _delta___2);
#line 826
                p += _delta___2;
                }
              }
            }
          }
#line 826
          if (to_lowcase) {
            {
#line 826
            memcpy_lowcase(p, (char const   *)(ubuf + 1), _n___2);
            }
          } else
#line 826
          if (to_uppcase) {
            {
#line 826
            memcpy_uppcase(p, (char const   *)(ubuf + 1), _n___2);
            }
          } else {
            {
#line 826
            memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(ubuf + 1)),
                   _n___2);
            }
          }
#line 826
          p += _n___2;
        }
#line 826
        i += _incr___2;
#line 826
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 828
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 832
    if (modifier == 79) {
#line 833
      goto bad_format;
    }
#line 834
    if (modifier == 69) {
#line 850
      goto underlying_strftime;
    }
#line 855
    century = (int )(tp->tm_year / 100 + 19);
#line 856
    if (tp->tm_year % 100 < 0) {
#line 856
      if (0 < century) {
#line 856
        tmp___13 = 1;
      } else {
#line 856
        tmp___13 = 0;
      }
    } else {
#line 856
      tmp___13 = 0;
    }
#line 856
    century -= tmp___13;
#line 857
    digits = 2;
#line 857
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 857
    u_number_value = (unsigned int )century;
#line 857
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 861
    if (modifier == 79) {
#line 862
      goto bad_format;
    }
#line 871
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 874
    if (modifier != 0) {
#line 875
      goto bad_format;
    }
#line 876
    subfmt = "%m/%d/%y";
#line 877
    goto subformat;
    case_100: /* CIL Label */ 
#line 880
    if (modifier == 69) {
#line 881
      goto bad_format;
    }
#line 883
    digits = 2;
#line 883
    number_value = (int )tp->tm_mday;
#line 883
    goto do_number;
    case_101: /* CIL Label */ 
#line 886
    if (modifier == 69) {
#line 887
      goto bad_format;
    }
#line 889
    digits = 2;
#line 889
    number_value = (int )tp->tm_mday;
#line 889
    goto do_number_spacepad;
    do_tz_offset: 
#line 895
    always_output_a_sign = (_Bool)1;
#line 896
    goto do_number_body;
    do_number_spacepad: 
#line 900
    if (pad != 48) {
#line 900
      if (pad != 45) {
#line 901
        pad = '_';
      }
    }
    do_number: 
#line 905
    negative_number = (_Bool )(number_value < 0);
#line 906
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 909
    always_output_a_sign = (_Bool)0;
#line 910
    tz_colon_mask = 0;
    do_number_body: 
#line 918
    if (modifier == 79) {
#line 918
      if (! negative_number) {
#line 936
        goto underlying_strftime;
      }
    }
#line 940
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 942
    if (negative_number) {
#line 943
      u_number_value = - u_number_value;
    }
    {
#line 945
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 947
      if (tz_colon_mask & 1) {
#line 948
        bufp --;
#line 948
        *bufp = (char )':';
      }
#line 949
      tz_colon_mask >>= 1;
#line 950
      bufp --;
#line 950
      *bufp = (char )(u_number_value % 10U + 48U);
#line 951
      u_number_value /= 10U;
#line 945
      if (! (u_number_value != 0U)) {
#line 945
        if (! (tz_colon_mask != 0)) {
#line 945
          goto while_break___6;
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 956
    if (digits < width) {
#line 957
      digits = width;
    }
#line 959
    if (negative_number) {
#line 959
      sign_char = (char )'-';
    } else {
#line 959
      if (always_output_a_sign) {
#line 959
        tmp___14 = '+';
      } else {
#line 959
        tmp___14 = 0;
      }
#line 959
      sign_char = (char )tmp___14;
    }
#line 963
    if (pad == 45) {
#line 965
      if (sign_char) {
        {
#line 966
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 966
          _n___3 = (size_t )1;
#line 966
          if (width < 0) {
#line 966
            tmp___15 = 0;
          } else {
#line 966
            tmp___15 = width;
          }
#line 966
          _w___3 = (size_t )tmp___15;
#line 966
          if (_n___3 < _w___3) {
#line 966
            tmp___16 = _w___3;
          } else {
#line 966
            tmp___16 = _n___3;
          }
#line 966
          _incr___3 = tmp___16;
#line 966
          if (_incr___3 >= maxsize - i) {
#line 966
            return ((size_t )0);
          }
#line 966
          if (p) {
#line 966
            if (digits == 0) {
#line 966
              if (_n___3 < _w___3) {
#line 966
                _delta___3 = (size_t )width - _n___3;
#line 966
                if (pad == 48) {
                  {
#line 966
                  memset((void *)p, '0', _delta___3);
#line 966
                  p += _delta___3;
                  }
                } else {
                  {
#line 966
                  memset((void *)p, ' ', _delta___3);
#line 966
                  p += _delta___3;
                  }
                }
              }
            }
#line 966
            *p = sign_char;
#line 966
            p += _n___3;
          }
#line 966
          i += _incr___3;
#line 966
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    } else {
#line 970
      padding = (int )(((long )digits - ((buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp)) - (long )(! (! sign_char)));
#line 973
      if (padding > 0) {
#line 975
        if (pad == 95) {
#line 977
          if ((size_t )padding >= maxsize - i) {
#line 978
            return ((size_t )0);
          }
#line 980
          if (p) {
            {
#line 981
            memset((void *)p, ' ', (size_t )padding);
#line 981
            p += padding;
            }
          }
#line 982
          i += (size_t )padding;
#line 983
          if (width > padding) {
#line 983
            width -= padding;
          } else {
#line 983
            width = 0;
          }
#line 984
          if (sign_char) {
            {
#line 985
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 985
              _n___4 = (size_t )1;
#line 985
              if (width < 0) {
#line 985
                tmp___17 = 0;
              } else {
#line 985
                tmp___17 = width;
              }
#line 985
              _w___4 = (size_t )tmp___17;
#line 985
              if (_n___4 < _w___4) {
#line 985
                tmp___18 = _w___4;
              } else {
#line 985
                tmp___18 = _n___4;
              }
#line 985
              _incr___4 = tmp___18;
#line 985
              if (_incr___4 >= maxsize - i) {
#line 985
                return ((size_t )0);
              }
#line 985
              if (p) {
#line 985
                if (digits == 0) {
#line 985
                  if (_n___4 < _w___4) {
#line 985
                    _delta___4 = (size_t )width - _n___4;
#line 985
                    if (pad == 48) {
                      {
#line 985
                      memset((void *)p, '0', _delta___4);
#line 985
                      p += _delta___4;
                      }
                    } else {
                      {
#line 985
                      memset((void *)p, ' ', _delta___4);
#line 985
                      p += _delta___4;
                      }
                    }
                  }
                }
#line 985
                *p = sign_char;
#line 985
                p += _n___4;
              }
#line 985
              i += _incr___4;
#line 985
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        } else {
#line 989
          if ((size_t )digits >= maxsize - i) {
#line 990
            return ((size_t )0);
          }
#line 992
          if (sign_char) {
            {
#line 993
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 993
              _n___5 = (size_t )1;
#line 993
              if (width < 0) {
#line 993
                tmp___19 = 0;
              } else {
#line 993
                tmp___19 = width;
              }
#line 993
              _w___5 = (size_t )tmp___19;
#line 993
              if (_n___5 < _w___5) {
#line 993
                tmp___20 = _w___5;
              } else {
#line 993
                tmp___20 = _n___5;
              }
#line 993
              _incr___5 = tmp___20;
#line 993
              if (_incr___5 >= maxsize - i) {
#line 993
                return ((size_t )0);
              }
#line 993
              if (p) {
#line 993
                if (digits == 0) {
#line 993
                  if (_n___5 < _w___5) {
#line 993
                    _delta___5 = (size_t )width - _n___5;
#line 993
                    if (pad == 48) {
                      {
#line 993
                      memset((void *)p, '0', _delta___5);
#line 993
                      p += _delta___5;
                      }
                    } else {
                      {
#line 993
                      memset((void *)p, ' ', _delta___5);
#line 993
                      p += _delta___5;
                      }
                    }
                  }
                }
#line 993
                *p = sign_char;
#line 993
                p += _n___5;
              }
#line 993
              i += _incr___5;
#line 993
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 995
          if (p) {
            {
#line 996
            memset((void *)p, '0', (size_t )padding);
#line 996
            p += padding;
            }
          }
#line 997
          i += (size_t )padding;
#line 998
          width = 0;
        }
      } else
#line 1003
      if (sign_char) {
        {
#line 1004
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1004
          _n___6 = (size_t )1;
#line 1004
          if (width < 0) {
#line 1004
            tmp___21 = 0;
          } else {
#line 1004
            tmp___21 = width;
          }
#line 1004
          _w___6 = (size_t )tmp___21;
#line 1004
          if (_n___6 < _w___6) {
#line 1004
            tmp___22 = _w___6;
          } else {
#line 1004
            tmp___22 = _n___6;
          }
#line 1004
          _incr___6 = tmp___22;
#line 1004
          if (_incr___6 >= maxsize - i) {
#line 1004
            return ((size_t )0);
          }
#line 1004
          if (p) {
#line 1004
            if (digits == 0) {
#line 1004
              if (_n___6 < _w___6) {
#line 1004
                _delta___6 = (size_t )width - _n___6;
#line 1004
                if (pad == 48) {
                  {
#line 1004
                  memset((void *)p, '0', _delta___6);
#line 1004
                  p += _delta___6;
                  }
                } else {
                  {
#line 1004
                  memset((void *)p, ' ', _delta___6);
#line 1004
                  p += _delta___6;
                  }
                }
              }
            }
#line 1004
            *p = sign_char;
#line 1004
            p += _n___6;
          }
#line 1004
          i += _incr___6;
#line 1004
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
    {
#line 1008
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1008
      _n___7 = (size_t )((buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp);
#line 1008
      if (width < 0) {
#line 1008
        tmp___23 = 0;
      } else {
#line 1008
        tmp___23 = width;
      }
#line 1008
      _w___7 = (size_t )tmp___23;
#line 1008
      if (_n___7 < _w___7) {
#line 1008
        tmp___24 = _w___7;
      } else {
#line 1008
        tmp___24 = _n___7;
      }
#line 1008
      _incr___7 = tmp___24;
#line 1008
      if (_incr___7 >= maxsize - i) {
#line 1008
        return ((size_t )0);
      }
#line 1008
      if (p) {
#line 1008
        if (digits == 0) {
#line 1008
          if (_n___7 < _w___7) {
#line 1008
            _delta___7 = (size_t )width - _n___7;
#line 1008
            if (pad == 48) {
              {
#line 1008
              memset((void *)p, '0', _delta___7);
#line 1008
              p += _delta___7;
              }
            } else {
              {
#line 1008
              memset((void *)p, ' ', _delta___7);
#line 1008
              p += _delta___7;
              }
            }
          }
        }
#line 1008
        if (to_lowcase) {
          {
#line 1008
          memcpy_lowcase(p, (char const   *)bufp, _n___7);
          }
        } else
#line 1008
        if (to_uppcase) {
          {
#line 1008
          memcpy_uppcase(p, (char const   *)bufp, _n___7);
          }
        } else {
          {
#line 1008
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)bufp),
                 _n___7);
          }
        }
#line 1008
        p += _n___7;
      }
#line 1008
      i += _incr___7;
#line 1008
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1009
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 1012
    if (modifier != 0) {
#line 1013
      goto bad_format;
    }
#line 1014
    subfmt = "%Y-%m-%d";
#line 1015
    goto subformat;
    case_72: /* CIL Label */ 
#line 1018
    if (modifier == 69) {
#line 1019
      goto bad_format;
    }
#line 1021
    digits = 2;
#line 1021
    number_value = (int )tp->tm_hour;
#line 1021
    goto do_number;
    case_73: /* CIL Label */ 
#line 1024
    if (modifier == 69) {
#line 1025
      goto bad_format;
    }
#line 1027
    digits = 2;
#line 1027
    number_value = hour12;
#line 1027
    goto do_number;
    case_107: /* CIL Label */ 
#line 1030
    if (modifier == 69) {
#line 1031
      goto bad_format;
    }
#line 1033
    digits = 2;
#line 1033
    number_value = (int )tp->tm_hour;
#line 1033
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1036
    if (modifier == 69) {
#line 1037
      goto bad_format;
    }
#line 1039
    digits = 2;
#line 1039
    number_value = hour12;
#line 1039
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1042
    if (modifier == 69) {
#line 1043
      goto bad_format;
    }
#line 1045
    digits = 3;
#line 1045
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1045
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1045
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1048
    if (modifier == 69) {
#line 1049
      goto bad_format;
    }
#line 1051
    digits = 2;
#line 1051
    number_value = (int )tp->tm_min;
#line 1051
    goto do_number;
    case_109: /* CIL Label */ 
#line 1054
    if (modifier == 69) {
#line 1055
      goto bad_format;
    }
#line 1057
    digits = 2;
#line 1057
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1057
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1057
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1061
    if (modifier == 69) {
#line 1062
      goto bad_format;
    }
#line 1064
    number_value = ns;
#line 1065
    if (width == -1) {
#line 1066
      width = 9;
    } else {
#line 1071
      j = width;
      {
#line 1071
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1071
        if (! (j < 9)) {
#line 1071
          goto while_break___12;
        }
#line 1072
        number_value /= 10;
#line 1071
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1075
    digits = width;
#line 1075
    number_value = number_value;
#line 1075
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1079
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1079
      _n___8 = (size_t )1;
#line 1079
      if (width < 0) {
#line 1079
        tmp___25 = 0;
      } else {
#line 1079
        tmp___25 = width;
      }
#line 1079
      _w___8 = (size_t )tmp___25;
#line 1079
      if (_n___8 < _w___8) {
#line 1079
        tmp___26 = _w___8;
      } else {
#line 1079
        tmp___26 = _n___8;
      }
#line 1079
      _incr___8 = tmp___26;
#line 1079
      if (_incr___8 >= maxsize - i) {
#line 1079
        return ((size_t )0);
      }
#line 1079
      if (p) {
#line 1079
        if (digits == 0) {
#line 1079
          if (_n___8 < _w___8) {
#line 1079
            _delta___8 = (size_t )width - _n___8;
#line 1079
            if (pad == 48) {
              {
#line 1079
              memset((void *)p, '0', _delta___8);
#line 1079
              p += _delta___8;
              }
            } else {
              {
#line 1079
              memset((void *)p, ' ', _delta___8);
#line 1079
              p += _delta___8;
              }
            }
          }
        }
#line 1079
        *p = (char )'\n';
#line 1079
        p += _n___8;
      }
#line 1079
      i += _incr___8;
#line 1079
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1080
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1083
    to_lowcase = (_Bool)1;
#line 1085
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1090
    if (change_case) {
#line 1092
      to_uppcase = (_Bool)0;
#line 1093
      to_lowcase = (_Bool)1;
    }
#line 1099
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1103
    subfmt = "%H:%M";
#line 1104
    goto subformat;
    case_114: /* CIL Label */ 
#line 1114
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1118
    if (modifier == 69) {
#line 1119
      goto bad_format;
    }
#line 1121
    digits = 2;
#line 1121
    number_value = (int )tp->tm_sec;
#line 1121
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1128
    ltm = (struct tm )*tp;
#line 1129
    t = mktime(& ltm);
#line 1134
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 1135
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1137
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1139
      d = (int )(t % 10L);
#line 1140
      t /= 10L;
#line 1141
      bufp --;
#line 1141
      if (negative_number) {
#line 1141
        tmp___27 = - d;
      } else {
#line 1141
        tmp___27 = d;
      }
#line 1141
      *bufp = (char )(tmp___27 + 48);
#line 1137
      if (! (t != 0L)) {
#line 1137
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1145
    digits = 1;
#line 1146
    always_output_a_sign = (_Bool)0;
#line 1147
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1151
    if (modifier == 79) {
#line 1152
      goto bad_format;
    }
#line 1161
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1164
    subfmt = "%H:%M:%S";
#line 1165
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1168
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1168
      _n___9 = (size_t )1;
#line 1168
      if (width < 0) {
#line 1168
        tmp___28 = 0;
      } else {
#line 1168
        tmp___28 = width;
      }
#line 1168
      _w___9 = (size_t )tmp___28;
#line 1168
      if (_n___9 < _w___9) {
#line 1168
        tmp___29 = _w___9;
      } else {
#line 1168
        tmp___29 = _n___9;
      }
#line 1168
      _incr___9 = tmp___29;
#line 1168
      if (_incr___9 >= maxsize - i) {
#line 1168
        return ((size_t )0);
      }
#line 1168
      if (p) {
#line 1168
        if (digits == 0) {
#line 1168
          if (_n___9 < _w___9) {
#line 1168
            _delta___9 = (size_t )width - _n___9;
#line 1168
            if (pad == 48) {
              {
#line 1168
              memset((void *)p, '0', _delta___9);
#line 1168
              p += _delta___9;
              }
            } else {
              {
#line 1168
              memset((void *)p, ' ', _delta___9);
#line 1168
              p += _delta___9;
              }
            }
          }
        }
#line 1168
        *p = (char )'\t';
#line 1168
        p += _n___9;
      }
#line 1168
      i += _incr___9;
#line 1168
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 1169
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1172
    digits = 1;
#line 1172
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1172
    goto do_number;
    case_85: /* CIL Label */ 
#line 1175
    if (modifier == 69) {
#line 1176
      goto bad_format;
    }
#line 1178
    digits = 2;
#line 1178
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1178
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1183
    if (modifier == 69) {
#line 1184
      goto bad_format;
    }
#line 1190
    if (tp->tm_year < 0) {
#line 1190
      tmp___30 = 300;
    } else {
#line 1190
      tmp___30 = -100;
    }
    {
#line 1190
    year = (int )(tp->tm_year + (int const   )tmp___30);
#line 1194
    year_adjust = 0;
#line 1195
    tmp___31 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1195
    days = tmp___31;
    }
#line 1197
    if (days < 0) {
#line 1200
      year_adjust = -1;
#line 1201
      if ((year - 1) % 4 == 0) {
#line 1201
        if ((year - 1) % 100 != 0) {
#line 1201
          tmp___32 = 1;
        } else
#line 1201
        if ((year - 1) % 400 == 0) {
#line 1201
          tmp___32 = 1;
        } else {
#line 1201
          tmp___32 = 0;
        }
      } else {
#line 1201
        tmp___32 = 0;
      }
      {
#line 1201
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___32)), (int )tp->tm_wday);
      }
    } else {
#line 1206
      if (year % 4 == 0) {
#line 1206
        if (year % 100 != 0) {
#line 1206
          tmp___33 = 1;
        } else
#line 1206
        if (year % 400 == 0) {
#line 1206
          tmp___33 = 1;
        } else {
#line 1206
          tmp___33 = 0;
        }
      } else {
#line 1206
        tmp___33 = 0;
      }
      {
#line 1206
      tmp___34 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___33)),
                               (int )tp->tm_wday);
#line 1206
      d___0 = tmp___34;
      }
#line 1208
      if (0 <= d___0) {
#line 1211
        year_adjust = 1;
#line 1212
        days = d___0;
      }
    }
    {
#line 1218
    if ((int const   )*f == 103) {
#line 1218
      goto case_103___0;
    }
#line 1228
    if ((int const   )*f == 71) {
#line 1228
      goto case_71___0;
    }
#line 1233
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1220
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1221
    digits = 2;
#line 1221
    if (0 <= yy) {
#line 1221
      number_value = yy;
    } else {
#line 1221
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1221
        tmp___35 = - yy;
      } else {
#line 1221
        tmp___35 = yy + 100;
      }
#line 1221
      number_value = tmp___35;
    }
#line 1221
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1229
    digits = 4;
#line 1229
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1229
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1229
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1234
    digits = 2;
#line 1234
    number_value = days / 7 + 1;
#line 1234
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1239
    if (modifier == 69) {
#line 1240
      goto bad_format;
    }
#line 1242
    digits = 2;
#line 1242
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1242
    goto do_number;
    case_119: /* CIL Label */ 
#line 1245
    if (modifier == 69) {
#line 1246
      goto bad_format;
    }
#line 1248
    digits = 1;
#line 1248
    number_value = (int )tp->tm_wday;
#line 1248
    goto do_number;
    case_89: /* CIL Label */ 
#line 1251
    if (modifier == 69) {
#line 1265
      goto underlying_strftime;
    }
#line 1268
    if (modifier == 79) {
#line 1269
      goto bad_format;
    } else {
#line 1271
      digits = 4;
    }
#line 1271
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1271
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1271
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1275
    if (modifier == 69) {
#line 1286
      goto underlying_strftime;
    }
#line 1291
    yy___0 = (int )(tp->tm_year % 100);
#line 1292
    if (yy___0 < 0) {
#line 1293
      if (tp->tm_year < -1900) {
#line 1293
        yy___0 = - yy___0;
      } else {
#line 1293
        yy___0 += 100;
      }
    }
#line 1294
    digits = 2;
#line 1294
    number_value = yy___0;
#line 1294
    goto do_number;
    case_90: /* CIL Label */ 
#line 1298
    if (change_case) {
#line 1300
      to_uppcase = (_Bool)0;
#line 1301
      to_lowcase = (_Bool)1;
    }
#line 1309
    if (! zone) {
#line 1310
      zone = "";
    }
    {
#line 1322
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 1322
      tmp___36 = strlen(zone);
#line 1322
      _n___10 = tmp___36;
      }
#line 1322
      if (width < 0) {
#line 1322
        tmp___37 = 0;
      } else {
#line 1322
        tmp___37 = width;
      }
#line 1322
      _w___10 = (size_t )tmp___37;
#line 1322
      if (_n___10 < _w___10) {
#line 1322
        tmp___38 = _w___10;
      } else {
#line 1322
        tmp___38 = _n___10;
      }
#line 1322
      _incr___10 = tmp___38;
#line 1322
      if (_incr___10 >= maxsize - i) {
#line 1322
        return ((size_t )0);
      }
#line 1322
      if (p) {
#line 1322
        if (digits == 0) {
#line 1322
          if (_n___10 < _w___10) {
#line 1322
            _delta___10 = (size_t )width - _n___10;
#line 1322
            if (pad == 48) {
              {
#line 1322
              memset((void *)p, '0', _delta___10);
#line 1322
              p += _delta___10;
              }
            } else {
              {
#line 1322
              memset((void *)p, ' ', _delta___10);
#line 1322
              p += _delta___10;
              }
            }
          }
        }
#line 1322
        if (to_lowcase) {
          {
#line 1322
          memcpy_lowcase(p, zone, _n___10);
          }
        } else
#line 1322
        if (to_uppcase) {
          {
#line 1322
          memcpy_uppcase(p, zone, _n___10);
          }
        } else {
          {
#line 1322
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)zone),
                 _n___10);
          }
        }
#line 1322
        p += _n___10;
      }
#line 1322
      i += _incr___10;
#line 1322
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1324
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1329
    colons = (size_t )1;
    {
#line 1329
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1329
      if (! ((int const   )*(f + colons) == 58)) {
#line 1329
        goto while_break___17;
      }
#line 1330
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1329
      colons ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1331
    if ((int const   )*(f + colons) != 122) {
#line 1332
      goto bad_format;
    }
#line 1333
    f += colons;
#line 1334
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1337
    colons = (size_t )0;
    do_z_conversion: 
#line 1340
    if (tp->tm_isdst < 0) {
#line 1341
      goto switch_break___1;
    }
#line 1349
    diff = (int )tp->tm_gmtoff;
#line 1386
    hour_diff = (diff / 60) / 60;
#line 1387
    min_diff = (diff / 60) % 60;
#line 1388
    sec_diff = diff % 60;
    {
#line 1392
    if (colons == 0UL) {
#line 1392
      goto case_0;
    }
#line 1395
    if (colons == 1UL) {
#line 1395
      goto tz_hh_mm;
    }
#line 1398
    if (colons == 2UL) {
#line 1398
      goto tz_hh_mm_ss;
    }
#line 1402
    if (colons == 3UL) {
#line 1402
      goto case_3;
    }
#line 1409
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1393
    digits = 5;
#line 1393
    negative_number = (_Bool )(diff < 0);
#line 1393
    tz_colon_mask = 0;
#line 1393
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1393
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1396
    digits = 6;
#line 1396
    negative_number = (_Bool )(diff < 0);
#line 1396
    tz_colon_mask = 4;
#line 1396
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1396
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1399
    digits = 9;
#line 1399
    negative_number = (_Bool )(diff < 0);
#line 1399
    tz_colon_mask = 20;
#line 1399
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1399
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1403
    if (sec_diff != 0) {
#line 1404
      goto tz_hh_mm_ss;
    }
#line 1405
    if (min_diff != 0) {
#line 1406
      goto tz_hh_mm;
    }
#line 1407
    digits = 3;
#line 1407
    negative_number = (_Bool )(diff < 0);
#line 1407
    tz_colon_mask = 0;
#line 1407
    u_number_value = (unsigned int )hour_diff;
#line 1407
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1410
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1415
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1424
    flen = 1;
    {
#line 1424
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1424
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1424
        goto while_break___18;
      }
#line 1425
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1424
      flen ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1426
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1426
      _n___11 = (size_t )flen;
#line 1426
      if (width < 0) {
#line 1426
        tmp___39 = 0;
      } else {
#line 1426
        tmp___39 = width;
      }
#line 1426
      _w___11 = (size_t )tmp___39;
#line 1426
      if (_n___11 < _w___11) {
#line 1426
        tmp___40 = _w___11;
      } else {
#line 1426
        tmp___40 = _n___11;
      }
#line 1426
      _incr___11 = tmp___40;
#line 1426
      if (_incr___11 >= maxsize - i) {
#line 1426
        return ((size_t )0);
      }
#line 1426
      if (p) {
#line 1426
        if (digits == 0) {
#line 1426
          if (_n___11 < _w___11) {
#line 1426
            _delta___11 = (size_t )width - _n___11;
#line 1426
            if (pad == 48) {
              {
#line 1426
              memset((void *)p, '0', _delta___11);
#line 1426
              p += _delta___11;
              }
            } else {
              {
#line 1426
              memset((void *)p, ' ', _delta___11);
#line 1426
              p += _delta___11;
              }
            }
          }
        }
#line 1426
        if (to_lowcase) {
          {
#line 1426
          memcpy_lowcase(p, f + (1 - flen), _n___11);
          }
        } else
#line 1426
        if (to_uppcase) {
          {
#line 1426
          memcpy_uppcase(p, f + (1 - flen), _n___11);
          }
        } else {
          {
#line 1426
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(f + (1 - flen))),
                 _n___11);
          }
        }
#line 1426
        p += _n___11;
      }
#line 1426
      i += _incr___11;
#line 1426
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1428
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 509
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1433
  if (p) {
#line 1433
    if (maxsize != 0UL) {
#line 1434
      *p = (char )'\000';
    }
  }
#line 1437
  return (i);
}
}
#line 1446 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1451
  tmp = strftime_case_((_Bool)0, s, maxsize, format, tp, ut, ns);
  }
#line 1451
  return (tmp);
}
}
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 1242 "./string.h"
char *rpl_strerror(int n ) ;
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 39 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strerror.c"
static char buf[256]  ;
#line 57 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strerror.c"
static char const   fmt[17]  = 
#line 57
  {      (char const   )'U',      (char const   )'n',      (char const   )'k',      (char const   )'n', 
        (char const   )'o',      (char const   )'w',      (char const   )'n',      (char const   )' ', 
        (char const   )'e',      (char const   )'r',      (char const   )'r',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'%',      (char const   )'d', 
        (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/strerror.c"
char *rpl_strerror(int n ) 
{ 
  size_t len ;
  char const   *msg ;
  char *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 44
  msg = (char const   *)((void *)0);
#line 45
  if (msg) {
#line 46
    return ((char *)msg);
  }
  {
#line 48
  tmp = strerror(n);
#line 48
  msg = (char const   *)tmp;
  }
#line 55
  if (! msg) {
    {
#line 59
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmt),
            n);
#line 60
    tmp___0 = __errno_location();
#line 60
    *tmp___0 = 22;
    }
#line 61
    return (buf);
  } else
#line 55
  if (! *msg) {
    {
#line 59
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmt),
            n);
#line 60
    tmp___0 = __errno_location();
#line 60
    *tmp___0 = 22;
    }
#line 61
    return (buf);
  }
  {
#line 65
  len = strlen(msg);
  }
#line 66
  if (sizeof(buf) <= len) {
    {
#line 67
    abort();
    }
  }
  {
#line 69
  tmp___1 = memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)msg,
                   len + 1UL);
  }
#line 69
  return ((char *)tmp___1);
}
}
#line 25 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/sh-quote.h"
size_t shell_quote_length(char const   *string ) ;
#line 29
char *shell_quote_copy(char *p , char const   *string ) ;
#line 32
char *shell_quote(char const   *string ) ;
#line 36
char *shell_quote_argv(char **argv ) ;
#line 245 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.h"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 252
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 293
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 300
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 106 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 108
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 108 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 111
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 111
    tmp = -1;
  } else {
#line 111
    tmp = -2;
  }
#line 111
  if ((size_t )tmp / s < n) {
    {
#line 112
    xalloc_die();
    }
  }
  {
#line 113
  tmp___0 = xmalloc(n * s);
  }
#line 113
  return (tmp___0);
}
}
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/sh-quote.c"
static struct quoting_options *sh_quoting_options  ;
#line 34 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/sh-quote.c"
static void init_sh_quoting_options(void) 
{ 


  {
  {
#line 37
  sh_quoting_options = clone_quoting_options((struct quoting_options *)((void *)0));
#line 38
  set_quoting_style(sh_quoting_options, (enum quoting_style )1);
  }
#line 39
  return;
}
}
#line 42 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/sh-quote.c"
size_t shell_quote_length(char const   *string ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 45
  if ((unsigned long )sh_quoting_options == (unsigned long )((void *)0)) {
    {
#line 46
    init_sh_quoting_options();
    }
  }
  {
#line 47
  tmp = strlen(string);
#line 47
  tmp___0 = quotearg_buffer((char *)((void *)0), (size_t )0, string, tmp, (struct quoting_options  const  *)sh_quoting_options);
  }
#line 47
  return (tmp___0);
}
}
#line 53 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/sh-quote.c"
char *shell_quote_copy(char *p , char const   *string ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 56
  if ((unsigned long )sh_quoting_options == (unsigned long )((void *)0)) {
    {
#line 57
    init_sh_quoting_options();
    }
  }
  {
#line 58
  tmp = strlen(string);
#line 58
  tmp___0 = quotearg_buffer(p, (size_t )-1, string, tmp, (struct quoting_options  const  *)sh_quoting_options);
  }
#line 58
  return (p + tmp___0);
}
}
#line 63 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/sh-quote.c"
char *shell_quote(char const   *string ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
#line 66
  if ((unsigned long )sh_quoting_options == (unsigned long )((void *)0)) {
    {
#line 67
    init_sh_quoting_options();
    }
  }
  {
#line 68
  tmp = strlen(string);
#line 68
  tmp___0 = quotearg_alloc(string, tmp, (struct quoting_options  const  *)sh_quoting_options);
  }
#line 68
  return (tmp___0);
}
}
#line 73 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/sh-quote.c"
char *shell_quote_argv(char **argv ) 
{ 
  char **argp ;
  size_t length ;
  char *command ;
  char *p ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp12 ;

  {
#line 76
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 83
    length = (size_t )0;
#line 84
    argp = argv;
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 86
      tmp = shell_quote_length((char const   *)*argp);
#line 86
      length += tmp + 1UL;
#line 87
      argp ++;
      }
#line 88
      if ((unsigned long )*argp == (unsigned long )((void *)0)) {
#line 89
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 92
    if (sizeof(char ) == 1UL) {
      {
#line 92
      tmp___0 = xmalloc(length);
#line 92
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 92
      tmp___1 = xnmalloc(length, sizeof(char ));
#line 92
      tmp___2 = tmp___1;
      }
    }
#line 92
    command = (char *)tmp___2;
#line 94
    p = command;
#line 95
    argp = argv;
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 97
      p = shell_quote_copy(p, (char const   *)*argp);
#line 98
      argp ++;
      }
#line 99
      if ((unsigned long )*argp == (unsigned long )((void *)0)) {
#line 100
        goto while_break___0;
      }
#line 101
      tmp___3 = p;
#line 101
      p ++;
#line 101
      *tmp___3 = (char )' ';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    *p = (char )'\000';
#line 105
    return (command);
  } else {
    {
#line 108
    tmp___4 = xstrdup("");
    }
#line 108
    return (tmp___4);
  }
}
}
#line 234 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 235
enum quoting_style  const  quoting_style_vals[8] ;
#line 248
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 261
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 267
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 278
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 309
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 319
char *quotearg_n(int n , char const   *arg ) ;
#line 322
char *quotearg(char const   *arg ) ;
#line 327
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 330
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 335
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 340
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 344
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 347
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 352
char *quotearg_char(char const   *arg , char ch ) ;
#line 355
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 358
char *quotearg_colon(char const   *arg ) ;
#line 361
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 367
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 372
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 377
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 382
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 387
void quotearg_free(void) ;
#line 106 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 221
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 223
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 223 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 226
  if (sizeof(char ) == 1UL) {
    {
#line 226
    tmp = xmalloc(n);
#line 226
    tmp___1 = tmp;
    }
  } else {
    {
#line 226
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 226
    tmp___1 = tmp___0;
    }
  }
#line 226
  return ((char *)tmp___1);
}
}
#line 137 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 65 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 65 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 79 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 79
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 92 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 97 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 100
  tmp = __errno_location();
#line 100
  e = *tmp;
  }
#line 101
  if (o) {
#line 101
    tmp___0 = o;
  } else {
#line 101
    tmp___0 = & default_quoting_options;
  }
  {
#line 101
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 101
  p = (struct quoting_options *)tmp___1;
#line 103
  tmp___2 = __errno_location();
#line 103
  *tmp___2 = e;
  }
#line 104
  return (p);
}
}
#line 108 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 111
  if (o) {
#line 111
    tmp = o;
  } else {
#line 111
    tmp = & default_quoting_options;
  }
#line 111
  return (tmp->style);
}
}
#line 116 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 119
  if (o) {
#line 119
    tmp = o;
  } else {
#line 119
    tmp = & default_quoting_options;
  }
#line 119
  tmp->style = s;
#line 120
  return;
}
}
#line 127 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 130
  uc = (unsigned char )c;
#line 131
  if (o) {
#line 131
    tmp = o;
  } else {
#line 131
    tmp = & default_quoting_options;
  }
#line 131
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 133
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 134
  r = (int )((*p >> shift) & 1U);
#line 135
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 136
  return (r);
}
}
#line 143 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 147
  if (! o) {
#line 148
    o = & default_quoting_options;
  }
#line 149
  r = o->flags;
#line 150
  o->flags = i;
#line 151
  return (r);
}
}
#line 154 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 158
  if (! o) {
#line 159
    o = & default_quoting_options;
  }
#line 160
  o->style = (enum quoting_style )8;
#line 161
  if (! left_quote) {
    {
#line 162
    abort();
    }
  } else
#line 161
  if (! right_quote) {
    {
#line 162
    abort();
    }
  }
#line 163
  o->left_quote = left_quote;
#line 164
  o->right_quote = right_quote;
#line 165
  return;
}
}
#line 168 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
#line 171
  o.style = (enum quoting_style )0;
#line 171
  o.flags = 0;
#line 171
  o.quote_these_too[0] = 0U;
#line 171
  o.quote_these_too[1] = 0U;
#line 171
  o.quote_these_too[2] = 0U;
#line 171
  o.quote_these_too[3] = 0U;
#line 171
  o.quote_these_too[4] = 0U;
#line 171
  o.quote_these_too[5] = 0U;
#line 171
  o.quote_these_too[6] = 0U;
#line 171
  o.quote_these_too[7] = 0U;
#line 171
  o.left_quote = (char const   *)0;
#line 171
  o.right_quote = (char const   *)0;
#line 172
  if ((unsigned int )style == 8U) {
    {
#line 173
    abort();
    }
  }
#line 174
  o.style = style;
#line 175
  return (o);
}
}
#line 180 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 183
  tmp = gettext(msgid);
#line 183
  translation = (char const   *)tmp;
  }
#line 184
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 184
    if ((unsigned int )s == 7U) {
#line 185
      translation = "\"";
    }
  }
#line 186
  return (translation);
}
}
#line 202 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 211
  len = (size_t )0;
#line 212
  quote_string = (char const   *)0;
#line 213
  quote_string_len = (size_t )0;
#line 214
  backslash_escapes = (_Bool)0;
#line 215
  tmp = __ctype_get_mb_cur_max();
#line 215
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 216
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 229
  if ((unsigned int )quoting_style == 4U) {
#line 229
    goto case_4;
  }
#line 233
  if ((unsigned int )quoting_style == 3U) {
#line 233
    goto case_3;
  }
#line 241
  if ((unsigned int )quoting_style == 5U) {
#line 241
    goto case_5;
  }
#line 248
  if ((unsigned int )quoting_style == 8U) {
#line 248
    goto case_8;
  }
#line 248
  if ((unsigned int )quoting_style == 7U) {
#line 248
    goto case_8;
  }
#line 248
  if ((unsigned int )quoting_style == 6U) {
#line 248
    goto case_8;
  }
#line 283
  if ((unsigned int )quoting_style == 1U) {
#line 283
    goto case_1;
  }
#line 287
  if ((unsigned int )quoting_style == 2U) {
#line 287
    goto case_2;
  }
#line 294
  if ((unsigned int )quoting_style == 0U) {
#line 294
    goto case_0;
  }
#line 298
  goto switch_default;
  case_4: /* CIL Label */ 
#line 230
  quoting_style = (enum quoting_style )3;
#line 231
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 234
  if (! elide_outer_quotes) {
    {
#line 235
    while (1) {
      while_continue: /* CIL Label */ ;
#line 235
      if (len < buffersize) {
#line 235
        *(buffer + len) = (char )'\"';
      }
#line 235
      len ++;
#line 235
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 236
  backslash_escapes = (_Bool)1;
#line 237
  quote_string = "\"";
#line 238
  quote_string_len = (size_t )1;
#line 239
  goto switch_break;
  case_5: /* CIL Label */ 
#line 242
  backslash_escapes = (_Bool)1;
#line 243
  elide_outer_quotes = (_Bool)0;
#line 244
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 250
  if ((unsigned int )quoting_style != 8U) {
    {
#line 271
    left_quote = gettext_quote("`", quoting_style);
#line 272
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 274
  if (! elide_outer_quotes) {
#line 275
    quote_string = left_quote;
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! *quote_string) {
#line 275
        goto while_break___0;
      }
      {
#line 276
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 276
        if (len < buffersize) {
#line 276
          *(buffer + len) = (char )*quote_string;
        }
#line 276
        len ++;
#line 276
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 275
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 277
  backslash_escapes = (_Bool)1;
#line 278
  quote_string = right_quote;
#line 279
  quote_string_len = strlen(quote_string);
  }
#line 281
  goto switch_break;
  case_1: /* CIL Label */ 
#line 284
  quoting_style = (enum quoting_style )2;
#line 285
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 288
  if (! elide_outer_quotes) {
    {
#line 289
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 289
      if (len < buffersize) {
#line 289
        *(buffer + len) = (char )'\'';
      }
#line 289
      len ++;
#line 289
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 290
  quote_string = "\'";
#line 291
  quote_string_len = (size_t )1;
#line 292
  goto switch_break;
  case_0: /* CIL Label */ 
#line 295
  elide_outer_quotes = (_Bool)0;
#line 296
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 299
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 302
  i = (size_t )0;
  {
#line 302
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 302
    if (argsize == 0xffffffffffffffffUL) {
#line 302
      tmp___6 = (int const   )*(arg + i) == 0;
    } else {
#line 302
      tmp___6 = i == argsize;
    }
#line 302
    if (tmp___6) {
#line 302
      goto while_break___3;
    }
#line 306
    is_right_quote = (_Bool)0;
#line 308
    if (backslash_escapes) {
#line 308
      if (quote_string_len) {
#line 308
        if (i + quote_string_len <= argsize) {
          {
#line 308
          tmp___0 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 308
          if (tmp___0 == 0) {
#line 313
            if (elide_outer_quotes) {
#line 314
              goto force_outer_quoting_style;
            }
#line 315
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 318
    c = (unsigned char )*(arg + i);
    {
#line 321
    if ((int )c == 0) {
#line 321
      goto case_0___0;
    }
#line 347
    if ((int )c == 63) {
#line 347
      goto case_63;
    }
#line 385
    if ((int )c == 7) {
#line 385
      goto case_7___0;
    }
#line 386
    if ((int )c == 8) {
#line 386
      goto case_8___0;
    }
#line 387
    if ((int )c == 12) {
#line 387
      goto case_12;
    }
#line 388
    if ((int )c == 10) {
#line 388
      goto case_10;
    }
#line 389
    if ((int )c == 13) {
#line 389
      goto case_13;
    }
#line 390
    if ((int )c == 9) {
#line 390
      goto case_9;
    }
#line 391
    if ((int )c == 11) {
#line 391
      goto case_11;
    }
#line 392
    if ((int )c == 92) {
#line 392
      goto case_92;
    }
#line 411
    if ((int )c == 125) {
#line 411
      goto case_125;
    }
#line 411
    if ((int )c == 123) {
#line 411
      goto case_125;
    }
#line 415
    if ((int )c == 126) {
#line 415
      goto case_126;
    }
#line 415
    if ((int )c == 35) {
#line 415
      goto case_126;
    }
#line 427
    if ((int )c == 124) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 96) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 94) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 91) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 62) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 61) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 60) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 59) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 42) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 41) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 40) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 38) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 36) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 34) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 33) {
#line 427
      goto case_124;
    }
#line 427
    if ((int )c == 32) {
#line 427
      goto case_124;
    }
#line 437
    if ((int )c == 39) {
#line 437
      goto case_39___0;
    }
#line 459
    if ((int )c == 122) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 121) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 120) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 119) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 118) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 117) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 116) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 115) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 114) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 113) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 112) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 111) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 110) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 109) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 108) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 107) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 106) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 105) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 104) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 103) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 102) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 101) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 100) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 99) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 98) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 97) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 95) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 93) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 90) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 89) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 88) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 87) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 86) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 85) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 84) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 83) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 82) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 81) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 80) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 79) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 78) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 77) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 76) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 75) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 74) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 73) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 72) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 71) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 70) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 69) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 68) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 67) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 66) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 65) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 58) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 57) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 56) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 55) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 54) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 53) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 52) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 51) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 50) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 49) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 48) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 47) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 46) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 45) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 44) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 43) {
#line 459
      goto case_122;
    }
#line 459
    if ((int )c == 37) {
#line 459
      goto case_122;
    }
#line 472
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 322
    if (backslash_escapes) {
#line 324
      if (elide_outer_quotes) {
#line 325
        goto force_outer_quoting_style;
      }
      {
#line 326
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 326
        if (len < buffersize) {
#line 326
          *(buffer + len) = (char )'\\';
        }
#line 326
        len ++;
#line 326
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 332
      if (i + 1UL < argsize) {
#line 332
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 332
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            {
#line 334
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 334
              if (len < buffersize) {
#line 334
                *(buffer + len) = (char )'0';
              }
#line 334
              len ++;
#line 334
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 335
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 335
              if (len < buffersize) {
#line 335
                *(buffer + len) = (char )'0';
              }
#line 335
              len ++;
#line 335
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 337
      c = (unsigned char )'0';
    } else
#line 343
    if (flags & 1) {
#line 344
      goto __Cont;
    }
#line 345
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 350
    if ((unsigned int )quoting_style == 2U) {
#line 350
      goto case_2___0;
    }
#line 355
    if ((unsigned int )quoting_style == 3U) {
#line 355
      goto case_3___0;
    }
#line 380
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 351
    if (elide_outer_quotes) {
#line 352
      goto force_outer_quoting_style;
    }
#line 353
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 356
    if (flags & 4) {
#line 356
      if (i + 2UL < argsize) {
#line 356
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 362
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 362
            goto case_62;
          }
#line 362
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 362
            goto case_62;
          }
#line 375
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 365
          if (elide_outer_quotes) {
#line 366
            goto force_outer_quoting_style;
          }
#line 367
          c = (unsigned char )*(arg + (i + 2UL));
#line 368
          i += 2UL;
          {
#line 369
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 369
            if (len < buffersize) {
#line 369
              *(buffer + len) = (char )'?';
            }
#line 369
            len ++;
#line 369
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 370
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 370
            if (len < buffersize) {
#line 370
              *(buffer + len) = (char )'\"';
            }
#line 370
            len ++;
#line 370
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 371
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 371
            if (len < buffersize) {
#line 371
              *(buffer + len) = (char )'\"';
            }
#line 371
            len ++;
#line 371
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 372
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 372
            if (len < buffersize) {
#line 372
              *(buffer + len) = (char )'?';
            }
#line 372
            len ++;
#line 372
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 373
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 376
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 378
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 381
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 383
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 385
    esc = (unsigned char )'a';
#line 385
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 386
    esc = (unsigned char )'b';
#line 386
    goto c_escape;
    case_12: /* CIL Label */ 
#line 387
    esc = (unsigned char )'f';
#line 387
    goto c_escape;
    case_10: /* CIL Label */ 
#line 388
    esc = (unsigned char )'n';
#line 388
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 389
    esc = (unsigned char )'r';
#line 389
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 390
    esc = (unsigned char )'t';
#line 390
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 391
    esc = (unsigned char )'v';
#line 391
    goto c_escape;
    case_92: /* CIL Label */ 
#line 392
    esc = c;
#line 395
    if (backslash_escapes) {
#line 395
      if (elide_outer_quotes) {
#line 395
        if (quote_string_len) {
#line 396
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 399
    if ((unsigned int )quoting_style == 2U) {
#line 399
      if (elide_outer_quotes) {
#line 401
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 404
    if (backslash_escapes) {
#line 406
      c = esc;
#line 407
      goto store_escape;
    }
#line 409
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 412
    if (argsize == 0xffffffffffffffffUL) {
#line 412
      tmp___1 = (int const   )*(arg + 1) == 0;
    } else {
#line 412
      tmp___1 = argsize == 1UL;
    }
#line 412
    if (! tmp___1) {
#line 413
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 416
    if (i != 0UL) {
#line 417
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 432
    if ((unsigned int )quoting_style == 2U) {
#line 432
      if (elide_outer_quotes) {
#line 434
        goto force_outer_quoting_style;
      }
    }
#line 435
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 438
    if ((unsigned int )quoting_style == 2U) {
#line 440
      if (elide_outer_quotes) {
#line 441
        goto force_outer_quoting_style;
      }
      {
#line 442
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 442
        if (len < buffersize) {
#line 442
          *(buffer + len) = (char )'\'';
        }
#line 442
        len ++;
#line 442
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 443
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 443
        if (len < buffersize) {
#line 443
          *(buffer + len) = (char )'\\';
        }
#line 443
        len ++;
#line 443
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 444
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 444
        if (len < buffersize) {
#line 444
          *(buffer + len) = (char )'\'';
        }
#line 444
        len ++;
#line 444
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 446
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 470
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 484
    if (unibyte_locale) {
      {
#line 486
      m = (size_t )1;
#line 487
      tmp___2 = __ctype_b_loc();
#line 487
      printable = (_Bool )(((int const   )*(*tmp___2 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 492
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 494
      m = (size_t )0;
#line 495
      printable = (_Bool)1;
      }
#line 496
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 497
        argsize = strlen(arg);
        }
      }
      {
#line 499
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 502
        tmp___3 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), & mbstate);
#line 502
        bytes = tmp___3;
        }
#line 504
        if (bytes == 0UL) {
#line 505
          goto while_break___14;
        } else
#line 506
        if (bytes == 0xffffffffffffffffUL) {
#line 508
          printable = (_Bool)0;
#line 509
          goto while_break___14;
        } else
#line 511
        if (bytes == 0xfffffffffffffffeUL) {
#line 513
          printable = (_Bool)0;
          {
#line 514
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 514
            if (i + m < argsize) {
#line 514
              if (! *(arg + (i + m))) {
#line 514
                goto while_break___15;
              }
            } else {
#line 514
              goto while_break___15;
            }
#line 515
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 516
          goto while_break___14;
        } else {
#line 524
          if (elide_outer_quotes) {
#line 524
            if ((unsigned int )quoting_style == 2U) {
#line 528
              j = (size_t )1;
              {
#line 528
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 528
                if (! (j < bytes)) {
#line 528
                  goto while_break___16;
                }
                {
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 532
                  goto case_124___0;
                }
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 532
                  goto case_124___0;
                }
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 532
                  goto case_124___0;
                }
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 532
                  goto case_124___0;
                }
#line 532
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 532
                  goto case_124___0;
                }
#line 535
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 533
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 536
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 528
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 540
          tmp___4 = iswprint((wint_t )w);
          }
#line 540
          if (! tmp___4) {
#line 541
            printable = (_Bool)0;
          }
#line 542
          m += bytes;
        }
        {
#line 499
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 499
        if (tmp___5) {
#line 499
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 548
    if (1UL < m) {
#line 548
      goto _L___0;
    } else
#line 548
    if (backslash_escapes) {
#line 548
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 552
        ilim = i + m;
        {
#line 554
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 556
          if (backslash_escapes) {
#line 556
            if (! printable) {
#line 558
              if (elide_outer_quotes) {
#line 559
                goto force_outer_quoting_style;
              }
              {
#line 560
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 560
                if (len < buffersize) {
#line 560
                  *(buffer + len) = (char )'\\';
                }
#line 560
                len ++;
#line 560
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 561
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 561
                if (len < buffersize) {
#line 561
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 561
                len ++;
#line 561
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 562
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 562
                if (len < buffersize) {
#line 562
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 562
                len ++;
#line 562
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 563
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 556
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 565
          if (is_right_quote) {
            {
#line 567
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 567
              if (len < buffersize) {
#line 567
                *(buffer + len) = (char )'\\';
              }
#line 567
              len ++;
#line 567
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 568
            is_right_quote = (_Bool)0;
          }
#line 570
          if (ilim <= i + 1UL) {
#line 571
            goto while_break___17;
          }
          {
#line 572
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 572
            if (len < buffersize) {
#line 572
              *(buffer + len) = (char )c;
            }
#line 572
            len ++;
#line 572
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 573
          i ++;
#line 573
          c = (unsigned char )*(arg + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 576
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 581
    if (backslash_escapes) {
#line 581
      goto _L___3;
    } else
#line 581
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 581
      if (quote_these_too) {
#line 581
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 581
          goto _L___2;
        }
      } else {
#line 581
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 581
    if (! is_right_quote) {
#line 585
      goto store_c;
    }
    store_escape: 
#line 588
    if (elide_outer_quotes) {
#line 589
      goto force_outer_quoting_style;
    }
    {
#line 590
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 590
      if (len < buffersize) {
#line 590
        *(buffer + len) = (char )'\\';
      }
#line 590
      len ++;
#line 590
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 593
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 593
      if (len < buffersize) {
#line 593
        *(buffer + len) = (char )c;
      }
#line 593
      len ++;
#line 593
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 302
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 596
  if (len == 0UL) {
#line 596
    if ((unsigned int )quoting_style == 2U) {
#line 596
      if (elide_outer_quotes) {
#line 598
        goto force_outer_quoting_style;
      }
    }
  }
#line 600
  if (quote_string) {
#line 600
    if (! elide_outer_quotes) {
      {
#line 601
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 601
        if (! *quote_string) {
#line 601
          goto while_break___25;
        }
        {
#line 602
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 602
          if (len < buffersize) {
#line 602
            *(buffer + len) = (char )*quote_string;
          }
#line 602
          len ++;
#line 602
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 601
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 604
  if (len < buffersize) {
#line 605
    *(buffer + len) = (char )'\000';
  }
#line 606
  return (len);
  force_outer_quoting_style: 
  {
#line 611
  tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 611
  return (tmp___7);
}
}
#line 626 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 631
  if (o) {
#line 631
    tmp = o;
  } else {
#line 631
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 631
  p = tmp;
#line 632
  tmp___0 = __errno_location();
#line 632
  e = *tmp___0;
#line 633
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 633
  r = tmp___1;
#line 636
  tmp___2 = __errno_location();
#line 636
  *tmp___2 = e;
  }
#line 637
  return (r);
}
}
#line 641 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 645
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 645
  return (tmp);
}
}
#line 654 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf___0 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 658
  if (o) {
#line 658
    tmp = o;
  } else {
#line 658
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 658
  p = tmp;
#line 659
  tmp___0 = __errno_location();
#line 659
  e = *tmp___0;
  }
#line 661
  if (size) {
#line 661
    tmp___1 = 0;
  } else {
#line 661
    tmp___1 = 1;
  }
  {
#line 661
  flags = (int )(p->flags | (int const   )tmp___1);
#line 662
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 662
  bufsize = tmp___2 + 1UL;
#line 666
  tmp___3 = xcharalloc(bufsize);
#line 666
  buf___0 = tmp___3;
#line 667
  quotearg_buffer_restyled(buf___0, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 670
  tmp___4 = __errno_location();
#line 670
  *tmp___4 = e;
  }
#line 671
  if (size) {
#line 672
    *size = bufsize - 1UL;
  }
#line 673
  return (buf___0);
}
}
#line 685 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
static char slot0[256]  ;
#line 686 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
static unsigned int nslots  =    1U;
#line 687 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 688 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 690 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 693
  sv = slotvec;
#line 695
  i = 1U;
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! (i < nslots)) {
#line 695
      goto while_break;
    }
    {
#line 696
    free((void *)(sv + i)->val);
#line 695
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 699
    free((void *)(sv + 0)->val);
#line 700
    slotvec0.size = sizeof(slot0);
#line 701
    slotvec0.val = slot0;
    }
  }
#line 703
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 705
    free((void *)sv);
#line 706
    slotvec = & slotvec0;
    }
  }
#line 708
  nslots = 1U;
#line 709
  return;
}
}
#line 719 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 723
  tmp = __errno_location();
#line 723
  e = *tmp;
#line 725
  n0 = (unsigned int )n;
#line 726
  sv = slotvec;
  }
#line 728
  if (n < 0) {
    {
#line 729
    abort();
    }
  }
#line 731
  if (nslots <= n0) {
#line 738
    n1 = (size_t )(n0 + 1U);
#line 739
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 741
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 741
      tmp___0 = -1;
    } else {
#line 741
      tmp___0 = -2;
    }
#line 741
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 742
      xalloc_die();
      }
    }
#line 744
    if (preallocated) {
#line 744
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 744
      tmp___1 = sv;
    }
    {
#line 744
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 744
    sv = (struct slotvec *)tmp___2;
#line 744
    slotvec = sv;
    }
#line 745
    if (preallocated) {
#line 746
      *sv = slotvec0;
    }
    {
#line 747
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 748
    nslots = (unsigned int )n1;
    }
  }
  {
#line 752
  size = (sv + n)->size;
#line 753
  val = (sv + n)->val;
#line 755
  flags = (int )(options->flags | 1);
#line 756
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 756
  qsize = tmp___3;
  }
#line 762
  if (size <= qsize) {
#line 764
    size = qsize + 1UL;
#line 764
    (sv + n)->size = size;
#line 765
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 766
      free((void *)val);
      }
    }
    {
#line 767
    val = xcharalloc(size);
#line 767
    (sv + n)->val = val;
#line 768
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 774
  tmp___4 = __errno_location();
#line 774
  *tmp___4 = e;
  }
#line 775
  return (val);
}
}
#line 779 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 782
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 782
  return (tmp);
}
}
#line 785 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 788
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 788
  return (tmp);
}
}
#line 791 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 794
  tmp = quotearg_n(0, arg);
  }
#line 794
  return (tmp);
}
}
#line 797 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 800
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 800
  return (tmp);
}
}
#line 803 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 806
  tmp = quoting_options_from_style(s);
#line 806
  o = tmp;
#line 807
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 807
  return (tmp___0);
}
}
#line 810 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
#line 814
  tmp = quoting_options_from_style(s);
#line 814
  o = tmp;
#line 815
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 815
  return (tmp___0);
}
}
#line 818 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 821
  tmp = quotearg_n_style(0, s, arg);
  }
#line 821
  return (tmp);
}
}
#line 824 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 827
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 827
  return (tmp);
}
}
#line 830 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 834
  options = default_quoting_options;
#line 835
  set_char_quoting(& options, ch, 1);
#line 836
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 836
  return (tmp);
}
}
#line 839 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 842
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 842
  return (tmp);
}
}
#line 845 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 848
  tmp = quotearg_char(arg, (char )':');
  }
#line 848
  return (tmp);
}
}
#line 851 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 854
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 854
  return (tmp);
}
}
#line 857 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 861
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
  }
#line 861
  return (tmp);
}
}
#line 865 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 870
  o = default_quoting_options;
#line 871
  set_custom_quoting(& o, left_quote, right_quote);
#line 872
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 872
  return (tmp);
}
}
#line 875 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 879
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 879
  return (tmp);
}
}
#line 882 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 886
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 886
  return (tmp);
}
}
#line 20 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quote.h"
char const   *quote(char const   *name ) ;
#line 28 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quote.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 31
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
  }
#line 31
  return ((char const   *)tmp);
}
}
#line 36 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/quote.c"
char const   *quote(char const   *name ) 
{ 
  char const   *tmp ;

  {
  {
#line 39
  tmp = quote_n(0, name);
  }
#line 39
  return (tmp);
}
}
#line 92 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/propername.h"
char const   *proper_name(char const   *name ) ;
#line 98
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) ;
#line 1103 "./string.h"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle ) ;
#line 112 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswalnum(wint_t __wc ) ;
#line 123 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbuiter.h"
__inline static void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
  {
#line 131
  tmp___3 = is_basic((char )*(iter->cur.ptr));
  }
#line 131
  if (tmp___3) {
#line 136
    iter->cur.bytes = (size_t )1;
#line 137
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 142
    tmp = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 142
    if (! tmp) {
      {
#line 142
      __assert_fail("mbsinit (&iter->state)", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbuiter.h",
                    142U, "mbuiter_multi_next");
      }
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 145
    tmp___0 = __ctype_get_mb_cur_max();
#line 145
    tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
#line 145
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              tmp___1, & iter->state);
    }
#line 148
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 151
      iter->cur.bytes = (size_t )1;
#line 152
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 156
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
      {
#line 159
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 160
      iter->cur.wc_valid = (_Bool)0;
      }
    } else {
#line 166
      if (iter->cur.bytes == 0UL) {
#line 169
        iter->cur.bytes = (size_t )1;
#line 170
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 170
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbuiter.h",
                        170U, "mbuiter_multi_next");
          }
        }
#line 171
        if (! (iter->cur.wc == 0)) {
          {
#line 171
          __assert_fail("iter->cur.wc == 0", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbuiter.h",
                        171U, "mbuiter_multi_next");
          }
        }
      }
      {
#line 173
      iter->cur.wc_valid = (_Bool)1;
#line 177
      tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 177
      if (tmp___2) {
#line 178
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 181
  iter->next_done = (_Bool)1;
#line 182
  return;
}
}
#line 35 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 106 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 48 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;

  {
  {
#line 51
  tmp = trim2(sub, 2);
#line 51
  tsub = tmp;
#line 52
  found = (_Bool)0;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((int const   )*string != 0)) {
#line 54
      goto while_break;
    }
    {
#line 56
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 56
    tsub_in_string = (char const   *)tmp___0;
    }
#line 57
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 58
      goto while_break;
    } else {
      {
#line 61
      tmp___11 = __ctype_get_mb_cur_max();
      }
#line 61
      if (tmp___11 > 1UL) {
        {
#line 67
        string_iter.cur.ptr = string;
#line 67
        string_iter.in_shift = (_Bool)0;
#line 67
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 67
        string_iter.next_done = (_Bool)0;
#line 68
        word_boundary_before = (_Bool)1;
        }
#line 69
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          {
#line 72
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 74
            mbuiter_multi_next(& string_iter);
            }
#line 74
            if (string_iter.cur.wc_valid) {
#line 74
              if (string_iter.cur.wc == 0) {
#line 74
                tmp___1 = 0;
              } else {
#line 74
                tmp___1 = 1;
              }
            } else {
#line 74
              tmp___1 = 1;
            }
#line 74
            if (! tmp___1) {
              {
#line 75
              abort();
              }
            }
#line 76
            last_char_before_tsub = string_iter.cur;
#line 77
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 77
            string_iter.next_done = (_Bool)0;
#line 72
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 72
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 80
          if (last_char_before_tsub.wc_valid) {
            {
#line 80
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            }
#line 80
            if (tmp___2) {
#line 81
              word_boundary_before = (_Bool)0;
            }
          }
        }
        {
#line 84
        string_iter.cur.ptr = tsub_in_string;
#line 84
        string_iter.in_shift = (_Bool)0;
#line 84
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 84
        string_iter.next_done = (_Bool)0;
#line 88
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 88
        tsub_iter.in_shift = (_Bool)0;
#line 88
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 88
        tsub_iter.next_done = (_Bool)0;
        }
        {
#line 88
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 88
          mbuiter_multi_next(& tsub_iter);
          }
#line 88
          if (tsub_iter.cur.wc_valid) {
#line 88
            if (tsub_iter.cur.wc == 0) {
#line 88
              tmp___4 = 0;
            } else {
#line 88
              tmp___4 = 1;
            }
          } else {
#line 88
            tmp___4 = 1;
          }
#line 88
          if (! tmp___4) {
#line 88
            goto while_break___1;
          }
          {
#line 92
          mbuiter_multi_next(& string_iter);
          }
#line 92
          if (string_iter.cur.wc_valid) {
#line 92
            if (string_iter.cur.wc == 0) {
#line 92
              tmp___3 = 0;
            } else {
#line 92
              tmp___3 = 1;
            }
          } else {
#line 92
            tmp___3 = 1;
          }
#line 92
          if (! tmp___3) {
            {
#line 93
            abort();
            }
          }
#line 94
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 94
          string_iter.next_done = (_Bool)0;
#line 88
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 88
          tsub_iter.next_done = (_Bool)0;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 97
        word_boundary_after = (_Bool)1;
#line 98
        mbuiter_multi_next(& string_iter);
        }
#line 98
        if (string_iter.cur.wc_valid) {
#line 98
          if (string_iter.cur.wc == 0) {
#line 98
            tmp___6 = 0;
          } else {
#line 98
            tmp___6 = 1;
          }
        } else {
#line 98
          tmp___6 = 1;
        }
#line 98
        if (tmp___6) {
#line 100
          first_char_after_tsub = string_iter.cur;
#line 101
          if (first_char_after_tsub.wc_valid) {
            {
#line 101
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            }
#line 101
            if (tmp___5) {
#line 102
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 105
        if (word_boundary_before) {
#line 105
          if (word_boundary_after) {
#line 107
            found = (_Bool)1;
#line 108
            goto while_break;
          }
        }
        {
#line 111
        string_iter.cur.ptr = tsub_in_string;
#line 111
        string_iter.in_shift = (_Bool)0;
#line 111
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 111
        string_iter.next_done = (_Bool)0;
#line 112
        mbuiter_multi_next(& string_iter);
        }
#line 112
        if (string_iter.cur.wc_valid) {
#line 112
          if (string_iter.cur.wc == 0) {
#line 112
            tmp___7 = 0;
          } else {
#line 112
            tmp___7 = 1;
          }
        } else {
#line 112
          tmp___7 = 1;
        }
#line 112
        if (! tmp___7) {
#line 113
          goto while_break;
        }
#line 114
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 122
        word_boundary_before___0 = (_Bool)1;
#line 123
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          {
#line 124
          tmp___8 = __ctype_b_loc();
          }
#line 124
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 125
            word_boundary_before___0 = (_Bool)0;
          }
        }
        {
#line 127
        tmp___9 = strlen((char const   *)tsub);
#line 127
        p = tsub_in_string + tmp___9;
#line 128
        word_boundary_after___0 = (_Bool)1;
        }
#line 129
        if ((int const   )*p != 0) {
          {
#line 130
          tmp___10 = __ctype_b_loc();
          }
#line 130
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 131
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 133
        if (word_boundary_before___0) {
#line 133
          if (word_boundary_after___0) {
#line 135
            found = (_Bool)1;
#line 136
            goto while_break;
          }
        }
#line 139
        if ((int const   )*tsub_in_string == 0) {
#line 140
          goto while_break;
        }
#line 141
        string = tsub_in_string + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  free((void *)tsub);
  }
#line 146
  return (found);
}
}
#line 151 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/propername.c"
char const   *proper_name(char const   *name ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;
  char *__cil_tmp13 ;

  {
  {
#line 155
  tmp = gettext(name);
#line 155
  translation = (char const   *)tmp;
  }
#line 157
  if ((unsigned long )translation != (unsigned long )name) {
    {
#line 160
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
    }
#line 160
    if (tmp___7) {
#line 161
      return (translation);
    } else {
#line 165
      if (sizeof(char ) == 1UL) {
        {
#line 165
        tmp___0 = strlen(translation);
#line 165
        tmp___1 = strlen(name);
#line 165
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
#line 165
        tmp___6 = tmp___2;
        }
      } else {
        {
#line 165
        tmp___3 = strlen(translation);
#line 165
        tmp___4 = strlen(name);
#line 165
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
#line 165
        tmp___6 = tmp___5;
        }
      }
      {
#line 165
      result = (char *)tmp___6;
#line 168
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 169
      return ((char const   *)result);
    }
  } else {
#line 173
    return (name);
  }
}
}
#line 181 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/propername.c"
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const   *name_converted ;
  char const   *name_converted_translit ;
  char const   *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *result ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 185
  tmp = gettext(name_ascii);
#line 185
  translation = (char const   *)tmp;
#line 188
  tmp___0 = locale_charset();
#line 188
  locale_code = tmp___0;
#line 189
  alloc_name_converted = (char *)((void *)0);
#line 190
  alloc_name_converted_translit = (char *)((void *)0);
#line 191
  name_converted = (char const   *)((void *)0);
#line 192
  name_converted_translit = (char const   *)((void *)0);
#line 195
  tmp___6 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 195
  if (tmp___6 != 0) {
    {
#line 198
    alloc_name_converted = xstr_iconv(name_utf8, "UTF-8", locale_code);
#line 198
    name_converted = (char const   *)alloc_name_converted;
#line 207
    tmp___1 = strlen(locale_code);
#line 207
    len = tmp___1;
    }
#line 208
    if (sizeof(char ) == 1UL) {
      {
#line 208
      tmp___2 = xmalloc((len + 10UL) + 1UL);
#line 208
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 208
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
#line 208
      tmp___4 = tmp___3;
      }
    }
    {
#line 208
    locale_code_translit = (char *)tmp___4;
#line 209
    memcpy((void */* __restrict  */)locale_code_translit, (void const   */* __restrict  */)locale_code,
           len);
#line 210
    memcpy((void */* __restrict  */)(locale_code_translit + len), (void const   */* __restrict  */)"//TRANSLIT",
           (size_t )11);
#line 212
    converted_translit = xstr_iconv(name_utf8, "UTF-8", (char const   *)locale_code_translit);
#line 215
    free((void *)locale_code_translit);
    }
#line 217
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
      {
#line 224
      tmp___5 = strchr((char const   *)converted_translit, '?');
      }
#line 224
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
#line 225
        free((void *)converted_translit);
        }
      } else {
#line 228
        alloc_name_converted_translit = converted_translit;
#line 228
        name_converted_translit = (char const   *)alloc_name_converted_translit;
      }
    }
  } else {
#line 237
    name_converted = name_utf8;
#line 238
    name_converted_translit = name_utf8;
  }
#line 242
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 242
    name = name_converted;
  } else {
#line 242
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 242
      tmp___7 = name_converted_translit;
    } else {
#line 242
      tmp___7 = name_ascii;
    }
#line 242
    name = tmp___7;
  }
  {
#line 249
  tmp___18 = strcmp(translation, name_ascii);
  }
#line 249
  if (tmp___18 != 0) {
    {
#line 252
    tmp___15 = mbsstr_trimmed_wordbounded(translation, name_ascii);
    }
#line 252
    if (tmp___15) {
#line 252
      goto _L;
    } else
#line 252
    if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
      {
#line 252
      tmp___16 = mbsstr_trimmed_wordbounded(translation, name_converted);
      }
#line 252
      if (tmp___16) {
#line 252
        goto _L;
      } else {
#line 252
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 252
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
      {
#line 252
      tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
      }
#line 252
      if (tmp___17) {
        _L: /* CIL Label */ 
#line 258
        if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
          {
#line 259
          free((void *)alloc_name_converted);
          }
        }
#line 260
        if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
          {
#line 261
          free((void *)alloc_name_converted_translit);
          }
        }
#line 262
        return (translation);
      } else {
#line 252
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 267
      if (sizeof(char ) == 1UL) {
        {
#line 267
        tmp___8 = strlen(translation);
#line 267
        tmp___9 = strlen(name);
#line 267
        tmp___10 = xmalloc((((tmp___8 + 2UL) + tmp___9) + 1UL) + 1UL);
#line 267
        tmp___14 = tmp___10;
        }
      } else {
        {
#line 267
        tmp___11 = strlen(translation);
#line 267
        tmp___12 = strlen(name);
#line 267
        tmp___13 = xnmalloc((((tmp___11 + 2UL) + tmp___12) + 1UL) + 1UL, sizeof(char ));
#line 267
        tmp___14 = tmp___13;
        }
      }
      {
#line 267
      result = (char *)tmp___14;
#line 270
      sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"%s (%s)",
              translation, name);
      }
#line 272
      if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
        {
#line 273
        free((void *)alloc_name_converted);
        }
      }
#line 274
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
        {
#line 275
        free((void *)alloc_name_converted_translit);
        }
      }
#line 276
      return ((char const   *)result);
    }
  } else {
#line 281
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 281
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
        {
#line 282
        free((void *)alloc_name_converted);
        }
      }
    }
#line 283
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 283
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
        {
#line 285
        free((void *)alloc_name_converted_translit);
        }
      }
    }
#line 286
    return (name);
  }
}
}
#line 32 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 55 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 55
extern char *program_invocation_short_name ;
#line 662 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 54
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
  }
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7L) {
    {
#line 61
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 61
    if (tmp___1 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 64
      if (tmp___0 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 3 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/prepargs.h"
void prepend_default_options(char const   *options , int *pargc , char ***pargv ) ;
#line 44 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/prepargs.c"
static int prepend_args(char const   *options , char *buf___0 , char **argv ) 
{ 
  char const   *o ;
  char *b ;
  int n ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 47
  o = options;
#line 48
  b = buf___0;
#line 49
  n = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 53
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 53
      tmp = __ctype_b_loc();
      }
#line 53
      if (! ((int const   )*(*tmp + (int )((unsigned char )*o)) & 8192)) {
#line 53
        goto while_break___0;
      }
#line 54
      o ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 55
    if (! *o) {
#line 56
      return (n);
    }
#line 57
    if (argv) {
#line 58
      *(argv + n) = b;
    }
#line 59
    n ++;
    {
#line 61
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 62
      tmp___1 = b;
#line 62
      b ++;
#line 62
      tmp___3 = o;
#line 62
      o ++;
#line 62
      tmp___2 = (char )*tmp___3;
#line 62
      *tmp___1 = tmp___2;
#line 62
      if ((int )tmp___2 == 92) {
#line 62
        if (*o) {
#line 63
          tmp___0 = o;
#line 63
          o ++;
#line 63
          *(b + -1) = (char )*tmp___0;
        }
      }
#line 61
      if (*o) {
        {
#line 61
        tmp___4 = __ctype_b_loc();
        }
#line 61
        if ((int const   )*(*tmp___4 + (int )((unsigned char )*o)) & 8192) {
#line 61
          goto while_break___1;
        }
      } else {
#line 61
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 66
    tmp___5 = b;
#line 66
    b ++;
#line 66
    *tmp___5 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 73 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/prepargs.c"
void prepend_default_options(char const   *options , int *pargc , char ***pargv ) 
{ 
  char *buf___0 ;
  size_t tmp ;
  void *tmp___0 ;
  int prepended ;
  int tmp___1 ;
  int argc ;
  char * const  *argv ;
  char **pp ;
  void *tmp___2 ;
  char **tmp___3 ;
  char * const  *tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  char *tmp___7 ;
  char * const  *tmp___8 ;

  {
#line 76
  if (options) {
    {
#line 78
    tmp = strlen(options);
#line 78
    tmp___0 = xmalloc(tmp + 1UL);
#line 78
    buf___0 = (char *)tmp___0;
#line 79
    tmp___1 = prepend_args(options, buf___0, (char **)0);
#line 79
    prepended = tmp___1;
#line 80
    argc = *pargc;
#line 81
    argv = (char * const  *)*pargv;
#line 82
    tmp___2 = xmalloc((unsigned long )((prepended + argc) + 1) * sizeof(*pp));
#line 82
    pp = (char **)tmp___2;
#line 83
    *pargc = prepended + argc;
#line 84
    *pargv = pp;
#line 85
    tmp___3 = pp;
#line 85
    pp ++;
#line 85
    tmp___4 = argv;
#line 85
    argv ++;
#line 85
    *tmp___3 = (char *)*tmp___4;
#line 86
    tmp___5 = prepend_args(options, buf___0, pp);
#line 86
    pp += tmp___5;
    }
    {
#line 87
    while (1) {
      while_continue: /* CIL Label */ ;
#line 87
      tmp___6 = pp;
#line 87
      pp ++;
#line 87
      tmp___8 = argv;
#line 87
      argv ++;
#line 87
      tmp___7 = (char *)*tmp___8;
#line 87
      *tmp___6 = tmp___7;
#line 87
      if (! tmp___7) {
#line 87
        goto while_break;
      }
#line 88
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 90
  return;
}
}
#line 22 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 44 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___0 ) ;
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/anytostr.c"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___0 ) 
{ 
  char *p ;

  {
#line 36
  p = buf___0 + (((sizeof(off_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0L) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48L - i % 10L);
#line 41
      i /= 10L;
#line 41
      if (! (i != 0L)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      p --;
#line 50
      *p = (char )(48L + i % 10L);
#line 49
      i /= 10L;
#line 49
      if (! (i != 0L)) {
#line 49
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 54
  return (p);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 404 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strnlen)(char const   *__string ,
                                                                                       size_t __maxlen )  __attribute__((__pure__)) ;
#line 1045 "./string.h"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string ) ;
#line 66 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 70
void freea(void *p ) ;
#line 259 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbchar.h"
__inline static void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc ) 
{ 
  _Bool tmp ;

  {
#line 262
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
    {
#line 264
    memcpy((void */* __restrict  */)(& new_mbc->buf[0]), (void const   */* __restrict  */)(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
#line 265
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
    }
  } else {
#line 268
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
#line 269
  new_mbc->bytes = (size_t )old_mbc->bytes;
#line 270
  tmp = (_Bool )old_mbc->wc_valid;
#line 270
  new_mbc->wc_valid = tmp;
#line 270
  if (tmp) {
#line 271
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
#line 272
  return;
}
}
#line 37 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/str-kmp.h"
static _Bool knuth_morris_pratt(unsigned char const   *haystack , unsigned char const   *needle ,
                                size_t needle_len , unsigned char const   **resultp ) 
{ 
  size_t m ;
  size_t *table ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
#line 42
  m = needle_len;
#line 45
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 45
    tmp___4 = -1;
  } else {
#line 45
    tmp___4 = -2;
  }
#line 45
  if (m > (size_t )tmp___4 / sizeof(size_t )) {
#line 45
    tmp___3 = (void *)0;
  } else {
#line 45
    if (m * sizeof(size_t ) < 4016UL) {
      {
#line 45
      tmp___0 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 45
      tmp___2 = (void *)((char *)tmp___0 + 16);
      }
    } else {
      {
#line 45
      tmp___1 = mmalloca(m * sizeof(size_t ));
#line 45
      tmp___2 = tmp___1;
      }
    }
#line 45
    tmp___3 = tmp___2;
  }
#line 45
  table = (size_t *)tmp___3;
#line 46
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 47
    return ((_Bool)0);
  }
#line 67
  *(table + 1) = (size_t )1;
#line 68
  j = (size_t )0;
#line 70
  i = (size_t )2;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < m)) {
#line 70
      goto while_break;
    }
#line 76
    b = (unsigned char )*(needle + (i - 1UL));
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      if ((int )b == (int )*(needle + j)) {
#line 86
        j ++;
#line 86
        *(table + i) = i - j;
#line 87
        goto while_break___0;
      }
#line 92
      if (j == 0UL) {
#line 95
        *(table + i) = i;
#line 96
        goto while_break___0;
      }
#line 109
      j -= *(table + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  *resultp = (unsigned char const   *)((void *)0);
#line 122
  j___0 = (size_t )0;
#line 123
  rhaystack = haystack;
#line 124
  phaystack = haystack;
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 126
    if (! ((int const   )*phaystack != 0)) {
#line 126
      goto while_break___1;
    }
#line 127
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
#line 129
      j___0 ++;
#line 130
      phaystack ++;
#line 131
      if (j___0 == m) {
#line 134
        *resultp = rhaystack;
#line 135
        goto while_break___1;
      }
    } else
#line 138
    if (j___0 > 0UL) {
#line 141
      rhaystack += *(table + j___0);
#line 142
      j___0 -= *(table + j___0);
    } else {
#line 147
      rhaystack ++;
#line 148
      phaystack ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 152
  freea((void *)table);
  }
#line 153
  return ((_Bool)1);
}
}
#line 39 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte(char const   *haystack , char const   *needle ,
                                          char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  char *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;

  {
  {
#line 43
  tmp = mbslen(needle);
#line 43
  m = tmp;
  }
#line 48
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 48
    tmp___5 = -1;
  } else {
#line 48
    tmp___5 = -2;
  }
#line 48
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
#line 48
    tmp___4 = (void *)0;
  } else {
#line 48
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      {
#line 48
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 48
      tmp___3 = (void *)((char *)tmp___1 + 16);
      }
    } else {
      {
#line 48
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 48
      tmp___3 = tmp___2;
      }
    }
#line 48
    tmp___4 = tmp___3;
  }
#line 48
  memory = (char *)tmp___4;
#line 49
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 50
    return ((_Bool)0);
  }
  {
#line 51
  needle_mbchars = (mbchar_t *)memory;
#line 52
  table = (size_t *)(memory + m * sizeof(mbchar_t ));
#line 59
  j = (size_t )0;
#line 60
  iter.cur.ptr = needle;
#line 60
  iter.in_shift = (_Bool)0;
#line 60
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 60
  iter.next_done = (_Bool)0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    mbuiter_multi_next(& iter);
    }
#line 60
    if (iter.cur.wc_valid) {
#line 60
      if (iter.cur.wc == 0) {
#line 60
        tmp___6 = 0;
      } else {
#line 60
        tmp___6 = 1;
      }
    } else {
#line 60
      tmp___6 = 1;
    }
#line 60
    if (! tmp___6) {
#line 60
      goto while_break;
    }
    {
#line 61
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 60
    iter.cur.ptr += iter.cur.bytes;
#line 60
    iter.next_done = (_Bool)0;
#line 60
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  *(table + 1) = (size_t )1;
#line 84
  j___0 = (size_t )0;
#line 86
  i = (size_t )2;
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (i < m)) {
#line 86
      goto while_break___0;
    }
#line 92
    b = needle_mbchars + (i - 1UL);
    {
#line 94
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 99
      if (b->wc_valid) {
#line 99
        if ((needle_mbchars + j___0)->wc_valid) {
#line 99
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 99
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 99
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          {
#line 99
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          }
#line 99
          if (tmp___7 == 0) {
#line 99
            tmp___8 = 1;
          } else {
#line 99
            tmp___8 = 0;
          }
        } else {
#line 99
          tmp___8 = 0;
        }
#line 99
        tmp___9 = tmp___8;
      }
#line 99
      if (tmp___9) {
#line 102
        j___0 ++;
#line 102
        *(table + i) = i - j___0;
#line 103
        goto while_break___1;
      }
#line 108
      if (j___0 == 0UL) {
#line 111
        *(table + i) = i;
#line 112
        goto while_break___1;
      }
#line 125
      j___0 -= *(table + j___0);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 86
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 137
  *resultp = (char const   *)((void *)0);
#line 138
  j___1 = (size_t )0;
#line 139
  rhaystack.cur.ptr = haystack;
#line 139
  rhaystack.in_shift = (_Bool)0;
#line 139
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 139
  rhaystack.next_done = (_Bool)0;
#line 140
  phaystack.cur.ptr = haystack;
#line 140
  phaystack.in_shift = (_Bool)0;
#line 140
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 140
  phaystack.next_done = (_Bool)0;
  }
  {
#line 142
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 142
    mbuiter_multi_next(& phaystack);
    }
#line 142
    if (phaystack.cur.wc_valid) {
#line 142
      if (phaystack.cur.wc == 0) {
#line 142
        tmp___15 = 0;
      } else {
#line 142
        tmp___15 = 1;
      }
    } else {
#line 142
      tmp___15 = 1;
    }
#line 142
    if (! tmp___15) {
#line 142
      goto while_break___2;
    }
#line 143
    if ((needle_mbchars + j___1)->wc_valid) {
#line 143
      if (phaystack.cur.wc_valid) {
#line 143
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 143
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 143
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        {
#line 143
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        }
#line 143
        if (tmp___12 == 0) {
#line 143
          tmp___13 = 1;
        } else {
#line 143
          tmp___13 = 0;
        }
      } else {
#line 143
        tmp___13 = 0;
      }
#line 143
      tmp___14 = tmp___13;
    }
#line 143
    if (tmp___14) {
#line 145
      j___1 ++;
#line 146
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 146
      phaystack.next_done = (_Bool)0;
#line 147
      if (j___1 == m) {
#line 150
        *resultp = rhaystack.cur.ptr;
#line 151
        goto while_break___2;
      }
    } else
#line 154
    if (j___1 > 0UL) {
#line 157
      count = *(table + j___1);
#line 158
      j___1 -= count;
      {
#line 159
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 159
        if (! (count > 0UL)) {
#line 159
          goto while_break___3;
        }
        {
#line 161
        mbuiter_multi_next(& rhaystack);
        }
#line 161
        if (rhaystack.cur.wc_valid) {
#line 161
          if (rhaystack.cur.wc == 0) {
#line 161
            tmp___10 = 0;
          } else {
#line 161
            tmp___10 = 1;
          }
        } else {
#line 161
          tmp___10 = 1;
        }
#line 161
        if (! tmp___10) {
          {
#line 162
          abort();
          }
        }
#line 163
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 163
        rhaystack.next_done = (_Bool)0;
#line 159
        count --;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 169
      mbuiter_multi_next(& rhaystack);
      }
#line 169
      if (rhaystack.cur.wc_valid) {
#line 169
        if (rhaystack.cur.wc == 0) {
#line 169
          tmp___11 = 0;
        } else {
#line 169
          tmp___11 = 1;
        }
      } else {
#line 169
        tmp___11 = 1;
      }
#line 169
      if (! tmp___11) {
        {
#line 170
        abort();
        }
      }
#line 171
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 171
      rhaystack.next_done = (_Bool)0;
#line 172
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 172
      phaystack.next_done = (_Bool)0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 176
  freea((void *)memory);
  }
#line 177
  return ((_Bool)1);
}
}
#line 182 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbsstr.c"
char *( __attribute__((__nonnull__(1,2))) mbsstr)(char const   *haystack , char const   *needle ) 
{ 
  mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const   *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const   *needle_last_ccount ;
  char b ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  unsigned char const   *result___0 ;
  _Bool success___0 ;
  size_t tmp___15 ;
  _Bool tmp___16 ;
  char const   *rhaystack___0 ;
  char const   *rneedle___0 ;
  size_t tmp___17 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;

  {
  {
#line 190
  tmp___17 = __ctype_get_mb_cur_max();
  }
#line 190
  if (tmp___17 > 1UL) {
    {
#line 194
    iter_needle.cur.ptr = needle;
#line 194
    iter_needle.in_shift = (_Bool)0;
#line 194
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
#line 194
    iter_needle.next_done = (_Bool)0;
#line 195
    mbuiter_multi_next(& iter_needle);
    }
#line 195
    if (iter_needle.cur.wc_valid) {
#line 195
      if (iter_needle.cur.wc == 0) {
#line 195
        tmp___12 = 0;
      } else {
#line 195
        tmp___12 = 1;
      }
    } else {
#line 195
      tmp___12 = 1;
    }
#line 195
    if (tmp___12) {
      {
#line 211
      try_kmp = (_Bool)1;
#line 212
      outer_loop_count = (size_t )0;
#line 213
      comparison_count = (size_t )0;
#line 214
      last_ccount = (size_t )0;
#line 219
      iter_needle_last_ccount.cur.ptr = needle;
#line 219
      iter_needle_last_ccount.in_shift = (_Bool)0;
#line 219
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
#line 219
      iter_needle_last_ccount.next_done = (_Bool)0;
#line 220
      iter_haystack.cur.ptr = haystack;
#line 220
      iter_haystack.in_shift = (_Bool)0;
#line 220
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
#line 220
      iter_haystack.next_done = (_Bool)0;
      }
      {
#line 221
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 223
        mbuiter_multi_next(& iter_haystack);
        }
#line 223
        if (iter_haystack.cur.wc_valid) {
#line 223
          if (iter_haystack.cur.wc == 0) {
#line 223
            tmp = 0;
          } else {
#line 223
            tmp = 1;
          }
        } else {
#line 223
          tmp = 1;
        }
#line 223
        if (! tmp) {
#line 225
          return ((char *)((void *)0));
        }
#line 229
        if (try_kmp) {
#line 229
          if (outer_loop_count >= 10UL) {
#line 229
            if (comparison_count >= 5UL * outer_loop_count) {
#line 235
              count = comparison_count - last_ccount;
              {
#line 236
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 236
                if (count > 0UL) {
                  {
#line 236
                  mbuiter_multi_next(& iter_needle_last_ccount);
                  }
#line 236
                  if (iter_needle_last_ccount.cur.wc_valid) {
#line 236
                    if (iter_needle_last_ccount.cur.wc == 0) {
#line 236
                      tmp___0 = 0;
                    } else {
#line 236
                      tmp___0 = 1;
                    }
                  } else {
#line 236
                    tmp___0 = 1;
                  }
#line 236
                  if (! tmp___0) {
#line 236
                    goto while_break___0;
                  }
                } else {
#line 236
                  goto while_break___0;
                }
#line 239
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
#line 239
                iter_needle_last_ccount.next_done = (_Bool)0;
#line 236
                count --;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 240
              last_ccount = comparison_count;
#line 241
              mbuiter_multi_next(& iter_needle_last_ccount);
              }
#line 241
              if (iter_needle_last_ccount.cur.wc_valid) {
#line 241
                if (iter_needle_last_ccount.cur.wc == 0) {
#line 241
                  tmp___2 = 0;
                } else {
#line 241
                  tmp___2 = 1;
                }
              } else {
#line 241
                tmp___2 = 1;
              }
#line 241
              if (! tmp___2) {
                {
#line 245
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
#line 245
                success = tmp___1;
                }
#line 248
                if (success) {
#line 249
                  return ((char *)result);
                }
#line 250
                try_kmp = (_Bool)0;
              }
            }
          }
        }
#line 254
        outer_loop_count ++;
#line 255
        comparison_count ++;
#line 256
        if (iter_haystack.cur.wc_valid) {
#line 256
          if (iter_needle.cur.wc_valid) {
#line 256
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
          } else {
#line 256
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 256
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
            {
#line 256
            tmp___9 = memcmp((void const   *)iter_haystack.cur.ptr, (void const   *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
            }
#line 256
            if (tmp___9 == 0) {
#line 256
              tmp___10 = 1;
            } else {
#line 256
              tmp___10 = 0;
            }
          } else {
#line 256
            tmp___10 = 0;
          }
#line 256
          tmp___11 = tmp___10;
        }
#line 256
        if (tmp___11) {
          {
#line 262
          memcpy((void */* __restrict  */)(& rhaystack), (void const   */* __restrict  */)(& iter_haystack),
                 sizeof(mbui_iterator_t ));
#line 263
          rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 263
          rhaystack.next_done = (_Bool)0;
#line 265
          rneedle.cur.ptr = needle;
#line 265
          rneedle.in_shift = (_Bool)0;
#line 265
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
#line 265
          rneedle.next_done = (_Bool)0;
#line 266
          mbuiter_multi_next(& rneedle);
          }
#line 266
          if (rneedle.cur.wc_valid) {
#line 266
            if (rneedle.cur.wc == 0) {
#line 266
              tmp___3 = 0;
            } else {
#line 266
              tmp___3 = 1;
            }
          } else {
#line 266
            tmp___3 = 1;
          }
#line 266
          if (! tmp___3) {
            {
#line 267
            abort();
            }
          }
#line 268
          rneedle.cur.ptr += rneedle.cur.bytes;
#line 268
          rneedle.next_done = (_Bool)0;
          {
#line 270
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 272
            mbuiter_multi_next(& rneedle);
            }
#line 272
            if (rneedle.cur.wc_valid) {
#line 272
              if (rneedle.cur.wc == 0) {
#line 272
                tmp___4 = 0;
              } else {
#line 272
                tmp___4 = 1;
              }
            } else {
#line 272
              tmp___4 = 1;
            }
#line 272
            if (! tmp___4) {
#line 274
              return ((char *)iter_haystack.cur.ptr);
            }
            {
#line 275
            mbuiter_multi_next(& rhaystack);
            }
#line 275
            if (rhaystack.cur.wc_valid) {
#line 275
              if (rhaystack.cur.wc == 0) {
#line 275
                tmp___5 = 0;
              } else {
#line 275
                tmp___5 = 1;
              }
            } else {
#line 275
              tmp___5 = 1;
            }
#line 275
            if (! tmp___5) {
#line 277
              return ((char *)((void *)0));
            }
#line 278
            comparison_count ++;
#line 279
            if (rhaystack.cur.wc_valid) {
#line 279
              if (rneedle.cur.wc_valid) {
#line 279
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
              } else {
#line 279
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 279
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
                {
#line 279
                tmp___6 = memcmp((void const   *)rhaystack.cur.ptr, (void const   *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
                }
#line 279
                if (tmp___6 == 0) {
#line 279
                  tmp___7 = 1;
                } else {
#line 279
                  tmp___7 = 0;
                }
              } else {
#line 279
                tmp___7 = 0;
              }
#line 279
              tmp___8 = tmp___7;
            }
#line 279
            if (! tmp___8) {
#line 281
              goto while_break___1;
            }
#line 270
            rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 270
            rhaystack.next_done = (_Bool)0;
#line 270
            rneedle.cur.ptr += rneedle.cur.bytes;
#line 270
            rneedle.next_done = (_Bool)0;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 221
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
#line 221
        iter_haystack.next_done = (_Bool)0;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 287
      return ((char *)haystack);
    }
  } else
#line 291
  if ((int const   )*needle != 0) {
#line 307
    try_kmp___0 = (_Bool)1;
#line 308
    outer_loop_count___0 = (size_t )0;
#line 309
    comparison_count___0 = (size_t )0;
#line 310
    last_ccount___0 = (size_t )0;
#line 311
    needle_last_ccount = needle;
#line 315
    tmp___13 = needle;
#line 315
    needle ++;
#line 315
    b = (char )*tmp___13;
    {
#line 317
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 319
      if ((int const   )*haystack == 0) {
#line 321
        return ((char *)((void *)0));
      }
#line 325
      if (try_kmp___0) {
#line 325
        if (outer_loop_count___0 >= 10UL) {
#line 325
          if (comparison_count___0 >= 5UL * outer_loop_count___0) {
#line 331
            if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
              {
#line 333
              tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
#line 333
              needle_last_ccount += tmp___14;
              }
#line 336
              if ((int const   )*needle_last_ccount == 0) {
#line 337
                needle_last_ccount = (char const   *)((void *)0);
              }
#line 338
              last_ccount___0 = comparison_count___0;
            }
#line 340
            if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
              {
#line 344
              tmp___15 = strlen(needle - 1);
#line 344
              tmp___16 = knuth_morris_pratt((unsigned char const   *)haystack, (unsigned char const   *)(needle - 1),
                                            tmp___15, & result___0);
#line 344
              success___0 = tmp___16;
              }
#line 349
              if (success___0) {
#line 350
                return ((char *)result___0);
              }
#line 351
              try_kmp___0 = (_Bool)0;
            }
          }
        }
      }
#line 355
      outer_loop_count___0 ++;
#line 356
      comparison_count___0 ++;
#line 357
      if ((int const   )*haystack == (int const   )b) {
#line 360
        rhaystack___0 = haystack + 1;
#line 361
        rneedle___0 = needle;
        {
#line 363
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 365
          if ((int const   )*rneedle___0 == 0) {
#line 367
            return ((char *)haystack);
          }
#line 368
          if ((int const   )*rhaystack___0 == 0) {
#line 370
            return ((char *)((void *)0));
          }
#line 371
          comparison_count___0 ++;
#line 372
          if ((int const   )*rhaystack___0 != (int const   )*rneedle___0) {
#line 374
            goto while_break___3;
          }
#line 363
          rhaystack___0 ++;
#line 363
          rneedle___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 317
      haystack ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 380
    return ((char *)haystack);
  }
}
}
#line 28 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbslen.c"
size_t ( __attribute__((__nonnull__(1))) mbslen)(char const   *string ) 
{ 
  size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
  {
#line 31
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 31
  if (tmp___1 > 1UL) {
    {
#line 36
    count = (size_t )0;
#line 37
    iter.cur.ptr = string;
#line 37
    iter.in_shift = (_Bool)0;
#line 37
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 37
    iter.next_done = (_Bool)0;
    }
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 37
      mbuiter_multi_next(& iter);
      }
#line 37
      if (iter.cur.wc_valid) {
#line 37
        if (iter.cur.wc == 0) {
#line 37
          tmp = 0;
        } else {
#line 37
          tmp = 1;
        }
      } else {
#line 37
        tmp = 1;
      }
#line 37
      if (! tmp) {
#line 37
        goto while_break;
      }
#line 38
      count ++;
#line 37
      iter.cur.ptr += iter.cur.bytes;
#line 37
      iter.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
#line 40
    return (count);
  } else {
    {
#line 43
    tmp___0 = strlen(string);
    }
#line 43
    return (tmp___0);
  }
}
}
#line 1114 "./string.h"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 ) ;
#line 195 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) wint_t towlower(wint_t __wc ) ;
#line 36 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 ) 
{ 
  mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  size_t tmp___25 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;

  {
#line 39
  if ((unsigned long )s1 == (unsigned long )s2) {
#line 40
    return (0);
  }
  {
#line 45
  tmp___25 = __ctype_get_mb_cur_max();
  }
#line 45
  if (tmp___25 > 1UL) {
    {
#line 50
    iter1.cur.ptr = s1;
#line 50
    iter1.in_shift = (_Bool)0;
#line 50
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 50
    iter1.next_done = (_Bool)0;
#line 51
    iter2.cur.ptr = s2;
#line 51
    iter2.in_shift = (_Bool)0;
#line 51
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 51
    iter2.next_done = (_Bool)0;
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 53
      mbuiter_multi_next(& iter1);
      }
#line 53
      if (iter1.cur.wc_valid) {
#line 53
        if (iter1.cur.wc == 0) {
#line 53
          tmp___13 = 0;
        } else {
#line 53
          tmp___13 = 1;
        }
      } else {
#line 53
        tmp___13 = 1;
      }
#line 53
      if (tmp___13) {
        {
#line 53
        mbuiter_multi_next(& iter2);
        }
#line 53
        if (iter2.cur.wc_valid) {
#line 53
          if (iter2.cur.wc == 0) {
#line 53
            tmp___14 = 0;
          } else {
#line 53
            tmp___14 = 1;
          }
        } else {
#line 53
          tmp___14 = 1;
        }
#line 53
        if (! tmp___14) {
#line 53
          goto while_break;
        }
      } else {
#line 53
        goto while_break;
      }
#line 55
      if (iter1.cur.wc_valid) {
#line 55
        if (iter2.cur.wc_valid) {
          {
#line 55
          tmp = towlower((wint_t )iter1.cur.wc);
#line 55
          tmp___0 = towlower((wint_t )iter2.cur.wc);
#line 55
          tmp___1 = (int )tmp - (int )tmp___0;
          }
        } else {
#line 55
          tmp___1 = -1;
        }
#line 55
        tmp___12 = tmp___1;
      } else {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp___11 = 1;
        } else {
#line 55
          if (iter1.cur.bytes == iter2.cur.bytes) {
            {
#line 55
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
#line 55
            tmp___10 = tmp___2;
            }
          } else {
#line 55
            if (iter1.cur.bytes < iter2.cur.bytes) {
              {
#line 55
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
              }
#line 55
              if (tmp___5 > 0) {
#line 55
                tmp___4 = 1;
              } else {
#line 55
                tmp___4 = -1;
              }
#line 55
              tmp___9 = tmp___4;
            } else {
              {
#line 55
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
              }
#line 55
              if (tmp___8 >= 0) {
#line 55
                tmp___7 = 1;
              } else {
#line 55
                tmp___7 = -1;
              }
#line 55
              tmp___9 = tmp___7;
            }
#line 55
            tmp___10 = tmp___9;
          }
#line 55
          tmp___11 = tmp___10;
        }
#line 55
        tmp___12 = tmp___11;
      }
#line 55
      cmp = tmp___12;
#line 57
      if (cmp != 0) {
#line 58
        return (cmp);
      }
#line 60
      iter1.cur.ptr += iter1.cur.bytes;
#line 60
      iter1.next_done = (_Bool)0;
#line 61
      iter2.cur.ptr += iter2.cur.bytes;
#line 61
      iter2.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 63
    mbuiter_multi_next(& iter1);
    }
#line 63
    if (iter1.cur.wc_valid) {
#line 63
      if (iter1.cur.wc == 0) {
#line 63
        tmp___15 = 0;
      } else {
#line 63
        tmp___15 = 1;
      }
    } else {
#line 63
      tmp___15 = 1;
    }
#line 63
    if (tmp___15) {
#line 65
      return (1);
    }
    {
#line 66
    mbuiter_multi_next(& iter2);
    }
#line 66
    if (iter2.cur.wc_valid) {
#line 66
      if (iter2.cur.wc == 0) {
#line 66
        tmp___16 = 0;
      } else {
#line 66
        tmp___16 = 1;
      }
    } else {
#line 66
      tmp___16 = 1;
    }
#line 66
    if (tmp___16) {
#line 68
      return (-1);
    }
#line 69
    return (0);
  } else {
#line 73
    p1 = (unsigned char const   *)s1;
#line 74
    p2 = (unsigned char const   *)s2;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___19 = __ctype_b_loc();
      }
#line 79
      if ((int const   )*(*tmp___19 + (int )*p1) & 256) {
        {
#line 79
        tmp___18 = tolower((int )*p1);
#line 79
        c1 = (unsigned char )tmp___18;
        }
      } else {
#line 79
        c1 = (unsigned char )*p1;
      }
      {
#line 80
      tmp___22 = __ctype_b_loc();
      }
#line 80
      if ((int const   )*(*tmp___22 + (int )*p2) & 256) {
        {
#line 80
        tmp___21 = tolower((int )*p2);
#line 80
        c2 = (unsigned char )tmp___21;
        }
      } else {
#line 80
        c2 = (unsigned char )*p2;
      }
#line 82
      if ((int )c1 == 0) {
#line 83
        goto while_break___0;
      }
#line 85
      p1 ++;
#line 86
      p2 ++;
#line 77
      if (! ((int )c1 == (int )c2)) {
#line 77
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    return ((int )c1 - (int )c2);
  }
}
}
#line 26 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/mbchar.c"
unsigned int const   is_basic_table[8]  = {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646};
#line 64 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 68 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  char *p ;
  void *tmp ;
  size_t slot ;

  {
#line 74
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 76
  if (nplus >= n) {
    {
#line 78
    tmp = malloc(nplus);
#line 78
    p = (char *)tmp;
    }
#line 80
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 84
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 87
      *((int *)p + -1) = 336984906;
#line 90
      slot = (unsigned long )p % 257UL;
#line 91
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
#line 92
      mmalloca_results[slot] = (void *)p;
#line 94
      return ((void *)p);
    }
  }
#line 98
  return ((void *)0);
}
}
#line 109 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  char *p_begin ;

  {
#line 113
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 119
    if (*((int *)p + -1) == 336984906) {
#line 123
      slot = (unsigned long )p % 257UL;
#line 124
      chain = & mmalloca_results[slot];
      {
#line 125
      while (1) {
        while_continue: /* CIL Label */ ;
#line 125
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 125
          goto while_break;
        }
#line 127
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 130
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 131
          *chain = ((struct header *)p_begin)->next;
#line 132
          free((void *)p_begin);
          }
#line 133
          return;
        }
#line 135
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 140
  return;
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 532
extern int getc_unlocked(FILE *__stream ) ;
#line 675
extern int ungetc(int __c , FILE *__stream ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 584 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 117 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 120 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 125
  cp = (char const   *)charset_aliases;
#line 126
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 130
    base = "charset.alias";
#line 135
    tmp = getenv("CHARSETALIASDIR");
#line 135
    dir = (char const   *)tmp;
    }
#line 136
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 137
      dir = "/usr/local/lib";
    } else
#line 136
    if ((int const   )*(dir + 0) == 0) {
#line 137
      dir = "/usr/local/lib";
    }
    {
#line 141
    tmp___0 = strlen(dir);
#line 141
    dir_len___0 = tmp___0;
#line 142
    tmp___1 = strlen(base);
#line 142
    base_len___0 = tmp___1;
    }
#line 143
    if (dir_len___0 > 0UL) {
#line 143
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 143
        tmp___2 = 1;
      } else {
#line 143
        tmp___2 = 0;
      }
    } else {
#line 143
      tmp___2 = 0;
    }
    {
#line 143
    add_slash = tmp___2;
#line 144
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 144
    file_name = (char *)tmp___3;
    }
#line 145
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 147
      memcpy((void */* __restrict  */)file_name, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 148
      if (add_slash) {
#line 149
        *(file_name + dir_len___0) = (char )'/';
      }
      {
#line 150
      memcpy((void */* __restrict  */)((file_name + dir_len___0) + add_slash), (void const   */* __restrict  */)base,
             base_len___0 + 1UL);
      }
    }
#line 154
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 156
      cp = "";
    } else {
      {
#line 168
      fd = open((char const   *)file_name, 131072);
      }
#line 170
      if (fd < 0) {
#line 172
        cp = "";
      } else {
        {
#line 177
        fp = fdopen(fd, "r");
        }
#line 178
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 181
          close(fd);
#line 182
          cp = "";
          }
        } else {
#line 187
          res_ptr = (char *)((void *)0);
#line 188
          res_size = (size_t )0;
          {
#line 190
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 198
            c = getc_unlocked(fp);
            }
#line 199
            if (c == -1) {
#line 200
              goto while_break;
            }
#line 201
            if (c == 10) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 32) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 9) {
#line 202
              goto __Cont;
            }
#line 203
            if (c == 35) {
              {
#line 206
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 207
                c = getc_unlocked(fp);
                }
#line 206
                if (c == -1) {
#line 206
                  goto while_break___0;
                } else
#line 206
                if (c == 10) {
#line 206
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 209
              if (c == -1) {
#line 210
                goto while_break;
              }
#line 211
              goto __Cont;
            }
            {
#line 213
            ungetc(c, fp);
#line 214
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 214
            if (tmp___4 < 2) {
#line 215
              goto while_break;
            }
            {
#line 216
            l1 = strlen((char const   *)(buf1));
#line 217
            l2 = strlen((char const   *)(buf2));
#line 218
            old_res_ptr = res_ptr;
            }
#line 219
            if (res_size == 0UL) {
              {
#line 221
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 222
              tmp___5 = malloc(res_size + 1UL);
#line 222
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 226
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 227
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 227
              res_ptr = (char *)tmp___6;
              }
            }
#line 229
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 232
              res_size = (size_t )0;
#line 233
              free((void *)old_res_ptr);
              }
#line 234
              goto while_break;
            }
            {
#line 236
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 237
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 239
          fclose(fp);
          }
#line 240
          if (res_size == 0UL) {
#line 241
            cp = "";
          } else {
#line 244
            *(res_ptr + res_size) = (char )'\000';
#line 245
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 250
      free((void *)file_name);
      }
    }
#line 344
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 347
  return (cp);
}
}
#line 359 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 370
  tmp = nl_langinfo(14);
#line 370
  codeset = (char const   *)tmp;
  }
#line 527
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 529
    codeset = "";
  }
  {
#line 532
  aliases = get_charset_aliases();
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((int const   )*aliases != 0)) {
#line 532
      goto while_break;
    }
    {
#line 535
    tmp___3 = strcmp(codeset, aliases);
    }
#line 535
    if (tmp___3 == 0) {
      {
#line 538
      tmp___2 = strlen(aliases);
#line 538
      codeset = (aliases + tmp___2) + 1;
      }
#line 539
      goto while_break;
    } else
#line 535
    if ((int const   )*(aliases + 0) == 42) {
#line 535
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 538
        tmp___2 = strlen(aliases);
#line 538
        codeset = (aliases + tmp___2) + 1;
        }
#line 539
        goto while_break;
      }
    }
    {
#line 532
    tmp___0 = strlen(aliases);
#line 532
    aliases += tmp___0 + 1UL;
#line 532
    tmp___1 = strlen(aliases);
#line 532
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  if ((int const   )*(codeset + 0) == 0) {
#line 546
    codeset = "ASCII";
  }
#line 548
  return (codeset);
}
}
#line 22 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 43 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) inttostr)(int i , char *buf___0 ) ;
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/anytostr.c"
char *( __attribute__((__warn_unused_result__)) inttostr)(int i , char *buf___0 ) 
{ 
  char *p ;

  {
#line 36
  p = buf___0 + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48 - i % 10);
#line 41
      i /= 10;
#line 41
      if (! (i != 0)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      p --;
#line 50
      *p = (char )(48 + i % 10);
#line 49
      i /= 10;
#line 49
      if (! (i != 0)) {
#line 49
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 54
  return (p);
}
}
#line 22
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 42 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___0 ) ;
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/anytostr.c"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___0 ) 
{ 
  char *p ;

  {
#line 36
  p = buf___0 + (((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
#line 37
  *p = (char)0;
#line 39
  if (i < 0L) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48L - i % 10L);
#line 41
      i /= 10L;
#line 41
      if (! (i != 0L)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      p --;
#line 50
      *p = (char )(48L + i % 10L);
#line 49
      i /= 10L;
#line 49
      if (! (i != 0L)) {
#line 49
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 54
  return (p);
}
}
#line 62 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table ) ;
#line 63
size_t hash_get_n_buckets_used(Hash_table const   *table ) ;
#line 64
size_t hash_get_n_entries(Hash_table const   *table ) ;
#line 65
size_t hash_get_max_bucket_length(Hash_table const   *table ) ;
#line 66
_Bool hash_table_ok(Hash_table const   *table ) ;
#line 67
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 68
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 71
void *hash_get_first(Hash_table const   *table ) ;
#line 72
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 73
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) ;
#line 74
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 77
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 78
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 79
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 82
void hash_clear(Hash_table *table ) ;
#line 83
void hash_free(Hash_table *table ) ;
#line 86
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 87
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) ;
#line 88
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 90
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 76 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/bitrotate.h"
__inline static size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 79
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 130 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 149 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 152
  return ((size_t )table->n_buckets);
}
}
#line 157 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 160
  return ((size_t )table->n_buckets_used);
}
}
#line 165 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 168
  return ((size_t )table->n_entries);
}
}
#line 173 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 179
      goto while_break;
    }
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        cursor = (struct hash_entry  const  *)cursor->next;
#line 186
        if (! cursor) {
#line 186
          goto while_break___0;
        }
#line 187
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
#line 179
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (max_bucket_length);
}
}
#line 200 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 207
      goto while_break;
    }
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        cursor = (struct hash_entry  const  *)cursor->next;
#line 218
        if (! cursor) {
#line 218
          goto while_break___0;
        }
#line 219
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 207
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 223
    if (n_entries == (size_t )table->n_entries) {
#line 224
      return ((_Bool)1);
    }
  }
#line 226
  return ((_Bool)0);
}
}
#line 229 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 232
  tmp = hash_get_n_entries(table);
#line 232
  n_entries = tmp;
#line 233
  tmp___0 = hash_get_n_buckets(table);
#line 233
  n_buckets = tmp___0;
#line 234
  tmp___1 = hash_get_n_buckets_used(table);
#line 234
  n_buckets_used = tmp___1;
#line 235
  tmp___2 = hash_get_max_bucket_length(table);
#line 235
  max_bucket_length = tmp___2;
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          n_entries);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          n_buckets);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 242
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          max_bucket_length);
  }
#line 244
  return;
}
}
#line 248 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static struct hash_entry *safe_hasher(Hash_table const   *table , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 260 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 263
  tmp = safe_hasher(table, entry);
#line 263
  bucket = (struct hash_entry  const  *)tmp;
  }
#line 266
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! cursor) {
#line 269
      goto while_break;
    }
#line 270
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 271
      return ((void *)cursor->data);
    } else {
      {
#line 270
      tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
      }
#line 270
      if (tmp___0) {
#line 271
        return ((void *)cursor->data);
      }
    }
#line 269
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return ((void *)0);
}
}
#line 287 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 292
  if (table->n_entries == 0UL) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 297
      abort();
      }
    } else
#line 298
    if (bucket->data) {
#line 299
      return ((void *)bucket->data);
    }
#line 295
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 306 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 309
  tmp = safe_hasher(table, entry);
#line 309
  bucket = (struct hash_entry  const  *)tmp;
#line 313
  cursor = bucket;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = (struct hash_entry  const  *)cursor->next;
#line 314
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    bucket ++;
#line 323
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 323
      goto while_break___0;
    }
#line 324
    if (bucket->data) {
#line 325
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return ((void *)0);
}
}
#line 335 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 343
      goto while_break;
    }
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! cursor) {
#line 347
          goto while_break___0;
        }
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        tmp = counter;
#line 351
        counter ++;
#line 351
        *(buffer + tmp) = (void *)cursor->data;
#line 347
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 343
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (counter);
}
}
#line 367 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 375
      goto while_break;
    }
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! cursor) {
#line 379
          goto while_break___0;
        }
        {
#line 381
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 381
        if (! tmp) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
#line 379
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 375
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (counter);
}
}
#line 427 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value___0 ;
  unsigned char ch ;

  {
#line 430
  value___0 = (size_t )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    ch = (unsigned char )*string;
#line 433
    if (! ch) {
#line 433
      goto while_break;
    }
#line 434
    value___0 = (value___0 * 31UL + (size_t )ch) % n_buckets;
#line 433
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (value___0);
}
}
#line 443 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 478 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 481
  *tuning = (Hash_tuning )default_tuning;
#line 482
  return;
}
}
#line 485 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val = tmp;
  }
#line 494
  return (val % n);
}
}
#line 498 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static size_t compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime(candidate);
  }
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = -1;
  } else {
#line 554
    tmp = -2;
  }
#line 554
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t )0);
  }
#line 556
  return (candidate);
}
}
#line 593 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;

  {
#line 600
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 601
    hasher = & raw_hasher;
  }
#line 602
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 603
    comparator = & raw_comparator;
  }
  {
#line 605
  tmp = malloc(sizeof(*table));
#line 605
  table = (Hash_table *)tmp;
  }
#line 606
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
  {
#line 611
  table->tuning = tuning;
#line 612
  tmp___0 = check_tuning(table);
  }
#line 612
  if (! tmp___0) {
#line 619
    goto fail;
  }
  {
#line 622
  table->n_buckets = compute_bucket_size(candidate, tuning);
  }
#line 623
  if (! table->n_buckets) {
#line 624
    goto fail;
  }
  {
#line 626
  tmp___1 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 626
  table->bucket = (struct hash_entry *)tmp___1;
  }
#line 627
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 630
  table->n_buckets_used = (size_t )0;
#line 631
  table->n_entries = (size_t )0;
#line 633
  table->hasher = hasher;
#line 634
  table->comparator = comparator;
#line 635
  table->data_freer = data_freer;
#line 637
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table);
  fail: 
  {
#line 644
  free((void *)table);
  }
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 652 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table->bucket;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 657
      goto while_break;
    }
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
      {
#line 665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 665
        if (! cursor) {
#line 665
          goto while_break___0;
        }
#line 667
        if (table->data_freer) {
          {
#line 668
          (*(table->data_freer))(cursor->data);
          }
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table->free_entry_list;
#line 675
        table->free_entry_list = cursor;
#line 665
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 679
      if (table->data_freer) {
        {
#line 680
        (*(table->data_freer))(bucket->data);
        }
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 657
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  table->n_buckets_used = (size_t )0;
#line 687
  table->n_entries = (size_t )0;
#line 688
  return;
}
}
#line 695 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table->data_freer) {
#line 703
    if (table->n_entries) {
#line 705
      bucket = table->bucket;
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 705
          goto while_break;
        }
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
          {
#line 709
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 709
            if (! cursor) {
#line 709
              goto while_break___0;
            }
            {
#line 710
            (*(table->data_freer))(cursor->data);
#line 709
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 705
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 722
  bucket = table->bucket;
  {
#line 722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 722
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 722
      goto while_break___1;
    }
#line 724
    cursor = bucket->next;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! cursor) {
#line 724
        goto while_break___2;
      }
      {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
#line 724
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 722
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  cursor = table->free_entry_list;
  {
#line 732
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 732
    if (! cursor) {
#line 732
      goto while_break___3;
    }
    {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
#line 732
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 741
  free((void *)table->bucket);
#line 742
  free((void *)table);
  }
#line 743
  return;
}
}
#line 750 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 778
  entry->data = (void *)0;
#line 779
  entry->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry;
#line 781
  return;
}
}
#line 789 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher((Hash_table const   *)table, entry);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 942 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  void *__cil_tmp11 ;

  {
  {
#line 947
  tmp = compute_bucket_size(candidate, table->tuning);
#line 947
  new_size = tmp;
  }
#line 949
  if (! new_size) {
#line 950
    return ((_Bool)0);
  }
#line 951
  if (new_size == table->n_buckets) {
#line 952
    return ((_Bool)1);
  }
  {
#line 953
  new_table = & storage;
#line 954
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 955
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 956
    return ((_Bool)0);
  }
  {
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table->tuning;
#line 962
  new_table->hasher = table->hasher;
#line 963
  new_table->comparator = table->comparator;
#line 964
  new_table->data_freer = table->data_freer;
#line 984
  new_table->free_entry_list = table->free_entry_list;
#line 986
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
  }
#line 986
  if (tmp___1) {
    {
#line 989
    free((void *)table->bucket);
#line 990
    table->bucket = new_table->bucket;
#line 991
    table->bucket_limit = new_table->bucket_limit;
#line 992
    table->n_buckets = new_table->n_buckets;
#line 993
    table->n_buckets_used = new_table->n_buckets_used;
#line 994
    table->free_entry_list = new_table->free_entry_list;
    }
#line 996
    return ((_Bool)1);
  }
  {
#line 1012
  table->free_entry_list = new_table->free_entry_list;
#line 1013
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
  }
#line 1013
  if (tmp___2) {
    {
#line 1013
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
    }
#line 1013
    if (! tmp___3) {
      {
#line 1015
      abort();
      }
    }
  } else {
    {
#line 1015
    abort();
    }
  }
  {
#line 1017
  free((void *)new_table->bucket);
  }
#line 1018
  return ((_Bool)0);
}
}
#line 1035 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1044
  if (! entry) {
    {
#line 1045
    abort();
    }
  }
  {
#line 1048
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 1048
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1050
    if (matched_ent) {
#line 1051
      *matched_ent = (void const   *)data;
    }
#line 1052
    return (0);
  }
#line 1060
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 1065
    check_tuning(table);
    }
#line 1066
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1069
      tuning = table->tuning;
#line 1070
      if (tuning->is_n_buckets) {
#line 1070
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1070
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1070
      candidate = (float )tmp;
#line 1076
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1077
        return (-1);
      }
      {
#line 1080
      tmp___0 = hash_rehash(table, (size_t )candidate);
      }
#line 1080
      if (! tmp___0) {
#line 1081
        return (-1);
      }
      {
#line 1084
      tmp___1 = hash_find_entry(table, entry, & bucket, (_Bool)0);
      }
#line 1084
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1085
        abort();
        }
      }
    }
  }
#line 1091
  if (bucket->data) {
    {
#line 1093
    tmp___2 = allocate_entry(table);
#line 1093
    new_entry = tmp___2;
    }
#line 1095
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1096
      return (-1);
    }
#line 1100
    new_entry->data = (void *)entry;
#line 1101
    new_entry->next = bucket->next;
#line 1102
    bucket->next = new_entry;
#line 1103
    (table->n_entries) ++;
#line 1104
    return (1);
  }
#line 1109
  bucket->data = (void *)entry;
#line 1110
  (table->n_entries) ++;
#line 1111
  (table->n_buckets_used) ++;
#line 1113
  return (1);
}
}
#line 1122 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) 
{ 
  void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1126
  tmp = hash_insert0(table, entry, & matched_ent);
#line 1126
  err = tmp;
  }
#line 1127
  if (err == -1) {
#line 1127
    tmp___1 = (void *)0;
  } else {
#line 1127
    if (err == 0) {
#line 1127
      tmp___0 = matched_ent;
    } else {
#line 1127
      tmp___0 = entry;
    }
#line 1127
    tmp___1 = (void *)tmp___0;
  }
#line 1127
  return (tmp___1);
}
}
#line 1136 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1142
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 1143
  if (! data) {
#line 1144
    return ((void *)0);
  }
#line 1146
  (table->n_entries) --;
#line 1147
  if (! bucket->data) {
#line 1149
    (table->n_buckets_used) --;
#line 1154
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1159
      check_tuning(table);
      }
#line 1160
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1163
        tuning = table->tuning;
#line 1164
        if (tuning->is_n_buckets) {
#line 1164
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1164
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1164
        candidate = (size_t )tmp;
#line 1170
        tmp___0 = hash_rehash(table, candidate);
        }
#line 1170
        if (! tmp___0) {
#line 1178
          cursor = table->free_entry_list;
          {
#line 1180
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1180
            if (! cursor) {
#line 1180
              goto while_break;
            }
            {
#line 1182
            next = cursor->next;
#line 1183
            free((void *)cursor);
#line 1184
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1186
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1193
  return (data);
}
}
#line 23 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hard-locale.h"
_Bool hard_locale(int category ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 37 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/hard-locale.c"
_Bool hard_locale(int category ) 
{ 
  _Bool hard ;
  char const   *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *locale ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 40
  hard = (_Bool)1;
#line 41
  tmp = setlocale(category, (char const   *)((void *)0));
#line 41
  p = (char const   *)tmp;
  }
#line 43
  if (p) {
#line 45
    if (1) {
      {
#line 47
      tmp___0 = strcmp(p, "C");
      }
#line 47
      if (tmp___0 == 0) {
#line 48
        hard = (_Bool)0;
      } else {
        {
#line 47
        tmp___1 = strcmp(p, "POSIX");
        }
#line 47
        if (tmp___1 == 0) {
#line 48
          hard = (_Bool)0;
        }
      }
    } else {
      {
#line 52
      tmp___2 = strdup(p);
#line 52
      locale = tmp___2;
      }
#line 53
      if (locale) {
        {
#line 58
        tmp___3 = setlocale(category, "C");
#line 58
        p = (char const   *)tmp___3;
        }
#line 58
        if (p) {
          {
#line 58
          tmp___4 = strcmp(p, (char const   *)locale);
          }
#line 58
          if (tmp___4 == 0) {
#line 62
            hard = (_Bool)0;
          } else {
#line 58
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 58
          tmp___5 = setlocale(category, "POSIX");
#line 58
          p = (char const   *)tmp___5;
          }
#line 58
          if (p) {
            {
#line 58
            tmp___6 = strcmp(p, (char const   *)locale);
            }
#line 58
            if (tmp___6 == 0) {
#line 62
              hard = (_Bool)0;
            }
          }
        }
        {
#line 65
        setlocale(category, (char const   *)locale);
#line 66
        free((void *)locale);
        }
      }
    }
  }
#line 71
  return (hard);
}
}
#line 336 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 79 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/timespec.h"
void gettime(struct timespec *ts ) ;
#line 28 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/gettime.c"
void gettime(struct timespec *ts ) 
{ 
  int tmp ;
  struct timeval tv ;
  void *__cil_tmp4 ;

  {
  {
#line 36
  tmp = clock_gettime(0, ts);
  }
#line 36
  if (tmp == 0) {
#line 37
    return;
  }
  {
#line 42
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 43
  ts->tv_sec = tv.tv_sec;
#line 44
  ts->tv_nsec = tv.tv_usec * 1000L;
  }
#line 48
  return;
}
}
#line 245 "./getopt.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc ,
                                                                                       char **argv ,
                                                                                       char const   *options ,
                                                                                       struct rpl_option  const  *long_options ,
                                                                                       int *opt_index ) ;
#line 249
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc ,
                                                                                            char **argv ,
                                                                                            char const   *options ,
                                                                                            struct rpl_option  const  *long_options ,
                                                                                            int *opt_index ) ;
#line 24 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt_int.h"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts___0 ,
                        int *longind , int long_only , int posixly_correct___0 ) ;
#line 118
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts___0 ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct___0 ) ;
#line 124
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 129
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 39 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt1.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc ,
                                                                                       char **argv ,
                                                                                       char const   *options ,
                                                                                       struct rpl_option  const  *long_options ,
                                                                                       int *opt_index ) ;
#line 39 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt1.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long)(int argc , char **argv ,
                                                         char const   *options , struct rpl_option  const  *long_options ,
                                                         int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = rpl_getopt_internal(argc, argv, options, long_options, opt_index, 0, 0);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt1.c"
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 52
  tmp = _getopt_internal_r(argc, argv, options, long_options, opt_index, 0, d, 0);
  }
#line 52
  return (tmp);
}
}
#line 61
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc ,
                                                                                            char **argv ,
                                                                                            char const   *options ,
                                                                                            struct rpl_option  const  *long_options ,
                                                                                            int *opt_index ) ;
#line 61 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt1.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt_long_only)(int argc , char **argv ,
                                                              char const   *options ,
                                                              struct rpl_option  const  *long_options ,
                                                              int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 66
  tmp = rpl_getopt_internal(argc, argv, options, long_options, opt_index, 1, 0);
  }
#line 66
  return (tmp);
}
}
#line 70 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt1.c"
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 75
  tmp = _getopt_internal_r(argc, argv, options, long_options, opt_index, 1, d, 0);
  }
#line 75
  return (tmp);
}
}
#line 148 "./getopt.h"
char *rpl_optarg  ;
#line 162
int rpl_optind ;
#line 167
int rpl_opterr ;
#line 171
int rpl_optopt ;
#line 241
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc ,
                                                                                  char * const  *argv ,
                                                                                  char const   *optstring ) ;
#line 555 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 82 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
int rpl_optind  =    1;
#line 87 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
int rpl_opterr  =    1;
#line 93 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
int rpl_optopt  =    '?';
#line 97 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
static struct _getopt_data getopt_data  ;
#line 143 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ 
  int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
#line 146
  bottom = d->__first_nonopt;
#line 147
  middle = d->__last_nonopt;
#line 148
  top = d->rpl_optind;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (top > middle) {
#line 178
      if (! (middle > bottom)) {
#line 178
        goto while_break;
      }
    } else {
#line 178
      goto while_break;
    }
#line 180
    if (top - middle > middle - bottom) {
#line 183
      len = middle - bottom;
#line 187
      i = 0;
      {
#line 187
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 187
        if (! (i < len)) {
#line 187
          goto while_break___0;
        }
#line 189
        tem = *(argv + (bottom + i));
#line 190
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
#line 191
        *(argv + ((top - (middle - bottom)) + i)) = tem;
#line 187
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 195
      top -= len;
    } else {
#line 200
      len___0 = top - middle;
#line 204
      i___0 = 0;
      {
#line 204
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 204
        if (! (i___0 < len___0)) {
#line 204
          goto while_break___1;
        }
#line 206
        tem = *(argv + (bottom + i___0));
#line 207
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
#line 208
        *(argv + (middle + i___0)) = tem;
#line 204
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 212
      bottom += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
#line 219
  d->__last_nonopt = d->rpl_optind;
#line 220
  return;
}
}
#line 224 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
static char const   *_getopt_initialize(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                                        char const   *optstring , struct _getopt_data *d ,
                                        int posixly_correct___0 ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 233
  tmp = d->rpl_optind;
#line 233
  d->__last_nonopt = tmp;
#line 233
  d->__first_nonopt = tmp;
#line 235
  d->__nextchar = (char *)((void *)0);
#line 237
  if (posixly_correct___0) {
#line 237
    tmp___1 = 1;
  } else {
    {
#line 237
    tmp___0 = getenv("POSIXLY_CORRECT");
    }
#line 237
    if (tmp___0) {
#line 237
      tmp___1 = 1;
    } else {
#line 237
      tmp___1 = 0;
    }
  }
#line 237
  d->__posixly_correct = tmp___1;
#line 241
  if ((int const   )*(optstring + 0) == 45) {
#line 243
    d->__ordering = (enum __ord )2;
#line 244
    optstring ++;
  } else
#line 246
  if ((int const   )*(optstring + 0) == 43) {
#line 248
    d->__ordering = (enum __ord )0;
#line 249
    optstring ++;
  } else
#line 251
  if (d->__posixly_correct) {
#line 252
    d->__ordering = (enum __ord )0;
  } else {
#line 254
    d->__ordering = (enum __ord )1;
  }
#line 286
  return (optstring);
}
}
#line 345 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts___0 ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct___0 ) 
{ 
  int print_errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *nameend ;
  unsigned int namelen ;
  struct rpl_option  const  *p ;
  struct rpl_option  const  *pfound ;
  struct option_list *ambig_list ;
  int exact ;
  int indfound ;
  int option_index ;
  struct option_list *newp ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  struct option_list first ;
  char *tmp___5 ;
  size_t tmp___6 ;
  struct option_list *pn ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char c ;
  char *tmp___19 ;
  char const   *temp ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *nameend___0 ;
  struct rpl_option  const  *p___0 ;
  struct rpl_option  const  *pfound___0 ;
  int exact___0 ;
  int ambig ;
  int indfound___0 ;
  int option_index___0 ;
  char *tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  char *tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  void *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;

  {
#line 350
  print_errors = d->rpl_opterr;
#line 352
  if (argc < 1) {
#line 353
    return (-1);
  }
#line 355
  d->rpl_optarg = (char *)((void *)0);
#line 357
  if (d->rpl_optind == 0) {
#line 357
    goto _L;
  } else
#line 357
  if (! d->__initialized) {
    _L: /* CIL Label */ 
#line 359
    if (d->rpl_optind == 0) {
#line 360
      d->rpl_optind = 1;
    }
    {
#line 361
    optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct___0);
#line 363
    d->__initialized = 1;
    }
  } else
#line 365
  if ((int const   )*(optstring + 0) == 45) {
#line 366
    optstring ++;
  } else
#line 365
  if ((int const   )*(optstring + 0) == 43) {
#line 366
    optstring ++;
  }
#line 367
  if ((int const   )*(optstring + 0) == 58) {
#line 368
    print_errors = 0;
  }
#line 382
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
#line 382
    goto _L___3;
  } else
#line 382
  if ((int )*(d->__nextchar) == 0) {
    _L___3: /* CIL Label */ 
#line 388
    if (d->__last_nonopt > d->rpl_optind) {
#line 389
      d->__last_nonopt = d->rpl_optind;
    }
#line 390
    if (d->__first_nonopt > d->rpl_optind) {
#line 391
      d->__first_nonopt = d->rpl_optind;
    }
#line 393
    if ((unsigned int )d->__ordering == 1U) {
#line 398
      if (d->__first_nonopt != d->__last_nonopt) {
#line 398
        if (d->__last_nonopt != d->rpl_optind) {
          {
#line 400
          exchange(argv, d);
          }
        } else {
#line 398
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 401
      if (d->__last_nonopt != d->rpl_optind) {
#line 402
        d->__first_nonopt = d->rpl_optind;
      }
      {
#line 407
      while (1) {
        while_continue: /* CIL Label */ ;
#line 407
        if (d->rpl_optind < argc) {
#line 407
          if (! ((int )*(*(argv + d->rpl_optind) + 0) != 45)) {
#line 407
            if (! ((int )*(*(argv + d->rpl_optind) + 1) == 0)) {
#line 407
              goto while_break;
            }
          }
        } else {
#line 407
          goto while_break;
        }
#line 408
        (d->rpl_optind) ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 409
      d->__last_nonopt = d->rpl_optind;
    }
#line 417
    if (d->rpl_optind != argc) {
      {
#line 417
      tmp = strcmp((char const   *)*(argv + d->rpl_optind), "--");
      }
#line 417
      if (! tmp) {
#line 419
        (d->rpl_optind) ++;
#line 421
        if (d->__first_nonopt != d->__last_nonopt) {
#line 421
          if (d->__last_nonopt != d->rpl_optind) {
            {
#line 423
            exchange(argv, d);
            }
          } else {
#line 421
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 424
        if (d->__first_nonopt == d->__last_nonopt) {
#line 425
          d->__first_nonopt = d->rpl_optind;
        }
#line 426
        d->__last_nonopt = argc;
#line 428
        d->rpl_optind = argc;
      }
    }
#line 434
    if (d->rpl_optind == argc) {
#line 438
      if (d->__first_nonopt != d->__last_nonopt) {
#line 439
        d->rpl_optind = d->__first_nonopt;
      }
#line 440
      return (-1);
    }
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
#line 446
      goto _L___2;
    } else
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
      _L___2: /* CIL Label */ 
#line 448
      if ((unsigned int )d->__ordering == 0U) {
#line 449
        return (-1);
      }
#line 450
      tmp___0 = d->rpl_optind;
#line 450
      (d->rpl_optind) ++;
#line 450
      d->rpl_optarg = *(argv + tmp___0);
#line 451
      return (1);
    }
#line 457
    if ((unsigned long )longopts___0 != (unsigned long )((void *)0)) {
#line 457
      if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 457
        tmp___1 = 1;
      } else {
#line 457
        tmp___1 = 0;
      }
    } else {
#line 457
      tmp___1 = 0;
    }
#line 457
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + tmp___1;
  }
#line 476
  if ((unsigned long )longopts___0 != (unsigned long )((void *)0)) {
#line 476
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 476
      goto _L___6;
    } else
#line 476
    if (long_only) {
#line 476
      if (*(*(argv + d->rpl_optind) + 2)) {
#line 476
        goto _L___6;
      } else {
        {
#line 476
        tmp___18 = strchr(optstring, (int )*(*(argv + d->rpl_optind) + 1));
        }
#line 476
        if (! tmp___18) {
          _L___6: /* CIL Label */ 
#line 484
          pfound = (struct rpl_option  const  *)((void *)0);
#line 485
          ambig_list = (struct option_list *)((void *)0);
#line 490
          exact = 0;
#line 491
          indfound = -1;
#line 494
          nameend = d->__nextchar;
          {
#line 494
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 494
            if (*nameend) {
#line 494
              if (! ((int )*nameend != 61)) {
#line 494
                goto while_break___0;
              }
            } else {
#line 494
              goto while_break___0;
            }
#line 494
            nameend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 496
          namelen = (unsigned int )(nameend - d->__nextchar);
#line 500
          p = longopts___0;
#line 500
          option_index = 0;
          {
#line 500
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 500
            if (! p->name) {
#line 500
              goto while_break___1;
            }
            {
#line 501
            tmp___4 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                              (size_t )namelen);
            }
#line 501
            if (! tmp___4) {
              {
#line 503
              tmp___3 = strlen((char const   *)p->name);
              }
#line 503
              if (namelen == (unsigned int )tmp___3) {
#line 506
                pfound = p;
#line 507
                indfound = option_index;
#line 508
                exact = 1;
#line 509
                goto while_break___1;
              } else
#line 511
              if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 514
                pfound = p;
#line 515
                indfound = option_index;
              } else
#line 517
              if (long_only) {
                {
#line 523
                tmp___2 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___2;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
                }
              } else
#line 517
              if (pfound->has_arg != p->has_arg) {
                {
#line 523
                tmp___2 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___2;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
                }
              } else
#line 517
              if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
                {
#line 523
                tmp___2 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___2;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
                }
              } else
#line 517
              if (pfound->val != p->val) {
                {
#line 523
                tmp___2 = malloc(sizeof(*newp));
#line 523
                newp = (struct option_list *)tmp___2;
#line 524
                newp->p = p;
#line 525
                newp->next = ambig_list;
#line 526
                ambig_list = newp;
                }
              }
            }
#line 500
            p ++;
#line 500
            option_index ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 530
          if ((unsigned long )ambig_list != (unsigned long )((void *)0)) {
#line 530
            if (! exact) {
#line 532
              if (print_errors) {
                {
#line 535
                first.p = pfound;
#line 536
                first.next = ambig_list;
#line 537
                ambig_list = & first;
#line 575
                tmp___5 = gettext("%s: option \'%s\' is ambiguous; possibilities:");
#line 575
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                        *(argv + 0), *(argv + d->rpl_optind));
                }
                {
#line 578
                while (1) {
                  while_continue___2: /* CIL Label */ ;
                  {
#line 580
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" \'--%s\'",
                          (ambig_list->p)->name);
#line 581
                  ambig_list = ambig_list->next;
                  }
#line 578
                  if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 578
                    goto while_break___2;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
                {
#line 585
                fputc('\n', stderr);
                }
              }
              {
#line 588
              tmp___6 = strlen((char const   *)d->__nextchar);
#line 588
              d->__nextchar += tmp___6;
#line 589
              (d->rpl_optind) ++;
#line 590
              d->rpl_optopt = 0;
              }
#line 591
              return ('?');
            }
          }
          {
#line 594
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 594
            if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 594
              goto while_break___3;
            }
            {
#line 596
            pn = ambig_list->next;
#line 597
            free((void *)ambig_list);
#line 598
            ambig_list = pn;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 601
          if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 603
            option_index = indfound;
#line 604
            (d->rpl_optind) ++;
#line 605
            if (*nameend) {
#line 609
              if (pfound->has_arg) {
#line 610
                d->rpl_optarg = nameend + 1;
              } else {
#line 613
                if (print_errors) {
#line 620
                  if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
                    {
#line 628
                    tmp___7 = gettext("%s: option \'--%s\' doesn\'t allow an argument\n");
#line 628
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
                            *(argv + 0), pfound->name);
                    }
                  } else {
                    {
#line 642
                    tmp___8 = gettext("%s: option \'%c%s\' doesn\'t allow an argument\n");
#line 642
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
                            *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                            pfound->name);
                    }
                  }
                }
                {
#line 668
                tmp___9 = strlen((char const   *)d->__nextchar);
#line 668
                d->__nextchar += tmp___9;
#line 670
                d->rpl_optopt = (int )pfound->val;
                }
#line 671
                return ('?');
              }
            } else
#line 674
            if (pfound->has_arg == 1) {
#line 676
              if (d->rpl_optind < argc) {
#line 677
                tmp___10 = d->rpl_optind;
#line 677
                (d->rpl_optind) ++;
#line 677
                d->rpl_optarg = *(argv + tmp___10);
              } else {
#line 680
                if (print_errors) {
                  {
#line 703
                  tmp___11 = gettext("%s: option \'--%s\' requires an argument\n");
#line 703
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
                          *(argv + 0), pfound->name);
                  }
                }
                {
#line 708
                tmp___12 = strlen((char const   *)d->__nextchar);
#line 708
                d->__nextchar += tmp___12;
#line 709
                d->rpl_optopt = (int )pfound->val;
                }
#line 710
                if ((int const   )*(optstring + 0) == 58) {
#line 710
                  tmp___13 = ':';
                } else {
#line 710
                  tmp___13 = '?';
                }
#line 710
                return (tmp___13);
              }
            }
            {
#line 713
            tmp___14 = strlen((char const   *)d->__nextchar);
#line 713
            d->__nextchar += tmp___14;
            }
#line 714
            if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 715
              *longind = option_index;
            }
#line 716
            if (pfound->flag) {
#line 718
              *(pfound->flag) = (int )pfound->val;
#line 719
              return (0);
            }
#line 721
            return ((int )pfound->val);
          }
#line 728
          if (! long_only) {
#line 728
            goto _L___4;
          } else
#line 728
          if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 728
            goto _L___4;
          } else {
            {
#line 728
            tmp___17 = strchr(optstring, (int )*(d->__nextchar));
            }
#line 728
            if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
              _L___4: /* CIL Label */ 
#line 731
              if (print_errors) {
#line 738
                if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
                  {
#line 745
                  tmp___15 = gettext("%s: unrecognized option \'--%s\'\n");
#line 745
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
                          *(argv + 0), d->__nextchar);
                  }
                } else {
                  {
#line 756
                  tmp___16 = gettext("%s: unrecognized option \'%c%s\'\n");
#line 756
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
                          *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0), d->__nextchar);
                  }
                }
              }
#line 778
              d->__nextchar = (char *)"";
#line 779
              (d->rpl_optind) ++;
#line 780
              d->rpl_optopt = 0;
#line 781
              return ('?');
            }
          }
        }
      }
    }
  }
  {
#line 788
  tmp___19 = d->__nextchar;
#line 788
  (d->__nextchar) ++;
#line 788
  c = *tmp___19;
#line 789
  tmp___20 = strchr(optstring, (int )c);
#line 789
  temp = (char const   *)tmp___20;
  }
#line 792
  if ((int )*(d->__nextchar) == 0) {
#line 793
    (d->rpl_optind) ++;
  }
#line 795
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 795
    goto _L___7;
  } else
#line 795
  if ((int )c == 58) {
#line 795
    goto _L___7;
  } else
#line 795
  if ((int )c == 59) {
    _L___7: /* CIL Label */ 
#line 797
    if (print_errors) {
      {
#line 808
      tmp___21 = gettext("%s: invalid option -- \'%c\'\n");
#line 808
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
              *(argv + 0), (int )c);
      }
    }
#line 828
    d->rpl_optopt = (int )c;
#line 829
    return ('?');
  }
#line 832
  if ((int const   )*(temp + 0) == 87) {
#line 832
    if ((int const   )*(temp + 1) == 59) {
#line 836
      pfound___0 = (struct rpl_option  const  *)((void *)0);
#line 837
      exact___0 = 0;
#line 838
      ambig = 0;
#line 839
      indfound___0 = 0;
#line 842
      if ((unsigned long )longopts___0 == (unsigned long )((void *)0)) {
#line 843
        goto no_longs;
      }
#line 846
      if ((int )*(d->__nextchar) != 0) {
#line 848
        d->rpl_optarg = d->__nextchar;
#line 851
        (d->rpl_optind) ++;
      } else
#line 853
      if (d->rpl_optind == argc) {
#line 855
        if (print_errors) {
          {
#line 877
          tmp___22 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 877
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22,
                  *(argv + 0), (int )c);
          }
        }
#line 882
        d->rpl_optopt = (int )c;
#line 883
        if ((int const   )*(optstring + 0) == 58) {
#line 884
          c = (char )':';
        } else {
#line 886
          c = (char )'?';
        }
#line 887
        return ((int )c);
      } else {
#line 892
        tmp___23 = d->rpl_optind;
#line 892
        (d->rpl_optind) ++;
#line 892
        d->rpl_optarg = *(argv + tmp___23);
      }
#line 897
      nameend___0 = d->rpl_optarg;
#line 897
      d->__nextchar = nameend___0;
      {
#line 897
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 897
        if (*nameend___0) {
#line 897
          if (! ((int )*nameend___0 != 61)) {
#line 897
            goto while_break___4;
          }
        } else {
#line 897
          goto while_break___4;
        }
#line 897
        nameend___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 903
      p___0 = longopts___0;
#line 903
      option_index___0 = 0;
      {
#line 903
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 903
        if (! p___0->name) {
#line 903
          goto while_break___5;
        }
        {
#line 904
        tmp___25 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                           (size_t )(nameend___0 - d->__nextchar));
        }
#line 904
        if (! tmp___25) {
          {
#line 906
          tmp___24 = strlen((char const   *)p___0->name);
          }
#line 906
          if ((size_t )((unsigned int )(nameend___0 - d->__nextchar)) == tmp___24) {
#line 909
            pfound___0 = p___0;
#line 910
            indfound___0 = option_index___0;
#line 911
            exact___0 = 1;
#line 912
            goto while_break___5;
          } else
#line 914
          if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
#line 917
            pfound___0 = p___0;
#line 918
            indfound___0 = option_index___0;
          } else
#line 920
          if (long_only) {
#line 925
            ambig = 1;
          } else
#line 920
          if (pfound___0->has_arg != p___0->has_arg) {
#line 925
            ambig = 1;
          } else
#line 920
          if ((unsigned long )pfound___0->flag != (unsigned long )p___0->flag) {
#line 925
            ambig = 1;
          } else
#line 920
          if (pfound___0->val != p___0->val) {
#line 925
            ambig = 1;
          }
        }
#line 903
        p___0 ++;
#line 903
        option_index___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 927
      if (ambig) {
#line 927
        if (! exact___0) {
#line 929
          if (print_errors) {
            {
#line 950
            tmp___26 = gettext("%s: option \'-W %s\' is ambiguous\n");
#line 950
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___26,
                    *(argv + 0), d->rpl_optarg);
            }
          }
          {
#line 954
          tmp___27 = strlen((char const   *)d->__nextchar);
#line 954
          d->__nextchar += tmp___27;
#line 955
          (d->rpl_optind) ++;
          }
#line 956
          return ('?');
        }
      }
#line 958
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
#line 960
        option_index___0 = indfound___0;
#line 961
        if (*nameend___0) {
#line 965
          if (pfound___0->has_arg) {
#line 966
            d->rpl_optarg = nameend___0 + 1;
          } else {
#line 969
            if (print_errors) {
              {
#line 992
              tmp___28 = gettext("%s: option \'-W %s\' doesn\'t allow an argument\n");
#line 992
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___28,
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 998
            tmp___29 = strlen((char const   *)d->__nextchar);
#line 998
            d->__nextchar += tmp___29;
            }
#line 999
            return ('?');
          }
        } else
#line 1002
        if (pfound___0->has_arg == 1) {
#line 1004
          if (d->rpl_optind < argc) {
#line 1005
            tmp___30 = d->rpl_optind;
#line 1005
            (d->rpl_optind) ++;
#line 1005
            d->rpl_optarg = *(argv + tmp___30);
          } else {
#line 1008
            if (print_errors) {
              {
#line 1031
              tmp___31 = gettext("%s: option \'-W %s\' requires an argument\n");
#line 1031
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___31,
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 1036
            tmp___32 = strlen((char const   *)d->__nextchar);
#line 1036
            d->__nextchar += tmp___32;
            }
#line 1037
            if ((int const   )*(optstring + 0) == 58) {
#line 1037
              tmp___33 = ':';
            } else {
#line 1037
              tmp___33 = '?';
            }
#line 1037
            return (tmp___33);
          }
        } else {
#line 1041
          d->rpl_optarg = (char *)((void *)0);
        }
        {
#line 1042
        tmp___34 = strlen((char const   *)d->__nextchar);
#line 1042
        d->__nextchar += tmp___34;
        }
#line 1043
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 1044
          *longind = option_index___0;
        }
#line 1045
        if (pfound___0->flag) {
#line 1047
          *(pfound___0->flag) = (int )pfound___0->val;
#line 1048
          return (0);
        }
#line 1050
        return ((int )pfound___0->val);
      }
      no_longs: 
#line 1054
      d->__nextchar = (char *)((void *)0);
#line 1055
      return ('W');
    }
  }
#line 1057
  if ((int const   )*(temp + 1) == 58) {
#line 1059
    if ((int const   )*(temp + 2) == 58) {
#line 1062
      if ((int )*(d->__nextchar) != 0) {
#line 1064
        d->rpl_optarg = d->__nextchar;
#line 1065
        (d->rpl_optind) ++;
      } else {
#line 1068
        d->rpl_optarg = (char *)((void *)0);
      }
#line 1069
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1074
      if ((int )*(d->__nextchar) != 0) {
#line 1076
        d->rpl_optarg = d->__nextchar;
#line 1079
        (d->rpl_optind) ++;
      } else
#line 1081
      if (d->rpl_optind == argc) {
#line 1083
        if (print_errors) {
          {
#line 1105
          tmp___35 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 1105
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___35,
                  *(argv + 0), (int )c);
          }
        }
#line 1110
        d->rpl_optopt = (int )c;
#line 1111
        if ((int const   )*(optstring + 0) == 58) {
#line 1112
          c = (char )':';
        } else {
#line 1114
          c = (char )'?';
        }
      } else {
#line 1119
        tmp___36 = d->rpl_optind;
#line 1119
        (d->rpl_optind) ++;
#line 1119
        d->rpl_optarg = *(argv + tmp___36);
      }
#line 1120
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1123
  return ((int )c);
}
}
#line 1127 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts___0 ,
                        int *longind , int long_only , int posixly_correct___0 ) 
{ 
  int result ;

  {
  {
#line 1134
  getopt_data.rpl_optind = rpl_optind;
#line 1135
  getopt_data.rpl_opterr = rpl_opterr;
#line 1137
  result = _getopt_internal_r(argc, argv, optstring, longopts___0, longind, long_only,
                              & getopt_data, posixly_correct___0);
#line 1141
  rpl_optind = getopt_data.rpl_optind;
#line 1142
  rpl_optarg = getopt_data.rpl_optarg;
#line 1143
  rpl_optopt = getopt_data.rpl_optopt;
  }
#line 1145
  return (result);
}
}
#line 1156
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc ,
                                                                                  char * const  *argv ,
                                                                                  char const   *optstring ) ;
#line 1156 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/getopt.c"
int ( __attribute__((__nonnull__(2,3))) rpl_getopt)(int argc , char * const  *argv ,
                                                    char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 1159
  tmp = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option  const  *)0,
                            (int *)0, 0, 1);
  }
#line 1159
  return (tmp);
}
}
#line 255 "/usr/include/stdio.h"
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 529 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/freopen-safer.c"
static _Bool protect_fd(int fd ) 
{ 
  int value___0 ;
  int tmp ;
  int *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 34
  tmp = open("/dev/null", 0);
#line 34
  value___0 = tmp;
  }
#line 35
  if (value___0 != fd) {
#line 37
    if (0 <= value___0) {
      {
#line 39
      close(value___0);
#line 40
      tmp___0 = __errno_location();
#line 40
      *tmp___0 = 9;
      }
    }
#line 42
    return ((_Bool)0);
  }
#line 44
  return ((_Bool)1);
}
}
#line 53 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/freopen-safer.c"
FILE *freopen_safer(char const   *name , char const   *mode , FILE *f ) 
{ 
  _Bool protect_in ;
  _Bool protect_out ;
  _Bool protect_err ;
  int saved_errno ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
  {
#line 62
  protect_in = (_Bool)0;
#line 63
  protect_out = (_Bool)0;
#line 64
  protect_err = (_Bool)0;
#line 67
  tmp = fileno(f);
  }
  {
#line 73
  if (tmp == 2) {
#line 73
    goto case_2;
  }
#line 77
  if (tmp == 1) {
#line 77
    goto case_1;
  }
#line 81
  if (tmp == 0) {
#line 81
    goto case_0;
  }
#line 69
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 70
  tmp___0 = dup2(2, 2);
  }
#line 70
  if (tmp___0 != 2) {
#line 71
    protect_err = (_Bool)1;
  }
  case_2: /* CIL Label */ 
  {
#line 74
  tmp___1 = dup2(1, 1);
  }
#line 74
  if (tmp___1 != 1) {
#line 75
    protect_out = (_Bool)1;
  }
  case_1: /* CIL Label */ 
  {
#line 78
  tmp___2 = dup2(0, 0);
  }
#line 78
  if (tmp___2 != 0) {
#line 79
    protect_in = (_Bool)1;
  }
  case_0: /* CIL Label */ 
#line 83
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 85
  if (protect_in) {
    {
#line 85
    tmp___5 = protect_fd(0);
    }
#line 85
    if (tmp___5) {
#line 85
      goto _L___0;
    } else {
#line 86
      f = (FILE *)((void *)0);
    }
  } else
  _L___0: /* CIL Label */ 
#line 87
  if (protect_out) {
    {
#line 87
    tmp___4 = protect_fd(1);
    }
#line 87
    if (tmp___4) {
#line 87
      goto _L;
    } else {
#line 88
      f = (FILE *)((void *)0);
    }
  } else
  _L: /* CIL Label */ 
#line 89
  if (protect_err) {
    {
#line 89
    tmp___3 = protect_fd(2);
    }
#line 89
    if (tmp___3) {
      {
#line 92
      f = freopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode,
                  (FILE */* __restrict  */)f);
      }
    } else {
#line 90
      f = (FILE *)((void *)0);
    }
  } else {
    {
#line 92
    f = freopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode,
                (FILE */* __restrict  */)f);
    }
  }
  {
#line 93
  tmp___6 = __errno_location();
#line 93
  saved_errno = *tmp___6;
  }
#line 94
  if (protect_err) {
    {
#line 95
    close(2);
    }
  }
#line 96
  if (protect_out) {
    {
#line 97
    close(1);
    }
  }
#line 98
  if (protect_in) {
    {
#line 99
    close(0);
    }
  }
#line 100
  if (! f) {
    {
#line 101
    tmp___7 = __errno_location();
#line 101
    *tmp___7 = saved_errno;
    }
  }
#line 102
  return (f);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 73 "./fnmatch.h"
int ( __attribute__((__nonnull__(1,2))) gnu_fnmatch)(char const   *pattern , char const   *string ,
                                                     int flags ) ;
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 389
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) mempcpy)(void * __restrict  __dest ,
                                                                                        void const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 152 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wchar_t *wcscat(wchar_t * __restrict  __dest ,
                                                     wchar_t const   * __restrict  __src ) ;
#line 284
extern  __attribute__((__nothrow__)) size_t wcslen(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 317
extern  __attribute__((__nothrow__)) wchar_t *wmemchr(wchar_t const   *__s , wchar_t __c ,
                                                      size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) wchar_t *wmempcpy(wchar_t * __restrict  __s1 ,
                                                       wchar_t const   * __restrict  __s2 ,
                                                       size_t __n ) ;
#line 351
extern  __attribute__((__nothrow__)) wint_t btowc(int __c ) ;
#line 406
extern  __attribute__((__nothrow__)) size_t mbsrtowcs(wchar_t * __restrict  __dst ,
                                                      char const   ** __restrict  __src ,
                                                      size_t __len , mbstate_t * __restrict  __ps ) ;
#line 172 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) wctype_t wctype(char const   *__property ) ;
#line 176
extern  __attribute__((__nothrow__)) int iswctype(wint_t __wc , wctype_t __desc ) ;
#line 139 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch.c"
static int posixly_correct  ;
#line 22 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
static int ext_match(int opt , char const   *pattern , char const   *string , char const   *string_end ,
                     _Bool no_leading_period , int flags ) ;
#line 25
static char const   *end_pattern(char const   *pattern ) ;
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
static int internal_fnmatch(char const   *pattern , char const   *string , char const   *string_end ,
                            _Bool no_leading_period , int flags ) 
{ 
  register char const   *p ;
  register char const   *n ;
  register unsigned char c ;
  _Bool new_no_leading_period ;
  int tmp ;
  int res ;
  long tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int res___0 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *endp ;
  char const   *tmp___8 ;
  long tmp___9 ;
  int result ;
  int tmp___10 ;
  void *tmp___11 ;
  char const   *endp___0 ;
  int tmp___12 ;
  void *tmp___13 ;
  int flags2 ;
  int tmp___14 ;
  _Bool no_leading_period2 ;
  int tmp___15 ;
  int tmp___16 ;
  int flags2___0 ;
  int tmp___17 ;
  int no_leading_period2___0 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;
  char const   *p_init ;
  char const   *n_init ;
  register _Bool not ;
  char cold ;
  unsigned char fn ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char str[257] ;
  size_t c1 ;
  wctype_t wt ;
  char const   *startp ;
  size_t tmp___29 ;
  wint_t tmp___30 ;
  int tmp___31 ;
  char const   *tmp___32 ;
  _Bool is_range ;
  int tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  unsigned char cend ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  int c1___0 ;
  char const   *startp___0 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  int res___1 ;
  long tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  char const   *tmp___46 ;
  void *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
#line 32
  p = pattern;
#line 32
  n = string;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    tmp___46 = p;
#line 44
    p ++;
#line 44
    c = (unsigned char )*tmp___46;
#line 44
    if (! ((int )c != 0)) {
#line 44
      goto while_break;
    }
#line 46
    new_no_leading_period = (_Bool)0;
#line 47
    if (flags & (1 << 4)) {
      {
#line 47
      tmp = tolower((int )c);
#line 47
      c = (unsigned char )tmp;
      }
    } else {
#line 47
      c = c;
    }
    {
#line 51
    if ((int )c == 63) {
#line 51
      goto case_63;
    }
#line 70
    if ((int )c == 92) {
#line 70
      goto case_92;
    }
#line 83
    if ((int )c == 42) {
#line 83
      goto case_42;
    }
#line 202
    if ((int )c == 91) {
#line 202
      goto case_91;
    }
#line 946
    if ((int )c == 33) {
#line 946
      goto case_33;
    }
#line 946
    if ((int )c == 64) {
#line 946
      goto case_33;
    }
#line 946
    if ((int )c == 43) {
#line 946
      goto case_33;
    }
#line 957
    if ((int )c == 47) {
#line 957
      goto case_47;
    }
#line 967
    goto normal_match;
    case_63: /* CIL Label */ 
    {
#line 52
    tmp___0 = __builtin_expect((long )(flags & (1 << 5)), 0L);
    }
#line 52
    if (tmp___0) {
#line 52
      if ((int const   )*p == 40) {
        {
#line 56
        res = ext_match((int )c, p, n, string_end, no_leading_period, flags);
        }
#line 58
        if (res != -1) {
#line 59
          return (res);
        }
      }
    }
#line 62
    if ((unsigned long )n == (unsigned long )string_end) {
#line 63
      return (1);
    } else
#line 64
    if ((int const   )*n == 47) {
#line 64
      if (flags & 1) {
#line 65
        return (1);
      } else {
#line 64
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 66
    if ((int const   )*n == 46) {
#line 66
      if (no_leading_period) {
#line 67
        return (1);
      }
    }
#line 68
    goto switch_break;
    case_92: /* CIL Label */ 
#line 71
    if (! (flags & (1 << 1))) {
#line 73
      tmp___1 = p;
#line 73
      p ++;
#line 73
      c = (unsigned char )*tmp___1;
#line 74
      if ((int )c == 0) {
#line 76
        return (1);
      }
#line 77
      if (flags & (1 << 4)) {
        {
#line 77
        tmp___2 = tolower((int )c);
#line 77
        c = (unsigned char )tmp___2;
        }
      } else {
#line 77
        c = c;
      }
    }
#line 79
    if ((unsigned long )n == (unsigned long )string_end) {
#line 80
      return (1);
    } else {
#line 79
      if (flags & (1 << 4)) {
        {
#line 79
        tmp___3 = tolower((int )((unsigned char )*n));
#line 79
        tmp___4 = tmp___3;
        }
      } else {
#line 79
        tmp___4 = (int )((unsigned char )*n);
      }
#line 79
      if (tmp___4 != (int )c) {
#line 80
        return (1);
      }
    }
#line 81
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 84
    tmp___5 = __builtin_expect((long )(flags & (1 << 5)), 0L);
    }
#line 84
    if (tmp___5) {
#line 84
      if ((int const   )*p == 40) {
        {
#line 88
        res___0 = ext_match((int )c, p, n, string_end, no_leading_period, flags);
        }
#line 90
        if (res___0 != -1) {
#line 91
          return (res___0);
        }
      }
    }
#line 94
    if ((unsigned long )n != (unsigned long )string_end) {
#line 94
      if ((int const   )*n == 46) {
#line 94
        if (no_leading_period) {
#line 95
          return (1);
        }
      }
    }
#line 97
    tmp___6 = p;
#line 97
    p ++;
#line 97
    c = (unsigned char )*tmp___6;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (! ((int )c == 63)) {
#line 97
        if (! ((int )c == 42)) {
#line 97
          goto while_break___0;
        }
      }
#line 99
      if ((int const   )*p == 40) {
#line 99
        if ((flags & (1 << 5)) != 0) {
          {
#line 101
          tmp___8 = end_pattern(p);
#line 101
          endp = tmp___8;
          }
#line 102
          if ((unsigned long )endp != (unsigned long )p) {
#line 105
            p = endp;
#line 106
            goto __Cont;
          }
        }
      }
#line 110
      if ((int )c == 63) {
#line 113
        if ((unsigned long )n == (unsigned long )string_end) {
#line 115
          return (1);
        } else
#line 116
        if ((int const   )*n == 47) {
          {
#line 116
          tmp___9 = __builtin_expect((long )(flags & 1), 0L);
          }
#line 116
          if (tmp___9) {
#line 120
            return (1);
          } else {
#line 125
            n ++;
          }
        } else {
#line 125
          n ++;
        }
      }
      __Cont: /* CIL Label */ 
#line 97
      tmp___7 = p;
#line 97
      p ++;
#line 97
      c = (unsigned char )*tmp___7;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 129
    if ((int )c == 0) {
#line 135
      if ((flags & 1) == 0) {
#line 135
        tmp___10 = 0;
      } else {
#line 135
        tmp___10 = 1;
      }
#line 135
      result = tmp___10;
#line 137
      if (flags & 1) {
#line 139
        if (flags & (1 << 3)) {
#line 140
          result = 0;
        } else {
          {
#line 143
          tmp___11 = memchr((void const   *)n, '/', (size_t )(string_end - n));
          }
#line 143
          if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 144
            result = 0;
          }
        }
      }
#line 148
      return (result);
    } else {
#line 154
      if (flags & 1) {
#line 154
        tmp___12 = '/';
      } else {
#line 154
        tmp___12 = '\000';
      }
      {
#line 154
      tmp___13 = memchr((void const   *)n, tmp___12, (size_t )(string_end - n));
#line 154
      endp___0 = (char const   *)tmp___13;
      }
#line 156
      if ((unsigned long )endp___0 == (unsigned long )((void *)0)) {
#line 157
        endp___0 = string_end;
      }
#line 159
      if ((int )c == 91) {
#line 159
        goto _L___1;
      } else {
        {
#line 159
        tmp___22 = __builtin_expect((long )(flags & (1 << 5)), 0L);
        }
#line 159
        if (tmp___22 != 0L) {
#line 159
          if ((int )c == 64) {
#line 159
            goto _L___4;
          } else
#line 159
          if ((int )c == 43) {
#line 159
            goto _L___4;
          } else
#line 159
          if ((int )c == 33) {
            _L___4: /* CIL Label */ 
#line 159
            if ((int const   )*p == 40) {
              _L___1: /* CIL Label */ 
#line 164
              if (flags & 1) {
#line 164
                tmp___14 = flags;
              } else {
#line 164
                tmp___14 = flags & ~ (1 << 2);
              }
#line 164
              flags2 = tmp___14;
#line 166
              no_leading_period2 = no_leading_period;
#line 168
              p --;
              {
#line 168
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 168
                if (! ((unsigned long )n < (unsigned long )endp___0)) {
#line 168
                  goto while_break___1;
                }
                {
#line 169
                tmp___15 = internal_fnmatch(p, n, string_end, no_leading_period2,
                                            flags2);
                }
#line 169
                if (tmp___15 == 0) {
#line 171
                  return (0);
                }
#line 168
                n ++;
#line 168
                no_leading_period2 = (_Bool)0;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
#line 159
              goto _L___3;
            }
          } else {
#line 159
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 173
        if ((int )c == 47) {
#line 173
          if (flags & 1) {
            {
#line 175
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 175
              if ((unsigned long )n < (unsigned long )string_end) {
#line 175
                if (! ((int const   )*n != 47)) {
#line 175
                  goto while_break___2;
                }
              } else {
#line 175
                goto while_break___2;
              }
#line 176
              n ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 177
            if ((unsigned long )n < (unsigned long )string_end) {
#line 177
              if ((int const   )*n == 47) {
                {
#line 177
                tmp___16 = internal_fnmatch(p, n + 1, string_end, (_Bool )(flags & (1 << 2)),
                                            flags);
                }
#line 177
                if (tmp___16 == 0) {
#line 180
                  return (0);
                }
              }
            }
          } else {
#line 173
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 184
          if (flags & 1) {
#line 184
            tmp___17 = flags;
          } else {
#line 184
            tmp___17 = flags & ~ (1 << 2);
          }
#line 184
          flags2___0 = tmp___17;
#line 186
          no_leading_period2___0 = (int )no_leading_period;
#line 188
          if ((int )c == 92) {
#line 188
            if (! (flags & (1 << 1))) {
#line 189
              c = (unsigned char )*p;
            }
          }
#line 190
          if (flags & (1 << 4)) {
            {
#line 190
            tmp___18 = tolower((int )c);
#line 190
            c = (unsigned char )tmp___18;
            }
          } else {
#line 190
            c = c;
          }
#line 191
          p --;
          {
#line 191
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 191
            if (! ((unsigned long )n < (unsigned long )endp___0)) {
#line 191
              goto while_break___3;
            }
#line 192
            if (flags & (1 << 4)) {
              {
#line 192
              tmp___19 = tolower((int )((unsigned char )*n));
#line 192
              tmp___20 = tmp___19;
              }
            } else {
#line 192
              tmp___20 = (int )((unsigned char )*n);
            }
#line 192
            if (tmp___20 == (int )c) {
              {
#line 192
              tmp___21 = internal_fnmatch(p, n, string_end, (_Bool )no_leading_period2___0,
                                          flags2___0);
              }
#line 192
              if (tmp___21 == 0) {
#line 195
                return (0);
              }
            }
#line 191
            n ++;
#line 191
            no_leading_period2___0 = 0;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
    }
#line 200
    return (1);
    case_91: /* CIL Label */ 
#line 205
    p_init = p;
#line 206
    n_init = n;
#line 211
    if (posixly_correct == 0) {
      {
#line 212
      tmp___24 = getenv("POSIXLY_CORRECT");
      }
#line 212
      if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
#line 212
        posixly_correct = 1;
      } else {
#line 212
        posixly_correct = -1;
      }
    }
#line 214
    if ((unsigned long )n == (unsigned long )string_end) {
#line 215
      return (1);
    }
#line 217
    if ((int const   )*n == 46) {
#line 217
      if (no_leading_period) {
#line 218
        return (1);
      }
    }
#line 220
    if ((int const   )*n == 47) {
#line 220
      if (flags & 1) {
#line 222
        return (1);
      }
    }
#line 224
    if ((int const   )*p == 33) {
#line 224
      tmp___25 = 1;
    } else
#line 224
    if (posixly_correct < 0) {
#line 224
      if ((int const   )*p == 94) {
#line 224
        tmp___25 = 1;
      } else {
#line 224
        tmp___25 = 0;
      }
    } else {
#line 224
      tmp___25 = 0;
    }
#line 224
    not = (_Bool )tmp___25;
#line 225
    if (not) {
#line 226
      p ++;
    }
#line 228
    if (flags & (1 << 4)) {
      {
#line 228
      tmp___26 = tolower((int )((unsigned char )*n));
#line 228
      fn = (unsigned char )tmp___26;
      }
    } else {
#line 228
      fn = (unsigned char )*n;
    }
#line 230
    tmp___27 = p;
#line 230
    p ++;
#line 230
    c = (unsigned char )*tmp___27;
    {
#line 231
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 233
      if (! (flags & (1 << 1))) {
#line 233
        if ((int )c == 92) {
#line 235
          if ((int const   )*p == 0) {
#line 236
            return (1);
          }
#line 237
          if (flags & (1 << 4)) {
            {
#line 237
            tmp___28 = tolower((int )((unsigned char )*p));
#line 237
            c = (unsigned char )tmp___28;
            }
          } else {
#line 237
            c = (unsigned char )*p;
          }
#line 238
          p ++;
#line 240
          goto normal_bracket;
        } else {
#line 233
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 242
      if ((int )c == 91) {
#line 242
        if ((int const   )*p == 58) {
#line 246
          c1 = (size_t )0;
#line 250
          startp = p;
          {
#line 252
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 254
            if (c1 == 256UL) {
#line 257
              return (1);
            }
#line 259
            p ++;
#line 259
            c = (unsigned char )*p;
#line 260
            if ((int )c == 58) {
#line 260
              if ((int const   )*(p + 1) == 93) {
#line 262
                p += 2;
#line 263
                goto while_break___5;
              }
            }
#line 265
            if ((int )c < 97) {
#line 269
              p = startp;
#line 270
              c = (unsigned char )'[';
#line 271
              goto normal_bracket;
            } else
#line 265
            if ((int )c >= 122) {
#line 269
              p = startp;
#line 270
              c = (unsigned char )'[';
#line 271
              goto normal_bracket;
            }
#line 273
            tmp___29 = c1;
#line 273
            c1 ++;
#line 273
            str[tmp___29] = (char )c;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 275
          str[c1] = (char )'\000';
#line 278
          wt = wctype((char const   *)(str));
          }
#line 279
          if (wt == 0UL) {
#line 281
            return (1);
          }
          {
#line 290
          tmp___30 = btowc((int )((unsigned char )*n));
#line 290
          tmp___31 = iswctype(tmp___30, wt);
          }
#line 290
          if (tmp___31) {
#line 291
            goto matched;
          }
#line 308
          tmp___32 = p;
#line 308
          p ++;
#line 308
          c = (unsigned char )*tmp___32;
        } else {
#line 242
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 416
      if ((int )c == 0) {
#line 419
        p = p_init;
#line 420
        n = n_init;
#line 421
        c = (unsigned char )'[';
#line 422
        goto normal_match;
      } else {
#line 426
        is_range = (_Bool)0;
#line 603
        if (flags & (1 << 4)) {
          {
#line 603
          tmp___33 = tolower((int )c);
#line 603
          c = (unsigned char )tmp___33;
          }
        } else {
#line 603
          c = c;
        }
        normal_bracket: 
#line 609
        if ((int const   )*p == 45) {
#line 609
          if ((int const   )*(p + 1) != 0) {
#line 609
            if ((int const   )*(p + 1) != 93) {
#line 609
              tmp___34 = 1;
            } else {
#line 609
              tmp___34 = 0;
            }
          } else {
#line 609
            tmp___34 = 0;
          }
        } else {
#line 609
          tmp___34 = 0;
        }
#line 609
        is_range = (_Bool )tmp___34;
#line 612
        if (! is_range) {
#line 612
          if ((int )c == (int )fn) {
#line 613
            goto matched;
          }
        }
#line 621
        cold = (char )c;
#line 622
        tmp___35 = p;
#line 622
        p ++;
#line 622
        c = (unsigned char )*tmp___35;
#line 625
        if ((int )c == 45) {
#line 625
          if ((int const   )*p != 93) {
#line 846
            tmp___36 = p;
#line 846
            p ++;
#line 846
            cend = (unsigned char )*tmp___36;
#line 848
            if (! (flags & (1 << 1))) {
#line 848
              if ((int )cend == 92) {
#line 849
                tmp___37 = p;
#line 849
                p ++;
#line 849
                cend = (unsigned char )*tmp___37;
              }
            }
#line 850
            if ((int )cend == 0) {
#line 851
              return (1);
            }
#line 854
            if ((int )cold <= (int )fn) {
#line 854
              if ((int )fn <= (int )cend) {
#line 855
                goto matched;
              }
            }
#line 858
            tmp___38 = p;
#line 858
            p ++;
#line 858
            c = (unsigned char )*tmp___38;
          }
        }
      }
#line 862
      if ((int )c == 93) {
#line 863
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 866
    if (! not) {
#line 867
      return (1);
    }
#line 868
    goto switch_break;
    matched: 
    {
#line 872
    while (1) {
      while_continue___6: /* CIL Label */ ;
      ignore_next: 
#line 875
      tmp___39 = p;
#line 875
      p ++;
#line 875
      c = (unsigned char )*tmp___39;
#line 877
      if ((int )c == 0) {
#line 879
        return (1);
      }
#line 881
      if (! (flags & (1 << 1))) {
#line 881
        if ((int )c == 92) {
#line 883
          if ((int const   )*p == 0) {
#line 884
            return (1);
          }
#line 886
          p ++;
        } else {
#line 881
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 888
      if ((int )c == 91) {
#line 888
        if ((int const   )*p == 58) {
#line 890
          c1___0 = 0;
#line 891
          startp___0 = p;
          {
#line 893
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 895
            p ++;
#line 895
            c = (unsigned char )*p;
#line 896
            c1___0 ++;
#line 896
            if (c1___0 == 256) {
#line 897
              return (1);
            }
#line 899
            if ((int const   )*p == 58) {
#line 899
              if ((int const   )*(p + 1) == 93) {
#line 900
                goto while_break___7;
              }
            }
#line 902
            if ((int )c < 97) {
#line 904
              p = startp___0;
#line 905
              goto ignore_next;
            } else
#line 902
            if ((int )c >= 122) {
#line 904
              p = startp___0;
#line 905
              goto ignore_next;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 908
          p += 2;
#line 909
          tmp___40 = p;
#line 909
          p ++;
#line 909
          c = (unsigned char )*tmp___40;
        } else {
#line 888
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 911
      if ((int )c == 91) {
#line 911
        if ((int const   )*p == 61) {
#line 913
          p ++;
#line 913
          c = (unsigned char )*p;
#line 914
          if ((int )c == 0) {
#line 915
            return (1);
          }
#line 916
          p ++;
#line 916
          c = (unsigned char )*p;
#line 917
          if ((int )c != 61) {
#line 918
            return (1);
          } else
#line 917
          if ((int const   )*(p + 1) != 93) {
#line 918
            return (1);
          }
#line 919
          p += 2;
#line 920
          tmp___41 = p;
#line 920
          p ++;
#line 920
          c = (unsigned char )*tmp___41;
        } else {
#line 911
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 922
      if ((int )c == 91) {
#line 922
        if ((int const   )*p == 46) {
#line 924
          p ++;
          {
#line 925
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 927
            p ++;
#line 927
            c = (unsigned char )*p;
#line 928
            if ((int )c == 0) {
#line 929
              return (1);
            }
#line 931
            if ((int const   )*p == 46) {
#line 931
              if ((int const   )*(p + 1) == 93) {
#line 932
                goto while_break___8;
              }
            }
          }
          while_break___8: /* CIL Label */ ;
          }
#line 934
          p += 2;
#line 935
          tmp___42 = p;
#line 935
          p ++;
#line 935
          c = (unsigned char )*tmp___42;
        }
      }
#line 872
      if (! ((int )c != 93)) {
#line 872
        goto while_break___6;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 939
    if (not) {
#line 940
      return (1);
    }
#line 942
    goto switch_break;
    case_33: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_43: /* CIL Label */ 
    {
#line 947
    tmp___43 = __builtin_expect((long )(flags & (1 << 5)), 0L);
    }
#line 947
    if (tmp___43) {
#line 947
      if ((int const   )*p == 40) {
        {
#line 951
        res___1 = ext_match((int )c, p, n, string_end, no_leading_period, flags);
        }
#line 952
        if (res___1 != -1) {
#line 953
          return (res___1);
        }
      }
    }
#line 955
    goto normal_match;
    case_47: /* CIL Label */ 
#line 958
    if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 960
      if ((unsigned long )n == (unsigned long )string_end) {
#line 961
        return (1);
      } else
#line 960
      if ((int )c != (int )((unsigned char )*n)) {
#line 961
        return (1);
      }
#line 963
      new_no_leading_period = (_Bool)1;
#line 964
      goto switch_break;
    }
    normal_match: 
    switch_default: /* CIL Label */ 
#line 969
    if ((unsigned long )n == (unsigned long )string_end) {
#line 970
      return (1);
    } else {
#line 969
      if (flags & (1 << 4)) {
        {
#line 969
        tmp___44 = tolower((int )((unsigned char )*n));
#line 969
        tmp___45 = tmp___44;
        }
      } else {
#line 969
        tmp___45 = (int )((unsigned char )*n);
      }
#line 969
      if ((int )c != tmp___45) {
#line 970
        return (1);
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 973
    no_leading_period = new_no_leading_period;
#line 974
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 977
  if ((unsigned long )n == (unsigned long )string_end) {
#line 978
    return (0);
  }
#line 980
  if (flags & (1 << 3)) {
#line 980
    if ((unsigned long )n != (unsigned long )string_end) {
#line 980
      if ((int const   )*n == 47) {
#line 982
        return (0);
      }
    }
  }
#line 984
  return (1);
}
}
#line 988 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
static char const   *end_pattern(char const   *pattern ) 
{ 
  char const   *p ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 992
  p = pattern;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 995
    p ++;
#line 995
    if ((int const   )*p == 0) {
#line 997
      return (pattern);
    } else
#line 998
    if ((int const   )*p == 91) {
#line 1001
      if (posixly_correct == 0) {
        {
#line 1002
        tmp___0 = getenv("POSIXLY_CORRECT");
        }
#line 1002
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1002
          posixly_correct = 1;
        } else {
#line 1002
          posixly_correct = -1;
        }
      }
#line 1006
      p ++;
#line 1006
      if ((int const   )*p == 33) {
#line 1007
        p ++;
      } else
#line 1006
      if (posixly_correct < 0) {
#line 1006
        if ((int const   )*p == 94) {
#line 1007
          p ++;
        }
      }
#line 1009
      if ((int const   )*p == 93) {
#line 1010
        p ++;
      }
      {
#line 1012
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1012
        if (! ((int const   )*p != 93)) {
#line 1012
          goto while_break___0;
        }
#line 1013
        tmp___1 = p;
#line 1013
        p ++;
#line 1013
        if ((int const   )*tmp___1 == 0) {
#line 1015
          return (pattern);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 1017
    if ((int const   )*p == 63) {
#line 1017
      goto _L___0;
    } else
#line 1017
    if ((int const   )*p == 42) {
#line 1017
      goto _L___0;
    } else
#line 1017
    if ((int const   )*p == 43) {
#line 1017
      goto _L___0;
    } else
#line 1017
    if ((int const   )*p == 64) {
#line 1017
      goto _L___0;
    } else
#line 1017
    if ((int const   )*p == 33) {
      _L___0: /* CIL Label */ 
#line 1017
      if ((int const   )*(p + 1) == 40) {
        {
#line 1019
        p = end_pattern(p + 1);
        }
      } else {
#line 1017
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1020
    if ((int const   )*p == 41) {
#line 1021
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1023
  return (p + 1);
}
}
#line 1027 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
static int ext_match(int opt , char const   *pattern , char const   *string , char const   *string_end ,
                     _Bool no_leading_period , int flags ) 
{ 
  char const   *startp ;
  size_t level ;
  struct patternlist *list ;
  struct patternlist **lastp ;
  size_t pattern_len ;
  size_t tmp ;
  char const   *p ;
  char const   *rs ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  struct patternlist *newp ;
  size_t plen ;
  size_t plensize ;
  size_t newpsize ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  struct patternlist *newp___0 ;
  size_t plen___0 ;
  size_t plensize___0 ;
  size_t newpsize___0 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  struct patternlist *runp ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 1034
  list = (struct patternlist *)((void *)0);
#line 1039
  lastp = & list;
#line 1040
  tmp = strlen(pattern);
#line 1040
  pattern_len = tmp;
#line 1046
  level = (size_t )0;
#line 1047
  p = pattern + 1;
#line 1047
  startp = p;
  }
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1048
    if ((int const   )*p == 0) {
#line 1050
      return (-1);
    } else
#line 1051
    if ((int const   )*p == 91) {
#line 1054
      if (posixly_correct == 0) {
        {
#line 1055
        tmp___1 = getenv("POSIXLY_CORRECT");
        }
#line 1055
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1055
          posixly_correct = 1;
        } else {
#line 1055
          posixly_correct = -1;
        }
      }
#line 1059
      p ++;
#line 1059
      if ((int const   )*p == 33) {
#line 1060
        p ++;
      } else
#line 1059
      if (posixly_correct < 0) {
#line 1059
        if ((int const   )*p == 94) {
#line 1060
          p ++;
        }
      }
#line 1062
      if ((int const   )*p == 93) {
#line 1063
        p ++;
      }
      {
#line 1065
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1065
        if (! ((int const   )*p != 93)) {
#line 1065
          goto while_break___0;
        }
#line 1066
        tmp___2 = p;
#line 1066
        p ++;
#line 1066
        if ((int const   )*tmp___2 == 0) {
#line 1068
          return (-1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 1070
    if ((int const   )*p == 63) {
#line 1070
      goto _L___0;
    } else
#line 1070
    if ((int const   )*p == 42) {
#line 1070
      goto _L___0;
    } else
#line 1070
    if ((int const   )*p == 43) {
#line 1070
      goto _L___0;
    } else
#line 1070
    if ((int const   )*p == 64) {
#line 1070
      goto _L___0;
    } else
#line 1070
    if ((int const   )*p == 33) {
      _L___0: /* CIL Label */ 
#line 1070
      if ((int const   )*(p + 1) == 40) {
#line 1073
        level ++;
      } else {
#line 1070
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1074
    if ((int const   )*p == 41) {
#line 1076
      tmp___5 = level;
#line 1076
      level --;
#line 1076
      if (tmp___5 == 0UL) {
#line 1099
        if (opt == 63) {
#line 1099
          plen = pattern_len;
        } else
#line 1099
        if (opt == 64) {
#line 1099
          plen = pattern_len;
        } else {
#line 1099
          plen = (unsigned long )(p - startp) + 1UL;
        }
#line 1099
        plensize = plen * sizeof(char );
#line 1099
        newpsize = (unsigned long )(& ((struct patternlist *)0)->str) + plensize;
#line 1099
        if (0xffffffffffffffffUL / sizeof(char ) < plen) {
#line 1099
          return (-1);
        } else
#line 1099
        if (newpsize < (unsigned long )(& ((struct patternlist *)0)->str)) {
#line 1099
          return (-1);
        } else
#line 1099
        if (8000UL <= newpsize) {
#line 1099
          return (-1);
        }
        {
#line 1099
        tmp___3 = __builtin_alloca(newpsize);
#line 1099
        newp = (struct patternlist *)tmp___3;
#line 1099
        tmp___4 = mempcpy((void */* __restrict  */)(newp->str), (void const   */* __restrict  */)startp,
                          (size_t )(p - startp));
#line 1099
        *((char *)tmp___4) = (char )'\000';
#line 1099
        newp->next = (struct patternlist *)((void *)0);
#line 1099
        *lastp = newp;
#line 1099
        lastp = & newp->next;
        }
#line 1100
        goto while_break;
      }
    } else
#line 1103
    if ((int const   )*p == 124) {
#line 1105
      if (level == 0UL) {
#line 1107
        if (opt == 63) {
#line 1107
          plen___0 = pattern_len;
        } else
#line 1107
        if (opt == 64) {
#line 1107
          plen___0 = pattern_len;
        } else {
#line 1107
          plen___0 = (unsigned long )(p - startp) + 1UL;
        }
#line 1107
        plensize___0 = plen___0 * sizeof(char );
#line 1107
        newpsize___0 = (unsigned long )(& ((struct patternlist *)0)->str) + plensize___0;
#line 1107
        if (0xffffffffffffffffUL / sizeof(char ) < plen___0) {
#line 1107
          return (-1);
        } else
#line 1107
        if (newpsize___0 < (unsigned long )(& ((struct patternlist *)0)->str)) {
#line 1107
          return (-1);
        } else
#line 1107
        if (8000UL <= newpsize___0) {
#line 1107
          return (-1);
        }
        {
#line 1107
        tmp___6 = __builtin_alloca(newpsize___0);
#line 1107
        newp___0 = (struct patternlist *)tmp___6;
#line 1107
        tmp___7 = mempcpy((void */* __restrict  */)(newp___0->str), (void const   */* __restrict  */)startp,
                          (size_t )(p - startp));
#line 1107
        *((char *)tmp___7) = (char )'\000';
#line 1107
        newp___0->next = (struct patternlist *)((void *)0);
#line 1107
        *lastp = newp___0;
#line 1107
        lastp = & newp___0->next;
#line 1108
        startp = p + 1;
        }
      }
    }
#line 1047
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 1111
    __assert_fail("list != ((void *)0)", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c",
                  1111U, "ext_match");
    }
  }
#line 1112
  if (! ((int const   )*(p + -1) == 41)) {
    {
#line 1112
    __assert_fail("p[-1] == \')\'", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c",
                  1112U, "ext_match");
    }
  }
  {
#line 1117
  if (opt == 42) {
#line 1117
    goto case_42;
  }
#line 1122
  if (opt == 43) {
#line 1122
    goto case_43;
  }
#line 1154
  if (opt == 63) {
#line 1154
    goto case_63;
  }
#line 1159
  if (opt == 64) {
#line 1159
    goto case_64;
  }
#line 1175
  if (opt == 33) {
#line 1175
    goto case_33;
  }
#line 1201
  goto switch_default;
  case_42: /* CIL Label */ 
  {
#line 1118
  tmp___8 = internal_fnmatch(p, string, string_end, no_leading_period, flags);
  }
#line 1118
  if (tmp___8 == 0) {
#line 1119
    return (0);
  }
  case_43: /* CIL Label */ 
  {
#line 1123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1125
    rs = string;
    {
#line 1125
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1125
      if (! ((unsigned long )rs <= (unsigned long )string_end)) {
#line 1125
        goto while_break___2;
      }
#line 1128
      if (flags & 1) {
#line 1128
        tmp___9 = flags;
      } else {
#line 1128
        tmp___9 = flags & ~ (1 << 2);
      }
      {
#line 1128
      tmp___10 = internal_fnmatch((char const   *)(list->str), string, rs, no_leading_period,
                                  tmp___9);
      }
#line 1128
      if (tmp___10 == 0) {
#line 1128
        if (flags & 1) {
#line 1128
          tmp___11 = flags;
        } else {
#line 1128
          tmp___11 = flags & ~ (1 << 2);
        }
#line 1128
        if ((unsigned long )rs == (unsigned long )string) {
#line 1128
          tmp___13 = (int )no_leading_period;
        } else {
#line 1128
          if ((int const   )*(rs + -1) == 47) {
#line 1128
            if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 1128
              tmp___12 = 1;
            } else {
#line 1128
              tmp___12 = 0;
            }
          } else {
#line 1128
            tmp___12 = 0;
          }
#line 1128
          tmp___13 = tmp___12;
        }
        {
#line 1128
        tmp___14 = internal_fnmatch(p, rs, string_end, (_Bool )tmp___13, tmp___11);
        }
#line 1128
        if (tmp___14 == 0) {
#line 1147
          return (0);
        } else
#line 1128
        if ((unsigned long )rs != (unsigned long )string) {
#line 1128
          if (flags & 1) {
#line 1128
            tmp___15 = flags;
          } else {
#line 1128
            tmp___15 = flags & ~ (1 << 2);
          }
#line 1128
          if ((unsigned long )rs == (unsigned long )string) {
#line 1128
            tmp___17 = (int )no_leading_period;
          } else {
#line 1128
            if ((int const   )*(rs + -1) == 47) {
#line 1128
              if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 1128
                tmp___16 = 1;
              } else {
#line 1128
                tmp___16 = 0;
              }
            } else {
#line 1128
              tmp___16 = 0;
            }
#line 1128
            tmp___17 = tmp___16;
          }
          {
#line 1128
          tmp___18 = internal_fnmatch(pattern - 1, rs, string_end, (_Bool )tmp___17,
                                      tmp___15);
          }
#line 1128
          if (tmp___18 == 0) {
#line 1147
            return (0);
          }
        }
      }
#line 1125
      rs ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1123
    list = list->next;
#line 1123
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 1123
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1152
  return (1);
  case_63: /* CIL Label */ 
  {
#line 1155
  tmp___19 = internal_fnmatch(p, string, string_end, no_leading_period, flags);
  }
#line 1155
  if (tmp___19 == 0) {
#line 1156
    return (0);
  }
  case_64: /* CIL Label */ 
  {
#line 1160
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1165
    if (flags & 1) {
#line 1165
      tmp___20 = flags;
    } else {
#line 1165
      tmp___20 = flags & ~ (1 << 2);
    }
    {
#line 1165
    tmp___21 = strcat((char */* __restrict  */)(list->str), (char const   */* __restrict  */)p);
#line 1165
    tmp___22 = internal_fnmatch((char const   *)tmp___21, string, string_end, no_leading_period,
                                tmp___20);
    }
#line 1165
    if (tmp___22 == 0) {
#line 1169
      return (0);
    }
#line 1160
    list = list->next;
#line 1160
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 1160
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1173
  return (1);
  case_33: /* CIL Label */ 
#line 1176
  rs = string;
  {
#line 1176
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1176
    if (! ((unsigned long )rs <= (unsigned long )string_end)) {
#line 1176
      goto while_break___4;
    }
#line 1180
    runp = list;
    {
#line 1180
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1180
      if (! ((unsigned long )runp != (unsigned long )((void *)0))) {
#line 1180
        goto while_break___5;
      }
#line 1181
      if (flags & 1) {
#line 1181
        tmp___23 = flags;
      } else {
#line 1181
        tmp___23 = flags & ~ (1 << 2);
      }
      {
#line 1181
      tmp___24 = internal_fnmatch((char const   *)(runp->str), string, rs, no_leading_period,
                                  tmp___23);
      }
#line 1181
      if (tmp___24 == 0) {
#line 1183
        goto while_break___5;
      }
#line 1180
      runp = runp->next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1186
    if ((unsigned long )runp == (unsigned long )((void *)0)) {
#line 1186
      if (flags & 1) {
#line 1186
        tmp___25 = flags;
      } else {
#line 1186
        tmp___25 = flags & ~ (1 << 2);
      }
#line 1186
      if ((unsigned long )rs == (unsigned long )string) {
#line 1186
        tmp___27 = (int )no_leading_period;
      } else {
#line 1186
        if ((int const   )*(rs + -1) == 47) {
#line 1186
          if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 1186
            tmp___26 = 1;
          } else {
#line 1186
            tmp___26 = 0;
          }
        } else {
#line 1186
          tmp___26 = 0;
        }
#line 1186
        tmp___27 = tmp___26;
      }
      {
#line 1186
      tmp___28 = internal_fnmatch(p, rs, string_end, (_Bool )tmp___27, tmp___25);
      }
#line 1186
      if (tmp___28 == 0) {
#line 1194
        return (0);
      }
    }
#line 1176
    rs ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1199
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 1202
  __assert_fail("! \"Invalid extended matching operator\"", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c",
                1202U, "ext_match");
  }
#line 1203
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1206
  return (-1);
}
}
#line 211 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch.c"
static wctype_t is_char_class(wchar_t const   *wcs ) 
{ 
  char s[257] ;
  char *cp ;
  char *tmp ;
  wchar_t const   *tmp___0 ;
  wctype_t tmp___1 ;
  void *__cil_tmp7 ;

  {
#line 215
  cp = s;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 246
    if (*wcs == 126) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 125) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 124) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 123) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 122) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 121) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 120) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 119) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 118) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 117) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 116) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 115) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 114) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 113) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 112) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 111) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 110) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 109) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 108) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 107) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 106) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 105) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 104) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 103) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 102) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 101) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 100) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 99) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 98) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 97) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 95) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 94) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 93) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 92) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 91) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 90) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 89) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 88) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 87) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 86) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 85) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 84) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 83) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 82) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 81) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 80) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 79) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 78) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 77) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 76) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 75) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 74) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 73) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 72) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 71) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 70) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 69) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 68) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 67) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 66) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 65) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 63) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 62) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 61) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 60) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 59) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 58) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 57) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 56) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 55) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 54) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 53) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 52) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 51) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 50) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 49) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 48) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 47) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 46) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 45) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 44) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 43) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 42) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 41) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 40) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 39) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 38) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 37) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 35) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 34) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 33) {
#line 246
      goto case_126;
    }
#line 246
    if (*wcs == 32) {
#line 246
      goto case_126;
    }
#line 248
    goto switch_default;
    case_126: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 247
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 249
    return ((wctype_t )0);
    switch_break: /* CIL Label */ ;
    }
#line 254
    if ((unsigned long )cp == (unsigned long )(s + 256)) {
#line 255
      return ((wctype_t )0);
    }
#line 257
    tmp = cp;
#line 257
    cp ++;
#line 257
    tmp___0 = wcs;
#line 257
    wcs ++;
#line 257
    *tmp = (char )*tmp___0;
#line 217
    if (! (*wcs != 0)) {
#line 217
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  *cp = (char )'\000';
#line 266
  tmp___1 = wctype((char const   *)(s));
  }
#line 266
  return (tmp___1);
}
}
#line 22 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
static int ext_wmatch(wint_t opt , wchar_t const   *pattern , wchar_t const   *string ,
                      wchar_t const   *string_end , _Bool no_leading_period , int flags ) ;
#line 25
static wchar_t const   *end_wpattern(wchar_t const   *pattern ) ;
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
static int internal_fnwmatch(wchar_t const   *pattern , wchar_t const   *string ,
                             wchar_t const   *string_end , _Bool no_leading_period ,
                             int flags ) 
{ 
  register wchar_t const   *p ;
  register wchar_t const   *n ;
  register wint_t c ;
  _Bool new_no_leading_period ;
  wint_t tmp ;
  int res ;
  long tmp___0 ;
  wchar_t const   *tmp___1 ;
  wint_t tmp___2 ;
  wint_t tmp___3 ;
  wint_t tmp___4 ;
  int res___0 ;
  long tmp___5 ;
  wchar_t const   *tmp___6 ;
  wchar_t const   *tmp___7 ;
  wchar_t const   *endp ;
  wchar_t const   *tmp___8 ;
  long tmp___9 ;
  int result ;
  int tmp___10 ;
  wchar_t *tmp___11 ;
  wchar_t const   *endp___0 ;
  int tmp___12 ;
  wchar_t *tmp___13 ;
  int flags2 ;
  int tmp___14 ;
  _Bool no_leading_period2 ;
  int tmp___15 ;
  int tmp___16 ;
  int flags2___0 ;
  int tmp___17 ;
  int no_leading_period2___0 ;
  wint_t tmp___18 ;
  wint_t tmp___19 ;
  wint_t tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;
  wchar_t const   *p_init ;
  wchar_t const   *n_init ;
  register _Bool not ;
  wchar_t cold ;
  wint_t fn ;
  char *tmp___24 ;
  int tmp___25 ;
  wint_t tmp___26 ;
  wchar_t const   *tmp___27 ;
  wint_t tmp___28 ;
  wchar_t str[257] ;
  size_t c1 ;
  wctype_t wt ;
  wchar_t const   *startp ;
  size_t tmp___29 ;
  int tmp___30 ;
  wchar_t const   *tmp___31 ;
  _Bool is_range ;
  wint_t tmp___32 ;
  int tmp___33 ;
  wchar_t const   *tmp___34 ;
  wint_t cend ;
  wchar_t const   *tmp___35 ;
  wchar_t const   *tmp___36 ;
  wchar_t const   *tmp___37 ;
  wchar_t const   *tmp___38 ;
  int c1___0 ;
  wchar_t const   *startp___0 ;
  wchar_t const   *tmp___39 ;
  wchar_t const   *tmp___40 ;
  wchar_t const   *tmp___41 ;
  int res___1 ;
  long tmp___42 ;
  wint_t tmp___43 ;
  wint_t tmp___44 ;
  wchar_t const   *tmp___45 ;
  void *__cil_tmp80 ;
  char *__cil_tmp81 ;

  {
#line 32
  p = pattern;
#line 32
  n = string;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    tmp___45 = p;
#line 44
    p ++;
#line 44
    c = (wint_t )*tmp___45;
#line 44
    if (! (c != 0U)) {
#line 44
      goto while_break;
    }
#line 46
    new_no_leading_period = (_Bool)0;
#line 47
    if (flags & (1 << 4)) {
      {
#line 47
      tmp = towlower(c);
#line 47
      c = tmp;
      }
    } else {
#line 47
      c = c;
    }
    {
#line 51
    if (c == 63U) {
#line 51
      goto case_63;
    }
#line 70
    if (c == 92U) {
#line 70
      goto case_92;
    }
#line 83
    if (c == 42U) {
#line 83
      goto case_42;
    }
#line 202
    if (c == 91U) {
#line 202
      goto case_91;
    }
#line 946
    if (c == 33U) {
#line 946
      goto case_33;
    }
#line 946
    if (c == 64U) {
#line 946
      goto case_33;
    }
#line 946
    if (c == 43U) {
#line 946
      goto case_33;
    }
#line 957
    if (c == 47U) {
#line 957
      goto case_47;
    }
#line 967
    goto normal_match;
    case_63: /* CIL Label */ 
    {
#line 52
    tmp___0 = __builtin_expect((long )(flags & (1 << 5)), 0L);
    }
#line 52
    if (tmp___0) {
#line 52
      if (*p == 40) {
        {
#line 56
        res = ext_wmatch(c, p, n, string_end, no_leading_period, flags);
        }
#line 58
        if (res != -1) {
#line 59
          return (res);
        }
      }
    }
#line 62
    if ((unsigned long )n == (unsigned long )string_end) {
#line 63
      return (1);
    } else
#line 64
    if (*n == 47) {
#line 64
      if (flags & 1) {
#line 65
        return (1);
      } else {
#line 64
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 66
    if (*n == 46) {
#line 66
      if (no_leading_period) {
#line 67
        return (1);
      }
    }
#line 68
    goto switch_break;
    case_92: /* CIL Label */ 
#line 71
    if (! (flags & (1 << 1))) {
#line 73
      tmp___1 = p;
#line 73
      p ++;
#line 73
      c = (wint_t )*tmp___1;
#line 74
      if (c == 0U) {
#line 76
        return (1);
      }
#line 77
      if (flags & (1 << 4)) {
        {
#line 77
        tmp___2 = towlower(c);
#line 77
        c = tmp___2;
        }
      } else {
#line 77
        c = c;
      }
    }
#line 79
    if ((unsigned long )n == (unsigned long )string_end) {
#line 80
      return (1);
    } else {
#line 79
      if (flags & (1 << 4)) {
        {
#line 79
        tmp___3 = towlower((wint_t )*n);
#line 79
        tmp___4 = tmp___3;
        }
      } else {
#line 79
        tmp___4 = (wint_t )*n;
      }
#line 79
      if (tmp___4 != c) {
#line 80
        return (1);
      }
    }
#line 81
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 84
    tmp___5 = __builtin_expect((long )(flags & (1 << 5)), 0L);
    }
#line 84
    if (tmp___5) {
#line 84
      if (*p == 40) {
        {
#line 88
        res___0 = ext_wmatch(c, p, n, string_end, no_leading_period, flags);
        }
#line 90
        if (res___0 != -1) {
#line 91
          return (res___0);
        }
      }
    }
#line 94
    if ((unsigned long )n != (unsigned long )string_end) {
#line 94
      if (*n == 46) {
#line 94
        if (no_leading_period) {
#line 95
          return (1);
        }
      }
    }
#line 97
    tmp___6 = p;
#line 97
    p ++;
#line 97
    c = (wint_t )*tmp___6;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (! (c == 63U)) {
#line 97
        if (! (c == 42U)) {
#line 97
          goto while_break___0;
        }
      }
#line 99
      if (*p == 40) {
#line 99
        if ((flags & (1 << 5)) != 0) {
          {
#line 101
          tmp___8 = end_wpattern(p);
#line 101
          endp = tmp___8;
          }
#line 102
          if ((unsigned long )endp != (unsigned long )p) {
#line 105
            p = endp;
#line 106
            goto __Cont;
          }
        }
      }
#line 110
      if (c == 63U) {
#line 113
        if ((unsigned long )n == (unsigned long )string_end) {
#line 115
          return (1);
        } else
#line 116
        if (*n == 47) {
          {
#line 116
          tmp___9 = __builtin_expect((long )(flags & 1), 0L);
          }
#line 116
          if (tmp___9) {
#line 120
            return (1);
          } else {
#line 125
            n ++;
          }
        } else {
#line 125
          n ++;
        }
      }
      __Cont: /* CIL Label */ 
#line 97
      tmp___7 = p;
#line 97
      p ++;
#line 97
      c = (wint_t )*tmp___7;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 129
    if (c == 0U) {
#line 135
      if ((flags & 1) == 0) {
#line 135
        tmp___10 = 0;
      } else {
#line 135
        tmp___10 = 1;
      }
#line 135
      result = tmp___10;
#line 137
      if (flags & 1) {
#line 139
        if (flags & (1 << 3)) {
#line 140
          result = 0;
        } else {
          {
#line 143
          tmp___11 = wmemchr(n, 47, (size_t )(string_end - n));
          }
#line 143
          if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 144
            result = 0;
          }
        }
      }
#line 148
      return (result);
    } else {
#line 154
      if (flags & 1) {
#line 154
        tmp___12 = 47;
      } else {
#line 154
        tmp___12 = 0;
      }
      {
#line 154
      tmp___13 = wmemchr(n, tmp___12, (size_t )(string_end - n));
#line 154
      endp___0 = (wchar_t const   *)tmp___13;
      }
#line 156
      if ((unsigned long )endp___0 == (unsigned long )((void *)0)) {
#line 157
        endp___0 = string_end;
      }
#line 159
      if (c == 91U) {
#line 159
        goto _L___1;
      } else {
        {
#line 159
        tmp___22 = __builtin_expect((long )(flags & (1 << 5)), 0L);
        }
#line 159
        if (tmp___22 != 0L) {
#line 159
          if (c == 64U) {
#line 159
            goto _L___4;
          } else
#line 159
          if (c == 43U) {
#line 159
            goto _L___4;
          } else
#line 159
          if (c == 33U) {
            _L___4: /* CIL Label */ 
#line 159
            if (*p == 40) {
              _L___1: /* CIL Label */ 
#line 164
              if (flags & 1) {
#line 164
                tmp___14 = flags;
              } else {
#line 164
                tmp___14 = flags & ~ (1 << 2);
              }
#line 164
              flags2 = tmp___14;
#line 166
              no_leading_period2 = no_leading_period;
#line 168
              p --;
              {
#line 168
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 168
                if (! ((unsigned long )n < (unsigned long )endp___0)) {
#line 168
                  goto while_break___1;
                }
                {
#line 169
                tmp___15 = internal_fnwmatch(p, n, string_end, no_leading_period2,
                                             flags2);
                }
#line 169
                if (tmp___15 == 0) {
#line 171
                  return (0);
                }
#line 168
                n ++;
#line 168
                no_leading_period2 = (_Bool)0;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
#line 159
              goto _L___3;
            }
          } else {
#line 159
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 173
        if (c == 47U) {
#line 173
          if (flags & 1) {
            {
#line 175
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 175
              if ((unsigned long )n < (unsigned long )string_end) {
#line 175
                if (! (*n != 47)) {
#line 175
                  goto while_break___2;
                }
              } else {
#line 175
                goto while_break___2;
              }
#line 176
              n ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 177
            if ((unsigned long )n < (unsigned long )string_end) {
#line 177
              if (*n == 47) {
                {
#line 177
                tmp___16 = internal_fnwmatch(p, n + 1, string_end, (_Bool )(flags & (1 << 2)),
                                             flags);
                }
#line 177
                if (tmp___16 == 0) {
#line 180
                  return (0);
                }
              }
            }
          } else {
#line 173
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 184
          if (flags & 1) {
#line 184
            tmp___17 = flags;
          } else {
#line 184
            tmp___17 = flags & ~ (1 << 2);
          }
#line 184
          flags2___0 = tmp___17;
#line 186
          no_leading_period2___0 = (int )no_leading_period;
#line 188
          if (c == 92U) {
#line 188
            if (! (flags & (1 << 1))) {
#line 189
              c = (wint_t )*p;
            }
          }
#line 190
          if (flags & (1 << 4)) {
            {
#line 190
            tmp___18 = towlower(c);
#line 190
            c = tmp___18;
            }
          } else {
#line 190
            c = c;
          }
#line 191
          p --;
          {
#line 191
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 191
            if (! ((unsigned long )n < (unsigned long )endp___0)) {
#line 191
              goto while_break___3;
            }
#line 192
            if (flags & (1 << 4)) {
              {
#line 192
              tmp___19 = towlower((wint_t )*n);
#line 192
              tmp___20 = tmp___19;
              }
            } else {
#line 192
              tmp___20 = (wint_t )*n;
            }
#line 192
            if (tmp___20 == c) {
              {
#line 192
              tmp___21 = internal_fnwmatch(p, n, string_end, (_Bool )no_leading_period2___0,
                                           flags2___0);
              }
#line 192
              if (tmp___21 == 0) {
#line 195
                return (0);
              }
            }
#line 191
            n ++;
#line 191
            no_leading_period2___0 = 0;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
    }
#line 200
    return (1);
    case_91: /* CIL Label */ 
#line 205
    p_init = p;
#line 206
    n_init = n;
#line 211
    if (posixly_correct == 0) {
      {
#line 212
      tmp___24 = getenv("POSIXLY_CORRECT");
      }
#line 212
      if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
#line 212
        posixly_correct = 1;
      } else {
#line 212
        posixly_correct = -1;
      }
    }
#line 214
    if ((unsigned long )n == (unsigned long )string_end) {
#line 215
      return (1);
    }
#line 217
    if (*n == 46) {
#line 217
      if (no_leading_period) {
#line 218
        return (1);
      }
    }
#line 220
    if (*n == 47) {
#line 220
      if (flags & 1) {
#line 222
        return (1);
      }
    }
#line 224
    if (*p == 33) {
#line 224
      tmp___25 = 1;
    } else
#line 224
    if (posixly_correct < 0) {
#line 224
      if (*p == 94) {
#line 224
        tmp___25 = 1;
      } else {
#line 224
        tmp___25 = 0;
      }
    } else {
#line 224
      tmp___25 = 0;
    }
#line 224
    not = (_Bool )tmp___25;
#line 225
    if (not) {
#line 226
      p ++;
    }
#line 228
    if (flags & (1 << 4)) {
      {
#line 228
      tmp___26 = towlower((wint_t )*n);
#line 228
      fn = tmp___26;
      }
    } else {
#line 228
      fn = (wint_t )*n;
    }
#line 230
    tmp___27 = p;
#line 230
    p ++;
#line 230
    c = (wint_t )*tmp___27;
    {
#line 231
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 233
      if (! (flags & (1 << 1))) {
#line 233
        if (c == 92U) {
#line 235
          if (*p == 0) {
#line 236
            return (1);
          }
#line 237
          if (flags & (1 << 4)) {
            {
#line 237
            tmp___28 = towlower((wint_t )*p);
#line 237
            c = tmp___28;
            }
          } else {
#line 237
            c = (wint_t )*p;
          }
#line 238
          p ++;
#line 240
          goto normal_bracket;
        } else {
#line 233
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 242
      if (c == 91U) {
#line 242
        if (*p == 58) {
#line 246
          c1 = (size_t )0;
#line 250
          startp = p;
          {
#line 252
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 254
            if (c1 == 256UL) {
#line 257
              return (1);
            }
#line 259
            p ++;
#line 259
            c = (wint_t )*p;
#line 260
            if (c == 58U) {
#line 260
              if (*(p + 1) == 93) {
#line 262
                p += 2;
#line 263
                goto while_break___5;
              }
            }
#line 265
            if (c < 97U) {
#line 269
              p = startp;
#line 270
              c = (wint_t )91;
#line 271
              goto normal_bracket;
            } else
#line 265
            if (c >= 122U) {
#line 269
              p = startp;
#line 270
              c = (wint_t )91;
#line 271
              goto normal_bracket;
            }
#line 273
            tmp___29 = c1;
#line 273
            c1 ++;
#line 273
            str[tmp___29] = (wchar_t )c;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 275
          str[c1] = 0;
#line 278
          wt = is_char_class((wchar_t const   *)(str));
          }
#line 279
          if (wt == 0UL) {
#line 281
            return (1);
          }
          {
#line 290
          tmp___30 = iswctype((wint_t )*n, wt);
          }
#line 290
          if (tmp___30) {
#line 291
            goto matched;
          }
#line 308
          tmp___31 = p;
#line 308
          p ++;
#line 308
          c = (wint_t )*tmp___31;
        } else {
#line 242
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 416
      if (c == 0U) {
#line 419
        p = p_init;
#line 420
        n = n_init;
#line 421
        c = (wint_t )91;
#line 422
        goto normal_match;
      } else {
#line 426
        is_range = (_Bool)0;
#line 603
        if (flags & (1 << 4)) {
          {
#line 603
          tmp___32 = towlower(c);
#line 603
          c = tmp___32;
          }
        } else {
#line 603
          c = c;
        }
        normal_bracket: 
#line 609
        if (*p == 45) {
#line 609
          if (*(p + 1) != 0) {
#line 609
            if (*(p + 1) != 93) {
#line 609
              tmp___33 = 1;
            } else {
#line 609
              tmp___33 = 0;
            }
          } else {
#line 609
            tmp___33 = 0;
          }
        } else {
#line 609
          tmp___33 = 0;
        }
#line 609
        is_range = (_Bool )tmp___33;
#line 612
        if (! is_range) {
#line 612
          if (c == fn) {
#line 613
            goto matched;
          }
        }
#line 621
        cold = (wchar_t )c;
#line 622
        tmp___34 = p;
#line 622
        p ++;
#line 622
        c = (wint_t )*tmp___34;
#line 625
        if (c == 45U) {
#line 625
          if (*p != 93) {
#line 846
            tmp___35 = p;
#line 846
            p ++;
#line 846
            cend = (wint_t )*tmp___35;
#line 848
            if (! (flags & (1 << 1))) {
#line 848
              if (cend == 92U) {
#line 849
                tmp___36 = p;
#line 849
                p ++;
#line 849
                cend = (wint_t )*tmp___36;
              }
            }
#line 850
            if (cend == 0U) {
#line 851
              return (1);
            }
#line 854
            if ((wint_t )cold <= fn) {
#line 854
              if (fn <= cend) {
#line 855
                goto matched;
              }
            }
#line 858
            tmp___37 = p;
#line 858
            p ++;
#line 858
            c = (wint_t )*tmp___37;
          }
        }
      }
#line 862
      if (c == 93U) {
#line 863
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 866
    if (! not) {
#line 867
      return (1);
    }
#line 868
    goto switch_break;
    matched: 
    {
#line 872
    while (1) {
      while_continue___6: /* CIL Label */ ;
      ignore_next: 
#line 875
      tmp___38 = p;
#line 875
      p ++;
#line 875
      c = (wint_t )*tmp___38;
#line 877
      if (c == 0U) {
#line 879
        return (1);
      }
#line 881
      if (! (flags & (1 << 1))) {
#line 881
        if (c == 92U) {
#line 883
          if (*p == 0) {
#line 884
            return (1);
          }
#line 886
          p ++;
        } else {
#line 881
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 888
      if (c == 91U) {
#line 888
        if (*p == 58) {
#line 890
          c1___0 = 0;
#line 891
          startp___0 = p;
          {
#line 893
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 895
            p ++;
#line 895
            c = (wint_t )*p;
#line 896
            c1___0 ++;
#line 896
            if (c1___0 == 256) {
#line 897
              return (1);
            }
#line 899
            if (*p == 58) {
#line 899
              if (*(p + 1) == 93) {
#line 900
                goto while_break___7;
              }
            }
#line 902
            if (c < 97U) {
#line 904
              p = startp___0;
#line 905
              goto ignore_next;
            } else
#line 902
            if (c >= 122U) {
#line 904
              p = startp___0;
#line 905
              goto ignore_next;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 908
          p += 2;
#line 909
          tmp___39 = p;
#line 909
          p ++;
#line 909
          c = (wint_t )*tmp___39;
        } else {
#line 888
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 911
      if (c == 91U) {
#line 911
        if (*p == 61) {
#line 913
          p ++;
#line 913
          c = (wint_t )*p;
#line 914
          if (c == 0U) {
#line 915
            return (1);
          }
#line 916
          p ++;
#line 916
          c = (wint_t )*p;
#line 917
          if (c != 61U) {
#line 918
            return (1);
          } else
#line 917
          if (*(p + 1) != 93) {
#line 918
            return (1);
          }
#line 919
          p += 2;
#line 920
          tmp___40 = p;
#line 920
          p ++;
#line 920
          c = (wint_t )*tmp___40;
        } else {
#line 911
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 922
      if (c == 91U) {
#line 922
        if (*p == 46) {
#line 924
          p ++;
          {
#line 925
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 927
            p ++;
#line 927
            c = (wint_t )*p;
#line 928
            if (c == 0U) {
#line 929
              return (1);
            }
#line 931
            if (*p == 46) {
#line 931
              if (*(p + 1) == 93) {
#line 932
                goto while_break___8;
              }
            }
          }
          while_break___8: /* CIL Label */ ;
          }
#line 934
          p += 2;
#line 935
          tmp___41 = p;
#line 935
          p ++;
#line 935
          c = (wint_t )*tmp___41;
        }
      }
#line 872
      if (! (c != 93U)) {
#line 872
        goto while_break___6;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 939
    if (not) {
#line 940
      return (1);
    }
#line 942
    goto switch_break;
    case_33: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_43: /* CIL Label */ 
    {
#line 947
    tmp___42 = __builtin_expect((long )(flags & (1 << 5)), 0L);
    }
#line 947
    if (tmp___42) {
#line 947
      if (*p == 40) {
        {
#line 951
        res___1 = ext_wmatch(c, p, n, string_end, no_leading_period, flags);
        }
#line 952
        if (res___1 != -1) {
#line 953
          return (res___1);
        }
      }
    }
#line 955
    goto normal_match;
    case_47: /* CIL Label */ 
#line 958
    if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 960
      if ((unsigned long )n == (unsigned long )string_end) {
#line 961
        return (1);
      } else
#line 960
      if (c != (wint_t )*n) {
#line 961
        return (1);
      }
#line 963
      new_no_leading_period = (_Bool)1;
#line 964
      goto switch_break;
    }
    normal_match: 
    switch_default: /* CIL Label */ 
#line 969
    if ((unsigned long )n == (unsigned long )string_end) {
#line 970
      return (1);
    } else {
#line 969
      if (flags & (1 << 4)) {
        {
#line 969
        tmp___43 = towlower((wint_t )*n);
#line 969
        tmp___44 = tmp___43;
        }
      } else {
#line 969
        tmp___44 = (wint_t )*n;
      }
#line 969
      if (c != tmp___44) {
#line 970
        return (1);
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 973
    no_leading_period = new_no_leading_period;
#line 974
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 977
  if ((unsigned long )n == (unsigned long )string_end) {
#line 978
    return (0);
  }
#line 980
  if (flags & (1 << 3)) {
#line 980
    if ((unsigned long )n != (unsigned long )string_end) {
#line 980
      if (*n == 47) {
#line 982
        return (0);
      }
    }
  }
#line 984
  return (1);
}
}
#line 988 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
static wchar_t const   *end_wpattern(wchar_t const   *pattern ) 
{ 
  wchar_t const   *p ;
  char *tmp___0 ;
  wchar_t const   *tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 992
  p = pattern;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 995
    p ++;
#line 995
    if (*p == 0) {
#line 997
      return (pattern);
    } else
#line 998
    if (*p == 91) {
#line 1001
      if (posixly_correct == 0) {
        {
#line 1002
        tmp___0 = getenv("POSIXLY_CORRECT");
        }
#line 1002
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1002
          posixly_correct = 1;
        } else {
#line 1002
          posixly_correct = -1;
        }
      }
#line 1006
      p ++;
#line 1006
      if (*p == 33) {
#line 1007
        p ++;
      } else
#line 1006
      if (posixly_correct < 0) {
#line 1006
        if (*p == 94) {
#line 1007
          p ++;
        }
      }
#line 1009
      if (*p == 93) {
#line 1010
        p ++;
      }
      {
#line 1012
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1012
        if (! (*p != 93)) {
#line 1012
          goto while_break___0;
        }
#line 1013
        tmp___1 = p;
#line 1013
        p ++;
#line 1013
        if (*tmp___1 == 0) {
#line 1015
          return (pattern);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 1017
    if (*p == 63) {
#line 1017
      goto _L___0;
    } else
#line 1017
    if (*p == 42) {
#line 1017
      goto _L___0;
    } else
#line 1017
    if (*p == 43) {
#line 1017
      goto _L___0;
    } else
#line 1017
    if (*p == 64) {
#line 1017
      goto _L___0;
    } else
#line 1017
    if (*p == 33) {
      _L___0: /* CIL Label */ 
#line 1017
      if (*(p + 1) == 40) {
        {
#line 1019
        p = end_wpattern(p + 1);
        }
      } else {
#line 1017
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1020
    if (*p == 41) {
#line 1021
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1023
  return (p + 1);
}
}
#line 1027 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c"
static int ext_wmatch(wint_t opt , wchar_t const   *pattern , wchar_t const   *string ,
                      wchar_t const   *string_end , _Bool no_leading_period , int flags ) 
{ 
  wchar_t const   *startp ;
  size_t level ;
  struct patternlist___0 *list ;
  struct patternlist___0 **lastp ;
  size_t pattern_len ;
  size_t tmp ;
  wchar_t const   *p ;
  wchar_t const   *rs ;
  char *tmp___1 ;
  wchar_t const   *tmp___2 ;
  struct patternlist___0 *newp ;
  size_t plen ;
  size_t plensize ;
  size_t newpsize ;
  void *tmp___3 ;
  wchar_t *tmp___4 ;
  size_t tmp___5 ;
  struct patternlist___0 *newp___0 ;
  size_t plen___0 ;
  size_t plensize___0 ;
  size_t newpsize___0 ;
  void *tmp___6 ;
  wchar_t *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  wchar_t *tmp___21 ;
  int tmp___22 ;
  struct patternlist___0 *runp ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 1034
  list = (struct patternlist___0 *)((void *)0);
#line 1039
  lastp = & list;
#line 1040
  tmp = wcslen(pattern);
#line 1040
  pattern_len = tmp;
#line 1046
  level = (size_t )0;
#line 1047
  p = pattern + 1;
#line 1047
  startp = p;
  }
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1048
    if (*p == 0) {
#line 1050
      return (-1);
    } else
#line 1051
    if (*p == 91) {
#line 1054
      if (posixly_correct == 0) {
        {
#line 1055
        tmp___1 = getenv("POSIXLY_CORRECT");
        }
#line 1055
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1055
          posixly_correct = 1;
        } else {
#line 1055
          posixly_correct = -1;
        }
      }
#line 1059
      p ++;
#line 1059
      if (*p == 33) {
#line 1060
        p ++;
      } else
#line 1059
      if (posixly_correct < 0) {
#line 1059
        if (*p == 94) {
#line 1060
          p ++;
        }
      }
#line 1062
      if (*p == 93) {
#line 1063
        p ++;
      }
      {
#line 1065
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1065
        if (! (*p != 93)) {
#line 1065
          goto while_break___0;
        }
#line 1066
        tmp___2 = p;
#line 1066
        p ++;
#line 1066
        if (*tmp___2 == 0) {
#line 1068
          return (-1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 1070
    if (*p == 63) {
#line 1070
      goto _L___0;
    } else
#line 1070
    if (*p == 42) {
#line 1070
      goto _L___0;
    } else
#line 1070
    if (*p == 43) {
#line 1070
      goto _L___0;
    } else
#line 1070
    if (*p == 64) {
#line 1070
      goto _L___0;
    } else
#line 1070
    if (*p == 33) {
      _L___0: /* CIL Label */ 
#line 1070
      if (*(p + 1) == 40) {
#line 1073
        level ++;
      } else {
#line 1070
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1074
    if (*p == 41) {
#line 1076
      tmp___5 = level;
#line 1076
      level --;
#line 1076
      if (tmp___5 == 0UL) {
#line 1099
        if (opt == 63U) {
#line 1099
          plen = pattern_len;
        } else
#line 1099
        if (opt == 64U) {
#line 1099
          plen = pattern_len;
        } else {
#line 1099
          plen = (unsigned long )(p - startp) + 1UL;
        }
#line 1099
        plensize = plen * sizeof(wchar_t );
#line 1099
        newpsize = (unsigned long )(& ((struct patternlist___0 *)0)->str) + plensize;
#line 1099
        if (0xffffffffffffffffUL / sizeof(wchar_t ) < plen) {
#line 1099
          return (-1);
        } else
#line 1099
        if (newpsize < (unsigned long )(& ((struct patternlist___0 *)0)->str)) {
#line 1099
          return (-1);
        } else
#line 1099
        if (8000UL <= newpsize) {
#line 1099
          return (-1);
        }
        {
#line 1099
        tmp___3 = __builtin_alloca(newpsize);
#line 1099
        newp = (struct patternlist___0 *)tmp___3;
#line 1099
        tmp___4 = wmempcpy((wchar_t */* __restrict  */)(newp->str), (wchar_t const   */* __restrict  */)startp,
                           (size_t )(p - startp));
#line 1099
        *tmp___4 = 0;
#line 1099
        newp->next = (struct patternlist *)((void *)0);
#line 1099
        *lastp = newp;
#line 1099
        lastp = (struct patternlist___0 **)(& newp->next);
        }
#line 1100
        goto while_break;
      }
    } else
#line 1103
    if (*p == 124) {
#line 1105
      if (level == 0UL) {
#line 1107
        if (opt == 63U) {
#line 1107
          plen___0 = pattern_len;
        } else
#line 1107
        if (opt == 64U) {
#line 1107
          plen___0 = pattern_len;
        } else {
#line 1107
          plen___0 = (unsigned long )(p - startp) + 1UL;
        }
#line 1107
        plensize___0 = plen___0 * sizeof(wchar_t );
#line 1107
        newpsize___0 = (unsigned long )(& ((struct patternlist___0 *)0)->str) + plensize___0;
#line 1107
        if (0xffffffffffffffffUL / sizeof(wchar_t ) < plen___0) {
#line 1107
          return (-1);
        } else
#line 1107
        if (newpsize___0 < (unsigned long )(& ((struct patternlist___0 *)0)->str)) {
#line 1107
          return (-1);
        } else
#line 1107
        if (8000UL <= newpsize___0) {
#line 1107
          return (-1);
        }
        {
#line 1107
        tmp___6 = __builtin_alloca(newpsize___0);
#line 1107
        newp___0 = (struct patternlist___0 *)tmp___6;
#line 1107
        tmp___7 = wmempcpy((wchar_t */* __restrict  */)(newp___0->str), (wchar_t const   */* __restrict  */)startp,
                           (size_t )(p - startp));
#line 1107
        *tmp___7 = 0;
#line 1107
        newp___0->next = (struct patternlist *)((void *)0);
#line 1107
        *lastp = newp___0;
#line 1107
        lastp = (struct patternlist___0 **)(& newp___0->next);
#line 1108
        startp = p + 1;
        }
      }
    }
#line 1047
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 1111
    __assert_fail("list != ((void *)0)", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c",
                  1111U, "ext_wmatch");
    }
  }
#line 1112
  if (! (*(p + -1) == 41)) {
    {
#line 1112
    __assert_fail("p[-1] == L\')\'", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c",
                  1112U, "ext_wmatch");
    }
  }
  {
#line 1117
  if (opt == 42U) {
#line 1117
    goto case_42;
  }
#line 1122
  if (opt == 43U) {
#line 1122
    goto case_43;
  }
#line 1154
  if (opt == 63U) {
#line 1154
    goto case_63;
  }
#line 1159
  if (opt == 64U) {
#line 1159
    goto case_64;
  }
#line 1175
  if (opt == 33U) {
#line 1175
    goto case_33;
  }
#line 1201
  goto switch_default;
  case_42: /* CIL Label */ 
  {
#line 1118
  tmp___8 = internal_fnwmatch(p, string, string_end, no_leading_period, flags);
  }
#line 1118
  if (tmp___8 == 0) {
#line 1119
    return (0);
  }
  case_43: /* CIL Label */ 
  {
#line 1123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1125
    rs = string;
    {
#line 1125
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1125
      if (! ((unsigned long )rs <= (unsigned long )string_end)) {
#line 1125
        goto while_break___2;
      }
#line 1128
      if (flags & 1) {
#line 1128
        tmp___9 = flags;
      } else {
#line 1128
        tmp___9 = flags & ~ (1 << 2);
      }
      {
#line 1128
      tmp___10 = internal_fnwmatch((wchar_t const   *)(list->str), string, rs, no_leading_period,
                                   tmp___9);
      }
#line 1128
      if (tmp___10 == 0) {
#line 1128
        if (flags & 1) {
#line 1128
          tmp___11 = flags;
        } else {
#line 1128
          tmp___11 = flags & ~ (1 << 2);
        }
#line 1128
        if ((unsigned long )rs == (unsigned long )string) {
#line 1128
          tmp___13 = (int )no_leading_period;
        } else {
#line 1128
          if (*(rs + -1) == 47) {
#line 1128
            if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 1128
              tmp___12 = 1;
            } else {
#line 1128
              tmp___12 = 0;
            }
          } else {
#line 1128
            tmp___12 = 0;
          }
#line 1128
          tmp___13 = tmp___12;
        }
        {
#line 1128
        tmp___14 = internal_fnwmatch(p, rs, string_end, (_Bool )tmp___13, tmp___11);
        }
#line 1128
        if (tmp___14 == 0) {
#line 1147
          return (0);
        } else
#line 1128
        if ((unsigned long )rs != (unsigned long )string) {
#line 1128
          if (flags & 1) {
#line 1128
            tmp___15 = flags;
          } else {
#line 1128
            tmp___15 = flags & ~ (1 << 2);
          }
#line 1128
          if ((unsigned long )rs == (unsigned long )string) {
#line 1128
            tmp___17 = (int )no_leading_period;
          } else {
#line 1128
            if (*(rs + -1) == 47) {
#line 1128
              if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 1128
                tmp___16 = 1;
              } else {
#line 1128
                tmp___16 = 0;
              }
            } else {
#line 1128
              tmp___16 = 0;
            }
#line 1128
            tmp___17 = tmp___16;
          }
          {
#line 1128
          tmp___18 = internal_fnwmatch(pattern - 1, rs, string_end, (_Bool )tmp___17,
                                       tmp___15);
          }
#line 1128
          if (tmp___18 == 0) {
#line 1147
            return (0);
          }
        }
      }
#line 1125
      rs ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1123
    list = (struct patternlist___0 *)list->next;
#line 1123
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 1123
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1152
  return (1);
  case_63: /* CIL Label */ 
  {
#line 1155
  tmp___19 = internal_fnwmatch(p, string, string_end, no_leading_period, flags);
  }
#line 1155
  if (tmp___19 == 0) {
#line 1156
    return (0);
  }
  case_64: /* CIL Label */ 
  {
#line 1160
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1165
    if (flags & 1) {
#line 1165
      tmp___20 = flags;
    } else {
#line 1165
      tmp___20 = flags & ~ (1 << 2);
    }
    {
#line 1165
    tmp___21 = wcscat((wchar_t */* __restrict  */)(list->str), (wchar_t const   */* __restrict  */)p);
#line 1165
    tmp___22 = internal_fnwmatch((wchar_t const   *)tmp___21, string, string_end,
                                 no_leading_period, tmp___20);
    }
#line 1165
    if (tmp___22 == 0) {
#line 1169
      return (0);
    }
#line 1160
    list = (struct patternlist___0 *)list->next;
#line 1160
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 1160
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1173
  return (1);
  case_33: /* CIL Label */ 
#line 1176
  rs = string;
  {
#line 1176
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1176
    if (! ((unsigned long )rs <= (unsigned long )string_end)) {
#line 1176
      goto while_break___4;
    }
#line 1180
    runp = list;
    {
#line 1180
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1180
      if (! ((unsigned long )runp != (unsigned long )((void *)0))) {
#line 1180
        goto while_break___5;
      }
#line 1181
      if (flags & 1) {
#line 1181
        tmp___23 = flags;
      } else {
#line 1181
        tmp___23 = flags & ~ (1 << 2);
      }
      {
#line 1181
      tmp___24 = internal_fnwmatch((wchar_t const   *)(runp->str), string, rs, no_leading_period,
                                   tmp___23);
      }
#line 1181
      if (tmp___24 == 0) {
#line 1183
        goto while_break___5;
      }
#line 1180
      runp = (struct patternlist___0 *)runp->next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1186
    if ((unsigned long )runp == (unsigned long )((void *)0)) {
#line 1186
      if (flags & 1) {
#line 1186
        tmp___25 = flags;
      } else {
#line 1186
        tmp___25 = flags & ~ (1 << 2);
      }
#line 1186
      if ((unsigned long )rs == (unsigned long )string) {
#line 1186
        tmp___27 = (int )no_leading_period;
      } else {
#line 1186
        if (*(rs + -1) == 47) {
#line 1186
          if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 1186
            tmp___26 = 1;
          } else {
#line 1186
            tmp___26 = 0;
          }
        } else {
#line 1186
          tmp___26 = 0;
        }
#line 1186
        tmp___27 = tmp___26;
      }
      {
#line 1186
      tmp___28 = internal_fnwmatch(p, rs, string_end, (_Bool )tmp___27, tmp___25);
      }
#line 1186
      if (tmp___28 == 0) {
#line 1194
        return (0);
      }
    }
#line 1176
    rs ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1199
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 1202
  __assert_fail("! \"Invalid extended matching operator\"", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch_loop.c",
                1202U, "ext_wmatch");
  }
#line 1203
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1206
  return (-1);
}
}
#line 275 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch.c"
int ( __attribute__((__nonnull__(1,2))) gnu_fnmatch)(char const   *pattern , char const   *string ,
                                                     int flags ) 
{ 
  mbstate_t ps ;
  size_t patsize ;
  size_t strsize ;
  size_t totsize ;
  wchar_t *wpattern ;
  wchar_t *wstring ;
  int res ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  size_t tmp___15 ;
  long tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 280
  tmp___15 = __ctype_get_mb_cur_max();
#line 280
  tmp___16 = __builtin_expect((long )tmp___15, 1L);
  }
#line 280
  if (tmp___16 != 1L) {
    {
#line 292
    memset((void *)(& ps), '\000', sizeof(ps));
#line 293
    tmp = mbsrtowcs((wchar_t */* __restrict  */)((void *)0), (char const   **/* __restrict  */)(& pattern),
                    (size_t )0, (mbstate_t */* __restrict  */)(& ps));
#line 293
    patsize = tmp + 1UL;
#line 294
    tmp___14 = __builtin_expect((long )(patsize != 0UL), 1L);
    }
#line 294
    if (tmp___14) {
      {
#line 296
      tmp___0 = mbsinit((mbstate_t const   *)(& ps));
      }
#line 296
      if (! tmp___0) {
        {
#line 296
        __assert_fail("mbsinit (&ps)", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch.c",
                      296U, "gnu_fnmatch");
        }
      }
      {
#line 297
      tmp___1 = mbsrtowcs((wchar_t */* __restrict  */)((void *)0), (char const   **/* __restrict  */)(& string),
                          (size_t )0, (mbstate_t */* __restrict  */)(& ps));
#line 297
      strsize = tmp___1 + 1UL;
#line 298
      tmp___13 = __builtin_expect((long )(strsize != 0UL), 1L);
      }
#line 298
      if (tmp___13) {
        {
#line 300
        tmp___2 = mbsinit((mbstate_t const   *)(& ps));
        }
#line 300
        if (! tmp___2) {
          {
#line 300
          __assert_fail("mbsinit (&ps)", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch.c",
                        300U, "gnu_fnmatch");
          }
        }
#line 301
        totsize = patsize + strsize;
#line 302
        if (patsize <= totsize) {
#line 302
          if (totsize <= 0xffffffffffffffffUL / sizeof(wchar_t )) {
#line 302
            tmp___4 = 0;
          } else {
#line 302
            tmp___4 = 1;
          }
        } else {
#line 302
          tmp___4 = 1;
        }
        {
#line 302
        tmp___5 = __builtin_expect((long )tmp___4, 0L);
        }
#line 302
        if (tmp___5) {
          {
#line 306
          tmp___3 = __errno_location();
#line 306
          *tmp___3 = 12;
          }
#line 307
          return (-1);
        }
        {
#line 311
        tmp___10 = __builtin_expect((long )(totsize < 2000UL), 1L);
        }
#line 311
        if (tmp___10) {
          {
#line 312
          tmp___6 = __builtin_alloca(totsize * sizeof(wchar_t ));
#line 312
          wpattern = (wchar_t *)tmp___6;
          }
        } else {
          {
#line 315
          tmp___7 = malloc(totsize * sizeof(wchar_t ));
#line 315
          wpattern = (wchar_t *)tmp___7;
#line 316
          tmp___9 = __builtin_expect((long )(! wpattern), 0L);
          }
#line 316
          if (tmp___9) {
            {
#line 318
            tmp___8 = __errno_location();
#line 318
            *tmp___8 = 12;
            }
#line 319
            return (-1);
          }
        }
        {
#line 322
        wstring = wpattern + patsize;
#line 325
        mbsrtowcs((wchar_t */* __restrict  */)wpattern, (char const   **/* __restrict  */)(& pattern),
                  patsize, (mbstate_t */* __restrict  */)(& ps));
#line 326
        tmp___11 = mbsinit((mbstate_t const   *)(& ps));
        }
#line 326
        if (! tmp___11) {
          {
#line 326
          __assert_fail("mbsinit (&ps)", "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fnmatch.c",
                        326U, "gnu_fnmatch");
          }
        }
        {
#line 327
        mbsrtowcs((wchar_t */* __restrict  */)wstring, (char const   **/* __restrict  */)(& string),
                  strsize, (mbstate_t */* __restrict  */)(& ps));
#line 329
        res = internal_fnwmatch((wchar_t const   *)wpattern, (wchar_t const   *)wstring,
                                (wchar_t const   *)((wstring + strsize) - 1), (_Bool )(flags & (1 << 2)),
                                flags);
#line 332
        tmp___12 = __builtin_expect((long )(! (totsize < 2000UL)), 0L);
        }
#line 332
        if (tmp___12) {
          {
#line 333
          free((void *)wpattern);
          }
        }
#line 334
        return (res);
      }
    }
  }
  {
#line 341
  tmp___17 = strlen(string);
#line 341
  tmp___18 = internal_fnmatch(pattern, string, string + tmp___17, (_Bool )(flags & (1 << 2)),
                              flags);
  }
#line 341
  return (tmp___18);
}
}
#line 22 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/filenamecat.h"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 26
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 34 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/filenamecat.c"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 37
  tmp = mfile_name_concat(dir, abase, base_in_result);
#line 37
  p = tmp;
  }
#line 38
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 39
    xalloc_die();
    }
  }
#line 40
  return (p);
}
}
#line 37 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/filenamecat-lgpl.c"
static char const   *longest_relative_suffix(char const   *f ) 
{ 


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return (f);
}
}
#line 60 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/filenamecat-lgpl.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   *tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 63
  tmp = last_component(dir);
#line 63
  dirbase = (char const   *)tmp;
#line 64
  tmp___0 = base_len(dirbase);
#line 64
  dirbaselen = tmp___0;
#line 65
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
  }
#line 66
  if (dirbaselen) {
#line 66
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
#line 66
      tmp___1 = 1;
    } else {
#line 66
      tmp___1 = 0;
    }
  } else {
#line 66
    tmp___1 = 0;
  }
  {
#line 66
  needs_separator = (size_t )tmp___1;
#line 68
  tmp___2 = longest_relative_suffix(abase);
#line 68
  base = tmp___2;
#line 69
  tmp___3 = strlen(base);
#line 69
  baselen = tmp___3;
#line 71
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
#line 71
  p_concat = (char *)tmp___4;
  }
#line 74
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
#line 75
    return ((char *)((void *)0));
  }
  {
#line 77
  tmp___5 = mempcpy((void */* __restrict  */)p_concat, (void const   */* __restrict  */)dir,
                    dirlen);
#line 77
  p = (char *)tmp___5;
#line 78
  *p = (char )'/';
#line 79
  p += needs_separator;
  }
#line 81
  if (base_in_result) {
#line 82
    if ((int const   )*(abase + 0) == 47) {
#line 82
      tmp___6 = 1;
    } else {
#line 82
      tmp___6 = 0;
    }
#line 82
    *base_in_result = p - tmp___6;
  }
  {
#line 84
  tmp___7 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)base,
                    baselen);
#line 84
  p = (char *)tmp___7;
#line 85
  *p = (char )'\000';
  }
#line 87
  return (p_concat);
}
}
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/file-type.h"
char const   *file_type(struct stat  const  *st ) ;
#line 28 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/file-type.c"
char const   *file_type(struct stat  const  *st ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___12 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 37
  if ((st->st_mode & 61440U) == 32768U) {
#line 38
    if (st->st_size == 0L) {
      {
#line 38
      tmp = gettext("regular empty file");
#line 38
      tmp___1 = tmp;
      }
    } else {
      {
#line 38
      tmp___0 = gettext("regular file");
#line 38
      tmp___1 = tmp___0;
      }
    }
#line 38
    return ((char const   *)tmp___1);
  }
#line 40
  if ((st->st_mode & 61440U) == 16384U) {
    {
#line 41
    tmp___2 = gettext("directory");
    }
#line 41
    return ((char const   *)tmp___2);
  }
#line 43
  if ((st->st_mode & 61440U) == 24576U) {
    {
#line 44
    tmp___3 = gettext("block special file");
    }
#line 44
    return ((char const   *)tmp___3);
  }
#line 46
  if ((st->st_mode & 61440U) == 8192U) {
    {
#line 47
    tmp___4 = gettext("character special file");
    }
#line 47
    return ((char const   *)tmp___4);
  }
#line 49
  if ((st->st_mode & 61440U) == 4096U) {
    {
#line 50
    tmp___5 = gettext("fifo");
    }
#line 50
    return ((char const   *)tmp___5);
  }
#line 52
  if ((st->st_mode & 61440U) == 40960U) {
    {
#line 53
    tmp___6 = gettext("symbolic link");
    }
#line 53
    return ((char const   *)tmp___6);
  }
#line 55
  if ((st->st_mode & 61440U) == 49152U) {
    {
#line 56
    tmp___7 = gettext("socket");
    }
#line 56
    return ((char const   *)tmp___7);
  }
#line 58
  if (st->st_mode - st->st_mode) {
    {
#line 59
    tmp___8 = gettext("message queue");
    }
#line 59
    return ((char const   *)tmp___8);
  }
#line 61
  if (st->st_mode - st->st_mode) {
    {
#line 62
    tmp___9 = gettext("semaphore");
    }
#line 62
    return ((char const   *)tmp___9);
  }
#line 64
  if (st->st_mode - st->st_mode) {
    {
#line 65
    tmp___10 = gettext("shared memory object");
    }
#line 65
    return ((char const   *)tmp___10);
  }
  {
#line 70
  tmp___12 = gettext("weird file");
  }
#line 70
  return ((char const   *)tmp___12);
}
}
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 393 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 229 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 165 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list arg ;
  int result ;
  int target ;
  int tmp___0 ;
  int *tmp___1 ;
  int flags ;
  int tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *p ;
  void *tmp___7 ;

  {
  {
#line 169
  result = -1;
#line 170
  __builtin_va_start(arg, action);
  }
  {
#line 214
  if (action == 1030) {
#line 214
    goto case_1030;
  }
#line 295
  goto switch_default;
  case_1030: /* CIL Label */ 
  {
#line 216
  tmp___0 = __builtin_va_arg(arg, int );
#line 216
  target = tmp___0;
  }
#line 230
  if (0 <= have_dupfd_cloexec) {
    {
#line 232
    result = fcntl(fd, action, target);
    }
#line 233
    if (0 <= result) {
#line 235
      have_dupfd_cloexec = 1;
    } else {
      {
#line 233
      tmp___1 = __errno_location();
      }
#line 233
      if (*tmp___1 != 22) {
#line 235
        have_dupfd_cloexec = 1;
      } else {
        {
#line 243
        result = rpl_fcntl(fd, 0, target);
        }
#line 244
        if (result < 0) {
#line 245
          goto switch_break;
        }
#line 246
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    {
#line 250
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 251
  if (0 <= result) {
#line 251
    if (have_dupfd_cloexec == -1) {
      {
#line 253
      tmp___2 = fcntl(result, 1);
#line 253
      flags = tmp___2;
      }
#line 254
      if (flags < 0) {
#line 254
        goto _L;
      } else {
        {
#line 254
        tmp___5 = fcntl(result, 2, flags | 1);
        }
#line 254
        if (tmp___5 == -1) {
          _L: /* CIL Label */ 
          {
#line 256
          tmp___3 = __errno_location();
#line 256
          saved_errno = *tmp___3;
#line 257
          close(result);
#line 258
          tmp___4 = __errno_location();
#line 258
          *tmp___4 = saved_errno;
#line 259
          result = -1;
          }
        }
      }
    }
  }
#line 262
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 298
  tmp___7 = __builtin_va_arg(arg, void *);
#line 298
  p = tmp___7;
#line 299
  result = fcntl(fd, action, p);
  }
#line 303
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 306
  __builtin_va_end(arg);
  }
#line 307
  return (result);
}
}
#line 24 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 249 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 810
extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
#line 282 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 42 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.h"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) ;
#line 44
struct exclude *new_exclude(void) ;
#line 45
void free_exclude(struct exclude *ex ) ;
#line 46
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
#line 47
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name , int options ,
                     char line_end ) ;
#line 49
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 50
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
#line 114 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) 
{ 
  char const   *cset ;
  size_t n ;
  size_t tmp ;
  char *__cil_tmp6 ;

  {
#line 117
  cset = "\\?*[]";
#line 118
  if (options & (1 << 1)) {
#line 119
    cset ++;
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! *str) {
#line 120
      goto while_break;
    }
    {
#line 122
    tmp = strcspn(str, cset);
#line 122
    n = tmp;
    }
#line 123
    if ((int const   )*(str + n) == 0) {
#line 124
      goto while_break;
    } else
#line 125
    if ((int const   )*(str + n) == 92) {
#line 127
      str += n + 1UL;
#line 128
      if (*str) {
#line 129
        str ++;
      }
    } else {
#line 132
      return ((_Bool)1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return ((_Bool)0);
}
}
#line 137 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static void unescape_pattern(char *str ) 
{ 
  int inset ;
  char *q ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;

  {
#line 140
  inset = 0;
#line 141
  q = str;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (inset) {
#line 146
      if ((int )*q == 93) {
#line 147
        inset = 0;
      }
    } else
#line 149
    if ((int )*q == 91) {
#line 150
      inset = 1;
    } else
#line 151
    if ((int )*q == 92) {
#line 152
      q ++;
    }
#line 142
    tmp = str;
#line 142
    str ++;
#line 142
    tmp___1 = q;
#line 142
    q ++;
#line 142
    tmp___0 = *tmp___1;
#line 142
    *tmp = tmp___0;
#line 142
    if (! tmp___0) {
#line 142
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return;
}
}
#line 159 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
struct exclude *new_exclude(void) 
{ 
  struct exclude *tmp ;
  void *tmp___0 ;

  {
  {
#line 162
  tmp___0 = xzalloc(sizeof(*tmp));
  }
#line 162
  return ((struct exclude *)tmp___0);
}
}
#line 166 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static size_t string_hasher(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
  {
#line 169
  p = (char const   *)data;
#line 170
  tmp = hash_string(p, n_buckets);
  }
#line 170
  return (tmp);
}
}
#line 174 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static size_t string_hasher_ci(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value___0 ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 177
  p = (char const   *)data;
#line 179
  value___0 = (size_t )0;
#line 181
  iter.cur.ptr = p;
#line 181
  iter.in_shift = (_Bool)0;
#line 181
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 181
  iter.next_done = (_Bool)0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 181
    mbuiter_multi_next(& iter);
    }
#line 181
    if (iter.cur.wc_valid) {
#line 181
      if (iter.cur.wc == 0) {
#line 181
        tmp___0 = 0;
      } else {
#line 181
        tmp___0 = 1;
      }
    } else {
#line 181
      tmp___0 = 1;
    }
#line 181
    if (! tmp___0) {
#line 181
      goto while_break;
    }
#line 183
    m = iter.cur;
#line 186
    if (m.wc_valid) {
      {
#line 187
      tmp = towlower((wint_t )m.wc);
#line 187
      wc = (wchar_t )tmp;
      }
    } else {
#line 189
      wc = (wchar_t )*(m.ptr);
    }
#line 191
    value___0 = (value___0 * 31UL + (size_t )wc) % n_buckets;
#line 181
    iter.cur.ptr += iter.cur.bytes;
#line 181
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (value___0);
}
}
#line 198 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static _Bool string_compare(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 201
  p1 = (char const   *)data1;
#line 202
  p2 = (char const   *)data2;
#line 203
  tmp = strcmp(p1, p2);
  }
#line 203
  return ((_Bool )(tmp == 0));
}
}
#line 207 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static _Bool string_compare_ci(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 210
  p1 = (char const   *)data1;
#line 211
  p2 = (char const   *)data2;
#line 212
  tmp = mbscasecmp(p1, p2);
  }
#line 212
  return ((_Bool )(tmp == 0));
}
}
#line 215 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static void string_free(void *data ) 
{ 


  {
  {
#line 218
  free(data);
  }
#line 219
  return;
}
}
#line 223 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static struct exclude_segment *new_exclude_segment(struct exclude *ex , enum exclude_type type ,
                                                   int options ) 
{ 
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 226
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 226
  sp = (struct exclude_segment *)tmp;
#line 227
  sp->type = type;
#line 228
  sp->options = options;
  }
  {
#line 231
  if ((unsigned int )type == 1U) {
#line 231
    goto case_1;
  }
#line 234
  if ((unsigned int )type == 0U) {
#line 234
    goto case_0;
  }
#line 229
  goto switch_break;
  case_1: /* CIL Label */ 
#line 232
  goto switch_break;
  case_0: /* CIL Label */ 
#line 235
  if (options & (1 << 4)) {
#line 235
    tmp___0 = & string_compare_ci;
  } else {
#line 235
    tmp___0 = & string_compare;
  }
#line 235
  if (options & (1 << 4)) {
#line 235
    tmp___1 = & string_hasher_ci;
  } else {
#line 235
    tmp___1 = & string_hasher;
  }
  {
#line 235
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free);
  }
#line 243
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 245
  if (ex->tail) {
#line 246
    (ex->tail)->next = sp;
  } else {
#line 248
    ex->head = sp;
  }
#line 249
  ex->tail = sp;
#line 250
  return (sp);
}
}
#line 254 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static void free_exclude_segment(struct exclude_segment *seg ) 
{ 


  {
  {
#line 259
  if ((unsigned int )seg->type == 1U) {
#line 259
    goto case_1;
  }
#line 263
  if ((unsigned int )seg->type == 0U) {
#line 263
    goto case_0;
  }
#line 257
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 260
  free((void *)seg->v.pat.exclude);
  }
#line 261
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 264
  hash_free(seg->v.table);
  }
#line 265
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 267
  free((void *)seg);
  }
#line 268
  return;
}
}
#line 271 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
void free_exclude(struct exclude *ex ) 
{ 
  struct exclude_segment *seg ;
  struct exclude_segment *next ;

  {
#line 275
  seg = ex->head;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! seg) {
#line 275
      goto while_break;
    }
    {
#line 277
    next = seg->next;
#line 278
    free_exclude_segment(seg);
#line 279
    seg = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  free((void *)ex);
  }
#line 282
  return;
}
}
#line 287 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 290
  if (! (options & (1 << 3))) {
#line 291
    if (options & (1 << 4)) {
      {
#line 291
      tmp = mbscasecmp(pattern, f);
#line 291
      tmp___1 = tmp;
      }
    } else {
      {
#line 291
      tmp___0 = strcmp(pattern, f);
#line 291
      tmp___1 = tmp___0;
      }
    }
#line 291
    return (tmp___1);
  } else
#line 294
  if (! (options & (1 << 4))) {
    {
#line 296
    tmp___2 = strlen(pattern);
#line 296
    patlen = tmp___2;
#line 297
    tmp___3 = strncmp(pattern, f, patlen);
#line 297
    r = tmp___3;
    }
#line 298
    if (! r) {
#line 300
      r = (int )*(f + patlen);
#line 301
      if (r == 47) {
#line 302
        r = 0;
      }
    }
#line 304
    return (r);
  } else {
    {
#line 315
    tmp___4 = xstrdup(f);
#line 315
    fcopy = tmp___4;
#line 318
    p = fcopy;
    }
    {
#line 318
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 320
      p = strchr((char const   *)p, '/');
      }
#line 321
      if (p) {
#line 322
        *p = (char )'\000';
      }
      {
#line 323
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 324
      if (! p) {
#line 325
        goto while_break;
      } else
#line 324
      if (r___0 <= 0) {
#line 325
        goto while_break;
      }
#line 318
      tmp___5 = p;
#line 318
      p ++;
#line 318
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 327
    free((void *)fcopy);
    }
#line 328
    return (r___0);
  }
}
}
#line 332 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) 
{ 
  int (*matcher)(char const   * , char const   * , int  ) ;
  int ( __attribute__((__nonnull__(1,2))) (*tmp))(char const   *pattern , char const   *f ,
                                                  int options ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
#line 335
  if (options & (1 << 28)) {
#line 335
    tmp = & gnu_fnmatch;
  } else {
#line 335
    tmp = (int ( __attribute__((__nonnull__(1,2))) (*))(char const   *pattern , char const   *f ,
                                                        int options ))(& fnmatch_no_wildcards);
  }
  {
#line 335
  matcher = (int (*)(char const   * , char const   * , int  ))tmp;
#line 339
  tmp___0 = (*matcher)(pattern, f, options);
#line 339
  matched = (_Bool )(tmp___0 == 0);
  }
#line 342
  if (! (options & (1 << 30))) {
#line 343
    p = f;
    {
#line 343
    while (1) {
      while_continue: /* CIL Label */ ;
#line 343
      if (*p) {
#line 343
        if (! (! matched)) {
#line 343
          goto while_break;
        }
      } else {
#line 343
        goto while_break;
      }
#line 344
      if ((int const   )*p == 47) {
#line 344
        if ((int const   )*(p + 1) != 47) {
          {
#line 345
          tmp___1 = (*matcher)(pattern, p + 1, options);
#line 345
          matched = (_Bool )(tmp___1 == 0);
          }
        }
      }
#line 343
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 347
  return (matched);
}
}
#line 352 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static _Bool excluded_file_pattern_p(struct exclude_segment  const  *seg , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool excluded___0 ;
  char const   *pattern ;
  int options ;
  _Bool tmp ;

  {
#line 355
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 356
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 358
  excluded___0 = (_Bool )(! (! ((exclude + 0)->options & (int const   )(1 << 29))));
#line 361
  i = (size_t )0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (i < exclude_count)) {
#line 361
      goto while_break;
    }
    {
#line 363
    pattern = (char const   *)(exclude + i)->pattern;
#line 364
    options = (int )(exclude + i)->options;
#line 365
    tmp = exclude_fnmatch(pattern, f, options);
    }
#line 365
    if (tmp) {
#line 366
      return ((_Bool )(! excluded___0));
    }
#line 361
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return (excluded___0);
}
}
#line 374 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
static _Bool excluded_file_name_p(struct exclude_segment  const  *seg , char const   *f ,
                                  char *buffer ) 
{ 
  int options ;
  _Bool excluded___0 ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 378
  options = (int )seg->options;
#line 379
  excluded___0 = (_Bool )(! (! (options & (1 << 29))));
#line 380
  table = (Hash_table *)seg->v.table;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 385
    strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)f);
    }
    {
#line 387
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 389
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer);
      }
#line 389
      if (tmp) {
#line 390
        return ((_Bool )(! excluded___0));
      }
#line 391
      if (options & (1 << 3)) {
        {
#line 393
        tmp___0 = strrchr((char const   *)buffer, '/');
#line 393
        p = tmp___0;
        }
#line 394
        if (p) {
#line 396
          *p = (char)0;
#line 397
          goto while_continue___0;
        }
      }
#line 400
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 403
    if (! (options & (1 << 30))) {
      {
#line 405
      tmp___1 = strchr(f, '/');
#line 405
      f = (char const   *)tmp___1;
      }
#line 406
      if (f) {
#line 407
        f ++;
      }
    } else {
#line 410
      goto while_break;
    }
#line 382
    if (! f) {
#line 382
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return (excluded___0);
}
}
#line 418 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ 
  struct exclude_segment *seg ;
  _Bool excluded___0 ;
  char *filename ;
  _Bool rc ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 423
  filename = (char *)((void *)0);
#line 426
  if (! ex->head) {
#line 427
    return ((_Bool)0);
  }
#line 430
  excluded___0 = (_Bool )(! (! ((ex->head)->options & (1 << 29))));
#line 433
  seg = (struct exclude_segment *)ex->head;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! seg) {
#line 433
      goto while_break;
    }
    {
#line 439
    if ((unsigned int )seg->type == 1U) {
#line 439
      goto case_1;
    }
#line 443
    if ((unsigned int )seg->type == 0U) {
#line 443
      goto case_0;
    }
#line 449
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 440
    rc = excluded_file_pattern_p((struct exclude_segment  const  *)seg, f);
    }
#line 441
    goto switch_break;
    case_0: /* CIL Label */ 
#line 444
    if (! filename) {
      {
#line 445
      tmp = strlen(f);
#line 445
      tmp___0 = xmalloc(tmp + 1UL);
#line 445
      filename = (char *)tmp___0;
      }
    }
    {
#line 446
    rc = excluded_file_name_p((struct exclude_segment  const  *)seg, f, filename);
    }
#line 447
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 450
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 452
    if ((int )rc != (int )excluded___0) {
#line 454
      excluded___0 = rc;
#line 455
      goto while_break;
    }
#line 433
    seg = seg->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  free((void *)filename);
  }
#line 459
  return (excluded___0);
}
}
#line 464 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options ) 
{ 
  struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  char *str ;
  char *p ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
#line 469
  if (options & (1 << 28)) {
    {
#line 469
    tmp___2 = fnmatch_pattern_has_wildcards(pattern, options);
    }
#line 469
    if (tmp___2) {
#line 475
      if (ex->tail) {
#line 475
        if ((unsigned int )(ex->tail)->type == 1U) {
#line 475
          if (((ex->tail)->options & (1 << 29)) == (options & (1 << 29))) {
#line 478
            seg = ex->tail;
          } else {
            {
#line 480
            seg = new_exclude_segment(ex, (enum exclude_type )1, options);
            }
          }
        } else {
          {
#line 480
          seg = new_exclude_segment(ex, (enum exclude_type )1, options);
          }
        }
      } else {
        {
#line 480
        seg = new_exclude_segment(ex, (enum exclude_type )1, options);
        }
      }
#line 482
      pat = & seg->v.pat;
#line 483
      if (pat->exclude_count == pat->exclude_alloc) {
        {
#line 484
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
#line 484
        pat->exclude = (struct patopts *)tmp;
        }
      }
#line 486
      tmp___0 = pat->exclude_count;
#line 486
      (pat->exclude_count) ++;
#line 486
      patopts = pat->exclude + tmp___0;
#line 487
      patopts->pattern = pattern;
#line 488
      patopts->options = options;
    } else {
#line 469
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 495
    if (ex->tail) {
#line 495
      if ((unsigned int )(ex->tail)->type == 0U) {
#line 495
        if (((ex->tail)->options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4))) == (options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4)))) {
#line 498
          seg = ex->tail;
        } else {
          {
#line 500
          seg = new_exclude_segment(ex, (enum exclude_type )0, options);
          }
        }
      } else {
        {
#line 500
        seg = new_exclude_segment(ex, (enum exclude_type )0, options);
        }
      }
    } else {
      {
#line 500
      seg = new_exclude_segment(ex, (enum exclude_type )0, options);
      }
    }
    {
#line 502
    str = xstrdup(pattern);
    }
#line 503
    if (options & (1 << 28)) {
      {
#line 504
      unescape_pattern(str);
      }
    }
    {
#line 505
    tmp___1 = hash_insert(seg->v.table, (void const   *)str);
#line 505
    p = (char *)tmp___1;
    }
#line 506
    if ((unsigned long )p != (unsigned long )str) {
      {
#line 507
      free((void *)str);
      }
    }
  }
#line 509
  return;
}
}
#line 516 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name , int options ,
                     char line_end ) 
{ 
  _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  char *buf___0 ;
  char *p ;
  char const   *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *pattern_end ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp30 ;

  {
#line 521
  if ((int const   )*(file_name + 0) == 45) {
#line 521
    if (! *(file_name + 1)) {
#line 521
      tmp = 1;
    } else {
#line 521
      tmp = 0;
    }
  } else {
#line 521
    tmp = 0;
  }
#line 521
  use_stdin = (_Bool )tmp;
#line 523
  buf___0 = (char *)((void *)0);
#line 527
  buf_alloc = (size_t )0;
#line 528
  buf_count = (size_t )0;
#line 530
  e = 0;
#line 532
  if (use_stdin) {
#line 533
    in = stdin;
  } else {
    {
#line 534
    in = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
    }
#line 534
    if (! in) {
#line 535
      return (-1);
    }
  }
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 537
    c = getc_unlocked(in);
    }
#line 537
    if (! (c != -1)) {
#line 537
      goto while_break;
    }
#line 539
    if (buf_count == buf_alloc) {
      {
#line 540
      tmp___0 = x2realloc((void *)buf___0, & buf_alloc);
#line 540
      buf___0 = (char *)tmp___0;
      }
    }
#line 541
    tmp___1 = buf_count;
#line 541
    buf_count ++;
#line 541
    *(buf___0 + tmp___1) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 544
  tmp___3 = ferror_unlocked(in);
  }
#line 544
  if (tmp___3) {
    {
#line 545
    tmp___2 = __errno_location();
#line 545
    e = *tmp___2;
    }
  }
#line 547
  if (! use_stdin) {
    {
#line 547
    tmp___5 = fclose(in);
    }
#line 547
    if (tmp___5 != 0) {
      {
#line 548
      tmp___4 = __errno_location();
#line 548
      e = *tmp___4;
      }
    }
  }
  {
#line 550
  tmp___6 = xrealloc((void *)buf___0, buf_count + 1UL);
#line 550
  buf___0 = (char *)tmp___6;
#line 551
  *(buf___0 + buf_count) = line_end;
  }
#line 552
  if (buf_count == 0UL) {
#line 552
    tmp___7 = 0;
  } else
#line 552
  if ((int )*(buf___0 + (buf_count - 1UL)) == (int )line_end) {
#line 552
    tmp___7 = 0;
  } else {
#line 552
    tmp___7 = 1;
  }
#line 552
  lim = (char const   *)((buf___0 + buf_count) + tmp___7);
#line 553
  pattern = (char const   *)buf___0;
#line 555
  p = buf___0;
  {
#line 555
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 555
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 555
      goto while_break___0;
    }
#line 556
    if ((int )*p == (int )line_end) {
      {
#line 558
      pattern_end = p;
#line 560
      tmp___9 = __ctype_b_loc();
      }
#line 560
      if ((int const   )*(*tmp___9 + (int )((unsigned char )line_end)) & 8192) {
        {
#line 562
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 563
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
#line 564
            goto next_pattern;
          } else {
            {
#line 565
            tmp___8 = __ctype_b_loc();
            }
#line 565
            if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
#line 566
              goto while_break___1;
            }
          }
#line 562
          pattern_end --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 569
      *pattern_end = (char )'\000';
#line 570
      (*add_func)(ex, pattern, options);
      }
      next_pattern: 
#line 573
      pattern = (char const   *)(p + 1);
    }
#line 555
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 576
  tmp___10 = __errno_location();
#line 576
  *tmp___10 = e;
  }
#line 577
  if (e) {
#line 577
    tmp___11 = -1;
  } else {
#line 577
    tmp___11 = 0;
  }
#line 577
  return (tmp___11);
}
}
#line 36 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/dirname.h"
char *dir_name(char const   *file ) ;
#line 39
char *mdir_name(char const   *file ) ;
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/dirname.c"
char *dir_name(char const   *file ) 
{ 
  char *result ;
  char *tmp ;

  {
  {
#line 34
  tmp = mdir_name(file);
#line 34
  result = tmp;
  }
#line 35
  if (! result) {
    {
#line 36
    xalloc_die();
    }
  }
#line 37
  return (result);
}
}
#line 41 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/dirname.h"
size_t dir_len(char const   *file ) ;
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 357 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 18 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/cmpbuf.h"
size_t block_read(int fd , char *buf___0 , size_t nbytes ) ;
#line 19
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) ;
#line 44 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/cmpbuf.c"
size_t block_read(int fd , char *buf___0 , size_t nbytes ) 
{ 
  char *bp ;
  char const   *buflim ;
  size_t readlim ;
  size_t bytes_remaining ;
  size_t bytes_to_read ;
  size_t tmp ;
  ssize_t nread ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
#line 47
  bp = buf___0;
#line 48
  buflim = (char const   *)(buf___0 + nbytes);
#line 49
  readlim = 9223372036854775807UL;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    bytes_remaining = (size_t )(buflim - (char const   *)bp);
#line 54
    if (bytes_remaining <= readlim) {
#line 54
      tmp = bytes_remaining;
    } else {
#line 54
      tmp = readlim;
    }
    {
#line 54
    bytes_to_read = tmp;
#line 55
    tmp___0 = read(fd, (void *)bp, bytes_to_read);
#line 55
    nread = tmp___0;
    }
#line 56
    if (nread <= 0L) {
#line 58
      if (nread == 0L) {
#line 59
        goto while_break;
      }
      {
#line 63
      tmp___1 = __errno_location();
      }
#line 63
      if (*tmp___1 == 22) {
#line 63
        if (2147483647UL < bytes_to_read) {
#line 65
          readlim = (size_t )2147483647;
#line 66
          goto __Cont;
        }
      }
#line 77
      return (0xffffffffffffffffUL);
    }
#line 79
    bp += nread;
    __Cont: /* CIL Label */ 
#line 51
    if (! ((unsigned long )bp < (unsigned long )buflim)) {
#line 51
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return ((size_t )(bp - buf___0));
}
}
#line 90 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/cmpbuf.c"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) 
{ 
  size_t lcm ;
  size_t m ;
  size_t n ;
  size_t q ;
  size_t r ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 96
  if (! a) {
#line 97
    if (b) {
#line 97
      tmp = b;
    } else {
#line 97
      tmp = (size_t )8192;
    }
#line 97
    return (tmp);
  }
#line 98
  if (! b) {
#line 99
    return (a);
  }
#line 102
  m = a;
#line 102
  n = b;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    r = m % n;
#line 102
    if (! (r != 0UL)) {
#line 102
      goto while_break;
    }
#line 103
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 102
    m = n;
#line 102
    n = r;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  q = a / n;
#line 107
  lcm = q * b;
#line 108
  if (lcm <= lcm_max) {
#line 108
    if (lcm / b == q) {
#line 108
      tmp___0 = lcm;
    } else {
#line 108
      tmp___0 = a;
    }
  } else {
#line 108
    tmp___0 = a;
  }
#line 108
  return (tmp___0);
}
}
#line 50 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 138 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.h"
int c_tolower(int c ) ;
#line 29 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  } else
#line 36
  if (n == 0UL) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
#line 44
    n --;
    }
#line 44
    if (n == 0UL) {
#line 45
      goto while_break;
    } else
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 29 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
    }
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 138 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 598
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 65 "/usr/include/sigsegv.h"
extern int sigsegv_install_handler(int (*handler)(void *fault_address , int serious ) ) ;
#line 108
extern int stackoverflow_install_handler(void (*handler)(int emergency , stackoverflow_context_t scp ) ,
                                         void *extra_stack , unsigned long extra_stack_size ) ;
#line 44 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.h"
int c_stack_action(void (*action)(int  ) ) ;
#line 95 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
static void (* volatile  segv_action)(int  )  ;
#line 100 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
static char const   * volatile  program_error_message  ;
#line 101 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
static char const   * volatile  stack_overflow_message  ;
#line 107
static  __attribute__((__noreturn__)) void die(int signo ) ;
#line 107 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
static void die(int signo ) 
{ 
  char const   *message___0 ;
  ssize_t __x ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t __x___0 ;
  ssize_t tmp___2 ;
  ssize_t __x___1 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t __x___2 ;
  ssize_t tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 117
  (*segv_action)(signo);
  }
#line 118
  if (signo) {
#line 118
    message___0 = (char const   *)program_error_message;
  } else {
#line 118
    message___0 = (char const   *)stack_overflow_message;
  }
  {
#line 119
  tmp___0 = strlen((char const   *)program_name);
#line 119
  tmp___1 = write(2, (void const   *)program_name, tmp___0);
#line 119
  __x = tmp___1;
#line 120
  tmp___2 = write(2, (void const   *)": ", (size_t )2);
#line 120
  __x___0 = tmp___2;
#line 121
  tmp___4 = strlen(message___0);
#line 121
  tmp___5 = write(2, (void const   *)message___0, tmp___4);
#line 121
  __x___1 = tmp___5;
#line 122
  tmp___6 = write(2, (void const   *)"\n", (size_t )1);
#line 122
  __x___2 = tmp___6;
  }
#line 123
  if (! signo) {
    {
#line 124
    _exit((int )exit_failure);
    }
  }
  {
#line 125
  raise(signo);
#line 126
  abort();
  }
}
}
#line 133 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
static union __anonunion_alternate_signal_stack_46 alternate_signal_stack  ;
#line 145 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
static void null_action(int signo  __attribute__((__unused__)) ) 
{ 


  {
#line 148
  return;
}
}
#line 158 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
static int volatile   segv_handler_missing  ;
#line 163 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
static int segv_handler(void *address  __attribute__((__unused__)) , int serious ) 
{ 


  {
#line 176
  if (! serious) {
#line 177
    return (0);
  }
  {
#line 178
  die(11);
  }
}
}
#line 184
static  __attribute__((__noreturn__)) void overflow_handler(int emergency , stackoverflow_context_t context___0  __attribute__((__unused__)) ) ;
#line 184 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
static void overflow_handler(int emergency , stackoverflow_context_t context___0  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
#line 197
  if (! emergency) {
#line 197
    tmp = 0;
  } else
#line 197
  if (segv_handler_missing) {
#line 197
    tmp = 0;
  } else {
#line 197
    tmp = 11;
  }
  {
#line 197
  die(tmp);
  }
}
}
#line 200 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-stack.c"
int c_stack_action(void (*action)(int  ) ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 203
  if (action) {
#line 203
    segv_action = (void (*/* volatile  */)(int  ))action;
  } else {
#line 203
    segv_action = (void (*/* volatile  */)(int  ))(& null_action);
  }
  {
#line 204
  tmp = gettext("program error");
#line 204
  program_error_message = (char const   */* volatile  */)tmp;
#line 205
  tmp___0 = gettext("stack overflow");
#line 205
  stack_overflow_message = (char const   */* volatile  */)tmp___0;
#line 208
  tmp___2 = stackoverflow_install_handler(& overflow_handler, (void *)(alternate_signal_stack.buffer),
                                          sizeof(alternate_signal_stack.buffer));
  }
#line 208
  if (tmp___2) {
    {
#line 212
    tmp___1 = __errno_location();
#line 212
    *tmp___1 = 95;
    }
#line 213
    return (-1);
  }
  {
#line 217
  tmp___3 = sigsegv_install_handler(& segv_handler);
#line 217
  segv_handler_missing = (int volatile   )tmp___3;
  }
#line 218
  return (0);
}
}
#line 123 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.h"
_Bool c_isascii(int c ) ;
#line 125
_Bool c_isalnum(int c ) ;
#line 126
_Bool c_isalpha(int c ) ;
#line 127
_Bool c_isblank(int c ) ;
#line 128
_Bool c_iscntrl(int c ) ;
#line 129
_Bool c_isdigit(int c ) ;
#line 130
_Bool c_islower(int c ) ;
#line 131
_Bool c_isgraph(int c ) ;
#line 132
_Bool c_isprint(int c ) ;
#line 133
_Bool c_ispunct(int c ) ;
#line 134
_Bool c_isspace(int c ) ;
#line 135
_Bool c_isupper(int c ) ;
#line 136
_Bool c_isxdigit(int c ) ;
#line 139
int c_toupper(int c ) ;
#line 29 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 32
  if (c >= 0) {
#line 32
    if (c <= 127) {
#line 32
      tmp = 1;
    } else {
#line 32
      tmp = 0;
    }
  } else {
#line 32
    tmp = 0;
  }
#line 32
  return ((_Bool )tmp);
}
}
#line 35 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 41
  if (c >= 48) {
#line 41
    if (c <= 57) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if ((c & -33) >= 65) {
#line 41
    if ((c & -33) <= 90) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return ((_Bool )tmp);
}
}
#line 70 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 75
  if ((c & -33) >= 65) {
#line 75
    if ((c & -33) <= 90) {
#line 75
      tmp = 1;
    } else {
#line 75
      tmp = 0;
    }
  } else {
#line 75
    tmp = 0;
  }
#line 75
  return ((_Bool )tmp);
}
}
#line 99 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 102
  if (c == 32) {
#line 102
    tmp = 1;
  } else
#line 102
  if (c == 9) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return ((_Bool )tmp);
}
}
#line 105 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 109
  if ((c & -32) == 0) {
#line 109
    tmp = 1;
  } else
#line 109
  if (c == 127) {
#line 109
    tmp = 1;
  } else {
#line 109
    tmp = 0;
  }
#line 109
  return ((_Bool )tmp);
}
}
#line 139 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 143
  if (c >= 48) {
#line 143
    if (c <= 57) {
#line 143
      tmp = 1;
    } else {
#line 143
      tmp = 0;
    }
  } else {
#line 143
    tmp = 0;
  }
#line 143
  return ((_Bool )tmp);
}
}
#line 156 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 160
  if (c >= 97) {
#line 160
    if (c <= 122) {
#line 160
      tmp = 1;
    } else {
#line 160
      tmp = 0;
    }
  } else {
#line 160
    tmp = 0;
  }
#line 160
  return ((_Bool )tmp);
}
}
#line 176 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 180
  if (c >= 33) {
#line 180
    if (c <= 126) {
#line 180
      tmp = 1;
    } else {
#line 180
      tmp = 0;
    }
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return ((_Bool )tmp);
}
}
#line 210 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 214
  if (c >= 32) {
#line 214
    if (c <= 126) {
#line 214
      tmp = 1;
    } else {
#line 214
      tmp = 0;
    }
  } else {
#line 214
    tmp = 0;
  }
#line 214
  return ((_Bool )tmp);
}
}
#line 244 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 248
  if (c >= 33) {
#line 248
    if (c <= 126) {
#line 248
      if (c >= 48) {
#line 248
        if (c <= 57) {
#line 248
          tmp = 0;
        } else {
#line 248
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 248
      if ((c & -33) >= 65) {
#line 248
        if ((c & -33) <= 90) {
#line 248
          tmp = 0;
        } else {
#line 248
          tmp = 1;
        }
      } else {
#line 248
        tmp = 1;
      }
    } else {
#line 248
      tmp = 0;
    }
  } else {
#line 248
    tmp = 0;
  }
#line 248
  return ((_Bool )tmp);
}
}
#line 268 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 271
  if (c == 32) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 9) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 10) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 11) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 12) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 13) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
#line 271
  return ((_Bool )tmp);
}
}
#line 275 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 279
  if (c >= 65) {
#line 279
    if (c <= 90) {
#line 279
      tmp = 1;
    } else {
#line 279
      tmp = 0;
    }
  } else {
#line 279
    tmp = 0;
  }
#line 279
  return ((_Bool )tmp);
}
}
#line 295 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 301
  if (c >= 48) {
#line 301
    if (c <= 57) {
#line 301
      tmp = 1;
    } else {
#line 301
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 301
  if ((c & -33) >= 65) {
#line 301
    if ((c & -33) <= 70) {
#line 301
      tmp = 1;
    } else {
#line 301
      tmp = 0;
    }
  } else {
#line 301
    tmp = 0;
  }
#line 301
  return ((_Bool )tmp);
}
}
#line 322 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 326
  if (c >= 65) {
#line 326
    if (c <= 90) {
#line 326
      tmp = (c - 65) + 97;
    } else {
#line 326
      tmp = c;
    }
  } else {
#line 326
    tmp = c;
  }
#line 326
  return (tmp);
}
}
#line 361 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 365
  if (c >= 97) {
#line 365
    if (c <= 122) {
#line 365
      tmp = (c - 97) + 65;
    } else {
#line 365
      tmp = c;
    }
  } else {
#line 365
    tmp = c;
  }
#line 365
  return (tmp);
}
}
#line 35 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/dirname.h"
char *base_name(char const   *name ) ;
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  {
#line 30
  tmp = last_component(name);
#line 30
  base = (char const   *)tmp;
  }
#line 35
  if (! *base) {
    {
#line 36
    tmp___0 = base_len(name);
#line 36
    tmp___1 = xstrndup(name, tmp___0);
    }
#line 36
    return (tmp___1);
  }
  {
#line 39
  length = base_len(base);
  }
#line 40
  if ((int const   )*(base + length) == 47) {
#line 41
    length ++;
  }
  {
#line 57
  tmp___3 = xstrndup(base, length);
  }
#line 57
  return (tmp___3);
}
}
#line 29 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57 "/home/wslee/gnu_benchmarks/diffutils-3.2/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 2 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/version.c"
char const   *Version  =    "3.2";
#line 414 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 568
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execl)(char const   *__path ,
                                                                                  char const   *__arg 
                                                                                  , ...) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 573 "../lib/regex.h"
extern regoff_t re_search(struct re_pattern_buffer *__buffer , char const   *__string ,
                          __re_idx_t __length , __re_idx_t __start , regoff_t __range ,
                          struct re_registers *__regs ) ;
#line 229 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 584
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 585
extern int putchar_unlocked(int __c ) ;
#line 712
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 84 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
enum output_style output_style ;
#line 123
enum DIFF_white_space ignore_white_space ;
#line 126
_Bool ignore_blank_lines ;
#line 133
_Bool ignore_case ;
#line 145
struct re_pattern_buffer ignore_regexp ;
#line 152
_Bool expand_tabs ;
#line 155
size_t tabsize ;
#line 160
_Bool initial_tab ;
#line 163
_Bool suppress_blank_empty ;
#line 174
_Bool paginate ;
#line 183
_Bool sdiff_merge_assist ;
#line 198
char *switch_string ;
#line 319
struct file_data files[2] ;
#line 323
FILE *outfile ;
#line 331
void print_context_header(struct file_data *inf , _Bool unidiff ) ;
#line 361
char const   change_letter[4] ;
#line 362
char const   pr_program[12] ;
#line 363
char *concat(char const   *s1 , char const   *s2 , char const   *s3 ) ;
#line 364
_Bool lines_differ(char const   *s1 , char const   *s2 ) ;
#line 365
lin translate_line_number(struct file_data  const  *file , lin i ) ;
#line 366
struct change *find_change(struct change *start ) ;
#line 367
struct change *find_reverse_change(struct change *start ) ;
#line 368
void *zalloc(size_t size ) ;
#line 369
enum changes analyze_hunk(struct change *hunk , lin *first0 , lin *last0 , lin *first1 ,
                          lin *last1 ) ;
#line 370
void begin_output(void) ;
#line 371
void debug_script(struct change *sp ) ;
#line 372
 __attribute__((__noreturn__)) void fatal(char const   *msgid ) ;
#line 373
void finish_output(void) ;
#line 374
void message(char const   *format_msgid , char const   *arg1 , char const   *arg2 ) ;
#line 375
void message5(char const   *format_msgid , char const   *arg1 , char const   *arg2 ,
              char const   *arg3 , char const   *arg4 ) ;
#line 377
void output_1_line(char const   *base , char const   *limit , char const   *flag_format ,
                   char const   *line_flag ) ;
#line 379
void perror_with_name(char const   *name ) ;
#line 380
 __attribute__((__noreturn__)) void pfatal_with_name(char const   *name ) ;
#line 381
void print_1_line(char const   *line_flag , char const   * const  *line ) ;
#line 382
void print_message_queue(void) ;
#line 383
void print_number_range(char sepchar , struct file_data *file , lin a , lin b ) ;
#line 384
void print_script(struct change *script , struct change *(*hunkfun)(struct change * ) ,
                  void (*printfun)(struct change * ) ) ;
#line 386
void setup_output(char const   *name0 , char const   *name1 , _Bool recursive___0 ) ;
#line 387
void translate_range(struct file_data  const  *file , lin a , lin b , long *aptr ,
                     long *bptr ) ;
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
char const   pr_program[12]  = 
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
  {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'b',      (char const   )'i',      (char const   )'n', 
        (char const   )'/',      (char const   )'p',      (char const   )'r',      (char const   )'\000'};
#line 40 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
static struct msg *msg_chain  ;
#line 44 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
static struct msg **msg_chain_end  =    & msg_chain;
#line 49 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void perror_with_name(char const   *name ) 
{ 
  int *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 52
  tmp = __errno_location();
#line 52
  error(0, *tmp, "%s", name);
  }
#line 53
  return;
}
}
#line 57
 __attribute__((__noreturn__)) void pfatal_with_name(char const   *name ) ;
#line 57 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void pfatal_with_name(char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 60
  tmp = __errno_location();
#line 60
  e = *tmp;
#line 61
  print_message_queue();
#line 62
  error(2, e, "%s", name);
#line 63
  abort();
  }
}
}
#line 68
 __attribute__((__noreturn__)) void fatal(char const   *msgid ) ;
#line 68 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void fatal(char const   *msgid ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 71
  print_message_queue();
#line 72
  tmp = gettext(msgid);
#line 72
  error(2, 0, "%s", tmp);
#line 73
  abort();
  }
}
}
#line 79 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void message(char const   *format_msgid , char const   *arg1 , char const   *arg2 ) 
{ 


  {
  {
#line 82
  message5(format_msgid, arg1, arg2, (char const   *)0, (char const   *)0);
  }
#line 83
  return;
}
}
#line 85 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void message5(char const   *format_msgid , char const   *arg1 , char const   *arg2 ,
              char const   *arg3 , char const   *arg4 ) 
{ 
  char *p ;
  char const   *arg[5] ;
  int i ;
  size_t size[5] ;
  size_t total_size ;
  struct msg *new ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 89
  if (paginate) {
#line 95
    total_size = (unsigned long )(& ((struct msg *)0)->args);
#line 98
    arg[0] = format_msgid;
#line 99
    arg[1] = arg1;
#line 100
    arg[2] = arg2;
#line 101
    if (arg3) {
#line 101
      arg[3] = arg3;
    } else {
#line 101
      arg[3] = "";
    }
#line 102
    if (arg4) {
#line 102
      arg[4] = arg4;
    } else {
#line 102
      arg[4] = "";
    }
#line 104
    i = 0;
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! (i < 5)) {
#line 104
        goto while_break;
      }
      {
#line 105
      tmp___0 = strlen(arg[i]);
#line 105
      tmp = tmp___0 + 1UL;
#line 105
      size[i] = tmp;
#line 105
      total_size += tmp;
#line 104
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 107
    tmp___1 = xmalloc(total_size);
#line 107
    new = (struct msg *)tmp___1;
#line 109
    i = 0;
#line 109
    p = new->args;
    }
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      if (! (i < 5)) {
#line 109
        goto while_break___0;
      }
      {
#line 110
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)arg[i],
             size[i]);
#line 109
      tmp___2 = i;
#line 109
      i ++;
#line 109
      p += size[tmp___2];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 112
    *msg_chain_end = new;
#line 113
    new->next = (struct msg *)0;
#line 114
    msg_chain_end = & new->next;
  } else {
#line 118
    if (sdiff_merge_assist) {
      {
#line 119
      putchar_unlocked(' ');
      }
    }
    {
#line 120
    tmp___3 = gettext(format_msgid);
#line 120
    printf((char const   */* __restrict  */)tmp___3, arg1, arg2, arg3, arg4);
    }
  }
#line 122
  return;
}
}
#line 126 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void print_message_queue(void) 
{ 
  char const   *arg[5] ;
  int i ;
  struct msg *m ;
  struct msg *next ;
  size_t tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;

  {
#line 131
  m = msg_chain;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! m) {
#line 133
      goto while_break;
    }
#line 135
    next = m->next;
#line 136
    arg[0] = (char const   *)(m->args);
#line 137
    i = 0;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! (i < 4)) {
#line 137
        goto while_break___0;
      }
      {
#line 138
      tmp = strlen(arg[i]);
#line 138
      arg[i + 1] = (arg[i] + tmp) + 1;
#line 137
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 139
    tmp___0 = gettext(arg[0]);
#line 139
    printf((char const   */* __restrict  */)tmp___0, arg[1], arg[2], arg[3], arg[4]);
#line 140
    free((void *)m);
#line 141
    m = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 152 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
static char const   *current_name0  ;
#line 153 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
static char const   *current_name1  ;
#line 154 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
static _Bool currently_recursive  ;
#line 156 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void setup_output(char const   *name0 , char const   *name1 , _Bool recursive___0 ) 
{ 


  {
#line 159
  current_name0 = name0;
#line 160
  current_name1 = name1;
#line 161
  currently_recursive = recursive___0;
#line 162
  outfile = (FILE *)0;
#line 163
  return;
}
}
#line 166 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
static pid_t pr_pid  ;
#line 169 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void begin_output(void) 
{ 
  char *name ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int pipes[2] ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___8 ;
  int *tmp___9 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 174
  if ((unsigned long )outfile != (unsigned long )((FILE *)0)) {
#line 175
    return;
  }
  {
#line 178
  tmp = strlen(current_name0);
#line 178
  tmp___0 = strlen(current_name1);
#line 178
  tmp___1 = strlen((char const   *)switch_string);
#line 178
  tmp___2 = xmalloc(((tmp + tmp___0) + tmp___1) + 7UL);
#line 178
  name = (char *)tmp___2;
#line 186
  sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"diff%s %s %s",
          switch_string, current_name0, current_name1);
  }
#line 188
  if (paginate) {
    {
#line 190
    tmp___4 = fflush_unlocked(stdout);
    }
#line 190
    if (tmp___4 != 0) {
      {
#line 191
      tmp___3 = gettext("write failed");
#line 191
      pfatal_with_name((char const   *)tmp___3);
      }
    }
    {
#line 198
    tmp___5 = pipe((int *)(pipes));
    }
#line 198
    if (tmp___5 != 0) {
      {
#line 199
      pfatal_with_name("pipe");
      }
    }
    {
#line 201
    pr_pid = fork();
    }
#line 202
    if (pr_pid < 0) {
      {
#line 203
      pfatal_with_name("fork");
      }
    }
#line 205
    if (pr_pid == 0) {
      {
#line 207
      close(pipes[1]);
      }
#line 208
      if (pipes[0] != 0) {
        {
#line 210
        tmp___6 = dup2(pipes[0], 0);
        }
#line 210
        if (tmp___6 < 0) {
          {
#line 211
          pfatal_with_name("dup2");
          }
        }
        {
#line 212
        close(pipes[0]);
        }
      }
      {
#line 215
      execl(pr_program, pr_program, "-h", name, (char *)0);
#line 216
      tmp___9 = __errno_location();
      }
#line 216
      if (*tmp___9 == 2) {
#line 216
        tmp___8 = 127;
      } else {
#line 216
        tmp___8 = 126;
      }
      {
#line 216
      _exit(tmp___8);
      }
    } else {
      {
#line 220
      close(pipes[0]);
#line 221
      outfile = fdopen(pipes[1], "w");
      }
#line 222
      if (! outfile) {
        {
#line 223
        pfatal_with_name("fdopen");
        }
      }
    }
  } else {
#line 246
    outfile = stdout;
#line 250
    if (currently_recursive) {
      {
#line 251
      printf((char const   */* __restrict  */)"%s\n", name);
      }
    }
  }
  {
#line 254
  free((void *)name);
  }
  {
#line 259
  if ((unsigned int )output_style == 2U) {
#line 259
    goto case_2;
  }
#line 263
  if ((unsigned int )output_style == 3U) {
#line 263
    goto case_3;
  }
#line 267
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 260
  print_context_header(files, (_Bool)0);
  }
#line 261
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 264
  print_context_header(files, (_Bool)1);
  }
#line 265
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 268
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 270
  return;
}
}
#line 275 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void finish_output(void) 
{ 
  int status ;
  int wstatus ;
  int werrno ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  union __anonunion_66 __constr_expr_1 ;
  union __anonunion_67 __constr_expr_2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 278
  if ((unsigned long )outfile != (unsigned long )((FILE *)0)) {
#line 278
    if ((unsigned long )outfile != (unsigned long )stdout) {
      {
#line 282
      werrno = 0;
#line 283
      tmp = ferror_unlocked(outfile);
      }
#line 283
      if (tmp) {
        {
#line 284
        fatal("write failed");
        }
      }
      {
#line 290
      tmp___1 = fclose(outfile);
      }
#line 290
      if (tmp___1 != 0) {
        {
#line 291
        tmp___0 = gettext("write failed");
#line 291
        pfatal_with_name((char const   *)tmp___0);
        }
      }
      {
#line 292
      tmp___2 = waitpid(pr_pid, & wstatus, 0);
      }
#line 292
      if (tmp___2 < 0) {
        {
#line 293
        pfatal_with_name("waitpid");
        }
      }
#line 295
      if (! werrno) {
#line 295
        __constr_expr_2.__in = wstatus;
#line 295
        if ((__constr_expr_2.__i & 127) == 0) {
#line 295
          __constr_expr_1.__in = wstatus;
#line 295
          status = (__constr_expr_1.__i & 65280) >> 8;
        } else {
#line 295
          status = 2147483647;
        }
      } else {
#line 295
        status = 2147483647;
      }
#line 298
      if (status) {
#line 299
        if (status == 126) {
#line 299
          tmp___5 = "subsidiary program `%s\' could not be invoked";
        } else {
#line 299
          if (status == 127) {
#line 299
            tmp___4 = "subsidiary program `%s\' not found";
          } else {
#line 299
            if (status == 2147483647) {
#line 299
              tmp___3 = "subsidiary program `%s\' failed";
            } else {
#line 299
              tmp___3 = "subsidiary program `%s\' failed (exit status %d)";
            }
#line 299
            tmp___4 = tmp___3;
          }
#line 299
          tmp___5 = tmp___4;
        }
        {
#line 299
        tmp___6 = gettext(tmp___5);
#line 299
        error(2, werrno, (char const   *)tmp___6, pr_program, status);
        }
      }
    }
  }
#line 310
  outfile = (FILE *)0;
#line 311
  return;
}
}
#line 319 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
_Bool lines_differ(char const   *s1 , char const   *s2 ) 
{ 
  register char const   *t1 ;
  register char const   *t2 ;
  size_t column ;
  register unsigned char c1 ;
  char const   *tmp ;
  register unsigned char c2 ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char const   *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char const   *tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned char c ;
  char const   *p ;
  unsigned short const   **tmp___13 ;
  char const   *p___0 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  size_t column2 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;

  {
#line 322
  t1 = s1;
#line 323
  t2 = s2;
#line 324
  column = (size_t )0;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    tmp = t1;
#line 328
    t1 ++;
#line 328
    c1 = (unsigned char )*tmp;
#line 329
    tmp___0 = t2;
#line 329
    t2 ++;
#line 329
    c2 = (unsigned char )*tmp___0;
#line 332
    if ((int )c1 != (int )c2) {
      {
#line 336
      if ((unsigned int )ignore_white_space == 5U) {
#line 336
        goto case_5;
      }
#line 342
      if ((unsigned int )ignore_white_space == 4U) {
#line 342
        goto case_4;
      }
#line 399
      if ((unsigned int )ignore_white_space == 3U) {
#line 399
        goto case_3;
      }
#line 399
      if ((unsigned int )ignore_white_space == 2U) {
#line 399
        goto case_3;
      }
#line 425
      if ((unsigned int )ignore_white_space == 1U) {
#line 425
        goto case_1;
      }
#line 453
      if ((unsigned int )ignore_white_space == 0U) {
#line 453
        goto case_0;
      }
#line 334
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 338
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 338
        tmp___2 = __ctype_b_loc();
        }
#line 338
        if ((int const   )*(*tmp___2 + (int )c1) & 8192) {
#line 338
          if (! ((int )c1 != 10)) {
#line 338
            goto while_break___0;
          }
        } else {
#line 338
          goto while_break___0;
        }
#line 338
        tmp___1 = t1;
#line 338
        t1 ++;
#line 338
        c1 = (unsigned char )*tmp___1;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 339
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 339
        tmp___4 = __ctype_b_loc();
        }
#line 339
        if ((int const   )*(*tmp___4 + (int )c2) & 8192) {
#line 339
          if (! ((int )c2 != 10)) {
#line 339
            goto while_break___1;
          }
        } else {
#line 339
          goto while_break___1;
        }
#line 339
        tmp___3 = t2;
#line 339
        t2 ++;
#line 339
        c2 = (unsigned char )*tmp___3;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 340
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 346
      tmp___7 = __ctype_b_loc();
      }
#line 346
      if ((int const   )*(*tmp___7 + (int )c1) & 8192) {
        {
#line 348
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 348
          if (! ((int )c1 != 10)) {
#line 348
            goto while_break___2;
          }
          {
#line 350
          tmp___5 = t1;
#line 350
          t1 ++;
#line 350
          c1 = (unsigned char )*tmp___5;
#line 351
          tmp___6 = __ctype_b_loc();
          }
#line 351
          if (! ((int const   )*(*tmp___6 + (int )c1) & 8192)) {
#line 353
            t1 --;
#line 354
            c1 = (unsigned char )' ';
#line 355
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 361
      tmp___10 = __ctype_b_loc();
      }
#line 361
      if ((int const   )*(*tmp___10 + (int )c2) & 8192) {
        {
#line 363
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 363
          if (! ((int )c2 != 10)) {
#line 363
            goto while_break___3;
          }
          {
#line 365
          tmp___8 = t2;
#line 365
          t2 ++;
#line 365
          c2 = (unsigned char )*tmp___8;
#line 366
          tmp___9 = __ctype_b_loc();
          }
#line 366
          if (! ((int const   )*(*tmp___9 + (int )c2) & 8192)) {
#line 368
            t2 --;
#line 369
            c2 = (unsigned char )' ';
#line 370
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 375
      if ((int )c1 != (int )c2) {
#line 380
        if ((int )c2 == 32) {
#line 380
          if ((int )c1 != 10) {
#line 380
            if ((unsigned long )(s1 + 1) < (unsigned long )t1) {
              {
#line 380
              tmp___11 = __ctype_b_loc();
              }
#line 380
              if ((int const   )*(*tmp___11 + (int )((unsigned char )*(t1 + -2))) & 8192) {
#line 384
                t1 --;
#line 385
                goto while_continue;
              }
            }
          }
        }
#line 387
        if ((int )c1 == 32) {
#line 387
          if ((int )c2 != 10) {
#line 387
            if ((unsigned long )(s2 + 1) < (unsigned long )t2) {
              {
#line 387
              tmp___12 = __ctype_b_loc();
              }
#line 387
              if ((int const   )*(*tmp___12 + (int )((unsigned char )*(t2 + -2))) & 8192) {
#line 391
                t2 --;
#line 392
                goto while_continue;
              }
            }
          }
        }
      }
#line 396
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      {
#line 400
      tmp___15 = __ctype_b_loc();
      }
#line 400
      if ((int const   )*(*tmp___15 + (int )c1) & 8192) {
        {
#line 400
        tmp___16 = __ctype_b_loc();
        }
#line 400
        if ((int const   )*(*tmp___16 + (int )c2) & 8192) {
#line 403
          if ((int )c1 != 10) {
#line 405
            p = t1;
            {
#line 406
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 406
              c = (unsigned char )*p;
#line 406
              if ((int )c != 10) {
                {
#line 406
                tmp___13 = __ctype_b_loc();
                }
#line 406
                if (! ((int const   )*(*tmp___13 + (int )c) & 8192)) {
#line 406
                  goto while_break___4;
                }
              } else {
#line 406
                goto while_break___4;
              }
#line 407
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 408
            if ((int )c != 10) {
#line 409
              goto switch_break;
            }
          }
#line 411
          if ((int )c2 != 10) {
#line 413
            p___0 = t2;
            {
#line 414
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 414
              c = (unsigned char )*p___0;
#line 414
              if ((int )c != 10) {
                {
#line 414
                tmp___14 = __ctype_b_loc();
                }
#line 414
                if (! ((int const   )*(*tmp___14 + (int )c) & 8192)) {
#line 414
                  goto while_break___5;
                }
              } else {
#line 414
                goto while_break___5;
              }
#line 415
              p___0 ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 416
            if ((int )c != 10) {
#line 417
              goto switch_break;
            }
          }
#line 420
          return ((_Bool)0);
        }
      }
#line 422
      if ((unsigned int )ignore_white_space == 2U) {
#line 423
        goto switch_break;
      }
      case_1: /* CIL Label */ 
#line 426
      if ((int )c1 == 32) {
#line 426
        if ((int )c2 == 9) {
#line 426
          goto _L;
        } else {
#line 426
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 426
      if ((int )c1 == 9) {
#line 426
        if ((int )c2 == 32) {
          _L: /* CIL Label */ 
#line 429
          column2 = column;
          {
#line 430
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 432
            if ((int )c1 == 32) {
#line 433
              column ++;
            } else
#line 434
            if ((int )c1 == 9) {
#line 435
              column += tabsize - column % tabsize;
            } else {
#line 437
              goto while_break___6;
            }
#line 430
            tmp___17 = t1;
#line 430
            t1 ++;
#line 430
            c1 = (unsigned char )*tmp___17;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 439
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 441
            if ((int )c2 == 32) {
#line 442
              column2 ++;
            } else
#line 443
            if ((int )c2 == 9) {
#line 444
              column2 += tabsize - column2 % tabsize;
            } else {
#line 446
              goto while_break___7;
            }
#line 439
            tmp___18 = t2;
#line 439
            t2 ++;
#line 439
            c2 = (unsigned char )*tmp___18;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 448
          if (column != column2) {
#line 449
            return ((_Bool)1);
          }
        }
      }
#line 451
      goto switch_break;
      case_0: /* CIL Label */ 
#line 454
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 459
      if (ignore_case) {
        {
#line 461
        tmp___19 = tolower((int )c1);
#line 461
        c1 = (unsigned char )tmp___19;
#line 462
        tmp___20 = tolower((int )c2);
#line 462
        c2 = (unsigned char )tmp___20;
        }
      }
#line 465
      if ((int )c1 != (int )c2) {
#line 466
        goto while_break;
      }
    }
#line 468
    if ((int )c1 == 10) {
#line 469
      return ((_Bool)0);
    }
#line 471
    if ((int )c1 == 9) {
#line 471
      tmp___21 = tabsize - column % tabsize;
    } else {
#line 471
      tmp___21 = (size_t )1;
    }
#line 471
    column += tmp___21;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  return ((_Bool)1);
}
}
#line 480 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
struct change *find_change(struct change *start ) 
{ 


  {
#line 483
  return (start);
}
}
#line 486 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
struct change *find_reverse_change(struct change *start ) 
{ 


  {
#line 489
  return (start);
}
}
#line 503 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void print_script(struct change *script , struct change *(*hunkfun)(struct change * ) ,
                  void (*printfun)(struct change * ) ) 
{ 
  struct change *next ;
  struct change *this ;
  struct change *end ;

  {
#line 508
  next = script;
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! next) {
#line 510
      goto while_break;
    }
    {
#line 515
    this = next;
#line 516
    end = (*hunkfun)(next);
#line 520
    next = end->link;
#line 521
    end->link = (struct change *)0;
#line 527
    (*printfun)(this);
#line 530
    end->link = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  return;
}
}
#line 539 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void print_1_line(char const   *line_flag , char const   * const  *line ) 
{ 
  char const   *base ;
  char const   *limit ;
  FILE *out ;
  char const   *flag_format ;
  char const   *flag_format_1 ;
  char const   *line_flag_1 ;
  char *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 542
  base = (char const   *)*(line + 0);
#line 542
  limit = (char const   *)*(line + 1);
#line 543
  out = outfile;
#line 544
  flag_format = (char const   *)0;
#line 551
  if (line_flag) {
#line 551
    if (*line_flag) {
#line 553
      if (initial_tab) {
#line 553
        flag_format = "%s\t";
      } else {
#line 553
        flag_format = "%s ";
      }
#line 553
      flag_format_1 = flag_format;
#line 554
      line_flag_1 = line_flag;
#line 556
      if (suppress_blank_empty) {
#line 556
        if ((int const   )*(*line) == 10) {
#line 558
          flag_format_1 = "%s";
#line 563
          line_flag_1 += (int const   )*line_flag_1 == 32;
        }
      }
      {
#line 566
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)flag_format_1,
              line_flag_1);
      }
    }
  }
  {
#line 569
  output_1_line(base, limit, flag_format, line_flag);
  }
#line 571
  if (! line_flag) {
#line 571
    goto _L;
  } else
#line 571
  if (*(line_flag + 0)) {
    _L: /* CIL Label */ 
#line 571
    if ((int const   )*(limit + -1) != 10) {
      {
#line 572
      tmp = gettext("No newline at end of file");
#line 572
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n\\ %s\n",
              tmp);
      }
    }
  }
#line 573
  return;
}
}
#line 580 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void output_1_line(char const   *base , char const   *limit , char const   *flag_format ,
                   char const   *line_flag ) 
{ 
  register FILE *out ;
  register unsigned char c ;
  register char const   *t ;
  register size_t column ;
  size_t tab_size ;
  char const   *tmp ;
  size_t spaces ;
  unsigned short const   **tmp___0 ;

  {
#line 584
  if (! expand_tabs) {
    {
#line 585
    fwrite_unlocked((void const   */* __restrict  */)base, sizeof(char ), (size_t )(limit - base),
                    (FILE */* __restrict  */)outfile);
    }
  } else {
#line 588
    out = outfile;
#line 590
    t = base;
#line 591
    column = (size_t )0;
#line 592
    tab_size = tabsize;
    {
#line 594
    while (1) {
      while_continue: /* CIL Label */ ;
#line 594
      if (! ((unsigned long )t < (unsigned long )limit)) {
#line 594
        goto while_break;
      }
#line 595
      tmp = t;
#line 595
      t ++;
#line 595
      c = (unsigned char )*tmp;
      {
#line 597
      if ((int )c == 9) {
#line 597
        goto case_9;
      }
#line 607
      if ((int )c == 13) {
#line 607
        goto case_13;
      }
#line 614
      if ((int )c == 8) {
#line 614
        goto case_8;
      }
#line 621
      goto switch_default;
      case_9: /* CIL Label */ 
#line 599
      spaces = tab_size - column % tab_size;
#line 600
      column += spaces;
      {
#line 601
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 602
        putc_unlocked(' ', out);
#line 601
        spaces --;
        }
#line 601
        if (! spaces) {
#line 601
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 605
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 608
      putc_unlocked((int )c, out);
      }
#line 609
      if (flag_format) {
#line 609
        if ((unsigned long )t < (unsigned long )limit) {
#line 609
          if ((int const   )*t != 10) {
            {
#line 610
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)flag_format,
                    line_flag);
            }
          }
        }
      }
#line 611
      column = (size_t )0;
#line 612
      goto switch_break;
      case_8: /* CIL Label */ 
#line 615
      if (column == 0UL) {
#line 616
        goto while_continue;
      }
      {
#line 617
      column --;
#line 618
      putc_unlocked((int )c, out);
      }
#line 619
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 622
      tmp___0 = __ctype_b_loc();
#line 622
      column += (size_t )(((int const   )*(*tmp___0 + (int )c) & 16384) != 0);
#line 623
      putc_unlocked((int )c, out);
      }
#line 624
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 627
  return;
}
}
#line 629 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
char const   change_letter[4]  = {      (char const   )0,      (char const   )'d',      (char const   )'a',      (char const   )'c'};
#line 638 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
lin translate_line_number(struct file_data  const  *file , lin i ) 
{ 


  {
#line 641
  return ((i + (lin )file->prefix_lines) + 1L);
}
}
#line 648 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void translate_range(struct file_data  const  *file , lin a , lin b , long *aptr ,
                     long *bptr ) 
{ 
  lin tmp ;
  lin tmp___0 ;

  {
  {
#line 653
  tmp = translate_line_number(file, a - 1L);
#line 653
  *aptr = tmp + 1L;
#line 654
  tmp___0 = translate_line_number(file, b + 1L);
#line 654
  *bptr = tmp___0 - 1L;
  }
#line 655
  return;
}
}
#line 663 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void print_number_range(char sepchar , struct file_data *file , lin a , lin b ) 
{ 
  long trans_a ;
  long trans_b ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 667
  translate_range((struct file_data  const  *)file, a, b, & trans_a, & trans_b);
  }
#line 672
  if (trans_b > trans_a) {
    {
#line 673
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%ld%c%ld",
            trans_a, (int )sepchar, trans_b);
    }
  } else {
    {
#line 675
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%ld",
            trans_b);
    }
  }
#line 676
  return;
}
}
#line 691 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
enum changes analyze_hunk(struct change *hunk , lin *first0 , lin *last0 , lin *first1 ,
                          lin *last1 ) 
{ 
  struct change *next ;
  lin l0 ;
  lin l1 ;
  lin show_from ;
  lin show_to ;
  lin i ;
  _Bool trivial ;
  int tmp ;
  size_t trivial_length ;
  _Bool skip_white_space ;
  int tmp___0 ;
  _Bool skip_leading_white_space ;
  int tmp___1 ;
  char const   * const  *linbuf0 ;
  char const   * const  *linbuf1 ;
  char const   *line ;
  char const   *newline ;
  size_t len ;
  char const   *p ;
  unsigned short const   **tmp___2 ;
  regoff_t tmp___3 ;
  char const   *line___0 ;
  char const   *newline___0 ;
  size_t len___0 ;
  char const   *p___0 ;
  unsigned short const   **tmp___4 ;
  regoff_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 700
  if (ignore_blank_lines) {
#line 700
    tmp = 1;
  } else
#line 700
  if (ignore_regexp.fastmap) {
#line 700
    tmp = 1;
  } else {
#line 700
    tmp = 0;
  }
#line 700
  trivial = (_Bool )tmp;
#line 701
  trivial_length = (size_t )((int )ignore_blank_lines - 1);
#line 705
  if (ignore_blank_lines) {
#line 705
    if (2U <= (unsigned int )ignore_white_space) {
#line 705
      tmp___0 = 1;
    } else {
#line 705
      tmp___0 = 0;
    }
  } else {
#line 705
    tmp___0 = 0;
  }
#line 705
  skip_white_space = (_Bool )tmp___0;
#line 707
  if (skip_white_space) {
#line 707
    if (4U <= (unsigned int )ignore_white_space) {
#line 707
      tmp___1 = 1;
    } else {
#line 707
      tmp___1 = 0;
    }
  } else {
#line 707
    tmp___1 = 0;
  }
#line 707
  skip_leading_white_space = (_Bool )tmp___1;
#line 710
  linbuf0 = (char const   * const  *)files[0].linbuf;
#line 711
  linbuf1 = (char const   * const  *)files[1].linbuf;
#line 713
  show_to = (lin )0;
#line 713
  show_from = show_to;
#line 715
  *first0 = hunk->line0;
#line 716
  *first1 = hunk->line1;
#line 718
  next = hunk;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    l0 = (next->line0 + next->deleted) - 1L;
#line 722
    l1 = (next->line1 + next->inserted) - 1L;
#line 723
    show_from += next->deleted;
#line 724
    show_to += next->inserted;
#line 726
    i = next->line0;
    {
#line 726
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 726
      if (i <= l0) {
#line 726
        if (! trivial) {
#line 726
          goto while_break___0;
        }
      } else {
#line 726
        goto while_break___0;
      }
#line 728
      line = (char const   *)*(linbuf0 + i);
#line 729
      newline = (char const   *)(*(linbuf0 + (i + 1L)) - 1);
#line 730
      len = (size_t )(newline - line);
#line 731
      p = line;
#line 732
      if (skip_white_space) {
        {
#line 733
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 733
          if (! ((int const   )*p != 10)) {
#line 733
            goto while_break___1;
          }
          {
#line 734
          tmp___2 = __ctype_b_loc();
          }
#line 734
          if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*p)) & 8192)) {
#line 736
            if (! skip_leading_white_space) {
#line 737
              p = line;
            }
#line 738
            goto while_break___1;
          }
#line 733
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 740
      if ((size_t )(newline - p) != trivial_length) {
#line 740
        if (! ignore_regexp.fastmap) {
#line 743
          trivial = (_Bool)0;
        } else {
          {
#line 740
          tmp___3 = re_search(& ignore_regexp, line, (__re_idx_t )len, 0, (regoff_t )len,
                              (struct re_registers *)0);
          }
#line 740
          if (tmp___3 < 0) {
#line 743
            trivial = (_Bool)0;
          }
        }
      }
#line 726
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 746
    i = next->line1;
    {
#line 746
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 746
      if (i <= l1) {
#line 746
        if (! trivial) {
#line 746
          goto while_break___2;
        }
      } else {
#line 746
        goto while_break___2;
      }
#line 748
      line___0 = (char const   *)*(linbuf1 + i);
#line 749
      newline___0 = (char const   *)(*(linbuf1 + (i + 1L)) - 1);
#line 750
      len___0 = (size_t )(newline___0 - line___0);
#line 751
      p___0 = line___0;
#line 752
      if (skip_white_space) {
        {
#line 753
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 753
          if (! ((int const   )*p___0 != 10)) {
#line 753
            goto while_break___3;
          }
          {
#line 754
          tmp___4 = __ctype_b_loc();
          }
#line 754
          if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*p___0)) & 8192)) {
#line 756
            if (! skip_leading_white_space) {
#line 757
              p___0 = line___0;
            }
#line 758
            goto while_break___3;
          }
#line 753
          p___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 760
      if ((size_t )(newline___0 - p___0) != trivial_length) {
#line 760
        if (! ignore_regexp.fastmap) {
#line 763
          trivial = (_Bool)0;
        } else {
          {
#line 760
          tmp___5 = re_search(& ignore_regexp, line___0, (__re_idx_t )len___0, 0,
                              (regoff_t )len___0, (struct re_registers *)0);
          }
#line 760
          if (tmp___5 < 0) {
#line 763
            trivial = (_Bool)0;
          }
        }
      }
#line 746
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 719
    next = next->link;
#line 719
    if (! ((unsigned long )next != (unsigned long )((struct change *)0))) {
#line 719
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 768
  *last0 = l0;
#line 769
  *last1 = l1;
#line 774
  if (trivial) {
#line 775
    return ((enum changes )0);
  }
#line 777
  if (show_from) {
#line 777
    tmp___6 = 1;
  } else {
#line 777
    tmp___6 = 0;
  }
#line 777
  if (show_to) {
#line 777
    tmp___7 = 2;
  } else {
#line 777
    tmp___7 = 0;
  }
#line 777
  return ((enum changes )(tmp___6 | tmp___7));
}
}
#line 782 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
char *concat(char const   *s1 , char const   *s2 , char const   *s3 ) 
{ 
  char *new ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 785
  tmp = strlen(s1);
#line 785
  tmp___0 = strlen(s2);
#line 785
  tmp___1 = strlen(s3);
#line 785
  tmp___2 = xmalloc(((tmp + tmp___0) + tmp___1) + 1UL);
#line 785
  new = (char *)tmp___2;
#line 786
  sprintf((char */* __restrict  */)new, (char const   */* __restrict  */)"%s%s%s",
          s1, s2, s3);
  }
#line 787
  return (new);
}
}
#line 792 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void *zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 795
  tmp = xmalloc(size);
#line 795
  p = tmp;
#line 796
  memset(p, 0, size);
  }
#line 797
  return (p);
}
}
#line 800 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/util.c"
void debug_script(struct change *sp ) 
{ 
  long line0 ;
  long line1 ;
  long deleted ;
  long inserted ;
  char *__cil_tmp6 ;

  {
  {
#line 803
  fflush_unlocked(stdout);
  }
  {
#line 805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 805
    if (! sp) {
#line 805
      goto while_break;
    }
    {
#line 807
    line0 = sp->line0;
#line 808
    line1 = sp->line1;
#line 809
    deleted = sp->deleted;
#line 810
    inserted = sp->inserted;
#line 811
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%3ld %3ld delete %ld insert %ld\n",
            line0, line1, deleted, inserted);
#line 805
    sp = sp->link;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  fflush_unlocked(stderr);
  }
#line 816
  return;
}
}
#line 186 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool left_column ;
#line 189
_Bool suppress_common_lines ;
#line 192
size_t sdiff_half_width ;
#line 193
size_t sdiff_column2_offset ;
#line 358
void print_sdiff_script(struct change *script ) ;
#line 437 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int wcwidth(wchar_t __c ) ;
#line 27 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/side.c"
static void print_sdiff_common_lines(lin limit0 , lin limit1 ) ;
#line 28
static void print_sdiff_hunk(struct change *hunk ) ;
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/side.c"
static lin next0  ;
#line 31 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/side.c"
static lin next1  ;
#line 35 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/side.c"
void print_sdiff_script(struct change *script ) 
{ 


  {
  {
#line 38
  begin_output();
#line 40
  next1 = - files[0].prefix_lines;
#line 40
  next0 = next1;
#line 41
  print_script(script, & find_change, & print_sdiff_hunk);
#line 43
  print_sdiff_common_lines(files[0].valid_lines, files[1].valid_lines);
  }
#line 44
  return;
}
}
#line 48 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/side.c"
static size_t tab_from_to(size_t from , size_t to ) 
{ 
  FILE *out ;
  size_t tab ;
  size_t tab_size ;
  size_t tmp ;

  {
#line 51
  out = outfile;
#line 53
  tab_size = tabsize;
#line 55
  if (! expand_tabs) {
#line 56
    tab = (from + tab_size) - from % tab_size;
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
#line 56
      if (! (tab <= to)) {
#line 56
        goto while_break;
      }
      {
#line 58
      putc_unlocked('\t', out);
#line 59
      from = tab;
#line 56
      tab += tab_size;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 61
    tmp = from;
#line 61
    from ++;
#line 61
    if (! (tmp < to)) {
#line 61
      goto while_break___0;
    }
    {
#line 62
    putc_unlocked(' ', out);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  return (to);
}
}
#line 70 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/side.c"
static size_t print_half_line(char const   * const  *line , size_t indent , size_t out_bound ) 
{ 
  FILE *out ;
  register size_t in_position ;
  register size_t out_position ;
  register char const   *text_pointer ;
  register char const   *text_limit ;
  mbstate_t mbstate ;
  char const   *tp0 ;
  register char c ;
  char const   *tmp ;
  size_t spaces ;
  size_t tabstop ;
  wchar_t wc ;
  size_t bytes ;
  size_t tmp___0 ;
  int width ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
#line 73
  out = outfile;
#line 74
  in_position = (size_t )0;
#line 75
  out_position = (size_t )0;
#line 76
  text_pointer = (char const   *)*(line + 0);
#line 77
  text_limit = (char const   *)*(line + 1);
#line 78
  mbstate.__count = 0;
#line 78
  mbstate.__value.__wch = 0U;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((unsigned long )text_pointer < (unsigned long )text_limit)) {
#line 80
      goto while_break;
    }
#line 82
    tp0 = text_pointer;
#line 83
    tmp = text_pointer;
#line 83
    text_pointer ++;
#line 83
    c = (char )*tmp;
    {
#line 87
    if ((int )c == 9) {
#line 87
      goto case_9;
    }
#line 111
    if ((int )c == 13) {
#line 111
      goto case_13;
    }
#line 119
    if ((int )c == 8) {
#line 119
      goto case_8;
    }
#line 155
    if ((int )c == 11) {
#line 155
      goto case_11;
    }
#line 155
    if ((int )c == 12) {
#line 155
      goto case_11;
    }
#line 179
    if ((int )c == 126) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 125) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 124) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 123) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 122) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 121) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 120) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 119) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 118) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 117) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 116) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 115) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 114) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 113) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 112) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 111) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 110) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 109) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 108) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 107) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 106) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 105) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 104) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 103) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 102) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 101) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 100) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 99) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 98) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 97) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 95) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 94) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 93) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 92) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 91) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 90) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 89) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 88) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 87) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 86) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 85) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 84) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 83) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 82) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 81) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 80) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 79) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 78) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 77) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 76) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 75) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 74) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 73) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 72) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 71) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 70) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 69) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 68) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 67) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 66) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 65) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 63) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 62) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 61) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 60) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 59) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 58) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 57) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 56) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 55) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 54) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 53) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 52) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 51) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 50) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 49) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 48) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 47) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 46) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 45) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 44) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 43) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 42) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 41) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 40) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 39) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 38) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 37) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 35) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 34) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 33) {
#line 179
      goto case_126;
    }
#line 179
    if ((int )c == 32) {
#line 179
      goto case_126;
    }
#line 188
    if ((int )c == 10) {
#line 188
      goto case_10;
    }
#line 134
    goto switch_default;
    case_9: /* CIL Label */ 
#line 89
    spaces = tabsize - in_position % tabsize;
#line 90
    if (in_position == out_position) {
#line 92
      tabstop = out_position + spaces;
#line 93
      if (expand_tabs) {
#line 95
        if (out_bound < tabstop) {
#line 96
          tabstop = out_bound;
        }
        {
#line 97
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 97
          if (! (out_position < tabstop)) {
#line 97
            goto while_break___0;
          }
          {
#line 98
          putc_unlocked(' ', out);
#line 97
          out_position ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 101
      if (tabstop < out_bound) {
        {
#line 103
        out_position = tabstop;
#line 104
        putc_unlocked((int )c, out);
        }
      }
    }
#line 107
    in_position += spaces;
#line 109
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 113
    putc_unlocked((int )c, out);
#line 114
    tab_from_to((size_t )0, indent);
#line 115
    out_position = (size_t )0;
#line 115
    in_position = out_position;
    }
#line 117
    goto switch_break;
    case_8: /* CIL Label */ 
#line 120
    if (in_position != 0UL) {
#line 120
      in_position --;
#line 120
      if (in_position < out_bound) {
#line 122
        if (out_position <= in_position) {
          {
#line 124
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 124
            if (! (out_position < in_position)) {
#line 124
              goto while_break___1;
            }
            {
#line 125
            putc_unlocked(' ', out);
#line 124
            out_position ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
          {
#line 128
          out_position = in_position;
#line 129
          putc_unlocked((int )c, out);
          }
        }
      }
    }
#line 132
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 137
    tmp___0 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)tp0,
                      (size_t )(text_limit - tp0), & mbstate);
#line 137
    bytes = tmp___0;
    }
#line 139
    if (0UL < bytes) {
#line 139
      if (bytes < 0xfffffffffffffffeUL) {
        {
#line 141
        tmp___1 = wcwidth(wc);
#line 141
        width = tmp___1;
        }
#line 142
        if (0 < width) {
#line 143
          in_position += (size_t )width;
        }
#line 144
        if (in_position <= out_bound) {
          {
#line 146
          out_position = in_position;
#line 147
          fwrite_unlocked((void const   */* __restrict  */)tp0, (size_t )1, bytes,
                          (FILE */* __restrict  */)stdout);
          }
        }
#line 149
        text_pointer = tp0 + bytes;
#line 150
        goto switch_break;
      }
    }
    case_11: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 156
    if (in_position < out_bound) {
      {
#line 157
      putc_unlocked((int )c, out);
      }
    }
#line 158
    goto switch_break;
    case_126: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 181
    tmp___2 = in_position;
#line 181
    in_position ++;
#line 181
    if (tmp___2 < out_bound) {
      {
#line 183
      out_position = in_position;
#line 184
      putc_unlocked((int )c, out);
      }
    }
#line 186
    goto switch_break;
    case_10: /* CIL Label */ 
#line 189
    return (out_position);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  return (out_position);
}
}
#line 200 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/side.c"
static void print_1sdiff_line(char const   * const  *left , char sep , char const   * const  *right ) 
{ 
  FILE *out ;
  size_t hw ;
  size_t c2o ;
  size_t col ;
  _Bool put_newline ;
  size_t tmp ;

  {
#line 204
  out = outfile;
#line 205
  hw = sdiff_half_width;
#line 206
  c2o = sdiff_column2_offset;
#line 207
  col = (size_t )0;
#line 208
  put_newline = (_Bool)0;
#line 210
  if (left) {
    {
#line 212
    put_newline = (_Bool )((int )put_newline | ((int const   )*(*(left + 1) + -1) == 10));
#line 213
    col = print_half_line(left, (size_t )0, hw);
    }
  }
#line 216
  if ((int )sep != 32) {
    {
#line 218
    tmp = tab_from_to(col, ((hw + c2o) - 1UL) / 2UL);
#line 218
    col = tmp + 1UL;
    }
#line 219
    if ((int )sep == 124) {
#line 219
      if ((int )put_newline != ((int const   )*(*(right + 1) + -1) == 10)) {
#line 220
        if (put_newline) {
#line 220
          sep = (char )'/';
        } else {
#line 220
          sep = (char )'\\';
        }
      }
    }
    {
#line 221
    putc_unlocked((int )sep, out);
    }
  }
#line 224
  if (right) {
#line 226
    put_newline = (_Bool )((int )put_newline | ((int const   )*(*(right + 1) + -1) == 10));
#line 227
    if ((int const   )*(*right) != 10) {
      {
#line 229
      col = tab_from_to(col, c2o);
#line 230
      print_half_line(right, col, hw);
      }
    }
  }
#line 234
  if (put_newline) {
    {
#line 235
    putc_unlocked('\n', out);
    }
  }
#line 236
  return;
}
}
#line 239 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/side.c"
static void print_sdiff_common_lines(lin limit0 , lin limit1 ) 
{ 
  lin i0 ;
  lin i1 ;
  long len0 ;
  long len1 ;
  lin tmp ;
  lin tmp___0 ;
  lin tmp___1 ;
  lin tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 242
  i0 = next0;
#line 242
  i1 = next1;
#line 244
  if (! suppress_common_lines) {
#line 244
    if (i0 != limit0) {
#line 244
      goto _L;
    } else
#line 244
    if (i1 != limit1) {
      _L: /* CIL Label */ 
#line 246
      if (sdiff_merge_assist) {
        {
#line 248
        len0 = limit0 - i0;
#line 249
        len1 = limit1 - i1;
#line 250
        fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"i%ld,%ld\n",
                len0, len1);
        }
      }
#line 253
      if (! left_column) {
        {
#line 255
        while (1) {
          while_continue: /* CIL Label */ ;
#line 255
          if (i0 != limit0) {
#line 255
            if (! (i1 != limit1)) {
#line 255
              goto while_break;
            }
          } else {
#line 255
            goto while_break;
          }
          {
#line 256
          tmp = i1;
#line 256
          i1 ++;
#line 256
          tmp___0 = i0;
#line 256
          i0 ++;
#line 256
          print_1sdiff_line((char const   * const  *)(files[0].linbuf + tmp___0),
                            (char )' ', (char const   * const  *)(files[1].linbuf + tmp));
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 258
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 258
          if (! (i1 != limit1)) {
#line 258
            goto while_break___0;
          }
          {
#line 259
          tmp___1 = i1;
#line 259
          i1 ++;
#line 259
          print_1sdiff_line((char const   * const  *)0, (char )')', (char const   * const  *)(files[1].linbuf + tmp___1));
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 261
        if (! (i0 != limit0)) {
#line 261
          goto while_break___1;
        }
        {
#line 262
        tmp___2 = i0;
#line 262
        i0 ++;
#line 262
        print_1sdiff_line((char const   * const  *)(files[0].linbuf + tmp___2), (char )'(',
                          (char const   * const  *)0);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 265
  next0 = limit0;
#line 266
  next1 = limit1;
#line 267
  return;
}
}
#line 273 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/side.c"
static void print_sdiff_hunk(struct change *hunk ) 
{ 
  lin first0 ;
  lin last0 ;
  lin first1 ;
  lin last1 ;
  register lin i ;
  register lin j ;
  enum changes changes ;
  enum changes tmp ;
  long len0 ;
  long len1 ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp14 ;

  {
  {
#line 280
  tmp = analyze_hunk(hunk, & first0, & last0, & first1, & last1);
#line 280
  changes = tmp;
  }
#line 282
  if (! changes) {
#line 283
    return;
  }
  {
#line 286
  print_sdiff_common_lines(first0, first1);
  }
#line 288
  if (sdiff_merge_assist) {
    {
#line 290
    len0 = (last0 - first0) + 1L;
#line 291
    len1 = (last1 - first1) + 1L;
#line 292
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"c%ld,%ld\n",
            len0, len1);
    }
  }
#line 296
  if ((unsigned int )changes == 3U) {
#line 298
    i = first0;
#line 298
    j = first1;
    {
#line 298
    while (1) {
      while_continue: /* CIL Label */ ;
#line 298
      if (i <= last0) {
#line 298
        if (! (j <= last1)) {
#line 298
          goto while_break;
        }
      } else {
#line 298
        goto while_break;
      }
      {
#line 299
      print_1sdiff_line((char const   * const  *)(files[0].linbuf + i), (char )'|',
                        (char const   * const  *)(files[1].linbuf + j));
#line 298
      i ++;
#line 298
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 300
    if (i <= last0) {
#line 300
      tmp___0 = 1;
    } else {
#line 300
      tmp___0 = 0;
    }
#line 300
    if (j <= last1) {
#line 300
      tmp___1 = 2;
    } else {
#line 300
      tmp___1 = 0;
    }
#line 300
    changes = (enum changes )(tmp___0 + tmp___1);
#line 301
    first0 = i;
#line 301
    next0 = first0;
#line 302
    first1 = j;
#line 302
    next1 = first1;
  }
#line 306
  if ((unsigned int )changes & 2U) {
#line 308
    j = first1;
    {
#line 308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 308
      if (! (j <= last1)) {
#line 308
        goto while_break___0;
      }
      {
#line 309
      print_1sdiff_line((char const   * const  *)0, (char )'>', (char const   * const  *)(files[1].linbuf + j));
#line 308
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 310
    next1 = j;
  }
#line 314
  if ((unsigned int )changes & 1U) {
#line 316
    i = first0;
    {
#line 316
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 316
      if (! (i <= last0)) {
#line 316
        goto while_break___1;
      }
      {
#line 317
      print_1sdiff_line((char const   * const  *)(files[0].linbuf + i), (char )'<',
                        (char const   * const  *)0);
#line 316
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 318
    next0 = i;
  }
#line 320
  return;
}
}
#line 576 "/usr/include/stdio.h"
extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 352 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
void print_normal_script(struct change *script ) ;
#line 23 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/normal.c"
static void print_normal_hunk(struct change *hunk ) ;
#line 28 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/normal.c"
void print_normal_script(struct change *script ) 
{ 


  {
  {
#line 31
  print_script(script, & find_change, & print_normal_hunk);
  }
#line 32
  return;
}
}
#line 38 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/normal.c"
static void print_normal_hunk(struct change *hunk ) 
{ 
  lin first0 ;
  lin last0 ;
  lin first1 ;
  lin last1 ;
  register lin i ;
  enum changes changes ;
  enum changes tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 45
  tmp = analyze_hunk(hunk, & first0, & last0, & first1, & last1);
#line 45
  changes = tmp;
  }
#line 46
  if (! changes) {
#line 47
    return;
  }
  {
#line 49
  begin_output();
#line 52
  print_number_range((char )',', & files[0], first0, last0);
#line 53
  fputc_unlocked((int )change_letter[changes], outfile);
#line 54
  print_number_range((char )',', & files[1], first1, last1);
#line 55
  fputc_unlocked('\n', outfile);
  }
#line 58
  if ((unsigned int )changes & 1U) {
#line 59
    i = first0;
    {
#line 59
    while (1) {
      while_continue: /* CIL Label */ ;
#line 59
      if (! (i <= last0)) {
#line 59
        goto while_break;
      }
      {
#line 60
      print_1_line("<", (char const   * const  *)(files[0].linbuf + i));
#line 59
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 62
  if ((unsigned int )changes == 3U) {
    {
#line 63
    fputs_unlocked((char const   */* __restrict  */)"---\n", (FILE */* __restrict  */)outfile);
    }
  }
#line 66
  if ((unsigned int )changes & 2U) {
#line 67
    i = first1;
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 67
      if (! (i <= last1)) {
#line 67
        goto while_break___0;
      }
      {
#line 68
      print_1_line(">", (char const   * const  *)(files[1].linbuf + i));
#line 67
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 69
  return;
}
}
#line 87 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool no_diff_means_no_output ;
#line 91
lin context ;
#line 95
_Bool text ;
#line 98
lin horizon_lines ;
#line 142
struct re_pattern_buffer function_regexp ;
#line 166
_Bool strip_trailing_cr ;
#line 348
void file_block_read(struct file_data *current , size_t size ) ;
#line 349
_Bool read_files(struct file_data *filevec , _Bool pretend_binary ) ;
#line 50 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static lin *buckets  ;
#line 53 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static size_t nbuckets  ;
#line 58 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static struct equivclass *equivs  ;
#line 61 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static lin equivs_index  ;
#line 64 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static lin equivs_alloc  ;
#line 68 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
void file_block_read(struct file_data *current , size_t size ) 
{ 
  size_t s ;
  size_t tmp ;

  {
#line 71
  if (size) {
#line 71
    if (! current->eof) {
      {
#line 73
      tmp = block_read(current->desc, (char *)current->buffer + current->buffered,
                       size);
#line 73
      s = tmp;
      }
#line 75
      if (s == 0xffffffffffffffffUL) {
        {
#line 76
        pfatal_with_name(current->name);
        }
      }
#line 77
      current->buffered += s;
#line 78
      current->eof = (_Bool )(s < size);
    }
  }
#line 80
  return;
}
}
#line 93 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static _Bool sip(struct file_data *current , _Bool skip_test ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 97
  if (current->desc < 0) {
    {
#line 100
    current->bufsize = sizeof(uintmax_t );
#line 101
    tmp = xmalloc(current->bufsize);
#line 101
    current->buffer = (uintmax_t *)tmp;
    }
  } else {
    {
#line 105
    current->bufsize = buffer_lcm(sizeof(uintmax_t ), (size_t )current->stat.st_blksize,
                                  9223372036854775807UL - 2UL * sizeof(uintmax_t ));
#line 108
    tmp___0 = xmalloc(current->bufsize);
#line 108
    current->buffer = (uintmax_t *)tmp___0;
    }
#line 110
    if (! skip_test) {
      {
#line 117
      file_block_read(current, current->bufsize);
#line 118
      tmp___1 = memchr((void const   *)current->buffer, 0, current->buffered);
      }
#line 118
      return ((_Bool )((unsigned long )tmp___1 != (unsigned long )((void *)0)));
    }
  }
#line 122
  current->buffered = (size_t )0;
#line 123
  current->eof = (_Bool)0;
#line 124
  return ((_Bool)0);
}
}
#line 129 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static void slurp(struct file_data *current ) 
{ 
  size_t cc ;
  size_t file_size ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 134
  if (current->desc < 0) {
#line 137
    return;
  }
#line 140
  if ((current->stat.st_mode & 61440U) == 32768U) {
#line 147
    file_size = (size_t )current->stat.st_size;
#line 148
    cc = (file_size + 2UL * sizeof(uintmax_t )) - file_size % sizeof(uintmax_t );
#line 149
    if (file_size != (size_t )current->stat.st_size) {
      {
#line 151
      xalloc_die();
      }
    } else
#line 149
    if (cc < file_size) {
      {
#line 151
      xalloc_die();
      }
    } else
#line 149
    if (9223372036854775807UL <= cc) {
      {
#line 151
      xalloc_die();
      }
    }
#line 153
    if (current->bufsize < cc) {
      {
#line 155
      current->bufsize = cc;
#line 156
      tmp = xrealloc((void *)current->buffer, cc);
#line 156
      current->buffer = (uintmax_t *)tmp;
      }
    }
#line 163
    if (current->buffered <= file_size) {
      {
#line 165
      file_block_read(current, (file_size + 1UL) - current->buffered);
      }
#line 166
      if (current->buffered <= file_size) {
#line 167
        return;
      }
    }
  }
  {
#line 174
  file_block_read(current, current->bufsize - current->buffered);
  }
#line 176
  if (current->buffered) {
    {
#line 178
    while (1) {
      while_continue: /* CIL Label */ ;
#line 178
      if (! (current->buffered == current->bufsize)) {
#line 178
        goto while_break;
      }
#line 180
      if (4611686018427387903UL - sizeof(uintmax_t ) < current->bufsize) {
        {
#line 181
        xalloc_die();
        }
      }
      {
#line 182
      current->bufsize *= 2UL;
#line 183
      tmp___0 = xrealloc((void *)current->buffer, current->bufsize);
#line 183
      current->buffer = (uintmax_t *)tmp___0;
#line 184
      file_block_read(current, current->bufsize - current->buffered);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 189
    cc = current->buffered + 2UL * sizeof(uintmax_t );
#line 190
    current->bufsize = cc - cc % sizeof(uintmax_t );
#line 191
    tmp___1 = xrealloc((void *)current->buffer, current->bufsize);
#line 191
    current->buffer = (uintmax_t *)tmp___1;
    }
  }
#line 193
  return;
}
}
#line 198 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static void find_and_hash_each_line(struct file_data *current ) 
{ 
  char const   *p ;
  lin i ;
  lin *bucket ;
  size_t length ;
  char const   **linbuf ;
  lin alloc_lines ;
  lin line ;
  lin linbuf_base ;
  lin *cureqs ;
  void *tmp ;
  struct equivclass *eqs ;
  lin eqs_index ;
  lin eqs_alloc ;
  char const   *suffix_begin ;
  char const   *bufend ;
  _Bool ig_case ;
  enum DIFF_white_space ig_white_space ;
  _Bool diff_length_compare_anyway ;
  _Bool same_length_diff_contents_compare_anyway ;
  char const   *ip ;
  hash_value h ;
  unsigned char c ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  size_t column ;
  char const   *p1 ;
  unsigned char c1 ;
  char const   *tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  size_t repetitions ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  lin tmp___18 ;
  void *tmp___19 ;
  char const   *eqline ;
  int tmp___20 ;
  _Bool tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  char const   *tmp___25 ;

  {
  {
#line 201
  p = current->prefix_end;
#line 206
  linbuf = current->linbuf;
#line 207
  alloc_lines = current->alloc_lines;
#line 208
  line = (lin )0;
#line 209
  linbuf_base = current->linbuf_base;
#line 210
  tmp = xmalloc((unsigned long )alloc_lines * sizeof(*cureqs));
#line 210
  cureqs = (lin *)tmp;
#line 211
  eqs = equivs;
#line 212
  eqs_index = equivs_index;
#line 213
  eqs_alloc = equivs_alloc;
#line 214
  suffix_begin = current->suffix_begin;
#line 215
  bufend = (char const   *)((char *)current->buffer + current->buffered);
#line 216
  ig_case = ignore_case;
#line 217
  ig_white_space = ignore_white_space;
#line 218
  diff_length_compare_anyway = (_Bool )((unsigned int )ig_white_space != 0U);
#line 220
  same_length_diff_contents_compare_anyway = (_Bool )((int )diff_length_compare_anyway | (int )ig_case);
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! ((unsigned long )p < (unsigned long )suffix_begin)) {
#line 223
      goto while_break;
    }
#line 225
    ip = p;
#line 226
    h = (hash_value )0;
    {
#line 232
    if ((unsigned int )ig_white_space == 5U) {
#line 232
      goto case_5;
    }
#line 238
    if ((unsigned int )ig_white_space == 4U) {
#line 238
      goto case_4;
    }
#line 258
    if ((unsigned int )ig_white_space == 2U) {
#line 258
      goto case_2;
    }
#line 258
    if ((unsigned int )ig_white_space == 3U) {
#line 258
      goto case_2;
    }
#line 258
    if ((unsigned int )ig_white_space == 1U) {
#line 258
      goto case_2;
    }
#line 313
    goto switch_default___0;
    case_5: /* CIL Label */ 
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      tmp___3 = p;
#line 233
      p ++;
#line 233
      c = (unsigned char )*tmp___3;
#line 233
      if (! ((int )c != 10)) {
#line 233
        goto while_break___0;
      }
      {
#line 234
      tmp___2 = __ctype_b_loc();
      }
#line 234
      if (! ((int const   )*(*tmp___2 + (int )c) & 8192)) {
#line 235
        if (ig_case) {
          {
#line 235
          tmp___0 = tolower((int )c);
#line 235
          tmp___1 = tmp___0;
          }
        } else {
#line 235
          tmp___1 = (int )c;
        }
#line 235
        h = (unsigned long )tmp___1 + ((h << 7) | (h >> (sizeof(h) * 8UL - 7UL)));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 236
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 239
      tmp___9 = p;
#line 239
      p ++;
#line 239
      c = (unsigned char )*tmp___9;
#line 239
      if (! ((int )c != 10)) {
#line 239
        goto while_break___1;
      }
      {
#line 241
      tmp___6 = __ctype_b_loc();
      }
#line 241
      if ((int const   )*(*tmp___6 + (int )c) & 8192) {
        {
#line 243
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 244
          tmp___4 = p;
#line 244
          p ++;
#line 244
          c = (unsigned char )*tmp___4;
#line 244
          if ((int )c == 10) {
#line 245
            goto hashing_done;
          }
          {
#line 243
          tmp___5 = __ctype_b_loc();
          }
#line 243
          if (! ((int const   )*(*tmp___5 + (int )c) & 8192)) {
#line 243
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 248
        h = 32UL + ((h << 7) | (h >> (sizeof(h) * 8UL - 7UL)));
      }
#line 252
      if (ig_case) {
        {
#line 252
        tmp___7 = tolower((int )c);
#line 252
        tmp___8 = tmp___7;
        }
      } else {
#line 252
        tmp___8 = (int )c;
      }
#line 252
      h = (unsigned long )tmp___8 + ((h << 7) | (h >> (sizeof(h) * 8UL - 7UL)));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 254
    goto switch_break;
    case_2: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 260
    column = (size_t )0;
    {
#line 261
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 261
      tmp___14 = p;
#line 261
      p ++;
#line 261
      c = (unsigned char )*tmp___14;
#line 261
      if (! ((int )c != 10)) {
#line 261
        goto while_break___3;
      }
#line 263
      if ((unsigned int )ig_white_space & 2U) {
        {
#line 263
        tmp___12 = __ctype_b_loc();
        }
#line 263
        if ((int const   )*(*tmp___12 + (int )c) & 8192) {
#line 266
          p1 = p;
          {
#line 268
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 269
            tmp___10 = p1;
#line 269
            p1 ++;
#line 269
            c1 = (unsigned char )*tmp___10;
#line 269
            if ((int )c1 == 10) {
#line 271
              p = p1;
#line 272
              goto hashing_done;
            }
            {
#line 268
            tmp___11 = __ctype_b_loc();
            }
#line 268
            if (! ((int const   )*(*tmp___11 + (int )c1) & 8192)) {
#line 268
              goto while_break___4;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      }
#line 277
      repetitions = (size_t )1;
#line 279
      if ((unsigned int )ig_white_space & 1U) {
        {
#line 282
        if ((int )c == 8) {
#line 282
          goto case_8;
        }
#line 286
        if ((int )c == 9) {
#line 286
          goto case_9;
        }
#line 294
        if ((int )c == 13) {
#line 294
          goto case_13;
        }
#line 298
        goto switch_default;
        case_8: /* CIL Label */ 
#line 283
        column -= (size_t )(0UL < column);
#line 284
        goto switch_break___0;
        case_9: /* CIL Label */ 
#line 287
        c = (unsigned char )' ';
#line 288
        repetitions = tabsize - column % tabsize;
#line 289
        if (column + repetitions < column) {
#line 289
          column = (size_t )0;
        } else {
#line 289
          column += repetitions;
        }
#line 292
        goto switch_break___0;
        case_13: /* CIL Label */ 
#line 295
        column = (size_t )0;
#line 296
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 299
        column ++;
#line 300
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
#line 303
      if (ig_case) {
        {
#line 304
        tmp___13 = tolower((int )c);
#line 304
        c = (unsigned char )tmp___13;
        }
      }
      {
#line 306
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 307
        h = (unsigned long )c + ((h << 7) | (h >> (sizeof(h) * 8UL - 7UL)));
#line 306
        repetitions --;
#line 306
        if (! (repetitions != 0UL)) {
#line 306
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 311
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 314
    if (ig_case) {
      {
#line 315
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 315
        tmp___16 = p;
#line 315
        p ++;
#line 315
        c = (unsigned char )*tmp___16;
#line 315
        if (! ((int )c != 10)) {
#line 315
          goto while_break___6;
        }
        {
#line 316
        tmp___15 = tolower((int )c);
#line 316
        h = (unsigned long )tmp___15 + ((h << 7) | (h >> (sizeof(h) * 8UL - 7UL)));
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
      {
#line 318
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 318
        tmp___17 = p;
#line 318
        p ++;
#line 318
        c = (unsigned char )*tmp___17;
#line 318
        if (! ((int )c != 10)) {
#line 318
          goto while_break___7;
        }
#line 319
        h = (unsigned long )c + ((h << 7) | (h >> (sizeof(h) * 8UL - 7UL)));
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 320
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    hashing_done: 
#line 325
    bucket = buckets + h % nbuckets;
#line 326
    length = (size_t )((p - ip) - 1L);
#line 328
    if ((unsigned long )p == (unsigned long )bufend) {
#line 328
      if (current->missing_newline) {
#line 328
        if ((unsigned int )output_style != 4U) {
#line 328
          if ((unsigned int )output_style != 5U) {
#line 337
            if ((unsigned int )ig_white_space < 2U) {
#line 338
              bucket = buckets + -1;
            }
          }
        }
      }
    }
#line 341
    i = *bucket;
    {
#line 341
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 342
      if (! i) {
#line 345
        tmp___18 = eqs_index;
#line 345
        eqs_index ++;
#line 345
        i = tmp___18;
#line 346
        if (i == eqs_alloc) {
#line 348
          if (9223372036854775807UL / (2UL * sizeof(*eqs)) <= (unsigned long )eqs_alloc) {
            {
#line 349
            xalloc_die();
            }
          }
          {
#line 350
          eqs_alloc *= 2L;
#line 351
          tmp___19 = xrealloc((void *)eqs, (unsigned long )eqs_alloc * sizeof(*eqs));
#line 351
          eqs = (struct equivclass *)tmp___19;
          }
        }
#line 353
        (eqs + i)->next = *bucket;
#line 354
        (eqs + i)->hash = h;
#line 355
        (eqs + i)->line = ip;
#line 356
        (eqs + i)->length = length;
#line 357
        *bucket = i;
#line 358
        goto while_break___8;
      } else
#line 360
      if ((eqs + i)->hash == h) {
#line 362
        eqline = (eqs + i)->line;
#line 366
        if ((eqs + i)->length == length) {
          {
#line 371
          tmp___20 = memcmp((void const   *)eqline, (void const   *)ip, length);
          }
#line 371
          if (tmp___20 == 0) {
#line 372
            goto while_break___8;
          }
#line 373
          if (! same_length_diff_contents_compare_anyway) {
#line 374
            goto __Cont;
          }
        } else
#line 376
        if (! diff_length_compare_anyway) {
#line 377
          goto __Cont;
        }
        {
#line 379
        tmp___21 = lines_differ(eqline, ip);
        }
#line 379
        if (! tmp___21) {
#line 380
          goto while_break___8;
        }
      }
      __Cont: /* CIL Label */ 
#line 341
      i = (eqs + i)->next;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 384
    if (line == alloc_lines) {
#line 387
      if (3074457345618258602L <= alloc_lines) {
        {
#line 390
        xalloc_die();
        }
      } else
#line 387
      if (9223372036854775807UL / sizeof(*cureqs) <= (unsigned long )(2L * alloc_lines - linbuf_base)) {
        {
#line 390
        xalloc_die();
        }
      } else
#line 387
      if (9223372036854775807UL / sizeof(*linbuf) <= (unsigned long )(alloc_lines - linbuf_base)) {
        {
#line 390
        xalloc_die();
        }
      }
      {
#line 391
      alloc_lines = 2L * alloc_lines - linbuf_base;
#line 392
      tmp___22 = xrealloc((void *)cureqs, (unsigned long )alloc_lines * sizeof(*cureqs));
#line 392
      cureqs = (lin *)tmp___22;
#line 393
      linbuf += linbuf_base;
#line 394
      tmp___23 = xrealloc((void *)linbuf, (unsigned long )(alloc_lines - linbuf_base) * sizeof(*linbuf));
#line 394
      linbuf = (char const   **)tmp___23;
#line 396
      linbuf -= linbuf_base;
      }
    }
#line 398
    *(linbuf + line) = ip;
#line 399
    *(cureqs + line) = i;
#line 400
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  current->buffered_lines = line;
#line 405
  i = (lin )0;
  {
#line 405
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 410
    if (line == alloc_lines) {
#line 413
      if (3074457345618258602L <= alloc_lines) {
        {
#line 416
        xalloc_die();
        }
      } else
#line 413
      if (9223372036854775807UL / sizeof(*cureqs) <= (unsigned long )(2L * alloc_lines - linbuf_base)) {
        {
#line 416
        xalloc_die();
        }
      } else
#line 413
      if (9223372036854775807UL / sizeof(*linbuf) <= (unsigned long )(alloc_lines - linbuf_base)) {
        {
#line 416
        xalloc_die();
        }
      }
      {
#line 417
      alloc_lines = 2L * alloc_lines - linbuf_base;
#line 418
      linbuf += linbuf_base;
#line 419
      tmp___24 = xrealloc((void *)linbuf, (unsigned long )(alloc_lines - linbuf_base) * sizeof(*linbuf));
#line 419
      linbuf = (char const   **)tmp___24;
#line 421
      linbuf -= linbuf_base;
      }
    }
#line 423
    *(linbuf + line) = p;
#line 425
    if ((unsigned long )p == (unsigned long )bufend) {
#line 429
      if (current->missing_newline) {
#line 429
        if ((unsigned int )output_style != 4U) {
#line 429
          if ((unsigned int )output_style != 5U) {
#line 430
            (*(linbuf + line)) --;
          }
        }
      }
#line 431
      goto while_break___9;
    }
#line 434
    if (context <= i) {
#line 434
      if (no_diff_means_no_output) {
#line 435
        goto while_break___9;
      }
    }
#line 437
    line ++;
    {
#line 439
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 439
      tmp___25 = p;
#line 439
      p ++;
#line 439
      if (! ((int const   )*tmp___25 != 10)) {
#line 439
        goto while_break___10;
      }
#line 440
      goto while_continue___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 405
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 444
  current->linbuf = linbuf;
#line 445
  current->valid_lines = line;
#line 446
  current->alloc_lines = alloc_lines;
#line 447
  current->equivs = cureqs;
#line 448
  equivs = eqs;
#line 449
  equivs_alloc = eqs_alloc;
#line 450
  equivs_index = eqs_index;
#line 451
  return;
}
}
#line 458 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static void prepare_text(struct file_data *current ) 
{ 
  size_t buffered ;
  char *p ;
  char *dst ;
  size_t tmp ;
  char const   *src ;
  char const   *srclim ;
  char tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 461
  buffered = current->buffered;
#line 462
  p = (char *)current->buffer;
#line 465
  if (buffered == 0UL) {
#line 466
    current->missing_newline = (_Bool)0;
  } else
#line 465
  if ((int )*(p + (buffered - 1UL)) == 10) {
#line 466
    current->missing_newline = (_Bool)0;
  } else {
#line 469
    tmp = buffered;
#line 469
    buffered ++;
#line 469
    *(p + tmp) = (char )'\n';
#line 470
    current->missing_newline = (_Bool)1;
  }
#line 473
  if (! p) {
#line 474
    return;
  }
  {
#line 477
  memset((void *)(p + buffered), 0, sizeof(uintmax_t ));
  }
#line 479
  if (strip_trailing_cr) {
    {
#line 479
    tmp___3 = memchr((void const   *)p, '\r', buffered);
#line 479
    dst = (char *)tmp___3;
    }
#line 479
    if (dst) {
#line 481
      src = (char const   *)dst;
#line 482
      srclim = (char const   *)(p + buffered);
      {
#line 484
      while (1) {
        while_continue: /* CIL Label */ ;
#line 485
        tmp___1 = src;
#line 485
        src ++;
#line 485
        tmp___0 = (char )*tmp___1;
#line 485
        *dst = tmp___0;
#line 485
        if ((int )tmp___0 == 13) {
#line 485
          if ((int const   )*src == 10) {
#line 485
            tmp___2 = 0;
          } else {
#line 485
            tmp___2 = 1;
          }
        } else {
#line 485
          tmp___2 = 1;
        }
#line 485
        dst += tmp___2;
#line 484
        if (! ((unsigned long )src < (unsigned long )srclim)) {
#line 484
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 488
      buffered -= (size_t )(src - (char const   *)dst);
    }
  }
#line 491
  current->buffered = buffered;
#line 492
  return;
}
}
#line 498 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static lin guess_lines(lin n , size_t s , size_t t ) 
{ 
  size_t guessed_bytes_per_line ;
  size_t tmp ;
  lin guessed_lines ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 501
  if (n < 10L) {
#line 501
    tmp = (size_t )32;
  } else {
#line 501
    tmp = s / (size_t )(n - 1L);
  }
#line 501
  guessed_bytes_per_line = tmp;
#line 502
  if (1UL >= t / guessed_bytes_per_line) {
#line 502
    tmp___0 = (size_t )1;
  } else {
#line 502
    tmp___0 = t / guessed_bytes_per_line;
  }
#line 502
  guessed_lines = (lin )tmp___0;
#line 503
  if ((unsigned long )guessed_lines <= 9223372036854775807UL / (2UL * sizeof(char *) + 1UL) - 5UL) {
#line 503
    tmp___1 = (unsigned long )guessed_lines;
  } else {
#line 503
    tmp___1 = 9223372036854775807UL / (2UL * sizeof(char *) + 1UL) - 5UL;
  }
#line 503
  return ((lin )(tmp___1 + 5UL));
}
}
#line 509 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static void find_identical_ends(struct file_data *filevec ) 
{ 
  uintmax_t *w0 ;
  uintmax_t *w1 ;
  char *p0 ;
  char *p1 ;
  char *buffer0 ;
  char *buffer1 ;
  char const   *end0 ;
  char const   *beg0 ;
  char const   **linbuf0 ;
  char const   **linbuf1 ;
  lin i ;
  lin lines ;
  size_t n0 ;
  size_t n1 ;
  lin alloc_lines0 ;
  lin alloc_lines1 ;
  lin buffered_prefix ;
  lin prefix_count ;
  lin prefix_mask ;
  lin middle_guess ;
  lin suffix_guess ;
  lin tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  lin tmp___3 ;
  lin tmp___4 ;
  void *tmp___5 ;
  lin l ;
  lin tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  lin tmp___9 ;
  void *tmp___10 ;
  lin tmp___11 ;
  lin tmp___12 ;

  {
  {
#line 522
  slurp(filevec + 0);
#line 523
  prepare_text(filevec + 0);
  }
#line 524
  if ((filevec + 0)->desc != (filevec + 1)->desc) {
    {
#line 526
    slurp(filevec + 1);
#line 527
    prepare_text(filevec + 1);
    }
  } else {
#line 531
    (filevec + 1)->buffer = (filevec + 0)->buffer;
#line 532
    (filevec + 1)->bufsize = (filevec + 0)->bufsize;
#line 533
    (filevec + 1)->buffered = (filevec + 0)->buffered;
#line 534
    (filevec + 1)->missing_newline = (filevec + 0)->missing_newline;
  }
#line 539
  w0 = (filevec + 0)->buffer;
#line 540
  w1 = (filevec + 1)->buffer;
#line 541
  buffer0 = (char *)w0;
#line 541
  p0 = buffer0;
#line 542
  buffer1 = (char *)w1;
#line 542
  p1 = buffer1;
#line 543
  n0 = (filevec + 0)->buffered;
#line 544
  n1 = (filevec + 1)->buffered;
#line 546
  if ((unsigned long )p0 == (unsigned long )p1) {
#line 548
    p1 += n1;
#line 548
    p0 = p1;
  } else {
#line 554
    if (n0 < n1) {
#line 555
      *(p0 + n0) = (char )(~ ((int )*(p1 + n0)));
    } else {
#line 557
      *(p1 + n1) = (char )(~ ((int )*(p0 + n1)));
    }
    {
#line 562
    while (1) {
      while_continue: /* CIL Label */ ;
#line 562
      if (! (*w0 == *w1)) {
#line 562
        goto while_break;
      }
#line 563
      w0 ++;
#line 563
      w1 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 566
    p0 = (char *)w0;
#line 567
    p1 = (char *)w1;
    {
#line 568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 568
      if (! ((int )*p0 == (int )*p1)) {
#line 568
        goto while_break___0;
      }
#line 569
      p0 ++;
#line 569
      p1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 572
    if ((unsigned int )output_style != 4U) {
#line 572
      if ((unsigned int )output_style != 5U) {
#line 572
        if (((unsigned long )((buffer0 + n0) - (int )(filevec + 0)->missing_newline) < (unsigned long )p0) != ((unsigned long )((buffer1 + n1) - (int )(filevec + 1)->missing_newline) < (unsigned long )p1)) {
#line 576
          p0 --;
#line 576
          p1 --;
        }
      }
    }
  }
#line 583
  i = horizon_lines;
  {
#line 584
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 584
    if ((unsigned long )p0 != (unsigned long )buffer0) {
#line 584
      if (! ((int )*(p0 + -1) != 10)) {
#line 584
        tmp = i;
#line 584
        i --;
#line 584
        if (! tmp) {
#line 584
          goto while_break___1;
        }
      }
    } else {
#line 584
      goto while_break___1;
    }
#line 585
    p0 --;
#line 585
    p1 --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 588
  (filevec + 0)->prefix_end = (char const   *)p0;
#line 589
  (filevec + 1)->prefix_end = (char const   *)p1;
#line 594
  p0 = buffer0 + n0;
#line 595
  p1 = buffer1 + n1;
#line 597
  if ((unsigned int )output_style != 4U) {
#line 597
    if ((unsigned int )output_style != 5U) {
#line 597
      if ((int )(filevec + 0)->missing_newline == (int )(filevec + 1)->missing_newline) {
        _L___0: /* CIL Label */ 
#line 600
        end0 = (char const   *)p0;
#line 605
        if (n0 < n1) {
#line 605
          tmp___0 = (size_t )0;
        } else {
#line 605
          tmp___0 = n0 - n1;
        }
#line 605
        beg0 = (filevec + 0)->prefix_end + tmp___0;
        {
#line 608
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 608
          if (! ((unsigned long )p0 != (unsigned long )beg0)) {
#line 608
            goto while_break___2;
          }
#line 609
          p0 --;
#line 609
          p1 --;
#line 609
          if ((int )*p0 != (int )*p1) {
#line 612
            p0 ++;
#line 612
            p1 ++;
#line 613
            beg0 = (char const   *)p0;
#line 614
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 621
        if ((unsigned long )buffer0 == (unsigned long )p0) {
#line 621
          goto _L;
        } else
#line 621
        if ((int )*(p0 + -1) == 10) {
          _L: /* CIL Label */ 
#line 621
          if ((unsigned long )buffer1 == (unsigned long )p1) {
#line 621
            tmp___1 = 0;
          } else
#line 621
          if ((int )*(p1 + -1) == 10) {
#line 621
            tmp___1 = 0;
          } else {
#line 621
            tmp___1 = 1;
          }
        } else {
#line 621
          tmp___1 = 1;
        }
#line 621
        i = horizon_lines + (lin )tmp___1;
        {
#line 624
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 624
          tmp___3 = i;
#line 624
          i --;
#line 624
          if (tmp___3) {
#line 624
            if (! ((unsigned long )p0 != (unsigned long )end0)) {
#line 624
              goto while_break___3;
            }
          } else {
#line 624
            goto while_break___3;
          }
          {
#line 625
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 625
            tmp___2 = p0;
#line 625
            p0 ++;
#line 625
            if (! ((int )*tmp___2 != 10)) {
#line 625
              goto while_break___4;
            }
#line 626
            goto while_continue___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 628
        p1 += p0 - (char *)beg0;
      }
    } else {
#line 597
      goto _L___0;
    }
  } else {
#line 597
    goto _L___0;
  }
#line 632
  (filevec + 0)->suffix_begin = (char const   *)p0;
#line 633
  (filevec + 1)->suffix_begin = (char const   *)p1;
#line 649
  if (no_diff_means_no_output) {
#line 649
    if (! function_regexp.fastmap) {
#line 649
      if (context < 2305843009213693951L) {
#line 649
        if ((size_t )context < n0) {
          {
#line 652
          middle_guess = guess_lines((lin )0, (size_t )0, (size_t )(p0 - (char *)(filevec + 0)->prefix_end));
#line 653
          suffix_guess = guess_lines((lin )0, (size_t )0, (size_t )((buffer0 + n0) - p0));
#line 654
          prefix_count = (lin )1;
          }
          {
#line 654
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 654
            if (! (prefix_count <= context)) {
#line 654
              goto while_break___5;
            }
#line 655
            goto __Cont;
            __Cont: /* CIL Label */ 
#line 654
            prefix_count *= 2L;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 656
          if (context <= suffix_guess) {
#line 656
            tmp___4 = context;
          } else {
#line 656
            tmp___4 = suffix_guess;
          }
#line 656
          alloc_lines0 = (prefix_count + middle_guess) + tmp___4;
        } else {
          {
#line 661
          prefix_count = (lin )0;
#line 662
          alloc_lines0 = guess_lines((lin )0, (size_t )0, n0);
          }
        }
      } else {
        {
#line 661
        prefix_count = (lin )0;
#line 662
        alloc_lines0 = guess_lines((lin )0, (size_t )0, n0);
        }
      }
    } else {
      {
#line 661
      prefix_count = (lin )0;
#line 662
      alloc_lines0 = guess_lines((lin )0, (size_t )0, n0);
      }
    }
  } else {
    {
#line 661
    prefix_count = (lin )0;
#line 662
    alloc_lines0 = guess_lines((lin )0, (size_t )0, n0);
    }
  }
  {
#line 665
  prefix_mask = prefix_count - 1L;
#line 666
  lines = (lin )0;
#line 667
  tmp___5 = xmalloc((unsigned long )alloc_lines0 * sizeof(*linbuf0));
#line 667
  linbuf0 = (char const   **)tmp___5;
#line 668
  p0 = buffer0;
  }
#line 671
  if (no_diff_means_no_output) {
#line 671
    if ((unsigned long )(filevec + 0)->prefix_end == (unsigned long )p0) {
#line 671
      if (! ((unsigned long )(filevec + 1)->prefix_end == (unsigned long )p1)) {
#line 671
        goto _L___2;
      }
    } else {
#line 671
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 675
    end0 = (filevec + 0)->prefix_end;
    {
#line 676
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 676
      if (! ((unsigned long )p0 != (unsigned long )end0)) {
#line 676
        goto while_break___6;
      }
#line 678
      tmp___6 = lines;
#line 678
      lines ++;
#line 678
      l = tmp___6 & prefix_mask;
#line 679
      if (l == alloc_lines0) {
#line 681
        if (9223372036854775807UL / (2UL * sizeof(*linbuf0)) <= (unsigned long )alloc_lines0) {
          {
#line 682
          xalloc_die();
          }
        }
        {
#line 683
        alloc_lines0 *= 2L;
#line 684
        tmp___7 = xrealloc((void *)linbuf0, (unsigned long )alloc_lines0 * sizeof(*linbuf0));
#line 684
        linbuf0 = (char const   **)tmp___7;
        }
      }
#line 686
      *(linbuf0 + l) = (char const   *)p0;
      {
#line 687
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 687
        tmp___8 = p0;
#line 687
        p0 ++;
#line 687
        if (! ((int )*tmp___8 != 10)) {
#line 687
          goto while_break___7;
        }
#line 688
        goto while_continue___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 691
  if (prefix_count) {
#line 691
    if (context < lines) {
#line 691
      buffered_prefix = context;
    } else {
#line 691
      buffered_prefix = lines;
    }
  } else {
#line 691
    buffered_prefix = lines;
  }
  {
#line 695
  middle_guess = guess_lines(lines, (size_t )(p0 - buffer0), (size_t )(p1 - (char *)(filevec + 1)->prefix_end));
#line 696
  suffix_guess = guess_lines(lines, (size_t )(p0 - buffer0), (size_t )((buffer1 + n1) - p1));
  }
#line 697
  if (context <= suffix_guess) {
#line 697
    tmp___9 = context;
  } else {
#line 697
    tmp___9 = suffix_guess;
  }
#line 697
  alloc_lines1 = (buffered_prefix + middle_guess) + tmp___9;
#line 698
  if (alloc_lines1 < buffered_prefix) {
    {
#line 700
    xalloc_die();
    }
  } else
#line 698
  if (9223372036854775807UL / sizeof(*linbuf1) <= (unsigned long )alloc_lines1) {
    {
#line 700
    xalloc_die();
    }
  }
  {
#line 701
  tmp___10 = xmalloc((unsigned long )alloc_lines1 * sizeof(*linbuf1));
#line 701
  linbuf1 = (char const   **)tmp___10;
  }
#line 703
  if (buffered_prefix != lines) {
#line 706
    i = (lin )0;
    {
#line 706
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 706
      if (! (i < buffered_prefix)) {
#line 706
        goto while_break___8;
      }
#line 707
      *(linbuf1 + i) = *(linbuf0 + (((lines - context) + i) & prefix_mask));
#line 706
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 708
    i = (lin )0;
    {
#line 708
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 708
      if (! (i < buffered_prefix)) {
#line 708
        goto while_break___9;
      }
#line 709
      *(linbuf0 + i) = *(linbuf1 + i);
#line 708
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 713
  i = (lin )0;
  {
#line 713
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 713
    if (! (i < buffered_prefix)) {
#line 713
      goto while_break___10;
    }
#line 714
    *(linbuf1 + i) = (char const   *)(buffer1 + (*(linbuf0 + i) - (char const   *)buffer0));
#line 713
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 718
  (filevec + 0)->linbuf = linbuf0 + buffered_prefix;
#line 719
  (filevec + 1)->linbuf = linbuf1 + buffered_prefix;
#line 720
  tmp___11 = - buffered_prefix;
#line 720
  (filevec + 1)->linbuf_base = tmp___11;
#line 720
  (filevec + 0)->linbuf_base = tmp___11;
#line 721
  (filevec + 0)->alloc_lines = alloc_lines0 - buffered_prefix;
#line 722
  (filevec + 1)->alloc_lines = alloc_lines1 - buffered_prefix;
#line 723
  tmp___12 = lines;
#line 723
  (filevec + 1)->prefix_lines = tmp___12;
#line 723
  (filevec + 0)->prefix_lines = tmp___12;
#line 724
  return;
}
}
#line 730 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
static unsigned char const   prime_offset[64]  = 
#line 730
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )5,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )9, 
        (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )19, 
        (unsigned char const   )15,      (unsigned char const   )1,      (unsigned char const   )5,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )9,      (unsigned char const   )3,      (unsigned char const   )15, 
        (unsigned char const   )3,      (unsigned char const   )39,      (unsigned char const   )5,      (unsigned char const   )39, 
        (unsigned char const   )57,      (unsigned char const   )3,      (unsigned char const   )35,      (unsigned char const   )1, 
        (unsigned char const   )5,      (unsigned char const   )9,      (unsigned char const   )41,      (unsigned char const   )31, 
        (unsigned char const   )5,      (unsigned char const   )25,      (unsigned char const   )45,      (unsigned char const   )7, 
        (unsigned char const   )87,      (unsigned char const   )21,      (unsigned char const   )11,      (unsigned char const   )57, 
        (unsigned char const   )17,      (unsigned char const   )55,      (unsigned char const   )21,      (unsigned char const   )115, 
        (unsigned char const   )59,      (unsigned char const   )81,      (unsigned char const   )27,      (unsigned char const   )129, 
        (unsigned char const   )47,      (unsigned char const   )111,      (unsigned char const   )33,      (unsigned char const   )55, 
        (unsigned char const   )5,      (unsigned char const   )13,      (unsigned char const   )27,      (unsigned char const   )55, 
        (unsigned char const   )93,      (unsigned char const   )1,      (unsigned char const   )57,      (unsigned char const   )25};
#line 747 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/io.c"
_Bool read_files(struct file_data *filevec , _Bool pretend_binary ) 
{ 
  int i ;
  _Bool skip_test ;
  _Bool appears_binary ;
  _Bool tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  lin tmp___3 ;

  {
  {
#line 751
  skip_test = (_Bool )((int )text | (int )pretend_binary);
#line 752
  tmp = sip(filevec + 0, skip_test);
#line 752
  appears_binary = (_Bool )((int )pretend_binary | (int )tmp);
  }
#line 754
  if ((filevec + 0)->desc != (filevec + 1)->desc) {
    {
#line 755
    tmp___0 = sip(filevec + 1, (_Bool )((int )skip_test | (int )appears_binary));
#line 755
    appears_binary = (_Bool )((int )appears_binary | (int )tmp___0);
    }
  } else {
#line 758
    (filevec + 1)->buffer = (filevec + 0)->buffer;
#line 759
    (filevec + 1)->bufsize = (filevec + 0)->bufsize;
#line 760
    (filevec + 1)->buffered = (filevec + 0)->buffered;
  }
#line 762
  if (appears_binary) {
#line 765
    return ((_Bool)1);
  }
  {
#line 768
  find_identical_ends(filevec);
#line 770
  equivs_alloc = ((filevec + 0)->alloc_lines + (filevec + 1)->alloc_lines) + 1L;
  }
#line 771
  if (9223372036854775807UL / sizeof(*equivs) <= (unsigned long )equivs_alloc) {
    {
#line 772
    xalloc_die();
    }
  }
  {
#line 773
  tmp___1 = xmalloc((unsigned long )equivs_alloc * sizeof(*equivs));
#line 773
  equivs = (struct equivclass *)tmp___1;
#line 776
  equivs_index = (lin )1;
#line 781
  i = 9;
  }
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! (1UL << i < (size_t )(equivs_alloc / 3L))) {
#line 781
      goto while_break;
    }
#line 782
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 781
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 783
  nbuckets = (1UL << i) - (size_t )prime_offset[i];
#line 784
  if (9223372036854775807UL / sizeof(*buckets) <= nbuckets) {
    {
#line 785
    xalloc_die();
    }
  }
  {
#line 786
  tmp___2 = zalloc((nbuckets + 1UL) * sizeof(*buckets));
#line 786
  buckets = (lin *)tmp___2;
#line 787
  buckets ++;
#line 789
  i = 0;
  }
  {
#line 789
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 789
    if (! (i < 2)) {
#line 789
      goto while_break___0;
    }
    {
#line 790
    find_and_hash_each_line(filevec + i);
#line 789
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 792
  tmp___3 = equivs_index;
#line 792
  (filevec + 1)->equiv_max = tmp___3;
#line 792
  (filevec + 0)->equiv_max = tmp___3;
#line 794
  free((void *)equivs);
#line 795
  free((void *)(buckets - 1));
  }
#line 797
  return ((_Bool)0);
}
}
#line 177 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
char const   *group_format[4] ;
#line 180
char const   *line_format[3] ;
#line 345
void print_ifdef_script(struct change *script ) ;
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static char const   *format_group(FILE *out , char const   *format , char endchar ,
                                  struct group  const  *groups ) ;
#line 35
static char const   *do_printf_spec(FILE *out , char const   *spec , struct file_data  const  *file ,
                                    lin n , struct group  const  *groups ) ;
#line 38
static char const   *scan_char_literal(char const   *lit , char *valptr ) ;
#line 39
static lin groups_letter_value(struct group  const  *g , char letter ) ;
#line 40
static void format_ifdef(char const   *format , lin beg0 , lin end0 , lin beg1 , lin end1 ) ;
#line 41
static void print_ifdef_hunk(struct change *hunk ) ;
#line 42
static void print_ifdef_lines(FILE *out , char const   *format , struct group  const  *group ) ;
#line 44 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static lin next_line0  ;
#line 45 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static lin next_line1  ;
#line 49 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
void print_ifdef_script(struct change *script ) 
{ 


  {
  {
#line 52
  next_line1 = - files[0].prefix_lines;
#line 52
  next_line0 = next_line1;
#line 53
  print_script(script, & find_change, & print_ifdef_hunk);
  }
#line 54
  if (next_line0 < files[0].valid_lines) {
    {
#line 57
    begin_output();
#line 58
    format_ifdef(group_format[0], next_line0, files[0].valid_lines, next_line1, files[1].valid_lines);
    }
  } else
#line 54
  if (next_line1 < files[1].valid_lines) {
    {
#line 57
    begin_output();
#line 58
    format_ifdef(group_format[0], next_line0, files[0].valid_lines, next_line1, files[1].valid_lines);
    }
  }
#line 62
  return;
}
}
#line 68 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static void print_ifdef_hunk(struct change *hunk ) 
{ 
  lin first0 ;
  lin last0 ;
  lin first1 ;
  lin last1 ;
  enum changes changes ;
  enum changes tmp ;

  {
  {
#line 74
  tmp = analyze_hunk(hunk, & first0, & last0, & first1, & last1);
#line 74
  changes = tmp;
  }
#line 75
  if (! changes) {
#line 76
    return;
  }
  {
#line 78
  begin_output();
  }
#line 81
  if (next_line0 < first0) {
    {
#line 82
    format_ifdef(group_format[0], next_line0, first0, next_line1, first1);
    }
  } else
#line 81
  if (next_line1 < first1) {
    {
#line 82
    format_ifdef(group_format[0], next_line0, first0, next_line1, first1);
    }
  }
  {
#line 87
  next_line0 = last0 + 1L;
#line 88
  next_line1 = last1 + 1L;
#line 89
  format_ifdef(group_format[changes], first0, next_line0, first1, next_line1);
  }
#line 92
  return;
}
}
#line 98 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static void format_ifdef(char const   *format , lin beg0 , lin end0 , lin beg1 , lin end1 ) 
{ 
  struct group groups[2] ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 103
  groups[0].file = (struct file_data  const  *)(& files[0]);
#line 104
  groups[0].from = beg0;
#line 105
  groups[0].upto = end0;
#line 106
  groups[1].file = (struct file_data  const  *)(& files[1]);
#line 107
  groups[1].from = beg1;
#line 108
  groups[1].upto = end1;
#line 109
  format_group(outfile, format, (char)0, (struct group  const  *)(groups));
  }
#line 110
  return;
}
}
#line 118 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static char const   *format_group(FILE *out , char const   *format , char endchar ,
                                  struct group  const  *groups ) 
{ 
  register char c ;
  register char const   *f ;
  char const   *f1 ;
  char const   *tmp ;
  int i ;
  uintmax_t value___0[2] ;
  FILE *thenout ;
  FILE *elseout ;
  char *fend ;
  int *tmp___0 ;
  int *tmp___1 ;
  lin tmp___2 ;
  char const   *tmp___3 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 123
  f = format;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    c = (char )*f;
#line 125
    if ((int )c != (int )endchar) {
#line 125
      if (! ((int )c != 0)) {
#line 125
        goto while_break;
      }
    } else {
#line 125
      goto while_break;
    }
#line 127
    f ++;
#line 127
    f1 = f;
#line 128
    if ((int )c == 37) {
#line 129
      tmp = f;
#line 129
      f ++;
#line 129
      c = (char )*tmp;
      {
#line 131
      if ((int )c == 37) {
#line 131
        goto case_37;
      }
#line 134
      if ((int )c == 40) {
#line 134
        goto case_40;
      }
#line 176
      if ((int )c == 60) {
#line 176
        goto case_60;
      }
#line 181
      if ((int )c == 61) {
#line 181
        goto case_61;
      }
#line 186
      if ((int )c == 62) {
#line 186
        goto case_62;
      }
#line 191
      goto switch_default;
      case_37: /* CIL Label */ 
#line 132
      goto switch_break;
      case_40: /* CIL Label */ 
#line 141
      i = 0;
      {
#line 141
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 141
        if (! (i < 2)) {
#line 141
          goto while_break___0;
        }
#line 143
        if ((unsigned int )*f - 48U <= 9U) {
          {
#line 146
          tmp___0 = __errno_location();
#line 146
          *tmp___0 = 0;
#line 147
          value___0[i] = strtoumax((char const   */* __restrict  */)f, (char **/* __restrict  */)(& fend),
                                   10);
#line 148
          tmp___1 = __errno_location();
          }
#line 148
          if (*tmp___1) {
#line 149
            goto bad_format;
          }
#line 150
          f = (char const   *)fend;
        } else {
          {
#line 154
          tmp___2 = groups_letter_value(groups, (char )*f);
#line 154
          value___0[i] = (uintmax_t )tmp___2;
          }
#line 155
          if (value___0[i] == 0xffffffffffffffffUL) {
#line 156
            goto bad_format;
          }
#line 157
          f ++;
        }
#line 159
        tmp___3 = f;
#line 159
        f ++;
#line 159
        if ((int const   )*tmp___3 != (int const   )*("=?" + i)) {
#line 160
          goto bad_format;
        }
#line 141
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 162
      if (value___0[0] == value___0[1]) {
#line 163
        thenout = out;
#line 163
        elseout = (FILE *)0;
      } else {
#line 165
        thenout = (FILE *)0;
#line 165
        elseout = out;
      }
      {
#line 166
      f = format_group(thenout, f, (char )':', groups);
      }
#line 167
      if (*f) {
        {
#line 169
        f = format_group(elseout, f + 1, (char )')', groups);
        }
#line 170
        if (*f) {
#line 171
          f ++;
        }
      }
#line 174
      goto while_continue;
      case_60: /* CIL Label */ 
      {
#line 178
      print_ifdef_lines(out, line_format[1], groups + 0);
      }
#line 179
      goto while_continue;
      case_61: /* CIL Label */ 
      {
#line 183
      print_ifdef_lines(out, line_format[0], groups + 0);
      }
#line 184
      goto while_continue;
      case_62: /* CIL Label */ 
      {
#line 188
      print_ifdef_lines(out, line_format[2], groups + 1);
      }
#line 189
      goto while_continue;
      switch_default: /* CIL Label */ 
      {
#line 192
      f = do_printf_spec(out, f - 2, (struct file_data  const  *)0, (lin )0, groups);
      }
#line 193
      if (f) {
#line 194
        goto while_continue;
      }
      bad_format: 
#line 197
      c = (char )'%';
#line 198
      f = f1;
#line 199
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 202
    if (out) {
      {
#line 203
      putc_unlocked((int )c, out);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return (f);
}
}
#line 211 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static lin groups_letter_value(struct group  const  *g , char letter ) 
{ 
  lin tmp ;
  lin tmp___0 ;
  lin tmp___1 ;
  lin tmp___2 ;

  {
  {
#line 216
  if ((int )letter == 69) {
#line 216
    goto case_69;
  }
#line 217
  if ((int )letter == 70) {
#line 217
    goto case_70;
  }
#line 218
  if ((int )letter == 76) {
#line 218
    goto case_76;
  }
#line 219
  if ((int )letter == 77) {
#line 219
    goto case_77;
  }
#line 220
  if ((int )letter == 78) {
#line 220
    goto case_78;
  }
#line 214
  goto switch_break;
  case_69: /* CIL Label */ 
#line 216
  letter = (char )'e';
#line 216
  g ++;
#line 216
  goto switch_break;
  case_70: /* CIL Label */ 
#line 217
  letter = (char )'f';
#line 217
  g ++;
#line 217
  goto switch_break;
  case_76: /* CIL Label */ 
#line 218
  letter = (char )'l';
#line 218
  g ++;
#line 218
  goto switch_break;
  case_77: /* CIL Label */ 
#line 219
  letter = (char )'m';
#line 219
  g ++;
#line 219
  goto switch_break;
  case_78: /* CIL Label */ 
#line 220
  letter = (char )'n';
#line 220
  g ++;
#line 220
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 225
  if ((int )letter == 101) {
#line 225
    goto case_101;
  }
#line 226
  if ((int )letter == 102) {
#line 226
    goto case_102;
  }
#line 227
  if ((int )letter == 108) {
#line 227
    goto case_108;
  }
#line 228
  if ((int )letter == 109) {
#line 228
    goto case_109;
  }
#line 229
  if ((int )letter == 110) {
#line 229
    goto case_110;
  }
#line 230
  goto switch_default;
  case_101: /* CIL Label */ 
  {
#line 225
  tmp = translate_line_number((struct file_data  const  *)g->file, (lin )g->from);
  }
#line 225
  return (tmp - 1L);
  case_102: /* CIL Label */ 
  {
#line 226
  tmp___0 = translate_line_number((struct file_data  const  *)g->file, (lin )g->from);
  }
#line 226
  return (tmp___0);
  case_108: /* CIL Label */ 
  {
#line 227
  tmp___1 = translate_line_number((struct file_data  const  *)g->file, (lin )g->upto);
  }
#line 227
  return (tmp___1 - 1L);
  case_109: /* CIL Label */ 
  {
#line 228
  tmp___2 = translate_line_number((struct file_data  const  *)g->file, (lin )g->upto);
  }
#line 228
  return (tmp___2);
  case_110: /* CIL Label */ 
#line 229
  return ((lin )(g->upto - g->from));
  switch_default: /* CIL Label */ 
#line 230
  return ((lin )-1);
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 236 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static void print_ifdef_lines(FILE *out , char const   *format , struct group  const  *group ) 
{ 
  struct file_data  const  *file ;
  char const   * const  *linbuf ;
  lin from ;
  lin upto ;
  register char c ;
  register char const   *f ;
  char const   *f1 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 240
  file = (struct file_data  const  *)group->file;
#line 241
  linbuf = (char const   * const  *)file->linbuf;
#line 242
  from = (lin )group->from;
#line 242
  upto = (lin )group->upto;
#line 244
  if (! out) {
#line 245
    return;
  }
#line 248
  if (! expand_tabs) {
#line 248
    if ((int const   )*(format + 0) == 37) {
#line 250
      if ((int const   )*(format + 1) == 108) {
#line 250
        if ((int const   )*(format + 2) == 10) {
#line 250
          if (! *(format + 3)) {
#line 250
            if (from < upto) {
              {
#line 252
              fwrite_unlocked((void const   */* __restrict  */)*(linbuf + from), sizeof(char ),
                              (size_t )((*(linbuf + upto) + ((int const   )*(*(linbuf + upto) + -1) != 10)) - *(linbuf + from)),
                              (FILE */* __restrict  */)out);
              }
#line 255
              return;
            }
          }
        }
      }
#line 257
      if ((int const   )*(format + 1) == 76) {
#line 257
        if (! *(format + 2)) {
          {
#line 259
          fwrite_unlocked((void const   */* __restrict  */)*(linbuf + from), sizeof(char ),
                          (size_t )(*(linbuf + upto) - *(linbuf + from)), (FILE */* __restrict  */)out);
          }
#line 261
          return;
        }
      }
    }
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (from < upto)) {
#line 265
      goto while_break;
    }
#line 268
    f = format;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      tmp___0 = f;
#line 270
      f ++;
#line 270
      c = (char )*tmp___0;
#line 270
      if (! ((int )c != 0)) {
#line 270
        goto while_break___0;
      }
#line 272
      f1 = f;
#line 273
      if ((int )c == 37) {
#line 274
        tmp = f;
#line 274
        f ++;
#line 274
        c = (char )*tmp;
        {
#line 276
        if ((int )c == 37) {
#line 276
          goto case_37;
        }
#line 279
        if ((int )c == 108) {
#line 279
          goto case_108;
        }
#line 286
        if ((int )c == 76) {
#line 286
          goto case_76;
        }
#line 290
        goto switch_default;
        case_37: /* CIL Label */ 
#line 277
        goto switch_break;
        case_108: /* CIL Label */ 
        {
#line 280
        output_1_line((char const   *)*(linbuf + from), (char const   *)(*(linbuf + (from + 1L)) - ((int const   )*(*(linbuf + (from + 1L)) + -1) == 10)),
                      (char const   *)0, (char const   *)0);
        }
#line 284
        goto while_continue___0;
        case_76: /* CIL Label */ 
        {
#line 287
        output_1_line((char const   *)*(linbuf + from), (char const   *)*(linbuf + (from + 1L)),
                      (char const   *)0, (char const   *)0);
        }
#line 288
        goto while_continue___0;
        switch_default: /* CIL Label */ 
        {
#line 291
        f = do_printf_spec(out, f - 2, file, from, (struct group  const  *)0);
        }
#line 292
        if (f) {
#line 293
          goto while_continue___0;
        }
#line 294
        c = (char )'%';
#line 295
        f = f1;
#line 296
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
      {
#line 299
      putc_unlocked((int )c, out);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 265
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return;
}
}
#line 304 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static char const   *do_printf_spec(FILE *out , char const   *spec , struct file_data  const  *file ,
                                    lin n , struct group  const  *groups ) 
{ 
  char const   *f ;
  char c ;
  char c1 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char value___0 ;
  lin value___1 ;
  long long_value ;
  size_t spec_prefix_len ;
  char *format ;
  unsigned long __lengthofformat ;
  void *tmp___3 ;
  char *p ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 309
  f = spec;
#line 315
  f ++;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    tmp = f;
#line 316
    f ++;
#line 316
    c = (char )*tmp;
#line 316
    if (! ((int )c == 45)) {
#line 316
      if (! ((int )c == 39)) {
#line 316
        if (! ((int )c == 48)) {
#line 316
          goto while_break;
        }
      }
    }
#line 317
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! ((unsigned int )c - 48U <= 9U)) {
#line 318
      goto while_break___0;
    }
#line 319
    tmp___0 = f;
#line 319
    f ++;
#line 319
    c = (char )*tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 320
  if ((int )c == 46) {
    {
#line 321
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 321
      tmp___1 = f;
#line 321
      f ++;
#line 321
      c = (char )*tmp___1;
#line 321
      if (! ((unsigned int )c - 48U <= 9U)) {
#line 321
        goto while_break___1;
      }
#line 322
      goto while_continue___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 323
  tmp___2 = f;
#line 323
  f ++;
#line 323
  c1 = (char )*tmp___2;
  {
#line 327
  if ((int )c == 99) {
#line 327
    goto case_99;
  }
#line 341
  if ((int )c == 88) {
#line 341
    goto case_88;
  }
#line 341
  if ((int )c == 120) {
#line 341
    goto case_88;
  }
#line 341
  if ((int )c == 111) {
#line 341
    goto case_88;
  }
#line 341
  if ((int )c == 100) {
#line 341
    goto case_88;
  }
#line 382
  goto switch_default;
  case_99: /* CIL Label */ 
#line 328
  if ((int )c1 != 39) {
#line 329
    return ((char const   *)0);
  } else {
    {
#line 333
    f = scan_char_literal(f, & value___0);
    }
#line 334
    if (! f) {
#line 335
      return ((char const   *)0);
    }
#line 336
    if (out) {
      {
#line 337
      putc_unlocked((int )value___0, out);
      }
    }
  }
#line 339
  goto switch_break;
  case_88: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 345
  if (file) {
#line 347
    if ((int )c1 != 110) {
#line 348
      return ((char const   *)0);
    }
    {
#line 349
    value___1 = translate_line_number(file, n);
    }
  } else {
    {
#line 353
    value___1 = groups_letter_value(groups, c1);
    }
#line 354
    if (value___1 < 0L) {
#line 355
      return ((char const   *)0);
    }
  }
#line 358
  if (out) {
    {
#line 362
    long_value = value___1;
#line 363
    spec_prefix_len = (size_t )((f - spec) - 2L);
#line 365
    __lengthofformat = spec_prefix_len + 3UL;
#line 365
    tmp___3 = __builtin_alloca(sizeof(*format) * __lengthofformat);
#line 365
    format = (char *)tmp___3;
#line 369
    p = format + spec_prefix_len;
#line 370
    memcpy((void */* __restrict  */)format, (void const   */* __restrict  */)spec,
           spec_prefix_len);
#line 371
    tmp___4 = p;
#line 371
    p ++;
#line 371
    *tmp___4 = (char )'l';
#line 372
    tmp___5 = p;
#line 372
    p ++;
#line 372
    *tmp___5 = c;
#line 373
    *p = (char )'\000';
#line 374
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)format,
            long_value);
    }
  }
#line 380
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 383
  return ((char const   *)0);
  switch_break: /* CIL Label */ ;
  }
#line 386
  return (f);
}
}
#line 393 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ifdef.c"
static char const   *scan_char_literal(char const   *lit , char *valptr ) 
{ 
  register char const   *p ;
  char value___0 ;
  ptrdiff_t digits ;
  char c ;
  char const   *tmp ;
  unsigned int digit ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 396
  p = lit;
#line 399
  tmp = p;
#line 399
  p ++;
#line 399
  c = (char )*tmp;
  {
#line 404
  if ((int )c == 39) {
#line 404
    goto case_39;
  }
#line 404
  if ((int )c == 0) {
#line 404
    goto case_39;
  }
#line 407
  if ((int )c == 92) {
#line 407
    goto case_92;
  }
#line 421
  goto switch_default;
  case_39: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 405
  return ((char const   *)((void *)0));
  case_92: /* CIL Label */ 
#line 408
  value___0 = (char)0;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    tmp___0 = p;
#line 409
    p ++;
#line 409
    c = (char )*tmp___0;
#line 409
    if (! ((int )c != 39)) {
#line 409
      goto while_break;
    }
#line 411
    digit = (unsigned int )((int )c - 48);
#line 412
    if (8U <= digit) {
#line 413
      return ((char const   *)((void *)0));
    }
#line 414
    value___0 = (char )((unsigned int )(8 * (int )value___0) + digit);
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  digits = (p - lit) - 2L;
#line 417
  if (1L <= digits) {
#line 417
    if (! (digits <= 3L)) {
#line 418
      return ((char const   *)((void *)0));
    }
  } else {
#line 418
    return ((char const   *)((void *)0));
  }
#line 419
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 422
  value___0 = c;
#line 423
  tmp___1 = p;
#line 423
  p ++;
#line 423
  if ((int const   )*tmp___1 != 39) {
#line 424
    return ((char const   *)((void *)0));
  }
#line 425
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 428
  *valptr = value___0;
#line 429
  return (p);
}
}
#line 341 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
void print_ed_script(struct change *script ) ;
#line 342
void pr_forward_ed_script(struct change *script ) ;
#line 355
void print_rcs_script(struct change *script ) ;
#line 23 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ed.c"
static void print_ed_hunk(struct change *hunk ) ;
#line 24
static void print_rcs_hunk(struct change *hunk ) ;
#line 25
static void pr_forward_ed_hunk(struct change *hunk ) ;
#line 29 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ed.c"
void print_ed_script(struct change *script ) 
{ 


  {
  {
#line 32
  print_script(script, & find_reverse_change, & print_ed_hunk);
  }
#line 33
  return;
}
}
#line 37 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ed.c"
static void print_ed_hunk(struct change *hunk ) 
{ 
  lin f0 ;
  lin l0 ;
  lin f1 ;
  lin l1 ;
  enum changes changes ;
  lin i ;
  _Bool insert_mode ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 48
  changes = analyze_hunk(hunk, & f0, & l0, & f1, & l1);
  }
#line 49
  if (! changes) {
#line 50
    return;
  }
  {
#line 52
  begin_output();
#line 55
  print_number_range((char )',', & files[0], f0, l0);
#line 56
  fputc_unlocked((int )change_letter[changes], outfile);
#line 57
  fputc_unlocked('\n', outfile);
  }
#line 60
  if ((unsigned int )changes != 1U) {
#line 63
    insert_mode = (_Bool)1;
#line 65
    i = f1;
    {
#line 65
    while (1) {
      while_continue: /* CIL Label */ ;
#line 65
      if (! (i <= l1)) {
#line 65
        goto while_break;
      }
#line 67
      if (! insert_mode) {
        {
#line 69
        fputs_unlocked((char const   */* __restrict  */)"a\n", (FILE */* __restrict  */)outfile);
#line 70
        insert_mode = (_Bool)1;
        }
      }
#line 72
      if ((int const   )*(*(files[1].linbuf + i) + 0) == 46) {
#line 72
        if ((int const   )*(*(files[1].linbuf + i) + 1) == 10) {
          {
#line 77
          fputs_unlocked((char const   */* __restrict  */)"..\n.\ns/.//\n", (FILE */* __restrict  */)outfile);
#line 78
          insert_mode = (_Bool)0;
          }
        } else {
          {
#line 81
          print_1_line("", (char const   * const  *)(files[1].linbuf + i));
          }
        }
      } else {
        {
#line 81
        print_1_line("", (char const   * const  *)(files[1].linbuf + i));
        }
      }
#line 65
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 84
    if (insert_mode) {
      {
#line 85
      fputs_unlocked((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)outfile);
      }
    }
  }
#line 87
  return;
}
}
#line 95 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ed.c"
void pr_forward_ed_script(struct change *script ) 
{ 


  {
  {
#line 98
  print_script(script, & find_change, & pr_forward_ed_hunk);
  }
#line 99
  return;
}
}
#line 101 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ed.c"
static void pr_forward_ed_hunk(struct change *hunk ) 
{ 
  lin i ;
  lin f0 ;
  lin l0 ;
  lin f1 ;
  lin l1 ;
  enum changes changes ;
  enum changes tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 107
  tmp = analyze_hunk(hunk, & f0, & l0, & f1, & l1);
#line 107
  changes = tmp;
  }
#line 108
  if (! changes) {
#line 109
    return;
  }
  {
#line 111
  begin_output();
#line 113
  fputc_unlocked((int )change_letter[changes], outfile);
#line 114
  print_number_range((char )' ', files, f0, l0);
#line 115
  fputc_unlocked('\n', outfile);
  }
#line 119
  if ((unsigned int )changes == 1U) {
#line 120
    return;
  }
#line 125
  i = f1;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i <= l1)) {
#line 125
      goto while_break;
    }
    {
#line 126
    print_1_line("", (char const   * const  *)(files[1].linbuf + i));
#line 125
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  fputs_unlocked((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)outfile);
  }
#line 129
  return;
}
}
#line 135 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ed.c"
void print_rcs_script(struct change *script ) 
{ 


  {
  {
#line 138
  print_script(script, & find_change, & print_rcs_hunk);
  }
#line 139
  return;
}
}
#line 143 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/ed.c"
static void print_rcs_hunk(struct change *hunk ) 
{ 
  lin i ;
  lin f0 ;
  lin l0 ;
  lin f1 ;
  lin l1 ;
  long tf0 ;
  long tl0 ;
  long tf1 ;
  long tl1 ;
  enum changes changes ;
  enum changes tmp ;
  long tmp___0 ;
  long tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 150
  tmp = analyze_hunk(hunk, & f0, & l0, & f1, & l1);
#line 150
  changes = tmp;
  }
#line 151
  if (! changes) {
#line 152
    return;
  }
  {
#line 154
  begin_output();
#line 156
  translate_range((struct file_data  const  *)(& files[0]), f0, l0, & tf0, & tl0);
  }
#line 158
  if ((unsigned int )changes & 1U) {
#line 162
    if (tf0 <= tl0) {
#line 162
      tmp___0 = (tl0 - tf0) + 1L;
    } else {
#line 162
      tmp___0 = 1L;
    }
    {
#line 162
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"d%ld %ld\n",
            tf0, tmp___0);
    }
  }
#line 165
  if ((unsigned int )changes & 2U) {
    {
#line 168
    translate_range((struct file_data  const  *)(& files[1]), f1, l1, & tf1, & tl1);
    }
#line 169
    if (tf1 <= tl1) {
#line 169
      tmp___1 = (tl1 - tf1) + 1L;
    } else {
#line 169
      tmp___1 = 1L;
    }
    {
#line 169
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"a%ld %ld\n",
            tl0, tmp___1);
#line 172
    i = f1;
    }
    {
#line 172
    while (1) {
      while_continue: /* CIL Label */ ;
#line 172
      if (! (i <= l1)) {
#line 172
        goto while_break;
      }
      {
#line 173
      print_1_line("", (char const   * const  *)(files[1].linbuf + i));
#line 172
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 175
  return;
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 756 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 149 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcoll)(char const   *__s1 ,
                                                                                      char const   *__s2 )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 136 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool ignore_file_name_case ;
#line 171
char const   *starting_file ;
#line 205
struct exclude *excluded ;
#line 335
int diff_dirs(struct comparison  const  *cmp , int (*handle_file)(struct comparison  const  * ,
                                                                  char const   * ,
                                                                  char const   * ) ) ;
#line 338
char *find_dir_file_pathname(char const   *dir , char const   *file ) ;
#line 65 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 82
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 42 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/dir.c"
static _Bool locale_specific_sorting  ;
#line 45 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/dir.c"
static jmp_buf failed_locale_specific_sorting  ;
#line 47
static _Bool dir_loop(struct comparison  const  *cmp , int i ) ;
#line 48
static int compare_names_for_qsort(void const   *file1 , void const   *file2 ) ;
#line 53 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/dir.c"
static _Bool dir_read(struct file_data  const  *dir , struct dirdata *dirdata ) 
{ 
  register struct dirent *next ;
  register size_t i ;
  char const   **names ;
  size_t nnames ;
  char *data ;
  size_t data_alloc ;
  size_t data_used ;
  register DIR *reading ;
  DIR *tmp ;
  void *tmp___0 ;
  char *d_name ;
  size_t d_size ;
  size_t tmp___1 ;
  _Bool tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int e ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;

  {
#line 69
  dirdata->names = (char const   **)0;
#line 70
  dirdata->data = (char *)0;
#line 71
  nnames = (size_t )0;
#line 72
  data = (char *)0;
#line 74
  if (dir->desc != -1) {
    {
#line 77
    tmp = opendir((char const   *)dir->name);
#line 77
    reading = tmp;
    }
#line 78
    if (! reading) {
#line 79
      return ((_Bool)0);
    }
    {
#line 83
    data_alloc = (size_t )512;
#line 84
    data_used = (size_t )0;
#line 85
    tmp___0 = xmalloc(data_alloc);
#line 85
    data = (char *)tmp___0;
#line 85
    dirdata->data = data;
    }
    {
#line 90
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 90
      tmp___4 = __errno_location();
#line 90
      *tmp___4 = 0;
#line 90
      next = readdir(reading);
      }
#line 90
      if (! ((unsigned long )next != (unsigned long )((struct dirent *)0))) {
#line 90
        goto while_break;
      }
      {
#line 92
      d_name = next->d_name;
#line 93
      tmp___1 = strlen((char const   *)(next->d_name));
#line 93
      d_size = tmp___1 + 1UL;
      }
#line 96
      if ((int )*(d_name + 0) == 46) {
#line 96
        if ((int )*(d_name + 1) == 0) {
#line 98
          goto while_continue;
        } else
#line 96
        if ((int )*(d_name + 1) == 46) {
#line 96
          if ((int )*(d_name + 2) == 0) {
#line 98
            goto while_continue;
          }
        }
      }
      {
#line 100
      tmp___2 = excluded_file_name((struct exclude  const  *)excluded, (char const   *)d_name);
      }
#line 100
      if (tmp___2) {
#line 101
        goto while_continue;
      }
      {
#line 103
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 103
        if (! (data_alloc < data_used + d_size)) {
#line 103
          goto while_break___0;
        }
#line 105
        if (4611686018427387903UL <= data_alloc) {
          {
#line 106
          xalloc_die();
          }
        }
        {
#line 107
        data_alloc *= 2UL;
#line 107
        tmp___3 = xrealloc((void *)data, data_alloc);
#line 107
        data = (char *)tmp___3;
#line 107
        dirdata->data = data;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 110
      memcpy((void */* __restrict  */)(data + data_used), (void const   */* __restrict  */)d_name,
             d_size);
#line 111
      data_used += d_size;
#line 112
      nnames ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 114
    tmp___7 = __errno_location();
    }
#line 114
    if (*tmp___7) {
      {
#line 116
      tmp___5 = __errno_location();
#line 116
      e = *tmp___5;
#line 117
      closedir(reading);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = e;
      }
#line 119
      return ((_Bool)0);
    }
    {
#line 124
    tmp___8 = closedir(reading);
    }
#line 124
    if (tmp___8 != 0) {
#line 125
      return ((_Bool)0);
    }
  }
#line 130
  if (9223372036854775807UL / sizeof(*names) - 1UL <= nnames) {
    {
#line 131
    xalloc_die();
    }
  }
  {
#line 132
  tmp___9 = xmalloc((nnames + 1UL) * sizeof(*names));
#line 132
  names = (char const   **)tmp___9;
#line 132
  dirdata->names = names;
#line 133
  dirdata->nnames = nnames;
#line 134
  i = (size_t )0;
  }
  {
#line 134
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 134
    if (! (i < nnames)) {
#line 134
      goto while_break___1;
    }
    {
#line 136
    *(names + i) = (char const   *)data;
#line 137
    tmp___10 = strlen((char const   *)data);
#line 137
    data += tmp___10 + 1UL;
#line 134
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 139
  *(names + nnames) = (char const   *)0;
#line 140
  return ((_Bool)1);
}
}
#line 145 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/dir.c"
static int compare_names(char const   *name1 , char const   *name2 ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;

  {
#line 148
  if (locale_specific_sorting) {
    {
#line 151
    tmp = __errno_location();
#line 151
    *tmp = 0;
    }
#line 152
    if (ignore_file_name_case) {
      {
#line 153
      r = strcasecmp(name1, name2);
      }
    } else {
      {
#line 155
      r = strcoll(name1, name2);
      }
    }
    {
#line 156
    tmp___2 = __errno_location();
    }
#line 156
    if (*tmp___2) {
      {
#line 158
      tmp___0 = gettext("cannot compare file names `%s\' and `%s\'");
#line 158
      tmp___1 = __errno_location();
#line 158
      error(0, *tmp___1, (char const   *)tmp___0, name1, name2);
#line 160
      longjmp((struct __jmp_buf_tag *)(failed_locale_specific_sorting), 1);
      }
    }
#line 162
    return (r);
  }
  {
#line 165
  tmp___3 = strcmp(name1, name2);
  }
#line 165
  return (tmp___3);
}
}
#line 171 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/dir.c"
static int compare_names_for_qsort(void const   *file1 , void const   *file2 ) 
{ 
  char const   * const  *f1 ;
  char const   * const  *f2 ;
  int diff ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 174
  f1 = (char const   * const  *)file1;
#line 175
  f2 = (char const   * const  *)file2;
#line 176
  tmp = compare_names((char const   *)*f1, (char const   *)*f2);
#line 176
  diff = tmp;
  }
#line 177
  if (diff) {
#line 177
    tmp___1 = diff;
  } else {
    {
#line 177
    tmp___0 = strcmp((char const   *)*f1, (char const   *)*f2);
#line 177
    tmp___1 = tmp___0;
    }
  }
#line 177
  return (tmp___1);
}
}
#line 197 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/dir.c"
int diff_dirs(struct comparison  const  *cmp , int (*handle_file)(struct comparison  const  * ,
                                                                  char const   * ,
                                                                  char const   * ) ) 
{ 
  struct dirdata dirdata[2] ;
  int volatile   val ;
  int i ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  char const   ** volatile  names[2] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int nameorder ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int raw_order ;
  int tmp___9 ;
  int greater_side ;
  int lesser_side ;
  char const   **lesser ;
  char const   *greater_name ;
  char const   **p ;
  int c ;
  int tmp___10 ;
  int tmp___11 ;
  int v1 ;
  char const   ** volatile  tmp___12 ;
  char const   *tmp___13 ;
  char const   ** volatile  tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp34 ;
  int __cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 203
  val = (int volatile   )0;
#line 206
  if (cmp->file[0].desc == -1) {
#line 206
    goto _L;
  } else {
    {
#line 206
    tmp___0 = dir_loop(cmp, 0);
    }
#line 206
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 206
      if (cmp->file[1].desc == -1) {
        {
#line 209
        tmp = gettext("%s: recursive directory loop");
#line 209
        error(0, 0, (char const   *)tmp, cmp->file[cmp->file[0].desc == -1].name);
        }
#line 211
        return (2);
      } else {
        {
#line 206
        tmp___1 = dir_loop(cmp, 1);
        }
#line 206
        if (tmp___1) {
          {
#line 209
          tmp = gettext("%s: recursive directory loop");
#line 209
          error(0, 0, (char const   *)tmp, cmp->file[cmp->file[0].desc == -1].name);
          }
#line 211
          return (2);
        }
      }
    }
  }
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < 2)) {
#line 215
      goto while_break;
    }
    {
#line 216
    tmp___2 = dir_read((struct file_data  const  *)(& cmp->file[i]), & dirdata[i]);
    }
#line 216
    if (! tmp___2) {
      {
#line 218
      perror_with_name((char const   *)cmp->file[i].name);
#line 219
      val = (int volatile   )2;
      }
    }
#line 215
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (val == (int volatile   )0) {
    {
#line 225
    names[0] = (char const   **/* volatile  */)dirdata[0].names;
#line 226
    names[1] = (char const   **/* volatile  */)dirdata[1].names;
#line 229
    locale_specific_sorting = (_Bool)1;
#line 230
    tmp___3 = _setjmp((struct __jmp_buf_tag *)(failed_locale_specific_sorting));
    }
#line 230
    if (tmp___3) {
#line 231
      locale_specific_sorting = (_Bool)0;
    }
#line 234
    i = 0;
    {
#line 234
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 234
      if (! (i < 2)) {
#line 234
        goto while_break___0;
      }
      {
#line 235
      qsort((void *)names[i], dirdata[i].nnames, sizeof(*(dirdata[i].names)), & compare_names_for_qsort);
#line 234
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 241
    if (starting_file) {
#line 241
      if (! cmp->parent) {
        {
#line 243
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 243
          if (*(names[0])) {
            {
#line 243
            tmp___4 = compare_names(*(names[0]), starting_file);
            }
#line 243
            if (! (tmp___4 < 0)) {
#line 243
              goto while_break___1;
            }
          } else {
#line 243
            goto while_break___1;
          }
#line 244
          (names[0]) ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 245
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 245
          if (*(names[1])) {
            {
#line 245
            tmp___5 = compare_names(*(names[1]), starting_file);
            }
#line 245
            if (! (tmp___5 < 0)) {
#line 245
              goto while_break___2;
            }
          } else {
#line 245
            goto while_break___2;
          }
#line 246
          (names[1]) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    {
#line 250
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 250
      if (! *(names[0])) {
#line 250
        if (! *(names[1])) {
#line 250
          goto while_break___3;
        }
      }
#line 255
      if (! *(names[0])) {
#line 255
        tmp___8 = 1;
      } else {
#line 255
        if (! *(names[1])) {
#line 255
          tmp___7 = -1;
        } else {
          {
#line 255
          tmp___6 = compare_names(*(names[0]), *(names[1]));
#line 255
          tmp___7 = tmp___6;
          }
        }
#line 255
        tmp___8 = tmp___7;
      }
#line 255
      nameorder = tmp___8;
#line 262
      if (nameorder == 0) {
        {
#line 264
        tmp___9 = strcmp(*(names[0]), *(names[1]));
#line 264
        raw_order = tmp___9;
        }
#line 265
        if (raw_order != 0) {
#line 267
          greater_side = raw_order < 0;
#line 268
          lesser_side = 1 - greater_side;
#line 269
          lesser = (char const   **)names[lesser_side];
#line 270
          greater_name = *(names[greater_side]);
#line 273
          p = lesser + 1;
          {
#line 273
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 273
            if (*p) {
              {
#line 273
              tmp___11 = compare_names(*p, greater_name);
              }
#line 273
              if (! (tmp___11 == 0)) {
#line 273
                goto while_break___4;
              }
            } else {
#line 273
              goto while_break___4;
            }
            {
#line 277
            tmp___10 = strcmp(*p, greater_name);
#line 277
            c = tmp___10;
            }
#line 278
            if (0 <= c) {
#line 280
              if (c == 0) {
                {
#line 282
                memmove((void *)(lesser + 1), (void const   *)lesser, (size_t )((char *)p - (char *)lesser));
#line 284
                *lesser = greater_name;
                }
              }
#line 286
              goto while_break___4;
            }
#line 273
            p ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      }
#line 292
      if (nameorder < 0) {
#line 292
        tmp___13 = (char const   *)0;
      } else {
#line 292
        tmp___12 = names[1];
#line 292
        (names[1]) ++;
#line 292
        tmp___13 = *tmp___12;
      }
#line 292
      if (0 < nameorder) {
#line 292
        tmp___15 = (char const   *)0;
      } else {
#line 292
        tmp___14 = names[0];
#line 292
        (names[0]) ++;
#line 292
        tmp___15 = *tmp___14;
      }
      {
#line 292
      tmp___16 = (*handle_file)(cmp, tmp___15, tmp___13);
#line 292
      v1 = tmp___16;
      }
#line 295
      if (val < (int volatile   )v1) {
#line 296
        val = (int volatile   )v1;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 300
    if (! (i < 2)) {
#line 300
      goto while_break___5;
    }
    {
#line 302
    free((void *)dirdata[i].names);
#line 303
    free((void *)dirdata[i].data);
#line 300
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 306
  return ((int )val);
}
}
#line 311 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/dir.c"
static _Bool dir_loop(struct comparison  const  *cmp , int i ) 
{ 
  struct comparison  const  *p ;
  int tmp ;

  {
#line 314
  p = cmp;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    p = (struct comparison  const  *)p->parent;
#line 315
    if (! p) {
#line 315
      goto while_break;
    }
#line 316
    if (p->file[i].stat.st_ino == cmp->file[i].stat.st_ino) {
#line 316
      if (p->file[i].stat.st_dev == cmp->file[i].stat.st_dev) {
#line 316
        tmp = 1;
      } else {
#line 316
        tmp = 0;
      }
    } else {
#line 316
      tmp = 0;
    }
#line 316
    if (0 < tmp) {
#line 317
      return ((_Bool)1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return ((_Bool)0);
}
}
#line 323 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/dir.c"
char *find_dir_file_pathname(char const   *dir , char const   *file ) 
{ 
  char *val ;
  char const   *match ;
  struct dirdata dirdata ;
  struct file_data filedata ;
  char const   **p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;

  {
#line 327
  match = file;
#line 329
  dirdata.names = (char const   **)((void *)0);
#line 330
  dirdata.data = (char *)((void *)0);
#line 332
  if (ignore_file_name_case) {
    {
#line 335
    filedata.name = dir;
#line 336
    filedata.desc = 0;
#line 338
    tmp___2 = dir_read((struct file_data  const  *)(& filedata), & dirdata);
    }
#line 338
    if (tmp___2) {
      {
#line 340
      locale_specific_sorting = (_Bool)1;
#line 341
      tmp___1 = _setjmp((struct __jmp_buf_tag *)(failed_locale_specific_sorting));
      }
#line 341
      if (tmp___1) {
#line 342
        match = file;
      } else {
#line 345
        p = dirdata.names;
        {
#line 345
        while (1) {
          while_continue: /* CIL Label */ ;
#line 345
          if (! *p) {
#line 345
            goto while_break;
          }
          {
#line 346
          tmp___0 = compare_names(*p, file);
          }
#line 346
          if (tmp___0 == 0) {
            {
#line 348
            tmp = strcmp(*p, file);
            }
#line 348
            if (tmp == 0) {
#line 350
              match = *p;
#line 351
              goto while_break;
            }
#line 353
            if ((unsigned long )match == (unsigned long )file) {
#line 354
              match = *p;
            }
          }
#line 345
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 360
  val = file_name_concat(dir, match, (char **)((void *)0));
#line 361
  free((void *)dirdata.names);
#line 362
  free((void *)dirdata.data);
  }
#line 363
  return (val);
}
}
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 553 "../lib/regex.h"
extern reg_syntax_t re_set_syntax(reg_syntax_t __syntax ) ;
#line 558
extern char const   *re_compile_pattern(char const   *__pattern , size_t __length ,
                                        struct re_pattern_buffer *__buffer ) ;
#line 84 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
enum output_style output_style  ;
#line 87 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool no_diff_means_no_output  ;
#line 91 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
lin context  ;
#line 95 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool text  ;
#line 98 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
lin horizon_lines  ;
#line 123 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
enum DIFF_white_space ignore_white_space  ;
#line 126 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool ignore_blank_lines  ;
#line 130 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool files_can_be_treated_as_binary  ;
#line 133 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool ignore_case  ;
#line 136 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool ignore_file_name_case  ;
#line 139 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
char *file_label[2]  ;
#line 142 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
struct re_pattern_buffer function_regexp  ;
#line 145 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
struct re_pattern_buffer ignore_regexp  ;
#line 148 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool brief  ;
#line 152 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool expand_tabs  ;
#line 155 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
size_t tabsize  ;
#line 160 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool initial_tab  ;
#line 163 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool suppress_blank_empty  ;
#line 166 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool strip_trailing_cr  ;
#line 171 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
char const   *starting_file  ;
#line 174 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool paginate  ;
#line 177 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
char const   *group_format[4]  ;
#line 180 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
char const   *line_format[3]  ;
#line 183 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool sdiff_merge_assist  ;
#line 186 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool left_column  ;
#line 189 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool suppress_common_lines  ;
#line 192 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
size_t sdiff_half_width  ;
#line 193 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
size_t sdiff_column2_offset  ;
#line 198 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
char *switch_string  ;
#line 202 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool speed_large_files  ;
#line 205 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
struct exclude *excluded  ;
#line 209 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
_Bool minimal  ;
#line 212 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
char const   *time_format  ;
#line 319 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
struct file_data files[2]  ;
#line 323 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
FILE *outfile  ;
#line 328
int diff_2_files(struct comparison *cmp ) ;
#line 67 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static int compare_files(struct comparison  const  *parent , char const   *name0 ,
                         char const   *name1 ) ;
#line 68
static void add_regexp(struct regexp_list *reglist , char const   *pattern ) ;
#line 69
static void summarize_regexp_list(struct regexp_list *reglist ) ;
#line 70
static void specify_style(enum output_style style ) ;
#line 71
static void specify_value(char const   **var , char const   *value___0 , char const   *rpl_option ) ;
#line 72
static  __attribute__((__noreturn__)) void try_help(char const   *reason_msgid , char const   *operand ) ;
#line 73
static void check_stdout(void) ;
#line 74
static void usage(void) ;
#line 78 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static _Bool recursive  ;
#line 81 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static struct regexp_list function_regexp_list  ;
#line 84 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static struct regexp_list ignore_regexp_list  ;
#line 97 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static _Bool new_file  ;
#line 103 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static _Bool unidirectional_new_file  ;
#line 107 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static _Bool report_identical_files  ;
#line 109 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static char const   shortopts[57]  = 
#line 109
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'B',      (char const   )'c',      (char const   )'C',      (char const   )':', 
        (char const   )'d',      (char const   )'D',      (char const   )':',      (char const   )'e', 
        (char const   )'E',      (char const   )'f',      (char const   )'F',      (char const   )':', 
        (char const   )'h',      (char const   )'H',      (char const   )'i',      (char const   )'I', 
        (char const   )':',      (char const   )'l',      (char const   )'L',      (char const   )':', 
        (char const   )'n',      (char const   )'N',      (char const   )'p',      (char const   )'P', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'S', 
        (char const   )':',      (char const   )'t',      (char const   )'T',      (char const   )'u', 
        (char const   )'U',      (char const   )':',      (char const   )'v',      (char const   )'w', 
        (char const   )'W',      (char const   )':',      (char const   )'x',      (char const   )':', 
        (char const   )'X',      (char const   )':',      (char const   )'y',      (char const   )'Z', 
        (char const   )'\000'};
#line 144 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static char const   group_format_option[4][sizeof("--unchanged-group-format")]  = { {        (char const   )'-',        (char const   )'-',        (char const   )'u',        (char const   )'n', 
            (char const   )'c',        (char const   )'h',        (char const   )'a',        (char const   )'n', 
            (char const   )'g',        (char const   )'e',        (char const   )'d',        (char const   )'-', 
            (char const   )'g',        (char const   )'r',        (char const   )'o',        (char const   )'u', 
            (char const   )'p',        (char const   )'-',        (char const   )'f',        (char const   )'o', 
            (char const   )'r',        (char const   )'m',        (char const   )'a',        (char const   )'t', 
            (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'-',        (char const   )'o',        (char const   )'l', 
            (char const   )'d',        (char const   )'-',        (char const   )'g',        (char const   )'r', 
            (char const   )'o',        (char const   )'u',        (char const   )'p',        (char const   )'-', 
            (char const   )'f',        (char const   )'o',        (char const   )'r',        (char const   )'m', 
            (char const   )'a',        (char const   )'t',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'-',        (char const   )'n',        (char const   )'e', 
            (char const   )'w',        (char const   )'-',        (char const   )'g',        (char const   )'r', 
            (char const   )'o',        (char const   )'u',        (char const   )'p',        (char const   )'-', 
            (char const   )'f',        (char const   )'o',        (char const   )'r',        (char const   )'m', 
            (char const   )'a',        (char const   )'t',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'-',        (char const   )'c',        (char const   )'h', 
            (char const   )'a',        (char const   )'n',        (char const   )'g',        (char const   )'e', 
            (char const   )'d',        (char const   )'-',        (char const   )'g',        (char const   )'r', 
            (char const   )'o',        (char const   )'u',        (char const   )'p',        (char const   )'-', 
            (char const   )'f',        (char const   )'o',        (char const   )'r',        (char const   )'m', 
            (char const   )'a',        (char const   )'t',        (char const   )'\000'}};
#line 152 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static char const   line_format_option[3][sizeof("--unchanged-line-format")]  = { {        (char const   )'-',        (char const   )'-',        (char const   )'u',        (char const   )'n', 
            (char const   )'c',        (char const   )'h',        (char const   )'a',        (char const   )'n', 
            (char const   )'g',        (char const   )'e',        (char const   )'d',        (char const   )'-', 
            (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'-',        (char const   )'f',        (char const   )'o',        (char const   )'r', 
            (char const   )'m',        (char const   )'a',        (char const   )'t',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'-',        (char const   )'o',        (char const   )'l', 
            (char const   )'d',        (char const   )'-',        (char const   )'l',        (char const   )'i', 
            (char const   )'n',        (char const   )'e',        (char const   )'-',        (char const   )'f', 
            (char const   )'o',        (char const   )'r',        (char const   )'m',        (char const   )'a', 
            (char const   )'t',        (char const   )'\000'}, 
   {        (char const   )'-',        (char const   )'-',        (char const   )'n',        (char const   )'e', 
            (char const   )'w',        (char const   )'-',        (char const   )'l',        (char const   )'i', 
            (char const   )'n',        (char const   )'e',        (char const   )'-',        (char const   )'f', 
            (char const   )'o',        (char const   )'r',        (char const   )'m',        (char const   )'a', 
            (char const   )'t',        (char const   )'\000'}};
#line 159 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static struct rpl_option  const  longopts[57]  = 
#line 159
  {      {"binary", 0, (int *)0, 128}, 
        {"brief", 0, (int *)0, 'q'}, 
        {"changed-group-format", 1, (int *)0, 150}, 
        {"context", 2, (int *)0, 'C'}, 
        {"ed", 0, (int *)0, 'e'}, 
        {"exclude", 1, (int *)0, 'x'}, 
        {"exclude-from", 1, (int *)0, 'X'}, 
        {"expand-tabs", 0, (int *)0, 't'}, 
        {"forward-ed", 0, (int *)0, 'f'}, 
        {"from-file", 1, (int *)0, 129}, 
        {"help", 0, (int *)0, 130}, 
        {"horizon-lines", 1, (int *)0, 131}, 
        {"ifdef", 1, (int *)0, 'D'}, 
        {"ignore-all-space", 0, (int *)0, 'w'}, 
        {"ignore-blank-lines", 0, (int *)0, 'B'}, 
        {"ignore-case", 0, (int *)0, 'i'}, 
        {"ignore-file-name-case", 0, (int *)0, 132}, 
        {"ignore-matching-lines", 1, (int *)0, 'I'}, 
        {"ignore-space-change", 0, (int *)0, 'b'}, 
        {"ignore-tab-expansion", 0, (int *)0, 'E'}, 
        {"ignore-trailing-space", 0, (int *)0, 'Z'}, 
        {"inhibit-hunk-merge", 0, (int *)0, 133}, 
        {"initial-tab", 0, (int *)0, 'T'}, 
        {"label", 1, (int *)0, 'L'}, 
        {"left-column", 0, (int *)0, 134}, 
        {"line-format", 1, (int *)0, 135}, 
        {"minimal", 0, (int *)0, 'd'}, 
        {"new-file", 0, (int *)0, 'N'}, 
        {"new-group-format", 1, (int *)0, 149}, 
        {"new-line-format", 1, (int *)0, 146}, 
        {"no-ignore-file-name-case", 0, (int *)0, 136}, 
        {"normal", 0, (int *)0, 137}, 
        {"old-group-format", 1, (int *)0, 148}, 
        {"old-line-format", 1, (int *)0, 145}, 
        {"paginate", 0, (int *)0, 'l'}, 
        {"rcs", 0, (int *)0, 'n'}, 
        {"recursive", 0, (int *)0, 'r'}, 
        {"report-identical-files", 0, (int *)0, 's'}, 
        {"sdiff-merge-assist", 0, (int *)0, 138}, 
        {"show-c-function", 0, (int *)0, 'p'}, 
        {"show-function-line", 1, (int *)0, 'F'}, 
        {"side-by-side", 0, (int *)0, 'y'}, 
        {"speed-large-files", 0, (int *)0, 'H'}, 
        {"starting-file", 1, (int *)0, 'S'}, 
        {"strip-trailing-cr", 0, (int *)0, 139}, 
        {"suppress-blank-empty", 0, (int *)0, 140}, 
        {"suppress-common-lines", 0, (int *)0, 141}, 
        {"tabsize", 1, (int *)0, 142}, 
        {"text", 0, (int *)0, 'a'}, 
        {"to-file", 1, (int *)0, 143}, 
        {"unchanged-group-format", 1, (int *)0, 147}, 
        {"unchanged-line-format", 1, (int *)0, 144}, 
        {"unidirectional-new-file", 0, (int *)0, 'P'}, 
        {"unified", 2, (int *)0, 'U'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"width", 1, (int *)0, 'W'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 228 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static char *option_list(char **optionvec , int count ) 
{ 
  int i ;
  size_t size ;
  char *result ;
  char *p ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 232
  size = (size_t )1;
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < count)) {
#line 236
      goto while_break;
    }
    {
#line 237
    tmp = shell_quote_length((char const   *)*(optionvec + i));
#line 237
    size += 1UL + tmp;
#line 236
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  tmp___0 = xmalloc(size);
#line 239
  result = (char *)tmp___0;
#line 239
  p = result;
#line 241
  i = 0;
  }
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 241
    if (! (i < count)) {
#line 241
      goto while_break___0;
    }
    {
#line 243
    tmp___1 = p;
#line 243
    p ++;
#line 243
    *tmp___1 = (char )' ';
#line 244
    p = shell_quote_copy(p, (char const   *)*(optionvec + i));
#line 241
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 247
  *p = (char )'\000';
#line 248
  return (result);
}
}
#line 254 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static int exclude_options(void) 
{ 
  int tmp ;

  {
#line 257
  if (ignore_file_name_case) {
#line 257
    tmp = 1 << 4;
  } else {
#line 257
    tmp = 0;
  }
#line 257
  return ((1 << 28) | tmp);
}
}
#line 367
int main(int argc , char **argv ) ;
#line 367 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static char const   C_ifdef_group_formats[119]  = 
#line 367
  {      (char const   )'%',      (char const   )'%',      (char const   )'=',      (char const   )'%', 
        (char const   )'c',      (char const   )'#',      (char const   )'i',      (char const   )'f', 
        (char const   )'n',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\n', 
        (char const   )'%',      (char const   )'%',      (char const   )'<',      (char const   )'#', 
        (char const   )'e',      (char const   )'n',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )' ',      (char const   )'/',      (char const   )'*', 
        (char const   )' ',      (char const   )'!',      (char const   )' ',      (char const   )'%', 
        (char const   )'s',      (char const   )' ',      (char const   )'*',      (char const   )'/', 
        (char const   )'\n',      (char const   )'%',      (char const   )'c',      (char const   )'#', 
        (char const   )'i',      (char const   )'f',      (char const   )'d',      (char const   )'e', 
        (char const   )'f',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )'\n',      (char const   )'%',      (char const   )'%',      (char const   )'>', 
        (char const   )'#',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )'i',      (char const   )'f',      (char const   )' ',      (char const   )'/', 
        (char const   )'*',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'*',      (char const   )'/',      (char const   )'\n', 
        (char const   )'%',      (char const   )'c',      (char const   )'#',      (char const   )'i', 
        (char const   )'f',      (char const   )'n',      (char const   )'d',      (char const   )'e', 
        (char const   )'f',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )'\n',      (char const   )'%',      (char const   )'%',      (char const   )'<', 
        (char const   )'#',      (char const   )'e',      (char const   )'l',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'/',      (char const   )'*', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )' ', 
        (char const   )'*',      (char const   )'/',      (char const   )'\n',      (char const   )'%', 
        (char const   )'%',      (char const   )'>',      (char const   )'#',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'i',      (char const   )'f', 
        (char const   )' ',      (char const   )'/',      (char const   )'*',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )' ',      (char const   )'*', 
        (char const   )'/',      (char const   )'\n',      (char const   )'\000'};
#line 260 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
int main(int argc , char **argv ) 
{ 
  int exit_status ;
  int c ;
  int i ;
  int prev ;
  lin ocontext ;
  _Bool explicit_context ;
  size_t width ;
  _Bool show_c_function ;
  char const   *from_file ;
  char const   *to_file ;
  uintmax_t numval ;
  char *numend ;
  int tmp ;
  char *b ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  uintmax_t tmp___12 ;
  uintmax_t tmp___13 ;
  _Bool tmp___14 ;
  intmax_t t ;
  size_t tmp___15 ;
  intmax_t w ;
  intmax_t off ;
  intmax_t tmp___17 ;
  intmax_t tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int status ;
  int tmp___23 ;
  int status___0 ;
  int tmp___24 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;

  {
  {
#line 263
  exit_status = 0;
#line 266
  prev = -1;
#line 267
  ocontext = (lin )-1;
#line 268
  explicit_context = (_Bool)0;
#line 269
  width = (size_t )0;
#line 270
  show_c_function = (_Bool)0;
#line 271
  from_file = (char const   *)((void *)0);
#line 272
  to_file = (char const   *)((void *)0);
#line 277
  exit_failure = (int volatile   )2;
#line 279
  set_program_name((char const   *)*(argv + 0));
#line 280
  setlocale(6, "");
#line 281
  bindtextdomain("diffutils", "/usr/local/share/locale");
#line 282
  textdomain("diffutils");
#line 283
  c_stack_action((void (*)(int  ))0);
#line 284
  function_regexp_list.buf = & function_regexp;
#line 285
  ignore_regexp_list.buf = & ignore_regexp;
#line 286
  re_set_syntax((((((1UL << 1) | ((1UL << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 287
  excluded = new_exclude();
  }
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 291
    c = rpl_getopt_long(argc, argv, shortopts, longopts, (int *)((void *)0));
    }
#line 291
    if (! (c != -1)) {
#line 291
      goto while_break;
    }
    {
#line 295
    if (c == 0) {
#line 295
      goto case_0;
    }
#line 307
    if (c == 57) {
#line 307
      goto case_57;
    }
#line 307
    if (c == 56) {
#line 307
      goto case_57;
    }
#line 307
    if (c == 55) {
#line 307
      goto case_57;
    }
#line 307
    if (c == 54) {
#line 307
      goto case_57;
    }
#line 307
    if (c == 53) {
#line 307
      goto case_57;
    }
#line 307
    if (c == 52) {
#line 307
      goto case_57;
    }
#line 307
    if (c == 51) {
#line 307
      goto case_57;
    }
#line 307
    if (c == 50) {
#line 307
      goto case_57;
    }
#line 307
    if (c == 49) {
#line 307
      goto case_57;
    }
#line 307
    if (c == 48) {
#line 307
      goto case_57;
    }
#line 315
    if (c == 97) {
#line 315
      goto case_97;
    }
#line 319
    if (c == 98) {
#line 319
      goto case_98;
    }
#line 324
    if (c == 90) {
#line 324
      goto case_90;
    }
#line 329
    if (c == 66) {
#line 329
      goto case_66;
    }
#line 334
    if (c == 85) {
#line 334
      goto case_85;
    }
#line 334
    if (c == 67) {
#line 334
      goto case_85;
    }
#line 354
    if (c == 99) {
#line 354
      goto case_99;
    }
#line 360
    if (c == 100) {
#line 360
      goto case_100;
    }
#line 364
    if (c == 68) {
#line 364
      goto case_68;
    }
#line 385
    if (c == 101) {
#line 385
      goto case_101;
    }
#line 389
    if (c == 69) {
#line 389
      goto case_69;
    }
#line 394
    if (c == 102) {
#line 394
      goto case_102;
    }
#line 398
    if (c == 70) {
#line 398
      goto case_70;
    }
#line 402
    if (c == 104) {
#line 402
      goto case_104;
    }
#line 409
    if (c == 72) {
#line 409
      goto case_72;
    }
#line 413
    if (c == 105) {
#line 413
      goto case_105;
    }
#line 417
    if (c == 73) {
#line 417
      goto case_73;
    }
#line 421
    if (c == 108) {
#line 421
      goto case_108;
    }
#line 432
    if (c == 76) {
#line 432
      goto case_76;
    }
#line 441
    if (c == 110) {
#line 441
      goto case_110;
    }
#line 445
    if (c == 78) {
#line 445
      goto case_78;
    }
#line 449
    if (c == 112) {
#line 449
      goto case_112;
    }
#line 454
    if (c == 80) {
#line 454
      goto case_80;
    }
#line 458
    if (c == 113) {
#line 458
      goto case_113;
    }
#line 462
    if (c == 114) {
#line 462
      goto case_114;
    }
#line 466
    if (c == 115) {
#line 466
      goto case_115;
    }
#line 470
    if (c == 83) {
#line 470
      goto case_83;
    }
#line 474
    if (c == 116) {
#line 474
      goto case_116;
    }
#line 478
    if (c == 84) {
#line 478
      goto case_84;
    }
#line 482
    if (c == 117) {
#line 482
      goto case_117;
    }
#line 488
    if (c == 118) {
#line 488
      goto case_118;
    }
#line 494
    if (c == 119) {
#line 494
      goto case_119;
    }
#line 498
    if (c == 120) {
#line 498
      goto case_120;
    }
#line 502
    if (c == 88) {
#line 502
      goto case_88;
    }
#line 508
    if (c == 121) {
#line 508
      goto case_121;
    }
#line 512
    if (c == 87) {
#line 512
      goto case_87;
    }
#line 524
    if (c == 128) {
#line 524
      goto case_128;
    }
#line 532
    if (c == 129) {
#line 532
      goto case_129;
    }
#line 536
    if (c == 130) {
#line 536
      goto case_130;
    }
#line 541
    if (c == 131) {
#line 541
      goto case_131;
    }
#line 548
    if (c == 132) {
#line 548
      goto case_132;
    }
#line 552
    if (c == 133) {
#line 552
      goto case_133;
    }
#line 557
    if (c == 134) {
#line 557
      goto case_134;
    }
#line 561
    if (c == 135) {
#line 561
      goto case_135;
    }
#line 567
    if (c == 136) {
#line 567
      goto case_136;
    }
#line 571
    if (c == 137) {
#line 571
      goto case_137;
    }
#line 575
    if (c == 138) {
#line 575
      goto case_138;
    }
#line 580
    if (c == 139) {
#line 580
      goto case_139;
    }
#line 584
    if (c == 140) {
#line 584
      goto case_140;
    }
#line 588
    if (c == 141) {
#line 588
      goto case_141;
    }
#line 592
    if (c == 142) {
#line 592
      goto case_142;
    }
#line 604
    if (c == 143) {
#line 604
      goto case_143;
    }
#line 610
    if (c == 146) {
#line 610
      goto case_146;
    }
#line 610
    if (c == 145) {
#line 610
      goto case_146;
    }
#line 610
    if (c == 144) {
#line 610
      goto case_146;
    }
#line 619
    if (c == 150) {
#line 619
      goto case_150;
    }
#line 619
    if (c == 149) {
#line 619
      goto case_150;
    }
#line 619
    if (c == 148) {
#line 619
      goto case_150;
    }
#line 619
    if (c == 147) {
#line 619
      goto case_150;
    }
#line 625
    goto switch_default;
    case_0: /* CIL Label */ 
#line 296
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 308
    if (! ((unsigned int )prev - 48U <= 9U)) {
#line 309
      ocontext = (lin )(c - 48);
    } else
#line 310
    if (922337203685477580L < ocontext) {
#line 312
      ocontext = 9223372036854775807L;
    } else {
#line 310
      ocontext = (10L * ocontext + (lin )c) - 48L;
#line 310
      if (ocontext < 0L) {
#line 312
        ocontext = 9223372036854775807L;
      }
    }
#line 313
    goto switch_break;
    case_97: /* CIL Label */ 
#line 316
    text = (_Bool)1;
#line 317
    goto switch_break;
    case_98: /* CIL Label */ 
#line 320
    if ((unsigned int )ignore_white_space < 4U) {
#line 321
      ignore_white_space = (enum DIFF_white_space )4;
    }
#line 322
    goto switch_break;
    case_90: /* CIL Label */ 
#line 325
    if ((unsigned int )ignore_white_space < 4U) {
#line 326
      ignore_white_space = (enum DIFF_white_space )((unsigned int )ignore_white_space | 2U);
    }
#line 327
    goto switch_break;
    case_66: /* CIL Label */ 
#line 330
    ignore_blank_lines = (_Bool)1;
#line 331
    goto switch_break;
    case_85: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 336
    if (rpl_optarg) {
      {
#line 338
      numval = strtoumax((char const   */* __restrict  */)rpl_optarg, (char **/* __restrict  */)(& numend),
                         10);
      }
#line 339
      if (*numend) {
        {
#line 340
        try_help("invalid context length `%s\'", (char const   *)rpl_optarg);
        }
      }
#line 341
      if (9223372036854775807UL < numval) {
#line 342
        numval = (uintmax_t )9223372036854775807L;
      }
    } else {
#line 345
      numval = (uintmax_t )3;
    }
#line 347
    if (c == 85) {
#line 347
      tmp = 3;
    } else {
#line 347
      tmp = 2;
    }
    {
#line 347
    specify_style((enum output_style )tmp);
    }
#line 348
    if ((uintmax_t )context < numval) {
#line 349
      context = (lin )numval;
    }
#line 350
    explicit_context = (_Bool)1;
#line 352
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 355
    specify_style((enum output_style )2);
    }
#line 356
    if (context < 3L) {
#line 357
      context = (lin )3;
    }
#line 358
    goto switch_break;
    case_100: /* CIL Label */ 
#line 361
    minimal = (_Bool)1;
#line 362
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 365
    specify_style((enum output_style )7);
#line 369
    tmp___0 = strlen((char const   *)rpl_optarg);
#line 369
    tmp___1 = xmalloc(((sizeof(C_ifdef_group_formats) + 7UL * tmp___0) - 14UL) - 8UL);
#line 369
    b = (char *)tmp___1;
#line 372
    sprintf((char */* __restrict  */)b, (char const   */* __restrict  */)(C_ifdef_group_formats),
            0, rpl_optarg, rpl_optarg, 0, rpl_optarg, rpl_optarg, 0, rpl_optarg, rpl_optarg,
            rpl_optarg);
#line 377
    i = 0;
    }
    {
#line 377
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 377
      if (! ((unsigned long )i < sizeof(group_format) / sizeof(group_format[0]))) {
#line 377
        goto while_break___0;
      }
      {
#line 379
      specify_value(& group_format[i], (char const   *)b, "-D");
#line 380
      tmp___2 = strlen((char const   *)b);
#line 380
      b += tmp___2 + 1UL;
#line 377
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 383
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 386
    specify_style((enum output_style )4);
    }
#line 387
    goto switch_break;
    case_69: /* CIL Label */ 
#line 390
    if ((unsigned int )ignore_white_space < 4U) {
#line 391
      ignore_white_space = (enum DIFF_white_space )((unsigned int )ignore_white_space | 1U);
    }
#line 392
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 395
    specify_style((enum output_style )5);
    }
#line 396
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 399
    add_regexp(& function_regexp_list, (char const   *)rpl_optarg);
    }
#line 400
    goto switch_break;
    case_104: /* CIL Label */ 
#line 407
    goto switch_break;
    case_72: /* CIL Label */ 
#line 410
    speed_large_files = (_Bool)1;
#line 411
    goto switch_break;
    case_105: /* CIL Label */ 
#line 414
    ignore_case = (_Bool)1;
#line 415
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 418
    add_regexp(& ignore_regexp_list, (char const   *)rpl_optarg);
    }
#line 419
    goto switch_break;
    case_108: /* CIL Label */ 
#line 422
    if (! pr_program[0]) {
      {
#line 423
      try_help("pagination not supported on this host", (char const   *)((void *)0));
      }
    }
    {
#line 424
    paginate = (_Bool)1;
#line 428
    signal(17, (void (*)(int  ))0);
    }
#line 430
    goto switch_break;
    case_76: /* CIL Label */ 
#line 433
    if (! file_label[0]) {
#line 434
      file_label[0] = rpl_optarg;
    } else
#line 435
    if (! file_label[1]) {
#line 436
      file_label[1] = rpl_optarg;
    } else {
      {
#line 438
      fatal("too many file label options");
      }
    }
#line 439
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 442
    specify_style((enum output_style )6);
    }
#line 443
    goto switch_break;
    case_78: /* CIL Label */ 
#line 446
    new_file = (_Bool)1;
#line 447
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 450
    show_c_function = (_Bool)1;
#line 451
    add_regexp(& function_regexp_list, "^[[:alpha:]$_]");
    }
#line 452
    goto switch_break;
    case_80: /* CIL Label */ 
#line 455
    unidirectional_new_file = (_Bool)1;
#line 456
    goto switch_break;
    case_113: /* CIL Label */ 
#line 459
    brief = (_Bool)1;
#line 460
    goto switch_break;
    case_114: /* CIL Label */ 
#line 463
    recursive = (_Bool)1;
#line 464
    goto switch_break;
    case_115: /* CIL Label */ 
#line 467
    report_identical_files = (_Bool)1;
#line 468
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 471
    specify_value(& starting_file, (char const   *)rpl_optarg, "-S");
    }
#line 472
    goto switch_break;
    case_116: /* CIL Label */ 
#line 475
    expand_tabs = (_Bool)1;
#line 476
    goto switch_break;
    case_84: /* CIL Label */ 
#line 479
    initial_tab = (_Bool)1;
#line 480
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 483
    specify_style((enum output_style )3);
    }
#line 484
    if (context < 3L) {
#line 485
      context = (lin )3;
    }
#line 486
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 489
    tmp___3 = proper_name("Len Tower");
#line 489
    tmp___4 = proper_name("Richard Stallman");
#line 489
    tmp___5 = proper_name("David Hayes");
#line 489
    tmp___6 = proper_name("Mike Haertel");
#line 489
    tmp___7 = proper_name("Paul Eggert");
#line 489
    version_etc(stdout, "diff", "GNU diffutils", Version, tmp___7, tmp___6, tmp___5,
                tmp___4, tmp___3, (char *)((void *)0));
#line 491
    check_stdout();
    }
#line 492
    return (0);
    case_119: /* CIL Label */ 
#line 495
    ignore_white_space = (enum DIFF_white_space )5;
#line 496
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 499
    tmp___8 = exclude_options();
#line 499
    add_exclude(excluded, (char const   *)rpl_optarg, tmp___8);
    }
#line 500
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 503
    tmp___9 = exclude_options();
#line 503
    tmp___10 = add_exclude_file(& add_exclude, excluded, (char const   *)rpl_optarg,
                                tmp___9, (char )'\n');
    }
#line 503
    if (tmp___10) {
      {
#line 505
      pfatal_with_name((char const   *)rpl_optarg);
      }
    }
#line 506
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 509
    specify_style((enum output_style )8);
    }
#line 510
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 513
    numval = strtoumax((char const   */* __restrict  */)rpl_optarg, (char **/* __restrict  */)(& numend),
                       10);
    }
#line 514
    if (0UL < numval) {
#line 514
      if (numval <= 0xffffffffffffffffUL) {
#line 514
        if (*numend) {
          {
#line 515
          try_help("invalid width `%s\'", (char const   *)rpl_optarg);
          }
        }
      } else {
        {
#line 515
        try_help("invalid width `%s\'", (char const   *)rpl_optarg);
        }
      }
    } else {
      {
#line 515
      try_help("invalid width `%s\'", (char const   *)rpl_optarg);
      }
    }
#line 516
    if (width != numval) {
#line 518
      if (width) {
        {
#line 519
        fatal("conflicting width options");
        }
      }
#line 520
      width = numval;
    }
#line 522
    goto switch_break;
    case_128: /* CIL Label */ 
#line 530
    goto switch_break;
    case_129: /* CIL Label */ 
    {
#line 533
    specify_value(& from_file, (char const   *)rpl_optarg, "--from-file");
    }
#line 534
    goto switch_break;
    case_130: /* CIL Label */ 
    {
#line 537
    usage();
#line 538
    check_stdout();
    }
#line 539
    return (0);
    case_131: /* CIL Label */ 
    {
#line 542
    numval = strtoumax((char const   */* __restrict  */)rpl_optarg, (char **/* __restrict  */)(& numend),
                       10);
    }
#line 543
    if (*numend) {
      {
#line 544
      try_help("invalid horizon length `%s\'", (char const   *)rpl_optarg);
      }
    }
#line 545
    if (numval <= 9223372036854775807UL) {
#line 545
      tmp___13 = numval;
    } else {
#line 545
      tmp___13 = (uintmax_t )9223372036854775807L;
    }
#line 545
    if ((uintmax_t )horizon_lines >= tmp___13) {
#line 545
      horizon_lines = horizon_lines;
    } else {
#line 545
      if (numval <= 9223372036854775807UL) {
#line 545
        tmp___12 = numval;
      } else {
#line 545
        tmp___12 = (uintmax_t )9223372036854775807L;
      }
#line 545
      horizon_lines = (lin )tmp___12;
    }
#line 546
    goto switch_break;
    case_132: /* CIL Label */ 
#line 549
    ignore_file_name_case = (_Bool)1;
#line 550
    goto switch_break;
    case_133: /* CIL Label */ 
#line 555
    goto switch_break;
    case_134: /* CIL Label */ 
#line 558
    left_column = (_Bool)1;
#line 559
    goto switch_break;
    case_135: /* CIL Label */ 
    {
#line 562
    specify_style((enum output_style )7);
#line 563
    i = 0;
    }
    {
#line 563
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 563
      if (! ((unsigned long )i < sizeof(line_format) / sizeof(line_format[0]))) {
#line 563
        goto while_break___1;
      }
      {
#line 564
      specify_value(& line_format[i], (char const   *)rpl_optarg, "--line-format");
#line 563
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 565
    goto switch_break;
    case_136: /* CIL Label */ 
#line 568
    ignore_file_name_case = (_Bool)0;
#line 569
    goto switch_break;
    case_137: /* CIL Label */ 
    {
#line 572
    specify_style((enum output_style )1);
    }
#line 573
    goto switch_break;
    case_138: /* CIL Label */ 
    {
#line 576
    specify_style((enum output_style )8);
#line 577
    sdiff_merge_assist = (_Bool)1;
    }
#line 578
    goto switch_break;
    case_139: /* CIL Label */ 
#line 581
    strip_trailing_cr = (_Bool)1;
#line 582
    goto switch_break;
    case_140: /* CIL Label */ 
#line 585
    suppress_blank_empty = (_Bool)1;
#line 586
    goto switch_break;
    case_141: /* CIL Label */ 
#line 589
    suppress_common_lines = (_Bool)1;
#line 590
    goto switch_break;
    case_142: /* CIL Label */ 
    {
#line 593
    numval = strtoumax((char const   */* __restrict  */)rpl_optarg, (char **/* __restrict  */)(& numend),
                       10);
    }
#line 594
    if (0UL < numval) {
#line 594
      if (numval <= 0xffffffffffffffffUL) {
#line 594
        if (*numend) {
          {
#line 595
          try_help("invalid tabsize `%s\'", (char const   *)rpl_optarg);
          }
        }
      } else {
        {
#line 595
        try_help("invalid tabsize `%s\'", (char const   *)rpl_optarg);
        }
      }
    } else {
      {
#line 595
      try_help("invalid tabsize `%s\'", (char const   *)rpl_optarg);
      }
    }
#line 596
    if (tabsize != numval) {
#line 598
      if (tabsize) {
        {
#line 599
        fatal("conflicting tabsize options");
        }
      }
#line 600
      tabsize = numval;
    }
#line 602
    goto switch_break;
    case_143: /* CIL Label */ 
    {
#line 605
    specify_value(& to_file, (char const   *)rpl_optarg, "--to-file");
    }
#line 606
    goto switch_break;
    case_146: /* CIL Label */ 
    case_145: /* CIL Label */ 
    case_144: /* CIL Label */ 
    {
#line 611
    specify_style((enum output_style )7);
#line 612
    c -= 144;
#line 613
    specify_value(& line_format[c], (char const   *)rpl_optarg, line_format_option[c]);
    }
#line 614
    goto switch_break;
    case_150: /* CIL Label */ 
    case_149: /* CIL Label */ 
    case_148: /* CIL Label */ 
    case_147: /* CIL Label */ 
    {
#line 620
    specify_style((enum output_style )7);
#line 621
    c -= 147;
#line 622
    specify_value(& group_format[c], (char const   *)rpl_optarg, group_format_option[c]);
    }
#line 623
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 626
    try_help((char const   *)((void *)0), (char const   *)((void *)0));
    }
    switch_break: /* CIL Label */ ;
    }
#line 628
    prev = c;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  if ((unsigned int )output_style == 0U) {
#line 633
    if (show_c_function) {
      {
#line 635
      specify_style((enum output_style )2);
      }
#line 636
      if (ocontext < 0L) {
#line 637
        context = (lin )3;
      }
    } else {
      {
#line 640
      specify_style((enum output_style )1);
      }
    }
  }
#line 643
  if ((unsigned int )output_style != 2U) {
#line 647
    time_format = "%Y-%m-%d %H:%M:%S.%N %z";
  } else {
    {
#line 643
    tmp___14 = hard_locale(2);
    }
#line 643
    if (tmp___14) {
#line 647
      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
    } else {
#line 655
      time_format = "%a %b %e %T %Y";
    }
  }
#line 658
  if (0L <= ocontext) {
#line 658
    if ((unsigned int )output_style == 2U) {
#line 658
      goto _L;
    } else
#line 658
    if ((unsigned int )output_style == 3U) {
      _L: /* CIL Label */ 
#line 658
      if (context < ocontext) {
#line 663
        context = ocontext;
      } else
#line 658
      if (ocontext < context) {
#line 658
        if (! explicit_context) {
#line 663
          context = ocontext;
        }
      }
    }
  }
#line 665
  if (! tabsize) {
#line 666
    tabsize = (size_t )8;
  }
#line 667
  if (! width) {
#line 668
    width = (size_t )130;
  }
#line 681
  if (expand_tabs) {
#line 681
    tmp___15 = (size_t )1;
  } else {
#line 681
    tmp___15 = tabsize;
  }
#line 681
  t = (intmax_t )tmp___15;
#line 682
  w = (intmax_t )width;
#line 683
  off = (((w + t) + 3L) / (2L * t)) * t;
#line 684
  if (off - 3L <= w - off) {
#line 684
    tmp___18 = off - 3L;
  } else {
#line 684
    tmp___18 = w - off;
  }
#line 684
  if (0L >= tmp___18) {
#line 684
    sdiff_half_width = (size_t )0;
  } else {
#line 684
    if (off - 3L <= w - off) {
#line 684
      tmp___17 = off - 3L;
    } else {
#line 684
      tmp___17 = w - off;
    }
#line 684
    sdiff_half_width = (size_t )tmp___17;
  }
#line 684
  if (sdiff_half_width) {
#line 684
    sdiff_column2_offset = (size_t )off;
  } else {
#line 684
    sdiff_column2_offset = (size_t )w;
  }
#line 690
  if (horizon_lines < context) {
#line 691
    horizon_lines = context;
  }
  {
#line 693
  summarize_regexp_list(& function_regexp_list);
#line 694
  summarize_regexp_list(& ignore_regexp_list);
  }
#line 696
  if ((unsigned int )output_style == 7U) {
#line 698
    i = 0;
    {
#line 698
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 698
      if (! ((unsigned long )i < sizeof(line_format) / sizeof(line_format[0]))) {
#line 698
        goto while_break___2;
      }
#line 699
      if (! line_format[i]) {
#line 700
        line_format[i] = "%l\n";
      }
#line 698
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 701
    if (! group_format[1]) {
#line 702
      if (group_format[3]) {
#line 702
        group_format[1] = group_format[3];
      } else {
#line 702
        group_format[1] = "%<";
      }
    }
#line 704
    if (! group_format[2]) {
#line 705
      if (group_format[3]) {
#line 705
        group_format[2] = group_format[3];
      } else {
#line 705
        group_format[2] = "%>";
      }
    }
#line 707
    if (! group_format[0]) {
#line 708
      group_format[0] = "%=";
    }
#line 709
    if (! group_format[3]) {
      {
#line 710
      tmp___19 = concat(group_format[1], group_format[2], "");
#line 710
      group_format[3] = (char const   *)tmp___19;
      }
    }
  }
#line 714
  if ((unsigned int )output_style == 7U) {
#line 714
    if (! *(group_format[0])) {
#line 714
      tmp___21 = 1;
    } else {
      {
#line 714
      tmp___20 = strcmp(group_format[0], "%=");
      }
#line 714
      if (tmp___20 == 0) {
#line 714
        if (! *(line_format[0])) {
#line 714
          tmp___21 = 1;
        } else {
#line 714
          tmp___21 = 0;
        }
      } else {
#line 714
        tmp___21 = 0;
      }
    }
#line 714
    no_diff_means_no_output = (_Bool )tmp___21;
  } else {
#line 714
    no_diff_means_no_output = (_Bool )(((unsigned int )output_style != 8U) | (int )suppress_common_lines);
  }
#line 721
  if (ignore_regexp_list.regexps) {
#line 721
    tmp___22 = 1;
  } else
#line 721
  if (ignore_white_space) {
#line 721
    tmp___22 = 1;
  } else {
#line 721
    tmp___22 = 0;
  }
  {
#line 721
  files_can_be_treated_as_binary = (_Bool )(((int )brief & 1) & ~ ((((int )ignore_blank_lines | (int )ignore_case) | (int )strip_trailing_cr) | tmp___22));
#line 726
  switch_string = option_list(argv + 1, rpl_optind - 1);
  }
#line 728
  if (from_file) {
#line 730
    if (to_file) {
      {
#line 731
      fatal("--from-file and --to-file both specified");
      }
    } else {
      {
#line 733
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 733
        if (! (rpl_optind < argc)) {
#line 733
          goto while_break___3;
        }
        {
#line 735
        tmp___23 = compare_files((struct comparison  const  *)((void *)0), from_file,
                                 (char const   *)*(argv + rpl_optind));
#line 735
        status = tmp___23;
        }
#line 736
        if (exit_status < status) {
#line 737
          exit_status = status;
        }
#line 733
        rpl_optind ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  } else
#line 742
  if (to_file) {
    {
#line 743
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 743
      if (! (rpl_optind < argc)) {
#line 743
        goto while_break___4;
      }
      {
#line 745
      tmp___24 = compare_files((struct comparison  const  *)((void *)0), (char const   *)*(argv + rpl_optind),
                               to_file);
#line 745
      status___0 = tmp___24;
      }
#line 746
      if (exit_status < status___0) {
#line 747
        exit_status = status___0;
      }
#line 743
      rpl_optind ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 751
    if (argc - rpl_optind != 2) {
#line 753
      if (argc - rpl_optind < 2) {
        {
#line 754
        try_help("missing operand after `%s\'", (char const   *)*(argv + (argc - 1)));
        }
      } else {
        {
#line 756
        try_help("extra operand `%s\'", (char const   *)*(argv + (rpl_optind + 2)));
        }
      }
    }
    {
#line 759
    exit_status = compare_files((struct comparison  const  *)((void *)0), (char const   *)*(argv + rpl_optind),
                                (char const   *)*(argv + (rpl_optind + 1)));
    }
  }
  {
#line 764
  print_message_queue();
#line 766
  check_stdout();
#line 767
  exit(exit_status);
  }
#line 768
  return (exit_status);
}
}
#line 773 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static void add_regexp(struct regexp_list *reglist , char const   *pattern ) 
{ 
  size_t patlen ;
  size_t tmp ;
  char const   *m ;
  char const   *tmp___0 ;
  char *regexps ;
  size_t len ;
  _Bool multiple_regexps ;
  _Bool tmp___1 ;
  size_t newlen ;
  size_t tmp___2 ;
  size_t size ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *__cil_tmp17 ;

  {
  {
#line 776
  tmp = strlen(pattern);
#line 776
  patlen = tmp;
#line 777
  tmp___0 = re_compile_pattern(pattern, patlen, reglist->buf);
#line 777
  m = tmp___0;
  }
#line 779
  if ((unsigned long )m != (unsigned long )((char const   *)0)) {
    {
#line 780
    error(0, 0, "%s: %s", pattern, m);
    }
  } else {
#line 783
    regexps = reglist->regexps;
#line 784
    len = reglist->len;
#line 785
    tmp___1 = (_Bool )((unsigned long )regexps != (unsigned long )((char *)0));
#line 785
    reglist->multiple_regexps = tmp___1;
#line 785
    multiple_regexps = tmp___1;
#line 786
    tmp___2 = (len + (size_t )(2 * (int )multiple_regexps)) + patlen;
#line 786
    reglist->len = tmp___2;
#line 786
    newlen = tmp___2;
#line 787
    size = reglist->size;
#line 789
    if (size <= newlen) {
#line 791
      if (! size) {
#line 792
        size = (size_t )1;
      }
      {
#line 794
      while (1) {
        while_continue: /* CIL Label */ ;
#line 794
        size *= 2UL;
#line 794
        if (! (size <= newlen)) {
#line 794
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 797
      reglist->size = size;
#line 798
      tmp___3 = xrealloc((void *)regexps, size);
#line 798
      regexps = (char *)tmp___3;
#line 798
      reglist->regexps = regexps;
      }
    }
#line 800
    if (multiple_regexps) {
#line 802
      tmp___4 = len;
#line 802
      len ++;
#line 802
      *(regexps + tmp___4) = (char )'\\';
#line 803
      tmp___5 = len;
#line 803
      len ++;
#line 803
      *(regexps + tmp___5) = (char )'|';
    }
    {
#line 805
    memcpy((void */* __restrict  */)(regexps + len), (void const   */* __restrict  */)pattern,
           patlen + 1UL);
    }
  }
#line 807
  return;
}
}
#line 812 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static void summarize_regexp_list(struct regexp_list *reglist ) 
{ 
  void *tmp ;
  char const   *m ;
  char const   *tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 815
  if (reglist->regexps) {
    {
#line 818
    tmp = xmalloc((size_t )(1 << 8));
#line 818
    (reglist->buf)->fastmap = (char *)tmp;
    }
#line 819
    if (reglist->multiple_regexps) {
      {
#line 823
      tmp___0 = re_compile_pattern((char const   *)reglist->regexps, reglist->len,
                                   reglist->buf);
#line 823
      m = tmp___0;
      }
#line 825
      if (m) {
        {
#line 826
        error(2, 0, "%s: %s", reglist->regexps, m);
        }
      }
    }
  }
#line 829
  return;
}
}
#line 831
static  __attribute__((__noreturn__)) void try_help(char const   *reason_msgid , char const   *operand ) ;
#line 831 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static void try_help(char const   *reason_msgid , char const   *operand ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 834
  if (reason_msgid) {
    {
#line 835
    tmp = gettext(reason_msgid);
#line 835
    error(0, 0, (char const   *)tmp, operand);
    }
  }
  {
#line 836
  tmp___0 = gettext("Try `%s --help\' for more information.");
#line 836
  error(2, 0, (char const   *)tmp___0, program_name);
#line 838
  abort();
  }
}
}
#line 841 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static void check_stdout(void) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 844
  tmp___1 = ferror_unlocked(stdout);
  }
#line 844
  if (tmp___1) {
    {
#line 845
    fatal("write failed");
    }
  } else {
    {
#line 846
    tmp___0 = fclose(stdout);
    }
#line 846
    if (tmp___0 != 0) {
      {
#line 847
      tmp = gettext("standard output");
#line 847
      pfatal_with_name((char const   *)tmp);
      }
    }
  }
#line 848
  return;
}
}
#line 850 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static char const   * const  option_help_msgid[66]  = 
#line 850
  {      (char const   */* const  */)"    --normal                  output a normal diff (the default)",      (char const   */* const  */)"-q, --brief                   report only when files differ",      (char const   */* const  */)"-s, --report-identical-files  report when two files are the same",      (char const   */* const  */)"-c, -C NUM, --context[=NUM]   output NUM (default 3) lines of copied context", 
        (char const   */* const  */)"-u, -U NUM, --unified[=NUM]   output NUM (default 3) lines of unified context",      (char const   */* const  */)"-e, --ed                      output an ed script",      (char const   */* const  */)"-n, --rcs                     output an RCS format diff",      (char const   */* const  */)"-y, --side-by-side            output in two columns", 
        (char const   */* const  */)"-W, --width=NUM               output at most NUM (default 130) print columns",      (char const   */* const  */)"    --left-column             output only the left column of common lines",      (char const   */* const  */)"    --suppress-common-lines   do not output common lines",      (char const   */* const  */)"", 
        (char const   */* const  */)"-p, --show-c-function         show which C function each change is in",      (char const   */* const  */)"-F, --show-function-line=RE   show the most recent line matching RE",      (char const   */* const  */)"    --label LABEL             use LABEL instead of file name\n                                (can be repeated)",      (char const   */* const  */)"", 
        (char const   */* const  */)"-t, --expand-tabs             expand tabs to spaces in output",      (char const   */* const  */)"-T, --initial-tab             make tabs line up by prepending a tab",      (char const   */* const  */)"    --tabsize=NUM             tab stops every NUM (default 8) print columns",      (char const   */* const  */)"    --suppress-blank-empty    suppress space or tab before empty output lines", 
        (char const   */* const  */)"-l, --paginate                pass output through `pr\' to paginate it",      (char const   */* const  */)"",      (char const   */* const  */)"-r, --recursive                 recursively compare any subdirectories found",      (char const   */* const  */)"-N, --new-file                  treat absent files as empty", 
        (char const   */* const  */)"    --unidirectional-new-file   treat absent first files as empty",      (char const   */* const  */)"    --ignore-file-name-case     ignore case when comparing file names",      (char const   */* const  */)"    --no-ignore-file-name-case  consider case when comparing file names",      (char const   */* const  */)"-x, --exclude=PAT               exclude files that match PAT", 
        (char const   */* const  */)"-X, --exclude-from=FILE         exclude files that match any pattern in FILE",      (char const   */* const  */)"-S, --starting-file=FILE        start with FILE when comparing directories",      (char const   */* const  */)"    --from-file=FILE1           compare FILE1 to all operands;\n                                  FILE1 can be a directory",      (char const   */* const  */)"    --to-file=FILE2             compare all operands to FILE2;\n                                  FILE2 can be a directory", 
        (char const   */* const  */)"",      (char const   */* const  */)"-i, --ignore-case               ignore case differences in file contents",      (char const   */* const  */)"-E, --ignore-tab-expansion      ignore changes due to tab expansion",      (char const   */* const  */)"-Z, --ignore-trailing-space     ignore white space at line end", 
        (char const   */* const  */)"-b, --ignore-space-change       ignore changes in the amount of white space",      (char const   */* const  */)"-w, --ignore-all-space          ignore all white space",      (char const   */* const  */)"-B, --ignore-blank-lines        ignore changes whose lines are all blank",      (char const   */* const  */)"-I, --ignore-matching-lines=RE  ignore changes whose lines all match RE", 
        (char const   */* const  */)"",      (char const   */* const  */)"-a, --text                      treat all files as text",      (char const   */* const  */)"    --strip-trailing-cr         strip trailing carriage return on input",      (char const   */* const  */)"", 
        (char const   */* const  */)"-D, --ifdef=NAME                output merged file with `#ifdef NAME\' diffs",      (char const   */* const  */)"    --GTYPE-group-format=GFMT   format GTYPE input groups with GFMT",      (char const   */* const  */)"    --line-format=LFMT          format all input lines with LFMT",      (char const   */* const  */)"    --LTYPE-line-format=LFMT    format LTYPE input lines with LFMT", 
        (char const   */* const  */)"  These format options provide fine-grained control over the output\n    of diff, generalizing -D/--ifdef.",      (char const   */* const  */)"  LTYPE is `old\', `new\', or `unchanged\'.  GTYPE is LTYPE or `changed\'.",      (char const   */* const  */)"  GFMT (only) may contain:\n    %<  lines from FILE1\n    %>  lines from FILE2\n    %=  lines common to FILE1 and FILE2\n    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n      LETTERs are as follows for new group, lower case for old group:\n        F  first line number\n        L  last line number\n        N  number of lines = L-F+1\n        E  F-1\n        M  L+1\n    %(A=B?T:E)  if A equals B then T else E",      (char const   */* const  */)"  LFMT (only) may contain:\n    %L  contents of line\n    %l  contents of line, excluding any trailing newline\n    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number", 
        (char const   */* const  */)"  Both GFMT and LFMT may contain:\n    %%  %\n    %c\'C\'  the single character C\n    %c\'\\OOO\'  the character with octal code OOO\n    C    the character C (other characters represent themselves)",      (char const   */* const  */)"",      (char const   */* const  */)"-d, --minimal            try hard to find a smaller set of changes",      (char const   */* const  */)"    --horizon-lines=NUM  keep NUM lines of the common prefix and suffix", 
        (char const   */* const  */)"    --speed-large-files  assume large files and many scattered small changes",      (char const   */* const  */)"",      (char const   */* const  */)"    --help               display this help and exit",      (char const   */* const  */)"-v, --version            output version information and exit", 
        (char const   */* const  */)"",      (char const   */* const  */)"FILES are `FILE1 FILE2\' or `DIR1 DIR2\' or `DIR FILE...\' or `FILE... DIR\'.",      (char const   */* const  */)"If --from-file or --to-file is given, there are no restrictions on FILE(s).",      (char const   */* const  */)"If a FILE is `-\', read standard input.", 
        (char const   */* const  */)"Exit status is 0 if inputs are the same, 1 if different, 2 if trouble.",      (char const   */* const  */)0};
#line 944 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static void usage(void) 
{ 
  char const   * const  *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *msg ;
  char *tmp___2 ;
  char const   *nl ;
  int msglen ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 949
  tmp = gettext("Usage: %s [OPTION]... FILES\n");
#line 949
  printf((char const   */* __restrict  */)tmp, program_name);
#line 950
  tmp___0 = gettext("Compare FILES line by line.");
#line 950
  printf((char const   */* __restrict  */)"%s\n\n", tmp___0);
#line 952
  tmp___1 = gettext("Mandatory arguments to long options are mandatory for short options too.\n");
#line 952
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
#line 956
  p = option_help_msgid;
  }
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 956
    if (! *p) {
#line 956
      goto while_break;
    }
#line 958
    if (! *(*p)) {
      {
#line 959
      putchar_unlocked('\n');
      }
    } else {
      {
#line 962
      tmp___2 = gettext((char const   *)*p);
#line 962
      msg = (char const   *)tmp___2;
      }
      {
#line 964
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 964
        tmp___3 = strchr(msg, '\n');
#line 964
        nl = (char const   *)tmp___3;
        }
#line 964
        if (! nl) {
#line 964
          goto while_break___0;
        }
        {
#line 966
        msglen = (int )((nl + 1) - msg);
#line 967
        printf((char const   */* __restrict  */)"  %.*s", msglen, msg);
#line 968
        msg = nl + 1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 971
      if ((int const   )*msg != 32) {
#line 971
        if ((int const   )*msg != 45) {
#line 971
          tmp___4 = 1;
        } else {
#line 971
          tmp___4 = 0;
        }
      } else {
#line 971
        tmp___4 = 0;
      }
      {
#line 971
      printf((char const   */* __restrict  */)("  %s\n" + 2 * tmp___4), msg);
      }
    }
#line 956
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 974
  emit_bug_reporting_address();
  }
#line 975
  return;
}
}
#line 979 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static void specify_value(char const   **var , char const   *value___0 , char const   *rpl_option ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 982
  if (*var) {
    {
#line 982
    tmp___0 = strcmp(*var, value___0);
    }
#line 982
    if (! (tmp___0 == 0)) {
      {
#line 984
      tmp = gettext("conflicting %s option value `%s\'");
#line 984
      error(0, 0, (char const   *)tmp, rpl_option, value___0);
#line 985
      try_help((char const   *)((void *)0), (char const   *)((void *)0));
      }
    }
  }
#line 987
  *var = value___0;
#line 988
  return;
}
}
#line 991 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static void specify_style(enum output_style style ) 
{ 
  char *__cil_tmp2 ;

  {
#line 994
  if ((unsigned int )output_style != (unsigned int )style) {
#line 996
    if ((unsigned int )output_style != 0U) {
      {
#line 997
      try_help("conflicting output style options", (char const   *)((void *)0));
      }
    }
#line 998
    output_style = style;
  }
#line 1000
  return;
}
}
#line 1004 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static void set_mtime_to_now(struct stat *st ) 
{ 


  {
  {
#line 1008
  gettime(& st->st_mtim);
  }
#line 1019
  return;
}
}
#line 1029 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c"
static int compare_files(struct comparison  const  *parent , char const   *name0 ,
                         char const   *name1 ) 
{ 
  struct comparison cmp ;
  register int f ;
  int status ;
  _Bool same_files ;
  char *free0 ;
  char *free1 ;
  char const   *name ;
  char const   *tmp ;
  char const   *dir ;
  int *tmp___1 ;
  off_t pos ;
  __off_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int e ;
  int *tmp___12 ;
  int fnm_arg ;
  int dir_arg ;
  char const   *fnm ;
  char const   *dir___0 ;
  char const   *filename ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *dir___1 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  int oflags ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  int __cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;

  {
#line 1037
  status = 0;
#line 1046
  if (name0) {
#line 1046
    if (! name1) {
#line 1046
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1046
  if (unidirectional_new_file) {
#line 1046
    if (! name1) {
#line 1046
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1046
  if (! new_file) {
#line 1050
    if (name0) {
#line 1050
      tmp = name0;
    } else {
#line 1050
      tmp = name1;
    }
    {
#line 1050
    name = tmp;
#line 1051
    dir = (char const   *)parent->file[! name0].name;
#line 1054
    message("Only in %s: %s\n", dir, name);
    }
#line 1058
    return (1);
  }
  {
#line 1061
  memset((void *)(cmp.file), 0, sizeof(cmp.file));
#line 1062
  cmp.parent = parent;
  }
#line 1071
  if (name0) {
#line 1071
    cmp.file[0].desc = -2;
  } else {
#line 1071
    cmp.file[0].desc = -1;
  }
#line 1072
  if (name1) {
#line 1072
    cmp.file[1].desc = -2;
  } else {
#line 1072
    cmp.file[1].desc = -1;
  }
#line 1076
  if (! name0) {
#line 1077
    name0 = name1;
  }
#line 1078
  if (! name1) {
#line 1079
    name1 = name0;
  }
#line 1081
  if (! parent) {
#line 1083
    free0 = (char *)((void *)0);
#line 1084
    free1 = (char *)((void *)0);
#line 1085
    cmp.file[0].name = name0;
#line 1086
    cmp.file[1].name = name1;
  } else {
    {
#line 1090
    free0 = file_name_concat((char const   *)parent->file[0].name, name0, (char **)((void *)0));
#line 1090
    cmp.file[0].name = (char const   *)free0;
#line 1092
    free1 = file_name_concat((char const   *)parent->file[1].name, name1, (char **)((void *)0));
#line 1092
    cmp.file[1].name = (char const   *)free1;
    }
  }
#line 1098
  f = 0;
  {
#line 1098
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1098
    if (! (f < 2)) {
#line 1098
      goto while_break;
    }
#line 1100
    if (cmp.file[f].desc != -1) {
#line 1102
      if (f) {
        {
#line 1102
        tmp___8 = strcmp(cmp.file[f].name, cmp.file[0].name);
        }
#line 1102
        if (tmp___8 == 0) {
#line 1104
          cmp.file[f].desc = cmp.file[0].desc;
#line 1105
          cmp.file[f].stat = cmp.file[0].stat;
        } else {
#line 1102
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 1107
        tmp___7 = strcmp(cmp.file[f].name, "-");
        }
#line 1107
        if (tmp___7 == 0) {
          {
#line 1109
          cmp.file[f].desc = 0;
#line 1112
          tmp___4 = fstat(0, & cmp.file[f].stat);
          }
#line 1112
          if (tmp___4 != 0) {
            {
#line 1113
            tmp___1 = __errno_location();
#line 1113
            cmp.file[f].desc = -3 - *tmp___1;
            }
          } else {
#line 1116
            if ((cmp.file[f].stat.st_mode & 61440U) == 32768U) {
              {
#line 1118
              tmp___2 = lseek(0, (__off_t )0, 1);
#line 1118
              pos = tmp___2;
              }
#line 1119
              if (pos < 0L) {
                {
#line 1120
                tmp___3 = __errno_location();
#line 1120
                cmp.file[f].desc = -3 - *tmp___3;
                }
              } else
#line 1122
              if (0L >= cmp.file[f].stat.st_size - pos) {
#line 1122
                cmp.file[f].stat.st_size = (__off_t )0;
              } else {
#line 1122
                cmp.file[f].stat.st_size -= pos;
              }
            }
            {
#line 1128
            set_mtime_to_now(& cmp.file[f].stat);
            }
          }
        } else {
          {
#line 1131
          tmp___6 = stat((char const   */* __restrict  */)cmp.file[f].name, (struct stat */* __restrict  */)(& cmp.file[f].stat));
          }
#line 1131
          if (tmp___6 != 0) {
            {
#line 1132
            tmp___5 = __errno_location();
#line 1132
            cmp.file[f].desc = -3 - *tmp___5;
            }
          }
        }
      }
    }
#line 1098
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1141
  f = 0;
  {
#line 1141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1141
    if (! (f < 2)) {
#line 1141
      goto while_break___0;
    }
#line 1142
    if (new_file) {
#line 1142
      goto _L___2;
    } else
#line 1142
    if (f == 0) {
#line 1142
      if (unidirectional_new_file) {
        _L___2: /* CIL Label */ 
#line 1142
        if (cmp.file[f].desc == -2) {
#line 1142
          if ((cmp.file[f].stat.st_mode & 61440U) == 32768U) {
#line 1142
            if (! (cmp.file[f].stat.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3)))) {
#line 1142
              if (cmp.file[f].stat.st_size == 0L) {
#line 1142
                tmp___9 = 1;
              } else {
#line 1142
                tmp___9 = 0;
              }
            } else {
#line 1142
              tmp___9 = 0;
            }
          } else {
#line 1142
            tmp___9 = 0;
          }
#line 1142
          tmp___11 = tmp___9;
        } else {
#line 1142
          if (cmp.file[f].desc == -5) {
#line 1142
            if (! parent) {
#line 1142
              if (cmp.file[1 - f].desc == -2) {
#line 1142
                tmp___10 = 1;
              } else {
#line 1142
                tmp___10 = 0;
              }
            } else {
#line 1142
              tmp___10 = 0;
            }
          } else {
#line 1142
            tmp___10 = 0;
          }
#line 1142
          tmp___11 = tmp___10;
        }
#line 1142
        if (tmp___11) {
#line 1150
          cmp.file[f].desc = -1;
        }
      }
    }
#line 1141
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1152
  f = 0;
  {
#line 1152
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1152
    if (! (f < 2)) {
#line 1152
      goto while_break___1;
    }
#line 1153
    if (cmp.file[f].desc == -1) {
      {
#line 1155
      memset((void *)(& cmp.file[f].stat), 0, sizeof(cmp.file[f].stat));
#line 1156
      cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
      }
    }
#line 1152
    f ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1159
  f = 0;
  {
#line 1159
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1159
    if (! (f < 2)) {
#line 1159
      goto while_break___2;
    }
#line 1161
    e = -3 - cmp.file[f].desc;
#line 1162
    if (0 <= e) {
      {
#line 1164
      tmp___12 = __errno_location();
#line 1164
      *tmp___12 = e;
#line 1165
      perror_with_name(cmp.file[f].name);
#line 1166
      status = 2;
      }
    }
#line 1159
    f ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1170
  if (status == 0) {
#line 1170
    if (! parent) {
#line 1170
      if ((((cmp.file[0].stat.st_mode & 61440U) == 16384U) != 0) != (((cmp.file[1].stat.st_mode & 61440U) == 16384U) != 0)) {
        {
#line 1175
        fnm_arg = ((cmp.file[0].stat.st_mode & 61440U) == 16384U) != 0;
#line 1176
        dir_arg = 1 - fnm_arg;
#line 1177
        fnm = cmp.file[fnm_arg].name;
#line 1178
        dir___0 = cmp.file[dir_arg].name;
#line 1179
        tmp___14 = last_component(fnm);
#line 1179
        free0 = find_dir_file_pathname(dir___0, (char const   *)tmp___14);
#line 1179
        tmp___13 = (char const   *)free0;
#line 1179
        cmp.file[dir_arg].name = tmp___13;
#line 1179
        filename = tmp___13;
#line 1182
        tmp___15 = strcmp(fnm, "-");
        }
#line 1182
        if (tmp___15 == 0) {
          {
#line 1183
          fatal("cannot compare `-\' to a directory");
          }
        }
        {
#line 1185
        tmp___16 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& cmp.file[dir_arg].stat));
        }
#line 1185
        if (tmp___16 != 0) {
          {
#line 1187
          perror_with_name(filename);
#line 1188
          status = 2;
          }
        }
      }
    }
  }
#line 1192
  if (! (status != 0)) {
#line 1196
    if (cmp.file[0].desc == -1) {
#line 1196
      if (! (cmp.file[1].desc == -1)) {
#line 1196
        goto _L___13;
      }
    } else {
      _L___13: /* CIL Label */ 
#line 1201
      if (cmp.file[0].desc != -1) {
#line 1201
        if (cmp.file[1].desc != -1) {
#line 1201
          if (cmp.file[0].stat.st_ino == cmp.file[1].stat.st_ino) {
#line 1201
            if (cmp.file[0].stat.st_dev == cmp.file[1].stat.st_dev) {
#line 1201
              tmp___25 = 1;
            } else {
#line 1201
              tmp___25 = 0;
            }
          } else {
#line 1201
            tmp___25 = 0;
          }
#line 1201
          if (0 < tmp___25) {
#line 1201
            if (cmp.file[0].stat.st_mode == cmp.file[1].stat.st_mode) {
#line 1201
              if (cmp.file[0].stat.st_nlink == cmp.file[1].stat.st_nlink) {
#line 1201
                if (cmp.file[0].stat.st_uid == cmp.file[1].stat.st_uid) {
#line 1201
                  if (cmp.file[0].stat.st_gid == cmp.file[1].stat.st_gid) {
#line 1201
                    if (cmp.file[0].stat.st_size == cmp.file[1].stat.st_size) {
#line 1201
                      if (cmp.file[0].stat.st_mtim.tv_sec == cmp.file[1].stat.st_mtim.tv_sec) {
#line 1201
                        if (cmp.file[0].stat.st_ctim.tv_sec == cmp.file[1].stat.st_ctim.tv_sec) {
#line 1201
                          tmp___26 = 1;
                        } else {
#line 1201
                          tmp___26 = 0;
                        }
                      } else {
#line 1201
                        tmp___26 = 0;
                      }
                    } else {
#line 1201
                      tmp___26 = 0;
                    }
                  } else {
#line 1201
                    tmp___26 = 0;
                  }
                } else {
#line 1201
                  tmp___26 = 0;
                }
              } else {
#line 1201
                tmp___26 = 0;
              }
            } else {
#line 1201
              tmp___26 = 0;
            }
          } else {
#line 1201
            tmp___26 = 0;
          }
        } else {
#line 1201
          tmp___26 = 0;
        }
      } else {
#line 1201
        tmp___26 = 0;
      }
#line 1201
      same_files = (_Bool )tmp___26;
#line 1201
      if (same_files) {
#line 1201
        if (! no_diff_means_no_output) {
#line 1201
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
#line 1212
      if ((((cmp.file[0].stat.st_mode & 61440U) == 16384U) != 0) & (((cmp.file[1].stat.st_mode & 61440U) == 16384U) != 0)) {
#line 1214
        if ((unsigned int )output_style == 7U) {
          {
#line 1215
          fatal("-D option not supported with directories");
          }
        }
#line 1219
        if (parent) {
#line 1219
          if (! recursive) {
            {
#line 1224
            message("Common subdirectories: %s and %s\n", cmp.file[0].name, cmp.file[1].name);
            }
          } else {
            {
#line 1228
            status = diff_dirs((struct comparison  const  *)(& cmp), & compare_files);
            }
          }
        } else {
          {
#line 1228
          status = diff_dirs((struct comparison  const  *)(& cmp), & compare_files);
          }
        }
      } else
#line 1230
      if ((((cmp.file[0].stat.st_mode & 61440U) == 16384U) != 0) | (((cmp.file[1].stat.st_mode & 61440U) == 16384U) != 0)) {
#line 1230
        goto _L___11;
      } else
#line 1230
      if (parent) {
#line 1230
        if (! ((cmp.file[0].stat.st_mode & 61440U) == 32768U)) {
#line 1230
          goto _L___11;
        } else
#line 1230
        if (! ((cmp.file[1].stat.st_mode & 61440U) == 32768U)) {
          _L___11: /* CIL Label */ 
#line 1235
          if (cmp.file[0].desc == -1) {
#line 1235
            goto _L___5;
          } else
#line 1235
          if (cmp.file[1].desc == -1) {
            _L___5: /* CIL Label */ 
#line 1239
            if ((((cmp.file[0].stat.st_mode & 61440U) == 16384U) != 0) | (((cmp.file[1].stat.st_mode & 61440U) == 16384U) != 0)) {
#line 1239
              if (recursive) {
#line 1239
                if (new_file) {
                  {
#line 1244
                  status = diff_dirs((struct comparison  const  *)(& cmp), & compare_files);
                  }
                } else
#line 1239
                if (unidirectional_new_file) {
#line 1239
                  if (cmp.file[0].desc == -1) {
                    {
#line 1244
                    status = diff_dirs((struct comparison  const  *)(& cmp), & compare_files);
                    }
                  } else {
#line 1239
                    goto _L___4;
                  }
                } else {
#line 1239
                  goto _L___4;
                }
              } else {
#line 1239
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ 
#line 1250
              if (! parent) {
                {
#line 1250
                __assert_fail("parent", "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.c",
                              1250U, "compare_files");
                }
              }
              {
#line 1251
              dir___1 = (char const   *)parent->file[cmp.file[0].desc == -1].name;
#line 1254
              message("Only in %s: %s\n", dir___1, name0);
#line 1256
              status = 1;
              }
            }
          } else {
            {
#line 1264
            tmp___17 = file_type((struct stat  const  *)(& cmp.file[1].stat));
            }
#line 1264
            if (file_label[1]) {
#line 1264
              tmp___18 = (char const   *)file_label[1];
            } else {
#line 1264
              tmp___18 = cmp.file[1].name;
            }
            {
#line 1264
            tmp___19 = file_type((struct stat  const  *)(& cmp.file[0].stat));
            }
#line 1264
            if (file_label[0]) {
#line 1264
              tmp___20 = (char const   *)file_label[0];
            } else {
#line 1264
              tmp___20 = cmp.file[0].name;
            }
            {
#line 1264
            message5("File %s is a %s while file %s is a %s\n", tmp___20, tmp___19,
                     tmp___18, tmp___17);
#line 1271
            status = 1;
            }
          }
        } else {
#line 1230
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
#line 1274
      if (files_can_be_treated_as_binary) {
#line 1274
        if ((cmp.file[0].stat.st_mode & 61440U) == 32768U) {
#line 1274
          if ((cmp.file[1].stat.st_mode & 61440U) == 32768U) {
#line 1274
            if (cmp.file[0].stat.st_size != cmp.file[1].stat.st_size) {
#line 1279
              if (file_label[1]) {
#line 1279
                tmp___21 = (char const   *)file_label[1];
              } else {
#line 1279
                tmp___21 = cmp.file[1].name;
              }
#line 1279
              if (file_label[0]) {
#line 1279
                tmp___22 = (char const   *)file_label[0];
              } else {
#line 1279
                tmp___22 = cmp.file[0].name;
              }
              {
#line 1279
              message("Files %s and %s differ\n", tmp___22, tmp___21);
#line 1282
              status = 1;
              }
            } else {
#line 1274
              goto _L___8;
            }
          } else {
#line 1274
            goto _L___8;
          }
        } else {
#line 1274
          goto _L___8;
        }
      } else {
        _L___8: /* CIL Label */ 
#line 1290
        oflags = 0;
#line 1292
        if (cmp.file[0].desc == -2) {
          {
#line 1293
          cmp.file[0].desc = open(cmp.file[0].name, oflags, 0);
          }
#line 1293
          if (cmp.file[0].desc < 0) {
            {
#line 1295
            perror_with_name(cmp.file[0].name);
#line 1296
            status = 2;
            }
          }
        }
#line 1298
        if (cmp.file[1].desc == -2) {
#line 1300
          if (same_files) {
#line 1301
            cmp.file[1].desc = cmp.file[0].desc;
          } else {
            {
#line 1302
            cmp.file[1].desc = open(cmp.file[1].name, oflags, 0);
            }
#line 1302
            if (cmp.file[1].desc < 0) {
              {
#line 1304
              perror_with_name(cmp.file[1].name);
#line 1305
              status = 2;
              }
            }
          }
        }
#line 1311
        if (status == 0) {
          {
#line 1312
          status = diff_2_files(& cmp);
          }
        }
#line 1316
        if (0 <= cmp.file[0].desc) {
          {
#line 1316
          tmp___23 = close(cmp.file[0].desc);
          }
#line 1316
          if (tmp___23 != 0) {
            {
#line 1318
            perror_with_name(cmp.file[0].name);
#line 1319
            status = 2;
            }
          }
        }
#line 1321
        if (0 <= cmp.file[1].desc) {
#line 1321
          if (cmp.file[0].desc != cmp.file[1].desc) {
            {
#line 1321
            tmp___24 = close(cmp.file[1].desc);
            }
#line 1321
            if (tmp___24 != 0) {
              {
#line 1324
              perror_with_name(cmp.file[1].name);
#line 1325
              status = 2;
              }
            }
          }
        }
      }
    }
  }
#line 1332
  if (status == 0) {
#line 1334
    if (report_identical_files) {
#line 1334
      if (! (((cmp.file[0].stat.st_mode & 61440U) == 16384U) != 0)) {
#line 1335
        if (file_label[1]) {
#line 1335
          tmp___27 = (char const   *)file_label[1];
        } else {
#line 1335
          tmp___27 = cmp.file[1].name;
        }
#line 1335
        if (file_label[0]) {
#line 1335
          tmp___28 = (char const   *)file_label[0];
        } else {
#line 1335
          tmp___28 = cmp.file[0].name;
        }
        {
#line 1335
        message("Files %s and %s are identical\n", tmp___28, tmp___27);
        }
      }
    }
  } else {
    {
#line 1343
    tmp___30 = fflush_unlocked(stdout);
    }
#line 1343
    if (tmp___30 != 0) {
      {
#line 1344
      tmp___29 = gettext("standard output");
#line 1344
      pfatal_with_name((char const   *)tmp___29);
      }
    }
  }
  {
#line 1347
  free((void *)free0);
#line 1348
  free((void *)free1);
  }
#line 1350
  return (status);
}
}
#line 237 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 332 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/diff.h"
void print_context_script(struct change *script , _Bool unidiff ) ;
#line 75 "../lib/stat-time.h"
__inline static long get_stat_mtime_ns(struct stat  const  *st ) 
{ 


  {
#line 79
  return ((long )st->st_mtim.tv_nsec);
}
}
#line 26 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static char const   *find_function(char const   * const  *linbuf , lin linenum ) ;
#line 27
static struct change *find_hunk(struct change *start ) ;
#line 28
static void mark_ignorable(struct change *script ) ;
#line 29
static void pr_context_hunk(struct change *hunk ) ;
#line 30
static void pr_unidiff_hunk(struct change *hunk ) ;
#line 33 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static lin find_function_last_search  ;
#line 36 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static lin find_function_last_match  ;
#line 40 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static void print_context_label(char const   *mark , struct file_data *inf , char const   *label ) 
{ 
  char buf___0[1024] ;
  struct tm  const  *tm ;
  struct tm *tmp ;
  int nsec ;
  long tmp___0 ;
  long sec ;
  intmax_t sec___0 ;
  uintmax_t sec___1 ;
  size_t tmp___1 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 45
  if (label) {
    {
#line 46
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s %s\n",
            mark, label);
    }
  } else {
    {
#line 51
    tmp = localtime((time_t const   *)(& inf->stat.st_mtim.tv_sec));
#line 51
    tm = (struct tm  const  *)tmp;
#line 52
    tmp___0 = get_stat_mtime_ns((struct stat  const  *)(& inf->stat));
#line 52
    nsec = (int )tmp___0;
    }
#line 53
    if (tm) {
      {
#line 53
      tmp___1 = nstrftime(buf___0, sizeof(buf___0), time_format, tm, 0, nsec);
      }
#line 53
      if (! tmp___1) {
#line 53
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 56
    if ((-0x7FFFFFFFFFFFFFFF-1) <= ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) {
#line 56
      if (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L <= 9223372036854775807L) {
        {
#line 59
        sec = inf->stat.st_mtim.tv_sec;
#line 60
        sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%ld.%.9d",
                sec, nsec);
        }
      } else {
#line 56
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 62
    if (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L <= 9223372036854775807L) {
      {
#line 64
      sec___0 = inf->stat.st_mtim.tv_sec;
#line 65
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%ld.%.9d",
              sec___0, nsec);
      }
    } else {
      {
#line 69
      sec___1 = (uintmax_t )inf->stat.st_mtim.tv_sec;
#line 70
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%lu.%.9d",
              sec___1, nsec);
      }
    }
    {
#line 73
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%s %s\t%s\n",
            mark, inf->name, buf___0);
    }
  }
#line 75
  return;
}
}
#line 79 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
void print_context_header(struct file_data *inf , _Bool unidiff ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 82
  if (unidiff) {
    {
#line 84
    print_context_label("---", inf + 0, (char const   *)file_label[0]);
#line 85
    print_context_label("+++", inf + 1, (char const   *)file_label[1]);
    }
  } else {
    {
#line 89
    print_context_label("***", inf + 0, (char const   *)file_label[0]);
#line 90
    print_context_label("---", inf + 1, (char const   *)file_label[1]);
    }
  }
#line 92
  return;
}
}
#line 96 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
void print_context_script(struct change *script , _Bool unidiff ) 
{ 
  struct change *e ;

  {
#line 99
  if (ignore_blank_lines) {
    {
#line 100
    mark_ignorable(script);
    }
  } else
#line 99
  if (ignore_regexp.fastmap) {
    {
#line 100
    mark_ignorable(script);
    }
  } else {
#line 104
    e = script;
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! e) {
#line 104
        goto while_break;
      }
#line 105
      e->ignore = (_Bool)0;
#line 104
      e = e->link;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 108
  find_function_last_search = - files[0].prefix_lines;
#line 109
  find_function_last_match = 9223372036854775807L;
#line 111
  if (unidiff) {
    {
#line 112
    print_script(script, & find_hunk, & pr_unidiff_hunk);
    }
  } else {
    {
#line 114
    print_script(script, & find_hunk, & pr_context_hunk);
    }
  }
#line 115
  return;
}
}
#line 123 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static void print_context_number_range(struct file_data  const  *file , lin a , lin b ) 
{ 
  long trans_a ;
  long trans_b ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 127
  translate_range(file, a, b, & trans_a, & trans_b);
  }
#line 138
  if (trans_b <= trans_a) {
    {
#line 139
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%ld",
            trans_b);
    }
  } else {
    {
#line 141
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%ld,%ld",
            trans_a, trans_b);
    }
  }
#line 142
  return;
}
}
#line 145 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static void print_context_function(FILE *out , char const   *function ) 
{ 
  int i ;
  int j ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 149
  putc_unlocked(' ', out);
#line 150
  i = 0;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    tmp = c_isspace((int )((unsigned char )*(function + i)));
    }
#line 150
    if (tmp) {
#line 150
      if (! ((int const   )*(function + i) != 10)) {
#line 150
        goto while_break;
      }
    } else {
#line 150
      goto while_break;
    }
#line 151
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  j = i;
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (j < i + 40) {
#line 152
      if (! ((int const   )*(function + j) != 10)) {
#line 152
        goto while_break___0;
      }
    } else {
#line 152
      goto while_break___0;
    }
#line 153
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 152
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 154
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 154
    if (i < j) {
      {
#line 154
      tmp___0 = c_isspace((int )((unsigned char )*(function + (j - 1))));
      }
#line 154
      if (! tmp___0) {
#line 154
        goto while_break___1;
      }
    } else {
#line 154
      goto while_break___1;
    }
#line 155
    j --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 156
  fwrite_unlocked((void const   */* __restrict  */)(function + i), sizeof(char ),
                  (size_t )(j - i), (FILE */* __restrict  */)out);
  }
#line 157
  return;
}
}
#line 166 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static void pr_context_hunk(struct change *hunk ) 
{ 
  lin first0 ;
  lin last0 ;
  lin first1 ;
  lin last1 ;
  lin i ;
  char const   *prefix ;
  char const   *function ;
  FILE *out ;
  enum changes changes ;
  enum changes tmp ;
  struct change *next ;
  struct change *next___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 176
  tmp = analyze_hunk(hunk, & first0, & last0, & first1, & last1);
#line 176
  changes = tmp;
  }
#line 177
  if (! changes) {
#line 178
    return;
  }
#line 182
  i = - files[0].prefix_lines;
#line 183
  if (first0 - context >= i) {
#line 183
    first0 -= context;
  } else {
#line 183
    first0 = i;
  }
#line 184
  if (first1 - context >= i) {
#line 184
    first1 -= context;
  } else {
#line 184
    first1 = i;
  }
#line 185
  if (last0 < files[0].valid_lines - context) {
#line 186
    last0 += context;
  } else {
#line 188
    last0 = files[0].valid_lines - 1L;
  }
#line 189
  if (last1 < files[1].valid_lines - context) {
#line 190
    last1 += context;
  } else {
#line 192
    last1 = files[1].valid_lines - 1L;
  }
#line 195
  function = (char const   *)((void *)0);
#line 196
  if (function_regexp.fastmap) {
    {
#line 197
    function = find_function((char const   * const  *)files[0].linbuf, first0);
    }
  }
  {
#line 199
  begin_output();
#line 200
  out = outfile;
#line 202
  fputs_unlocked((char const   */* __restrict  */)"***************", (FILE */* __restrict  */)out);
  }
#line 204
  if (function) {
    {
#line 205
    print_context_function(out, function);
    }
  }
  {
#line 207
  fputs_unlocked((char const   */* __restrict  */)"\n*** ", (FILE */* __restrict  */)out);
#line 208
  print_context_number_range((struct file_data  const  *)(& files[0]), first0, last0);
#line 209
  fputs_unlocked((char const   */* __restrict  */)" ****\n", (FILE */* __restrict  */)out);
  }
#line 211
  if ((unsigned int )changes & 1U) {
#line 213
    next = hunk;
#line 215
    i = first0;
    {
#line 215
    while (1) {
      while_continue: /* CIL Label */ ;
#line 215
      if (! (i <= last0)) {
#line 215
        goto while_break;
      }
      {
#line 220
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 220
        if (next) {
#line 220
          if (! (next->line0 + next->deleted <= i)) {
#line 220
            goto while_break___0;
          }
        } else {
#line 220
          goto while_break___0;
        }
#line 221
        next = next->link;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 225
      prefix = " ";
#line 226
      if (next) {
#line 226
        if (next->line0 <= i) {
#line 230
          if (next->inserted > 0L) {
#line 230
            prefix = "!";
          } else {
#line 230
            prefix = "-";
          }
        }
      }
      {
#line 232
      print_1_line(prefix, (char const   * const  *)(files[0].linbuf + i));
#line 215
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 236
  fputs_unlocked((char const   */* __restrict  */)"--- ", (FILE */* __restrict  */)out);
#line 237
  print_context_number_range((struct file_data  const  *)(& files[1]), first1, last1);
#line 238
  fputs_unlocked((char const   */* __restrict  */)" ----\n", (FILE */* __restrict  */)out);
  }
#line 240
  if ((unsigned int )changes & 2U) {
#line 242
    next___0 = hunk;
#line 244
    i = first1;
    {
#line 244
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 244
      if (! (i <= last1)) {
#line 244
        goto while_break___1;
      }
      {
#line 249
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 249
        if (next___0) {
#line 249
          if (! (next___0->line1 + next___0->inserted <= i)) {
#line 249
            goto while_break___2;
          }
        } else {
#line 249
          goto while_break___2;
        }
#line 250
        next___0 = next___0->link;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 254
      prefix = " ";
#line 255
      if (next___0) {
#line 255
        if (next___0->line1 <= i) {
#line 259
          if (next___0->deleted > 0L) {
#line 259
            prefix = "!";
          } else {
#line 259
            prefix = "+";
          }
        }
      }
      {
#line 261
      print_1_line(prefix, (char const   * const  *)(files[1].linbuf + i));
#line 244
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 264
  return;
}
}
#line 273 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static void print_unidiff_number_range(struct file_data  const  *file , lin a , lin b ) 
{ 
  long trans_a ;
  long trans_b ;
  char const   *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 277
  translate_range(file, a, b, & trans_a, & trans_b);
  }
#line 283
  if (trans_b <= trans_a) {
#line 284
    if (trans_b < trans_a) {
#line 284
      tmp = "%ld,0";
    } else {
#line 284
      tmp = "%ld";
    }
    {
#line 284
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)tmp,
            trans_b);
    }
  } else {
    {
#line 286
    fprintf((FILE */* __restrict  */)outfile, (char const   */* __restrict  */)"%ld,%ld",
            trans_a, (trans_b - trans_a) + 1L);
    }
  }
#line 287
  return;
}
}
#line 296 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static void pr_unidiff_hunk(struct change *hunk ) 
{ 
  lin first0 ;
  lin last0 ;
  lin first1 ;
  lin last1 ;
  lin i ;
  lin j ;
  lin k ;
  struct change *next ;
  char const   *function ;
  FILE *out ;
  enum changes tmp ;
  char const   * const  *line ;
  lin tmp___0 ;
  int tmp___1 ;
  char const   * const  *line___0 ;
  lin tmp___2 ;
  lin tmp___3 ;
  char const   * const  *line___1 ;
  lin tmp___4 ;
  lin tmp___5 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 307
  tmp = analyze_hunk(hunk, & first0, & last0, & first1, & last1);
  }
#line 307
  if (! tmp) {
#line 308
    return;
  }
#line 312
  i = - files[0].prefix_lines;
#line 313
  if (first0 - context >= i) {
#line 313
    first0 -= context;
  } else {
#line 313
    first0 = i;
  }
#line 314
  if (first1 - context >= i) {
#line 314
    first1 -= context;
  } else {
#line 314
    first1 = i;
  }
#line 315
  if (last0 < files[0].valid_lines - context) {
#line 316
    last0 += context;
  } else {
#line 318
    last0 = files[0].valid_lines - 1L;
  }
#line 319
  if (last1 < files[1].valid_lines - context) {
#line 320
    last1 += context;
  } else {
#line 322
    last1 = files[1].valid_lines - 1L;
  }
#line 325
  function = (char const   *)((void *)0);
#line 326
  if (function_regexp.fastmap) {
    {
#line 327
    function = find_function((char const   * const  *)files[0].linbuf, first0);
    }
  }
  {
#line 329
  begin_output();
#line 330
  out = outfile;
#line 332
  fputs_unlocked((char const   */* __restrict  */)"@@ -", (FILE */* __restrict  */)out);
#line 333
  print_unidiff_number_range((struct file_data  const  *)(& files[0]), first0, last0);
#line 334
  fputs_unlocked((char const   */* __restrict  */)" +", (FILE */* __restrict  */)out);
#line 335
  print_unidiff_number_range((struct file_data  const  *)(& files[1]), first1, last1);
#line 336
  fputs_unlocked((char const   */* __restrict  */)" @@", (FILE */* __restrict  */)out);
  }
#line 338
  if (function) {
    {
#line 339
    print_context_function(out, function);
    }
  }
  {
#line 341
  putc_unlocked('\n', out);
#line 343
  next = hunk;
#line 344
  i = first0;
#line 345
  j = first1;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (i <= last0)) {
#line 347
      if (! (j <= last1)) {
#line 347
        goto while_break;
      }
    }
#line 352
    if (! next) {
#line 352
      goto _L___0;
    } else
#line 352
    if (i < next->line0) {
      _L___0: /* CIL Label */ 
#line 354
      tmp___0 = i;
#line 354
      i ++;
#line 354
      line = (char const   * const  *)(files[0].linbuf + tmp___0);
#line 355
      if (suppress_blank_empty) {
#line 355
        if (! ((int const   )*(*line) == 10)) {
#line 355
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 356
        if (initial_tab) {
#line 356
          tmp___1 = '\t';
        } else {
#line 356
          tmp___1 = ' ';
        }
        {
#line 356
        putc_unlocked(tmp___1, out);
        }
      }
      {
#line 357
      print_1_line((char const   *)((void *)0), line);
#line 358
      j ++;
      }
    } else {
#line 364
      k = next->deleted;
      {
#line 365
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 365
        tmp___3 = k;
#line 365
        k --;
#line 365
        if (! tmp___3) {
#line 365
          goto while_break___0;
        }
        {
#line 367
        tmp___2 = i;
#line 367
        i ++;
#line 367
        line___0 = (char const   * const  *)(files[0].linbuf + tmp___2);
#line 368
        putc_unlocked('-', out);
        }
#line 369
        if (initial_tab) {
#line 369
          if (suppress_blank_empty) {
#line 369
            if (! ((int const   )*(*line___0) == 10)) {
              {
#line 370
              putc_unlocked('\t', out);
              }
            }
          } else {
            {
#line 370
            putc_unlocked('\t', out);
            }
          }
        }
        {
#line 371
        print_1_line((char const   *)((void *)0), line___0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 376
      k = next->inserted;
      {
#line 377
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 377
        tmp___5 = k;
#line 377
        k --;
#line 377
        if (! tmp___5) {
#line 377
          goto while_break___1;
        }
        {
#line 379
        tmp___4 = j;
#line 379
        j ++;
#line 379
        line___1 = (char const   * const  *)(files[1].linbuf + tmp___4);
#line 380
        putc_unlocked('+', out);
        }
#line 381
        if (initial_tab) {
#line 381
          if (suppress_blank_empty) {
#line 381
            if (! ((int const   )*(*line___1) == 10)) {
              {
#line 382
              putc_unlocked('\t', out);
              }
            }
          } else {
            {
#line 382
            putc_unlocked('\t', out);
            }
          }
        }
        {
#line 383
        print_1_line((char const   *)((void *)0), line___1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 388
      next = next->link;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  return;
}
}
#line 397 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static struct change *find_hunk(struct change *start ) 
{ 
  struct change *prev ;
  lin top0 ;
  lin top1 ;
  lin thresh ;
  lin non_ignorable_threshold ;
  long tmp ;
  lin ignorable_threshold ;

  {
#line 407
  if (4611686018427387903L < context) {
#line 407
    tmp = 9223372036854775807L;
  } else {
#line 407
    tmp = 2L * context + 1L;
  }
#line 407
  non_ignorable_threshold = tmp;
#line 409
  ignorable_threshold = context;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    top0 = start->line0 + start->deleted;
#line 415
    top1 = start->line1 + start->inserted;
#line 416
    prev = start;
#line 417
    start = start->link;
#line 418
    if (prev->ignore) {
#line 418
      thresh = ignorable_threshold;
    } else
#line 418
    if (start) {
#line 418
      if (start->ignore) {
#line 418
        thresh = ignorable_threshold;
      } else {
#line 418
        thresh = non_ignorable_threshold;
      }
    } else {
#line 418
      thresh = non_ignorable_threshold;
    }
#line 423
    if (start) {
#line 423
      if (start->line0 - top0 != start->line1 - top1) {
        {
#line 424
        abort();
        }
      }
    }
#line 411
    if (start) {
#line 411
      if (! (start->line0 - top0 < thresh)) {
#line 411
        goto while_break;
      }
    } else {
#line 411
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  return (prev);
}
}
#line 437 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static void mark_ignorable(struct change *script ) 
{ 
  struct change *next ;
  lin first0 ;
  lin last0 ;
  lin first1 ;
  lin last1 ;
  enum changes tmp ;
  int tmp___0 ;

  {
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! script) {
#line 440
      goto while_break;
    }
    {
#line 442
    next = script->link;
#line 446
    script->link = (struct change *)((void *)0);
#line 449
    tmp = analyze_hunk(script, & first0, & last0, & first1, & last1);
    }
#line 449
    if (tmp) {
#line 449
      tmp___0 = 0;
    } else {
#line 449
      tmp___0 = 1;
    }
#line 449
    script->ignore = (_Bool )tmp___0;
#line 453
    script->link = next;
#line 456
    script = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  return;
}
}
#line 464 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/context.c"
static char const   *find_function(char const   * const  *linbuf , lin linenum ) 
{ 
  lin i ;
  lin last ;
  char const   *line ;
  size_t linelen ;
  int len ;
  size_t tmp ;
  regoff_t tmp___0 ;

  {
#line 467
  i = linenum;
#line 468
  last = find_function_last_search;
#line 469
  find_function_last_search = i;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    i --;
#line 471
    if (! (last <= i)) {
#line 471
      goto while_break;
    }
#line 474
    line = (char const   *)*(linbuf + i);
#line 475
    linelen = (size_t )((*(linbuf + (i + 1L)) - (char const   */* const  */)line) - 1L);
#line 478
    if (linelen <= 2147483647UL) {
#line 478
      tmp = linelen;
    } else {
#line 478
      tmp = (size_t )2147483647;
    }
    {
#line 478
    len = (int )tmp;
#line 480
    tmp___0 = re_search(& function_regexp, line, len, 0, len, (struct re_registers *)((void *)0));
    }
#line 480
    if (0 <= tmp___0) {
#line 482
      find_function_last_match = i;
#line 483
      return (line);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  if (find_function_last_match != 9223372036854775807L) {
#line 489
    return ((char const   *)*(linbuf + find_function_last_match));
  }
#line 491
  return ((char const   *)((void *)0));
}
}
#line 177 "../lib/diffseq.h"
static void diag(lin xoff , lin xlim , lin yoff , lin ylim , _Bool find_minimal ,
                 struct partition *part , struct context *ctxt ) 
{ 
  lin *fd ;
  lin *bd ;
  lin const   *xv ;
  lin const   *yv ;
  lin dmin ;
  lin dmax ;
  lin fmid ;
  lin bmid ;
  lin fmin ;
  lin fmax ;
  lin bmin ;
  lin bmax ;
  lin c ;
  _Bool odd ;
  lin d ;
  _Bool big_snake ;
  lin x ;
  lin y ;
  lin tlo ;
  lin thi ;
  lin x0 ;
  lin tmp ;
  _Bool tmp___0 ;
  lin x___0 ;
  lin y___0 ;
  lin tlo___0 ;
  lin thi___0 ;
  lin x0___0 ;
  lin tmp___1 ;
  _Bool tmp___2 ;
  lin best ;
  lin dd ;
  lin x___1 ;
  lin y___1 ;
  lin v ;
  int k ;
  lin tmp___3 ;
  lin best___0 ;
  lin dd___0 ;
  lin x___2 ;
  lin y___2 ;
  lin v___0 ;
  int k___0 ;
  lin tmp___4 ;
  lin fxybest ;
  lin fxbest ;
  lin bxybest ;
  lin bxbest ;
  lin x___3 ;
  lin tmp___5 ;
  lin y___3 ;
  lin x___4 ;
  lin tmp___6 ;
  lin y___4 ;

  {
#line 181
  fd = ctxt->fdiag;
#line 182
  bd = ctxt->bdiag;
#line 184
  xv = ctxt->xvec;
#line 185
  yv = ctxt->yvec;
#line 190
  dmin = xoff - ylim;
#line 191
  dmax = xlim - yoff;
#line 192
  fmid = xoff - yoff;
#line 193
  bmid = xlim - ylim;
#line 194
  fmin = fmid;
#line 195
  fmax = fmid;
#line 196
  bmin = bmid;
#line 197
  bmax = bmid;
#line 199
  odd = (_Bool )((fmid - bmid) & 1L);
#line 202
  *(fd + fmid) = xoff;
#line 203
  *(bd + bmid) = xlim;
#line 205
  c = (lin )1;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    big_snake = (_Bool)0;
#line 211
    if (fmin > dmin) {
#line 212
      fmin --;
#line 212
      *(fd + (fmin - 1L)) = (lin )-1;
    } else {
#line 214
      fmin ++;
    }
#line 215
    if (fmax < dmax) {
#line 216
      fmax ++;
#line 216
      *(fd + (fmax + 1L)) = (lin )-1;
    } else {
#line 218
      fmax --;
    }
#line 219
    d = fmax;
    {
#line 219
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 219
      if (! (d >= fmin)) {
#line 219
        goto while_break___0;
      }
#line 223
      tlo = *(fd + (d - 1L));
#line 224
      thi = *(fd + (d + 1L));
#line 225
      if (tlo < thi) {
#line 225
        tmp = thi;
      } else {
#line 225
        tmp = tlo + 1L;
      }
#line 225
      x0 = tmp;
#line 227
      x = x0;
#line 227
      y = x0 - d;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 227
        if (x < xlim) {
#line 227
          if (y < ylim) {
#line 227
            if (! (*(xv + x) == *(yv + y))) {
#line 227
              goto while_break___1;
            }
          } else {
#line 227
            goto while_break___1;
          }
        } else {
#line 227
          goto while_break___1;
        }
#line 230
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 227
        x ++;
#line 227
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 231
      if (x - x0 > 20L) {
#line 232
        big_snake = (_Bool)1;
      }
#line 233
      *(fd + d) = x;
#line 234
      if (odd) {
#line 234
        if (bmin <= d) {
#line 234
          if (d <= bmax) {
#line 234
            if (*(bd + d) <= x) {
#line 236
              part->xmid = x;
#line 237
              part->ymid = y;
#line 238
              tmp___0 = (_Bool)1;
#line 238
              part->hi_minimal = tmp___0;
#line 238
              part->lo_minimal = tmp___0;
#line 239
              return;
            }
          }
        }
      }
#line 219
      d -= 2L;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    if (bmin > dmin) {
#line 245
      bmin --;
#line 245
      *(bd + (bmin - 1L)) = ((1L << (sizeof(lin ) * 8UL - 2UL)) - 1L) * 2L + 1L;
    } else {
#line 247
      bmin ++;
    }
#line 248
    if (bmax < dmax) {
#line 249
      bmax ++;
#line 249
      *(bd + (bmax + 1L)) = ((1L << (sizeof(lin ) * 8UL - 2UL)) - 1L) * 2L + 1L;
    } else {
#line 251
      bmax --;
    }
#line 252
    d = bmax;
    {
#line 252
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 252
      if (! (d >= bmin)) {
#line 252
        goto while_break___2;
      }
#line 256
      tlo___0 = *(bd + (d - 1L));
#line 257
      thi___0 = *(bd + (d + 1L));
#line 258
      if (tlo___0 < thi___0) {
#line 258
        tmp___1 = tlo___0;
      } else {
#line 258
        tmp___1 = thi___0 - 1L;
      }
#line 258
      x0___0 = tmp___1;
#line 260
      x___0 = x0___0;
#line 260
      y___0 = x0___0 - d;
      {
#line 260
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 260
        if (xoff < x___0) {
#line 260
          if (yoff < y___0) {
#line 260
            if (! (*(xv + (x___0 - 1L)) == *(yv + (y___0 - 1L)))) {
#line 260
              goto while_break___3;
            }
          } else {
#line 260
            goto while_break___3;
          }
        } else {
#line 260
          goto while_break___3;
        }
#line 263
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 260
        x___0 --;
#line 260
        y___0 --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 264
      if (x0___0 - x___0 > 20L) {
#line 265
        big_snake = (_Bool)1;
      }
#line 266
      *(bd + d) = x___0;
#line 267
      if (! odd) {
#line 267
        if (fmin <= d) {
#line 267
          if (d <= fmax) {
#line 267
            if (x___0 <= *(fd + d)) {
#line 269
              part->xmid = x___0;
#line 270
              part->ymid = y___0;
#line 271
              tmp___2 = (_Bool)1;
#line 271
              part->hi_minimal = tmp___2;
#line 271
              part->lo_minimal = tmp___2;
#line 272
              return;
            }
          }
        }
      }
#line 252
      d -= 2L;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 276
    if (find_minimal) {
#line 277
      goto __Cont___1;
    }
#line 288
    if (200L < c) {
#line 288
      if (big_snake) {
#line 288
        if (ctxt->heuristic) {
#line 291
          best = (lin )0;
#line 293
          d = fmax;
          {
#line 293
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 293
            if (! (d >= fmin)) {
#line 293
              goto while_break___4;
            }
#line 295
            dd = d - fmid;
#line 296
            x___1 = *(fd + d);
#line 297
            y___1 = x___1 - d;
#line 298
            v = (x___1 - xoff) * 2L - dd;
#line 300
            if (dd < 0L) {
#line 300
              tmp___3 = - dd;
            } else {
#line 300
              tmp___3 = dd;
            }
#line 300
            if (v > 12L * (c + tmp___3)) {
#line 302
              if (v > best) {
#line 302
                if (xoff + 20L <= x___1) {
#line 302
                  if (x___1 < xlim) {
#line 302
                    if (yoff + 20L <= y___1) {
#line 302
                      if (y___1 < ylim) {
#line 310
                        k = 1;
                        {
#line 310
                        while (1) {
                          while_continue___5: /* CIL Label */ ;
#line 310
                          if (! (*(xv + (x___1 - (lin )k)) == *(yv + (y___1 - (lin )k)))) {
#line 310
                            goto while_break___5;
                          }
#line 311
                          if (k == 20) {
#line 313
                            best = v;
#line 314
                            part->xmid = x___1;
#line 315
                            part->ymid = y___1;
#line 316
                            goto while_break___5;
                          }
#line 310
                          k ++;
                        }
                        while_break___5: /* CIL Label */ ;
                        }
                      }
                    }
                  }
                }
              }
            }
#line 293
            d -= 2L;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 321
          if (best > 0L) {
#line 323
            part->lo_minimal = (_Bool)1;
#line 324
            part->hi_minimal = (_Bool)0;
#line 325
            return;
          }
#line 330
          best___0 = (lin )0;
#line 332
          d = bmax;
          {
#line 332
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 332
            if (! (d >= bmin)) {
#line 332
              goto while_break___6;
            }
#line 334
            dd___0 = d - bmid;
#line 335
            x___2 = *(bd + d);
#line 336
            y___2 = x___2 - d;
#line 337
            v___0 = (xlim - x___2) * 2L + dd___0;
#line 339
            if (dd___0 < 0L) {
#line 339
              tmp___4 = - dd___0;
            } else {
#line 339
              tmp___4 = dd___0;
            }
#line 339
            if (v___0 > 12L * (c + tmp___4)) {
#line 341
              if (v___0 > best___0) {
#line 341
                if (xoff < x___2) {
#line 341
                  if (x___2 <= xlim - 20L) {
#line 341
                    if (yoff < y___2) {
#line 341
                      if (y___2 <= ylim - 20L) {
#line 349
                        k___0 = 0;
                        {
#line 349
                        while (1) {
                          while_continue___7: /* CIL Label */ ;
#line 349
                          if (! (*(xv + (x___2 + (lin )k___0)) == *(yv + (y___2 + (lin )k___0)))) {
#line 349
                            goto while_break___7;
                          }
#line 350
                          if (k___0 == 19) {
#line 352
                            best___0 = v___0;
#line 353
                            part->xmid = x___2;
#line 354
                            part->ymid = y___2;
#line 355
                            goto while_break___7;
                          }
#line 349
                          k___0 ++;
                        }
                        while_break___7: /* CIL Label */ ;
                        }
                      }
                    }
                  }
                }
              }
            }
#line 332
            d -= 2L;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 360
          if (best___0 > 0L) {
#line 362
            part->lo_minimal = (_Bool)0;
#line 363
            part->hi_minimal = (_Bool)1;
#line 364
            return;
          }
        }
      }
    }
#line 372
    if (c >= ctxt->too_expensive) {
#line 380
      fxybest = (lin )-1;
#line 381
      d = fmax;
      {
#line 381
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 381
        if (! (d >= fmin)) {
#line 381
          goto while_break___8;
        }
#line 383
        if (*(fd + d) <= xlim) {
#line 383
          tmp___5 = *(fd + d);
        } else {
#line 383
          tmp___5 = xlim;
        }
#line 383
        x___3 = tmp___5;
#line 384
        y___3 = x___3 - d;
#line 385
        if (ylim < y___3) {
#line 387
          x___3 = ylim + d;
#line 388
          y___3 = ylim;
        }
#line 390
        if (fxybest < x___3 + y___3) {
#line 392
          fxybest = x___3 + y___3;
#line 393
          fxbest = x___3;
        }
#line 381
        d -= 2L;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 398
      bxybest = ((1L << (sizeof(lin ) * 8UL - 2UL)) - 1L) * 2L + 1L;
#line 399
      d = bmax;
      {
#line 399
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 399
        if (! (d >= bmin)) {
#line 399
          goto while_break___9;
        }
#line 401
        if (xoff >= *(bd + d)) {
#line 401
          tmp___6 = xoff;
        } else {
#line 401
          tmp___6 = *(bd + d);
        }
#line 401
        x___4 = tmp___6;
#line 402
        y___4 = x___4 - d;
#line 403
        if (y___4 < yoff) {
#line 405
          x___4 = yoff + d;
#line 406
          y___4 = yoff;
        }
#line 408
        if (x___4 + y___4 < bxybest) {
#line 410
          bxybest = x___4 + y___4;
#line 411
          bxbest = x___4;
        }
#line 399
        d -= 2L;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 416
      if ((xlim + ylim) - bxybest < fxybest - (xoff + yoff)) {
#line 418
        part->xmid = fxbest;
#line 419
        part->ymid = fxybest - fxbest;
#line 420
        part->lo_minimal = (_Bool)1;
#line 421
        part->hi_minimal = (_Bool)0;
      } else {
#line 425
        part->xmid = bxbest;
#line 426
        part->ymid = bxybest - bxbest;
#line 427
        part->lo_minimal = (_Bool)0;
#line 428
        part->hi_minimal = (_Bool)1;
      }
#line 430
      return;
    }
    __Cont___1: /* CIL Label */ 
#line 205
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 453 "../lib/diffseq.h"
static _Bool compareseq(lin xoff , lin xlim , lin yoff , lin ylim , _Bool find_minimal ,
                        struct context *ctxt ) 
{ 
  lin const   *xv ;
  lin const   *yv ;
  struct partition part ;
  _Bool tmp ;
  _Bool tmp___0 ;
  void *__cil_tmp12 ;

  {
#line 458
  xv = ctxt->xvec;
#line 459
  yv = ctxt->yvec;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (xoff < xlim) {
#line 466
      if (yoff < ylim) {
#line 466
        if (! (*(xv + xoff) == *(yv + yoff))) {
#line 466
          goto while_break;
        }
      } else {
#line 466
        goto while_break;
      }
    } else {
#line 466
      goto while_break;
    }
#line 468
    xoff ++;
#line 469
    yoff ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 473
    if (xoff < xlim) {
#line 473
      if (yoff < ylim) {
#line 473
        if (! (*(xv + (xlim - 1L)) == *(yv + (ylim - 1L)))) {
#line 473
          goto while_break___0;
        }
      } else {
#line 473
        goto while_break___0;
      }
    } else {
#line 473
      goto while_break___0;
    }
#line 475
    xlim --;
#line 476
    ylim --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 480
  if (xoff == xlim) {
    {
#line 481
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 481
      if (! (yoff < ylim)) {
#line 481
        goto while_break___1;
      }
#line 483
      *(files[1].changed + *(files[1].realindexes + yoff)) = (char)1;
#line 486
      yoff ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 488
  if (yoff == ylim) {
    {
#line 489
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 489
      if (! (xoff < xlim)) {
#line 489
        goto while_break___2;
      }
#line 491
      *(files[0].changed + *(files[0].realindexes + xoff)) = (char)1;
#line 494
      xoff ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 501
    diag(xoff, xlim, yoff, ylim, find_minimal, & part, ctxt);
#line 504
    tmp = compareseq(xoff, part.xmid, yoff, part.ymid, part.lo_minimal, ctxt);
    }
#line 504
    if (tmp) {
#line 505
      return ((_Bool)1);
    }
    {
#line 506
    tmp___0 = compareseq(part.xmid, xlim, part.ymid, ylim, part.hi_minimal, ctxt);
    }
#line 506
    if (tmp___0) {
#line 507
      return ((_Bool)1);
    }
  }
#line 510
  return ((_Bool)0);
}
}
#line 49 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/analyze.c"
static void discard_confusing_lines(struct file_data *filevec ) 
{ 
  int f ;
  lin i ;
  char *discarded[2] ;
  lin *equiv_count[2] ;
  lin *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t end ;
  char *discards ;
  lin *counts ;
  lin *equivs___0 ;
  size_t many ;
  size_t tem ;
  lin nmatch ;
  lin end___0 ;
  register char *discards___0 ;
  register lin j ;
  lin length ;
  lin provisional ;
  register lin consec ;
  lin minimum ;
  lin tem___0 ;
  char *discards___1 ;
  lin end___1 ;
  lin j___0 ;
  lin tmp___2 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;

  {
  {
#line 59
  tmp = xmalloc((unsigned long )((filevec + 0)->buffered_lines + (filevec + 1)->buffered_lines) * (2UL * sizeof(*p)));
#line 59
  p = (lin *)tmp;
#line 61
  f = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (f < 2)) {
#line 61
      goto while_break;
    }
#line 63
    (filevec + f)->undiscarded = p;
#line 63
    p += (filevec + f)->buffered_lines;
#line 64
    (filevec + f)->realindexes = p;
#line 64
    p += (filevec + f)->buffered_lines;
#line 61
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  tmp___0 = zalloc((unsigned long )(filevec + 0)->equiv_max * (2UL * sizeof(*p)));
#line 70
  p = (lin *)tmp___0;
#line 71
  equiv_count[0] = p;
#line 72
  equiv_count[1] = p + (filevec + 0)->equiv_max;
#line 74
  i = (lin )0;
  }
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (! (i < (filevec + 0)->buffered_lines)) {
#line 74
      goto while_break___0;
    }
#line 75
    (*(equiv_count[0] + *((filevec + 0)->equivs + i))) ++;
#line 74
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 76
  i = (lin )0;
  {
#line 76
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 76
    if (! (i < (filevec + 1)->buffered_lines)) {
#line 76
      goto while_break___1;
    }
#line 77
    (*(equiv_count[1] + *((filevec + 1)->equivs + i))) ++;
#line 76
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 81
  tmp___1 = zalloc((size_t )((filevec + 0)->buffered_lines + (filevec + 1)->buffered_lines));
#line 81
  discarded[0] = (char *)tmp___1;
#line 83
  discarded[1] = discarded[0] + (filevec + 0)->buffered_lines;
#line 88
  f = 0;
  }
  {
#line 88
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 88
    if (! (f < 2)) {
#line 88
      goto while_break___2;
    }
#line 90
    end = (size_t )(filevec + f)->buffered_lines;
#line 91
    discards = discarded[f];
#line 92
    counts = equiv_count[1 - f];
#line 93
    equivs___0 = (filevec + f)->equivs;
#line 94
    many = (size_t )5;
#line 95
    tem = end / 64UL;
    {
#line 99
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 99
      tem >>= 2;
#line 99
      if (! (tem > 0UL)) {
#line 99
        goto while_break___3;
      }
#line 100
      many *= 2UL;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 102
    i = (lin )0;
    {
#line 102
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 102
      if (! ((size_t )i < end)) {
#line 102
        goto while_break___4;
      }
#line 105
      if (*(equivs___0 + i) == 0L) {
#line 106
        goto __Cont;
      }
#line 107
      nmatch = *(counts + *(equivs___0 + i));
#line 108
      if (nmatch == 0L) {
#line 109
        *(discards + i) = (char)1;
      } else
#line 110
      if ((size_t )nmatch > many) {
#line 111
        *(discards + i) = (char)2;
      }
      __Cont: /* CIL Label */ 
#line 102
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 88
    f ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 119
  f = 0;
  {
#line 119
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 119
    if (! (f < 2)) {
#line 119
      goto while_break___5;
    }
#line 121
    end___0 = (filevec + f)->buffered_lines;
#line 122
    discards___0 = discarded[f];
#line 124
    i = (lin )0;
    {
#line 124
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 124
      if (! (i < end___0)) {
#line 124
        goto while_break___6;
      }
#line 127
      if ((int )*(discards___0 + i) == 2) {
#line 128
        *(discards___0 + i) = (char)0;
      } else
#line 129
      if ((int )*(discards___0 + i) != 0) {
#line 134
        provisional = (lin )0;
#line 138
        j = i;
        {
#line 138
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 138
          if (! (j < end___0)) {
#line 138
            goto while_break___7;
          }
#line 140
          if ((int )*(discards___0 + j) == 0) {
#line 141
            goto while_break___7;
          }
#line 142
          if ((int )*(discards___0 + j) == 2) {
#line 143
            provisional ++;
          }
#line 138
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 147
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 147
          if (j > i) {
#line 147
            if (! ((int )*(discards___0 + (j - 1L)) == 2)) {
#line 147
              goto while_break___8;
            }
          } else {
#line 147
            goto while_break___8;
          }
#line 148
          j --;
#line 148
          *(discards___0 + j) = (char)0;
#line 148
          provisional --;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 152
        length = j - i;
#line 156
        if (provisional * 4L > length) {
          {
#line 158
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 158
            if (! (j > i)) {
#line 158
              goto while_break___9;
            }
#line 159
            j --;
#line 159
            if ((int )*(discards___0 + j) == 2) {
#line 160
              *(discards___0 + j) = (char)0;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
        } else {
#line 165
          minimum = (lin )1;
#line 166
          tem___0 = length >> 2;
          {
#line 172
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 172
            tem___0 >>= 2;
#line 172
            if (! (0L < tem___0)) {
#line 172
              goto while_break___10;
            }
#line 173
            minimum <<= 1;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 174
          minimum ++;
#line 178
          j = (lin )0;
#line 178
          consec = (lin )0;
          {
#line 178
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 178
            if (! (j < length)) {
#line 178
              goto while_break___11;
            }
#line 179
            if ((int )*(discards___0 + (i + j)) != 2) {
#line 180
              consec = (lin )0;
            } else {
#line 181
              consec ++;
#line 181
              if (minimum == consec) {
#line 183
                j -= consec;
              } else
#line 184
              if (minimum < consec) {
#line 185
                *(discards___0 + (i + j)) = (char)0;
              }
            }
#line 178
            j ++;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 191
          j = (lin )0;
#line 191
          consec = (lin )0;
          {
#line 191
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 191
            if (! (j < length)) {
#line 191
              goto while_break___12;
            }
#line 193
            if (j >= 8L) {
#line 193
              if ((int )*(discards___0 + (i + j)) == 1) {
#line 194
                goto while_break___12;
              }
            }
#line 195
            if ((int )*(discards___0 + (i + j)) == 2) {
#line 196
              consec = (lin )0;
#line 196
              *(discards___0 + (i + j)) = (char)0;
            } else
#line 197
            if ((int )*(discards___0 + (i + j)) == 0) {
#line 198
              consec = (lin )0;
            } else {
#line 200
              consec ++;
            }
#line 201
            if (consec == 3L) {
#line 202
              goto while_break___12;
            }
#line 191
            j ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 206
          i += length - 1L;
#line 209
          j = (lin )0;
#line 209
          consec = (lin )0;
          {
#line 209
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 209
            if (! (j < length)) {
#line 209
              goto while_break___13;
            }
#line 211
            if (j >= 8L) {
#line 211
              if ((int )*(discards___0 + (i - j)) == 1) {
#line 212
                goto while_break___13;
              }
            }
#line 213
            if ((int )*(discards___0 + (i - j)) == 2) {
#line 214
              consec = (lin )0;
#line 214
              *(discards___0 + (i - j)) = (char)0;
            } else
#line 215
            if ((int )*(discards___0 + (i - j)) == 0) {
#line 216
              consec = (lin )0;
            } else {
#line 218
              consec ++;
            }
#line 219
            if (consec == 3L) {
#line 220
              goto while_break___13;
            }
#line 209
            j ++;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
      }
#line 124
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 119
    f ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 228
  f = 0;
  {
#line 228
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 228
    if (! (f < 2)) {
#line 228
      goto while_break___14;
    }
#line 230
    discards___1 = discarded[f];
#line 231
    end___1 = (filevec + f)->buffered_lines;
#line 232
    j___0 = (lin )0;
#line 233
    i = (lin )0;
    {
#line 233
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 233
      if (! (i < end___1)) {
#line 233
        goto while_break___15;
      }
#line 234
      if (minimal) {
#line 236
        *((filevec + f)->undiscarded + j___0) = *((filevec + f)->equivs + i);
#line 237
        tmp___2 = j___0;
#line 237
        j___0 ++;
#line 237
        *((filevec + f)->realindexes + tmp___2) = i;
      } else
#line 234
      if ((int )*(discards___1 + i) == 0) {
#line 236
        *((filevec + f)->undiscarded + j___0) = *((filevec + f)->equivs + i);
#line 237
        tmp___2 = j___0;
#line 237
        j___0 ++;
#line 237
        *((filevec + f)->realindexes + tmp___2) = i;
      } else {
#line 240
        *((filevec + f)->changed + i) = (char)1;
      }
#line 233
      i ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 241
    (filevec + f)->nondiscarded_lines = j___0;
#line 228
    f ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 244
  free((void *)discarded[0]);
#line 245
  free((void *)equiv_count[0]);
  }
#line 246
  return;
}
}
#line 258 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/analyze.c"
static void shift_boundaries(struct file_data *filevec ) 
{ 
  int f ;
  char *changed ;
  char *other_changed ;
  lin const   *equivs___0 ;
  lin i ;
  lin j ;
  lin i_end ;
  lin runlength ;
  lin start ;
  lin corresponding ;
  lin tmp ;
  lin tmp___0 ;
  lin tmp___1 ;

  {
#line 263
  f = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (f < 2)) {
#line 263
      goto while_break;
    }
#line 265
    changed = (filevec + f)->changed;
#line 266
    other_changed = (filevec + (1 - f))->changed;
#line 267
    equivs___0 = (lin const   *)(filevec + f)->equivs;
#line 268
    i = (lin )0;
#line 269
    j = (lin )0;
#line 270
    i_end = (filevec + f)->buffered_lines;
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 279
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 279
        if (i < i_end) {
#line 279
          if (! (! *(changed + i))) {
#line 279
            goto while_break___1;
          }
        } else {
#line 279
          goto while_break___1;
        }
        {
#line 281
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 281
          tmp = j;
#line 281
          j ++;
#line 281
          if (! *(other_changed + tmp)) {
#line 281
            goto while_break___2;
          }
#line 282
          goto while_continue___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 283
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 286
      if (i == i_end) {
#line 287
        goto while_break___0;
      }
#line 289
      start = i;
      {
#line 293
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 293
        i ++;
#line 293
        if (! *(changed + i)) {
#line 293
          goto while_break___3;
        }
#line 294
        goto while_continue___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 295
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 295
        if (! *(other_changed + j)) {
#line 295
          goto while_break___4;
        }
#line 296
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 298
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 302
        runlength = i - start;
        {
#line 308
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 308
          if (start) {
#line 308
            if (! (*(equivs___0 + (start - 1L)) == *(equivs___0 + (i - 1L)))) {
#line 308
              goto while_break___6;
            }
          } else {
#line 308
            goto while_break___6;
          }
#line 310
          start --;
#line 310
          *(changed + start) = (char)1;
#line 311
          i --;
#line 311
          *(changed + i) = (char)0;
          {
#line 312
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 312
            if (! *(changed + (start - 1L))) {
#line 312
              goto while_break___7;
            }
#line 313
            start --;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 314
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 314
            j --;
#line 314
            if (! *(other_changed + j)) {
#line 314
              goto while_break___8;
            }
#line 315
            goto while_continue___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 321
        if (*(other_changed + (j - 1L))) {
#line 321
          corresponding = i;
        } else {
#line 321
          corresponding = i_end;
        }
        {
#line 329
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 329
          if (i != i_end) {
#line 329
            if (! (*(equivs___0 + start) == *(equivs___0 + i))) {
#line 329
              goto while_break___9;
            }
          } else {
#line 329
            goto while_break___9;
          }
#line 331
          tmp___0 = start;
#line 331
          start ++;
#line 331
          *(changed + tmp___0) = (char)0;
#line 332
          tmp___1 = i;
#line 332
          i ++;
#line 332
          *(changed + tmp___1) = (char)1;
          {
#line 333
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 333
            if (! *(changed + i)) {
#line 333
              goto while_break___10;
            }
#line 334
            i ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 335
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 335
            j ++;
#line 335
            if (! *(other_changed + j)) {
#line 335
              goto while_break___11;
            }
#line 336
            corresponding = i;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 298
        if (! (runlength != i - start)) {
#line 298
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 344
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 344
        if (! (corresponding < i)) {
#line 344
          goto while_break___12;
        }
#line 346
        start --;
#line 346
        *(changed + start) = (char)1;
#line 347
        i --;
#line 347
        *(changed + i) = (char)0;
        {
#line 348
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 348
          j --;
#line 348
          if (! *(other_changed + j)) {
#line 348
            goto while_break___13;
          }
#line 349
          goto while_continue___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 263
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  return;
}
}
#line 363 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/analyze.c"
static struct change *add_change(lin line0 , lin line1 , lin deleted , lin inserted ,
                                 struct change *old ) 
{ 
  struct change *new ;
  void *tmp ;

  {
  {
#line 367
  tmp = xmalloc(sizeof(*new));
#line 367
  new = (struct change *)tmp;
#line 369
  new->line0 = line0;
#line 370
  new->line1 = line1;
#line 371
  new->inserted = inserted;
#line 372
  new->deleted = deleted;
#line 373
  new->link = old;
  }
#line 374
  return (new);
}
}
#line 380 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/analyze.c"
static struct change *build_reverse_script(struct file_data  const  *filevec ) 
{ 
  struct change *script ;
  char *changed0 ;
  char *changed1 ;
  lin len0 ;
  lin len1 ;
  lin i0 ;
  lin i1 ;
  lin line0 ;
  lin line1 ;

  {
#line 383
  script = (struct change *)0;
#line 384
  changed0 = (char *)(filevec + 0)->changed;
#line 385
  changed1 = (char *)(filevec + 1)->changed;
#line 386
  len0 = (lin )(filevec + 0)->buffered_lines;
#line 387
  len1 = (lin )(filevec + 1)->buffered_lines;
#line 391
  i0 = (lin )0;
#line 391
  i1 = (lin )0;
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! (i0 < len0)) {
#line 393
      if (! (i1 < len1)) {
#line 393
        goto while_break;
      }
    }
#line 395
    if ((int )*(changed0 + i0) | (int )*(changed1 + i1)) {
#line 397
      line0 = i0;
#line 397
      line1 = i1;
      {
#line 400
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 400
        if (! *(changed0 + i0)) {
#line 400
          goto while_break___0;
        }
#line 400
        i0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 401
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 401
        if (! *(changed1 + i1)) {
#line 401
          goto while_break___1;
        }
#line 401
        i1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 404
      script = add_change(line0, line1, i0 - line0, i1 - line1, script);
      }
    }
#line 408
    i0 ++;
#line 408
    i1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return (script);
}
}
#line 417 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/analyze.c"
static struct change *build_script(struct file_data  const  *filevec ) 
{ 
  struct change *script ;
  char *changed0 ;
  char *changed1 ;
  lin i0 ;
  lin i1 ;
  lin line0 ;
  lin line1 ;

  {
#line 420
  script = (struct change *)0;
#line 421
  changed0 = (char *)(filevec + 0)->changed;
#line 422
  changed1 = (char *)(filevec + 1)->changed;
#line 423
  i0 = (lin )(filevec + 0)->buffered_lines;
#line 423
  i1 = (lin )(filevec + 1)->buffered_lines;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (i0 >= 0L)) {
#line 427
      if (! (i1 >= 0L)) {
#line 427
        goto while_break;
      }
    }
#line 429
    if ((int )*(changed0 + (i0 - 1L)) | (int )*(changed1 + (i1 - 1L))) {
#line 431
      line0 = i0;
#line 431
      line1 = i1;
      {
#line 434
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 434
        if (! *(changed0 + (i0 - 1L))) {
#line 434
          goto while_break___0;
        }
#line 434
        i0 --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 435
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 435
        if (! *(changed1 + (i1 - 1L))) {
#line 435
          goto while_break___1;
        }
#line 435
        i1 --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 438
      script = add_change(i0, i1, line0 - i0, line1 - i1, script);
      }
    }
#line 442
    i0 --;
#line 442
    i1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return (script);
}
}
#line 450 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/analyze.c"
static int briefly_report(int changes , struct file_data  const  *filevec ) 
{ 
  char const   *label0 ;
  char const   *tmp ;
  char const   *label1 ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 453
  if (changes) {
#line 455
    if (file_label[0]) {
#line 455
      tmp = (char const   */* const  */)file_label[0];
    } else {
#line 455
      tmp = (filevec + 0)->name;
    }
#line 455
    label0 = (char const   *)tmp;
#line 456
    if (file_label[1]) {
#line 456
      tmp___0 = (char const   */* const  */)file_label[1];
    } else {
#line 456
      tmp___0 = (filevec + 1)->name;
    }
#line 456
    label1 = (char const   *)tmp___0;
#line 458
    if (brief) {
      {
#line 459
      message("Files %s and %s differ\n", label0, label1);
      }
    } else {
      {
#line 462
      message("Binary files %s and %s differ\n", label0, label1);
#line 463
      changes = 2;
      }
    }
  }
#line 467
  return (changes);
}
}
#line 471 "/home/wslee/gnu_benchmarks/diffutils-3.2/src/analyze.c"
int diff_2_files(struct comparison *cmp ) 
{ 
  int f ;
  struct change *e ;
  struct change *p ;
  struct change *script ;
  int changes ;
  size_t lcm_max ;
  size_t buffer_size ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  struct context ctxt ;
  lin diags ;
  lin too_expensive ;
  size_t s ;
  char *flag_space ;
  void *tmp___4 ;
  void *tmp___5 ;
  struct change *next ;
  struct change *this ;
  struct change *end ;
  lin first0 ;
  lin last0 ;
  lin first1 ;
  lin last1 ;
  enum changes tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  _Bool tmp___11 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 486
  tmp___11 = read_files(cmp->file, files_can_be_treated_as_binary);
  }
#line 486
  if (tmp___11) {
#line 489
    if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size) {
#line 489
      if (cmp->file[0].desc < 0) {
#line 489
        goto _L___1;
      } else
#line 489
      if ((cmp->file[0].stat.st_mode & 61440U) == 32768U) {
        _L___1: /* CIL Label */ 
#line 489
        if (cmp->file[1].desc < 0) {
#line 492
          changes = 1;
        } else
#line 489
        if ((cmp->file[1].stat.st_mode & 61440U) == 32768U) {
#line 492
          changes = 1;
        } else {
#line 489
          goto _L___0;
        }
      } else {
#line 489
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 495
    if (cmp->file[0].desc == cmp->file[1].desc) {
#line 496
      changes = 0;
    } else {
      {
#line 502
      lcm_max = (size_t )9223372036854775806L;
#line 503
      tmp = buffer_lcm((size_t )cmp->file[0].stat.st_blksize, (size_t )cmp->file[1].stat.st_blksize,
                       lcm_max);
#line 503
      tmp___0 = buffer_lcm(sizeof(uintmax_t ), tmp, lcm_max);
#line 503
      buffer_size = tmp___0;
#line 509
      f = 0;
      }
      {
#line 509
      while (1) {
        while_continue: /* CIL Label */ ;
#line 509
        if (! (f < 2)) {
#line 509
          goto while_break;
        }
        {
#line 510
        tmp___1 = xrealloc((void *)cmp->file[f].buffer, buffer_size);
#line 510
        cmp->file[f].buffer = (uintmax_t *)tmp___1;
#line 509
        f ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 512
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 515
        f = 0;
        {
#line 515
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 515
          if (! (f < 2)) {
#line 515
            goto while_break___1;
          }
#line 516
          if (0 <= cmp->file[f].desc) {
            {
#line 517
            file_block_read(& cmp->file[f], buffer_size - cmp->file[f].buffered);
            }
          }
#line 515
          f ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 521
        if (cmp->file[0].buffered != cmp->file[1].buffered) {
#line 526
          changes = 1;
#line 527
          goto while_break___0;
        } else {
          {
#line 521
          tmp___3 = memcmp((void const   *)cmp->file[0].buffer, (void const   *)cmp->file[1].buffer,
                           cmp->file[0].buffered);
          }
#line 521
          if (tmp___3) {
#line 526
            changes = 1;
#line 527
            goto while_break___0;
          }
        }
#line 531
        if (cmp->file[0].buffered != buffer_size) {
#line 533
          changes = 0;
#line 534
          goto while_break___0;
        }
#line 512
        tmp___2 = (size_t )0;
#line 512
        cmp->file[1].buffered = tmp___2;
#line 512
        cmp->file[0].buffered = tmp___2;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 539
    changes = briefly_report(changes, (struct file_data  const  *)(cmp->file));
    }
  } else {
    {
#line 552
    s = (size_t )((cmp->file[0].buffered_lines + cmp->file[1].buffered_lines) + 4L);
#line 553
    tmp___4 = zalloc(s);
#line 553
    flag_space = (char *)tmp___4;
#line 554
    cmp->file[0].changed = flag_space + 1;
#line 555
    cmp->file[1].changed = (flag_space + cmp->file[0].buffered_lines) + 3;
#line 561
    discard_confusing_lines(cmp->file);
#line 566
    ctxt.xvec = (lin const   *)cmp->file[0].undiscarded;
#line 567
    ctxt.yvec = (lin const   *)cmp->file[1].undiscarded;
#line 568
    diags = (cmp->file[0].nondiscarded_lines + cmp->file[1].nondiscarded_lines) + 3L;
#line 570
    tmp___5 = xmalloc((unsigned long )diags * (2UL * sizeof(*(ctxt.fdiag))));
#line 570
    ctxt.fdiag = (lin *)tmp___5;
#line 571
    ctxt.bdiag = ctxt.fdiag + diags;
#line 572
    ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1L;
#line 573
    ctxt.bdiag += cmp->file[1].nondiscarded_lines + 1L;
#line 575
    ctxt.heuristic = speed_large_files;
#line 579
    too_expensive = (lin )1;
    }
    {
#line 580
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 580
      if (! (diags != 0L)) {
#line 580
        goto while_break___2;
      }
#line 581
      too_expensive <<= 1;
#line 580
      diags >>= 2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 582
    if (256L >= too_expensive) {
#line 582
      ctxt.too_expensive = (lin )256;
    } else {
#line 582
      ctxt.too_expensive = too_expensive;
    }
    {
#line 584
    files[0] = cmp->file[0];
#line 585
    files[1] = cmp->file[1];
#line 587
    compareseq((lin )0, cmp->file[0].nondiscarded_lines, (lin )0, cmp->file[1].nondiscarded_lines,
               minimal, & ctxt);
#line 590
    free((void *)(ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1L)));
#line 595
    shift_boundaries(cmp->file);
    }
#line 600
    if ((unsigned int )output_style == 4U) {
      {
#line 601
      script = build_reverse_script((struct file_data  const  *)(cmp->file));
      }
    } else {
      {
#line 603
      script = build_script((struct file_data  const  *)(cmp->file));
      }
    }
#line 607
    if (ignore_blank_lines) {
#line 607
      goto _L___2;
    } else
#line 607
    if (ignore_regexp.fastmap) {
      _L___2: /* CIL Label */ 
#line 609
      next = script;
#line 610
      changes = 0;
      {
#line 612
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 612
        if (next) {
#line 612
          if (! (changes == 0)) {
#line 612
            goto while_break___3;
          }
        } else {
#line 612
          goto while_break___3;
        }
        {
#line 618
        this = next;
#line 619
        end = find_change(next);
#line 623
        next = end->link;
#line 624
        end->link = (struct change *)0;
#line 627
        tmp___6 = analyze_hunk(this, & first0, & last0, & first1, & last1);
        }
#line 627
        if (tmp___6) {
#line 628
          changes = 1;
        }
#line 631
        end->link = next;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 635
      changes = (unsigned long )script != (unsigned long )((struct change *)0);
    }
#line 637
    if (brief) {
      {
#line 638
      changes = briefly_report(changes, (struct file_data  const  *)(cmp->file));
      }
    } else
#line 641
    if (changes) {
#line 641
      goto _L___3;
    } else
#line 641
    if (! no_diff_means_no_output) {
      _L___3: /* CIL Label */ 
#line 645
      if (file_label[1]) {
#line 645
        tmp___7 = (char const   *)file_label[1];
      } else {
#line 645
        tmp___7 = cmp->file[1].name;
      }
#line 645
      if (file_label[0]) {
#line 645
        tmp___8 = (char const   *)file_label[0];
      } else {
#line 645
        tmp___8 = cmp->file[0].name;
      }
      {
#line 645
      setup_output(tmp___8, tmp___7, (_Bool )((unsigned long )cmp->parent != (unsigned long )((struct comparison  const  *)0)));
      }
      {
#line 651
      if ((unsigned int )output_style == 2U) {
#line 651
        goto case_2;
      }
#line 655
      if ((unsigned int )output_style == 3U) {
#line 655
        goto case_3;
      }
#line 659
      if ((unsigned int )output_style == 4U) {
#line 659
        goto case_4;
      }
#line 663
      if ((unsigned int )output_style == 5U) {
#line 663
        goto case_5;
      }
#line 667
      if ((unsigned int )output_style == 6U) {
#line 667
        goto case_6;
      }
#line 671
      if ((unsigned int )output_style == 1U) {
#line 671
        goto case_1;
      }
#line 675
      if ((unsigned int )output_style == 7U) {
#line 675
        goto case_7;
      }
#line 679
      if ((unsigned int )output_style == 8U) {
#line 679
        goto case_8;
      }
#line 683
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 652
      print_context_script(script, (_Bool)0);
      }
#line 653
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 656
      print_context_script(script, (_Bool)1);
      }
#line 657
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 660
      print_ed_script(script);
      }
#line 661
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 664
      pr_forward_ed_script(script);
      }
#line 665
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 668
      print_rcs_script(script);
      }
#line 669
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 672
      print_normal_script(script);
      }
#line 673
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 676
      print_ifdef_script(script);
      }
#line 677
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 680
      print_sdiff_script(script);
      }
#line 681
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 684
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 687
      finish_output();
      }
    }
    {
#line 691
    free((void *)cmp->file[0].undiscarded);
#line 693
    free((void *)flag_space);
#line 695
    f = 0;
    }
    {
#line 695
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 695
      if (! (f < 2)) {
#line 695
        goto while_break___4;
      }
      {
#line 697
      free((void *)cmp->file[f].equivs);
#line 698
      free((void *)(cmp->file[f].linbuf + cmp->file[f].linbuf_base));
#line 695
      f ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 701
    e = script;
    {
#line 701
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 701
      if (! e) {
#line 701
        goto while_break___5;
      }
      {
#line 703
      p = e->link;
#line 704
      free((void *)e);
#line 701
      e = p;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 707
    if ((unsigned int )output_style != 4U) {
#line 707
      if (! ((unsigned int )output_style != 5U)) {
#line 707
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 708
      f = 0;
      {
#line 708
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 708
        if (! (f < 2)) {
#line 708
          goto while_break___6;
        }
#line 709
        if (cmp->file[f].missing_newline) {
          {
#line 711
          tmp___9 = gettext("No newline at end of file");
          }
#line 711
          if (file_label[f]) {
#line 711
            tmp___10 = (char const   *)file_label[f];
          } else {
#line 711
            tmp___10 = cmp->file[f].name;
          }
          {
#line 711
          error(0, 0, "%s: %s\n", tmp___10, tmp___9);
#line 714
          changes = 2;
          }
        }
#line 708
        f ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  }
#line 718
  if ((unsigned long )cmp->file[0].buffer != (unsigned long )cmp->file[1].buffer) {
    {
#line 719
    free((void *)cmp->file[0].buffer);
    }
  }
  {
#line 720
  free((void *)cmp->file[1].buffer);
  }
#line 722
  return (changes);
}
}
