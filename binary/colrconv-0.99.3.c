/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 849
extern char *getlogin(void) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 581 "/usr/include/curses.h"
extern int beep(void) ;
#line 587
extern int cbreak(void) ;
#line 606
extern int doupdate(void) ;
#line 608
extern int echo(void) ;
#line 611
extern int endwin(void) ;
#line 622
extern _Bool has_colors(void) ;
#line 627
extern int idlok(WINDOW * , _Bool  ) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 651
extern int meta(WINDOW * , _Bool  ) ;
#line 705
extern WINDOW *newpad(int  , int  ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 709
extern int nocbreak(void) ;
#line 710
extern int nodelay(WINDOW * , _Bool  ) ;
#line 711
extern int noecho(void) ;
#line 721
extern int pnoutrefresh(WINDOW * , int  , int  , int  , int  , int  , int  ) ;
#line 741
extern int scrollok(WINDOW * , _Bool  ) ;
#line 764
extern int start_color(void) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 806
extern int wdelch(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 814
extern chtype winch(WINDOW * ) ;
#line 818
extern int winsch(WINDOW * , chtype  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 825
extern int wnoutrefresh(WINDOW * ) ;
#line 826
extern int wprintw(WINDOW * , char const   *  , ...) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1384
extern WINDOW *curscr ;
#line 1386
extern WINDOW *stdscr ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static int getcall(char *rxptr ) ;
#line 47
static int my_wdelch(WINDOW *win ) ;
#line 48
static int my_waddch(WINDOW *win , chtype c , int ins ) ;
#line 49
static int my_wmove(WINDOW *win , int dir ) ;
#line 50
static void ins_char(char *buf , char *ptr , char c ) ;
#line 51
static void del_char(char *buf , char *ptr ) ;
#line 52
static void status(int stat , char const   *host , int port , int offset , int lines ) ;
#line 53
static int my_wclear(WINDOW *win___0 ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static char *Version  =    (char *)"ColrConv v0.99.3";
#line 57 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static int HasColors  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static int NoColor  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static char *Channel  =    (char *)((void *)0);
#line 60 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static char *Name  =    (char *)((void *)0);
#line 65 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
chtype ibm_map[32]  = 
#line 65
  {      (chtype )199,      (chtype )252,      (chtype )233,      (chtype )226, 
        (chtype )228,      (chtype )224,      (chtype )229,      (chtype )231, 
        (chtype )234,      (chtype )235,      (chtype )232,      (chtype )239, 
        (chtype )238,      (chtype )236,      (chtype )196,      (chtype )197, 
        (chtype )201,      (chtype )230,      (chtype )198,      (chtype )244, 
        (chtype )246,      (chtype )242,      (chtype )251,      (chtype )249, 
        (chtype )255,      (chtype )214,      (chtype )220,      (chtype )162, 
        (chtype )163,      (chtype )165,      (chtype )32,      (chtype )32};
#line 76 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int recvretval ;
  char rxbuff[1024] ;
  char *rxptr ;
  char *txptr ;
  char *txbuff ;
  struct servent *service ;
  struct hostent *hp ;
  struct hostent dummy ;
  struct timeval timeout___0 ;
  fd_set read_fdset ;
  struct sockaddr_in serv_addr ;
  int sockfd ;
  WINDOW *rxwin ;
  WINDOW *txwin ;
  int x ;
  int y ;
  int offset ;
  int nblines ;
  int rxcolor ;
  char *killbuff ;
  char *cp ;
  int nextarg ;
  FILE *f ;
  char ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  uint16_t tmp___8 ;
  int tmp___9 ;
  uint16_t tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int __d0 ;
  int __d1 ;
  int *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  ssize_t tmp___24 ;
  int *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  uint16_t tmp___30 ;
  int tmp___31 ;

  {
  {
#line 78
  c = -1;
#line 81
  rxptr = rxbuff;
#line 91
  y = 0;
#line 92
  offset = 0;
#line 93
  nblines = 0;
#line 94
  rxcolor = 0;
#line 102
  Name = getlogin();
#line 104
  nextarg = 1;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (argc > 1) {
#line 105
      if (! ((int )*(*(argv + nextarg)) == 45)) {
#line 105
        goto while_break;
      }
    } else {
#line 105
      goto while_break;
    }
    {
#line 106
    tmp___1 = strcmp((char const   *)*(argv + nextarg), "-n");
    }
#line 106
    if (tmp___1) {
      {
#line 109
      tmp___0 = strcmp((char const   *)*(argv + nextarg), "-c");
      }
#line 109
      if (tmp___0) {
        {
#line 112
        tmp = strcmp((char const   *)*(argv + nextarg), "-nocolor");
        }
#line 112
        if (! tmp) {
#line 113
          NoColor = 1;
        }
      } else {
#line 110
        nextarg ++;
#line 110
        Channel = *(argv + nextarg);
#line 111
        argc --;
      }
    } else {
#line 107
      nextarg ++;
#line 107
      Name = *(argv + nextarg);
#line 108
      argc --;
    }
#line 115
    argc --;
#line 116
    nextarg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if (argc < 2) {
    {
#line 120
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: colrconv [-nocolor] [-n<name> [-c<channel>]] <host> [service]\n");
#line 121
    exit(1);
    }
  }
  {
#line 124
  initscr();
#line 126
  tmp___2 = has_colors();
  }
#line 126
  if ((int )tmp___2 == 1) {
#line 126
    if (! NoColor) {
      {
#line 127
      HasColors = 1;
#line 128
      start_color();
#line 129
      init_pair((short)1, (short)2, (short)0);
#line 130
      init_pair((short)2, (short)3, (short)0);
#line 131
      init_pair((short)3, (short)6, (short)0);
#line 132
      init_pair((short)4, (short)5, (short)0);
#line 133
      init_pair((short)5, (short)4, (short)0);
#line 134
      init_pair((short)6, (short)1, (short)0);
#line 135
      init_pair((short)7, (short)7, (short)4);
#line 136
      init_pair((short)8, (short)7, (short)2);
      }
    }
  }
  {
#line 139
  tmp___3 = malloc((size_t )(3 * COLS + 2));
#line 139
  killbuff = (char *)tmp___3;
  }
#line 139
  if ((unsigned long )killbuff == (unsigned long )((void *)0)) {
    {
#line 140
    endwin();
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"colrconv: malloc failed\n");
#line 142
    exit(1);
    }
  }
  {
#line 144
  *killbuff = (char)0;
#line 145
  tmp___4 = malloc((size_t )(3 * COLS + 2));
#line 145
  txbuff = (char *)tmp___4;
  }
#line 145
  if ((unsigned long )txbuff == (unsigned long )((void *)0)) {
    {
#line 146
    endwin();
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"colrconv: malloc failed\n");
#line 148
    exit(1);
    }
  }
  {
#line 150
  txptr = txbuff;
#line 152
  wrefresh(stdscr);
#line 153
  cbreak();
#line 154
  noecho();
#line 156
  rxwin = newpad(1000, COLS);
#line 157
  txwin = newwin(3, COLS, (LINES - 3) - 1, 0);
  }
#line 158
  if (rxwin) {
#line 158
    rxwin->_attrs = (attr_t )0;
  }
  {
#line 159
  scrollok(rxwin, (_Bool)1);
#line 160
  idlok(rxwin, (_Bool)1);
  }
#line 162
  if (txwin) {
#line 162
    txwin->_attrs = (attr_t )0;
  }
#line 163
  if (HasColors) {
    {
#line 164
    wattr_on(txwin, (1UL << 21) | (8UL << 8), (void *)0);
    }
  } else {
    {
#line 166
    wattr_on(txwin, 1UL << 18, (void *)0);
    }
  }
  {
#line 167
  my_wclear(txwin);
#line 168
  wrefresh(txwin);
#line 172
  bzero((void *)((char *)(& serv_addr)), sizeof(serv_addr));
#line 174
  serv_addr.sin_family = (sa_family_t )2;
#line 175
  tmp___5 = __ctype_b_loc();
  }
#line 175
  if ((int const   )*(*tmp___5 + (int )*(*(argv + nextarg) + 0)) & 2048) {
    {
#line 176
    serv_addr.sin_addr.s_addr = inet_addr((char const   *)*(argv + nextarg));
#line 177
    hp = & dummy;
#line 178
    hp->h_name = (char *)"";
    }
  } else {
    {
#line 180
    status(1, (char const   *)*(argv + nextarg), 0, 0, 0);
#line 181
    doupdate();
#line 182
    hp = gethostbyname((char const   *)*(argv + nextarg));
    }
#line 182
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {
#line 183
      echo();
#line 184
      nocbreak();
#line 185
      endwin();
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ncolrconv: Unable to resolve name %s\n",
              *(argv + nextarg));
#line 187
      free((void *)txbuff);
#line 188
      free((void *)killbuff);
#line 189
      exit(1);
      }
    }
    {
#line 191
    memcpy((void */* __restrict  */)(& serv_addr.sin_addr.s_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
           (size_t )4);
    }
  }
#line 194
  nextarg ++;
#line 195
  if (argc <= 2) {
    {
#line 196
    serv_addr.sin_port = htons((uint16_t )3600);
    }
  } else {
    {
#line 198
    tmp___7 = __ctype_b_loc();
    }
#line 198
    if ((int const   )*(*tmp___7 + (int )*(*(argv + nextarg) + 0)) & 2048) {
      {
#line 199
      tmp___6 = atoi((char const   *)*(argv + nextarg));
#line 199
      serv_addr.sin_port = htons((uint16_t )tmp___6);
      }
    } else {
      {
#line 201
      service = getservbyname((char const   *)*(argv + nextarg), "tcp");
      }
#line 201
      if ((unsigned long )service != (unsigned long )((void *)0)) {
#line 202
        serv_addr.sin_port = (in_port_t )service->s_port;
      } else {
        {
#line 204
        echo();
#line 205
        nocbreak();
#line 206
        endwin();
#line 207
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ncolrconv: Unknown service %s\n",
                *(argv + nextarg));
#line 208
        free((void *)txbuff);
#line 209
        free((void *)killbuff);
#line 210
        exit(1);
        }
      }
    }
  }
  {
#line 214
  tmp___8 = ntohs(serv_addr.sin_port);
#line 214
  status(2, (char const   *)hp->h_name, (int )tmp___8, 0, 0);
#line 215
  doupdate();
#line 218
  sockfd = socket(2, 1, 0);
  }
#line 218
  if (sockfd < 0) {
    {
#line 219
    echo();
#line 220
    nocbreak();
#line 221
    endwin();
#line 222
    perror("colrconv: Can\'t open socket");
#line 223
    free((void *)txbuff);
#line 224
    free((void *)killbuff);
#line 225
    exit(1);
    }
  }
  {
#line 229
  tmp___9 = connect(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                    (socklen_t )sizeof(serv_addr));
  }
#line 229
  if (tmp___9 < 0) {
    {
#line 230
    echo();
#line 231
    nocbreak();
#line 232
    endwin();
#line 233
    perror("colrconv: Can\'t connect");
#line 234
    free((void *)txbuff);
#line 235
    free((void *)killbuff);
#line 236
    exit(1);
    }
  }
  {
#line 238
  tmp___10 = ntohs(serv_addr.sin_port);
#line 238
  status(3, (char const   *)hp->h_name, (int )tmp___10, 0, 0);
#line 239
  doupdate();
  }
#line 241
  if ((unsigned long )Name != (unsigned long )((void *)0)) {
#line 242
    if ((unsigned long )Channel != (unsigned long )((void *)0)) {
#line 242
      tmp___11 = (char const   *)Channel;
    } else {
#line 242
      tmp___11 = "";
    }
    {
#line 242
    sprintf((char */* __restrict  */)txbuff, (char const   */* __restrict  */)"/n %s %s\n",
            Name, tmp___11);
#line 243
    cp = txbuff;
    }
    {
#line 244
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 244
      if (! *cp) {
#line 244
        goto while_break___0;
      }
      {
#line 245
      my_waddch(rxwin, (unsigned long )((int )*cp & 255) | (1UL << 21), 0);
#line 246
      cp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 248
    tmp___12 = strlen((char const   *)txbuff);
#line 248
    send(sockfd, (void const   *)txbuff, tmp___12, 0);
#line 249
    *txbuff = (char)0;
    }
  }
  {
#line 254
  tmp___13 = getenv("HOME");
#line 254
  sprintf((char */* __restrict  */)txbuff, (char const   */* __restrict  */)"%s/.conversrc",
          tmp___13);
#line 255
  tmp___16 = access((char const   *)txbuff, 4);
  }
#line 255
  if (! tmp___16) {
    {
#line 256
    f = fopen((char const   */* __restrict  */)txbuff, (char const   */* __restrict  */)"r");
    }
#line 256
    if (f) {
      {
#line 257
      *txbuff = (char)0;
#line 258
      fgets((char */* __restrict  */)txbuff, 3 * COLS, (FILE */* __restrict  */)f);
      }
      {
#line 258
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 258
        tmp___15 = feof(f);
        }
#line 258
        if (tmp___15) {
#line 258
          goto while_break___1;
        }
#line 259
        cp = txbuff;
        {
#line 260
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 260
          if (! *cp) {
#line 260
            goto while_break___2;
          }
          {
#line 261
          my_waddch(rxwin, (unsigned long )((int )*cp & 255) | (1UL << 21), 0);
#line 262
          cp ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 264
        tmp___14 = strlen((char const   *)txbuff);
#line 264
        send(sockfd, (void const   *)txbuff, tmp___14, 0);
#line 265
        *txbuff = (char)0;
#line 258
        fgets((char */* __restrict  */)txbuff, 3 * COLS, (FILE */* __restrict  */)f);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 267
      fclose(f);
      }
    }
  }
  {
#line 270
  *txbuff = (char)0;
#line 273
  tmp___17 = fcntl(sockfd, 4, 2048);
  }
#line 273
  if (tmp___17 == -1) {
    {
#line 274
    echo();
#line 275
    nocbreak();
#line 276
    endwin();
#line 277
    perror("colrconv: fcntl error - sockfd");
#line 278
    free((void *)txbuff);
#line 279
    free((void *)killbuff);
#line 280
    exit(1);
    }
  }
  {
#line 282
  keypad(stdscr, (_Bool)1);
#line 283
  meta(stdscr, (_Bool)1);
  }
  {
#line 285
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 287
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 287
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_fdset.__fds_bits[0]): "memory");
#line 287
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 288
    read_fdset.__fds_bits[sockfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sockfd % (8 * (int )sizeof(__fd_mask ));
#line 289
    read_fdset.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 290
    timeout___0.tv_sec = (__time_t )1;
#line 291
    timeout___0.tv_usec = (__suseconds_t )0;
#line 293
    tmp___19 = select(sockfd + 1, (fd_set */* __restrict  */)(& read_fdset), (fd_set */* __restrict  */)0,
                      (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& timeout___0));
    }
#line 293
    if (tmp___19 == -1) {
      {
#line 294
      tmp___18 = __errno_location();
      }
#line 294
      if (*tmp___18 != 4) {
        {
#line 295
        echo();
#line 296
        nocbreak();
#line 297
        endwin();
#line 298
        perror("colrconv: Select error");
#line 299
        close(sockfd);
#line 300
        free((void *)txbuff);
#line 301
        free((void *)killbuff);
#line 302
        exit(1);
        }
      }
    }
    {
#line 306
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 306
      tmp___24 = recv(sockfd, (void *)(& ch), (size_t )1, 0);
#line 306
      recvretval = (int )tmp___24;
      }
#line 306
      if (! (recvretval != -1)) {
#line 306
        goto while_break___5;
      }
#line 307
      c = (int )ch;
#line 309
      if (recvretval == 0) {
        {
#line 310
        echo();
#line 311
        nocbreak();
#line 312
        endwin();
#line 313
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ncolrconv: Connection closed by foreign host\n");
#line 314
        close(sockfd);
#line 315
        free((void *)txbuff);
#line 316
        free((void *)killbuff);
#line 317
        exit(0);
        }
      }
      {
#line 320
      if ((c & 255) == 13) {
#line 320
        goto case_13;
      }
#line 322
      if ((c & 255) == 10) {
#line 322
        goto case_10;
      }
#line 374
      if ((c & 255) == 7) {
#line 374
        goto case_7;
      }
#line 381
      goto switch_default;
      case_13: /* CIL Label */ 
#line 321
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 323
      rxptr = rxbuff;
#line 324
      tmp___21 = strncmp((char const   *)rxptr, "*** ", (size_t )4);
      }
#line 324
      if (tmp___21) {
        {
#line 324
        tmp___22 = strncmp((char const   *)rxptr, "<*", (size_t )2);
        }
#line 324
        if (tmp___22) {
#line 352
          if ((int )*rxptr == 60) {
#line 352
            if (HasColors) {
              {
#line 353
              rxcolor = getcall(rxptr);
              }
#line 354
              if (rxcolor > 6) {
                {
#line 355
                rxcolor -= 6;
#line 356
                wattr_on(rxwin, 1UL << 21, (void *)0);
                }
              } else {
                {
#line 359
                wattr_off(rxwin, 1UL << 21, (void *)0);
                }
              }
            } else {
#line 352
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 361
            tmp___20 = strncmp((char const   *)rxptr, "   ", (size_t )3);
            }
#line 361
            if (tmp___20) {
              {
#line 362
              rxcolor = 0;
#line 363
              wattr_off(rxwin, 1UL << 21, (void *)0);
              }
            }
          }
        } else
        _L___0: /* CIL Label */ 
#line 325
        if (HasColors) {
          {
#line 326
          rxcolor = 6;
#line 327
          wattr_on(rxwin, 1UL << 21, (void *)0);
          }
        }
      } else {
#line 324
        goto _L___0;
      }
      {
#line 365
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 365
        if (! *rxptr) {
#line 365
          goto while_break___6;
        }
        {
#line 366
        my_waddch(rxwin, (unsigned long )((int )*rxptr & 255) | ((chtype )rxcolor << 8),
                  0);
#line 367
        rxptr ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 369
      waddch(rxwin, (chtype const   )'\n');
#line 370
      rxptr = rxbuff;
#line 371
      *rxptr = (char)0;
      }
#line 373
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 378
      beep();
      }
#line 380
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 382
      c &= 255;
#line 383
      tmp___23 = rxptr;
#line 383
      rxptr ++;
#line 383
      if (c > 127) {
#line 383
        if (c < 160) {
#line 383
          *tmp___23 = (char )ibm_map[c - 128];
        } else {
#line 383
          *tmp___23 = (char )c;
        }
      } else {
#line 383
        *tmp___23 = (char )c;
      }
#line 384
      *rxptr = (char)0;
#line 385
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 388
    tmp___25 = __errno_location();
    }
#line 388
    if (*tmp___25 != 11) {
      {
#line 389
      echo();
#line 390
      nocbreak();
#line 391
      close(sockfd);
#line 392
      endwin();
#line 393
      perror("\ncolrconv");
#line 394
      free((void *)txbuff);
#line 395
      free((void *)killbuff);
#line 396
      exit(1);
      }
    }
    {
#line 398
    nodelay(stdscr, (_Bool)1);
    }
    {
#line 399
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 399
      c = wgetch(stdscr);
      }
#line 399
      if (! (c != -1)) {
#line 399
        goto while_break___7;
      }
      {
#line 401
      if (c == 12) {
#line 401
        goto case_12;
      }
#line 404
      if (c == 1) {
#line 404
        goto case_1;
      }
#line 410
      if (c == 5) {
#line 410
        goto case_5;
      }
#line 417
      if (c == 260) {
#line 417
        goto case_260;
      }
#line 417
      if (c == 2) {
#line 417
        goto case_260;
      }
#line 424
      if (c == 261) {
#line 424
        goto case_261;
      }
#line 424
      if (c == 6) {
#line 424
        goto case_261;
      }
#line 431
      if (c == 259) {
#line 431
        goto case_259;
      }
#line 431
      if (c == 16) {
#line 431
        goto case_259;
      }
#line 439
      if (c == 258) {
#line 439
        goto case_258;
      }
#line 439
      if (c == 14) {
#line 439
        goto case_258;
      }
#line 445
      if (c == 339) {
#line 445
        goto case_339;
      }
#line 449
      if (c == 338) {
#line 449
        goto case_338;
      }
#line 453
      if (c == 262) {
#line 453
        goto case_262;
      }
#line 457
      if (c == 360) {
#line 457
        goto case_360;
      }
#line 460
      if (c == 18) {
#line 460
        goto case_18;
      }
#line 468
      if (c == 23) {
#line 468
        goto case_23;
      }
#line 480
      if (c == 21) {
#line 480
        goto case_21;
      }
#line 485
      if (c == 11) {
#line 485
        goto case_11;
      }
#line 493
      if (c == 25) {
#line 493
        goto case_25;
      }
#line 502
      if (c == 10) {
#line 502
        goto case_10___0;
      }
#line 519
      if (c == 4) {
#line 519
        goto case_4;
      }
#line 527
      if (c == 263) {
#line 527
        goto case_263;
      }
#line 527
      if (c == 127) {
#line 527
        goto case_263;
      }
#line 534
      goto switch_default___0;
      case_12: /* CIL Label */ 
      {
#line 402
      wrefresh(curscr);
      }
#line 403
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 405
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 405
        if (! ((unsigned long )txptr > (unsigned long )txbuff)) {
#line 405
          goto while_break___8;
        }
        {
#line 406
        txptr --;
#line 407
        my_wmove(txwin, -1);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 409
      goto switch_break___0;
      case_5: /* CIL Label */ 
      {
#line 411
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 411
        if (! ((int )*txptr != 0)) {
#line 411
          goto while_break___9;
        }
        {
#line 412
        txptr ++;
#line 413
        my_wmove(txwin, 1);
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 415
      goto switch_break___0;
      case_260: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 418
      if ((unsigned long )txptr > (unsigned long )txbuff) {
        {
#line 419
        txptr --;
#line 420
        my_wmove(txwin, -1);
        }
      }
#line 422
      goto switch_break___0;
      case_261: /* CIL Label */ 
      case_6: /* CIL Label */ 
#line 425
      if ((int )*txptr != 0) {
        {
#line 426
        txptr ++;
#line 427
        my_wmove(txwin, 1);
        }
      }
#line 429
      goto switch_break___0;
      case_259: /* CIL Label */ 
      case_16: /* CIL Label */ 
#line 432
      if (rxwin) {
#line 432
        y = (int )rxwin->_cury;
      } else {
#line 432
        y = -1;
      }
#line 432
      if (rxwin) {
#line 432
        x = (int )rxwin->_curx;
      } else {
#line 432
        x = -1;
      }
#line 433
      if ((y - offset) - (((LINES - 3) - 1) - 1) > 0) {
#line 434
        offset ++;
      } else {
        {
#line 436
        beep();
        }
      }
#line 437
      goto switch_break___0;
      case_258: /* CIL Label */ 
      case_14: /* CIL Label */ 
#line 440
      if (offset > 0) {
#line 441
        offset --;
      } else {
        {
#line 443
        beep();
        }
      }
#line 444
      goto switch_break___0;
      case_339: /* CIL Label */ 
#line 446
      offset += ((LINES - 3) - 1) - 1;
#line 447
      if ((y - offset) - (((LINES - 3) - 1) - 1) < 0) {
#line 447
        offset = y - (((LINES - 3) - 1) - 1);
      } else {
#line 447
        offset = offset;
      }
#line 448
      goto switch_break___0;
      case_338: /* CIL Label */ 
#line 450
      offset -= ((LINES - 3) - 1) - 1;
#line 451
      if (offset < 0) {
#line 451
        offset = 0;
      } else {
#line 451
        offset = offset;
      }
#line 452
      goto switch_break___0;
      case_262: /* CIL Label */ 
#line 454
      if (rxwin) {
#line 454
        y = (int )rxwin->_cury;
      } else {
#line 454
        y = -1;
      }
#line 454
      if (rxwin) {
#line 454
        x = (int )rxwin->_curx;
      } else {
#line 454
        x = -1;
      }
#line 455
      offset = y - (((LINES - 3) - 1) - 1);
#line 456
      goto switch_break___0;
      case_360: /* CIL Label */ 
#line 458
      offset = 0;
#line 459
      goto switch_break___0;
      case_18: /* CIL Label */ 
      {
#line 461
      my_wclear(txwin);
#line 462
      txptr = txbuff;
      }
      {
#line 463
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 463
        if (! *txptr) {
#line 463
          goto while_break___10;
        }
        {
#line 464
        my_waddch(txwin, (chtype )((int )*txptr & 255), 0);
#line 465
        txptr ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 467
      goto switch_break___0;
      case_23: /* CIL Label */ 
      {
#line 469
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 469
        if ((unsigned long )txptr != (unsigned long )txbuff) {
#line 469
          if (! ((int )*(txptr - 1) != 32)) {
#line 469
            goto while_break___11;
          }
        } else {
#line 469
          goto while_break___11;
        }
        {
#line 470
        txptr --;
#line 471
        del_char(txbuff, txptr);
#line 472
        my_wdelch(txwin);
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 474
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 474
        if ((unsigned long )txptr != (unsigned long )txbuff) {
#line 474
          if (! ((int )*(txptr - 1) == 32)) {
#line 474
            goto while_break___12;
          }
        } else {
#line 474
          goto while_break___12;
        }
        {
#line 475
        txptr --;
#line 476
        del_char(txbuff, txptr);
#line 477
        my_wdelch(txwin);
        }
      }
      while_break___12: /* CIL Label */ ;
      }
#line 479
      goto switch_break___0;
      case_21: /* CIL Label */ 
      {
#line 481
      txptr = txbuff;
#line 482
      *txptr = (char)0;
#line 483
      my_wclear(txwin);
      }
#line 484
      goto switch_break___0;
      case_11: /* CIL Label */ 
      {
#line 486
      strcpy((char */* __restrict  */)killbuff, (char const   */* __restrict  */)txptr);
      }
      {
#line 487
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 487
        if (! ((int )*txptr != 0)) {
#line 487
          goto while_break___13;
        }
        {
#line 488
        del_char(txbuff, txptr);
#line 489
        my_wmove(txwin, 1);
#line 490
        my_wdelch(txwin);
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 492
      goto switch_break___0;
      case_25: /* CIL Label */ 
#line 494
      cp = killbuff;
      {
#line 495
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 495
        if ((int )*cp != 0) {
          {
#line 495
          tmp___26 = strlen((char const   *)txbuff);
          }
#line 495
          if (! (tmp___26 < (size_t )(3 * COLS - 1))) {
#line 495
            goto while_break___14;
          }
        } else {
#line 495
          goto while_break___14;
        }
        {
#line 496
        my_waddch(txwin, (chtype )((int )*cp & 255), 1);
#line 497
        ins_char(txbuff, txptr, (char )((int )*cp & 255));
#line 498
        txptr ++;
#line 499
        cp ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 501
      goto switch_break___0;
      case_10___0: /* CIL Label */ 
      {
#line 504
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 504
        if (! ((int )*txptr != 0)) {
#line 504
          goto while_break___15;
        }
#line 505
        txptr ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 506
      ins_char(txbuff, txptr, (char )(c & 255));
#line 507
      cp = txbuff;
      }
      {
#line 508
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 508
        if (! *cp) {
#line 508
          goto while_break___16;
        }
        {
#line 509
        my_waddch(rxwin, (unsigned long )((int )*cp & 255) | (1UL << 21), 0);
#line 510
        cp ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 512
      tmp___27 = strlen((char const   *)txbuff);
#line 512
      send(sockfd, (void const   *)txbuff, tmp___27, 0);
#line 513
      my_wclear(txwin);
#line 514
      txptr = txbuff;
#line 515
      *txptr = (char)0;
#line 516
      nblines ++;
      }
#line 517
      if (nblines > 1000) {
#line 517
        nblines = 1000;
      } else {
#line 517
        nblines = nblines;
      }
#line 518
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 520
      if ((int )*txptr != 0) {
        {
#line 521
        my_wmove(txwin, 1);
#line 522
        my_wdelch(txwin);
#line 523
        del_char(txbuff, txptr);
        }
      }
#line 525
      goto switch_break___0;
      case_263: /* CIL Label */ 
      case_127: /* CIL Label */ 
#line 528
      if ((unsigned long )txptr != (unsigned long )txbuff) {
        {
#line 529
        txptr --;
#line 530
        my_wdelch(txwin);
#line 531
        del_char(txbuff, txptr);
        }
      }
#line 533
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 535
      if (! (c & 65280)) {
        {
#line 536
        tmp___28 = strlen((char const   *)txbuff);
        }
#line 536
        if (tmp___28 < (size_t )(3 * COLS - 1)) {
#line 537
          if ((int )*txptr != 0) {
            {
#line 538
            my_waddch(txwin, (chtype )(c & 255), 1);
            }
          } else {
            {
#line 540
            my_waddch(txwin, (chtype )(c & 255), 0);
            }
          }
          {
#line 541
          ins_char(txbuff, txptr, (char )(c & 255));
#line 542
          txptr ++;
          }
        } else {
          {
#line 544
          beep();
          }
        }
      }
#line 546
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 549
    nodelay(stdscr, (_Bool)0);
    }
#line 550
    if (rxwin) {
#line 550
      y = (int )rxwin->_cury;
    } else {
#line 550
      y = -1;
    }
#line 550
    if (rxwin) {
#line 550
      x = (int )rxwin->_curx;
    } else {
#line 550
      x = -1;
    }
    {
#line 551
    tmp___29 = pnoutrefresh(rxwin, (y - offset) - (((LINES - 3) - 1) - 1), 0, 1, 0,
                            ((LINES - 3) - 1) - 1, COLS - 1);
    }
#line 551
    if (tmp___29 == -1) {
      {
#line 553
      printf((char const   */* __restrict  */)"***prefresh failed***\n");
      }
    }
    {
#line 554
    tmp___30 = ntohs(serv_addr.sin_port);
#line 554
    status(3, (char const   *)hp->h_name, (int )tmp___30, offset, y);
#line 555
    tmp___31 = wnoutrefresh(txwin);
    }
#line 555
    if (tmp___31 == -1) {
      {
#line 556
      printf((char const   */* __restrict  */)"***wrefresh failed***\n");
      }
    }
    {
#line 557
    doupdate();
    }
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 586
static int getcall(char *rxptr ) ;
#line 586 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static int nextcall  =    0;
#line 587 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static char callsign[100][30]  ;
#line 584 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static int getcall(char *rxptr ) 
{ 
  int i ;
  char *endofcall ;
  int tmp ;

  {
  {
#line 591
  endofcall = strchr((char const   *)rxptr, '>');
  }
#line 591
  if ((unsigned long )endofcall == (unsigned long )((void *)0)) {
#line 592
    return (0);
  }
#line 593
  *endofcall = (char)0;
#line 595
  i = 0;
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    if (! (i < nextcall)) {
#line 595
      goto while_break;
    }
    {
#line 596
    tmp = strcmp((char const   *)(callsign[i]), (char const   *)rxptr);
    }
#line 596
    if (! tmp) {
#line 597
      goto while_break;
    }
#line 595
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  if (i == nextcall) {
#line 599
    if (nextcall < 99) {
      {
#line 600
      strcpy((char */* __restrict  */)(callsign[nextcall]), (char const   */* __restrict  */)rxptr);
#line 601
      nextcall ++;
      }
    }
  }
#line 609
  *endofcall = (char )'>';
#line 610
  return (i % 11 + 1);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static int my_wdelch(WINDOW *win ) 
{ 
  chtype c ;
  int x ;
  int y ;
  int savex ;
  int savey ;

  {
  {
#line 621
  my_wmove(win, -1);
#line 622
  wdelch(win);
  }
#line 623
  if (win) {
#line 623
    y = (int )win->_cury;
  } else {
#line 623
    y = -1;
  }
#line 623
  if (win) {
#line 623
    x = (int )win->_curx;
  } else {
#line 623
    x = -1;
  }
#line 624
  savex = x;
#line 625
  savey = y;
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    if (! (y < (int )win->_maxy)) {
#line 626
      goto while_break;
    }
    {
#line 627
    y ++;
#line 628
    wmove(win, y, 0);
#line 629
    c = winch(win);
#line 630
    wdelch(win);
#line 631
    y --;
#line 632
    wmove(win, y, (int )win->_maxx);
#line 633
    winsch(win, c);
#line 634
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 636
  wmove(win, savey, savex);
  }
#line 637
  return (0);
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static int my_waddch(WINDOW *win , chtype c , int ins ) 
{ 
  chtype ch ;
  int x ;
  int y ;
  int savex ;
  int savey ;
  int tmp ;

  {
#line 645
  if ((c & 255UL) != 10UL) {
#line 646
    if ((c & 255UL) < 32UL) {
#line 646
      c = (c + 64UL) | (1UL << 18);
    } else {
#line 646
      c = c;
    }
  }
#line 647
  if (! ins) {
    {
#line 648
    tmp = waddch(win, (chtype const   )c);
    }
#line 648
    return (tmp);
  } else {
#line 650
    if (win) {
#line 650
      y = (int )win->_cury;
    } else {
#line 650
      y = -1;
    }
#line 650
    if (win) {
#line 650
      x = (int )win->_curx;
    } else {
#line 650
      x = -1;
    }
#line 651
    savey = y;
#line 652
    savex = x;
#line 653
    y = (int )win->_maxy;
    {
#line 654
    while (1) {
      while_continue: /* CIL Label */ ;
#line 654
      if (! (y > savey)) {
#line 654
        goto while_break;
      }
      {
#line 655
      y --;
#line 656
      wmove(win, y, (int )win->_maxx);
#line 657
      ch = winch(win);
#line 658
      wdelch(win);
#line 659
      y ++;
#line 660
      wmove(win, y, 0);
#line 661
      winsch(win, ch);
#line 662
      y --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 664
    wmove(win, savey, savex);
#line 665
    winsch(win, c);
#line 666
    my_wmove(win, 1);
    }
  }
#line 668
  return (0);
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static int my_wmove(WINDOW *win , int dir ) 
{ 
  int x ;
  int y ;
  int tmp ;

  {
#line 675
  if (win) {
#line 675
    y = (int )win->_cury;
  } else {
#line 675
    y = -1;
  }
#line 675
  if (win) {
#line 675
    x = (int )win->_curx;
  } else {
#line 675
    x = -1;
  }
#line 676
  if (dir > 0) {
#line 677
    x ++;
#line 677
    if (x > COLS - 1) {
#line 678
      x = 0;
#line 679
      y ++;
    }
  } else {
#line 682
    x --;
#line 682
    if (x < 0) {
#line 683
      x = COLS - 1;
#line 684
      y --;
    }
  }
  {
#line 687
  tmp = wmove(win, y, x);
  }
#line 687
  return (tmp);
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static void ins_char(char *buf , char *ptr , char c ) 
{ 
  char *cp ;
  size_t tmp ;

  {
  {
#line 694
  tmp = strlen((char const   *)buf);
#line 694
  cp = buf + tmp;
  }
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! ((unsigned long )cp >= (unsigned long )ptr)) {
#line 695
      goto while_break;
    }
#line 696
    *(cp + 1) = *cp;
#line 697
    cp --;
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  *ptr = c;
#line 700
  return;
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static void del_char(char *buf , char *ptr ) 
{ 
  char *cp ;
  char tmp ;

  {
#line 706
  cp = ptr;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    tmp = *(cp + 1);
#line 707
    *cp = tmp;
#line 707
    if (! ((int )tmp != 0)) {
#line 707
      goto while_break;
    }
#line 708
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return;
}
}
#line 715
static void status(int stat , char const   *host , int port , int offset , int lines ) ;
#line 715 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static WINDOW *win  =    (WINDOW *)((void *)0);
#line 711 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static void status(int stat , char const   *host , int port , int offset , int lines ) 
{ 
  char pos[10] ;
  char line[80] ;
  char *cp ;
  struct tm *t ;
  time_t tim ;
  int x ;
  int y ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 714
  cp = (char *)((void *)0);
#line 720
  if (! win) {
    {
#line 721
    win = newwin(1, COLS, 0, 0);
    }
#line 722
    if (win) {
#line 722
      win->_attrs = (attr_t )0;
    }
#line 723
    if (HasColors) {
      {
#line 724
      wattr_on(win, (1UL << 21) | (7UL << 8), (void *)0);
      }
    } else {
      {
#line 726
      wattr_on(win, 1UL << 18, (void *)0);
      }
    }
  }
  {
#line 729
  if (stat == 1) {
#line 729
    goto case_1;
  }
#line 732
  if (stat == 2) {
#line 732
    goto case_2;
  }
#line 735
  if (stat == 3) {
#line 735
    goto case_3;
  }
#line 728
  goto switch_break;
  case_1: /* CIL Label */ 
#line 730
  cp = (char *)"Resolving";
#line 731
  goto switch_break;
  case_2: /* CIL Label */ 
#line 733
  cp = (char *)"Connecting to";
#line 734
  goto switch_break;
  case_3: /* CIL Label */ 
#line 736
  cp = (char *)"Connected to";
#line 737
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 739
  if (lines < (LINES - 3) - 1) {
    {
#line 740
    strcpy((char */* __restrict  */)(pos), (char const   */* __restrict  */)"All");
    }
  } else
#line 742
  if (offset == 0) {
    {
#line 743
    strcpy((char */* __restrict  */)(pos), (char const   */* __restrict  */)"Bot");
    }
  } else
#line 745
  if ((lines - offset) - (((LINES - 3) - 1) - 1) < 1) {
    {
#line 746
    strcpy((char */* __restrict  */)(pos), (char const   */* __restrict  */)"Top");
    }
  } else {
    {
#line 748
    sprintf((char */* __restrict  */)(pos), (char const   */* __restrict  */)"%d",
            lines - offset);
    }
  }
  {
#line 751
  time(& tim);
#line 752
  t = localtime((time_t const   *)(& tim));
#line 753
  sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%s --- %s/%d --- %02d:%02d --- %s",
          Version, pos, lines, t->tm_hour, t->tm_min, cp);
#line 755
  cp = strdup(host);
#line 756
  sprintf((char */* __restrict  */)(pos), (char const   */* __restrict  */)"%d", port);
#line 757
  tmp = strlen((char const   *)(line));
#line 757
  tmp___0 = strlen((char const   *)(pos));
#line 757
  x = (int )((((size_t )COLS - tmp) - tmp___0) - 4UL);
#line 758
  tmp___1 = strlen(host);
  }
#line 758
  if ((size_t )x < tmp___1) {
#line 759
    *(cp + x) = (char)0;
#line 760
    x --;
#line 760
    *(cp + x) = (char )'.';
#line 761
    x --;
#line 761
    *(cp + x) = (char )'.';
  }
  {
#line 763
  wmove(win, 0, 0);
#line 764
  wprintw(win, "%s %s:%s ", line, cp, pos);
  }
#line 765
  if (win) {
#line 765
    y = (int )win->_cury;
  } else {
#line 765
    y = -1;
  }
#line 765
  if (win) {
#line 765
    x = (int )win->_curx;
  } else {
#line 765
    x = -1;
  }
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    tmp___2 = x;
#line 766
    x ++;
#line 766
    if (! (tmp___2 <= (int )win->_maxx)) {
#line 766
      goto while_break;
    }
    {
#line 767
    waddch(win, (chtype const   )'-');
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 768
  wnoutrefresh(win);
  }
#line 769
  return;
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/colrconv-0.99.3/colrconv.c"
static int my_wclear(WINDOW *win___0 ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 775
  wmove(win___0, 0, 0);
#line 776
  i = ((int )win___0->_maxx + 1) * ((int )win___0->_maxy + 1);
  }
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    tmp = i;
#line 777
    i --;
#line 777
    if (! (tmp >= 0)) {
#line 777
      goto while_break;
    }
    {
#line 778
    waddch(win___0, (chtype const   )' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 779
  wmove(win___0, 0, 0);
  }
#line 783
  return (0);
}
}
