/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 36 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
struct hive {
   unsigned char *base ;
};
#line 41 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
struct _nk_hdr {
   short id ;
   short type ;
   int t1 ;
   int t2 ;
   int unk1 ;
   int parent_off ;
   int subkey_num ;
   int unk2 ;
   int lf_off ;
   int unk3 ;
   int value_cnt ;
   int value_off ;
   int sk_off ;
   int classname_off ;
   int unk4[4] ;
   int unk5 ;
   short name_len ;
   short classname_len ;
   unsigned char *key_name ;
};
#line 41 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
typedef struct _nk_hdr nk_hdr;
#line 63 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
struct _hashrecord {
   int nk_offset ;
   char keyname[4] ;
};
#line 63 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
typedef struct _hashrecord hashrecord;
#line 70 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
struct _lf_hdr {
   short id ;
   short key_num ;
   unsigned char *hr ;
};
#line 70 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
typedef struct _lf_hdr lf_hdr;
#line 77 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
struct _vk_hdr {
   short id ;
   short name_len ;
   int data_len ;
   int data_off ;
   int data_type ;
   short flag ;
   short unk1 ;
   unsigned char *value_name ;
};
#line 77 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
typedef struct _vk_hdr vk_hdr;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 99 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
unsigned char *read_data(struct hive *h , int offset ) ;
#line 102
void _RegCloseHive(struct hive *h ) ;
#line 104
void _InitHive(struct hive *h ) ;
#line 106
int _RegOpenHive(char *filename , struct hive *h ) ;
#line 110
int _RegGetRootKey(struct hive *h , char **root_key ) ;
#line 112
int _RegOpenKey(struct hive *h , char *path , nk_hdr **nr ) ;
#line 114
int _RegQueryValue(struct hive *h , char *name , nk_hdr *nr , unsigned char **buff ,
                   int *len ) ;
#line 39 "/home/june/collector/temp/bkhive-1.1.1/bkhive.c"
int main(int argc , char **argv ) 
{ 
  FILE *f ;
  struct hive h ;
  nk_hdr *n ;
  unsigned char *b ;
  int i ;
  int j ;
  int buf_len ;
  int control ;
  char *kn[4] ;
  char kv[9] ;
  unsigned char *buf ;
  char *keyname ;
  char *root_key ;
  char *regselect ;
  char *reglsa ;
  unsigned char key[16] ;
  unsigned char pkey[16] ;
  int p[16] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 45
  n = (nk_hdr *)((void *)0);
#line 50
  kn[0] = (char *)"JD";
#line 50
  kn[1] = (char *)"Skew1";
#line 50
  kn[2] = (char *)"GBG";
#line 50
  kn[3] = (char *)"Data";
#line 52
  buf = (unsigned char *)((void *)0);
#line 61
  p[0] = 11;
#line 61
  p[1] = 6;
#line 61
  p[2] = 7;
#line 61
  p[3] = 1;
#line 61
  p[4] = 8;
#line 61
  p[5] = 10;
#line 61
  p[6] = 14;
#line 61
  p[7] = 0;
#line 61
  p[8] = 3;
#line 61
  p[9] = 5;
#line 61
  p[10] = 2;
#line 61
  p[11] = 15;
#line 61
  p[12] = 13;
#line 61
  p[13] = 9;
#line 61
  p[14] = 12;
#line 61
  p[15] = 4;
#line 66
  printf((char const   */* __restrict  */)"bkhive 1.1.1 by Objectif Securite\nhttp://www.objectif-securite.ch\noriginal author: ncuomo@studenti.unina.it\n\n");
  }
#line 68
  if (argc != 3) {
    {
#line 69
    printf((char const   */* __restrict  */)"Usage:\nbkhive systemhive keyfile\n");
    }
#line 70
    return (-1);
  }
  {
#line 74
  _InitHive(& h);
#line 77
  tmp = _RegOpenHive(*(argv + 1), & h);
  }
#line 77
  if (tmp) {
    {
#line 78
    printf((char const   */* __restrict  */)"Error opening hive file %s\n", *(argv + 1));
    }
#line 79
    return (-1);
  }
  {
#line 85
  tmp___0 = _RegGetRootKey(& h, & root_key);
  }
#line 85
  if (tmp___0) {
    {
#line 86
    printf((char const   */* __restrict  */)"Error reading hive root key\n");
    }
#line 87
    return (-1);
  }
  {
#line 89
  printf((char const   */* __restrict  */)"Root Key : %s\n", root_key);
#line 91
  tmp___1 = strlen((char const   *)root_key);
#line 91
  tmp___2 = malloc(tmp___1 + 10UL);
#line 91
  regselect = (char *)tmp___2;
#line 92
  tmp___3 = strlen((char const   *)root_key);
#line 92
  tmp___4 = malloc(tmp___3 + 33UL);
#line 92
  reglsa = (char *)tmp___4;
#line 94
  sprintf((char */* __restrict  */)regselect, (char const   */* __restrict  */)"%s\\Select",
          root_key);
#line 97
  tmp___5 = malloc(sizeof(nk_hdr ));
#line 97
  n = (nk_hdr *)tmp___5;
#line 99
  tmp___7 = _RegOpenKey(& h, regselect, & n);
  }
#line 99
  if (tmp___7) {
    {
#line 114
    printf((char const   */* __restrict  */)"Error reading ControlSet: _RegOpenKey\n");
    }
#line 115
    return (-1);
  } else {
    {
#line 100
    tmp___6 = _RegQueryValue(& h, (char *)"Default", n, & buf, & buf_len);
    }
#line 100
    if (tmp___6) {
      {
#line 110
      printf((char const   */* __restrict  */)"Error reading ControlSet: _RegQueryValue\n");
      }
#line 111
      return (-1);
    } else {
#line 101
      if (buf_len == 4) {
#line 102
        control = *((int *)buf);
      } else {
#line 104
        control = 1;
      }
      {
#line 106
      sprintf((char */* __restrict  */)reglsa, (char const   */* __restrict  */)"%s\\ControlSet%03d\\Control\\Lsa\\",
              root_key, control);
#line 107
      printf((char const   */* __restrict  */)"Default ControlSet: %03d\n", control);
#line 107
      fflush(stdout);
      }
    }
  }
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < 4)) {
#line 120
      goto while_break;
    }
    {
#line 121
    tmp___8 = strlen((char const   *)reglsa);
#line 121
    tmp___9 = strlen((char const   *)kn[i]);
#line 121
    tmp___10 = malloc((tmp___8 + tmp___9) + 1UL);
#line 121
    keyname = (char *)tmp___10;
#line 122
    sprintf((char */* __restrict  */)keyname, (char const   */* __restrict  */)"%s%s",
            reglsa, kn[i]);
#line 128
    tmp___11 = _RegOpenKey(& h, keyname, & n);
    }
#line 128
    if (tmp___11) {
      {
#line 129
      _RegCloseHive(& h);
#line 131
      printf((char const   */* __restrict  */)"Error accessing key %s\nWrong/corrupted hive??\n",
             kn[i]);
      }
#line 132
      return (-1);
    }
    {
#line 136
    b = read_data(& h, n->classname_off + 4096);
#line 142
    j = 0;
    }
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if (j < (int )n->classname_len) {
#line 142
        if (! (j < 9)) {
#line 142
          goto while_break___0;
        }
      } else {
#line 142
        goto while_break___0;
      }
#line 143
      kv[j] = (char )*(b + j * 2);
#line 142
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 144
    kv[8] = (char)0;
#line 145
    sscanf((char const   */* __restrict  */)(kv), (char const   */* __restrict  */)"%x",
           (int *)(& key[i * 4]));
#line 147
    free((void *)keyname);
#line 120
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  _RegCloseHive(& h);
#line 161
  printf((char const   */* __restrict  */)"Bootkey: ");
#line 163
  i = 0;
  }
  {
#line 163
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 163
    if (! (i < 16)) {
#line 163
      goto while_break___1;
    }
    {
#line 165
    pkey[i] = key[p[i]];
#line 166
    printf((char const   */* __restrict  */)"%.2x", (int )pkey[i]);
#line 163
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 169
  printf((char const   */* __restrict  */)"\n");
#line 172
  f = fopen((char const   */* __restrict  */)*(argv + 2), (char const   */* __restrict  */)"wb");
  }
#line 172
  if ((unsigned long )f != (unsigned long )((void *)0)) {
    {
#line 173
    fwrite((void const   */* __restrict  */)(pkey), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
#line 174
    fclose(f);
    }
  } else {
    {
#line 177
    printf((char const   */* __restrict  */)"error writing to %s\n", *(argv + 2));
    }
  }
  {
#line 179
  free((void *)n);
  }
#line 180
  return (0);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 94 "/home/june/collector/temp/bkhive-1.1.1/hive.h"
nk_hdr *read_nk(nk_hdr *nk , struct hive *h , int offset ) ;
#line 95
lf_hdr *read_lf(lf_hdr *lf , struct hive *h , int offset ) ;
#line 96
vk_hdr *read_vk(vk_hdr *vk , struct hive *h , int offset ) ;
#line 97
hashrecord *read_hr(hashrecord *hr , unsigned char *pos , int index___0 ) ;
#line 98
int *read_valuelist(int *value , struct hive *h , int offset , int size ) ;
#line 108
long parself(struct hive *h , char *t , unsigned long off ) ;
#line 116
int _RegEnumKey(struct hive *h , nk_hdr *nr , int index___0 , char *name , int *namelen ) ;
#line 43 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
nk_hdr *read_nk(nk_hdr *nk , struct hive *h , int offset ) 
{ 


  {
  {
#line 44
  memcpy((void */* __restrict  */)nk, (void const   */* __restrict  */)((h->base + offset) + 4),
         sizeof(nk_hdr ));
#line 45
  nk->key_name = ((h->base + offset) + 4) + 76;
  }
#line 59
  return (nk);
}
}
#line 62 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
lf_hdr *read_lf(lf_hdr *lf , struct hive *h , int offset ) 
{ 


  {
  {
#line 63
  memcpy((void */* __restrict  */)lf, (void const   */* __restrict  */)((h->base + offset) + 4),
         sizeof(lf_hdr ));
#line 64
  lf->hr = ((h->base + offset) + 4) + 4;
  }
#line 70
  return (lf);
}
}
#line 73 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
vk_hdr *read_vk(vk_hdr *vk , struct hive *h , int offset ) 
{ 


  {
  {
#line 74
  memcpy((void */* __restrict  */)vk, (void const   */* __restrict  */)((h->base + offset) + 4),
         sizeof(vk_hdr ));
#line 75
  vk->value_name = ((h->base + offset) + 4) + 20;
  }
#line 85
  return (vk);
}
}
#line 88 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
int *read_valuelist(int *value , struct hive *h , int offset , int size ) 
{ 
  int i ;

  {
  {
#line 89
  i = 0;
#line 90
  memcpy((void */* __restrict  */)value, (void const   */* __restrict  */)((h->base + offset) + 4),
         (unsigned long )size * sizeof(int ));
  }
#line 96
  return (value);
}
}
#line 99 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
hashrecord *read_hr(hashrecord *hr , unsigned char *pos , int index___0 ) 
{ 


  {
  {
#line 100
  pos += 8 * index___0;
#line 101
  memcpy((void */* __restrict  */)hr, (void const   */* __restrict  */)pos, sizeof(hashrecord ));
  }
#line 106
  return (hr);
}
}
#line 110 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
unsigned char *read_data(struct hive *h , int offset ) 
{ 


  {
#line 111
  return ((h->base + offset) + 4);
}
}
#line 115 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
void _RegCloseHive(struct hive *h ) 
{ 


  {
#line 116
  if ((unsigned long )h->base != (unsigned long )((void *)0)) {
    {
#line 117
    free((void *)h->base);
    }
  }
#line 118
  return;
}
}
#line 121 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
void _InitHive(struct hive *h ) 
{ 


  {
#line 122
  h->base = (unsigned char *)((void *)0);
#line 123
  return;
}
}
#line 126 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
int _RegOpenHive(char *filename , struct hive *h ) 
{ 
  FILE *hiveh ;
  unsigned long hsize ;
  long tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 131
  hiveh = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 131
  if ((unsigned long )hiveh != (unsigned long )((void *)0)) {
    {
#line 132
    tmp___2 = fseek(hiveh, 0L, 2);
    }
#line 132
    if (tmp___2 == 0) {
      {
#line 133
      tmp = ftell(hiveh);
#line 133
      hsize = (unsigned long )tmp;
#line 137
      tmp___0 = malloc(hsize);
#line 137
      h->base = (unsigned char *)tmp___0;
#line 139
      fseek(hiveh, 0L, 0);
#line 141
      tmp___1 = fread((void */* __restrict  */)((void *)h->base), hsize, (size_t )1,
                      (FILE */* __restrict  */)hiveh);
      }
#line 141
      if (tmp___1 == 1UL) {
#line 143
        if (*((int *)h->base) == 1718052210) {
          {
#line 144
          fclose(hiveh);
          }
#line 145
          return (0);
        }
      }
    }
    {
#line 155
    fclose(hiveh);
    }
  }
#line 157
  return (-1);
}
}
#line 160 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
long parself(struct hive *h , char *t , unsigned long off ) 
{ 
  nk_hdr *n ;
  lf_hdr *l ;
  hashrecord *hr ;
  long res ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 168
  tmp = malloc(sizeof(hashrecord ));
#line 168
  hr = (hashrecord *)tmp;
#line 169
  tmp___0 = malloc(sizeof(nk_hdr ));
#line 169
  n = (nk_hdr *)tmp___0;
#line 170
  tmp___1 = malloc(sizeof(lf_hdr ));
#line 170
  l = (lf_hdr *)tmp___1;
#line 171
  l = read_lf(l, h, (int )off);
#line 176
  i = 0;
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < (int )l->key_num)) {
#line 176
      goto while_break;
    }
    {
#line 177
    hr = read_hr(hr, l->hr, i);
#line 178
    n = read_nk(n, h, hr->nk_offset + 4096);
#line 183
    tmp___2 = memcmp((void const   *)t, (void const   *)n->key_name, (size_t )n->name_len);
    }
#line 183
    if (! tmp___2) {
      {
#line 183
      tmp___3 = strlen((char const   *)t);
      }
#line 183
      if (tmp___3 == (size_t )n->name_len) {
        {
#line 184
        res = (long )hr->nk_offset;
#line 185
        free((void *)n);
#line 186
        free((void *)l);
        }
#line 187
        return (res);
      }
    }
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  free((void *)n);
#line 191
  free((void *)l);
  }
#line 192
  return (-1L);
}
}
#line 195 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
int _RegGetRootKey(struct hive *h , char **root_key ) 
{ 
  nk_hdr *n ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 198
  tmp = malloc(sizeof(nk_hdr ));
#line 198
  n = (nk_hdr *)tmp;
#line 199
  n = read_nk(n, h, 4128);
  }
#line 205
  if ((int )n->id == 27502) {
#line 205
    if ((int )n->type == 44) {
      {
#line 206
      tmp___0 = malloc((size_t )((int )n->name_len + 1));
#line 206
      *root_key = (char *)tmp___0;
#line 207
      strncpy((char */* __restrict  */)*root_key, (char const   */* __restrict  */)n->key_name,
              (size_t )n->name_len);
#line 208
      *(*root_key + n->name_len) = (char)0;
#line 209
      free((void *)n);
      }
#line 210
      return (0);
    }
  }
  {
#line 212
  free((void *)n);
  }
#line 213
  return (-1);
}
}
#line 216 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
int _RegOpenKey(struct hive *h , char *path , nk_hdr **nr ) 
{ 
  nk_hdr *n ;
  char *t ;
  char *tpath ;
  unsigned long noff ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 221
  tmp = malloc(sizeof(nk_hdr ));
#line 221
  n = (nk_hdr *)tmp;
#line 222
  n = read_nk(n, h, 4128);
  }
#line 227
  if ((int )n->id == 27502) {
#line 227
    if ((int )n->type == 44) {
      {
#line 228
      tpath = strdup((char const   *)path);
#line 229
      t = strtok((char */* __restrict  */)tpath, (char const   */* __restrict  */)"\\");
#line 233
      tmp___1 = memcmp((void const   *)t, (void const   *)n->key_name, (size_t )n->name_len);
      }
#line 233
      if (! tmp___1) {
        {
#line 234
        t = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\\");
        }
        {
#line 238
        while (1) {
          while_continue: /* CIL Label */ ;
#line 238
          if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 238
            goto while_break;
          }
          {
#line 239
          tmp___0 = parself(h, t, (unsigned long )(n->lf_off + 4096));
#line 239
          noff = (unsigned long )tmp___0;
          }
#line 239
          if (noff == 0xffffffffffffffffUL) {
            {
#line 240
            free((void *)n);
            }
#line 241
            return (-1);
          }
          {
#line 243
          n = read_nk(n, h, (int )(noff + 4096UL));
#line 244
          t = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\\");
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 249
        memcpy((void */* __restrict  */)*nr, (void const   */* __restrict  */)n, sizeof(nk_hdr ));
#line 250
        free((void *)n);
        }
#line 251
        return (0);
      }
      {
#line 253
      free((void *)tpath);
      }
    }
  }
  {
#line 255
  free((void *)n);
  }
#line 256
  return (-1);
}
}
#line 259 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
int _RegQueryValue(struct hive *h , char *name , nk_hdr *nr , unsigned char **buff ,
                   int *len ) 
{ 
  vk_hdr *v ;
  unsigned int i ;
  int *l ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 264
  tmp = malloc(sizeof(vk_hdr ));
#line 264
  v = (vk_hdr *)tmp;
#line 265
  tmp___0 = malloc(sizeof(int ) * (unsigned long )nr->value_cnt);
#line 265
  l = (int *)tmp___0;
#line 266
  l = read_valuelist(l, h, nr->value_off + 4096, nr->value_cnt);
#line 268
  *len = 0;
#line 270
  i = 0U;
  }
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (i < (unsigned int )nr->value_cnt)) {
#line 270
      goto while_break;
    }
    {
#line 271
    v = read_vk(v, h, *(l + i) + 4096);
#line 272
    tmp___3 = strlen((char const   *)name);
#line 272
    tmp___4 = memcmp((void const   *)name, (void const   *)v->value_name, tmp___3);
    }
#line 272
    if (tmp___4) {
#line 272
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 272
        if (((int )v->flag & 1) == 0) {
          _L: /* CIL Label */ 
#line 276
          *len = v->data_len & 65535;
#line 277
          if ((unsigned long )*buff != (unsigned long )((void *)0)) {
            {
#line 278
            free((void *)*buff);
            }
          }
          {
#line 279
          tmp___1 = malloc((size_t )*len);
#line 279
          *buff = (unsigned char *)tmp___1;
          }
#line 280
          if (*len < 5) {
            {
#line 281
            memcpy((void */* __restrict  */)*buff, (void const   */* __restrict  */)(& v->data_off),
                   (size_t )*len);
            }
          } else {
            {
#line 284
            tmp___2 = read_data(h, v->data_off + 4096);
#line 284
            memcpy((void */* __restrict  */)*buff, (void const   */* __restrict  */)tmp___2,
                   (size_t )*len);
            }
          }
          {
#line 292
          free((void *)v);
          }
#line 293
          return (0);
        }
      }
    } else {
#line 272
      goto _L;
    }
#line 270
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 296
  free((void *)v);
  }
#line 297
  return (-1);
}
}
#line 300 "/home/june/collector/temp/bkhive-1.1.1/hive.c"
int _RegEnumKey(struct hive *h , nk_hdr *nr , int index___0 , char *name , int *namelen ) 
{ 
  lf_hdr *lf ;
  nk_hdr *nk ;
  hashrecord *hr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 305
  tmp = malloc(sizeof(lf_hdr ));
#line 305
  lf = (lf_hdr *)tmp;
#line 306
  tmp___0 = malloc(sizeof(nk_hdr ));
#line 306
  nk = (nk_hdr *)tmp___0;
#line 307
  tmp___1 = malloc(sizeof(hashrecord ));
#line 307
  hr = (hashrecord *)tmp___1;
  }
#line 312
  if (index___0 < nr->subkey_num) {
    {
#line 313
    lf = read_lf(lf, h, nr->lf_off + 4096);
#line 314
    hr = read_hr(hr, lf->hr, index___0);
#line 315
    nk = read_nk(nk, h, hr->nk_offset + 4096);
    }
#line 316
    if (*namelen < (int )nk->name_len) {
#line 316
      tmp___2 = *namelen;
    } else {
#line 316
      tmp___2 = (int )nk->name_len;
    }
    {
#line 316
    memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)nk->key_name,
           (size_t )tmp___2);
    }
#line 317
    if (*namelen < (int )nk->name_len) {
#line 317
      tmp___3 = *namelen;
    } else {
#line 317
      tmp___3 = (int )nk->name_len;
    }
    {
#line 317
    *(name + tmp___3) = (char)0;
#line 318
    *namelen = (int )nk->name_len;
#line 319
    free((void *)lf);
    }
#line 320
    if (index___0 + 1 < nr->subkey_num) {
#line 320
      tmp___4 = index___0 + 1;
    } else {
#line 320
      tmp___4 = -1;
    }
#line 320
    return (tmp___4);
  }
  {
#line 322
  free((void *)lf);
  }
#line 323
  return (-1);
}
}
