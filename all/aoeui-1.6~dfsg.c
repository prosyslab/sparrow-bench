/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 7 "/home/june/collector/temp/aoeui-1.6~dfsg/types.h"
typedef unsigned int Unicode_t;
#line 8 "/home/june/collector/temp/aoeui-1.6~dfsg/types.h"
typedef unsigned char Byte_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_4 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_4 __sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_20 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_21 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_22 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_23 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_24 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_25 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_26 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_19 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_20 _kill ;
   struct __anonstruct__timer_21 _timer ;
   struct __anonstruct__rt_22 _rt ;
   struct __anonstruct__sigchld_23 _sigchld ;
   struct __anonstruct__sigfault_24 _sigfault ;
   struct __anonstruct__sigpoll_25 _sigpoll ;
   struct __anonstruct__sigsys_26 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_18 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_19 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_18 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_38 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_38 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 9 "/home/june/collector/temp/aoeui-1.6~dfsg/types.h"
enum Boolean_t {
    FALSE = 0,
    TRUE = 1
} ;
#line 9 "/home/june/collector/temp/aoeui-1.6~dfsg/types.h"
typedef enum Boolean_t Boolean_t;
#line 5 "/home/june/collector/temp/aoeui-1.6~dfsg/rgba.h"
typedef unsigned int rgba_t;
#line 9 "/home/june/collector/temp/aoeui-1.6~dfsg/display.h"
struct display;
#line 52 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
struct cell {
   Unicode_t unicode ;
   rgba_t fgrgba ;
   rgba_t bgrgba ;
};
#line 57
enum cursor_position_knowledge {
    NEEDED = 0,
    SOUGHT = 1,
    KNOWN = 2,
    INVALID = 3
} ;
#line 61 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
struct display {
   int rows ;
   int columns ;
   int cursor_row ;
   int cursor_column ;
   rgba_t cursor_rgba ;
   Boolean_t size_changed ;
   rgba_t fgrgba ;
   rgba_t bgrgba ;
   int at_row ;
   int at_column ;
   enum cursor_position_knowledge get_initial_cursor_position ;
   int initial_row ;
   int initial_column ;
   struct cell *image ;
   struct display *next ;
   Byte_t inbuf[64] ;
   char outbuf[1024] ;
   size_t inbuf_bytes ;
   size_t outbuf_bytes ;
   Boolean_t is_xterm ;
   Boolean_t is_linux ;
   Boolean_t is_apple ;
   rgba_t color[8] ;
   unsigned int colors ;
   char *title ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 10 "/home/june/collector/temp/aoeui-1.6~dfsg/types.h"
typedef size_t position_t;
#line 11 "/home/june/collector/temp/aoeui-1.6~dfsg/types.h"
typedef ssize_t sposition_t;
#line 12 "/home/june/collector/temp/aoeui-1.6~dfsg/types.h"
typedef int fd_t;
#line 7 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.h"
struct buffer;
#line 22 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.h"
struct buffer {
   char *data ;
   size_t payload ;
   size_t mapped ;
   position_t gap ;
   fd_t fd ;
   char *path ;
};
#line 9 "/home/june/collector/temp/aoeui-1.6~dfsg/locus.h"
typedef unsigned int locus_t;
#line 19
struct view;
#line 7 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
struct undo;
#line 7
struct keywords;
#line 7 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
struct text {
   struct text *next ;
   struct view *views ;
   char *clean ;
   size_t clean_bytes ;
   fd_t fd ;
   struct buffer *buffer ;
   struct undo *undo ;
   char *path ;
   unsigned int dirties ;
   unsigned int preserved ;
   time_t mtime ;
   unsigned int tabstop ;
   struct keywords *keywords ;
   sposition_t (*comment_start)(struct view * , position_t  ) ;
   sposition_t (*comment_end)(struct view * , position_t  ) ;
   sposition_t (*string_end)(struct view * , position_t  ) ;
   char const   *brackets ;
   unsigned int foldings ;
   unsigned int flags ;
};
#line 37
struct window;
#line 37
struct mode;
#line 37 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
struct goal_column {
   position_t cursor ;
   unsigned int row ;
   unsigned int column ;
};
#line 37 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
struct view {
   struct view *next ;
   struct text *text ;
   struct window *window ;
   char *name ;
   position_t start ;
   size_t bytes ;
   unsigned int loci ;
   position_t *locus ;
   struct mode *mode ;
   fd_t shell_std_in ;
   locus_t shell_out_locus ;
   pid_t shell_pg ;
   struct goal_column goal ;
};
#line 56 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
struct keywords {
   int count ;
   char const   **word ;
};
#line 9 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.h"
struct mode {
   void (*command)(struct view * , Unicode_t  ) ;
   rgba_t selection_bgrgba ;
};
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
struct edit {
   position_t offset ;
   ssize_t bytes ;
};
#line 9 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
struct undo {
   struct buffer *edits ;
   struct buffer *deleted ;
   position_t redo ;
   position_t saved ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_5 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_5 fd_set;
#line 16 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
struct stream;
#line 20 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
struct stream {
   struct stream *next ;
   fd_t fd ;
   Boolean_t retain ;
   Boolean_t (*activity)(struct stream * , char *received , ssize_t bytes ) ;
   struct view *view ;
   locus_t locus ;
   char const   *data ;
   size_t bytes ;
   size_t writ ;
};
#line 5 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.h"
struct macro;
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
struct macro {
   position_t start ;
   position_t at ;
   size_t bytes ;
   int repeat ;
   struct macro *next ;
   struct macro *suspended ;
};
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/bookmark.c"
struct bookmark {
   unsigned int id ;
   struct view *view ;
   locus_t locus[2] ;
   struct bookmark *next ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 67 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
enum utf8_mode {
    UTF8_NO = 0,
    UTF8_YES = 1,
    UTF8_AUTO = 2
} ;
#line 12 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
struct mode_default {
   void (*command)(struct view * , Unicode_t  ) ;
   rgba_t selection_bgrgba ;
   Boolean_t variant ;
   Boolean_t is_hex ;
   int value ;
};
#line 10 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
struct window {
   struct view *view ;
   locus_t start ;
   int row ;
   int column ;
   int rows ;
   int columns ;
   int cursor_row ;
   int cursor_column ;
   rgba_t fgrgba ;
   rgba_t bgrgba ;
   unsigned int last_dirties ;
   Boolean_t repaint ;
   position_t last_cursor ;
   position_t last_mark ;
   struct mode *last_mode ;
   struct window *next ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 171 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
struct file_keywords {
   char const   *suffix ;
   struct keywords keywords ;
   char const   *brackets ;
   sposition_t (*comment_start)(struct view * , position_t  ) ;
   sposition_t (*comment_end)(struct view * , position_t  ) ;
   sposition_t (*string_end)(struct view * , position_t  ) ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_17 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_17 regmatch_t;
#line 8 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
struct mode_search {
   void (*command)(struct view * , Unicode_t  ) ;
   rgba_t selection_bgrgba ;
   struct mode *previous ;
   Byte_t *pattern ;
   size_t bytes ;
   size_t alloc ;
   size_t last_bytes ;
   Boolean_t backward ;
   position_t start ;
   position_t mark ;
   regex_t *regex ;
   Boolean_t regex_ready ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 5 "/home/june/collector/temp/aoeui-1.6~dfsg/die.h"
void die(char const   *msg  , ...) ;
#line 5 "/home/june/collector/temp/aoeui-1.6~dfsg/mem.h"
void *reallocate(void const   *old , size_t bytes ) ;
#line 7
void *allocate0(size_t bytes ) ;
#line 9 "/home/june/collector/temp/aoeui-1.6~dfsg/mem.c"
void *reallocate(void const   *old , size_t bytes ) 
{ 
  void *new ;
  void *tmp ;

  {
  {
#line 11
  tmp = realloc((void *)old, bytes);
#line 11
  new = tmp;
  }
#line 12
  if (! new) {
#line 12
    if (bytes) {
      {
#line 13
      die("could not allocate %lu bytes", (long )bytes);
      }
    }
  }
#line 14
  return (new);
}
}
#line 17 "/home/june/collector/temp/aoeui-1.6~dfsg/mem.c"
void *allocate0(size_t bytes ) 
{ 
  void *new ;
  void *tmp ;

  {
  {
#line 19
  tmp = reallocate((void const   *)((void *)0), bytes);
#line 19
  new = tmp;
  }
#line 20
  if (new) {
    {
#line 21
    memset(new, 0, bytes);
    }
  }
#line 22
  return (new);
}
}
#line 42 "/home/june/collector/temp/aoeui-1.6~dfsg/utf8.h"
size_t unicode_utf8(char *out___1 , Unicode_t unicode ) ;
#line 43
size_t utf8_length(char const   *in , size_t max ) ;
#line 44
size_t utf8_length_backwards(char const   *in , size_t max ) ;
#line 45
Unicode_t utf8_unicode(char const   *in , size_t length ) ;
#line 55
Byte_t utf8_bytes[256] ;
#line 8 "/home/june/collector/temp/aoeui-1.6~dfsg/utf8.c"
size_t unicode_utf8(char *out___1 , Unicode_t unicode ) 
{ 
  char *p ;
  char *tmp ;
  int n ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 10
  p = out___1;
#line 12
  if (! (unicode >> 7)) {
#line 13
    tmp = p;
#line 13
    p ++;
#line 13
    *tmp = (char )unicode;
  } else {
#line 16
    n = 1;
    {
#line 16
    while (1) {
      while_continue: /* CIL Label */ ;
#line 16
      if (! (n < 5)) {
#line 16
        goto while_break;
      }
#line 17
      if (! (unicode >> (6 + 5 * n))) {
#line 18
        goto while_break;
      }
#line 16
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 19
    tmp___0 = p;
#line 19
    p ++;
#line 19
    *tmp___0 = (char )((unsigned int )(252 << (5 - n)) | (unicode >> 6 * n));
    {
#line 20
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 20
      tmp___2 = n;
#line 20
      n --;
#line 20
      if (! tmp___2) {
#line 20
        goto while_break___0;
      }
#line 21
      tmp___1 = p;
#line 21
      p ++;
#line 21
      *tmp___1 = (char )(128U | ((unicode >> 6 * n) & 63U));
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 24
  return ((size_t )(p - out___1));
}
}
#line 28 "/home/june/collector/temp/aoeui-1.6~dfsg/utf8.c"
Byte_t utf8_bytes[256]  = 
#line 28
  {      (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )1,      (Byte_t )1,      (Byte_t )1,      (Byte_t )1, 
        (Byte_t )2,      (Byte_t )2,      (Byte_t )2,      (Byte_t )2, 
        (Byte_t )2,      (Byte_t )2,      (Byte_t )2,      (Byte_t )2, 
        (Byte_t )2,      (Byte_t )2,      (Byte_t )2,      (Byte_t )2, 
        (Byte_t )2,      (Byte_t )2,      (Byte_t )2,      (Byte_t )2, 
        (Byte_t )2,      (Byte_t )2,      (Byte_t )2,      (Byte_t )2, 
        (Byte_t )2,      (Byte_t )2,      (Byte_t )2,      (Byte_t )2, 
        (Byte_t )2,      (Byte_t )2,      (Byte_t )2,      (Byte_t )2, 
        (Byte_t )2,      (Byte_t )2,      (Byte_t )2,      (Byte_t )2, 
        (Byte_t )3,      (Byte_t )3,      (Byte_t )3,      (Byte_t )3, 
        (Byte_t )3,      (Byte_t )3,      (Byte_t )3,      (Byte_t )3, 
        (Byte_t )3,      (Byte_t )3,      (Byte_t )3,      (Byte_t )3, 
        (Byte_t )3,      (Byte_t )3,      (Byte_t )3,      (Byte_t )3, 
        (Byte_t )4,      (Byte_t )4,      (Byte_t )4,      (Byte_t )4, 
        (Byte_t )4,      (Byte_t )4,      (Byte_t )4,      (Byte_t )4, 
        (Byte_t )5,      (Byte_t )5,      (Byte_t )5,      (Byte_t )5, 
        (Byte_t )6,      (Byte_t )6,      (Byte_t )1,      (Byte_t )1};
#line 67 "/home/june/collector/temp/aoeui-1.6~dfsg/utf8.c"
size_t utf8_length(char const   *in , size_t max ) 
{ 
  Byte_t const   *p ;
  size_t n ;

  {
#line 69
  p = (Byte_t const   *)in;
#line 70
  n = (size_t )utf8_bytes[*p];
#line 72
  if (max > n) {
#line 73
    max = n;
  }
#line 74
  if (max < n) {
#line 75
    return ((size_t )1);
  }
#line 76
  n = (size_t )1;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (n < max)) {
#line 76
      goto while_break;
    }
#line 77
    if (((int const   )*(p + n) & 192) != 128) {
#line 78
      return ((size_t )1);
    }
#line 76
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (max);
}
}
#line 83 "/home/june/collector/temp/aoeui-1.6~dfsg/utf8.c"
size_t utf8_length_backwards(char const   *in , size_t max ) 
{ 
  int n ;
  Byte_t const   *p ;

  {
#line 86
  p = (Byte_t const   *)in;
#line 88
  if (((int const   )*p & 192) != 128) {
#line 89
    return ((size_t )1);
  }
#line 90
  if (max > 6UL) {
#line 91
    max = (size_t )6;
  }
#line 92
  n = 1;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((size_t )n < max)) {
#line 92
      goto while_break;
    }
#line 93
    if (((int const   )*(p + - n) & 192) != 128) {
#line 94
      goto while_break;
    }
#line 92
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if ((int )utf8_bytes[*(p + - n)] == n + 1) {
#line 96
    return ((size_t )(n + 1));
  }
#line 97
  return ((size_t )1);
}
}
#line 101 "/home/june/collector/temp/aoeui-1.6~dfsg/utf8.c"
Unicode_t utf8_unicode(char const   *in , size_t length ) 
{ 
  Byte_t const   *p ;
  Unicode_t unicode ;

  {
#line 103
  p = (Byte_t const   *)in;
#line 106
  if (length <= 1UL) {
#line 107
    return ((Unicode_t )*p);
  } else
#line 106
  if (length > 6UL) {
#line 107
    return ((Unicode_t )*p);
  }
#line 108
  unicode = (Unicode_t )((int const   )*p & (int const   )((1 << (7UL - length)) - 1));
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    length --;
#line 109
    if (! length) {
#line 109
      goto while_break;
    }
#line 110
    unicode <<= 6;
#line 110
    p ++;
#line 110
    unicode |= (unsigned int )((int const   )*p & 63);
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return (unicode);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 70 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 76
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) cfmakeraw)(struct termios *__termios_p ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 7 "/home/june/collector/temp/aoeui-1.6~dfsg/display.h"
struct termios original_termios  ;
#line 11
struct display *display_init(void) ;
#line 12
void display_reset(struct display *display___0 ) ;
#line 13
void display_end(struct display *display___0 ) ;
#line 14
void display_get_geometry(struct display *display___0 , int *rows___0 , int *columns___0 ) ;
#line 15
Boolean_t display_title(struct display *display___0 , char const   *title___0 ) ;
#line 16
void display_cursor(struct display *display___0 , int row , int column ) ;
#line 17
Boolean_t display_cursor_color(struct display *display___0 , rgba_t rgba ) ;
#line 18
void display_put(struct display *display___0 , int row , int column , Unicode_t unicode ,
                 rgba_t fgrgba , rgba_t bgrgba ) ;
#line 20
void display_beep(struct display *display___0 ) ;
#line 21
void display_sync(struct display *display___0 ) ;
#line 28
Unicode_t display_getch(struct display *display___0 , Boolean_t block ) ;
#line 31
void display_erase(struct display *display___0 , int row , int column , int rows___0 ,
                   int columns___0 ) ;
#line 33
void display_insert_spaces(struct display *display___0 , int row , int column , int spaces ,
                           int columns___0 ) ;
#line 35
void display_delete_chars(struct display *display___0 , int row , int column , int chars ,
                          int columns___0 ) ;
#line 37
void display_insert_lines(struct display *display___0 , int row , int column , int lines ,
                          int rows___0 , int columns___0 ) ;
#line 39
void display_delete_lines(struct display *display___0 , int row , int column , int lines ,
                          int rows___0 , int columns___0 ) ;
#line 10 "/home/june/collector/temp/aoeui-1.6~dfsg/child.h"
Boolean_t multiplexor(Boolean_t block ) ;
#line 82 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static struct display *display_list  ;
#line 83 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void (*old_sigwinch)(int  , siginfo_t * , void * )  ;
#line 84 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static FILE *debug_file  ;
#line 86 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void emit(char const   *str , size_t bytes ) 
{ 
  size_t wrote ;
  ssize_t chunk ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 91
  if (debug_file) {
#line 91
    if (bytes) {
      {
#line 92
      fprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)"emit %d:",
              (int )bytes);
#line 93
      fwrite((void const   */* __restrict  */)str, bytes, (size_t )1, (FILE */* __restrict  */)debug_file);
#line 94
      fputc('\n', debug_file);
      }
    }
  }
#line 97
  wrote = (size_t )0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (wrote < bytes)) {
#line 97
      goto while_break;
    }
    {
#line 98
    tmp = __errno_location();
#line 98
    *tmp = 0;
#line 99
    chunk = write(1, (void const   *)(str + wrote), bytes - wrote);
    }
#line 100
    if (chunk < 0L) {
      {
#line 101
      tmp___0 = __errno_location();
      }
#line 101
      if (*tmp___0 == 4) {
#line 102
        goto __Cont;
      } else {
        {
#line 101
        tmp___1 = __errno_location();
        }
#line 101
        if (*tmp___1 == 11) {
#line 102
          goto __Cont;
        }
      }
      {
#line 103
      die("write of %d bytes failed", bytes);
      }
    }
    __Cont: /* CIL Label */ 
#line 97
    wrote += (size_t )chunk;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void flush(struct display *display___0 ) 
{ 


  {
  {
#line 110
  emit((char const   *)(display___0->outbuf), display___0->outbuf_bytes);
#line 111
  display___0->outbuf_bytes = (size_t )0;
  }
#line 112
  return;
}
}
#line 114 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void out(struct display *display___0 , char const   *str , size_t bytes ) 
{ 


  {
#line 116
  if (display___0->outbuf_bytes + bytes > sizeof(display___0->outbuf)) {
    {
#line 117
    flush(display___0);
    }
  }
#line 118
  if (bytes > sizeof(display___0->outbuf)) {
    {
#line 119
    emit(str, bytes);
    }
  } else {
    {
#line 121
    memcpy((void */* __restrict  */)(display___0->outbuf + display___0->outbuf_bytes),
           (void const   */* __restrict  */)str, bytes);
#line 122
    display___0->outbuf_bytes += bytes;
    }
  }
#line 124
  return;
}
}
#line 126 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void outs(struct display *display___0 , char const   *str ) 
{ 
  size_t tmp ;

  {
  {
#line 128
  tmp = strlen(str);
#line 128
  out(display___0, str, tmp);
  }
#line 129
  return;
}
}
#line 131 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void outf(struct display *display___0 , char const   *msg  , ...) 
{ 
  char buf[128] ;
  va_list ap ;

  {
  {
#line 135
  __builtin_va_start(ap, msg);
#line 136
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)msg,
            ap);
#line 137
  __builtin_va_end(ap);
#line 138
  outs(display___0, (char const   *)(buf));
  }
#line 139
  return;
}
}
#line 141 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void force_moveto(struct display *display___0 , int row , int column ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 143
  tmp = column;
#line 143
  display___0->at_column = tmp;
#line 143
  tmp___0 = row;
#line 143
  display___0->at_row = tmp___0;
#line 143
  outf(display___0, "\033[%d;%df", tmp___0 + 1, tmp + 1);
  }
#line 145
  return;
}
}
#line 147 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void moveto(struct display *display___0 , int row , int column ) 
{ 


  {
#line 149
  if (row == display___0->at_row) {
#line 149
    if (column == display___0->at_column) {
#line 150
      return;
    }
  }
#line 151
  if (row == display___0->at_row + 1) {
#line 152
    if (column == display___0->at_column) {
      {
#line 153
      outs(display___0, "\n");
#line 154
      (display___0->at_row) ++;
      }
#line 155
      return;
    }
#line 157
    if (! column) {
      {
#line 158
      outs(display___0, "\n\r");
#line 159
      (display___0->at_row) ++;
#line 160
      display___0->at_column = 0;
      }
#line 161
      return;
    }
  }
  {
#line 164
  force_moveto(display___0, row, column);
  }
#line 165
  return;
}
}
#line 167 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_sync(struct display *display___0 ) 
{ 


  {
  {
#line 169
  moveto(display___0, display___0->cursor_row, display___0->cursor_column);
#line 170
  flush(display___0);
  }
#line 171
  return;
}
}
#line 173 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static unsigned int linux_colormap(rgba_t rgba ) 
{ 
  unsigned int bgr1 ;

  {
#line 176
  if (rgba & 255U) {
#line 177
    return (9U);
  }
#line 178
  bgr1 = (unsigned int )(! (! (rgba >> 24)));
#line 179
  bgr1 |= (unsigned int )(! (! ((rgba >> 16) & 255U)) << 1);
#line 180
  bgr1 |= (unsigned int )(! (! ((rgba >> 8) & 255U)) << 2);
#line 181
  return (bgr1);
}
}
#line 184 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static unsigned int color_delta(rgba_t rgba1 , rgba_t rgba2 ) 
{ 
  unsigned int delta ;
  unsigned int j ;
  Byte_t c1 ;
  Byte_t c2 ;
  int cd ;
  int tmp ;

  {
#line 186
  delta = 1U;
#line 187
  if (rgba1 >> 8 == rgba2 >> 8) {
#line 188
    return (0U);
  }
#line 189
  j = 8U;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (j < 32U)) {
#line 189
      goto while_break;
    }
#line 190
    c1 = (Byte_t )(rgba1 >> j);
#line 190
    c2 = (Byte_t )(rgba2 >> j);
#line 191
    cd = (int )c1 - (int )c2;
#line 192
    if (cd < 0) {
#line 192
      tmp = - cd;
    } else {
#line 192
      tmp = cd;
    }
#line 192
    delta *= (unsigned int )(tmp + 1);
#line 189
    j += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (delta);
}
}
#line 197 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static rgba_t color_mean(rgba_t rgba1 , rgba_t rgba2 ) 
{ 
  rgba_t mean ;
  int j ;
  Byte_t c1 ;
  Byte_t c2 ;

  {
#line 199
  mean = (rgba_t )0;
#line 201
  j = 0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (j < 32)) {
#line 201
      goto while_break;
    }
#line 202
    c1 = (Byte_t )(rgba1 >> j);
#line 202
    c2 = (Byte_t )(rgba2 >> j);
#line 203
    mean |= (unsigned int )((((int )c1 + (int )c2) >> 1) << j);
#line 201
    j += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (mean);
}
}
#line 210
static unsigned int colormap(struct display *display___0 , rgba_t rgba ) ;
#line 210 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static rgba_t basic[8]  = 
#line 210
  {      (rgba_t )0,      2130706432U,      (rgba_t )8323072,      2139029504U, 
        (rgba_t )32512,      2130738944U,      (rgba_t )8355584,      2139062016U};
#line 216 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static rgba_t bright[8]  = 
#line 216
  {      (rgba_t )0,      4278190080U,      (rgba_t )16711680,      4294901760U, 
        (rgba_t )65280,      4278255360U,      (rgba_t )16776960,      4294967040U};
#line 208 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static unsigned int colormap(struct display *display___0 , rgba_t rgba ) 
{ 
  unsigned int idx ;
  unsigned int best ;
  unsigned int bestdelta ;
  unsigned int delta ;
  unsigned int tmp ;

  {
#line 223
  if (rgba & 255U) {
#line 224
    return (9U);
  }
#line 225
  idx = 0U;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (idx < 8U)) {
#line 225
      goto while_break;
    }
#line 226
    if (rgba == basic[idx]) {
#line 227
      return (idx);
    }
#line 225
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  idx = 0U;
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    if (! (idx < 8U)) {
#line 228
      goto while_break___0;
    }
#line 229
    if (rgba == bright[idx]) {
#line 230
      return (idx + 10U);
    }
#line 228
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  idx = 0U;
  {
#line 231
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 231
    if (! (idx < display___0->colors)) {
#line 231
      goto while_break___1;
    }
#line 232
    if (display___0->color[idx] == rgba) {
#line 233
      return (idx + 18U);
    }
#line 231
    idx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 234
  if (idx < 8U) {
#line 235
    tmp = display___0->colors;
#line 235
    (display___0->colors) ++;
#line 235
    best = tmp;
#line 235
    display___0->color[best] = rgba;
  } else {
#line 237
    best = 0U;
#line 238
    bestdelta = (unsigned int )(~ 0);
#line 239
    idx = 0U;
    {
#line 239
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 239
      if (! (idx < display___0->colors)) {
#line 239
        goto while_break___2;
      }
      {
#line 240
      delta = color_delta(display___0->color[idx], rgba);
      }
#line 241
      if (delta < bestdelta) {
#line 242
        best = idx;
#line 243
        bestdelta = delta;
      }
#line 239
      idx ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 246
    display___0->color[best] = color_mean(display___0->color[best], rgba);
    }
  }
  {
#line 248
  best += 18U;
#line 249
  outf(display___0, "\033]4;%d;rgb:%02x/%02x/%02x\a", best, rgba >> 24, (rgba >> 16) & 255U,
       (rgba >> 8) & 255U);
  }
#line 251
  return (best);
}
}
#line 254 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void set_color(struct display *display___0 , rgba_t rgba , unsigned int magic ) 
{ 
  unsigned int tmp ;
  unsigned int c ;
  unsigned int tmp___0 ;

  {
#line 256
  if (display___0->is_linux) {
    {
#line 257
    tmp = linux_colormap(rgba);
#line 257
    outf(display___0, "\033[%dm", tmp + magic);
    }
  } else {
    {
#line 259
    tmp___0 = colormap(display___0, rgba);
#line 259
    c = tmp___0;
    }
#line 260
    if (c >= 18U) {
      {
#line 261
      outf(display___0, "\033[%d;5;%dm", magic + 8U, c);
      }
    } else
#line 262
    if (c >= 10U) {
      {
#line 263
      outf(display___0, "\033[%dm", ((c - 10U) + magic) + 60U);
      }
    } else {
      {
#line 265
      outf(display___0, "\033[%dm", c + magic);
      }
    }
  }
#line 267
  return;
}
}
#line 269 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void background_color(struct display *display___0 , rgba_t rgba ) 
{ 


  {
#line 271
  if (rgba != display___0->bgrgba) {
    {
#line 272
    set_color(display___0, rgba, 40U);
#line 273
    display___0->bgrgba = rgba;
    }
  }
#line 275
  return;
}
}
#line 277 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void foreground_color(struct display *display___0 , rgba_t rgba ) 
{ 


  {
#line 279
  if (rgba != display___0->fgrgba) {
    {
#line 280
    set_color(display___0, rgba, 30U);
#line 281
    display___0->fgrgba = rgba;
    }
  }
#line 283
  return;
}
}
#line 285 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_put(struct display *display___0 , int row , int column , Unicode_t unicode ,
                 rgba_t fgrgba , rgba_t bgrgba ) 
{ 
  char buf[8] ;
  struct cell *cell ;
  size_t tmp ;

  {
#line 290
  if (row < 0) {
#line 292
    return;
  } else
#line 290
  if (row >= display___0->rows) {
#line 292
    return;
  } else
#line 290
  if (column < 0) {
#line 292
    return;
  } else
#line 290
  if (column >= display___0->columns) {
#line 292
    return;
  }
#line 293
  if (unicode < 32U) {
#line 294
    unicode = (Unicode_t )' ';
  }
#line 295
  cell = display___0->image + (row * display___0->columns + column);
#line 296
  if (cell->unicode == unicode) {
#line 296
    if (cell->fgrgba == fgrgba) {
#line 296
      goto _L;
    } else
#line 296
    if (unicode == 32U) {
      _L: /* CIL Label */ 
#line 296
      if (cell->bgrgba == bgrgba) {
#line 299
        return;
      }
    }
  }
  {
#line 300
  moveto(display___0, row, column);
#line 301
  background_color(display___0, bgrgba);
  }
#line 302
  if (unicode != 32U) {
    {
#line 303
    foreground_color(display___0, fgrgba);
    }
  }
  {
#line 304
  tmp = unicode_utf8(buf, unicode);
#line 304
  out(display___0, (char const   *)(buf), tmp);
#line 305
  (display___0->at_column) ++;
#line 307
  cell = display___0->image + (row * display___0->columns + column);
#line 308
  cell->unicode = unicode;
#line 309
  cell->bgrgba = bgrgba;
#line 310
  cell->fgrgba = fgrgba;
  }
#line 311
  return;
}
}
#line 313 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void color_fill(struct display *display___0 , int row , int rows___0 , int column ,
                       int columns___0 , rgba_t fgrgba , rgba_t bgrgba ) 
{ 
  int r ;
  int c ;
  struct cell *cell ;

  {
#line 318
  r = 0;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (r < rows___0)) {
#line 318
      goto while_break;
    }
#line 319
    cell = display___0->image + ((row + r) * display___0->columns + column);
#line 321
    c = 0;
    {
#line 321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 321
      if (! (c < columns___0)) {
#line 321
        goto while_break___0;
      }
#line 322
      cell->fgrgba = fgrgba;
#line 323
      cell->bgrgba = bgrgba;
#line 321
      c ++;
#line 321
      cell ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 318
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return;
}
}
#line 334 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void space_fill(struct display *display___0 , int row , int rows___0 , int column ,
                       int columns___0 ) 
{ 
  int r ;
  int c ;
  struct cell *cell ;

  {
#line 338
  r = 0;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (r < rows___0)) {
#line 338
      goto while_break;
    }
#line 339
    cell = display___0->image + ((row + r) * display___0->columns + column);
#line 341
    c = 0;
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (c < columns___0)) {
#line 341
        goto while_break___0;
      }
#line 342
      cell->unicode = (Unicode_t )' ';
#line 341
      c ++;
#line 341
      cell ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 338
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  if (display___0->is_apple) {
    {
#line 346
    color_fill(display___0, row, rows___0, column, columns___0, (rgba_t )255, (rgba_t )(~ 0));
    }
  } else {
    {
#line 349
    color_fill(display___0, row, rows___0, column, columns___0, display___0->fgrgba,
               display___0->bgrgba);
    }
  }
#line 351
  return;
}
}
#line 353 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_erase(struct display *display___0 , int row , int column , int rows___0 ,
                   int columns___0 ) 
{ 
  int r ;

  {
#line 358
  if (row < 0) {
#line 360
    return;
  } else
#line 358
  if (row >= display___0->rows) {
#line 360
    return;
  } else
#line 358
  if (column < 0) {
#line 360
    return;
  } else
#line 358
  if (column >= display___0->columns) {
#line 360
    return;
  }
#line 361
  if (row + rows___0 > display___0->rows) {
#line 362
    rows___0 = display___0->rows - row;
  }
#line 363
  if (column + columns___0 > display___0->columns) {
#line 364
    columns___0 = display___0->columns - column;
  }
#line 365
  if (rows___0 <= 0) {
#line 366
    return;
  } else
#line 365
  if (columns___0 <= 0) {
#line 366
    return;
  }
#line 368
  if (! column) {
#line 368
    if (columns___0 == display___0->columns) {
#line 368
      if (row + rows___0 == display___0->rows) {
#line 371
        if (! row) {
          {
#line 372
          outs(display___0, "\033[2J");
          }
        } else {
          {
#line 374
          moveto(display___0, row, column);
#line 375
          outs(display___0, "\033[J");
          }
        }
      } else {
#line 368
        goto _L___0;
      }
    } else {
#line 368
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 377
  if (column + columns___0 == display___0->columns) {
#line 378
    r = 0;
    {
#line 378
    while (1) {
      while_continue: /* CIL Label */ ;
#line 378
      if (! (r < rows___0)) {
#line 378
        goto while_break;
      }
      {
#line 379
      moveto(display___0, row + r, column);
#line 380
      outs(display___0, "\033[K");
#line 378
      r ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 383
    r = 0;
    {
#line 383
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 383
      if (! (r < rows___0)) {
#line 383
        goto while_break___0;
      }
      {
#line 384
      moveto(display___0, row + r, column);
#line 385
      outf(display___0, "\033[%dX", columns___0);
#line 383
      r ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 388
  space_fill(display___0, row, rows___0, column, columns___0);
  }
#line 389
  return;
}
}
#line 391 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_insert_spaces(struct display *display___0 , int row , int column , int spaces ,
                           int columns___0 ) 
{ 
  struct cell *cell ;

  {
#line 396
  if (row < 0) {
#line 398
    return;
  } else
#line 396
  if (row >= display___0->rows) {
#line 398
    return;
  } else
#line 396
  if (column < 0) {
#line 398
    return;
  } else
#line 396
  if (column >= display___0->columns) {
#line 398
    return;
  }
#line 399
  if (column + columns___0 > display___0->columns) {
#line 400
    columns___0 = display___0->columns - column;
  }
#line 401
  if (spaces > columns___0) {
#line 402
    spaces = columns___0;
  }
#line 403
  if (spaces <= 0) {
#line 404
    return;
  }
#line 405
  if (column + columns___0 != display___0->columns) {
    {
#line 406
    moveto(display___0, row, (column + columns___0) - spaces);
#line 407
    outf(display___0, "\033[%uP", spaces);
    }
  }
  {
#line 409
  moveto(display___0, row, column);
#line 410
  outf(display___0, "\033[%u@", spaces);
#line 411
  cell = display___0->image + (row * display___0->columns + column);
#line 412
  memmove((void *)(cell + spaces), (void const   *)cell, (unsigned long )(columns___0 - spaces) * sizeof(*cell));
#line 413
  space_fill(display___0, row, 1, column, spaces);
  }
#line 414
  return;
}
}
#line 416 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_delete_chars(struct display *display___0 , int row , int column , int chars ,
                          int columns___0 ) 
{ 
  struct cell *cell ;

  {
#line 421
  if (row < 0) {
#line 423
    return;
  } else
#line 421
  if (row >= display___0->rows) {
#line 423
    return;
  } else
#line 421
  if (column < 0) {
#line 423
    return;
  } else
#line 421
  if (column >= display___0->columns) {
#line 423
    return;
  }
#line 424
  if (column + columns___0 > display___0->columns) {
#line 425
    columns___0 = display___0->columns - column;
  }
#line 426
  if (chars > columns___0) {
#line 427
    chars = columns___0;
  }
#line 428
  if (chars <= 0) {
#line 429
    return;
  }
  {
#line 431
  moveto(display___0, row, column);
#line 432
  outf(display___0, "\033[%uP", chars);
#line 433
  moveto(display___0, row, (column + columns___0) - chars);
#line 434
  outf(display___0, "\033[%u@", chars);
#line 435
  cell = display___0->image + (row * display___0->columns + column);
#line 436
  memmove((void *)cell, (void const   *)(cell + chars), (unsigned long )(columns___0 - chars) * sizeof(*cell));
#line 437
  space_fill(display___0, row, 1, (column + columns___0) - chars, chars);
  }
#line 438
  return;
}
}
#line 440 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static Boolean_t validate(struct display *display___0 , int row , int column , int *rows___0 ,
                          int *columns___0 , int *lines ) 
{ 
  int tmp ;

  {
#line 443
  if (row < 0) {
#line 445
    return ((Boolean_t )0);
  } else
#line 443
  if (row >= display___0->rows) {
#line 445
    return ((Boolean_t )0);
  } else
#line 443
  if (column < 0) {
#line 445
    return ((Boolean_t )0);
  } else
#line 443
  if (column >= display___0->columns) {
#line 445
    return ((Boolean_t )0);
  }
#line 446
  if (row + *rows___0 > display___0->rows) {
#line 447
    *rows___0 = display___0->rows - row;
  }
#line 448
  if (*lines > *rows___0) {
#line 449
    *lines = *rows___0;
  }
#line 450
  if (column + *columns___0 > display___0->columns) {
#line 451
    *columns___0 = display___0->columns - column;
  }
#line 452
  if (*lines > 0) {
#line 452
    if (*columns___0 > 0) {
#line 452
      tmp = 1;
    } else {
#line 452
      tmp = 0;
    }
  } else {
#line 452
    tmp = 0;
  }
#line 452
  return ((Boolean_t )tmp);
}
}
#line 455 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_insert_lines(struct display *display___0 , int row , int column , int lines ,
                          int rows___0 , int columns___0 ) 
{ 
  Boolean_t tmp ;

  {
#line 458
  if (column) {
#line 461
    return;
  } else
#line 458
  if (columns___0 != display___0->columns) {
#line 461
    return;
  } else {
    {
#line 458
    tmp = validate(display___0, row, column, & rows___0, & columns___0, & lines);
    }
#line 458
    if (! tmp) {
#line 461
      return;
    }
  }
#line 463
  if (row + rows___0 != display___0->rows) {
    {
#line 464
    moveto(display___0, (row + rows___0) - lines, 0);
#line 465
    outf(display___0, "\033[%uM", lines);
    }
  }
  {
#line 467
  moveto(display___0, row, 0);
#line 468
  outf(display___0, "\033[%uL", lines);
#line 469
  memmove((void *)(display___0->image + (row + lines) * display___0->columns), (void const   *)(display___0->image + row * display___0->columns),
          (unsigned long )((rows___0 - lines) * display___0->columns) * sizeof(*(display___0->image)));
#line 472
  space_fill(display___0, row, lines, 0, display___0->columns);
  }
#line 473
  return;
}
}
#line 475 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_delete_lines(struct display *display___0 , int row , int column , int lines ,
                          int rows___0 , int columns___0 ) 
{ 
  struct cell *cell ;
  Boolean_t tmp ;

  {
#line 480
  if (column) {
#line 483
    return;
  } else
#line 480
  if (columns___0 != display___0->columns) {
#line 483
    return;
  } else {
    {
#line 480
    tmp = validate(display___0, row, column, & rows___0, & columns___0, & lines);
    }
#line 480
    if (! tmp) {
#line 483
      return;
    }
  }
  {
#line 485
  moveto(display___0, row, 0);
#line 486
  outf(display___0, "\033[%uM", lines);
  }
#line 487
  if (row + rows___0 != display___0->rows) {
    {
#line 488
    moveto(display___0, (row + rows___0) - lines, 0);
#line 489
    outf(display___0, "\033[%uL", lines);
    }
  }
  {
#line 491
  cell = display___0->image + row * display___0->columns;
#line 492
  memmove((void *)cell, (void const   *)(cell + lines * display___0->columns), (unsigned long )((rows___0 - lines) * display___0->columns) * sizeof(*cell));
#line 494
  space_fill(display___0, (row + rows___0) - lines, lines, 0, display___0->columns);
  }
#line 495
  return;
}
}
#line 497 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static struct cell *resize(struct display *display___0 , struct cell *old , int old_rows ,
                           int old_columns , int new_rows , int new_columns ) 
{ 
  int cells ;
  size_t bytes ;
  struct cell *new ;
  void *tmp ;
  int min_rows ;
  int tmp___0 ;
  int min_columns ;
  int tmp___1 ;
  int j ;
  int k ;
  struct cell *cell ;
  struct cell *tmp___2 ;
  struct cell *tmp___3 ;
  struct cell *cell___0 ;
  struct cell *tmp___4 ;

  {
  {
#line 501
  cells = new_rows * new_columns;
#line 502
  bytes = (unsigned long )cells * sizeof(*old);
#line 503
  tmp = reallocate((void const   *)((void *)0), bytes);
#line 503
  new = (struct cell *)tmp;
  }
#line 504
  if (new_rows < old_rows) {
#line 504
    tmp___0 = new_rows;
  } else {
#line 504
    tmp___0 = old_rows;
  }
#line 504
  min_rows = tmp___0;
#line 505
  if (new_columns < old_columns) {
#line 505
    tmp___1 = new_columns;
  } else {
#line 505
    tmp___1 = old_columns;
  }
#line 505
  min_columns = tmp___1;
#line 508
  if (! old) {
    {
#line 509
    memset((void *)new, 0, bytes);
#line 510
    j = 0;
    }
    {
#line 510
    while (1) {
      while_continue: /* CIL Label */ ;
#line 510
      if (! (j < cells)) {
#line 510
        goto while_break;
      }
#line 511
      (new + j)->unicode = (Unicode_t )' ';
#line 512
      (new + j)->bgrgba = display___0->bgrgba;
#line 513
      (new + j)->fgrgba = display___0->fgrgba;
#line 510
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 515
    return (new);
  }
#line 518
  j = 0;
  {
#line 518
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 518
    if (! (j < min_rows)) {
#line 518
      goto while_break___0;
    }
#line 519
    cell = new + j * new_columns;
#line 520
    k = 0;
    {
#line 520
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 520
      if (! (k < min_columns)) {
#line 520
        goto while_break___1;
      }
#line 521
      tmp___2 = cell;
#line 521
      cell ++;
#line 521
      *tmp___2 = *(old + (j * old_columns + k));
#line 520
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 522
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 522
      if (! (k < new_columns)) {
#line 522
        goto while_break___2;
      }
#line 523
      *cell = *(cell + -1);
#line 524
      tmp___3 = cell;
#line 524
      cell ++;
#line 524
      tmp___3->unicode = (Unicode_t )' ';
#line 522
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 518
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 527
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 527
    if (! (j < new_rows)) {
#line 527
      goto while_break___3;
    }
#line 528
    cell___0 = new + j * new_columns;
#line 529
    k = 0;
    {
#line 529
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 529
      if (! (k < new_columns)) {
#line 529
        goto while_break___4;
      }
#line 530
      *cell___0 = *(cell___0 - display___0->columns);
#line 531
      tmp___4 = cell___0;
#line 531
      cell___0 ++;
#line 531
      tmp___4->unicode = (Unicode_t )' ';
#line 529
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 527
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 535
  reallocate((void const   *)old, (size_t )0);
#line 535
  old = (struct cell *)((void *)0);
  }
#line 536
  return (new);
}
}
#line 539 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void set_geometry(struct display *display___0 , int rows___0 , int columns___0 ) 
{ 


  {
#line 541
  if (display___0->image) {
#line 541
    if (display___0->rows == rows___0) {
#line 541
      if (display___0->columns == columns___0) {
#line 544
        return;
      }
    }
  }
  {
#line 546
  display___0->image = resize(display___0, display___0->image, display___0->rows,
                              display___0->columns, rows___0, columns___0);
#line 549
  display___0->rows = rows___0;
#line 550
  display___0->columns = columns___0;
#line 551
  display___0->size_changed = (Boolean_t )1;
#line 552
  display_erase(display___0, 0, rows___0, 0, columns___0);
#line 553
  display_cursor(display___0, display___0->cursor_row, display___0->cursor_column);
  }
#line 554
  if ((unsigned int )display___0->get_initial_cursor_position == 2U) {
#line 555
    display___0->get_initial_cursor_position = (enum cursor_position_knowledge )3;
  }
#line 556
  return;
}
}
#line 558 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void geometry(struct display *display___0 ) 
{ 
  int rows___0 ;
  int columns___0 ;
  struct winsize ws ;
  char const   *p ;
  unsigned int n ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 560
  rows___0 = 0;
#line 560
  columns___0 = 0;
#line 566
  tmp = ioctl(1, 21523UL, & ws);
  }
#line 566
  if (! tmp) {
#line 567
    rows___0 = (int )ws.ws_row;
#line 568
    columns___0 = (int )ws.ws_col;
  }
#line 571
  if (! rows___0) {
    {
#line 571
    tmp___0 = getenv("ROWS");
#line 571
    p = (char const   *)tmp___0;
    }
#line 571
    if (p) {
      {
#line 571
      tmp___1 = atoi(p);
#line 571
      n = (unsigned int )tmp___1;
      }
#line 571
      if (n) {
#line 571
        if (n <= 100U) {
#line 575
          rows___0 = (int )n;
        }
      }
    }
  }
#line 576
  if (! columns___0) {
    {
#line 576
    tmp___2 = getenv("COLUMNS");
#line 576
    p = (char const   *)tmp___2;
    }
#line 576
    if (p) {
      {
#line 576
      tmp___3 = atoi(p);
#line 576
      n = (unsigned int )tmp___3;
      }
#line 576
      if (n) {
#line 576
        if (n <= 200U) {
#line 580
          columns___0 = (int )n;
        }
      }
    }
  }
#line 581
  if (! rows___0) {
#line 581
    goto _L;
  } else
#line 581
  if (! columns___0) {
    _L: /* CIL Label */ 
#line 582
    if (! rows___0) {
#line 583
      rows___0 = 24;
    }
#line 584
    if (! columns___0) {
#line 585
      columns___0 = 80;
    }
    {
#line 586
    force_moveto(display___0, 666, 666);
#line 587
    outs(display___0, "\033[6n");
    }
  }
  {
#line 589
  set_geometry(display___0, rows___0, columns___0);
  }
#line 590
  return;
}
}
#line 592 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_get_geometry(struct display *display___0 , int *rows___0 , int *columns___0 ) 
{ 


  {
#line 594
  *rows___0 = display___0->rows;
#line 595
  *columns___0 = display___0->columns;
#line 596
  display___0->size_changed = (Boolean_t )0;
#line 597
  return;
}
}
#line 599 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_reset(struct display *display___0 ) 
{ 
  int tmp ;

  {
  {
#line 601
  reallocate((void const   *)display___0->image, (size_t )0);
#line 601
  display___0->image = (struct cell *)((void *)0);
  }
#line 602
  if (display___0->is_xterm) {
#line 603
    if ((unsigned int )display___0->get_initial_cursor_position == 0U) {
      {
#line 604
      display___0->get_initial_cursor_position = (enum cursor_position_knowledge )1;
#line 605
      outs(display___0, "\033[6n");
      }
    }
    {
#line 607
    outs(display___0, "\033[?47h");
    }
  } else {
    {
#line 609
    outs(display___0, "\033c");
    }
  }
  {
#line 610
  outs(display___0, "\033%G\033[0m\033[39;49m");
  }
#line 613
  if (display___0->is_xterm) {
    {
#line 614
    outs(display___0, "\033[?67l");
    }
  }
#line 615
  if (display___0->is_linux) {
    {
#line 616
    outs(display___0, "\033>\033[0q\033[2q");
    }
  }
  {
#line 617
  display___0->colors = 0U;
#line 618
  display___0->fgrgba = (rgba_t )16843008;
#line 619
  display___0->bgrgba = (rgba_t )16843008;
#line 620
  geometry(display___0);
#line 621
  force_moveto(display___0, 0, 0);
#line 622
  tmp = 0;
#line 622
  display___0->cursor_column = tmp;
#line 622
  display___0->cursor_row = tmp;
#line 623
  display___0->cursor_rgba = (rgba_t )16843008;
#line 624
  flush(display___0);
  }
#line 625
  return;
}
}
#line 627 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void sigwinch(int signo , siginfo_t *info , void *data ) 
{ 
  struct display *display___0 ;

  {
#line 630
  display___0 = display_list;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! display___0) {
#line 630
      goto while_break;
    }
    {
#line 631
    geometry(display___0);
#line 630
    display___0 = display___0->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if (old_sigwinch) {
    {
#line 633
    (*old_sigwinch)(signo, info, data);
    }
  }
#line 634
  return;
}
}
#line 647 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
struct display *display_init(void) 
{ 
  struct display *display___0 ;
  void *tmp ;
  struct termios termios ;
  char const   *term ;
  char const   *path ;
  char *tmp___0 ;
  struct sigaction sigact ;
  struct sigaction old_sigact ;
  struct display *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  Boolean_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 649
  tmp = allocate0(sizeof(*display___0));
#line 649
  display___0 = (struct display *)tmp;
#line 650
  termios = original_termios;
#line 653
  tmp___0 = getenv("DISPLAY_DEBUG_PATH");
#line 653
  path = (char const   *)tmp___0;
  }
#line 653
  if (path) {
    {
#line 653
    debug_file = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"w");
    }
#line 653
    if (! debug_file) {
      {
#line 655
      die("could not open display debug file %s for writing", path);
      }
    }
  }
  {
#line 657
  cfmakeraw(& termios);
#line 658
  tcsetattr(1, 1, (struct termios  const  *)(& termios));
#line 660
  tmp___1 = display_list;
#line 660
  display___0->next = tmp___1;
  }
#line 660
  if (! tmp___1) {
    {
#line 662
    memset((void *)(& sigact), 0, sizeof(sigact));
#line 663
    sigact.__sigaction_handler.sa_sigaction = & sigwinch;
#line 664
    sigact.sa_flags = 4;
#line 665
    sigaction(28, (struct sigaction  const  */* __restrict  */)(& sigact), (struct sigaction */* __restrict  */)(& old_sigact));
    }
#line 666
    if ((unsigned long )((void (*)(int  ))old_sigact.__sigaction_handler.sa_sigaction) != (unsigned long )((void (*)(int  ))0)) {
#line 666
      if ((unsigned long )((void (*)(int  ))old_sigact.__sigaction_handler.sa_sigaction) != (unsigned long )((void (*)(int  ))1)) {
#line 666
        if ((unsigned long )old_sigact.__sigaction_handler.sa_sigaction != (unsigned long )(& sigwinch)) {
#line 669
          old_sigwinch = old_sigact.__sigaction_handler.sa_sigaction;
        }
      }
    }
  }
  {
#line 672
  display_list = display___0;
#line 673
  tmp___2 = (size_t )0;
#line 673
  display___0->outbuf_bytes = tmp___2;
#line 673
  display___0->inbuf_bytes = tmp___2;
#line 674
  tmp___13 = getenv("TERM");
#line 674
  term = (char const   *)tmp___13;
  }
#line 674
  if (term) {
    {
#line 675
    tmp___11 = strncmp(term, "xterm", (size_t )5);
    }
#line 675
    if (tmp___11) {
#line 675
      tmp___12 = 0;
    } else {
#line 675
      tmp___12 = 1;
    }
#line 675
    tmp___10 = (Boolean_t )tmp___12;
#line 675
    display___0->is_xterm = tmp___10;
#line 675
    if (tmp___10) {
      {
#line 676
      tmp___6 = getenv("COLORTERM");
#line 676
      term = (char const   *)tmp___6;
      }
#line 676
      if (term) {
        {
#line 676
        tmp___7 = strncmp(term, "gnome-", (size_t )6);
        }
#line 676
        if (tmp___7) {
#line 676
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 679
        tmp___5 = getenv("TERM_PROGRAM");
#line 679
        term = (char const   *)tmp___5;
        }
#line 679
        if (term) {
          {
#line 680
          tmp___3 = strcmp(term, "Apple_Terminal");
          }
#line 680
          if (tmp___3) {
#line 680
            tmp___4 = 0;
          } else {
#line 680
            tmp___4 = 1;
          }
#line 680
          display___0->is_apple = (Boolean_t )tmp___4;
        }
      }
    } else {
      {
#line 682
      tmp___8 = strcmp(term, "linux");
      }
#line 682
      if (tmp___8) {
#line 682
        tmp___9 = 0;
      } else {
#line 682
        tmp___9 = 1;
      }
#line 682
      display___0->is_linux = (Boolean_t )tmp___9;
    }
  }
  {
#line 684
  display_reset(display___0);
  }
#line 685
  return (display___0);
}
}
#line 688 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_end(struct display *display___0 ) 
{ 
  struct display *d ;
  struct display *prev ;

  {
#line 690
  prev = (struct display *)((void *)0);
#line 692
  if (! display___0) {
#line 693
    return;
  }
  {
#line 695
  display_title(display___0, (char const   *)((void *)0));
#line 696
  set_color(display___0, (rgba_t )255, 30U);
#line 697
  set_color(display___0, (rgba_t )(~ 0), 40U);
  }
#line 698
  if (display___0->is_xterm) {
    {
#line 699
    outs(display___0, "\033[?47l");
    }
#line 700
    if ((unsigned int )display___0->get_initial_cursor_position == 2U) {
      {
#line 701
      force_moveto(display___0, display___0->initial_row, display___0->initial_column);
      }
    } else {
      {
#line 704
      force_moveto(display___0, display___0->rows - 1, 0);
      }
    }
  } else {
    {
#line 706
    outs(display___0, "\033c\033[0m");
    }
  }
  {
#line 707
  flush(display___0);
#line 709
  tcsetattr(1, 1, (struct termios  const  *)(& original_termios));
#line 711
  reallocate((void const   *)display___0->image, (size_t )0);
#line 711
  display___0->image = (struct cell *)((void *)0);
#line 713
  d = display_list;
  }
  {
#line 713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 713
    if (! d) {
#line 713
      goto while_break;
    }
#line 714
    if ((unsigned long )d == (unsigned long )display___0) {
#line 715
      if (prev) {
#line 716
        prev->next = display___0->next;
      } else {
#line 718
        display_list = display___0->next;
      }
#line 719
      goto while_break;
    }
#line 713
    prev = d;
#line 713
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 722
  reallocate((void const   *)display___0, (size_t )0);
#line 722
  display___0 = (struct display *)((void *)0);
  }
#line 723
  return;
}
}
#line 725 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
Boolean_t display_title(struct display *display___0 , char const   *title___0 ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
#line 727
  if (! display___0->is_xterm) {
#line 728
    return ((Boolean_t )0);
  }
#line 729
  if (title___0) {
#line 729
    if (! *title___0) {
#line 730
      title___0 = (char const   *)((void *)0);
    }
  }
#line 731
  if (! title___0) {
#line 731
    if (! display___0->title) {
#line 732
      return ((Boolean_t )1);
    }
  }
#line 733
  if (! title___0) {
    {
#line 734
    reallocate((void const   *)display___0->title, (size_t )0);
#line 734
    display___0->title = (char *)((void *)0);
    }
  } else
#line 735
  if (display___0->title) {
    {
#line 735
    tmp = strcmp(title___0, (char const   *)display___0->title);
    }
#line 735
    if (! tmp) {
#line 736
      return ((Boolean_t )1);
    }
  }
#line 737
  if (title___0) {
    {
#line 738
    display___0->title = strdup(title___0);
    }
  } else {
#line 740
    title___0 = "";
  }
#line 741
  if (title___0) {
#line 741
    tmp___0 = title___0;
  } else {
#line 741
    tmp___0 = "";
  }
  {
#line 741
  outf(display___0, "\033]0;%s\a", tmp___0);
  }
#line 742
  return ((Boolean_t )1);
}
}
#line 745 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_cursor(struct display *display___0 , int row , int column ) 
{ 


  {
#line 747
  if (row >= display___0->rows) {
#line 748
    row = display___0->rows - 1;
  }
#line 749
  if (row < 0) {
#line 750
    row = 0;
  }
#line 751
  if (column >= display___0->columns) {
#line 752
    column = display___0->columns - 1;
  }
#line 753
  if (column < 0) {
#line 754
    column = 0;
  }
#line 755
  display___0->cursor_row = row;
#line 756
  display___0->cursor_column = column;
#line 757
  return;
}
}
#line 759 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
Boolean_t display_cursor_color(struct display *display___0 , rgba_t rgba ) 
{ 


  {
#line 761
  if (! display___0->is_xterm) {
#line 764
    return ((Boolean_t )0);
  } else
#line 761
  if (display___0->is_apple) {
#line 764
    return ((Boolean_t )0);
  } else
#line 761
  if (rgba & 255U) {
#line 764
    return ((Boolean_t )0);
  }
#line 765
  if (rgba != display___0->cursor_rgba) {
    {
#line 766
    outf(display___0, "\033]12;rgb:%02x/%02x/%02x\a", rgba >> 24, (rgba >> 16) & 255U,
         (rgba >> 8) & 255U);
#line 768
    display___0->cursor_rgba = rgba;
    }
  }
#line 770
  return ((Boolean_t )1);
}
}
#line 773 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
void display_beep(struct display *display___0 ) 
{ 


  {
  {
#line 775
  emit("\a", (size_t )1);
#line 776
  display_sync(display___0);
  }
#line 777
  return;
}
}
#line 779 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
Unicode_t display_getch(struct display *display___0 , Boolean_t block ) 
{ 
  Byte_t *p ;
  Unicode_t key ;
  unsigned int used ;
  unsigned int vals ;
  unsigned int val[16] ;
  int n ;
  int *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  Boolean_t tmp___4 ;
  size_t tmp___5 ;
  Byte_t *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 787
  if (! display___0) {
#line 788
    return ((((1U << 31) + 1U) + 256U) + 1U);
  }
  again: 
#line 790
  if (display___0->size_changed) {
#line 791
    return ((((1U << 31) + 1U) + 256U) + 2U);
  }
  {
#line 792
  display_sync(display___0);
  }
#line 793
  if (! (display___0->inbuf_bytes >= sizeof(display___0->inbuf) - 1UL)) {
    {
#line 795
    tmp___4 = multiplexor(block);
    }
#line 795
    if (tmp___4) {
      {
#line 800
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 801
        tmp = __errno_location();
#line 801
        *tmp = 0;
#line 802
        tmp___0 = read(0, (void *)(display___0->inbuf + display___0->inbuf_bytes),
                       (sizeof(display___0->inbuf) - 1UL) - display___0->inbuf_bytes);
#line 802
        n = (int )tmp___0;
        }
#line 800
        if (n < 0) {
          {
#line 800
          tmp___1 = __errno_location();
          }
#line 800
          if (! (*tmp___1 == 11)) {
            {
#line 800
            tmp___2 = __errno_location();
            }
#line 800
            if (! (*tmp___2 == 4)) {
#line 800
              goto while_break;
            }
          }
        } else {
#line 800
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 806
      if (debug_file) {
        {
#line 807
        fprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)"read %d:",
                n);
        }
#line 808
        if (n > 0) {
          {
#line 809
          fwrite((void const   */* __restrict  */)(display___0->inbuf + display___0->inbuf_bytes),
                 (size_t )n, (size_t )1, (FILE */* __restrict  */)debug_file);
          }
        }
        {
#line 811
        fputc('\n', debug_file);
        }
      }
#line 813
      if (! n) {
#line 814
        return ((((1U << 31) + 1U) + 256U) + 1U);
      }
#line 815
      if (n < 0) {
#line 816
        return ((((1U << 31) + 1U) + 256U) + 3U);
      }
#line 817
      tmp___3 = display___0->inbuf_bytes + (size_t )n;
#line 817
      display___0->inbuf_bytes = tmp___3;
#line 817
      display___0->inbuf[tmp___3] = (Byte_t )'\000';
    } else
#line 796
    if (! display___0->inbuf_bytes) {
#line 797
      return ((((1U << 31) + 1U) + 256U) + 4U);
    }
  }
#line 820
  p = display___0->inbuf;
#line 821
  if ((int )*p != 27) {
#line 822
    if ((size_t )utf8_bytes[*p] > display___0->inbuf_bytes) {
#line 823
      if (block) {
#line 824
        goto again;
      }
#line 825
      return ((((1U << 31) + 1U) + 256U) + 4U);
    }
    {
#line 827
    tmp___5 = utf8_length((char const   *)((char *)p), display___0->inbuf_bytes);
#line 827
    used = (unsigned int )tmp___5;
#line 828
    key = utf8_unicode((char const   *)((char *)p), (size_t )used);
#line 829
    p += used - 1U;
    }
#line 830
    goto done;
  }
#line 835
  vals = 0U;
#line 835
  key = vals;
  {
#line 838
  if ((int )*(p + 1) == 91) {
#line 838
    goto case_91;
  }
#line 887
  if ((int )*(p + 1) == 79) {
#line 887
    goto case_79;
  }
#line 900
  if ((int )*(p + 1) == 32) {
#line 900
    goto case_32;
  }
#line 900
  if ((int )*(p + 1) == 64) {
#line 900
    goto case_32;
  }
#line 907
  if ((int )*(p + 1) == 95) {
#line 907
    goto case_95;
  }
#line 907
  if ((int )*(p + 1) == 94) {
#line 907
    goto case_95;
  }
#line 907
  if ((int )*(p + 1) == 93) {
#line 907
    goto case_95;
  }
#line 907
  if ((int )*(p + 1) == 92) {
#line 907
    goto case_95;
  }
#line 910
  if ((int )*(p + 1) == 47) {
#line 910
    goto case_47;
  }
#line 914
  if ((int )*(p + 1) == 63) {
#line 914
    goto case_63;
  }
#line 918
  if ((int )*(p + 1) == 27) {
#line 918
    goto case_27;
  }
#line 921
  if ((int )*(p + 1) == 0) {
#line 921
    goto case_0___0;
  }
#line 925
  goto switch_default;
  case_91: /* CIL Label */ 
#line 839
  p += 2;
  {
#line 839
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 839
    tmp___8 = __ctype_b_loc();
    }
#line 839
    if (! ((int const   )*(*tmp___8 + (int )*p) & 2048)) {
#line 839
      goto while_break___0;
    }
#line 840
    val[vals] = 0U;
    {
#line 841
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 842
      val[vals] *= 10U;
#line 843
      tmp___6 = p;
#line 843
      p ++;
#line 843
      val[vals] += (unsigned int )((int )*tmp___6 - 48);
#line 841
      tmp___7 = __ctype_b_loc();
      }
#line 841
      if (! ((int const   )*(*tmp___7 + (int )*p) & 2048)) {
#line 841
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 845
    vals ++;
#line 846
    if ((int )*p != 59) {
#line 847
      goto while_break___0;
    }
#line 848
    if (vals == 16U) {
#line 849
      vals --;
    }
#line 839
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 852
  if ((int )*p == 82) {
#line 852
    goto case_82;
  }
#line 856
  if ((int )*p == 126) {
#line 856
    goto case_126;
  }
#line 874
  if ((int )*p == 65) {
#line 874
    goto case_65;
  }
#line 875
  if ((int )*p == 66) {
#line 875
    goto case_66;
  }
#line 876
  if ((int )*p == 67) {
#line 876
    goto case_67;
  }
#line 877
  if ((int )*p == 68) {
#line 877
    goto case_68;
  }
#line 878
  if ((int )*p == 70) {
#line 878
    goto case_70;
  }
#line 879
  if ((int )*p == 72) {
#line 879
    goto case_72;
  }
#line 880
  if ((int )*p == 0) {
#line 880
    goto case_0;
  }
#line 851
  goto switch_break___0;
  case_82: /* CIL Label */ 
#line 853
  if (vals >= 2U) {
#line 854
    key = ((1U << 31) + 1U) + 119U;
  }
#line 855
  goto switch_break___0;
  case_126: /* CIL Label */ 
#line 857
  if (! val[0]) {
#line 858
    goto switch_break___0;
  }
  {
#line 860
  if (val[0] == 2U) {
#line 860
    goto case_2;
  }
#line 861
  if (val[0] == 3U) {
#line 861
    goto case_3;
  }
#line 862
  if (val[0] == 5U) {
#line 862
    goto case_5;
  }
#line 863
  if (val[0] == 6U) {
#line 863
    goto case_6;
  }
#line 864
  if (val[0] == 15U) {
#line 864
    goto case_15;
  }
#line 865
  if (val[0] == 17U) {
#line 865
    goto case_17;
  }
#line 866
  if (val[0] == 18U) {
#line 866
    goto case_18;
  }
#line 867
  if (val[0] == 19U) {
#line 867
    goto case_19;
  }
#line 868
  if (val[0] == 20U) {
#line 868
    goto case_20;
  }
#line 869
  if (val[0] == 21U) {
#line 869
    goto case_21;
  }
#line 870
  if (val[0] == 22U) {
#line 870
    goto case_22;
  }
#line 871
  if (val[0] == 24U) {
#line 871
    goto case_24;
  }
#line 859
  goto switch_break___1;
  case_2: /* CIL Label */ 
#line 860
  key = ((1U << 31) + 1U) + 9U;
#line 860
  goto switch_break___1;
  case_3: /* CIL Label */ 
#line 861
  key = ((1U << 31) + 1U) + 10U;
#line 861
  goto switch_break___1;
  case_5: /* CIL Label */ 
#line 862
  key = ((1U << 31) + 1U) + 5U;
#line 862
  goto switch_break___1;
  case_6: /* CIL Label */ 
#line 863
  key = ((1U << 31) + 1U) + 6U;
#line 863
  goto switch_break___1;
  case_15: /* CIL Label */ 
#line 864
  key = ((1U << 31) + 1U) + 25U;
#line 864
  goto switch_break___1;
  case_17: /* CIL Label */ 
#line 865
  key = ((1U << 31) + 1U) + 26U;
#line 865
  goto switch_break___1;
  case_18: /* CIL Label */ 
#line 866
  key = ((1U << 31) + 1U) + 27U;
#line 866
  goto switch_break___1;
  case_19: /* CIL Label */ 
#line 867
  key = ((1U << 31) + 1U) + 28U;
#line 867
  goto switch_break___1;
  case_20: /* CIL Label */ 
#line 868
  key = ((1U << 31) + 1U) + 29U;
#line 868
  goto switch_break___1;
  case_21: /* CIL Label */ 
#line 869
  key = ((1U << 31) + 1U) + 30U;
#line 869
  goto switch_break___1;
  case_22: /* CIL Label */ 
#line 870
  key = ((1U << 31) + 1U) + 31U;
#line 870
  goto switch_break___1;
  case_24: /* CIL Label */ 
#line 871
  key = ((1U << 31) + 1U) + 32U;
#line 871
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 873
  goto switch_break___0;
  case_65: /* CIL Label */ 
#line 874
  key = ((1U << 31) + 1U) + 1U;
#line 874
  goto switch_break___0;
  case_66: /* CIL Label */ 
#line 875
  key = ((1U << 31) + 1U) + 2U;
#line 875
  goto switch_break___0;
  case_67: /* CIL Label */ 
#line 876
  key = ((1U << 31) + 1U) + 3U;
#line 876
  goto switch_break___0;
  case_68: /* CIL Label */ 
#line 877
  key = ((1U << 31) + 1U) + 4U;
#line 877
  goto switch_break___0;
  case_70: /* CIL Label */ 
#line 878
  key = ((1U << 31) + 1U) + 8U;
#line 878
  goto switch_break___0;
  case_72: /* CIL Label */ 
#line 879
  key = ((1U << 31) + 1U) + 7U;
#line 879
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 881
  if (! block) {
#line 882
    return ((((1U << 31) + 1U) + 256U) + 4U);
  }
#line 883
  goto again;
  switch_break___0: /* CIL Label */ ;
  }
#line 885
  goto switch_break;
  case_79: /* CIL Label */ 
#line 888
  p += 2;
  {
#line 889
  if ((int )*p == 72) {
#line 889
    goto case_72___0;
  }
#line 890
  if ((int )*p == 70) {
#line 890
    goto case_70___0;
  }
#line 891
  if ((int )*p == 80) {
#line 891
    goto case_80;
  }
#line 892
  if ((int )*p == 81) {
#line 892
    goto case_81;
  }
#line 893
  if ((int )*p == 82) {
#line 893
    goto case_82___0;
  }
#line 894
  if ((int )*p == 83) {
#line 894
    goto case_83;
  }
#line 888
  goto switch_break___2;
  case_72___0: /* CIL Label */ 
#line 889
  key = ((1U << 31) + 1U) + 7U;
#line 889
  goto switch_break___2;
  case_70___0: /* CIL Label */ 
#line 890
  key = ((1U << 31) + 1U) + 8U;
#line 890
  goto switch_break___2;
  case_80: /* CIL Label */ 
#line 891
  key = ((1U << 31) + 1U) + 21U;
#line 891
  goto switch_break___2;
  case_81: /* CIL Label */ 
#line 892
  key = ((1U << 31) + 1U) + 22U;
#line 892
  goto switch_break___2;
  case_82___0: /* CIL Label */ 
#line 893
  key = ((1U << 31) + 1U) + 23U;
#line 893
  goto switch_break___2;
  case_83: /* CIL Label */ 
#line 894
  key = ((1U << 31) + 1U) + 24U;
#line 894
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 896
  goto switch_break;
  case_32: /* CIL Label */ 
  case_64: /* CIL Label */ 
#line 901
  key = (Unicode_t )0;
#line 902
  p ++;
#line 903
  goto switch_break;
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 908
  p ++;
#line 908
  key = (Unicode_t )((int )*p - 64);
#line 909
  goto switch_break;
  case_47: /* CIL Label */ 
#line 911
  key = (Unicode_t )31;
#line 912
  p ++;
#line 913
  goto switch_break;
  case_63: /* CIL Label */ 
#line 915
  key = (Unicode_t )'\177';
#line 916
  p ++;
#line 917
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 919
  tmp___9 = display___0->inbuf_bytes - 2UL;
#line 919
  display___0->inbuf_bytes = tmp___9;
#line 919
  memmove((void *)(display___0->inbuf), (void const   *)(p + 2), tmp___9);
  }
#line 920
  goto again;
  case_0___0: /* CIL Label */ 
#line 922
  if (! block) {
#line 923
    return ((((1U << 31) + 1U) + 256U) + 4U);
  }
#line 924
  goto again;
  switch_default: /* CIL Label */ 
#line 926
  if ((int )*(p + 1) < 32) {
#line 927
    p ++;
#line 927
    key = (Unicode_t )*p;
  } else
#line 928
  if ((int )*(p + 1) >= 97) {
#line 928
    if ((int )*(p + 1) <= 122) {
#line 929
      p ++;
#line 929
      key = (Unicode_t )((((int )*p - 97) + 65) - 64);
    } else {
#line 928
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 930
  if ((int )*(p + 1) >= 65) {
#line 930
    if ((int )*(p + 1) <= 90) {
#line 931
      p ++;
#line 931
      key = (Unicode_t )((int )*p - 64);
    }
  }
  switch_break: /* CIL Label */ ;
  }
  done: 
#line 934
  if (! key) {
#line 935
    p = display___0->inbuf;
#line 935
    key = (Unicode_t )*p;
  }
  {
#line 936
  p ++;
#line 936
  used = (unsigned int )(p - display___0->inbuf);
#line 937
  tmp___10 = display___0->inbuf_bytes - (size_t )used;
#line 937
  display___0->inbuf_bytes = tmp___10;
#line 937
  memmove((void *)(display___0->inbuf), (void const   *)p, tmp___10);
  }
#line 938
  if (key == ((1U << 31) + 1U) + 119U) {
#line 939
    if ((unsigned int )display___0->get_initial_cursor_position == 1U) {
#line 939
      if (val[0] > 0U) {
#line 939
        if (val[1] > 0U) {
#line 941
          display___0->get_initial_cursor_position = (enum cursor_position_knowledge )2;
#line 942
          display___0->initial_row = (int )(val[0] - 1U);
#line 943
          display___0->initial_column = (int )(val[1] - 1U);
        } else {
          {
#line 945
          set_geometry(display___0, (int )val[0], (int )val[1]);
          }
        }
      } else {
        {
#line 945
        set_geometry(display___0, (int )val[0], (int )val[1]);
        }
      }
    } else {
      {
#line 945
      set_geometry(display___0, (int )val[0], (int )val[1]);
      }
    }
#line 946
    goto again;
  }
#line 948
  return (key);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 13 "/home/june/collector/temp/aoeui-1.6~dfsg/display-test.c"
static struct display *D  ;
#line 14 "/home/june/collector/temp/aoeui-1.6~dfsg/display-test.c"
static int rows  ;
#line 14 "/home/june/collector/temp/aoeui-1.6~dfsg/display-test.c"
static int columns  ;
#line 16 "/home/june/collector/temp/aoeui-1.6~dfsg/display-test.c"
static void dfill(int row , int rows___0 , int col , int cols , int ch , rgba_t fgrgba ,
                  rgba_t bgrgba ) 
{ 
  int j ;
  int k ;

  {
#line 20
  j = 0;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! (j < rows___0)) {
#line 20
      goto while_break;
    }
#line 21
    k = 0;
    {
#line 21
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 21
      if (! (k < cols)) {
#line 21
        goto while_break___0;
      }
      {
#line 22
      display_put(D, row + j, col + k, (Unicode_t )ch, fgrgba, bgrgba);
#line 21
      k ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 20
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return;
}
}
#line 25 "/home/june/collector/temp/aoeui-1.6~dfsg/display-test.c"
static void dprint(int row , int col , rgba_t fgrgba , rgba_t bgrgba , char const   *format 
                   , ...) 
{ 
  char buffer[256] ;
  char *p ;
  va_list ap ;
  int tmp ;

  {
  {
#line 30
  __builtin_va_start(ap, format);
#line 31
  vsnprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)format,
            ap);
#line 32
  __builtin_va_end(ap);
#line 33
  p = buffer;
  }
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! *p) {
#line 33
      goto while_break;
    }
    {
#line 34
    tmp = col;
#line 34
    col ++;
#line 34
    display_put(D, row, tmp, (Unicode_t )*p, fgrgba, bgrgba);
#line 33
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return;
}
}
#line 37 "/home/june/collector/temp/aoeui-1.6~dfsg/display-test.c"
static void dpause(void) 
{ 
  int ch ;
  Unicode_t tmp ;

  {
  {
#line 40
  dfill(rows - 1, 1, 0, columns, ' ', 4278190080U, 4294967040U);
#line 41
  dprint(rows - 1, 0, 4278190080U, 4294967040U, "Hit Q to quit, or any other key to continue...");
  }
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp = display_getch(D, (Boolean_t )1);
#line 42
    ch = (int )tmp;
    }
#line 42
    if (! ((unsigned int )ch == (((1U << 31) + 1U) + 256U) + 2U)) {
#line 42
      goto while_break;
    }
    {
#line 43
    display_get_geometry(D, & rows, & columns);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  if (ch == 113) {
    {
#line 45
    display_end(D);
#line 46
    exit(0);
    }
  } else
#line 44
  if (ch == 81) {
    {
#line 45
    display_end(D);
#line 46
    exit(0);
    }
  }
#line 48
  return;
}
}
#line 50 "/home/june/collector/temp/aoeui-1.6~dfsg/display-test.c"
void die(char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 53
  display_end(D);
#line 54
  __builtin_va_start(ap, msg);
#line 55
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           ap);
#line 56
  __builtin_va_end(ap);
#line 57
  exit(1);
  }
}
}
#line 60 "/home/june/collector/temp/aoeui-1.6~dfsg/display-test.c"
Boolean_t multiplexor(Boolean_t block ) 
{ 


  {
#line 62
  return ((Boolean_t )1);
}
}
#line 65 "/home/june/collector/temp/aoeui-1.6~dfsg/display-test.c"
int main(void) 
{ 
  int tmp ;

  {
  {
#line 67
  tmp = tcgetattr(1, & original_termios);
  }
#line 67
  if (tmp) {
    {
#line 68
    die("not running in a terminal");
    }
  }
  {
#line 69
  D = display_init();
#line 70
  display_get_geometry(D, & rows, & columns);
#line 71
  display_title(D, "display-test");
#line 72
  dprint(0, 0, (rgba_t )0, 4294967040U, "geometry: %d rows, %d columns", rows, columns);
#line 73
  dprint(1, 0, (rgba_t )255, (rgba_t )(~ 0), "default foreground and background");
#line 74
  dprint(2, 0, 4294967040U, (rgba_t )0, "white foreground on black background");
#line 75
  dprint(3, 0, (rgba_t )0, 4294967040U, "black foreground on white background");
#line 76
  dprint(4, 0, 4278190080U, (rgba_t )65280, "red foreground on blue background");
#line 77
  dprint(5, 0, (rgba_t )65280, 4278190080U, "blue foreground on red background");
#line 78
  dpause();
#line 80
  dfill(0, rows, 0, columns, '.', 4278190080U, (rgba_t )16711680);
#line 81
  dprint(0, 0, (rgba_t )65280, 4278190080U, "filled with red dots on green");
#line 82
  dpause();
#line 84
  display_erase(D, 0, 0, rows, columns);
#line 85
  dprint(0, 0, (rgba_t )65280, 4278190080U, "after ERASEALL display_erase()");
#line 86
  dpause();
#line 88
  dfill(0, rows, 0, columns, '.', 4278190080U, (rgba_t )16711680);
#line 89
  display_erase(D, rows / 2, 0, rows - rows / 2, columns);
#line 90
  dprint(0, 0, (rgba_t )65280, 4278190080U, "after ERASETOEND display_erase()");
#line 91
  dpause();
#line 93
  dfill(0, rows, 0, columns, '.', 4278190080U, (rgba_t )16711680);
#line 94
  display_erase(D, 1, columns / 2, 1, columns);
#line 95
  dprint(0, 0, (rgba_t )65280, 4278190080U, "after ERASELINE display_erase()");
#line 96
  dpause();
#line 98
  dfill(0, rows, 0, columns, '.', 4278190080U, (rgba_t )16711680);
#line 99
  display_erase(D, 1, 0, 1, columns / 2);
#line 100
  dprint(0, 0, (rgba_t )65280, 4278190080U, "after ERASECOLS display_erase()");
#line 101
  dpause();
#line 103
  dfill(0, rows, 0, columns, '.', 4278190080U, (rgba_t )16711680);
#line 104
  display_insert_lines(D, 2, 0, rows / 2, rows - 2, columns);
#line 105
  dprint(0, 0, (rgba_t )65280, 4278190080U, "after display_insert_lines()");
#line 106
  dpause();
#line 108
  dfill(0, rows, 0, columns, '.', 4278190080U, (rgba_t )16711680);
#line 109
  dfill(rows - 1, 1, 0, columns, '*', 4278190080U, (rgba_t )16711680);
#line 110
  display_delete_lines(D, 2, 0, rows / 2, rows - 2, columns);
#line 111
  dprint(0, 0, (rgba_t )65280, 4278190080U, "after display_delete_lines()");
#line 112
  dpause();
#line 114
  dfill(0, rows, 0, columns, '.', 4278190080U, (rgba_t )16711680);
#line 115
  display_insert_spaces(D, 2, 0, columns / 2, columns);
#line 116
  display_insert_spaces(D, 3, columns / 2, columns - columns / 2, columns);
#line 117
  dprint(0, 0, (rgba_t )65280, 4278190080U, "after display_insert_spaces()");
#line 118
  dpause();
#line 120
  dfill(0, rows, 0, columns, '.', 4278190080U, (rgba_t )16711680);
#line 121
  display_delete_chars(D, 2, 0, columns / 2, columns);
#line 122
  display_delete_chars(D, 3, columns / 2, columns - columns / 2, columns);
#line 123
  dprint(0, 0, (rgba_t )65280, 4278190080U, "after display_delete_chars()");
#line 124
  dpause();
#line 126
  display_end(D);
#line 127
  printf((char const   */* __restrict  */)"display-test done\n");
  }
#line 128
  return (0);
}
}
#line 21 "/home/june/collector/temp/aoeui-1.6~dfsg/locus.h"
locus_t locus_create(struct view *view , position_t offset ) ;
#line 22
void locus_destroy(struct view *view , locus_t locus ) ;
#line 23
position_t locus_get(struct view *view , locus_t locus ) ;
#line 24
position_t locus_set(struct view *view , locus_t locus , position_t offset ) ;
#line 25
void loci_adjust(struct view *view , position_t offset , int delta ) ;
#line 12 "/home/june/collector/temp/aoeui-1.6~dfsg/locus.c"
locus_t locus_create(struct view *view , position_t offset ) 
{ 
  locus_t locus ;
  void *tmp ;

  {
#line 16
  locus = (locus_t )0;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! (locus < view->loci)) {
#line 16
      goto while_break;
    }
#line 17
    if (*(view->locus + locus) == 0xfffffffffffffffeUL) {
#line 18
      goto while_break;
    }
#line 16
    locus ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 19
  if (locus == view->loci) {
    {
#line 20
    tmp = reallocate((void const   *)view->locus, (unsigned long )(locus + 1U) * sizeof(*(view->locus)));
#line 20
    view->locus = (position_t *)tmp;
#line 22
    (view->loci) ++;
    }
  }
  {
#line 24
  locus_set(view, locus, offset);
  }
#line 25
  return (locus);
}
}
#line 28 "/home/june/collector/temp/aoeui-1.6~dfsg/locus.c"
void locus_destroy(struct view *view , locus_t locus ) 
{ 


  {
#line 30
  if (locus < view->loci) {
#line 31
    *(view->locus + locus) = (position_t )-2;
  }
#line 32
  return;
}
}
#line 34 "/home/june/collector/temp/aoeui-1.6~dfsg/locus.c"
position_t locus_get(struct view *view , locus_t locus ) 
{ 
  position_t offset ;

  {
#line 38
  if (! view) {
#line 39
    return ((position_t )(~ 0));
  } else
#line 38
  if (locus >= view->loci) {
#line 39
    return ((position_t )(~ 0));
  }
#line 40
  offset = *(view->locus + locus);
#line 41
  if (offset == 0xffffffffffffffffUL) {
#line 42
    return ((position_t )(~ 0));
  }
#line 43
  if ((int )offset < 0) {
#line 44
    offset = (position_t )0;
  } else
#line 45
  if (offset > view->bytes) {
#line 46
    offset = view->bytes;
  }
#line 47
  return (offset);
}
}
#line 50 "/home/june/collector/temp/aoeui-1.6~dfsg/locus.c"
position_t locus_set(struct view *view , locus_t locus , position_t offset ) 
{ 


  {
#line 52
  if (offset != 0xffffffffffffffffUL) {
#line 52
    if (offset > view->bytes) {
#line 53
      offset = view->bytes;
    }
  }
#line 54
  if (locus < view->loci) {
#line 55
    *(view->locus + locus) = offset;
  }
#line 56
  return (offset);
}
}
#line 59 "/home/june/collector/temp/aoeui-1.6~dfsg/locus.c"
void loci_adjust(struct view *view , position_t offset , int delta ) 
{ 
  int j ;
  position_t limit ;
  position_t locus ;
  position_t locus___0 ;

  {
#line 63
  if (delta < 0) {
#line 64
    limit = offset - (position_t )delta;
#line 65
    j = 0;
    {
#line 65
    while (1) {
      while_continue: /* CIL Label */ ;
#line 65
      if (! ((unsigned int )j < view->loci)) {
#line 65
        goto while_break;
      }
#line 66
      locus = *(view->locus + j);
#line 67
      if (locus == 0xfffffffffffffffeUL) {
#line 68
        goto __Cont;
      } else
#line 67
      if (locus == 0xffffffffffffffffUL) {
#line 68
        goto __Cont;
      }
#line 69
      if (limit <= locus) {
#line 70
        locus += (position_t )delta;
      } else
#line 71
      if (offset < locus) {
#line 72
        if (j == 0) {
#line 72
          locus = offset;
        } else {
#line 72
          locus = (position_t )(~ 0);
        }
      }
#line 73
      *(view->locus + j) = locus;
      __Cont: /* CIL Label */ 
#line 65
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 76
    j = 0;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if (! ((unsigned int )j < view->loci)) {
#line 76
        goto while_break___0;
      }
#line 77
      locus___0 = *(view->locus + j);
#line 78
      if (locus___0 == 0xfffffffffffffffeUL) {
#line 79
        goto __Cont___0;
      } else
#line 78
      if (locus___0 == 0xffffffffffffffffUL) {
#line 79
        goto __Cont___0;
      }
#line 80
      if (offset <= locus___0) {
#line 81
        *(view->locus + j) = locus___0 + (position_t )delta;
      }
      __Cont___0: /* CIL Label */ 
#line 76
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 83
  return;
}
}
#line 9 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.h"
struct buffer *buffer_create(char *path ) ;
#line 10
void buffer_destroy(struct buffer *buffer ) ;
#line 11
size_t buffer_raw(struct buffer *buffer , char **out___1 , position_t offset , size_t bytes ) ;
#line 13
size_t buffer_delete(struct buffer *buffer , position_t offset , size_t bytes ) ;
#line 14
size_t buffer_insert(struct buffer *buffer , void const   *in , position_t offset ,
                     size_t bytes ) ;
#line 15
size_t buffer_move(struct buffer *to , position_t to_offset , struct buffer *from ,
                   position_t from_offset , size_t bytes ) ;
#line 30 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.h"
__inline static size_t buffer_bytes(struct buffer *buffer ) 
{ 
  size_t tmp ;

  {
#line 32
  if (buffer) {
#line 32
    tmp = buffer->payload;
  } else {
#line 32
    tmp = (size_t )0;
  }
#line 32
  return (tmp);
}
}
#line 78 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
void text_adjust_loci(struct text *text , position_t offset , int delta ) ;
#line 106
void text_dirty(struct text *text ) ;
#line 113
size_t text_delete(struct text *text , position_t offset , size_t bytes ) ;
#line 114
size_t text_insert(struct text *text , void const   *in , position_t offset , size_t bytes ) ;
#line 115
sposition_t text_undo(struct text *text ) ;
#line 116
sposition_t text_redo(struct text *text ) ;
#line 117
void text_forget_undo(struct text *text ) ;
#line 15 "/home/june/collector/temp/aoeui-1.6~dfsg/window.h"
void window_hint_deleting(struct window *window , position_t offset , size_t bytes ) ;
#line 16
void window_hint_inserted(struct window *window , position_t offset , size_t bytes ) ;
#line 14 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
static struct edit *last_edit(struct text *text ) 
{ 
  char *raw ;
  size_t tmp ;

  {
#line 16
  raw = (char *)((void *)0);
#line 18
  if (text->undo) {
#line 18
    if ((text->undo)->redo) {
      {
#line 18
      tmp = buffer_bytes((text->undo)->edits);
      }
#line 18
      if ((text->undo)->redo == tmp) {
        {
#line 21
        buffer_raw((text->undo)->edits, & raw, (text->undo)->redo - sizeof(struct edit ),
                   sizeof(struct edit ));
        }
      }
    }
  }
#line 24
  return ((struct edit *)raw);
}
}
#line 27 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
static void resume_editing(struct text *text ) 
{ 
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 29
  if (! text->undo) {
    {
#line 30
    tmp = allocate0(sizeof(*(text->undo)));
#line 30
    text->undo = (struct undo *)tmp;
#line 31
    (text->undo)->edits = buffer_create((char *)((void *)0));
#line 32
    (text->undo)->deleted = buffer_create((char *)((void *)0));
    }
  }
  {
#line 34
  tmp___0 = buffer_bytes((text->undo)->edits);
#line 34
  buffer_delete((text->undo)->edits, (text->undo)->redo, tmp___0 - (text->undo)->redo);
#line 36
  tmp___1 = buffer_bytes((text->undo)->deleted);
#line 36
  buffer_delete((text->undo)->deleted, (text->undo)->saved, tmp___1 - (text->undo)->saved);
  }
#line 38
  return;
}
}
#line 40 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
static Boolean_t in_view(struct view *view , position_t *offset , size_t *bytes ) 
{ 


  {
#line 42
  if (*offset < view->start) {
#line 43
    if (*offset + *bytes <= view->start) {
#line 44
      return ((Boolean_t )0);
    }
#line 45
    *bytes -= view->start - *offset;
#line 46
    *offset = (position_t )0;
  } else {
#line 48
    *offset -= view->start;
#line 49
    if (*offset >= view->bytes) {
#line 50
      return ((Boolean_t )0);
    }
#line 51
    if (*offset + *bytes > view->bytes) {
#line 52
      *bytes = view->bytes - *offset;
    }
  }
#line 54
  return ((Boolean_t )1);
}
}
#line 57 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
static void view_hint_deleting(struct view *view , position_t offset , size_t bytes ) 
{ 
  Boolean_t tmp ;

  {
#line 60
  if (view->window) {
    {
#line 60
    tmp = in_view(view, & offset, & bytes);
    }
#line 60
    if (tmp) {
      {
#line 61
      window_hint_deleting(view->window, offset, bytes);
      }
    }
  }
#line 62
  return;
}
}
#line 64 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
static void view_hint_inserted(struct view *view , position_t offset , size_t bytes ) 
{ 
  Boolean_t tmp ;

  {
#line 67
  if (view->window) {
    {
#line 67
    tmp = in_view(view, & offset, & bytes);
    }
#line 67
    if (tmp) {
      {
#line 68
      window_hint_inserted(view->window, offset, bytes);
      }
    }
  }
#line 69
  return;
}
}
#line 71 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
size_t text_delete(struct text *text , position_t offset , size_t bytes ) 
{ 
  char *old ;
  struct edit edit ;
  struct edit *last ;
  struct view *view ;
  size_t tmp ;

  {
#line 77
  if (! bytes) {
#line 78
    return ((size_t )0);
  }
  {
#line 79
  text_dirty(text);
#line 80
  edit.offset = offset;
#line 81
  tmp = buffer_raw(text->buffer, & old, offset, bytes);
#line 81
  edit.bytes = (ssize_t )tmp;
#line 82
  bytes = (size_t )edit.bytes;
#line 84
  last = last_edit(text);
  }
#line 84
  if (last) {
#line 84
    if (last->bytes >= 0L) {
#line 84
      if (last->offset == offset) {
#line 87
        last->bytes = (ssize_t )((size_t )last->bytes + bytes);
      } else {
        {
#line 89
        resume_editing(text);
#line 90
        buffer_insert((text->undo)->edits, (void const   *)(& edit), (text->undo)->redo,
                      sizeof(edit));
#line 92
        (text->undo)->redo += sizeof(edit);
        }
      }
    } else {
      {
#line 89
      resume_editing(text);
#line 90
      buffer_insert((text->undo)->edits, (void const   *)(& edit), (text->undo)->redo,
                    sizeof(edit));
#line 92
      (text->undo)->redo += sizeof(edit);
      }
    }
  } else {
    {
#line 89
    resume_editing(text);
#line 90
    buffer_insert((text->undo)->edits, (void const   *)(& edit), (text->undo)->redo,
                  sizeof(edit));
#line 92
    (text->undo)->redo += sizeof(edit);
    }
  }
#line 94
  view = text->views;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! view) {
#line 94
      goto while_break;
    }
    {
#line 95
    view_hint_deleting(view, offset, bytes);
#line 94
    view = view->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  buffer_move((text->undo)->deleted, (text->undo)->saved, text->buffer, offset, bytes);
#line 98
  (text->undo)->saved += bytes;
#line 99
  text_adjust_loci(text, offset, (int )(- bytes));
  }
#line 100
  return (bytes);
}
}
#line 103 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
size_t text_insert(struct text *text , void const   *in , position_t offset , size_t bytes ) 
{ 
  struct edit edit ;
  struct edit *last ;
  struct view *view ;

  {
#line 109
  if (! bytes) {
#line 110
    return ((size_t )0);
  }
  {
#line 111
  text_dirty(text);
#line 112
  bytes = buffer_insert(text->buffer, in, offset, bytes);
#line 113
  last = last_edit(text);
  }
#line 113
  if (last) {
#line 113
    if (last->bytes < 0L) {
#line 113
      if (last->offset - (position_t )last->bytes == offset) {
#line 116
        last->bytes = (ssize_t )((size_t )last->bytes - bytes);
      } else {
        {
#line 118
        resume_editing(text);
#line 119
        edit.offset = offset;
#line 120
        edit.bytes = (ssize_t )(- bytes);
#line 121
        buffer_insert((text->undo)->edits, (void const   *)(& edit), (text->undo)->redo,
                      sizeof(edit));
#line 123
        (text->undo)->redo += sizeof(edit);
        }
      }
    } else {
      {
#line 118
      resume_editing(text);
#line 119
      edit.offset = offset;
#line 120
      edit.bytes = (ssize_t )(- bytes);
#line 121
      buffer_insert((text->undo)->edits, (void const   *)(& edit), (text->undo)->redo,
                    sizeof(edit));
#line 123
      (text->undo)->redo += sizeof(edit);
      }
    }
  } else {
    {
#line 118
    resume_editing(text);
#line 119
    edit.offset = offset;
#line 120
    edit.bytes = (ssize_t )(- bytes);
#line 121
    buffer_insert((text->undo)->edits, (void const   *)(& edit), (text->undo)->redo,
                  sizeof(edit));
#line 123
    (text->undo)->redo += sizeof(edit);
    }
  }
  {
#line 125
  text_adjust_loci(text, offset, (int )bytes);
#line 126
  view = text->views;
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! view) {
#line 126
      goto while_break;
    }
    {
#line 127
    view_hint_inserted(view, offset, bytes);
#line 126
    view = view->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return (bytes);
}
}
#line 131 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
sposition_t text_undo(struct text *text ) 
{ 
  char *raw ;
  struct edit *edit ;
  position_t tmp ;
  position_t tmp___0 ;

  {
#line 136
  if (! text->undo) {
#line 137
    return ((sposition_t )-1);
  } else
#line 136
  if (! (text->undo)->redo) {
#line 137
    return ((sposition_t )-1);
  }
  {
#line 138
  text_dirty(text);
#line 139
  tmp = (text->undo)->redo - sizeof(*edit);
#line 139
  (text->undo)->redo = tmp;
#line 139
  buffer_raw((text->undo)->edits, & raw, tmp, sizeof(*edit));
#line 141
  edit = (struct edit *)raw;
  }
#line 142
  if (edit->bytes >= 0L) {
    {
#line 143
    tmp___0 = (text->undo)->saved - (position_t )edit->bytes;
#line 143
    (text->undo)->saved = tmp___0;
#line 143
    buffer_move(text->buffer, edit->offset, (text->undo)->deleted, tmp___0, (size_t )edit->bytes);
    }
  } else {
    {
#line 146
    buffer_move((text->undo)->deleted, (text->undo)->saved, text->buffer, edit->offset,
                (size_t )(- edit->bytes));
    }
  }
  {
#line 148
  text_adjust_loci(text, edit->offset, (int )edit->bytes);
  }
#line 149
  return ((sposition_t )edit->offset);
}
}
#line 152 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
sposition_t text_redo(struct text *text ) 
{ 
  char *raw ;
  struct edit *edit ;
  size_t tmp ;

  {
#line 157
  if (! text->undo) {
#line 159
    return ((sposition_t )-1);
  } else {
    {
#line 157
    tmp = buffer_bytes((text->undo)->edits);
    }
#line 157
    if ((text->undo)->redo == tmp) {
#line 159
      return ((sposition_t )-1);
    }
  }
  {
#line 160
  text_dirty(text);
#line 161
  buffer_raw((text->undo)->edits, & raw, (text->undo)->redo, sizeof(*edit));
#line 162
  edit = (struct edit *)raw;
#line 163
  (text->undo)->redo += sizeof(*edit);
  }
#line 164
  if (edit->bytes >= 0L) {
    {
#line 165
    buffer_move((text->undo)->deleted, (text->undo)->saved, text->buffer, edit->offset,
                (size_t )edit->bytes);
#line 167
    (text->undo)->saved += (position_t )edit->bytes;
    }
  } else {
    {
#line 169
    buffer_move(text->buffer, edit->offset, (text->undo)->deleted, (text->undo)->saved,
                (size_t )(- edit->bytes));
    }
  }
  {
#line 171
  text_adjust_loci(text, edit->offset, (int )(- edit->bytes));
  }
#line 172
  return ((sposition_t )edit->offset);
}
}
#line 175 "/home/june/collector/temp/aoeui-1.6~dfsg/undo.c"
void text_forget_undo(struct text *text ) 
{ 


  {
#line 177
  if (text->undo) {
    {
#line 178
    buffer_destroy((text->undo)->edits);
#line 179
    buffer_destroy((text->undo)->deleted);
#line 180
    reallocate((void const   *)text->undo, (size_t )0);
#line 180
    text->undo = (struct undo *)((void *)0);
    }
  }
#line 182
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 134 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) killpg)(__pid_t __pgrp ,
                                                                             int __sig ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 33 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) openpty)(int *__amaster ,
                                                                              int *__aslave ,
                                                                              char *__name ,
                                                                              struct termios  const  *__termp ,
                                                                              struct winsize  const  *__winp ) ;
#line 82 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
size_t view_insert(struct view *view , void const   *in , position_t offset , ssize_t bytes ) ;
#line 126
void demultiplex_view(struct view *view ) ;
#line 20 "/home/june/collector/temp/aoeui-1.6~dfsg/window.h"
void window_beep(struct view *view ) ;
#line 10 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
position_t find_line_start(struct view *view , position_t offset ) ;
#line 42
char *view_extract(struct view *view , position_t offset , unsigned int bytes ) ;
#line 43
char *view_extract_selection(struct view *view ) ;
#line 44
size_t view_delete_selection(struct view *view ) ;
#line 5 "/home/june/collector/temp/aoeui-1.6~dfsg/clip.h"
size_t clip_paste(struct view *view , position_t offset , unsigned int reg ) ;
#line 6 "/home/june/collector/temp/aoeui-1.6~dfsg/die.h"
void message(char const   *msg  , ...) ;
#line 5 "/home/june/collector/temp/aoeui-1.6~dfsg/child.h"
void mode_child(struct view *view ) ;
#line 6
void mode_shell_pipe(struct view *view ) ;
#line 7
void shell_command(struct view *view , Unicode_t ch ) ;
#line 8
void background_command(char const   *command___0 ) ;
#line 11
void multiplex_write(fd_t fd , char const   *data , ssize_t bytes , Boolean_t retain ) ;
#line 16 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static struct stream *streams  ;
#line 31 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static Boolean_t insertion_activity(struct stream *stream , char *received , ssize_t bytes ) 
{ 
  position_t offset ;

  {
#line 35
  if (bytes <= 0L) {
#line 36
    return ((Boolean_t )0);
  }
  {
#line 37
  offset = locus_get(stream->view, stream->locus);
  }
#line 38
  if (offset == 0xffffffffffffffffUL) {
#line 39
    return ((Boolean_t )0);
  }
  {
#line 40
  view_insert(stream->view, (void const   *)received, offset, bytes);
#line 41
  locus_set(stream->view, stream->locus, offset + (position_t )bytes);
  }
#line 42
  return ((Boolean_t )1);
}
}
#line 45 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static Boolean_t shell_output_activity(struct stream *stream , char *received , ssize_t bytes ) 
{ 
  position_t offset ;
  struct view *view ;
  locus_t locus ;
  char ch ;
  char *tmp ;
  position_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 49
  view = stream->view;
#line 50
  locus = view->shell_out_locus;
#line 52
  if (bytes <= 0L) {
#line 53
    return ((Boolean_t )0);
  }
  {
#line 54
  offset = locus_get(view, locus);
  }
#line 55
  if (offset == 0xffffffffffffffffUL) {
#line 56
    offset = view->bytes;
  } else {
#line 58
    offset ++;
  }
  {
#line 59
  locus_set(view, locus, offset);
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    tmp___1 = bytes;
#line 61
    bytes --;
#line 61
    if (! tmp___1) {
#line 61
      goto while_break;
    }
#line 62
    tmp = received;
#line 62
    received ++;
#line 62
    ch = *tmp;
#line 63
    if ((int )ch != 13) {
#line 63
      if ((int )ch != 8) {
#line 64
        if ((int )ch == 10) {
          {
#line 65
          offset = locus_get(view, locus);
          }
        }
        {
#line 66
        tmp___0 = offset;
#line 66
        offset ++;
#line 66
        view_insert(view, (void const   *)(& ch), tmp___0, (ssize_t )1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  offset = locus_get(view, locus);
#line 71
  locus_set(view, locus, offset - (position_t )(! (! offset)));
  }
#line 72
  return ((Boolean_t )1);
}
}
#line 75 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static Boolean_t error_activity(struct stream *stream , char *received , ssize_t bytes ) 
{ 


  {
#line 78
  if (bytes <= 0L) {
#line 79
    return ((Boolean_t )0);
  }
  {
#line 80
  *(received + bytes) = (char )'\000';
#line 81
  message("%s", received);
  }
#line 82
  return ((Boolean_t )1);
}
}
#line 85 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static Boolean_t out_activity(struct stream *stream , char *x , ssize_t bytes ) 
{ 
  ssize_t chunk ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 87
  chunk = (ssize_t )(stream->bytes - stream->writ);
#line 89
  if (chunk <= 0L) {
#line 90
    return ((Boolean_t )0);
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    tmp = __errno_location();
#line 92
    *tmp = 0;
#line 93
    bytes = write(stream->fd, (void const   *)(stream->data + stream->writ), (size_t )chunk);
    }
#line 91
    if (bytes < 0L) {
      {
#line 91
      tmp___0 = __errno_location();
      }
#line 91
      if (! (*tmp___0 == 11)) {
        {
#line 91
        tmp___1 = __errno_location();
        }
#line 91
        if (! (*tmp___1 == 4)) {
#line 91
          goto while_break;
        }
      }
    } else {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if (bytes < 0L) {
    {
#line 97
    tmp___2 = __errno_location();
    }
#line 97
    if (*tmp___2 == 32) {
      {
#line 98
      message("write failed (child terminated?)");
      }
#line 99
      return ((Boolean_t )0);
    } else {
      {
#line 97
      tmp___3 = __errno_location();
      }
#line 97
      if (*tmp___3 == 5) {
        {
#line 98
        message("write failed (child terminated?)");
        }
#line 99
        return ((Boolean_t )0);
      }
    }
  }
#line 101
  if (bytes <= 0L) {
    {
#line 102
    die("write of %d bytes failed", chunk);
    }
  }
#line 103
  stream->writ += (size_t )bytes;
#line 104
  return ((Boolean_t )(bytes > 0L));
}
}
#line 107 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static struct stream *stream_create(fd_t fd ) 
{ 
  struct stream *stream ;
  void *tmp ;
  struct stream *prev ;

  {
  {
#line 109
  tmp = allocate0(sizeof(*stream));
#line 109
  stream = (struct stream *)tmp;
#line 111
  stream->fd = fd;
#line 112
  stream->locus = ~ 0U;
  }
#line 113
  if (! streams) {
#line 114
    streams = stream;
  } else {
#line 116
    prev = streams;
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 117
      if (! prev->next) {
#line 117
        goto while_break;
      }
#line 118
      prev = prev->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 119
    prev->next = stream;
  }
#line 121
  return (stream);
}
}
#line 124 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static void stream_destroy(struct stream *stream , struct stream *prev ) 
{ 


  {
#line 126
  if (! stream->retain) {
    {
#line 127
    close(stream->fd);
    }
  }
#line 128
  if (stream->view) {
    {
#line 129
    locus_destroy(stream->view, stream->locus);
    }
  }
#line 130
  if (prev) {
#line 131
    prev->next = stream->next;
  } else {
#line 133
    streams = stream->next;
  }
  {
#line 134
  reallocate((void const   *)stream->data, (size_t )0);
#line 134
  stream->data = (char const   *)((void *)0);
#line 135
  reallocate((void const   *)stream, (size_t )0);
#line 135
  stream = (struct stream *)((void *)0);
  }
#line 136
  return;
}
}
#line 192 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static void child_close(struct view *view ) 
{ 


  {
#line 194
  if (view->shell_std_in >= 0) {
    {
#line 195
    close(view->shell_std_in);
#line 196
    view->shell_std_in = -1;
    }
  }
#line 198
  if (view->shell_pg >= 0) {
    {
#line 199
    killpg(view->shell_pg, 1);
#line 200
    view->shell_pg = -1;
    }
  }
  {
#line 202
  locus_destroy(view, view->shell_out_locus);
#line 203
  view->shell_out_locus = ~ 0U;
  }
#line 204
  return;
}
}
#line 206 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
void demultiplex_view(struct view *view ) 
{ 
  struct stream *stream ;
  struct stream *prev ;
  struct stream *next ;

  {
#line 208
  prev = (struct stream *)((void *)0);
#line 210
  stream = streams;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! stream) {
#line 210
      goto while_break;
    }
#line 211
    next = stream->next;
#line 212
    if ((unsigned long )stream->view == (unsigned long )view) {
      {
#line 213
      stream_destroy(stream, prev);
      }
    } else {
#line 215
      prev = stream;
    }
#line 210
    stream = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  child_close(view);
  }
#line 218
  return;
}
}
#line 220 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
void multiplex_write(fd_t fd , char const   *data , ssize_t bytes , Boolean_t retain ) 
{ 
  struct stream *stream ;
  size_t tmp ;

  {
#line 224
  if (bytes < 0L) {
#line 225
    if (data) {
      {
#line 225
      tmp = strlen(data);
#line 225
      bytes = (ssize_t )tmp;
      }
    } else {
#line 225
      bytes = (ssize_t )0;
    }
  }
#line 226
  if (! bytes) {
#line 227
    if (! retain) {
      {
#line 228
      close(fd);
      }
    }
#line 229
    return;
  }
  {
#line 231
  stream = stream_create(fd);
#line 232
  stream->retain = retain;
#line 233
  stream->activity = & out_activity;
#line 234
  stream->data = data;
#line 235
  stream->bytes = (size_t )bytes;
  }
#line 236
  return;
}
}
#line 238 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static void single_write(fd_t fd , Unicode_t ch ) 
{ 
  char buf[8] ;
  size_t len ;
  size_t tmp ;
  char *single ;
  void *tmp___0 ;

  {
  {
#line 241
  tmp = unicode_utf8(buf, ch);
#line 241
  len = tmp;
#line 242
  tmp___0 = reallocate((void const   *)((void *)0), len);
#line 242
  single = (char *)tmp___0;
#line 244
  memcpy((void */* __restrict  */)single, (void const   */* __restrict  */)(buf),
         len);
#line 245
  multiplex_write(fd, (char const   *)single, (ssize_t )len, (Boolean_t )1);
  }
#line 246
  return;
}
}
#line 251
static Boolean_t pipes(fd_t (*fd)[2] , unsigned int stdfds ) ;
#line 251 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static Boolean_t use_ptys  =    (Boolean_t )1;
#line 248 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static Boolean_t pipes(fd_t (*fd)[2] , unsigned int stdfds ) 
{ 
  int j ;
  int k ;
  struct termios termios ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 257
  if (stdfds == 2U) {
#line 257
    if (use_ptys) {
      {
#line 258
      termios = original_termios;
#line 259
      termios.c_oflag &= 4294967291U;
#line 260
      termios.c_lflag &= 4294965223U;
#line 261
      termios.c_lflag |= 32U;
#line 262
      tmp = __errno_location();
#line 262
      *tmp = 0;
#line 263
      tmp___0 = openpty(& (*(fd + 0))[0], & (*(fd + 0))[1], (char *)((void *)0), (struct termios  const  *)(& termios),
                        (struct winsize  const  *)((void *)0));
      }
#line 263
      if (! tmp___0) {
#line 264
        j = 1;
        {
#line 264
        while (1) {
          while_continue: /* CIL Label */ ;
#line 264
          if (! (j < 3)) {
#line 264
            goto while_break;
          }
#line 265
          k = 0;
          {
#line 265
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 265
            if (! (k < 2)) {
#line 265
              goto while_break___0;
            }
            {
#line 266
            (*(fd + j))[k] = dup((*(fd + 0))[k]);
#line 265
            k ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 264
          j ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 267
        return ((Boolean_t )1);
      }
      {
#line 269
      message("could not create pty");
#line 270
      use_ptys = (Boolean_t )0;
      }
    }
  }
  {
#line 274
  tmp___1 = __errno_location();
#line 274
  *tmp___1 = 0;
#line 275
  j = 0;
  }
  {
#line 275
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 275
    if (! ((unsigned int )j < stdfds)) {
#line 275
      goto while_break___1;
    }
    {
#line 276
    tmp___2 = pipe((int *)(*(fd + j)));
    }
#line 276
    if (tmp___2) {
      {
#line 277
      message("could not create pipes");
      }
#line 278
      return ((Boolean_t )0);
    }
#line 275
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 281
  j = (*(fd + 0))[0];
#line 281
  (*(fd + 0))[0] = (*(fd + 0))[1];
#line 281
  (*(fd + 0))[1] = j;
#line 282
  return ((Boolean_t )1);
}
}
#line 285 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static pid_t child(fd_t (*stdfd)[2] , unsigned int stdfds , char const   **argv ) 
{ 
  int j ;
  pid_t pid ;
  Boolean_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 290
  tmp = pipes(stdfd, stdfds);
  }
#line 290
  if (! tmp) {
#line 291
    return (-1);
  }
  {
#line 292
  fflush((FILE *)((void *)0));
#line 293
  tmp___0 = __errno_location();
#line 293
  *tmp___0 = 0;
#line 294
  pid = fork();
  }
#line 294
  if (pid < 0) {
    {
#line 295
    message("could not fork");
    }
#line 296
    return (-1);
  }
#line 299
  if (pid) {
#line 300
    return (pid);
  }
#line 303
  j = 0;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (j < 3)) {
#line 303
      goto while_break;
    }
    {
#line 304
    close((*(stdfd + j))[0]);
#line 305
    tmp___1 = __errno_location();
#line 305
    *tmp___1 = 0;
#line 306
    tmp___4 = dup2((*(stdfd + j))[1], j);
    }
#line 306
    if (tmp___4 != j) {
      {
#line 307
      tmp___2 = __errno_location();
#line 307
      tmp___3 = strerror(*tmp___2);
#line 307
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dup2(%d,%d) failed: %s\n",
              (*(stdfd + j))[1], j, tmp___3);
#line 309
      exit(1);
      }
    }
    {
#line 311
    close((*(stdfd + j))[1]);
#line 303
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 314
  tmp___5 = isatty(0);
  }
#line 314
  if (tmp___5) {
    {
#line 315
    pid = setsid();
#line 316
    ioctl(0, 21518UL);
#line 317
    ioctl(0, 21520UL, & pid);
    }
  }
  {
#line 319
  setenv("TERM", "network", 1);
#line 320
  unsetenv("LS_COLORS");
#line 322
  tmp___6 = __errno_location();
#line 322
  *tmp___6 = 0;
#line 323
  execvp(*(argv + 0), (char * const  *)argv);
#line 325
  tmp___7 = __errno_location();
#line 325
  tmp___8 = strerror(*tmp___7);
#line 325
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not execute %s: %s\n",
          *(argv + 0), tmp___8);
#line 327
  exit(1);
  }
}
}
#line 330 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
static char const   *shell_name(void) 
{ 
  char const   *shell ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 332
  tmp = getenv("SHELL");
#line 332
  shell = (char const   *)tmp;
#line 333
  tmp___0 = access(shell, 1);
  }
#line 333
  if (tmp___0) {
#line 334
    shell = "/bin/sh";
  }
#line 335
  return (shell);
}
}
#line 338 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
void mode_child(struct view *view ) 
{ 
  char *command___0 ;
  char *tmp ;
  char *wrbuff ;
  position_t cursor ;
  size_t to_write ;
  fd_t stdfd[3][2] ;
  char const   *argv[4] ;
  struct stream *std_out ;
  struct stream *std_err ;
  int j ;
  size_t tmp___0 ;
  char const   *dir ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  pid_t tmp___4 ;

  {
  {
#line 340
  tmp = view_extract_selection(view);
#line 340
  command___0 = tmp;
#line 341
  wrbuff = (char *)((void *)0);
  }
#line 349
  if (! command___0) {
    {
#line 350
    window_beep(view);
    }
#line 351
    return;
  }
#line 354
  if (view->shell_std_in >= 0) {
    {
#line 355
    locus_set(view, (locus_t )1, (position_t )(~ 0));
#line 356
    tmp___0 = strlen((char const   *)command___0);
#line 356
    multiplex_write(view->shell_std_in, (char const   *)command___0, (ssize_t )tmp___0,
                    (Boolean_t )1);
#line 358
    single_write(view->shell_std_in, (Unicode_t )'\n');
    }
#line 359
    return;
  }
  {
#line 362
  view_delete_selection(view);
  }
#line 364
  if ((int )*(command___0 + 0) == 99) {
#line 364
    if ((int )*(command___0 + 1) == 100) {
#line 364
      if (! *(command___0 + 2)) {
#line 364
        goto _L___0;
      } else
#line 364
      if ((int )*(command___0 + 2) == 32) {
        _L___0: /* CIL Label */ 
#line 366
        dir = (char const   *)(command___0 + 2);
        {
#line 367
        while (1) {
          while_continue: /* CIL Label */ ;
#line 367
          if (! ((int const   )*dir == 32)) {
#line 367
            goto while_break;
          }
#line 368
          dir ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 369
        if (! *dir) {
          {
#line 369
          tmp___3 = getenv("HOME");
#line 369
          dir = (char const   *)tmp___3;
          }
#line 369
          if (dir) {
#line 369
            goto _L;
          } else {
            {
#line 370
            window_beep(view);
            }
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 372
          tmp___1 = __errno_location();
#line 372
          *tmp___1 = 0;
#line 373
          tmp___2 = chdir(dir);
          }
#line 373
          if (tmp___2) {
            {
#line 374
            message("%s failed", command___0);
            }
          }
        }
#line 376
        return;
      }
    }
  }
  {
#line 378
  cursor = locus_get(view, (locus_t )0);
#line 379
  to_write = clip_paste(view, cursor, 0U);
  }
#line 380
  if (to_write) {
    {
#line 381
    locus_set(view, (locus_t )1, cursor);
#line 382
    wrbuff = view_extract_selection(view);
#line 383
    view_delete_selection(view);
    }
  }
  {
#line 386
  argv[0] = shell_name();
#line 387
  argv[1] = "-c";
#line 388
  argv[2] = (char const   *)command___0;
#line 389
  argv[3] = (char const   *)((void *)0);
#line 390
  tmp___4 = child((fd_t (*)[2])(stdfd), 3U, argv);
  }
#line 390
  if (tmp___4 < 0) {
#line 391
    return;
  }
#line 393
  j = 0;
  {
#line 393
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 393
    if (! (j < 3)) {
#line 393
      goto while_break___0;
    }
    {
#line 394
    close(stdfd[j][1]);
#line 393
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 396
  multiplex_write(stdfd[0][0], (char const   *)wrbuff, (ssize_t )to_write, (Boolean_t )0);
#line 397
  std_out = stream_create(stdfd[1][0]);
#line 398
  std_out->activity = & insertion_activity;
#line 399
  std_out->view = view;
#line 400
  std_out->locus = locus_create(view, cursor);
#line 401
  std_err = stream_create(stdfd[2][0]);
#line 402
  std_err->activity = & error_activity;
  }
#line 403
  return;
}
}
#line 405 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
void mode_shell_pipe(struct view *view ) 
{ 
  fd_t stdfd[3][2] ;
  char const   *shell ;
  char const   *p ;
  char const   *argv[8] ;
  struct stream *output ;
  int j ;
  int ai ;
  pid_t pg ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  position_t tmp___4 ;

  {
  {
#line 410
  ai = 0;
#line 413
  tmp = ai;
#line 413
  ai ++;
#line 413
  shell = shell_name();
#line 413
  argv[tmp] = shell;
#line 414
  tmp___1 = strrchr(shell, '/');
#line 414
  p = (char const   *)tmp___1;
  }
#line 414
  if (p) {
    {
#line 414
    tmp___2 = strcmp(p + 1, "bash");
    }
#line 414
    if (! tmp___2) {
#line 415
      tmp___0 = ai;
#line 415
      ai ++;
#line 415
      argv[tmp___0] = "--noediting";
    }
  }
  {
#line 416
  tmp___3 = ai;
#line 416
  ai ++;
#line 416
  argv[tmp___3] = (char const   *)((void *)0);
#line 418
  pg = child((fd_t (*)[2])(stdfd), 2U, argv);
  }
#line 418
  if (pg < 0) {
#line 419
    return;
  }
  {
#line 421
  close(stdfd[2][0]);
#line 422
  j = 0;
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (j < 3)) {
#line 422
      goto while_break;
    }
    {
#line 423
    close(stdfd[j][1]);
#line 422
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 425
  child_close(view);
#line 426
  tmp___4 = locus_get(view, (locus_t )0);
#line 426
  view->shell_out_locus = locus_create(view, tmp___4);
#line 427
  view->shell_pg = pg;
#line 428
  output = stream_create(stdfd[1][0]);
#line 429
  output->activity = & shell_output_activity;
#line 430
  output->view = view;
#line 431
  view->shell_std_in = stdfd[0][0];
  }
#line 432
  return;
}
}
#line 434 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
void shell_command(struct view *view , Unicode_t ch ) 
{ 
  position_t offset ;
  position_t linestart ;
  position_t cursor ;
  char *command___0 ;
  position_t tmp ;
  position_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 439
  if (ch >= 32U) {
#line 440
    return;
  } else
#line 439
  if (ch == 9U) {
#line 440
    return;
  }
  {
#line 442
  cursor = locus_get(view, (locus_t )0);
  }
#line 443
  if (cursor) {
    {
#line 443
    tmp = find_line_start(view, cursor - 1UL);
#line 443
    linestart = tmp;
    }
  } else {
#line 443
    linestart = (position_t )0;
  }
  {
#line 444
  tmp___0 = locus_get(view, view->shell_out_locus);
#line 444
  offset = tmp___0 + 1UL;
  }
#line 445
  if (offset < linestart) {
#line 446
    offset = linestart;
  } else
#line 445
  if (offset >= cursor) {
#line 446
    offset = linestart;
  }
  {
#line 447
  command___0 = view_extract(view, offset, (unsigned int )(cursor - offset));
  }
#line 448
  if (command___0) {
    {
#line 449
    multiplex_write(view->shell_std_in, (char const   *)command___0, (ssize_t )-1,
                    (Boolean_t )1);
    }
  }
#line 451
  if (view->bytes) {
#line 451
    tmp___1 = view->bytes - 1UL;
  } else {
#line 451
    tmp___1 = (size_t )(~ 0);
  }
  {
#line 451
  locus_set(view, view->shell_out_locus, tmp___1);
#line 453
  locus_set(view, (locus_t )0, view->bytes);
  }
#line 454
  return;
}
}
#line 456 "/home/june/collector/temp/aoeui-1.6~dfsg/child.c"
void background_command(char const   *command___0 ) 
{ 
  int j ;
  pid_t pg ;
  fd_t stdfd[3][2] ;
  char const   *argv[4] ;
  struct stream *std_out ;
  struct stream *std_err ;

  {
  {
#line 464
  argv[0] = shell_name();
#line 465
  argv[1] = "-c";
#line 466
  argv[2] = command___0;
#line 467
  argv[3] = (char const   *)((void *)0);
#line 468
  pg = child((fd_t (*)[2])(stdfd), 3U, argv);
  }
#line 468
  if (pg < 0) {
#line 469
    return;
  }
#line 470
  j = 0;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! (j < 3)) {
#line 470
      goto while_break;
    }
    {
#line 471
    close(stdfd[j][1]);
#line 470
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 472
  close(stdfd[0][0]);
#line 473
  std_out = stream_create(stdfd[1][0]);
#line 474
  std_out->activity = & error_activity;
#line 475
  std_err = stream_create(stdfd[2][0]);
#line 476
  std_err->activity = & error_activity;
#line 477
  waitpid(pg, (int *)((void *)0), 0);
  }
#line 478
  return;
}
}
#line 21 "/home/june/collector/temp/aoeui-1.6~dfsg/window.h"
Unicode_t window_getch(void) ;
#line 5 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.h"
struct macro *macro_record(void) ;
#line 6
Boolean_t macro_end_recording(Unicode_t chop ) ;
#line 7
Boolean_t macro_play(struct macro *macro , int repeat ) ;
#line 8
void macros_abort(void) ;
#line 9
void macro_free(struct macro *macro ) ;
#line 10
Unicode_t macro_getch(void) ;
#line 11 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
static struct buffer *macbuf  ;
#line 12 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
static struct macro *macros  ;
#line 13 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
static struct macro *recording  ;
#line 13 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
static struct macro *playing  ;
#line 15 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
struct macro *macro_record(void) 
{ 
  struct macro *new ;
  void *tmp ;

  {
#line 18
  if (! macbuf) {
    {
#line 19
    macbuf = buffer_create((char *)((void *)0));
    }
  }
  {
#line 20
  tmp = allocate0(sizeof(*new));
#line 20
  new = (struct macro *)tmp;
#line 21
  new->next = macros;
#line 22
  new->start = buffer_bytes(macbuf);
#line 23
  recording = new;
#line 23
  macros = recording;
  }
#line 23
  return (macros);
}
}
#line 26 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
Boolean_t macro_end_recording(Unicode_t chop ) 
{ 
  char *raw ;
  size_t n ;
  size_t lastlen ;
  size_t tmp ;
  Unicode_t tmp___0 ;

  {
#line 31
  if (! recording) {
#line 32
    return ((Boolean_t )0);
  }
  {
#line 33
  n = buffer_raw(macbuf, & raw, recording->start, recording->bytes);
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! n) {
#line 35
      goto while_break;
    }
    {
#line 36
    tmp = utf8_length_backwards((char const   *)((raw + n) - 1), n);
#line 36
    lastlen = tmp;
#line 37
    n -= lastlen;
#line 38
    tmp___0 = utf8_unicode((char const   *)(raw + n), lastlen);
    }
#line 38
    if (tmp___0 == chop) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 41
  buffer_delete(macbuf, recording->start + n, recording->bytes - n);
#line 42
  recording->bytes = n;
#line 43
  recording->at = recording->bytes;
#line 44
  recording = (struct macro *)((void *)0);
  }
#line 45
  return ((Boolean_t )1);
}
}
#line 48 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
static Boolean_t macro_is_playing(struct macro *macro ) 
{ 
  int tmp ;

  {
#line 50
  if (macro) {
#line 50
    if (macro->at < macro->bytes) {
#line 50
      tmp = 1;
    } else {
#line 50
      tmp = 0;
    }
  } else {
#line 50
    tmp = 0;
  }
#line 50
  return ((Boolean_t )tmp);
}
}
#line 53 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
Boolean_t macro_play(struct macro *macro , int repeat ) 
{ 
  Boolean_t tmp ;

  {
#line 55
  if (! macro) {
#line 58
    return ((Boolean_t )0);
  } else {
    {
#line 55
    tmp = macro_is_playing(macro);
    }
#line 55
    if (tmp) {
#line 58
      return ((Boolean_t )0);
    } else
#line 55
    if (! macro->bytes) {
#line 58
      return ((Boolean_t )0);
    }
  }
#line 59
  macro->suspended = playing;
#line 60
  macro->at = (position_t )0;
#line 61
  macro->repeat = repeat;
#line 62
  playing = macro;
#line 63
  return ((Boolean_t )1);
}
}
#line 66 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
void macros_abort(void) 
{ 


  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! playing) {
#line 68
      goto while_break;
    }
#line 69
    playing->at = playing->bytes;
#line 68
    playing = playing->suspended;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
void macro_free(struct macro *macro ) 
{ 
  struct macro *previous ;
  struct macro *mac ;
  struct macro *next ;
  Boolean_t tmp ;

  {
#line 74
  previous = (struct macro *)((void *)0);
#line 75
  if (! macro) {
#line 76
    return;
  }
#line 77
  if (recording) {
#line 78
    recording = (struct macro *)((void *)0);
  } else {
    {
#line 79
    tmp = macro_is_playing(macro);
    }
#line 79
    if (tmp) {
      {
#line 80
      macros_abort();
      }
    }
  }
#line 81
  mac = macros;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((unsigned long )mac != (unsigned long )macro)) {
#line 81
      goto while_break;
    }
#line 82
    next = mac->next;
#line 83
    if ((unsigned long )mac == (unsigned long )macro) {
#line 84
      if (previous) {
#line 85
        previous->next = next;
      } else {
#line 87
        macros = next;
      }
    } else
#line 88
    if (mac->start > macro->start) {
#line 89
      mac->start -= macro->bytes;
    }
#line 81
    previous = mac;
#line 81
    mac = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  buffer_delete(macbuf, macro->start, macro->bytes);
#line 92
  reallocate((void const   *)macro, (size_t )0);
#line 92
  macro = (struct macro *)((void *)0);
  }
#line 93
  return;
}
}
#line 95 "/home/june/collector/temp/aoeui-1.6~dfsg/macro.c"
Unicode_t macro_getch(void) 
{ 
  Unicode_t ch ;
  char *p ;
  size_t n ;
  size_t tmp ;
  int tmp___0 ;
  position_t tmp___1 ;
  char buf[8] ;
  size_t n___0 ;
  size_t tmp___2 ;

  {
#line 99
  if (playing) {
    {
#line 101
    tmp = buffer_raw(macbuf, & p, playing->start + playing->at, playing->bytes - playing->at);
#line 101
    n = tmp;
#line 103
    n = utf8_length((char const   *)p, n);
#line 103
    ch = utf8_unicode((char const   *)p, n);
#line 104
    tmp___1 = playing->at + n;
#line 104
    playing->at = tmp___1;
    }
#line 104
    if (tmp___1 == playing->bytes) {
#line 105
      tmp___0 = playing->repeat;
#line 105
      (playing->repeat) --;
#line 105
      if (tmp___0 > 1) {
#line 106
        playing->at = (position_t )0;
      } else {
#line 108
        playing = playing->suspended;
      }
    }
  } else {
    {
#line 110
    ch = window_getch();
    }
#line 111
    if (! (ch >= ((1U << 31) + 1U) + 256U)) {
#line 111
      if (recording) {
        {
#line 113
        tmp___2 = unicode_utf8(buf, ch);
#line 113
        n___0 = tmp___2;
#line 114
        buffer_insert(macbuf, (void const   *)(buf), recording->start + recording->bytes,
                      n___0);
#line 117
        recording->bytes += n___0;
        }
      }
    }
  }
#line 120
  return (ch);
}
}
#line 120 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
void bookmark_set(unsigned int id , struct view *view , position_t cursor , position_t mark ) ;
#line 121
Boolean_t bookmark_get(struct view **view , position_t *cursor , position_t *mark ,
                       unsigned int id ) ;
#line 123
void bookmark_unset(unsigned int id ) ;
#line 124
void bookmark_unset_view(struct view *view ) ;
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/bookmark.c"
static struct bookmark *bookmarks  ;
#line 11 "/home/june/collector/temp/aoeui-1.6~dfsg/bookmark.c"
void bookmark_set(unsigned int id , struct view *view , position_t cursor , position_t mark ) 
{ 
  struct bookmark *bm ;
  void *tmp ;

  {
  {
#line 14
  tmp = allocate0(sizeof(*bm));
#line 14
  bm = (struct bookmark *)tmp;
#line 16
  bookmark_unset(id);
#line 17
  bm->id = id;
#line 18
  bm->view = view;
#line 19
  bm->locus[0] = locus_create(view, cursor);
#line 20
  bm->locus[1] = locus_create(view, mark);
#line 21
  bm->next = bookmarks;
#line 22
  bookmarks = bm;
  }
#line 23
  return;
}
}
#line 25 "/home/june/collector/temp/aoeui-1.6~dfsg/bookmark.c"
Boolean_t bookmark_get(struct view **view , position_t *cursor , position_t *mark ,
                       unsigned int id ) 
{ 
  struct bookmark *bm ;
  position_t tmp ;

  {
#line 29
  bm = bookmarks;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! bm) {
#line 29
      goto while_break;
    }
#line 30
    if (bm->id == id) {
      {
#line 31
      *view = bm->view;
#line 32
      *cursor = locus_get(bm->view, bm->locus[0]);
      }
#line 33
      if (*cursor == 0xffffffffffffffffUL) {
#line 34
        *cursor = (position_t )0;
      }
      {
#line 35
      *mark = locus_get(bm->view, bm->locus[1]);
      }
#line 36
      return ((Boolean_t )1);
    }
#line 29
    bm = bm->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  *view = (struct view *)((void *)0);
#line 39
  tmp = (position_t )0;
#line 39
  *mark = tmp;
#line 39
  *cursor = tmp;
#line 40
  return ((Boolean_t )0);
}
}
#line 43 "/home/june/collector/temp/aoeui-1.6~dfsg/bookmark.c"
void bookmark_unset(unsigned int id ) 
{ 
  struct bookmark *bm ;
  struct bookmark *prev ;

  {
#line 45
  prev = (struct bookmark *)((void *)0);
#line 47
  bm = bookmarks;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! bm) {
#line 47
      goto while_break;
    }
#line 48
    if (bm->id == id) {
      {
#line 49
      locus_destroy(bm->view, bm->locus[0]);
#line 50
      locus_destroy(bm->view, bm->locus[1]);
      }
#line 51
      if (prev) {
#line 52
        prev->next = bm->next;
      } else {
#line 54
        bookmarks = bm->next;
      }
#line 55
      return;
    }
#line 47
    bm = bm->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return;
}
}
#line 59 "/home/june/collector/temp/aoeui-1.6~dfsg/bookmark.c"
void bookmark_unset_view(struct view *view ) 
{ 
  struct bookmark *bm ;
  struct bookmark *prev ;
  struct bookmark *next ;

  {
#line 61
  prev = (struct bookmark *)((void *)0);
#line 63
  bm = bookmarks;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! bm) {
#line 63
      goto while_break;
    }
#line 64
    next = bm->next;
#line 65
    if ((unsigned long )bm->view != (unsigned long )view) {
#line 66
      prev = bm;
#line 67
      goto __Cont;
    }
    {
#line 69
    locus_destroy(view, bm->locus[0]);
#line 70
    locus_destroy(view, bm->locus[1]);
    }
#line 71
    if (prev) {
#line 72
      prev->next = next;
    } else {
#line 74
      bookmarks = next;
    }
    __Cont: /* CIL Label */ 
#line 63
    bm = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return;
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 17 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.h"
void buffer_snap(struct buffer *buffer ) ;
#line 61 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
struct text *text_list ;
#line 62
unsigned int default_tab_stop ;
#line 63
Boolean_t default_no_tabs ;
#line 64
Boolean_t no_keywords ;
#line 65
Boolean_t no_save_originals ;
#line 66
Boolean_t read_only ;
#line 67
enum utf8_mode utf8_mode ;
#line 68
char const   *make_writable ;
#line 104
struct view *view_open(char const   *path0 ) ;
#line 140
void text_unfold_all(struct text *text ) ;
#line 22 "/home/june/collector/temp/aoeui-1.6~dfsg/window.h"
struct view *window_current_view(void) ;
#line 14 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.h"
Boolean_t is_asdfg ;
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/main.c"
static void sighandler(int signo ) 
{ 
  __pid_t tmp ;
  int *tmp___0 ;

  {
#line 6
  if (signo == 17) {
    {
#line 7
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 7
      tmp = waitpid(-1, (int *)((void *)0), 1);
      }
#line 7
      if (! (tmp > 0)) {
#line 7
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 10
    tmp___0 = __errno_location();
#line 10
    *tmp___0 = 0;
#line 11
    die("fatal signal %d", signo);
    }
  }
#line 13
  return;
}
}
#line 17
static void signals(void) ;
#line 17 "/home/june/collector/temp/aoeui-1.6~dfsg/main.c"
static int sig[9]  = 
#line 17
  {      1,      2,      3,      15, 
        17,      8,      11,      30, 
        0};
#line 26 "/home/june/collector/temp/aoeui-1.6~dfsg/main.c"
static int sigig[3]  = {      21,      13,      0};
#line 15 "/home/june/collector/temp/aoeui-1.6~dfsg/main.c"
static void signals(void) 
{ 
  int j ;

  {
#line 39
  j = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! sig[j]) {
#line 39
      goto while_break;
    }
    {
#line 40
    signal(sig[j], & sighandler);
#line 39
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  j = 0;
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 41
    if (! sigig[j]) {
#line 41
      goto while_break___0;
    }
    {
#line 42
    signal(sigig[j], (void (*)(int  ))1);
#line 41
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 43
  return;
}
}
#line 45 "/home/june/collector/temp/aoeui-1.6~dfsg/main.c"
static void save_all(void) 
{ 
  struct text *text ;
  Boolean_t msg ;
  char *raw ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 48
  msg = (Boolean_t )0;
#line 51
  text = text_list;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! text) {
#line 51
      goto while_break;
    }
#line 52
    if (! text->path) {
#line 53
      goto __Cont;
    } else
#line 52
    if (! text->buffer) {
#line 53
      goto __Cont;
    } else
#line 52
    if (! (text->buffer)->path) {
#line 53
      goto __Cont;
    }
    {
#line 54
    text_unfold_all(text);
    }
#line 55
    if (text->clean) {
      {
#line 55
      tmp = buffer_raw(text->buffer, & raw, (position_t )0, (size_t )(~ 0));
      }
#line 55
      if (tmp == text->clean_bytes) {
        {
#line 55
        tmp___0 = memcmp((void const   *)text->clean, (void const   *)raw, text->clean_bytes);
        }
#line 55
        if (! tmp___0) {
          {
#line 59
          unlink((char const   *)(text->buffer)->path);
          }
#line 60
          goto __Cont;
        }
      }
    }
#line 62
    if (! msg) {
      {
#line 63
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ncheck working files for current unsaved data\n");
#line 65
      msg = (Boolean_t )1;
      }
    }
    {
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t%s\n",
            (text->buffer)->path);
#line 68
    buffer_snap(text->buffer);
    }
    __Cont: /* CIL Label */ 
#line 51
    text = text->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 73 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
struct view *view_create(struct text *text ) ;
#line 76
void view_close(struct view *view ) ;
#line 81
size_t view_delete(struct view *view , position_t offset , size_t bytes ) ;
#line 135
void view_fold(struct view *view , position_t cursor , position_t mark ) ;
#line 136
sposition_t view_unfold(struct view *view , position_t offset ) ;
#line 137
void view_unfold_selection(struct view *view ) ;
#line 138
void view_fold_indented(struct view *view , unsigned int minindent ) ;
#line 139
void view_unfold_all(struct view *view ) ;
#line 11 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
position_t find_line_end(struct view *view , position_t offset ) ;
#line 47
Unicode_t view_unicode(struct view *view , position_t offset , size_t *next ) ;
#line 49
Unicode_t view_char(struct view *view , position_t offset , size_t *next ) ;
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/fold.c"
void view_fold(struct view *view , position_t cursor , position_t mark ) 
{ 
  size_t bytes ;
  char buf[8] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 6
  bytes = mark - cursor;
#line 9
  if (mark < cursor) {
#line 10
    bytes = - bytes;
#line 10
    cursor = mark;
  }
#line 11
  if (cursor > view->bytes) {
#line 12
    return;
  }
#line 13
  if (cursor + bytes > view->bytes) {
#line 14
    bytes = view->bytes - cursor;
  }
#line 15
  if (! bytes) {
#line 16
    return;
  }
  {
#line 17
  tmp = unicode_utf8(buf, (Unicode_t )(1610612736UL + bytes));
#line 17
  view_insert(view, (void const   *)(buf), cursor + bytes, (ssize_t )tmp);
#line 18
  tmp___0 = unicode_utf8(buf, (Unicode_t )(1073741824UL + bytes));
#line 18
  view_insert(view, (void const   *)(buf), cursor, (ssize_t )tmp___0);
#line 19
  ((view->text)->foldings) ++;
  }
#line 20
  return;
}
}
#line 22 "/home/june/collector/temp/aoeui-1.6~dfsg/fold.c"
sposition_t view_unfold(struct view *view , position_t offset ) 
{ 
  position_t next ;
  position_t next2 ;
  size_t fbytes ;
  Unicode_t ch ;
  Unicode_t tmp ;
  Unicode_t tmp___0 ;

  {
  {
#line 26
  tmp = view_unicode(view, offset, & next);
#line 26
  ch = tmp;
  }
#line 28
  if (ch < 1073741824U) {
#line 29
    return ((sposition_t )-1);
  } else
#line 28
  if (ch >= 1610612736U) {
#line 29
    return ((sposition_t )-1);
  }
  {
#line 30
  fbytes = (size_t )(ch & 536870911U);
#line 31
  tmp___0 = view_unicode(view, next + fbytes, & next2);
  }
#line 31
  if ((size_t )tmp___0 != 1610612736UL + fbytes) {
#line 33
    return ((sposition_t )-1);
  }
  {
#line 34
  view_delete(view, next + fbytes, next2 - (next + fbytes));
#line 35
  view_delete(view, offset, next - offset);
#line 36
  ((view->text)->foldings) --;
  }
#line 37
  return ((sposition_t )(offset + fbytes));
}
}
#line 40 "/home/june/collector/temp/aoeui-1.6~dfsg/fold.c"
void view_unfold_selection(struct view *view ) 
{ 
  position_t offset ;
  position_t tmp ;
  position_t end ;
  position_t tmp___0 ;
  position_t t ;
  position_t next ;
  position_t next2 ;
  size_t fbytes ;
  Unicode_t ch ;
  Unicode_t tmp___1 ;
  Unicode_t tmp___2 ;

  {
  {
#line 42
  tmp = locus_get(view, (locus_t )0);
#line 42
  offset = tmp;
#line 43
  tmp___0 = locus_get(view, (locus_t )1);
#line 43
  end = tmp___0;
  }
#line 45
  if (end == 0xffffffffffffffffUL) {
#line 46
    return;
  }
#line 47
  if (end < offset) {
#line 48
    t = end;
#line 49
    end = offset;
#line 50
    offset = t;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (offset < end)) {
#line 53
      goto while_break;
    }
    {
#line 56
    tmp___1 = view_unicode(view, offset, & next);
#line 56
    ch = tmp___1;
    }
#line 57
    if (! (ch < 1U << 31)) {
#line 58
      goto while_break;
    }
#line 59
    if (ch < 1073741824U) {
#line 60
      offset = next;
#line 61
      goto while_continue;
    } else
#line 59
    if (ch >= 1610612736U) {
#line 60
      offset = next;
#line 61
      goto while_continue;
    }
    {
#line 63
    fbytes = (size_t )(ch & 536870911U);
#line 64
    tmp___2 = view_unicode(view, next + fbytes, & next2);
    }
#line 64
    if ((size_t )tmp___2 != 1610612736UL + fbytes) {
#line 66
      offset = next;
#line 67
      goto while_continue;
    }
    {
#line 69
    view_delete(view, next + fbytes, next2 - (next + fbytes));
#line 70
    view_delete(view, offset, next - offset);
#line 71
    ((view->text)->foldings) --;
#line 72
    offset += fbytes;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/june/collector/temp/aoeui-1.6~dfsg/fold.c"
static int indentation(struct view *view , position_t offset ) 
{ 
  unsigned int indent ;
  unsigned int tabstop ;
  Unicode_t ch ;

  {
#line 78
  indent = 0U;
#line 78
  tabstop = (view->text)->tabstop;
#line 80
  tabstop |= (unsigned int )(! tabstop);
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    ch = view_char(view, offset, & offset);
    }
#line 82
    if (ch == 32U) {
#line 83
      indent ++;
    } else
#line 84
    if (ch == 9U) {
#line 85
      indent = (indent / tabstop + 1U) * tabstop;
    } else
#line 86
    if (ch == 10U) {
#line 87
      return (-1);
    } else {
#line 89
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return ((int )indent);
}
}
#line 93 "/home/june/collector/temp/aoeui-1.6~dfsg/fold.c"
static unsigned int max_indentation(struct view *view ) 
{ 
  position_t offset ;
  position_t next ;
  int maxindent ;
  int indent ;
  int tmp ;
  position_t tmp___0 ;

  {
#line 96
  maxindent = 0;
#line 98
  offset = (position_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (offset < view->bytes)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = indentation(view, offset);
#line 99
    indent = tmp;
    }
#line 100
    if (indent > maxindent) {
#line 101
      maxindent = indent;
    }
    {
#line 102
    tmp___0 = find_line_end(view, offset);
#line 102
    next = tmp___0 + 1UL;
#line 98
    offset = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return ((unsigned int )maxindent);
}
}
#line 107 "/home/june/collector/temp/aoeui-1.6~dfsg/fold.c"
void view_fold_indented(struct view *view , unsigned int minindent ) 
{ 
  unsigned int maxindent ;
  position_t offset ;
  position_t next ;
  sposition_t start ;
  position_t tmp ;
  int tmp___0 ;

  {
#line 111
  minindent |= (unsigned int )(! minindent);
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 112
    maxindent = max_indentation(view);
    }
#line 112
    if (! (maxindent >= minindent)) {
#line 112
      goto while_break;
    }
#line 114
    start = (sposition_t )-1;
#line 115
    offset = (position_t )0;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! (offset < view->bytes)) {
#line 115
        goto while_break___0;
      }
      {
#line 116
      tmp = find_line_end(view, offset);
#line 116
      next = tmp + 1UL;
#line 117
      tmp___0 = indentation(view, offset);
      }
#line 117
      if ((unsigned int )tmp___0 < maxindent) {
#line 118
        if (start >= 0L) {
          {
#line 119
          next = (position_t )start;
#line 119
          view_fold(view, next, offset - 1UL);
#line 120
          start = (sposition_t )-1;
          }
        }
      } else
#line 122
      if (start < 0L) {
#line 123
        start = (sposition_t )(offset - (position_t )(! (! offset)));
      }
#line 115
      offset = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 125
    if (start >= 0L) {
      {
#line 126
      view_fold(view, (position_t )start, offset - 1UL);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 130 "/home/june/collector/temp/aoeui-1.6~dfsg/fold.c"
void view_unfold_all(struct view *view ) 
{ 
  position_t offset ;
  position_t next ;
  sposition_t tmp ;
  Unicode_t tmp___0 ;

  {
#line 133
  if (! (view->text)->foldings) {
#line 134
    return;
  }
#line 135
  offset = (position_t )0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    tmp___0 = view_unicode(view, offset, & next);
    }
#line 135
    if (! (tmp___0 < 1U << 31)) {
#line 135
      goto while_break;
    }
    {
#line 138
    tmp = view_unfold(view, offset);
    }
#line 138
    if (tmp >= 0L) {
#line 139
      if (! (view->text)->foldings) {
#line 140
        goto while_break;
      }
#line 141
      next = offset;
    }
#line 135
    offset = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/june/collector/temp/aoeui-1.6~dfsg/fold.c"
void text_unfold_all(struct text *text ) 
{ 
  struct view *view ;

  {
#line 148
  if (! text->foldings) {
#line 149
    return;
  }
  {
#line 150
  view = view_create(text);
#line 150
  view_unfold_all(view);
#line 151
  view_close(view);
  }
#line 152
  return;
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 75 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
struct view *text_new(void) ;
#line 77
struct view *view_selection(struct view *current , position_t offset , size_t bytes ) ;
#line 105
Boolean_t text_rename(struct text *text , char const   *path0 ) ;
#line 108
void text_preserve(struct text *text ) ;
#line 109
void texts_preserve(void) ;
#line 110
void texts_uncreate(void) ;
#line 127
struct view *view_help(void) ;
#line 129
Boolean_t tab_completion_command(struct view *view ) ;
#line 130
void insert_tab(struct view *view ) ;
#line 131
void insert_newline(struct view *view ) ;
#line 132
void align(struct view *view ) ;
#line 7 "/home/june/collector/temp/aoeui-1.6~dfsg/window.h"
struct window *window_raise(struct view *view ) ;
#line 8
struct window *window_activate(struct view *view ) ;
#line 9
struct window *window_after(struct view *before , struct view *view , int vertical ) ;
#line 11
struct window *window_replace(struct view *old , struct view *new ) ;
#line 12
void window_destroy(struct window *window ) ;
#line 13
void window_next(struct view *view ) ;
#line 14
void window_index(int num ) ;
#line 17
struct window *window_recenter(struct view *view ) ;
#line 18
void window_page_up(struct view *view ) ;
#line 19
void window_page_down(struct view *view ) ;
#line 24
void windows_end(void) ;
#line 25
void windows_end_display(void) ;
#line 12 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
position_t find_paragraph_start(struct view *view , position_t offset ) ;
#line 13
position_t find_paragraph_end(struct view *view , position_t offset ) ;
#line 14
position_t find_line_up(struct view *view , position_t at ) ;
#line 15
position_t find_line_down(struct view *view , position_t at ) ;
#line 18
position_t find_nonspace(struct view *view , position_t offset ) ;
#line 19
position_t find_nonspace_prior(struct view *view , position_t offset ) ;
#line 20
position_t find_word_start(struct view *view , position_t offset ) ;
#line 21
position_t find_word_end(struct view *view , position_t offset ) ;
#line 24
position_t find_sentence_start(struct view *view , position_t offset ) ;
#line 25
position_t find_sentence_end(struct view *view , position_t offset ) ;
#line 26
sposition_t find_corresponding_bracket(struct view *view , position_t offset ) ;
#line 27
position_t find_line_number(struct view *view , unsigned int line ) ;
#line 28
unsigned int current_line_number(struct view *view , position_t offset ) ;
#line 37
void find_tag(struct view *view ) ;
#line 41
size_t view_get_selection(struct view *view , position_t *offset , Boolean_t *append ) ;
#line 45
struct view *view_next(struct view *view ) ;
#line 50
Unicode_t view_char_prior(struct view *view , position_t offset , position_t *prev ) ;
#line 3 "/home/june/collector/temp/aoeui-1.6~dfsg/clip.h"
void clip_init(unsigned int reg ) ;
#line 4
size_t clip(unsigned int reg , struct view *view , position_t offset , size_t bytes ,
            Boolean_t append ) ;
#line 14 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.h"
Boolean_t is_asdfg  ;
#line 15
struct mode *mode_default(void) ;
#line 16
void mode_search(struct view *view , Boolean_t regex ) ;
#line 7 "/home/june/collector/temp/aoeui-1.6~dfsg/die.h"
void status(char const   *msg  , ...) ;
#line 8
void status_hide(void) ;
#line 10 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static struct macro *default_macro  ;
#line 10 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static struct macro *function_key[13]  ;
#line 19
static void command_handler(struct view *view , Unicode_t ch0 ) ;
#line 22 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static position_t cut(struct view *view , Boolean_t delete ) 
{ 
  struct mode_default *mode ;
  position_t offset ;
  Boolean_t append ;
  size_t bytes ;
  size_t tmp ;
  int copies ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 24
  mode = (struct mode_default *)view->mode;
#line 27
  tmp = view_get_selection(view, & offset, & append);
#line 27
  bytes = tmp;
  }
#line 28
  if (mode->value) {
#line 28
    tmp___0 = mode->value;
  } else {
#line 28
    tmp___0 = 1;
  }
#line 28
  copies = tmp___0;
#line 30
  if (! mode->variant) {
    {
#line 31
    clip_init(0U);
    }
  } else
#line 30
  if (mode->value) {
    {
#line 31
    clip_init(0U);
    }
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    tmp___1 = copies;
#line 32
    copies --;
#line 32
    if (! tmp___1) {
#line 32
      goto while_break;
    }
    {
#line 33
    clip(0U, view, offset, bytes, append);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  if (delete) {
    {
#line 35
    view_delete(view, offset, bytes);
    }
  }
  {
#line 36
  locus_set(view, (locus_t )1, (position_t )(~ 0));
  }
#line 37
  return (offset);
}
}
#line 40 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static void paste(struct view *view ) 
{ 
  struct mode_default *mode ;
  position_t cursor ;
  position_t tmp ;

  {
  {
#line 42
  mode = (struct mode_default *)view->mode;
#line 43
  tmp = locus_get(view, (locus_t )0);
#line 43
  cursor = tmp;
#line 44
  clip_paste(view, cursor, (unsigned int )mode->value);
#line 45
  locus_set(view, (locus_t )1, cursor);
  }
#line 46
  return;
}
}
#line 48 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static void forward_lines(struct view *view ) 
{ 
  struct mode_default *mode ;
  unsigned int count ;
  int tmp ;
  position_t cursor ;
  position_t tmp___0 ;

  {
#line 50
  mode = (struct mode_default *)view->mode;
#line 51
  if (mode->variant) {
#line 51
    tmp = mode->value;
  } else {
#line 51
    tmp = 1;
  }
  {
#line 51
  count = (unsigned int )tmp;
#line 52
  tmp___0 = locus_get(view, (locus_t )0);
#line 52
  cursor = tmp___0;
  }
#line 54
  if (! count) {
    {
#line 55
    cursor = find_paragraph_end(view, cursor);
    }
  } else {
    {
#line 57
    while (1) {
      while_continue: /* CIL Label */ ;
#line 57
      if (count) {
#line 57
        if (! (cursor < view->bytes)) {
#line 57
          goto while_break;
        }
      } else {
#line 57
        goto while_break;
      }
      {
#line 58
      cursor = find_line_end(view, cursor + 1UL);
#line 57
      count --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 59
  if (count) {
    {
#line 60
    macros_abort();
    }
  }
  {
#line 61
  locus_set(view, (locus_t )0, cursor);
  }
#line 62
  return;
}
}
#line 64 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static void down_lines(struct view *view ) 
{ 
  struct mode_default *mode ;
  unsigned int count ;
  int tmp ;
  position_t cursor ;
  position_t tmp___0 ;

  {
#line 66
  mode = (struct mode_default *)view->mode;
#line 67
  if (mode->variant) {
#line 67
    tmp = mode->value;
  } else {
#line 67
    tmp = 1;
  }
  {
#line 67
  count = (unsigned int )tmp;
#line 68
  tmp___0 = locus_get(view, (locus_t )0);
#line 68
  cursor = tmp___0;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (count) {
#line 70
      if (! (cursor < view->bytes)) {
#line 70
        goto while_break;
      }
    } else {
#line 70
      goto while_break;
    }
    {
#line 71
    cursor = find_line_down(view, cursor);
#line 70
    count --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (count) {
    {
#line 73
    macros_abort();
    }
  }
  {
#line 74
  locus_set(view, (locus_t )0, cursor);
  }
#line 75
  return;
}
}
#line 77 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static void backward_lines(struct view *view ) 
{ 
  struct mode_default *mode ;
  unsigned int count ;
  int tmp ;
  position_t cursor ;
  position_t tmp___0 ;

  {
#line 79
  mode = (struct mode_default *)view->mode;
#line 80
  if (mode->variant) {
#line 80
    tmp = mode->value;
  } else {
#line 80
    tmp = 1;
  }
  {
#line 80
  count = (unsigned int )tmp;
#line 81
  tmp___0 = locus_get(view, (locus_t )0);
#line 81
  cursor = tmp___0;
  }
#line 83
  if (! count) {
    {
#line 84
    cursor = find_paragraph_start(view, cursor);
    }
  } else {
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (count) {
#line 86
        if (! cursor) {
#line 86
          goto while_break;
        }
      } else {
#line 86
        goto while_break;
      }
      {
#line 87
      cursor = find_line_start(view, cursor - 1UL);
#line 86
      count --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 88
  if (count) {
    {
#line 89
    macros_abort();
    }
  }
  {
#line 90
  locus_set(view, (locus_t )0, cursor);
  }
#line 91
  return;
}
}
#line 93 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static void up_lines(struct view *view ) 
{ 
  struct mode_default *mode ;
  unsigned int count ;
  int tmp ;
  position_t cursor ;
  position_t tmp___0 ;

  {
#line 95
  mode = (struct mode_default *)view->mode;
#line 96
  if (mode->variant) {
#line 96
    tmp = mode->value;
  } else {
#line 96
    tmp = 1;
  }
  {
#line 96
  count = (unsigned int )tmp;
#line 97
  tmp___0 = locus_get(view, (locus_t )0);
#line 97
  cursor = tmp___0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (count) {
#line 99
      if (! cursor) {
#line 99
        goto while_break;
      }
    } else {
#line 99
      goto while_break;
    }
    {
#line 100
    cursor = find_line_up(view, cursor);
#line 99
    count --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (count) {
#line 101
    if (! cursor) {
      {
#line 102
      macros_abort();
      }
    }
  }
  {
#line 103
  locus_set(view, (locus_t )0, cursor);
  }
#line 104
  return;
}
}
#line 106 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static void forward_chars(struct view *view ) 
{ 
  struct mode_default *mode ;
  unsigned int count ;
  int tmp ;
  position_t cursor ;
  position_t tmp___0 ;
  position_t next ;
  Unicode_t tmp___1 ;

  {
#line 108
  mode = (struct mode_default *)view->mode;
#line 109
  if (mode->variant) {
#line 109
    tmp = mode->value;
  } else {
#line 109
    tmp = 1;
  }
  {
#line 109
  count = (unsigned int )tmp;
#line 110
  tmp___0 = locus_get(view, (locus_t )0);
#line 110
  cursor = tmp___0;
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (count) {
      {
#line 112
      tmp___1 = view_char(view, cursor, & next);
      }
#line 112
      if (! (tmp___1 < 1U << 31)) {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
#line 113
    cursor = next;
#line 112
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if (count) {
    {
#line 115
    macros_abort();
    }
  }
  {
#line 116
  locus_set(view, (locus_t )0, cursor);
  }
#line 117
  return;
}
}
#line 119 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static void backward_chars(struct view *view ) 
{ 
  struct mode_default *mode ;
  unsigned int count ;
  int tmp ;
  position_t cursor ;
  position_t tmp___0 ;

  {
#line 121
  mode = (struct mode_default *)view->mode;
#line 122
  if (mode->variant) {
#line 122
    tmp = mode->value;
  } else {
#line 122
    tmp = 1;
  }
  {
#line 122
  count = (unsigned int )tmp;
#line 123
  tmp___0 = locus_get(view, (locus_t )0);
#line 123
  cursor = tmp___0;
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (count) {
#line 125
      if (! cursor) {
#line 125
        goto while_break;
      }
    } else {
#line 125
      goto while_break;
    }
    {
#line 126
    view_char_prior(view, cursor, & cursor);
#line 125
    count --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  if (count) {
    {
#line 128
    macros_abort();
    }
  }
  {
#line 129
  locus_set(view, (locus_t )0, cursor);
  }
#line 130
  return;
}
}
#line 132 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static Boolean_t funckey(struct view *view , int Fk ) 
{ 
  struct mode_default *mode ;
  Boolean_t tmp ;

  {
#line 134
  mode = (struct mode_default *)view->mode;
#line 136
  if (Fk > 12) {
#line 137
    return ((Boolean_t )0);
  }
#line 138
  if (mode->variant) {
#line 138
    if (! mode->value) {
      {
#line 139
      macro_end_recording((Unicode_t )0);
#line 140
      macro_free(function_key[Fk]);
#line 141
      function_key[Fk] = macro_record();
      }
#line 142
      return ((Boolean_t )1);
    }
  }
  {
#line 144
  tmp = macro_play(function_key[Fk], mode->value);
  }
#line 144
  return (tmp);
}
}
#line 147 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static position_t self_insert(struct view *view , Unicode_t ch , position_t mark ,
                              position_t old_cursor ) 
{ 
  char cbuf[16] ;
  char *p ;
  position_t cursor ;
  size_t len ;

  {
#line 150
  p = cbuf;
#line 151
  cursor = old_cursor;
#line 152
  len = (size_t )0;
#line 154
  if (mark != 0xffffffffffffffffUL) {
#line 154
    if (mark > cursor) {
      {
#line 155
      cursor = cut(view, (Boolean_t )1);
#line 156
      mark = (position_t )(~ 0);
      }
    }
  }
#line 158
  if (ch == 10U) {
#line 158
    if ((view->text)->flags & (unsigned int )(1 << 7)) {
      {
#line 159
      len = (size_t )2;
#line 159
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"\r\n",
             len);
      }
    } else {
#line 158
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 160
  if ((view->text)->flags & (unsigned int )(1 << 6)) {
#line 161
    p = cbuf + sizeof(cbuf);
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if (! ch) {
#line 161
        goto while_break;
      }
#line 162
      p --;
#line 162
      *p = (char )ch;
#line 162
      len ++;
#line 161
      ch >>= 8;
    }
    while_break: /* CIL Label */ ;
    }
#line 163
    if (! len) {
#line 164
      p --;
#line 164
      *p = (char)0;
#line 164
      len ++;
    }
  } else {
    {
#line 166
    len = unicode_utf8(p, ch);
    }
  }
  {
#line 168
  view_insert(view, (void const   *)p, cursor, (ssize_t )len);
  }
#line 169
  if (mark == old_cursor) {
    {
#line 170
    locus_set(view, (locus_t )1, old_cursor);
    }
  }
#line 171
  if (view->shell_std_in >= 0) {
    {
#line 172
    shell_command(view, ch);
    }
  }
#line 173
  return (cursor + len);
}
}
#line 335 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static char asdfg_to_aoeui[26]  = 
#line 335
  {      (char )'A',      (char )'O',      (char )'F',      (char )'Y', 
        (char )'X',      (char )'W',      (char )'H',      (char )'T', 
        (char )'I',      (char )'J',      (char )'N',      (char )'S', 
        (char )'M',      (char )'Z',      (char )'R',      (char )'L', 
        (char )'Q',      (char )'E',      (char )'P',      (char )'G', 
        (char )'V',      (char )'B',      (char )'K',      (char )'D', 
        (char )'C',      (char )'U'};
#line 176 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
static void command_handler(struct view *view , Unicode_t ch0 ) 
{ 
  struct mode_default *mode ;
  Unicode_t ch ;
  position_t cursor ;
  position_t tmp ;
  position_t mark ;
  position_t tmp___0 ;
  position_t offset ;
  Boolean_t ok ;
  struct view *new_view ;
  char *select___0 ;
  Unicode_t tmp___1 ;
  Boolean_t tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  Boolean_t tmp___7 ;
  struct view *tmp___8 ;
  sposition_t tmp___9 ;
  unsigned int tmp___10 ;
  struct view *tmp___11 ;
  size_t outbytes ;
  size_t tmp___12 ;
  unsigned int reg ;
  size_t inbytes ;
  size_t tmp___13 ;
  position_t tmp___14 ;
  position_t tmp___15 ;
  Boolean_t tmp___16 ;
  int tmp___17 ;
  Boolean_t tmp___18 ;
  Boolean_t tmp___19 ;
  __pid_t tmp___20 ;
  int tmp___21 ;
  sposition_t (*tmp___22)(struct text * ) ;
  sposition_t tmp___23 ;
  position_t tmp___24 ;
  position_t tmp___25 ;
  position_t tmp___26 ;
  struct view *tmp___27 ;
  struct window *tmp___28 ;
  int tmp___29 ;
  position_t offset___0 ;
  position_t tmp___30 ;
  size_t bytes ;
  position_t tmp___31 ;
  position_t tmp___32 ;
  sposition_t tmp___33 ;
  Boolean_t tmp___34 ;

  {
  {
#line 178
  mode = (struct mode_default *)view->mode;
#line 179
  ch = ch0;
#line 180
  tmp = locus_get(view, (locus_t )0);
#line 180
  cursor = tmp;
#line 181
  tmp___0 = locus_get(view, (locus_t )1);
#line 181
  mark = tmp___0;
#line 183
  ok = (Boolean_t )1;
#line 187
  status_hide();
  }
#line 190
  if (ch == 127U) {
    delete: 
    {
#line 191
    tmp___1 = view_char_prior(view, cursor, & mark);
    }
#line 191
    if (tmp___1 < 1U << 31) {
      {
#line 192
      view_delete(view, mark, cursor - mark);
      }
    } else {
      {
#line 194
      window_beep(view);
      }
    }
#line 195
    goto done;
  }
#line 199
  if (ch - ((1U << 31) + 1U) < 256U) {
#line 202
    if (ch != ((1U << 31) + 1U) + 1U) {
#line 202
      if (ch != ((1U << 31) + 1U) + 2U) {
#line 203
        view->goal.cursor = (position_t )(~ 0);
      }
    }
    {
#line 206
    if (ch == ((1U << 31) + 1U) + 2U) {
#line 206
      goto case_exp;
    }
#line 209
    if (ch == ((1U << 31) + 1U) + 1U) {
#line 209
      goto case_exp___0;
    }
#line 212
    if (ch == ((1U << 31) + 1U) + 4U) {
#line 212
      goto case_exp___1;
    }
#line 215
    if (ch == ((1U << 31) + 1U) + 3U) {
#line 215
      goto case_exp___2;
    }
#line 218
    if (ch == ((1U << 31) + 1U) + 5U) {
#line 218
      goto case_exp___3;
    }
#line 221
    if (ch == ((1U << 31) + 1U) + 6U) {
#line 221
      goto case_exp___4;
    }
#line 224
    if (ch == ((1U << 31) + 1U) + 7U) {
#line 224
      goto case_exp___5;
    }
#line 227
    if (ch == ((1U << 31) + 1U) + 8U) {
#line 227
      goto case_exp___6;
    }
#line 230
    if (ch == ((1U << 31) + 1U) + 9U) {
#line 230
      goto case_exp___7;
    }
#line 233
    if (ch == ((1U << 31) + 1U) + 10U) {
#line 233
      goto case_exp___8;
    }
#line 235
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
#line 207
    down_lines(view);
    }
#line 208
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 210
    up_lines(view);
    }
#line 211
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 213
    backward_chars(view);
    }
#line 214
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
#line 216
    forward_chars(view);
    }
#line 217
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    {
#line 219
    window_page_up(view);
    }
#line 220
    goto switch_break;
    case_exp___4: /* CIL Label */ 
    {
#line 222
    window_page_down(view);
    }
#line 223
    goto switch_break;
    case_exp___5: /* CIL Label */ 
    {
#line 225
    locus_set(view, (locus_t )0, (position_t )0);
    }
#line 226
    goto switch_break;
    case_exp___6: /* CIL Label */ 
    {
#line 228
    locus_set(view, (locus_t )0, view->bytes);
    }
#line 229
    goto switch_break;
    case_exp___7: /* CIL Label */ 
    {
#line 231
    paste(view);
    }
#line 232
    goto switch_break;
    case_exp___8: /* CIL Label */ 
#line 234
    goto delete;
    switch_default: /* CIL Label */ 
#line 236
    if (ch < ((1U << 31) + 1U) + 21U) {
#line 238
      ok = (Boolean_t )0;
    } else {
      {
#line 236
      tmp___2 = funckey(view, (int )((ch - (((1U << 31) + 1U) + 21U)) + 1U));
      }
#line 236
      if (! tmp___2) {
#line 238
        ok = (Boolean_t )0;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 240
    goto done;
  }
#line 252
  if (ch >= 32U) {
#line 254
    view->goal.cursor = (position_t )(~ 0);
#line 256
    if (mode->variant) {
#line 257
      if (mode->is_hex) {
        {
#line 257
        tmp___5 = __ctype_b_loc();
        }
#line 257
        if ((int const   )*(*tmp___5 + (int )ch) & 4096) {
          {
#line 258
          mode->value *= 16;
#line 259
          tmp___4 = __ctype_b_loc();
          }
#line 259
          if ((int const   )*(*tmp___4 + (int )ch) & 2048) {
#line 260
            mode->value = (int )((Unicode_t )mode->value + (ch - 48U));
          } else {
            {
#line 262
            tmp___3 = tolower((int )ch);
#line 262
            mode->value += (tmp___3 - 97) + 10;
            }
          }
#line 263
          return;
        }
      }
      {
#line 265
      tmp___6 = __ctype_b_loc();
      }
#line 265
      if ((int const   )*(*tmp___6 + (int )ch) & 2048) {
#line 266
        mode->value *= 10;
#line 267
        mode->value = (int )((Unicode_t )mode->value + (ch - 48U));
#line 268
        return;
      }
#line 270
      if (! mode->value) {
#line 270
        if (ch == 120U) {
#line 271
          mode->is_hex = (Boolean_t )1;
#line 272
          return;
        } else
#line 270
        if (ch == 88U) {
#line 271
          mode->is_hex = (Boolean_t )1;
#line 272
          return;
        }
      }
      {
#line 275
      if (ch == 61U) {
#line 275
        goto case_61;
      }
#line 278
      if (ch == 45U) {
#line 278
        goto case_45;
      }
#line 288
      if (ch == 59U) {
#line 288
        goto case_59;
      }
#line 291
      if (ch == 39U) {
#line 291
        goto case_39;
      }
#line 294
      if (ch == 44U) {
#line 294
        goto case_44;
      }
#line 302
      if (ch == 46U) {
#line 302
        goto case_46;
      }
#line 315
      if (ch == 35U) {
#line 315
        goto case_35;
      }
#line 319
      if (ch == 63U) {
#line 319
        goto case_63;
      }
#line 274
      goto switch_break___0;
      case_61: /* CIL Label */ 
      {
#line 276
      bookmark_set((unsigned int )mode->value, view, cursor, mark);
      }
#line 277
      goto done;
      case_45: /* CIL Label */ 
      {
#line 279
      tmp___7 = bookmark_get(& new_view, & cursor, & mark, (unsigned int )mode->value);
      }
#line 279
      if (tmp___7) {
        {
#line 281
        locus_set(new_view, (locus_t )0, cursor);
        }
#line 282
        if (mark != 0xffffffffffffffffUL) {
          {
#line 283
          locus_set(new_view, (locus_t )1, mark);
          }
        }
        {
#line 284
        window_activate(new_view);
        }
      } else {
#line 286
        ok = (Boolean_t )0;
      }
#line 287
      goto done;
      case_59: /* CIL Label */ 
      {
#line 289
      tmp___8 = text_new();
#line 289
      window_after(view, tmp___8, -1);
      }
#line 290
      goto done;
      case_39: /* CIL Label */ 
      {
#line 292
      find_tag(view);
      }
#line 293
      goto done;
      case_44: /* CIL Label */ 
#line 295
      if (mark == 0xffffffffffffffffUL) {
        {
#line 296
        view_fold_indented(view, (unsigned int )mode->value);
        }
      } else {
        {
#line 298
        view_fold(view, cursor, mark);
#line 299
        locus_set(view, (locus_t )1, (position_t )(~ 0));
        }
      }
#line 301
      goto done;
      case_46: /* CIL Label */ 
#line 303
      if (mode->value) {
        {
#line 304
        view_unfold_all(view);
        }
      } else
#line 305
      if (mark != 0xffffffffffffffffUL) {
        {
#line 306
        view_unfold_selection(view);
        }
      } else {
        {
#line 308
        tmp___9 = view_unfold(view, cursor);
#line 308
        mark = (position_t )tmp___9;
        }
#line 309
        if ((int )mark < 0) {
          {
#line 310
          view_unfold_all(view);
          }
        } else {
          {
#line 312
          locus_set(view, (locus_t )1, mark);
          }
        }
      }
#line 314
      goto done;
      case_35: /* CIL Label */ 
      {
#line 316
      tmp___10 = current_line_number(view, cursor);
#line 316
      status("%s line %d", (view->text)->path, tmp___10);
      }
#line 318
      goto done;
      case_63: /* CIL Label */ 
      {
#line 320
      tmp___11 = view_help();
#line 320
      window_after(view, tmp___11, -1);
      }
#line 321
      goto done;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 325
    self_insert(view, ch, mark, cursor);
    }
#line 326
    goto done;
  }
#line 333
  ch += 64U;
#line 334
  if (is_asdfg) {
#line 334
    if (ch >= 65U) {
#line 334
      if (ch <= 90U) {
#line 341
        ch = (Unicode_t )asdfg_to_aoeui[ch - 65U];
      }
    }
  }
#line 344
  if (ch != 71U) {
#line 344
    if (ch != 67U) {
#line 344
      if (ch != 72U) {
#line 344
        if (ch != 84U) {
#line 347
          view->goal.cursor = (position_t )(~ 0);
        } else {
#line 344
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 344
      if (! mode->variant) {
#line 347
        view->goal.cursor = (position_t )(~ 0);
      } else
#line 344
      if (mode->value) {
#line 347
        view->goal.cursor = (position_t )(~ 0);
      }
    }
  }
  {
#line 350
  if (ch == 64U) {
#line 350
    goto case_64;
  }
#line 356
  if (ch == 95U) {
#line 356
    goto case_95;
  }
#line 356
  if (ch == 65U) {
#line 356
    goto case_95;
  }
#line 359
  if (ch == 66U) {
#line 359
    goto case_66;
  }
#line 372
  if (ch == 67U) {
#line 372
    goto case_67;
  }
#line 375
  if (ch == 68U) {
#line 375
    goto case_68;
  }
#line 383
  if (ch == 69U) {
#line 383
    goto case_69;
  }
#line 394
  if (ch == 70U) {
#line 394
    goto case_70;
  }
#line 397
  if (ch == 71U) {
#line 397
    goto case_71;
  }
#line 400
  if (ch == 72U) {
#line 400
    goto case_72;
  }
#line 407
  if (ch == 73U) {
#line 407
    goto case_73;
  }
#line 422
  if (ch == 74U) {
#line 422
    goto case_74;
  }
#line 425
  if (ch == 77U) {
#line 425
    goto case_77;
  }
#line 428
  if (ch == 75U) {
#line 428
    goto case_75;
  }
#line 434
  if (ch == 76U) {
#line 434
    goto case_76;
  }
#line 440
  if (ch == 78U) {
#line 440
    goto case_78;
  }
#line 450
  if (ch == 79U) {
#line 450
    goto case_79;
  }
#line 459
  if (ch == 80U) {
#line 459
    goto case_80;
  }
#line 467
  if (ch == 81U) {
#line 467
    goto case_81;
  }
#line 479
  if (ch == 82U) {
#line 479
    goto case_82;
  }
#line 485
  if (ch == 83U) {
#line 485
    goto case_83;
  }
#line 495
  if (ch == 84U) {
#line 495
    goto case_84;
  }
#line 502
  if (ch == 85U) {
#line 502
    goto case_85;
  }
#line 508
  if (ch == 86U) {
#line 508
    goto case_86;
  }
#line 521
  if (ch == 87U) {
#line 521
    goto case_87;
  }
#line 527
  if (ch == 88U) {
#line 527
    goto case_88;
  }
#line 545
  if (ch == 89U) {
#line 545
    goto case_89;
  }
#line 558
  if (ch == 90U) {
#line 558
    goto case_90;
  }
#line 566
  if (ch == 92U) {
#line 566
    goto case_92;
  }
#line 573
  if (ch == 93U) {
#line 573
    goto case_93;
  }
#line 580
  if (ch == 94U) {
#line 580
    goto case_94;
  }
#line 594
  goto switch_default___0;
  case_64: /* CIL Label */ 
#line 351
  if (mode->variant) {
#line 352
    goto switch_break___1;
  }
#line 353
  mode->variant = (Boolean_t )1;
#line 354
  return;
  case_95: /* CIL Label */ 
  case_65: /* CIL Label */ 
  {
#line 357
  mode_search(view, mode->variant);
  }
#line 358
  goto switch_break___1;
  case_66: /* CIL Label */ 
#line 360
  if (mark != 0xffffffffffffffffUL) {
    {
#line 361
    tmp___12 = view_get_selection(view, & offset, (Boolean_t *)((void *)0));
#line 361
    outbytes = tmp___12;
#line 362
    reg = (unsigned int )mode->value;
#line 363
    tmp___13 = clip_paste(view, offset + outbytes, reg);
#line 363
    inbytes = tmp___13;
#line 364
    clip_init(reg);
#line 365
    clip(reg, view, offset, outbytes, (Boolean_t )0);
#line 366
    view_delete(view, offset, outbytes);
#line 367
    locus_set(view, (locus_t )0, offset);
#line 368
    locus_set(view, (locus_t )1, offset + inbytes);
    }
  } else {
    {
#line 370
    paste(view);
    }
  }
#line 371
  goto switch_break___1;
  case_67: /* CIL Label */ 
  {
#line 373
  forward_lines(view);
  }
#line 374
  goto switch_break___1;
  case_68: /* CIL Label */ 
#line 376
  if (mark == 0xffffffffffffffffUL) {
#line 376
    if (mode->variant) {
      {
#line 377
      tmp___14 = find_nonspace(view, cursor);
#line 377
      locus_set(view, (locus_t )1, tmp___14);
#line 378
      tmp___15 = find_nonspace_prior(view, cursor);
#line 378
      locus_set(view, (locus_t )0, tmp___15);
      }
    } else {
      {
#line 381
      cut(view, (Boolean_t )1);
      }
    }
  } else {
    {
#line 381
    cut(view, (Boolean_t )1);
    }
  }
#line 382
  goto switch_break___1;
  case_69: /* CIL Label */ 
#line 384
  if (mark != 0xffffffffffffffffUL) {
    {
#line 385
    mode_child(view);
    }
  } else
#line 386
  if (mode->variant) {
    {
#line 387
    demultiplex_view(view);
    }
  } else {
    {
#line 389
    new_view = text_new();
#line 390
    window_after(view, new_view, -1);
#line 391
    mode_shell_pipe(new_view);
    }
  }
#line 393
  goto switch_break___1;
  case_70: /* CIL Label */ 
  {
#line 395
  cut(view, (Boolean_t )0);
  }
#line 396
  goto switch_break___1;
  case_71: /* CIL Label */ 
  {
#line 398
  backward_lines(view);
  }
#line 399
  goto switch_break___1;
  case_72: /* CIL Label */ 
#line 401
  if (mode->variant) {
#line 401
    if (! mode->value) {
      {
#line 402
      mode->variant = (Boolean_t )0;
#line 403
      up_lines(view);
      }
    } else {
      {
#line 405
      backward_chars(view);
      }
    }
  } else {
    {
#line 405
    backward_chars(view);
    }
  }
#line 406
  goto switch_break___1;
  case_73: /* CIL Label */ 
#line 408
  if (! mode->variant) {
    {
#line 409
    tmp___16 = tab_completion_command(view);
    }
#line 409
    if (! tmp___16) {
      {
#line 410
      insert_tab(view);
      }
    }
  } else
#line 411
  if (mode->value) {
#line 412
    if (mode->value == 1) {
#line 413
      (view->text)->flags ^= (unsigned int )(1 << 5);
    } else
#line 414
    if (mode->value > 1) {
#line 414
      if (mode->value <= 20) {
#line 415
        default_tab_stop = (unsigned int )mode->value;
#line 415
        (view->text)->tabstop = default_tab_stop;
      } else {
        {
#line 418
        window_beep(view);
        }
      }
    } else {
      {
#line 418
      window_beep(view);
      }
    }
  } else {
    {
#line 420
    align(view);
    }
  }
#line 421
  goto switch_break___1;
  case_74: /* CIL Label */ 
  {
#line 423
  insert_newline(view);
  }
#line 424
  goto switch_break___1;
  case_77: /* CIL Label */ 
  {
#line 426
  self_insert(view, (Unicode_t )'\n', mark, cursor);
  }
#line 427
  goto switch_break___1;
  case_75: /* CIL Label */ 
#line 429
  if (mode->variant) {
    {
#line 430
    text_preserve(view->text);
    }
  } else {
    {
#line 432
    texts_preserve();
    }
  }
#line 433
  goto switch_break___1;
  case_76: /* CIL Label */ 
#line 435
  if (mode->variant) {
    {
#line 436
    locus_set(view, (locus_t )0, view->bytes);
    }
  } else {
    {
#line 438
    window_page_down(view);
    }
  }
#line 439
  goto switch_break___1;
  case_78: /* CIL Label */ 
#line 441
  if (mode->value) {
    {
#line 442
    while (1) {
      while_continue: /* CIL Label */ ;
#line 442
      tmp___17 = mode->value;
#line 442
      (mode->value) --;
#line 442
      if (tmp___17) {
#line 442
        if (! cursor) {
#line 442
          goto while_break;
        }
      } else {
#line 442
        goto while_break;
      }
      {
#line 443
      cursor = find_word_start(view, cursor);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 444
  if (mode->variant) {
    {
#line 445
    cursor = find_sentence_start(view, cursor);
    }
  } else {
    {
#line 447
    cursor = find_word_start(view, cursor);
    }
  }
  {
#line 448
  locus_set(view, (locus_t )0, cursor);
  }
#line 449
  goto switch_break___1;
  case_79: /* CIL Label */ 
#line 451
  if (mode->variant) {
#line 451
    if (! mode->value) {
      {
#line 452
      macro_end_recording((Unicode_t )0);
#line 453
      macro_free(default_macro);
#line 454
      default_macro = macro_record();
      }
    } else {
#line 451
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 455
    tmp___18 = macro_end_recording(ch0);
    }
#line 455
    if (! tmp___18) {
      {
#line 455
      tmp___19 = macro_play(default_macro, mode->value);
      }
#line 455
      if (! tmp___19) {
        {
#line 457
        window_beep(view);
        }
      }
    }
  }
#line 458
  goto switch_break___1;
  case_80: /* CIL Label */ 
#line 460
  if (! mode->variant) {
    {
#line 461
    window_next(view);
    }
  } else
#line 462
  if (mode->value) {
    {
#line 463
    window_index(mode->value);
    }
  } else {
    {
#line 465
    window_destroy(view->window);
    }
  }
#line 466
  goto switch_break___1;
  case_81: /* CIL Label */ 
#line 468
  if (mode->variant) {
    {
#line 469
    windows_end();
#line 470
    texts_preserve();
    }
    {
#line 471
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 471
      if (! text_list) {
#line 471
        goto while_break___0;
      }
      {
#line 472
      view_close(text_list->views);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 473
    exit(0);
    }
  }
  {
#line 475
  windows_end_display();
#line 476
  tmp___20 = getpid();
#line 476
  kill(tmp___20, 19);
#line 477
  window_recenter(view);
  }
#line 478
  goto switch_break___1;
  case_82: /* CIL Label */ 
#line 480
  if (mode->variant) {
    {
#line 481
    locus_set(view, (locus_t )0, (position_t )0);
    }
  } else {
    {
#line 483
    window_page_up(view);
    }
  }
#line 484
  goto switch_break___1;
  case_83: /* CIL Label */ 
#line 486
  if (mode->value) {
    {
#line 487
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 487
      tmp___21 = mode->value;
#line 487
      (mode->value) --;
#line 487
      if (! tmp___21) {
#line 487
        goto while_break___1;
      }
      {
#line 488
      cursor = find_word_end(view, cursor);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 489
  if (mode->variant) {
    {
#line 490
    cursor = find_sentence_end(view, cursor);
    }
  } else {
    {
#line 492
    cursor = find_word_end(view, cursor);
    }
  }
  {
#line 493
  locus_set(view, (locus_t )0, cursor);
  }
#line 494
  goto switch_break___1;
  case_84: /* CIL Label */ 
#line 496
  if (mode->variant) {
#line 496
    if (! mode->value) {
      {
#line 497
      mode->variant = (Boolean_t )0;
#line 498
      down_lines(view);
      }
    } else {
      {
#line 500
      forward_chars(view);
      }
    }
  } else {
    {
#line 500
    forward_chars(view);
    }
  }
#line 501
  goto switch_break___1;
  case_85: /* CIL Label */ 
#line 503
  if (mode->variant) {
#line 503
    tmp___22 = & text_redo;
  } else {
#line 503
    tmp___22 = & text_undo;
  }
  {
#line 503
  tmp___23 = (*tmp___22)(view->text);
#line 503
  offset = (position_t )tmp___23;
#line 504
  offset -= view->start;
  }
#line 504
  if (offset <= view->bytes) {
    {
#line 505
    locus_set(view, (locus_t )0, offset);
    }
  }
  {
#line 506
  locus_set(view, (locus_t )1, (position_t )(~ 0));
  }
#line 507
  goto switch_break___1;
  case_86: /* CIL Label */ 
#line 509
  if (! mode->variant) {
#line 510
    if (mark == 0xffffffffffffffffUL) {
#line 510
      tmp___24 = cursor;
    } else {
#line 510
      tmp___24 = (position_t )(~ 0);
    }
    {
#line 510
    locus_set(view, (locus_t )1, tmp___24);
    }
  } else
#line 511
  if (mode->value) {
    {
#line 512
    locus_set(view, (locus_t )1, (position_t )(~ 0));
    }
  } else
#line 513
  if (mark == 0xffffffffffffffffUL) {
    {
#line 514
    tmp___25 = find_line_end(view, cursor);
#line 514
    locus_set(view, (locus_t )1, tmp___25 + 1UL);
#line 515
    tmp___26 = find_line_start(view, cursor);
#line 515
    locus_set(view, (locus_t )0, tmp___26);
    }
  } else {
    {
#line 517
    locus_set(view, (locus_t )1, cursor);
#line 518
    locus_set(view, (locus_t )0, mark);
    }
  }
#line 520
  goto switch_break___1;
  case_87: /* CIL Label */ 
#line 522
  if (mode->variant) {
    {
#line 523
    view_close(view);
    }
  } else {
    {
#line 524
    tmp___27 = view_next(view);
#line 524
    tmp___28 = window_replace(view, tmp___27);
    }
#line 524
    if (! tmp___28) {
      {
#line 525
      window_beep(view);
      }
    }
  }
#line 526
  goto switch_break___1;
  case_88: /* CIL Label */ 
#line 528
  if (mark == 0xffffffffffffffffUL) {
    {
#line 529
    view_insert(view, (void const   *)(view->text)->path, cursor, (ssize_t )-1);
#line 530
    locus_set(view, (locus_t )1, cursor);
    }
  } else {
    {
#line 531
    select___0 = view_extract_selection(view);
    }
#line 531
    if (select___0) {
#line 532
      if (mode->variant) {
        {
#line 533
        ok = text_rename(view->text, (char const   *)select___0);
        }
#line 533
        if (ok) {
          {
#line 534
          window_activate(view);
          }
        }
#line 535
        new_view = (struct view *)((void *)0);
      } else {
        {
#line 537
        new_view = view_open((char const   *)select___0);
        }
#line 537
        if (new_view) {
#line 537
          tmp___29 = 1;
        } else {
#line 537
          tmp___29 = 0;
        }
#line 537
        ok = (Boolean_t )tmp___29;
      }
      {
#line 538
      reallocate((void const   *)select___0, (size_t )0);
#line 538
      select___0 = (char *)((void *)0);
      }
#line 539
      if (ok) {
        {
#line 540
        view_delete_selection(view);
        }
      }
#line 541
      if (new_view) {
        {
#line 542
        window_after(view, new_view, -1);
        }
      }
    }
  }
#line 544
  goto switch_break___1;
  case_89: /* CIL Label */ 
#line 546
  if (mark != 0xffffffffffffffffUL) {
#line 547
    if (mark < cursor) {
#line 547
      tmp___30 = mark;
    } else {
#line 547
      tmp___30 = cursor;
    }
#line 547
    offset___0 = tmp___30;
#line 548
    if (mark < cursor) {
#line 548
      tmp___31 = cursor - mark;
    } else {
#line 548
      tmp___31 = mark - cursor;
    }
    {
#line 548
    bytes = tmp___31;
#line 550
    new_view = view_selection(view, offset___0, bytes);
    }
  } else {
    {
#line 552
    new_view = view_next(view);
    }
  }
#line 553
  if (new_view) {
    {
#line 554
    window_after(view, new_view, (int )mode->variant);
    }
  } else {
    {
#line 556
    window_beep(view);
    }
  }
#line 557
  goto switch_break___1;
  case_90: /* CIL Label */ 
#line 559
  if (mode->value) {
    {
#line 560
    tmp___32 = find_line_number(view, (unsigned int )mode->value);
#line 560
    locus_set(view, (locus_t )0, tmp___32);
    }
  } else
#line 562
  if (mode->variant) {
    {
#line 563
    window_raise(view);
    }
  }
  {
#line 564
  window_recenter(view);
  }
#line 565
  goto switch_break___1;
  case_92: /* CIL Label */ 
#line 567
  if (mode->variant) {
    {
#line 568
    windows_end();
#line 569
    texts_uncreate();
#line 570
    exit(0);
    }
  }
#line 572
  goto switch_break___1;
  case_93: /* CIL Label */ 
  {
#line 574
  tmp___33 = find_corresponding_bracket(view, cursor);
#line 574
  cursor = (position_t )tmp___33;
  }
#line 575
  if ((int )cursor < 0) {
    {
#line 576
    window_beep(view);
    }
  } else {
    {
#line 578
    locus_set(view, (locus_t )0, cursor);
    }
  }
#line 579
  goto switch_break___1;
  case_94: /* CIL Label */ 
#line 581
  if (mode->value) {
    {
#line 582
    self_insert(view, (Unicode_t )mode->value, mark, cursor);
    }
  } else {
    {
#line 583
    ch = macro_getch();
    }
#line 583
    if (ch < 1U << 31) {
#line 584
      if (ch >= 64U) {
#line 584
        if (ch <= 95U) {
#line 585
          ch -= 64U;
        } else {
#line 584
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 586
      if (ch >= 97U) {
#line 586
        if (ch <= 122U) {
#line 587
          ch = ((ch - 97U) + 65U) - 64U;
        } else {
#line 586
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 588
      if (ch == 63U) {
#line 589
        ch = (Unicode_t )127;
      }
      {
#line 590
      self_insert(view, ch, mark, cursor);
      }
    } else {
#line 592
      ok = (Boolean_t )0;
    }
  }
#line 593
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 595
  ok = (Boolean_t )0;
#line 596
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  done: 
#line 599
  tmp___34 = (Boolean_t )0;
#line 599
  mode->is_hex = tmp___34;
#line 599
  mode->variant = tmp___34;
#line 600
  mode->value = 0;
#line 601
  if (! ok) {
    {
#line 602
    window_beep(view);
    }
  }
#line 603
  return;
}
}
#line 605 "/home/june/collector/temp/aoeui-1.6~dfsg/mode.c"
struct mode *mode_default(void) 
{ 
  struct mode_default *dft ;
  void *tmp ;

  {
  {
#line 607
  tmp = allocate0(sizeof(*dft));
#line 607
  dft = (struct mode_default *)tmp;
#line 608
  dft->command = & command_handler;
#line 609
  dft->selection_bgrgba = (rgba_t )16776960;
  }
#line 610
  return ((struct mode *)dft);
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 107 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
Boolean_t text_is_dirty(struct text *text ) ;
#line 10 "/home/june/collector/temp/aoeui-1.6~dfsg/window.h"
struct window *window_below(struct view *above , struct view *view , unsigned int rows___0 ) ;
#line 23
unsigned int window_columns(struct window *window ) ;
#line 29 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
position_t find_row_bytes(struct view *view , position_t offset0 , unsigned int column ,
                          unsigned int columns___0 ) ;
#line 31
unsigned int find_column(unsigned int *row , struct view *view , position_t at , position_t offset ,
                         unsigned int column ) ;
#line 55
Boolean_t is_keyword(struct view *view , position_t offset ) ;
#line 57 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
__inline static Boolean_t is_wordch(Unicode_t ch ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 59
  if (ch > 256U) {
#line 59
    if (ch < 1073741824U) {
#line 59
      tmp___0 = 1;
    } else {
#line 59
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 59
  if (ch < 65536U) {
    {
#line 59
    tmp = __ctype_b_loc();
    }
#line 59
    if ((int const   )*(*tmp + (int )ch) & 8) {
#line 59
      tmp___0 = 1;
    } else {
#line 59
      tmp___0 = 0;
    }
  } else {
#line 59
    tmp___0 = 0;
  }
#line 59
  return ((Boolean_t )tmp___0);
}
}
#line 62 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
__inline static Boolean_t is_idch(Unicode_t ch ) 
{ 
  Boolean_t tmp ;
  int tmp___0 ;

  {
#line 64
  if (ch == 95U) {
#line 64
    tmp___0 = 1;
  } else {
    {
#line 64
    tmp = is_wordch(ch);
    }
#line 64
    if (tmp) {
#line 64
      tmp___0 = 1;
    } else {
#line 64
      tmp___0 = 0;
    }
  }
#line 64
  return ((Boolean_t )tmp___0);
}
}
#line 24 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static struct window *window_list  ;
#line 25 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static struct window *active_window  ;
#line 26 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static struct display *display  ;
#line 27 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static int display_rows  ;
#line 27 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static int display_columns  ;
#line 28 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static Boolean_t titles  =    (Boolean_t )1;
#line 30 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static void title(struct window *window ) 
{ 
  char buff[128] ;
  struct view *view ;
  position_t cursor ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int line ;
  unsigned int tmp___2 ;
  int len ;
  size_t tmp___3 ;

  {
#line 36
  if (! titles) {
#line 37
    return;
  }
#line 38
  if ((unsigned long )window != (unsigned long )active_window) {
#line 39
    return;
  }
#line 40
  if (! window) {
    {
#line 41
    titles = display_title(display, (char const   *)((void *)0));
    }
#line 42
    return;
  }
#line 44
  view = window->view;
#line 45
  if ((view->text)->flags & (unsigned int )(1 << 3)) {
#line 45
    tmp___1 = " (new)";
  } else {
#line 45
    if ((view->text)->flags & (unsigned int )(1 << 1)) {
#line 45
      tmp___0 = " (read-only)";
    } else {
#line 45
      if ((view->text)->preserved != (view->text)->dirties) {
#line 45
        tmp = " (unsaved)";
      } else {
#line 45
        tmp = "";
      }
#line 45
      tmp___0 = tmp;
    }
#line 45
    tmp___1 = tmp___0;
  }
  {
#line 45
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%s%s",
           view->name, tmp___1);
#line 50
  cursor = locus_get(view, (locus_t )0);
  }
#line 51
  if (cursor < 65536UL) {
    {
#line 52
    tmp___2 = current_line_number(view, cursor);
#line 52
    line = (int )tmp___2;
#line 53
    tmp___3 = strlen((char const   *)(buff));
#line 53
    len = (int )tmp___3;
#line 54
    snprintf((char */* __restrict  */)(buff + len), (sizeof(buff) - (unsigned long )len) - 1UL,
             (char const   */* __restrict  */)" [%d]", line);
    }
  }
  {
#line 57
  titles = display_title(display, (char const   *)(buff));
  }
#line 58
  return;
}
}
#line 60 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static struct window *activate(struct window *window ) 
{ 


  {
#line 62
  if (active_window) {
#line 63
    active_window->repaint = (Boolean_t )1;
  }
  {
#line 64
  active_window = window;
#line 65
  title(window);
#line 66
  window->repaint = (Boolean_t )1;
  }
#line 67
  return (window);
}
}
#line 70 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static struct window *window_create(struct view *view , struct view *after ) 
{ 
  struct window *window ;
  void *tmp ;
  int tmp___0 ;

  {
#line 72
  window = view->window;
#line 74
  if (! window) {
    {
#line 75
    tmp = allocate0(sizeof(*window));
#line 75
    window = (struct window *)tmp;
#line 76
    window->view = view;
#line 77
    view->window = window;
#line 78
    window->start = locus_create(view, (position_t )(~ 0));
    }
#line 79
    if (after) {
#line 79
      if (after->window) {
#line 80
        window->next = (after->window)->next;
#line 81
        (after->window)->next = window;
      } else {
#line 83
        window->next = window_list;
#line 84
        window_list = window;
      }
    } else {
#line 83
      window->next = window_list;
#line 84
      window_list = window;
    }
  } else {
#line 87
    tmp___0 = 0;
#line 87
    window->column = tmp___0;
#line 87
    window->row = tmp___0;
  }
#line 88
  window->rows = display_rows;
#line 89
  window->columns = display_columns;
#line 90
  window->last_dirties = (unsigned int )(~ 0);
#line 91
  return (window);
}
}
#line 94 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static Boolean_t stacked(struct window *up , struct window *down ) 
{ 
  int tmp ;

  {
#line 96
  if (up) {
#line 96
    if (down) {
#line 96
      if (up->column == down->column) {
#line 96
        if (up->columns == down->columns) {
#line 96
          if (up->row + up->rows == down->row) {
#line 96
            tmp = 1;
          } else {
#line 96
            tmp = 0;
          }
        } else {
#line 96
          tmp = 0;
        }
      } else {
#line 96
        tmp = 0;
      }
    } else {
#line 96
      tmp = 0;
    }
  } else {
#line 96
    tmp = 0;
  }
#line 96
  return ((Boolean_t )tmp);
}
}
#line 102 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static Boolean_t beside(struct window *left , struct window *right ) 
{ 
  int tmp ;

  {
#line 104
  if (left) {
#line 104
    if (right) {
#line 104
      if (left->row == right->row) {
#line 104
        if (left->rows == right->rows) {
#line 104
          if (left->column + left->columns == right->column) {
#line 104
            tmp = 1;
          } else {
#line 104
            tmp = 0;
          }
        } else {
#line 104
          tmp = 0;
        }
      } else {
#line 104
        tmp = 0;
      }
    } else {
#line 104
      tmp = 0;
    }
  } else {
#line 104
    tmp = 0;
  }
#line 104
  return ((Boolean_t )tmp);
}
}
#line 110 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static Boolean_t adjacent(struct window *x , struct window *y ) 
{ 
  int tmp ;

  {
#line 112
  if (x->column + x->columns < y->column) {
#line 116
    return ((Boolean_t )0);
  } else
#line 112
  if (y->column + y->columns < x->column) {
#line 116
    return ((Boolean_t )0);
  } else
#line 112
  if (x->row + x->rows < y->row) {
#line 116
    return ((Boolean_t )0);
  } else
#line 112
  if (y->row + y->rows < x->row) {
#line 116
    return ((Boolean_t )0);
  }
#line 117
  if (y->column != x->column + x->columns) {
#line 117
    if (x->column != y->column + y->columns) {
#line 119
      return ((Boolean_t )1);
    }
  }
#line 120
  if (y->row < x->row + x->rows) {
#line 120
    if (x->row < y->row + y->rows) {
#line 120
      tmp = 1;
    } else {
#line 120
      tmp = 0;
    }
  } else {
#line 120
    tmp = 0;
  }
#line 120
  return ((Boolean_t )tmp);
}
}
#line 124 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static Boolean_t window_expand_next(struct window *window ) 
{ 
  struct window *next ;
  Boolean_t tmp ;
  Boolean_t tmp___0 ;

  {
#line 126
  next = window->next;
#line 127
  if (! next) {
#line 128
    return ((Boolean_t )0);
  }
  {
#line 129
  tmp = stacked(window, next);
  }
#line 129
  if (tmp) {
#line 130
    next->row = window->row;
#line 131
    next->rows += window->rows;
#line 132
    next->repaint = (Boolean_t )1;
#line 133
    return ((Boolean_t )1);
  }
  {
#line 135
  tmp___0 = beside(window, next);
  }
#line 135
  if (tmp___0) {
#line 136
    next->column = window->column;
#line 137
    next->columns += window->columns;
#line 138
    next->repaint = (Boolean_t )1;
#line 139
    return ((Boolean_t )1);
  }
#line 141
  return ((Boolean_t )0);
}
}
#line 144 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void window_destroy(struct window *window ) 
{ 
  struct window *previous ;
  struct window *wp ;
  struct window *next ;
  struct window *tmp ;
  Boolean_t tmp___0 ;
  Boolean_t tmp___1 ;
  Boolean_t tmp___2 ;
  Boolean_t tmp___3 ;
  Boolean_t tmp___4 ;
  Boolean_t tmp___5 ;

  {
#line 146
  previous = (struct window *)((void *)0);
#line 148
  if (! window) {
#line 149
    return;
  }
#line 150
  wp = window_list;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )wp != (unsigned long )window)) {
#line 150
      goto while_break;
    }
#line 151
    if ((unsigned long )wp == (unsigned long )window) {
#line 152
      goto while_break;
    }
#line 150
    previous = wp;
#line 150
    wp = wp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  if (! (! wp)) {
#line 155
    if (previous) {
      {
#line 156
      tmp = window->next;
#line 156
      previous->next = tmp;
#line 156
      next = tmp;
#line 157
      tmp___3 = stacked(previous, window);
      }
#line 157
      if (tmp___3) {
        {
#line 157
        tmp___4 = stacked(window, next);
        }
#line 157
        if (tmp___4) {
#line 157
          if (previous->rows <= next->rows) {
#line 160
            previous->rows += window->rows;
#line 161
            previous->repaint = (Boolean_t )1;
          } else {
#line 157
            goto _L___0;
          }
        } else {
#line 160
          previous->rows += window->rows;
#line 161
          previous->repaint = (Boolean_t )1;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 162
        tmp___1 = beside(previous, window);
        }
#line 162
        if (tmp___1) {
          {
#line 162
          tmp___2 = beside(window, next);
          }
#line 162
          if (tmp___2) {
#line 162
            if (previous->columns <= next->columns) {
#line 165
              previous->columns += window->columns;
#line 166
              previous->repaint = (Boolean_t )1;
            } else {
#line 162
              goto _L;
            }
          } else {
#line 165
            previous->columns += window->columns;
#line 166
            previous->repaint = (Boolean_t )1;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 167
          tmp___0 = window_expand_next(window);
          }
#line 167
          if (! tmp___0) {
            {
#line 168
            window_raise(previous->view);
            }
          }
        }
      }
    } else {
#line 169
      window_list = window->next;
#line 169
      if (window_list) {
        {
#line 169
        tmp___5 = window_expand_next(window);
        }
#line 169
        if (! tmp___5) {
          {
#line 171
          window_raise(window_list->view);
          }
        }
      }
    }
  }
#line 173
  if (window->view) {
    {
#line 174
    locus_destroy(window->view, window->start);
#line 175
    (window->view)->window = (struct window *)((void *)0);
    }
  }
#line 177
  if ((unsigned long )window == (unsigned long )active_window) {
#line 178
    active_window = (struct window *)((void *)0);
#line 179
    wp = window_list;
#line 180
    if (previous) {
#line 181
      wp = previous;
#line 182
      if (wp->next) {
#line 183
        wp = wp->next;
      }
    }
#line 185
    if (wp) {
      {
#line 186
      activate(wp);
      }
    }
  }
  {
#line 188
  reallocate((void const   *)window, (size_t )0);
#line 188
  window = (struct window *)((void *)0);
  }
#line 189
  return;
}
}
#line 191 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
struct window *window_raise(struct view *view ) 
{ 
  struct window *tmp ;
  struct window *tmp___0 ;

  {
#line 193
  if (! display) {
    {
#line 194
    display = display_init();
    }
  }
  {
#line 195
  display_get_geometry(display, & display_rows, & display_columns);
#line 196
  display_erase(display, 0, 0, display_rows, display_columns);
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (window_list) {
#line 197
      if (! ((unsigned long )window_list->view != (unsigned long )view)) {
#line 197
        goto while_break;
      }
    } else {
#line 197
      goto while_break;
    }
    {
#line 198
    window_destroy(window_list);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 199
    if (window_list) {
#line 199
      if (! window_list->next) {
#line 199
        goto while_break___0;
      }
    } else {
#line 199
      goto while_break___0;
    }
    {
#line 200
    window_destroy(window_list->next);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 201
  tmp = window_create(view, (struct view *)((void *)0));
#line 201
  tmp___0 = activate(tmp);
  }
#line 201
  return (tmp___0);
}
}
#line 204 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
struct window *window_activate(struct view *view ) 
{ 
  struct window *tmp ;
  struct window *tmp___0 ;

  {
#line 206
  if (view->window) {
    {
#line 207
    tmp = activate(view->window);
    }
#line 207
    return (tmp);
  }
  {
#line 208
  tmp___0 = window_raise(view);
  }
#line 208
  return (tmp___0);
}
}
#line 211 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
struct window *window_after(struct view *before , struct view *view , int vertical ) 
{ 
  struct window *window ;
  struct window *old ;
  struct window *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct window *tmp___4 ;

  {
#line 216
  if (view->window) {
#line 217
    return (view->window);
  }
#line 218
  if (! before) {
    {
#line 222
    tmp = window_raise(view);
    }
#line 222
    return (tmp);
  } else {
#line 218
    old = before->window;
#line 218
    if (old) {
#line 218
      if (old->rows < 4) {
        {
#line 222
        tmp = window_raise(view);
        }
#line 222
        return (tmp);
      } else
#line 218
      if (old->columns < 16) {
        {
#line 222
        tmp = window_raise(view);
        }
#line 222
        return (tmp);
      }
    } else {
      {
#line 222
      tmp = window_raise(view);
      }
#line 222
      return (tmp);
    }
  }
  {
#line 223
  window = window_create(view, before);
  }
#line 224
  if (vertical < 0) {
#line 225
    vertical = old->columns > 120;
  }
#line 226
  if (vertical) {
#line 227
    window->row = old->row;
#line 228
    window->rows = old->rows;
#line 229
    tmp___0 = old->columns >> 1;
#line 229
    window->columns = tmp___0;
#line 229
    tmp___1 = old->columns - tmp___0;
#line 229
    old->columns = tmp___1;
#line 229
    window->column = old->column + tmp___1;
  } else {
#line 232
    window->column = old->column;
#line 233
    window->columns = old->columns;
#line 234
    tmp___2 = old->rows >> 1;
#line 234
    window->rows = tmp___2;
#line 234
    tmp___3 = old->rows - tmp___2;
#line 234
    old->rows = tmp___3;
#line 234
    window->row = old->row + tmp___3;
  }
  {
#line 237
  old->repaint = (Boolean_t )1;
#line 238
  tmp___4 = activate(window);
  }
#line 238
  return (tmp___4);
}
}
#line 241 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
struct window *window_below(struct view *above , struct view *view , unsigned int rows___0 ) 
{ 
  struct window *window ;
  struct window *old ;
  struct window *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 245
  if (view->window) {
#line 246
    return (view->window);
  }
#line 247
  if (! above) {
#line 247
    if (active_window) {
#line 248
      above = active_window->view;
    }
  }
#line 249
  if (! above) {
    {
#line 250
    tmp = window_raise(view);
    }
#line 250
    return (tmp);
  } else {
#line 249
    old = above->window;
#line 249
    if (old) {
#line 249
      if ((unsigned int )old->rows < rows___0 * 2U) {
        {
#line 250
        tmp = window_raise(view);
        }
#line 250
        return (tmp);
      }
    } else {
      {
#line 250
      tmp = window_raise(view);
      }
#line 250
      return (tmp);
    }
  }
  {
#line 251
  window = window_create(view, above);
#line 252
  window->column = old->column;
#line 253
  window->columns = old->columns;
#line 254
  tmp___0 = (int )rows___0;
#line 254
  window->rows = tmp___0;
#line 254
  tmp___1 = old->rows - tmp___0;
#line 254
  old->rows = tmp___1;
#line 254
  window->row = old->row + tmp___1;
  }
#line 255
  return (window);
}
}
#line 258 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
struct window *window_replace(struct view *old , struct view *new ) 
{ 
  struct window *window ;
  struct window *tmp ;
  position_t tmp___0 ;
  struct window *tmp___1 ;
  struct window *tmp___2 ;

  {
#line 260
  window = old->window;
#line 262
  if (! new) {
#line 263
    return ((struct window *)((void *)0));
  }
#line 264
  if (new->window) {
#line 265
    return (new->window);
  }
#line 266
  if (! old) {
    {
#line 267
    tmp = window_raise(new);
    }
#line 267
    return (tmp);
  } else
#line 266
  if (! window) {
    {
#line 267
    tmp = window_raise(new);
    }
#line 267
    return (tmp);
  }
  {
#line 268
  window->view = new;
#line 269
  old->window = (struct window *)((void *)0);
#line 270
  locus_destroy(old, window->start);
#line 271
  tmp___0 = locus_get(new, (locus_t )0);
#line 271
  window->start = locus_create(new, tmp___0 + 1UL);
#line 272
  tmp___1 = window;
#line 272
  new->window = tmp___1;
#line 272
  tmp___2 = activate(tmp___1);
  }
#line 272
  return (tmp___2);
}
}
#line 275 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
struct view *window_current_view(void) 
{ 


  {
#line 277
  if (! active_window) {
#line 278
    if (! text_list) {
      {
#line 279
      view_help();
      }
    }
    {
#line 280
    window_raise(text_list->views);
    }
  }
#line 282
  return (active_window->view);
}
}
#line 285 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void windows_end_display(void) 
{ 
  struct window *window ;

  {
#line 288
  if (display) {
    {
#line 289
    display_end(display);
#line 290
    display = (struct display *)((void *)0);
    }
  }
#line 292
  window = window_list;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! window) {
#line 292
      goto while_break;
    }
#line 293
    window->repaint = (Boolean_t )1;
#line 292
    window = window->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return;
}
}
#line 296 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void windows_end(void) 
{ 


  {
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! window_list) {
#line 298
      goto while_break;
    }
    {
#line 299
    window_destroy(window_list);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 300
  windows_end_display();
  }
#line 301
  return;
}
}
#line 303 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static unsigned int count_rows(struct window *window , position_t start , position_t end ) 
{ 
  unsigned int rows___0 ;
  unsigned int bytes ;
  unsigned int max_rows ;
  position_t tmp ;

  {
#line 306
  rows___0 = 0U;
#line 306
  max_rows = (unsigned int )(window->rows + 1);
#line 308
  rows___0 = 0U;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (start < end) {
#line 308
      if (! (rows___0 < max_rows)) {
#line 308
        goto while_break;
      }
    } else {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = find_row_bytes(window->view, start, 0U, (unsigned int )window->columns);
#line 309
    bytes = (unsigned int )tmp;
    }
#line 309
    if (! bytes) {
#line 311
      goto while_break;
    }
#line 308
    rows___0 ++;
#line 308
    start += (position_t )bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return (rows___0);
}
}
#line 315 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static position_t find_row_start(struct window *window , position_t position , position_t start ) 
{ 
  size_t bytes ;

  {
#line 319
  if (position) {
#line 319
    if (position >= (window->view)->bytes) {
#line 320
      position --;
    }
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 321
    bytes = find_row_bytes(window->view, start, 0U, (unsigned int )window->columns);
    }
#line 321
    if (! bytes) {
#line 321
      goto while_break;
    }
#line 322
    if (start + bytes > position) {
#line 323
      goto while_break;
    }
#line 324
    start += bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return (start);
}
}
#line 329 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static void new_start(struct view *view , position_t start ) 
{ 


  {
#line 331
  if (start) {
    {
#line 332
    view_char_prior(view, start, & start);
    }
  } else {
#line 334
    start = (position_t )(~ 0);
  }
  {
#line 335
  locus_set(view, (view->window)->start, start);
#line 336
  (view->window)->last_dirties = (unsigned int )(~ 0);
  }
#line 337
  return;
}
}
#line 339 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static position_t screen_start(struct view *view ) 
{ 
  position_t start ;
  position_t tmp ;

  {
  {
#line 341
  tmp = locus_get(view, (view->window)->start);
#line 341
  start = tmp;
  }
#line 342
  if (start == 0xffffffffffffffffUL) {
#line 343
    start = (position_t )0;
  } else {
    {
#line 345
    view_char(view, start, & start);
    }
  }
#line 346
  return (start);
}
}
#line 349 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static position_t focus(struct window *window ) 
{ 
  struct view *view ;
  position_t cursor ;
  position_t tmp ;
  position_t cursorrow ;
  position_t tmp___0 ;
  position_t tmp___1 ;
  position_t start ;
  position_t tmp___2 ;
  position_t end ;
  position_t at ;
  unsigned int above ;
  unsigned int below ;
  size_t bytes ;
  position_t tmp___3 ;
  position_t tmp___4 ;
  position_t tmp___5 ;
  unsigned int tmp___6 ;
  position_t tmp___7 ;
  unsigned int tmp___8 ;
  position_t tmp___9 ;
  unsigned int tmp___10 ;

  {
  {
#line 351
  view = window->view;
#line 352
  tmp = locus_get(view, (locus_t )0);
#line 352
  cursor = tmp;
#line 353
  tmp___0 = find_line_start(view, cursor);
#line 353
  tmp___1 = find_row_start(window, cursor, tmp___0);
#line 353
  cursorrow = tmp___1;
#line 355
  tmp___2 = screen_start(view);
#line 355
  start = tmp___2;
#line 357
  above = 0U;
#line 360
  tmp___3 = find_line_start(view, start);
#line 360
  start = find_row_start(window, start, tmp___3);
  }
#line 363
  if (cursorrow < start) {
    {
#line 363
    tmp___4 = find_row_bytes(view, cursorrow, 0U, (unsigned int )window->columns);
    }
#line 363
    if (start == cursorrow + tmp___4) {
#line 366
      start = cursorrow;
#line 367
      goto done;
    }
  }
#line 369
  if (cursorrow >= start) {
    {
#line 369
    above = count_rows(window, start, cursorrow);
    }
#line 369
    if (above == (unsigned int )window->rows) {
      {
#line 371
      tmp___5 = find_row_bytes(view, start, 0U, (unsigned int )window->columns);
#line 371
      start += tmp___5;
#line 372
      above --;
      }
#line 373
      goto done;
    }
  }
#line 376
  if (cursorrow >= start) {
#line 376
    if (above < (unsigned int )window->rows) {
#line 377
      below = 1U;
#line 377
      at = cursorrow;
      {
#line 377
      while (1) {
        while_continue: /* CIL Label */ ;
#line 377
        if (! (above + below < (unsigned int )window->rows)) {
#line 377
          goto while_break;
        }
        {
#line 380
        bytes = find_row_bytes(view, at, 0U, (unsigned int )window->columns);
        }
#line 380
        if (! bytes) {
#line 382
          goto while_break;
        }
#line 377
        below ++;
#line 377
        at += bytes;
      }
      while_break: /* CIL Label */ ;
      }
#line 383
      if (above + below == (unsigned int )window->rows) {
#line 384
        goto done;
      } else
#line 383
      if (! start) {
#line 384
        goto done;
      }
    }
  }
#line 387
  start = cursorrow;
#line 387
  above = 0U;
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 387
    end = start;
#line 387
    if (end) {
#line 387
      if (! (above < (unsigned int )(window->rows >> 1))) {
#line 387
        goto while_break___0;
      }
    } else {
#line 387
      goto while_break___0;
    }
    {
#line 390
    start = find_line_start(view, start - 1UL);
#line 387
    tmp___6 = count_rows(window, start, end);
#line 387
    above += tmp___6;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 391
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 391
    if (! (above >= (unsigned int )(window->rows >> 1))) {
#line 391
      goto while_break___1;
    }
    {
#line 392
    tmp___7 = find_row_bytes(view, start, 0U, (unsigned int )window->columns);
#line 392
    start += tmp___7;
#line 391
    above --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 394
  below = 1U;
#line 394
  at = cursorrow;
  {
#line 394
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 394
    if (! (above + below < (unsigned int )window->rows)) {
#line 394
      goto while_break___2;
    }
    {
#line 397
    bytes = find_row_bytes(view, at, 0U, (unsigned int )window->columns);
    }
#line 397
    if (! bytes) {
#line 398
      goto while_break___2;
    }
#line 394
    below ++;
#line 394
    at += bytes;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 399
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 399
    end = start;
#line 399
    if (end) {
#line 399
      if (! (above + below < (unsigned int )window->rows)) {
#line 399
        goto while_break___3;
      }
    } else {
#line 399
      goto while_break___3;
    }
    {
#line 401
    start = find_line_start(view, start - 1UL);
#line 399
    tmp___8 = count_rows(window, start, end);
#line 399
    above += tmp___8;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 402
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 402
    if (! (above + below > (unsigned int )window->rows)) {
#line 402
      goto while_break___4;
    }
    {
#line 403
    tmp___9 = find_row_bytes(view, start, 0U, (unsigned int )window->columns);
#line 403
    start += tmp___9;
#line 402
    above --;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  done: 
  {
#line 405
  tmp___10 = find_column(& above, view, cursorrow, cursor, 0U);
#line 405
  window->cursor_column = (int )tmp___10;
#line 407
  window->cursor_row = (int )above;
#line 408
  new_start(view, start);
  }
#line 409
  return (start);
}
}
#line 412 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static Boolean_t lame_space(struct view *view , position_t start , unsigned int next_tab ) 
{ 
  unsigned int distance ;
  position_t offset ;
  Unicode_t ch ;
  Unicode_t tmp ;
  int tmp___0 ;

  {
#line 415
  distance = 0U;
#line 416
  offset = start;
#line 418
  if (view->shell_std_in >= 0) {
#line 419
    return ((Boolean_t )0);
  } else
#line 418
  if ((view->text)->flags & (unsigned int )(1 << 2)) {
#line 419
    return ((Boolean_t )0);
  }
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 421
    distance ++;
#line 422
    ch = view_char(view, offset, & offset);
    }
#line 423
    if (! (ch < 1U << 31)) {
#line 424
      return ((Boolean_t )1);
    } else
#line 423
    if (ch == 10U) {
#line 424
      return ((Boolean_t )1);
    } else
#line 423
    if (ch == 9U) {
#line 424
      return ((Boolean_t )1);
    }
#line 420
    if (! (ch == 32U)) {
#line 420
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  if (distance > next_tab) {
#line 426
    if (! ((view->text)->flags & (unsigned int )(1 << 5))) {
#line 426
      if (next_tab) {
#line 426
        tmp___0 = 1;
      } else {
        {
#line 426
        tmp = view_char_prior(view, start - 1UL, (position_t *)((void *)0));
        }
#line 426
        if (tmp == 32U) {
#line 426
          tmp___0 = 1;
        } else {
#line 426
          tmp___0 = 0;
        }
      }
    } else {
#line 426
      tmp___0 = 0;
    }
  } else {
#line 426
    tmp___0 = 0;
  }
#line 426
  return ((Boolean_t )tmp___0);
}
}
#line 432 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static Boolean_t lame_tab(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;

  {
#line 435
  if (view->shell_std_in >= 0) {
#line 436
    return ((Boolean_t )0);
  } else
#line 435
  if ((view->text)->flags & (unsigned int )(1 << 2)) {
#line 436
    return ((Boolean_t )0);
  }
#line 437
  if ((view->text)->flags & (unsigned int )(1 << 5)) {
#line 438
    return ((Boolean_t )1);
  }
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 439
    ch = view_char(view, offset, & offset);
    }
#line 439
    if (ch < 1U << 31) {
#line 439
      if (! (ch != 10U)) {
#line 439
        goto while_break;
      }
    } else {
#line 439
      goto while_break;
    }
#line 442
    if (ch != 32U) {
#line 442
      if (ch != 9U) {
#line 443
        return ((Boolean_t )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  return ((Boolean_t )1);
}
}
#line 447 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static int paintch(struct window *window , Unicode_t ch , int row , int column , position_t at ,
                   position_t cursor , position_t mark , unsigned int *brackets ,
                   rgba_t fgrgba ) 
{ 
  rgba_t bgrgba ;
  unsigned int tabstop ;
  char const   *brack ;
  rgba_t rgba ;
  Boolean_t tmp ;
  Boolean_t tmp___0 ;
  rgba_t bg ;
  unsigned int tmp___2 ;
  Boolean_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  Boolean_t tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
#line 451
  bgrgba = window->bgrgba;
#line 452
  tabstop = ((window->view)->text)->tabstop;
#line 453
  brack = ((window->view)->text)->brackets;
#line 455
  if (ch == 10U) {
#line 456
    return (column);
  }
#line 458
  if (mark != 0xffffffffffffffffUL) {
#line 458
    if (at >= cursor) {
#line 458
      if (at < mark) {
#line 461
        bgrgba = ((window->view)->mode)->selection_bgrgba;
#line 462
        fgrgba = 4278190080U;
      } else {
#line 458
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 458
    if (at >= mark) {
#line 458
      if (at < cursor) {
#line 461
        bgrgba = ((window->view)->mode)->selection_bgrgba;
#line 462
        fgrgba = 4278190080U;
      } else {
#line 458
        goto _L;
      }
    } else {
#line 458
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 463
  if (at == cursor) {
#line 464
    rgba = (rgba_t )16711680;
#line 465
    if (mark != 0xffffffffffffffffUL) {
#line 466
      rgba = (rgba_t )65280;
    } else
#line 467
    if (((window->view)->text)->flags & (unsigned int )(1 << 1)) {
#line 468
      rgba = 4278190080U;
    } else {
      {
#line 469
      tmp = text_is_dirty((window->view)->text);
      }
#line 469
      if (tmp) {
#line 470
        rgba = 4278255360U;
      }
    }
    {
#line 471
    tmp___0 = display_cursor_color(display, rgba);
    }
#line 471
    if (! tmp___0) {
#line 472
      fgrgba = rgba;
    }
  }
#line 475
  if (ch == 9U) {
    {
#line 476
    tmp___3 = lame_tab(window->view, at + 1UL);
    }
#line 476
    if (tmp___3) {
#line 476
      tmp___2 = 4278255360U;
    } else {
#line 476
      tmp___2 = bgrgba;
    }
#line 476
    bg = tmp___2;
    {
#line 478
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 479
      tmp___4 = column;
#line 479
      column ++;
#line 479
      display_put(display, window->row + row, window->column + tmp___4, (Unicode_t )' ',
                  fgrgba, bg);
#line 481
      bg = bgrgba;
      }
#line 478
      if (! ((unsigned int )column % tabstop)) {
#line 478
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 483
    return (column);
  }
#line 486
  if (ch < 32U) {
#line 486
    goto _L___2;
  } else
#line 486
  if (ch == 127U) {
#line 486
    goto _L___2;
  } else
#line 486
  if (ch - 1073741824U < 536870912U) {
    _L___2: /* CIL Label */ 
#line 487
    fgrgba = 4294967040U;
#line 488
    bgrgba = 4278190080U;
#line 489
    if (ch - 1073741824U < 536870912U) {
#line 489
      tmp___5 = '<';
    } else {
#line 489
      tmp___5 = '^';
    }
    {
#line 489
    tmp___6 = column;
#line 489
    column ++;
#line 489
    display_put(display, window->row + row, window->column + tmp___6, (Unicode_t )tmp___5,
                fgrgba, bgrgba);
    }
#line 492
    if (ch - 1073741824U < 536870912U) {
#line 493
      ch = (Unicode_t )'>';
    } else
#line 494
    if (ch == 127U) {
#line 495
      ch = (Unicode_t )'?';
    } else {
#line 497
      ch += 64U;
    }
  } else
#line 498
  if (ch == 32U) {
#line 499
    if (bgrgba == window->bgrgba) {
      {
#line 499
      tmp___7 = lame_space(window->view, at + 1UL, (tabstop - 1U) - (unsigned int )column % tabstop);
      }
#line 499
      if (tmp___7) {
#line 502
        bgrgba = 4278255360U;
      }
    }
  } else
#line 503
  if (! (ch < 1U << 31)) {
#line 504
    ch = (Unicode_t )' ';
#line 504
    bgrgba = 4278255360U;
  } else
#line 505
  if (brackets) {
#line 505
    if (brack) {
      {
#line 506
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 506
        if (! *brack) {
#line 506
          goto while_break___0;
        }
#line 507
        if (ch == (Unicode_t )*(brack + 0)) {
#line 507
          tmp___8 = *brackets;
#line 507
          (*brackets) ++;
#line 507
          if (tmp___8 & 1U) {
#line 509
            fgrgba = (rgba_t )65280;
#line 510
            goto while_break___0;
          } else {
#line 507
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 507
        if (ch == (Unicode_t )*(brack + 1)) {
#line 507
          (*brackets) --;
#line 507
          if (*brackets & 1U) {
#line 509
            fgrgba = (rgba_t )65280;
#line 510
            goto while_break___0;
          }
        }
#line 506
        brack += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 513
  tmp___9 = column;
#line 513
  column ++;
#line 513
  display_put(display, window->row + row, window->column + tmp___9, ch, fgrgba, bgrgba);
  }
#line 515
  return (column);
}
}
#line 518 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static Boolean_t needs_repainting(struct window *window ) 
{ 
  struct view *view ;
  position_t cursor ;
  position_t tmp ;
  position_t mark ;
  position_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 520
  view = window->view;
#line 521
  tmp = locus_get(view, (locus_t )0);
#line 521
  cursor = tmp;
#line 522
  tmp___0 = locus_get(view, (locus_t )1);
#line 522
  mark = tmp___0;
  }
#line 524
  if (window->repaint) {
#line 524
    tmp___1 = 1;
  } else
#line 524
  if ((view->text)->dirties != window->last_dirties) {
#line 524
    tmp___1 = 1;
  } else
#line 524
  if (window->last_cursor != cursor) {
#line 524
    tmp___1 = 1;
  } else
#line 524
  if (window->last_mark != mark) {
#line 524
    tmp___1 = 1;
  } else
#line 524
  if ((unsigned long )window->last_mode != (unsigned long )view->mode) {
#line 524
    tmp___1 = 1;
  } else {
#line 524
    tmp___1 = 0;
  }
#line 524
  return ((Boolean_t )tmp___1);
}
}
#line 531 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static void repainted(struct window *window , position_t cursor , position_t mark ) 
{ 


  {
#line 533
  window->repaint = (Boolean_t )0;
#line 534
  window->last_dirties = ((window->view)->text)->dirties;
#line 535
  window->last_cursor = cursor;
#line 536
  window->last_mark = mark;
#line 537
  window->last_mode = (window->view)->mode;
#line 538
  return;
}
}
#line 540 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static void paint(struct window *window ) 
{ 
  sposition_t at ;
  int row ;
  int column ;
  struct view *view ;
  position_t cursor ;
  position_t tmp ;
  position_t mark ;
  position_t tmp___0 ;
  sposition_t comment_end ;
  sposition_t string_end ;
  unsigned int brackets ;
  Boolean_t keywords ;
  int tmp___1 ;
  position_t tmp___2 ;
  sposition_t start ;
  sposition_t tmp___3 ;
  position_t limit ;
  position_t tmp___4 ;
  rgba_t fgrgba ;
  Boolean_t look_for_keyword ;
  position_t next ;
  unsigned int *brackets_ptr ;
  Unicode_t ch ;
  Unicode_t tmp___5 ;
  Boolean_t tmp___6 ;
  Boolean_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 544
  view = window->view;
#line 545
  tmp = locus_get(view, (locus_t )0);
#line 545
  cursor = tmp;
#line 546
  tmp___0 = locus_get(view, (locus_t )1);
#line 546
  mark = tmp___0;
#line 547
  comment_end = (sposition_t )-1;
#line 548
  string_end = (sposition_t )-1;
#line 549
  brackets = 1U;
  }
#line 550
  if (! no_keywords) {
#line 550
    if ((unsigned long )window == (unsigned long )active_window) {
#line 550
      if ((view->text)->keywords) {
#line 550
        tmp___1 = 1;
      } else {
#line 550
        tmp___1 = 0;
      }
    } else {
#line 550
      tmp___1 = 0;
    }
  } else {
#line 550
    tmp___1 = 0;
  }
  {
#line 550
  keywords = (Boolean_t )tmp___1;
#line 554
  title(window);
#line 556
  tmp___2 = focus(window);
#line 556
  at = (sposition_t )tmp___2;
  }
#line 557
  if (keywords) {
#line 557
    if ((view->text)->comment_start) {
      {
#line 558
      tmp___3 = (*((view->text)->comment_start))(view, (position_t )at);
#line 558
      start = tmp___3;
      }
#line 559
      if (start >= 0L) {
        {
#line 560
        comment_end = (*((view->text)->comment_end))(view, (position_t )start);
        }
      }
    }
  }
#line 563
  row = 0;
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! (row < window->rows)) {
#line 563
      goto while_break;
    }
    {
#line 565
    tmp___4 = find_row_bytes(view, (position_t )at, 0U, (unsigned int )window->columns);
#line 565
    limit = (position_t )at + tmp___4;
#line 567
    fgrgba = window->fgrgba;
#line 568
    look_for_keyword = keywords;
#line 570
    brackets_ptr = & brackets;
#line 572
    column = 0;
    }
    {
#line 572
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 572
      if (! ((position_t )at < limit)) {
#line 572
        goto while_break___0;
      }
      {
#line 574
      tmp___5 = view_char(view, (position_t )at, & next);
#line 574
      ch = tmp___5;
      }
#line 576
      if (ch == 47U) {
#line 576
        goto _L;
      } else
#line 576
      if (ch == 45U) {
#line 576
        goto _L;
      } else
#line 576
      if (ch == 123U) {
        _L: /* CIL Label */ 
#line 576
        if (at > comment_end) {
#line 576
          if (at > string_end) {
#line 576
            if (keywords) {
#line 576
              if ((view->text)->comment_end) {
                {
#line 581
                comment_end = (*((view->text)->comment_end))(view, (position_t )at);
                }
              }
            }
          }
        }
      }
#line 582
      if (ch == 34U) {
#line 582
        goto _L___0;
      } else
#line 582
      if (ch == 39U) {
        _L___0: /* CIL Label */ 
#line 582
        if (at > comment_end) {
#line 582
          if (at > string_end) {
#line 582
            if (keywords) {
#line 582
              if ((view->text)->string_end) {
                {
#line 587
                string_end = (*((view->text)->string_end))(view, (position_t )at);
                }
              }
            }
          }
        }
      }
#line 589
      if (at <= comment_end) {
#line 590
        fgrgba = 4278255360U;
#line 591
        brackets_ptr = (unsigned int *)((void *)0);
      } else
#line 592
      if (at <= string_end) {
#line 593
        fgrgba = 4278190080U;
#line 594
        brackets_ptr = (unsigned int *)((void *)0);
      } else {
        {
#line 595
        tmp___7 = is_idch(ch);
        }
#line 595
        if (tmp___7) {
          _L___1: /* CIL Label */ 
#line 598
          if (look_for_keyword) {
            {
#line 598
            tmp___6 = is_keyword(view, (position_t )at);
            }
#line 598
            if (tmp___6) {
#line 599
              fgrgba = (rgba_t )65280;
            } else {
#line 601
              look_for_keyword = (Boolean_t )0;
            }
          } else {
#line 601
            look_for_keyword = (Boolean_t )0;
          }
        } else
#line 595
        if (ch != 35U) {
#line 596
          fgrgba = window->fgrgba;
#line 597
          look_for_keyword = keywords;
        } else {
#line 595
          goto _L___1;
        }
      }
      {
#line 603
      column = paintch(window, ch, row, column, (position_t )at, cursor, mark, brackets_ptr,
                       fgrgba);
      }
#line 607
      if (at == comment_end) {
#line 608
        fgrgba = window->fgrgba;
#line 609
        brackets_ptr = & brackets;
#line 610
        look_for_keyword = keywords;
      } else
#line 607
      if (at == string_end) {
#line 608
        fgrgba = window->fgrgba;
#line 609
        brackets_ptr = & brackets;
#line 610
        look_for_keyword = keywords;
      }
#line 572
      at = (sposition_t )next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 614
    display_erase(display, window->row + row, window->column + column, 1, (window->columns - column) - 1);
    }
    {
#line 617
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 617
      if (! (column < window->columns)) {
#line 617
        goto while_break___1;
      }
      {
#line 618
      tmp___8 = column;
#line 618
      column ++;
#line 618
      display_put(display, window->row + row, window->column + tmp___8, (Unicode_t )' ',
                  (rgba_t )255, window->bgrgba);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 563
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 623
  repainted(window, cursor, mark);
  }
#line 624
  return;
}
}
#line 626 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void window_hint_deleting(struct window *window , position_t offset , size_t bytes ) 
{ 
  struct view *view ;
  position_t at ;
  position_t tmp ;
  unsigned int row ;
  unsigned int column ;
  unsigned int lines ;
  unsigned int end_column ;
  position_t tmp___0 ;
  Unicode_t tmp___1 ;
  unsigned int old ;
  position_t tmp___2 ;
  unsigned int new ;
  position_t tmp___3 ;

  {
  {
#line 629
  view = window->view;
#line 630
  tmp = screen_start(view);
#line 630
  at = tmp;
#line 631
  row = 0U;
#line 632
  lines = 0U;
#line 634
  tmp___0 = focus(window);
  }
#line 634
  if (tmp___0 != at) {
#line 635
    return;
  } else
#line 634
  if (offset + bytes <= at) {
#line 635
    return;
  }
#line 636
  if (offset < at) {
#line 637
    bytes -= at - offset;
#line 638
    offset = at;
  }
#line 640
  if (! bytes) {
#line 641
    return;
  } else {
    {
#line 640
    tmp___1 = view_char(view, offset, (size_t *)((void *)0));
    }
#line 640
    if (tmp___1 >= 1073741824U) {
#line 641
      return;
    }
  }
  {
#line 642
  column = find_column(& row, view, at, offset, 0U);
  }
#line 643
  if (row >= (unsigned int )window->rows) {
#line 644
    return;
  }
  {
#line 645
  end_column = find_column(& lines, view, offset, offset + bytes, column);
  }
#line 647
  if (! lines) {
    {
#line 648
    tmp___2 = find_row_bytes(view, offset, column, (unsigned int )window->columns);
#line 648
    old = (unsigned int )tmp___2;
#line 650
    tmp___3 = find_row_bytes(view, offset + bytes, end_column, (unsigned int )window->columns);
#line 650
    new = (unsigned int )tmp___3;
    }
#line 652
    if ((size_t )new + bytes == (size_t )old) {
      {
#line 653
      display_delete_chars(display, (int )((unsigned int )window->row + row), (int )((unsigned int )window->column + column),
                           (int )(end_column - column), (int )((unsigned int )window->columns - column));
      }
#line 657
      return;
    }
#line 659
    lines ++;
  }
#line 661
  if (row + lines >= (unsigned int )window->rows) {
#line 662
    lines = (unsigned int )window->rows - row;
#line 663
    end_column = 0U;
  }
  {
#line 665
  display_delete_lines(display, (int )((unsigned int )window->row + row), window->column,
                       (int )lines, (int )((unsigned int )window->rows - row), window->columns);
  }
#line 667
  return;
}
}
#line 669 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void window_hint_inserted(struct window *window , position_t offset , size_t bytes ) 
{ 
  struct view *view ;
  position_t at ;
  position_t tmp ;
  position_t column ;
  position_t end_column ;
  unsigned int row ;
  unsigned int lines ;
  position_t tmp___0 ;
  Unicode_t tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  size_t old ;
  position_t tmp___4 ;
  size_t new ;
  position_t tmp___5 ;

  {
  {
#line 672
  view = window->view;
#line 673
  tmp = screen_start(view);
#line 673
  at = tmp;
#line 675
  row = 0U;
#line 675
  lines = 0U;
#line 677
  tmp___0 = focus(window);
  }
#line 677
  if (tmp___0 != at) {
#line 678
    return;
  } else
#line 677
  if (offset + bytes <= at) {
#line 678
    return;
  }
#line 679
  if (offset < at) {
#line 680
    bytes -= at - offset;
#line 681
    offset = at;
  }
#line 683
  if (! bytes) {
#line 684
    return;
  } else {
    {
#line 683
    tmp___1 = view_char(view, offset, (size_t *)((void *)0));
    }
#line 683
    if (tmp___1 >= 1073741824U) {
#line 684
      return;
    }
  }
  {
#line 685
  tmp___2 = find_column(& row, view, at, offset, 0U);
#line 685
  column = (position_t )tmp___2;
  }
#line 686
  if (row >= (unsigned int )window->rows) {
#line 687
    return;
  }
  {
#line 688
  tmp___3 = find_column(& lines, view, offset, offset + bytes, (unsigned int )column);
#line 688
  end_column = (position_t )tmp___3;
  }
#line 690
  if (! lines) {
    {
#line 691
    tmp___4 = find_row_bytes(view, offset + bytes, (unsigned int )end_column, (unsigned int )window->columns);
#line 691
    old = tmp___4;
#line 693
    tmp___5 = find_row_bytes(view, offset, (unsigned int )column, (unsigned int )window->columns);
#line 693
    new = tmp___5;
    }
#line 695
    if (new == old + bytes) {
      {
#line 696
      display_insert_spaces(display, (int )((unsigned int )window->row + row), (int )((position_t )window->column + column),
                            (int )(end_column - column), (int )((position_t )window->columns - column));
      }
#line 700
      return;
    }
#line 702
    lines ++;
  }
#line 704
  if (row + lines >= (unsigned int )window->rows) {
#line 705
    lines = (unsigned int )window->rows - row;
#line 706
    end_column = (position_t )0;
  }
  {
#line 708
  display_insert_lines(display, (int )((unsigned int )window->row + row), window->column,
                       (int )lines, (int )((unsigned int )window->rows - row), window->columns);
  }
#line 710
  return;
}
}
#line 712 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void window_next(struct view *view ) 
{ 
  struct window *tmp ;

  {
#line 714
  if (view) {
#line 714
    if (view->window) {
#line 715
      if ((view->window)->next) {
#line 715
        tmp = (view->window)->next;
      } else {
#line 715
        tmp = window_list;
      }
      {
#line 715
      activate(tmp);
      }
    }
  }
#line 716
  return;
}
}
#line 718 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void window_index(int num ) 
{ 
  struct window *window ;

  {
#line 720
  window = window_list;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    num --;
#line 721
    if (num > 0) {
#line 721
      if (! window->next) {
#line 721
        goto while_break;
      }
    } else {
#line 721
      goto while_break;
    }
#line 722
    window = window->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 723
  activate(window);
  }
#line 724
  return;
}
}
#line 726 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
struct window *window_recenter(struct view *view ) 
{ 
  struct window *window ;
  position_t cursor ;
  position_t tmp ;
  position_t start ;
  position_t end ;
  int row ;
  int rows___0 ;
  int columns___0 ;
  position_t tmp___0 ;
  unsigned int tmp___1 ;
  position_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 728
  window = view->window;
#line 729
  tmp = locus_get(view, (locus_t )0);
#line 729
  cursor = tmp;
  }
#line 733
  if (! display) {
    {
#line 734
    display = display_init();
    }
  }
  {
#line 735
  display_get_geometry(display, & rows___0, & columns___0);
  }
#line 736
  if (rows___0 != display_rows) {
    {
#line 739
    window = window_raise(view);
    }
  } else
#line 736
  if (columns___0 != display_columns) {
    {
#line 739
    window = window_raise(view);
    }
  } else {
#line 736
    window = view->window;
#line 736
    if (! window) {
      {
#line 739
      window = window_raise(view);
      }
    }
  }
  {
#line 741
  tmp___0 = find_line_start(view, cursor);
#line 741
  start = find_row_start(window, cursor, tmp___0);
#line 742
  row = 0;
  }
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    end = start;
#line 742
    if (end) {
#line 742
      if (! (row < window->rows >> 1)) {
#line 742
        goto while_break;
      }
    } else {
#line 742
      goto while_break;
    }
    {
#line 745
    start = find_line_start(view, start - 1UL);
#line 742
    tmp___1 = count_rows(window, start, end);
#line 742
    row = (int )((unsigned int )row + tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 746
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 746
    tmp___3 = row;
#line 746
    row --;
#line 746
    if (! (tmp___3 > window->rows >> 1)) {
#line 746
      goto while_break___0;
    }
    {
#line 747
    tmp___2 = find_row_bytes(view, start, 0U, (unsigned int )window->columns);
#line 747
    start += tmp___2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 748
  new_start(view, start);
  }
#line 749
  return (window);
}
}
#line 754 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static int overlap_percent  ;
#line 752 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static int page_overlap(struct window *window ) 
{ 
  int o ;
  char const   *p ;
  char *tmp ;

  {
#line 757
  if (! overlap_percent) {
    {
#line 758
    tmp = getenv("AOEUI_OVERLAP");
#line 758
    p = (char const   *)tmp;
#line 759
    overlap_percent = 1;
    }
#line 760
    if (p) {
      {
#line 761
      overlap_percent = atoi(p);
      }
#line 762
      if (overlap_percent < 0) {
#line 763
        overlap_percent = 1;
      } else
#line 764
      if (overlap_percent > 100) {
#line 765
        overlap_percent = 100;
      }
    }
  }
#line 768
  o = (overlap_percent * window->rows) / 100;
#line 769
  if (o >= window->rows) {
#line 770
    o = window->rows - 1;
  }
#line 771
  if (o < 1) {
#line 772
    o = 1;
  }
#line 773
  return (o);
}
}
#line 776 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void window_page_up(struct view *view ) 
{ 
  struct window *window ;
  position_t start ;
  position_t tmp ;
  position_t end ;
  int row ;
  size_t bytes ;
  int overlap ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  position_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 778
  window = view->window;
#line 779
  tmp = screen_start(view);
#line 779
  start = tmp;
  }
#line 784
  if (start) {
    {
#line 785
    tmp___0 = page_overlap(window);
#line 785
    overlap = tmp___0;
#line 786
    row = 0;
    }
    {
#line 786
    while (1) {
      while_continue: /* CIL Label */ ;
#line 786
      end = start;
#line 786
      if (end) {
#line 786
        if (! (row + overlap < window->rows)) {
#line 786
          goto while_break;
        }
      } else {
#line 786
        goto while_break;
      }
      {
#line 789
      start = find_line_start(view, start - 1UL);
#line 786
      tmp___1 = count_rows(window, start, end);
#line 786
      row = (int )((unsigned int )row + tmp___1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 790
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 790
      tmp___3 = row;
#line 790
      row --;
#line 790
      if (! (tmp___3 + overlap > window->rows)) {
#line 790
        goto while_break___0;
      }
      {
#line 791
      tmp___2 = find_row_bytes(view, start, 0U, (unsigned int )window->columns);
#line 791
      start += tmp___2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 793
    new_start(view, start);
#line 794
    row = 0;
    }
    {
#line 794
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 794
      if (! (row < window->rows - 1)) {
#line 794
        goto while_break___1;
      }
      {
#line 795
      bytes = find_row_bytes(view, start, 0U, (unsigned int )window->columns);
      }
#line 795
      if (! bytes) {
#line 797
        goto while_break___1;
      }
#line 794
      row ++;
#line 794
      start += bytes;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 798
    display_insert_lines(display, window->row, window->column, window->rows - overlap,
                         window->rows, window->columns);
    }
  }
  {
#line 802
  locus_set(view, (locus_t )0, start);
  }
#line 803
  return;
}
}
#line 805 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void window_page_down(struct view *view ) 
{ 
  struct window *window ;
  position_t start ;
  position_t tmp ;
  int row ;
  size_t bytes ;
  int overlap ;
  int tmp___0 ;

  {
  {
#line 807
  window = view->window;
#line 808
  tmp = screen_start(view);
#line 808
  start = tmp;
#line 811
  tmp___0 = page_overlap(window);
#line 811
  overlap = tmp___0;
#line 813
  row = 0;
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! (row + overlap < window->rows)) {
#line 813
      goto while_break;
    }
    {
#line 814
    bytes = find_row_bytes(view, start, 0U, (unsigned int )window->columns);
    }
#line 814
    if (! bytes) {
#line 815
      goto while_break;
    }
#line 813
    row ++;
#line 813
    start += bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 816
  display_delete_lines(display, window->row, window->column, window->rows - overlap,
                       window->rows, window->columns);
#line 819
  new_start(view, start);
#line 820
  locus_set(view, (locus_t )0, start);
  }
#line 821
  return;
}
}
#line 823 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
void window_beep(struct view *view ) 
{ 


  {
#line 825
  if (display) {
    {
#line 826
    display_beep(display);
    }
  } else {
    {
#line 828
    fputc('\a', stderr);
    }
  }
#line 829
  return;
}
}
#line 836
static void window_colors(void) ;
#line 836 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static rgba_t colors[7][2]  = { {        (rgba_t )0,        2139062016U}, 
   {        (rgba_t )65280,        4294901760U}, 
   {        (rgba_t )65280,        2139029504U}, 
   {        (rgba_t )16711680,        4278255360U}, 
   {        (rgba_t )16711680,        2130738944U}, 
   {        4278190080U,        (rgba_t )8355584}, 
   {        4278190080U,        (rgba_t )16776960}};
#line 831 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static void window_colors(void) 
{ 
  int j ;
  struct window *window ;
  struct window *w ;
  Boolean_t tmp ;

  {
#line 847
  if (active_window) {
#line 848
    if (active_window->fgrgba != 255U) {
#line 849
      active_window->repaint = (Boolean_t )1;
    }
#line 850
    active_window->fgrgba = (rgba_t )255;
#line 851
    active_window->bgrgba = (rgba_t )(~ 0);
  }
#line 853
  window = window_list;
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 853
    if (! window) {
#line 853
      goto while_break;
    }
#line 854
    if ((unsigned long )window == (unsigned long )active_window) {
#line 855
      goto __Cont;
    }
#line 856
    j = 0;
    {
#line 856
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 856
      if (! colors[j][1]) {
#line 856
        goto while_break___0;
      }
#line 857
      w = window_list;
      {
#line 857
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 857
        if (! w) {
#line 857
          goto while_break___1;
        }
#line 858
        if ((unsigned long )w != (unsigned long )window) {
#line 858
          if (w->bgrgba == colors[j][1]) {
            {
#line 858
            tmp = adjacent(window, w);
            }
#line 858
            if (tmp) {
#line 861
              goto while_break___1;
            }
          }
        }
#line 857
        w = w->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 862
      if (! w) {
#line 863
        goto while_break___0;
      }
#line 856
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 865
    if (window->bgrgba != colors[j][1]) {
#line 866
      window->repaint = (Boolean_t )1;
#line 867
      window->fgrgba = colors[j][0];
#line 868
      window->bgrgba = colors[j][1];
    }
    __Cont: /* CIL Label */ 
#line 853
    window = window->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 871
  return;
}
}
#line 873 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
static void repaint(void) 
{ 
  struct window *window ;
  Boolean_t tmp ;

  {
  {
#line 877
  window_colors();
#line 878
  window = window_list;
  }
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    if (! window) {
#line 878
      goto while_break;
    }
    {
#line 879
    tmp = needs_repainting(window);
    }
#line 879
    if (tmp) {
      {
#line 880
      paint(window);
      }
    }
#line 878
    window = window->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 881
  display_cursor(display, active_window->row + active_window->cursor_row, active_window->column + active_window->cursor_column);
  }
#line 884
  return;
}
}
#line 886 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
Unicode_t window_getch(void) 
{ 
  Boolean_t block ;
  Unicode_t ch ;
  Unicode_t tmp ;
  struct view *tmp___0 ;

  {
#line 888
  block = (Boolean_t )0;
  {
#line 889
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 890
    tmp = display_getch(display, block);
#line 890
    ch = tmp;
    }
#line 891
    if (ch == (((1U << 31) + 1U) + 256U) + 2U) {
      {
#line 892
      tmp___0 = window_current_view();
#line 892
      window_raise(tmp___0);
      }
    } else
#line 893
    if (ch != (((1U << 31) + 1U) + 256U) + 4U) {
#line 894
      return (ch);
    }
    {
#line 895
    repaint();
#line 896
    block = (Boolean_t )1;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 900 "/home/june/collector/temp/aoeui-1.6~dfsg/window.c"
unsigned int window_columns(struct window *window ) 
{ 
  int tmp ;

  {
#line 902
  if (window) {
#line 902
    tmp = window->columns;
  } else {
#line 902
    tmp = 80;
  }
#line 902
  return ((unsigned int )tmp);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 192
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 891
extern char *cuserid(char *__s ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 978
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 89
extern int msync(void *__addr , size_t __len , int __flags ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 63 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
Boolean_t default_no_tabs  ;
#line 65 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
Boolean_t no_save_originals  ;
#line 66 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
Boolean_t read_only  ;
#line 68 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
char const   *make_writable  ;
#line 72
void view_name(struct view *view ) ;
#line 74
struct view *text_create(char const   *path , unsigned int flags ) ;
#line 80
size_t view_raw(struct view *view , char **out___1 , position_t offset , size_t bytes ) ;
#line 35 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
char const   *path_format(char const   *path ) ;
#line 54
void keyword_init(struct text *text ) ;
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
enum utf8_mode utf8_mode  =    (enum utf8_mode )2;
#line 8 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
unsigned int default_tab_stop  =    8U;
#line 11 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
char const   *path_format(char const   *path ) 
{ 
  char *cwdbuf ;
  char *cwd ;
  char const   *slash ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 16
  if (! path) {
#line 17
    return (path);
  } else
#line 16
  if ((int const   )*path != 47) {
#line 17
    return (path);
  }
  {
#line 18
  tmp = reallocate((void const   *)((void *)0), (size_t )1024);
#line 18
  cwdbuf = (char *)tmp;
#line 19
  cwd = getcwd(cwdbuf, (size_t )1024);
  }
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 20
    tmp___2 = strchr(path, '/');
#line 20
    slash = (char const   *)tmp___2;
    }
#line 20
    if (slash) {
      {
#line 20
      tmp___3 = strncmp((char const   *)cwd, path, (size_t )(slash - path));
      }
#line 20
      if (tmp___3) {
#line 20
        goto while_break;
      }
    } else {
#line 20
      goto while_break;
    }
#line 22
    tmp___0 = slash;
#line 22
    slash ++;
#line 22
    cwd += tmp___0 - path;
#line 23
    if (*cwd) {
#line 23
      tmp___1 = cwd;
#line 23
      cwd ++;
#line 23
      if ((int )*tmp___1 != 47) {
#line 24
        goto while_break;
      }
    }
#line 25
    path = slash;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 27
  reallocate((void const   *)cwdbuf, (size_t )0);
#line 27
  cwdbuf = (char *)((void *)0);
  }
#line 28
  return (path);
}
}
#line 31 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
static ssize_t old_fashioned_read(struct text *text ) 
{ 
  char *raw ;
  ssize_t got ;
  ssize_t total ;
  size_t max ;
  int *tmp ;
  char const   *tmp___0 ;

  {
#line 34
  total = (ssize_t )0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 39
    buffer_insert(text->buffer, (void const   *)((void *)0), (position_t )total, (size_t )1024);
#line 40
    max = buffer_raw(text->buffer, & raw, (position_t )total, (size_t )1024);
#line 41
    tmp = __errno_location();
#line 41
    *tmp = 0;
#line 42
    got = read(text->fd, (void *)raw, max);
    }
#line 43
    if (got < 0L) {
      {
#line 44
      tmp___0 = path_format((char const   *)text->path);
#line 44
      message("%s: can\'t read", tmp___0);
#line 46
      buffer_delete(text->buffer, (position_t )0, (size_t )(total + 1024L));
      }
#line 47
      return ((ssize_t )-1);
    }
    {
#line 49
    buffer_delete(text->buffer, (position_t )(total + got), (size_t )(1024L - got));
#line 50
    total += got;
    }
#line 38
    if (! got) {
#line 38
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return (total);
}
}
#line 56 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
static char *fix_path(char const   *path ) 
{ 
  char *fpath ;
  char const   *freepath ;
  char const   *home ;
  size_t pathlen ;
  unsigned short const   **tmp ;
  char *apath ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *apath___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *cwdbuf ;
  void *tmp___5 ;
  char *cwd ;
  char *tmp___6 ;
  char *apath___1 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
#line 59
  freepath = (char const   *)((void *)0);
#line 62
  if (! path) {
#line 63
    return ((char *)((void *)0));
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    tmp = __ctype_b_loc();
    }
#line 64
    if (! ((int const   )*(*tmp + (int )*path) & 8192)) {
#line 64
      goto while_break;
    }
#line 65
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 66
    if ((int const   )*path == 46) {
#line 66
      if (! ((int const   )*(path + 1) == 47)) {
#line 66
        goto while_break___0;
      }
    } else {
#line 66
      goto while_break___0;
    }
#line 67
    path += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 68
  pathlen = strlen(path);
  }
#line 68
  if (! pathlen) {
#line 69
    return ((char *)((void *)0));
  }
  {
#line 70
  tmp___2 = __ctype_b_loc();
  }
#line 70
  if ((int const   )*(*tmp___2 + (int )*(path + (pathlen - 1UL))) & 8192) {
    {
#line 72
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 72
      if (pathlen) {
        {
#line 72
        tmp___0 = __ctype_b_loc();
#line 72
        pathlen --;
        }
#line 72
        if (! ((int const   )*(*tmp___0 + (int )*(path + pathlen)) & 8192)) {
#line 72
          goto while_break___1;
        }
      } else {
#line 72
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 74
    if (! pathlen) {
#line 75
      return ((char *)((void *)0));
    }
    {
#line 76
    tmp___1 = reallocate((void const   *)((void *)0), pathlen + 1UL);
#line 76
    apath = (char *)tmp___1;
#line 77
    memcpy((void */* __restrict  */)apath, (void const   */* __restrict  */)path,
           pathlen);
#line 78
    *(apath + pathlen) = (char )'\000';
#line 79
    path = (char const   *)apath;
#line 79
    freepath = path;
    }
  }
  {
#line 81
  tmp___9 = strncmp(path, "~/", (size_t )2);
  }
#line 81
  if (tmp___9) {
    _L: /* CIL Label */ 
#line 86
    if ((int const   )*path != 47) {
      {
#line 87
      tmp___5 = reallocate((void const   *)((void *)0), (size_t )1024);
#line 87
      cwdbuf = (char *)tmp___5;
#line 88
      tmp___6 = getcwd(cwdbuf, (size_t )1024);
#line 88
      cwd = tmp___6;
#line 89
      tmp___7 = strlen((char const   *)cwd);
#line 89
      tmp___8 = reallocate((void const   *)((void *)0), (tmp___7 + pathlen) + 2UL);
#line 89
      apath___1 = (char *)tmp___8;
#line 90
      sprintf((char */* __restrict  */)apath___1, (char const   */* __restrict  */)"%s/%s",
              cwd, path);
#line 91
      reallocate((void const   *)freepath, (size_t )0);
#line 91
      freepath = (char const   *)((void *)0);
#line 92
      reallocate((void const   *)cwdbuf, (size_t )0);
#line 92
      cwdbuf = (char *)((void *)0);
#line 93
      path = (char const   *)apath___1;
#line 93
      freepath = path;
      }
    }
  } else {
    {
#line 81
    tmp___10 = getenv("HOME");
#line 81
    home = (char const   *)tmp___10;
    }
#line 81
    if (home) {
      {
#line 82
      tmp___3 = strlen(home);
#line 82
      tmp___4 = reallocate((void const   *)((void *)0), tmp___3 + pathlen);
#line 82
      apath___0 = (char *)tmp___4;
#line 83
      sprintf((char */* __restrict  */)apath___0, (char const   */* __restrict  */)"%s%s",
              home, path + 1);
#line 84
      reallocate((void const   *)freepath, (size_t )0);
#line 84
      freepath = (char const   *)((void *)0);
#line 85
      path = (char const   *)apath___0;
#line 85
      freepath = path;
      }
    } else {
#line 81
      goto _L;
    }
  }
  {
#line 95
  fpath = strdup(path);
#line 96
  reallocate((void const   *)freepath, (size_t )0);
#line 96
  freepath = (char const   *)((void *)0);
  }
#line 97
  return (fpath);
}
}
#line 100 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
static void clean_mmap(struct text *text , size_t bytes , int flags ) 
{ 
  void *p ;
  size_t pagesize___0 ;
  int tmp ;
  unsigned int pages ;

  {
  {
#line 103
  tmp = getpagesize();
#line 103
  pagesize___0 = (size_t )tmp;
#line 104
  pages = (unsigned int )(((bytes + pagesize___0) - 1UL) / pagesize___0);
  }
#line 106
  if (text->clean) {
    {
#line 107
    munmap((void *)text->clean, text->clean_bytes);
    }
  }
#line 108
  text->clean_bytes = bytes;
#line 109
  text->clean = (char *)((void *)0);
#line 110
  if (! pages) {
#line 111
    return;
  }
  {
#line 112
  p = mmap((void *)0, (size_t )pages * pagesize___0, flags, 1, text->fd, (__off_t )0);
  }
#line 113
  if ((unsigned long )p != (unsigned long )((void *)-1)) {
#line 114
    text->clean = (char *)p;
  }
#line 115
  return;
}
}
#line 117 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
static void grab_mtime(struct text *text ) 
{ 
  struct stat statbuf ;
  int tmp ;

  {
#line 121
  if (text->fd >= 0) {
    {
#line 121
    tmp = fstat(text->fd, & statbuf);
    }
#line 121
    if (tmp) {
#line 124
      text->mtime = (time_t )0;
    } else {
#line 122
      text->mtime = statbuf.st_mtim.tv_sec;
    }
  } else {
#line 124
    text->mtime = (time_t )0;
  }
#line 125
  return;
}
}
#line 127 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
static void scan(struct view *view ) 
{ 
  char *raw ;
  char scratch[8] ;
  position_t at ;
  size_t bytes ;
  int tmp ;
  size_t tmp___0 ;
  size_t chop ;
  int tmp___1 ;
  size_t chlen ;
  size_t check ;
  Unicode_t ch ;
  Unicode_t lastch ;
  int crnl ;
  int nl ;
  Boolean_t any_tab ;
  int tabstop ;
  position_t tmp___2 ;
  int spaces ;

  {
  {
#line 131
  tmp = getpagesize();
#line 131
  tmp___0 = view_raw(view, & raw, (position_t )0, (size_t )tmp);
#line 131
  bytes = tmp___0;
  }
#line 132
  if (bytes < view->bytes) {
#line 132
    tmp___1 = 8;
  } else {
#line 132
    tmp___1 = 0;
  }
#line 132
  chop = (size_t )tmp___1;
#line 134
  lastch = (Unicode_t )0;
#line 135
  crnl = 0;
#line 135
  nl = 0;
#line 136
  any_tab = (Boolean_t )0;
#line 137
  tabstop = (int )default_tab_stop;
#line 140
  (view->text)->flags &= (unsigned int )(~ (((1 << 6) | (1 << 7)) | (1 << 5)));
#line 141
  (view->text)->tabstop = default_tab_stop;
#line 143
  if ((unsigned int )utf8_mode == 0U) {
#line 144
    (view->text)->flags |= (unsigned int )(1 << 6);
  } else
#line 145
  if ((unsigned int )utf8_mode == 2U) {
#line 146
    at = (position_t )0;
    {
#line 146
    while (1) {
      while_continue: /* CIL Label */ ;
#line 146
      if (! (at + chop < bytes)) {
#line 146
        goto while_break;
      }
      {
#line 147
      chlen = utf8_length((char const   *)(raw + at), bytes - at);
#line 148
      ch = utf8_unicode((char const   *)(raw + at), chlen);
#line 149
      check = unicode_utf8(scratch, ch);
      }
#line 150
      if (chlen != check) {
#line 151
        (view->text)->flags |= (unsigned int )(1 << 6);
#line 152
        goto while_break;
      }
#line 146
      at += chlen;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 156
  at = (position_t )0;
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 156
    if (! (at + chop < bytes)) {
#line 156
      goto while_break___0;
    }
    {
#line 157
    ch = view_unicode(view, at, & at);
    }
#line 157
    if (ch == 10U) {
#line 158
      nl ++;
#line 159
      crnl += lastch == 13U;
    }
#line 156
    lastch = ch;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 161
  if (nl) {
#line 161
    if (crnl == nl) {
#line 162
      (view->text)->flags |= (unsigned int )(1 << 7);
    }
  }
#line 164
  at = (position_t )0;
  {
#line 164
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 164
    if (! (at + chop < bytes)) {
#line 164
      goto while_break___1;
    }
#line 165
    spaces = 0;
    {
#line 166
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 166
      ch = view_unicode(view, at, & at);
      }
#line 166
      if (! (ch == 32U)) {
#line 166
        goto while_break___2;
      }
#line 167
      spaces ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 168
    if (ch == 9U) {
#line 169
      any_tab = (Boolean_t )1;
    }
#line 170
    if (spaces > 1) {
#line 170
      if (spaces < tabstop) {
#line 171
        tabstop = spaces;
      }
    }
    {
#line 164
    tmp___2 = find_line_end(view, at);
#line 164
    at = tmp___2 + 1UL;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 173
  if (default_no_tabs) {
#line 174
    (view->text)->flags |= (unsigned int )(1 << 5);
#line 175
    (view->text)->tabstop = (unsigned int )tabstop;
  } else
#line 173
  if (! any_tab) {
#line 174
    (view->text)->flags |= (unsigned int )(1 << 5);
#line 175
    (view->text)->tabstop = (unsigned int )tabstop;
  }
#line 177
  return;
}
}
#line 179 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
struct view *view_open(char const   *path0 ) 
{ 
  struct view *view ;
  struct text *text ;
  struct stat statbuf ;
  char *path ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  ssize_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  {
#line 184
  tmp = fix_path(path0);
#line 184
  path = tmp;
  }
#line 186
  if (! path) {
#line 187
    return ((struct view *)((void *)0));
  }
#line 189
  text = text_list;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! text) {
#line 189
      goto while_break;
    }
#line 190
    if (text->path) {
      {
#line 190
      tmp___0 = strcmp((char const   *)text->path, (char const   *)path);
      }
#line 190
      if (! tmp___0) {
#line 191
        view = text->views;
        {
#line 191
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 191
          if (! view) {
#line 191
            goto while_break___0;
          }
#line 192
          if (! view->window) {
#line 193
            goto done;
          }
#line 191
          view = view->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 194
        view = view_create(text);
        }
#line 195
        goto done;
      }
    }
#line 189
    text = text->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  view = text_create((char const   *)path, 0U);
#line 199
  text = view->text;
#line 201
  tmp___1 = __errno_location();
#line 201
  *tmp___1 = 0;
#line 202
  tmp___12 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& statbuf));
  }
#line 202
  if (tmp___12) {
    {
#line 203
    tmp___3 = __errno_location();
    }
#line 203
    if (*tmp___3 != 2) {
      {
#line 204
      tmp___2 = path_format((char const   *)path);
#line 204
      message("%s: can\'t stat", tmp___2);
      }
#line 205
      goto fail;
    }
#line 207
    if (read_only) {
      {
#line 208
      tmp___4 = path_format((char const   *)path);
#line 208
      message("%s: can\'t create in read-only mode", tmp___4);
      }
#line 210
      goto fail;
    }
    {
#line 212
    tmp___5 = __errno_location();
#line 212
    *tmp___5 = 0;
#line 213
    text->fd = open((char const   *)path, 578, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
    }
#line 215
    if (text->fd < 0) {
      {
#line 216
      tmp___6 = path_format((char const   *)path);
#line 216
      message("%s: can\'t create", tmp___6);
      }
#line 217
      goto fail;
    }
#line 219
    text->flags |= (unsigned int )(1 << 3);
  } else {
#line 221
    if (! ((statbuf.st_mode & 61440U) == 32768U)) {
      {
#line 222
      tmp___7 = path_format((char const   *)path);
#line 222
      message("%s: not a regular file", tmp___7);
      }
#line 223
      goto fail;
    }
#line 225
    if (! read_only) {
      {
#line 226
      text->fd = open((char const   *)path, 2);
      }
    }
#line 227
    if (text->fd < 0) {
      {
#line 228
      tmp___8 = __errno_location();
#line 228
      *tmp___8 = 0;
#line 229
      text->flags |= (unsigned int )(1 << 1);
#line 230
      text->fd = open((char const   *)path, 0);
      }
#line 231
      if (text->fd < 0) {
        {
#line 232
        tmp___9 = path_format((char const   *)path);
#line 232
        message("%s: can\'t open", tmp___9);
        }
#line 233
        goto fail;
      }
    }
    {
#line 236
    clean_mmap(text, (size_t )statbuf.st_size, 1);
    }
#line 237
    if (! text->clean) {
      {
#line 238
      text->buffer = buffer_create(path);
#line 239
      tmp___10 = old_fashioned_read(text);
      }
#line 239
      if (tmp___10 < 0L) {
#line 240
        goto fail;
      }
      {
#line 241
      grab_mtime(text);
      }
    }
#line 243
    if (text->buffer) {
      {
#line 243
      tmp___11 = buffer_bytes(text->buffer);
#line 243
      view->bytes = tmp___11;
      }
    } else {
#line 243
      view->bytes = text->clean_bytes;
    }
    {
#line 245
    scan(view);
#line 246
    text_forget_undo(text);
    }
  }
#line 248
  goto done;
  fail: 
  {
#line 250
  view_close(view);
#line 251
  view = (struct view *)((void *)0);
  }
  done: 
  {
#line 253
  reallocate((void const   *)path, (size_t )0);
#line 253
  path = (char *)((void *)0);
  }
#line 254
  return (view);
}
}
#line 257 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
static fd_t try_dir(char *path , char const   *dir , struct tm  const  *gmt ) 
{ 
  struct stat statbuf ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 261
  tmp = __errno_location();
#line 261
  *tmp = 0;
#line 262
  tmp___3 = stat((char const   */* __restrict  */)dir, (struct stat */* __restrict  */)(& statbuf));
  }
#line 262
  if (tmp___3) {
    {
#line 263
    tmp___0 = __errno_location();
    }
#line 263
    if (*tmp___0 != 2) {
#line 264
      return (-1);
    }
    {
#line 265
    tmp___1 = mkdir(dir, (__mode_t )448);
    }
#line 265
    if (tmp___1) {
#line 266
      return (-1);
    }
    {
#line 267
    tmp___2 = stat((char const   */* __restrict  */)dir, (struct stat */* __restrict  */)(& statbuf));
    }
#line 267
    if (tmp___2) {
#line 268
      return (-1);
    }
  }
#line 270
  if (! ((statbuf.st_mode & 61440U) == 16384U)) {
#line 271
    return (-1);
  }
  {
#line 272
  sprintf((char */* __restrict  */)path, (char const   */* __restrict  */)"%s/%02d-%02d-%02d.%02d%02d%02d",
          dir, gmt->tm_year + 1900, gmt->tm_mon + 1, gmt->tm_mday, gmt->tm_hour, gmt->tm_min,
          gmt->tm_sec);
#line 275
  tmp___4 = open((char const   *)path, 578, 384);
  }
#line 275
  return (tmp___4);
}
}
#line 278 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
struct view *text_new(void) 
{ 
  char dir[128] ;
  char path[128] ;
  char const   *me ;
  char const   *home ;
  time_t now ;
  time_t tmp ;
  struct tm *gmt ;
  struct tm *tmp___0 ;
  fd_t fd ;
  struct view *view ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 282
  tmp = time((time_t *)((void *)0));
#line 282
  now = tmp;
#line 283
  tmp___0 = gmtime((time_t const   *)(& now));
#line 283
  gmt = tmp___0;
#line 284
  fd = -1;
#line 287
  tmp___1 = getenv("HOME");
#line 287
  home = (char const   *)tmp___1;
  }
#line 287
  if (home) {
    {
#line 288
    sprintf((char */* __restrict  */)(dir), (char const   */* __restrict  */)"%s/.aoeui",
            home);
#line 289
    fd = try_dir(path, (char const   *)(dir), (struct tm  const  *)gmt);
    }
  }
#line 291
  if (fd < 0) {
    {
#line 291
    tmp___2 = getenv("LOGNAME");
#line 291
    me = (char const   *)tmp___2;
    }
#line 291
    if (me) {
      {
#line 292
      sprintf((char */* __restrict  */)(dir), (char const   */* __restrict  */)"/tmp/aoeui-%s",
              me);
#line 293
      fd = try_dir(path, (char const   *)(dir), (struct tm  const  *)gmt);
      }
    }
  }
#line 296
  if (fd < 0) {
    {
#line 296
    tmp___3 = cuserid((char *)((void *)0));
#line 296
    me = (char const   *)tmp___3;
    }
#line 296
    if (me) {
      {
#line 297
      sprintf((char */* __restrict  */)(dir), (char const   */* __restrict  */)"/tmp/aoeui-%s",
              me);
#line 298
      fd = try_dir(path, (char const   *)(dir), (struct tm  const  *)gmt);
      }
    }
  }
#line 301
  if (fd < 0) {
    {
#line 302
    fd = try_dir(path, "/tmp/aoeui", (struct tm  const  *)gmt);
    }
  }
#line 303
  if (fd < 0) {
    {
#line 304
    fd = try_dir(path, "./aoeui", (struct tm  const  *)gmt);
    }
  }
#line 306
  if (fd < 0) {
    {
#line 307
    view = text_create("* New *", (unsigned int )(1 << 2));
    }
  } else {
    {
#line 309
    view = text_create((char const   *)(path), (unsigned int )((1 << 3) | (1 << 4)));
#line 310
    (view->text)->fd = fd;
    }
  }
#line 312
  return (view);
}
}
#line 315 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
Boolean_t text_rename(struct text *text , char const   *path0 ) 
{ 
  char *path ;
  char *tmp ;
  struct text *b ;
  struct view *view ;
  fd_t fd ;
  int tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 317
  tmp = fix_path(path0);
#line 317
  path = tmp;
  }
#line 322
  if (! path) {
#line 323
    return ((Boolean_t )0);
  }
#line 324
  b = text;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! b) {
#line 324
      goto while_break;
    }
#line 325
    if (b->path) {
      {
#line 325
      tmp___0 = strcmp((char const   *)b->path, (char const   *)path);
      }
#line 325
      if (! tmp___0) {
#line 326
        return ((Boolean_t )0);
      }
    }
#line 324
    b = b->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  tmp___1 = __errno_location();
#line 328
  *tmp___1 = 0;
#line 329
  fd = open((char const   *)path, 66, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
  }
#line 329
  if (fd < 0) {
    {
#line 331
    tmp___2 = path_format((char const   *)path);
#line 331
    message("%s: can\'t create", tmp___2);
#line 332
    reallocate((void const   *)path, (size_t )0);
#line 332
    path = (char *)((void *)0);
    }
#line 333
    return ((Boolean_t )0);
  }
#line 336
  if (text->flags & (unsigned int )(1 << 3)) {
    {
#line 337
    unlink((char const   *)text->path);
#line 338
    text->flags &= (unsigned int )(~ ((1 << 3) | (1 << 4)));
    }
  }
  {
#line 342
  text->flags |= 1U;
#line 343
  text->flags &= (unsigned int )(~ (1 << 1));
#line 344
  text_dirty(text);
#line 345
  close(text->fd);
  }
#line 346
  if (text->clean) {
    {
#line 347
    munmap((void *)text->clean, text->clean_bytes);
#line 348
    text->clean = (char *)((void *)0);
    }
  }
  {
#line 350
  text->fd = fd;
#line 351
  grab_mtime(text);
#line 352
  reallocate((void const   *)text->path, (size_t )0);
#line 352
  text->path = (char *)((void *)0);
#line 353
  text->path = path;
#line 354
  keyword_init(text);
#line 355
  view = text->views;
  }
  {
#line 355
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 355
    if (! view) {
#line 355
      goto while_break___0;
    }
    {
#line 356
    view_name(view);
#line 355
    view = view->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 357
  return ((Boolean_t )1);
}
}
#line 360 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
void text_dirty(struct text *text ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
#line 362
  if (text->path) {
#line 362
    if (! text->dirties) {
#line 362
      if (text->flags & (unsigned int )(1 << 1)) {
#line 363
        if (make_writable) {
#line 363
          tmp = "will be made writable";
        } else {
#line 363
          tmp = "changes won\'t be saved here";
        }
        {
#line 363
        tmp___0 = path_format((char const   *)text->path);
#line 363
        message("%s: read-only, %s", tmp___0, tmp);
        }
      }
    }
  }
#line 367
  (text->dirties) ++;
#line 368
  if (! text->buffer) {
#line 369
    if (text->fd >= 0) {
#line 369
      tmp___1 = text->path;
    } else {
#line 369
      tmp___1 = (char *)((void *)0);
    }
    {
#line 369
    text->buffer = buffer_create(tmp___1);
    }
#line 370
    if (text->clean) {
      {
#line 371
      buffer_insert(text->buffer, (void const   *)text->clean, (position_t )0, text->clean_bytes);
      }
    }
    {
#line 373
    grab_mtime(text);
    }
  }
#line 375
  return;
}
}
#line 377 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
static void save_original(struct text *text ) 
{ 
  char *save_path ;
  fd_t fd ;
  ssize_t wrote ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 381
  wrote = (ssize_t )-1;
#line 383
  if (no_save_originals) {
#line 390
    return;
  } else
#line 383
  if (! text->clean) {
#line 390
    return;
  } else
#line 383
  if (! text->path) {
#line 390
    return;
  } else
#line 383
  if (text->flags & (unsigned int )(((1 | (1 << 1)) | (1 << 3)) | (1 << 2))) {
#line 390
    return;
  }
  {
#line 392
  tmp = strlen((char const   *)text->path);
#line 392
  tmp___0 = reallocate((void const   *)((void *)0), tmp + 2UL);
#line 392
  save_path = (char *)tmp___0;
#line 393
  sprintf((char */* __restrict  */)save_path, (char const   */* __restrict  */)"%s~",
          text->path);
#line 394
  tmp___1 = __errno_location();
#line 394
  *tmp___1 = 0;
#line 395
  fd = creat((char const   *)save_path, (mode_t )384);
  }
#line 396
  if (fd >= 0) {
    {
#line 397
    wrote = write(fd, (void const   *)text->clean, text->clean_bytes);
#line 398
    tmp___2 = close(fd);
    }
#line 398
    if (tmp___2) {
#line 399
      wrote = (ssize_t )-1;
    }
  }
#line 401
  if ((size_t )wrote != text->clean_bytes) {
    {
#line 402
    tmp___3 = path_format((char const   *)save_path);
#line 402
    message("%s: can\'t save original text", tmp___3);
    }
  }
  {
#line 403
  reallocate((void const   *)save_path, (size_t )0);
#line 403
  save_path = (char *)((void *)0);
#line 404
  text->flags |= 1U;
  }
#line 405
  return;
}
}
#line 407 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
Boolean_t text_is_dirty(struct text *text ) 
{ 
  int tmp ;

  {
#line 409
  if (text->preserved != text->dirties) {
#line 409
    if (text->fd >= 0) {
#line 409
      if (text->buffer) {
#line 409
        tmp = 1;
      } else {
#line 409
        tmp = 0;
      }
    } else {
#line 409
      tmp = 0;
    }
  } else {
#line 409
    tmp = 0;
  }
#line 409
  return ((Boolean_t )tmp);
}
}
#line 414 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
void text_preserve(struct text *text ) 
{ 
  char *raw ;
  size_t bytes ;
  struct stat statbuf ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char cmd[128] ;
  int newfd ;
  int newfd___0 ;
  char *new_path ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  ssize_t wrote ;
  int *tmp___8 ;
  char const   *tmp___9 ;

  {
#line 420
  if (text->preserved == text->dirties) {
#line 423
    return;
  } else
#line 420
  if (text->fd < 0) {
#line 423
    return;
  } else
#line 420
  if (! text->buffer) {
#line 423
    return;
  }
#line 424
  (text->dirties) ++;
#line 424
  text->preserved = text->dirties;
#line 425
  if (read_only) {
#line 426
    return;
  }
  {
#line 427
  text_unfold_all(text);
  }
#line 428
  if (text->clean) {
    {
#line 429
    save_original(text);
#line 430
    bytes = buffer_raw(text->buffer, & raw, (position_t )0, (size_t )(~ 0));
    }
#line 431
    if (bytes == text->clean_bytes) {
      {
#line 431
      tmp = memcmp((void const   *)text->clean, (void const   *)raw, bytes);
      }
#line 431
      if (! tmp) {
#line 433
        return;
      }
    }
    {
#line 434
    munmap((void *)text->clean, text->clean_bytes);
#line 435
    text->clean = (char *)((void *)0);
    }
  }
#line 437
  if (text->mtime) {
#line 437
    if (text->path) {
      {
#line 437
      tmp___1 = fstat(text->fd, & statbuf);
      }
#line 437
      if (! tmp___1) {
#line 437
        if (text->mtime < statbuf.st_mtim.tv_sec) {
          {
#line 441
          tmp___0 = path_format((char const   *)text->path);
#line 441
          message("%s: modified since read into the editor, changes may have been overwritten.",
                  tmp___0);
          }
        }
      }
    }
  }
#line 444
  (text->dirties) ++;
#line 444
  text->preserved = text->dirties;
#line 445
  if (text->flags & (unsigned int )(1 << 1)) {
#line 445
    if (text->path) {
#line 445
      if (make_writable) {
        {
#line 448
        snprintf((char */* __restrict  */)(cmd), sizeof(cmd), (char const   */* __restrict  */)make_writable,
                 text->path);
#line 449
        background_command((char const   *)(cmd));
#line 450
        newfd = open((char const   *)text->path, 2);
        }
#line 451
        if (newfd >= 0) {
          {
#line 452
          close(text->fd);
#line 453
          text->fd = newfd;
#line 454
          text->flags &= (unsigned int )(~ (1 << 1));
          }
        }
      }
    }
  }
#line 457
  if (text->flags & (unsigned int )(1 << 1)) {
#line 457
    if (text->path) {
      {
#line 459
      tmp___2 = strlen((char const   *)text->path);
#line 459
      tmp___3 = reallocate((void const   *)((void *)0), tmp___2 + 2UL);
#line 459
      new_path = (char *)tmp___3;
#line 460
      sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"%s@",
              text->path);
#line 461
      tmp___4 = __errno_location();
#line 461
      *tmp___4 = 0;
#line 462
      newfd___0 = open((char const   *)new_path, 578, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
      }
#line 464
      if (newfd___0 < 0) {
        {
#line 465
        tmp___5 = path_format((char const   *)new_path);
#line 465
        message("%s: can\'t create", tmp___5);
#line 466
        reallocate((void const   *)new_path, (size_t )0);
#line 466
        new_path = (char *)((void *)0);
        }
#line 467
        return;
      }
      {
#line 469
      message("%s: read-only, new version saved to %s@", text->path, text->path);
#line 471
      text->flags &= (unsigned int )(~ (1 << 1));
#line 472
      close(text->fd);
#line 473
      reallocate((void const   *)text->path, (size_t )0);
#line 473
      text->path = (char *)((void *)0);
#line 474
      text->fd = newfd___0;
#line 475
      text->path = new_path;
      }
    }
  }
  {
#line 477
  text->flags &= (unsigned int )(~ (1 << 3));
#line 478
  bytes = buffer_raw(text->buffer, & raw, (position_t )0, (size_t )(~ 0));
#line 479
  tmp___7 = ftruncate(text->fd, (__off_t )bytes);
  }
#line 479
  if (tmp___7) {
    {
#line 480
    tmp___6 = path_format((char const   *)text->path);
#line 480
    message("%s: truncation failed", tmp___6);
    }
  }
  {
#line 481
  clean_mmap(text, bytes, 3);
  }
#line 482
  if (text->clean) {
    {
#line 483
    memcpy((void */* __restrict  */)text->clean, (void const   */* __restrict  */)raw,
           bytes);
#line 484
    msync((void *)text->clean, bytes, 4);
    }
  } else {
    {
#line 487
    lseek(text->fd, (__off_t )0, 0);
#line 488
    tmp___8 = __errno_location();
#line 488
    *tmp___8 = 0;
#line 489
    wrote = write(text->fd, (void const   *)raw, bytes);
    }
#line 490
    if ((size_t )wrote != bytes) {
      {
#line 491
      tmp___9 = path_format((char const   *)text->path);
#line 491
      message("%s: write failed", tmp___9);
      }
    }
  }
  {
#line 493
  grab_mtime(text);
  }
#line 494
  return;
}
}
#line 496 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
void texts_preserve(void) 
{ 
  struct text *text ;

  {
#line 499
  text = text_list;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! text) {
#line 499
      goto while_break;
    }
    {
#line 500
    text_preserve(text);
#line 499
    text = text->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  return;
}
}
#line 503 "/home/june/collector/temp/aoeui-1.6~dfsg/file.c"
void texts_uncreate(void) 
{ 
  struct text *text ;

  {
#line 506
  text = text_list;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! text) {
#line 506
      goto while_break;
    }
#line 507
    if (text->flags & (unsigned int )(1 << 3)) {
      {
#line 508
      unlink((char const   *)text->path);
      }
    }
#line 506
    text = text->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  return;
}
}
#line 12 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.h"
size_t buffer_get(struct buffer *buffer , void *out___1 , position_t offset , size_t bytes ) ;
#line 61 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
struct text *text_list  ;
#line 71
struct view *view_find(char const   *name ) ;
#line 79
size_t view_get(struct view *view , void *out___1 , position_t offset , size_t bytes ) ;
#line 15 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
struct view *view_find(char const   *name ) 
{ 
  struct view *view ;
  struct text *text ;
  int tmp ;

  {
#line 20
  if (! name) {
#line 21
    name = "";
  }
#line 22
  text = text_list;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (! text) {
#line 22
      goto while_break;
    }
#line 23
    view = text->views;
    {
#line 23
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 23
      if (! view) {
#line 23
        goto while_break___0;
      }
#line 24
      if (view->name) {
        {
#line 24
        tmp = strcmp((char const   *)view->name, name);
        }
#line 24
        if (! tmp) {
#line 25
          return (view);
        }
      }
#line 23
      view = view->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 22
    text = text->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return ((struct view *)((void *)0));
}
}
#line 29 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
void view_name(struct view *view ) 
{ 
  int j ;
  int len ;
  char const   *name ;
  char *new ;
  char *p ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned int ch ;
  char *tmp___1 ;
  struct view *tmp___2 ;
  struct view *tmp___3 ;

  {
#line 32
  name = (char const   *)(view->text)->path;
#line 35
  if (! name) {
#line 36
    name = "";
  }
  {
#line 37
  tmp = strlen(name);
#line 37
  len = (int )tmp;
#line 38
  tmp___0 = reallocate((void const   *)((void *)0), (size_t )(len + 8));
#line 38
  new = (char *)tmp___0;
  }
#line 39
  if ((view->text)->flags & (unsigned int )(1 << 2)) {
    {
#line 40
    memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)name, (size_t )(len + 1));
#line 41
    p = new + len;
    }
  } else {
#line 43
    j = 0;
#line 43
    p = new;
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 43
      if (! (j < len)) {
#line 43
        goto while_break;
      }
#line 44
      ch = (unsigned int )*(name + j);
#line 45
      if (ch >= 97U) {
#line 45
        if (ch <= 122U) {
#line 51
          tmp___1 = p;
#line 51
          p ++;
#line 51
          *tmp___1 = (char )ch;
        } else {
#line 45
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 45
      if (ch >= 65U) {
#line 45
        if (ch <= 90U) {
#line 51
          tmp___1 = p;
#line 51
          p ++;
#line 51
          *tmp___1 = (char )ch;
        } else {
#line 45
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 45
      if (ch >= 48U) {
#line 45
        if (ch <= 57U) {
#line 51
          tmp___1 = p;
#line 51
          p ++;
#line 51
          *tmp___1 = (char )ch;
        } else {
#line 45
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 45
      if (ch == 95U) {
#line 51
        tmp___1 = p;
#line 51
        p ++;
#line 51
        *tmp___1 = (char )ch;
      } else
#line 45
      if (ch == 45U) {
#line 51
        tmp___1 = p;
#line 51
        p ++;
#line 51
        *tmp___1 = (char )ch;
      } else
#line 45
      if (ch == 43U) {
#line 51
        tmp___1 = p;
#line 51
        p ++;
#line 51
        *tmp___1 = (char )ch;
      } else
#line 45
      if (ch == 46U) {
#line 51
        tmp___1 = p;
#line 51
        p ++;
#line 51
        *tmp___1 = (char )ch;
      } else
#line 45
      if (ch == 44U) {
#line 51
        tmp___1 = p;
#line 51
        p ++;
#line 51
        *tmp___1 = (char )ch;
      } else
#line 45
      if (ch >= 128U) {
#line 51
        tmp___1 = p;
#line 51
        p ++;
#line 51
        *tmp___1 = (char )ch;
      } else
#line 52
      if (ch == 47U) {
#line 52
        if (j < len - 1) {
#line 53
          p = new;
        }
      }
#line 43
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 55
    *p = (char )'\000';
  }
  {
#line 58
  tmp___3 = view_find((char const   *)new);
  }
#line 58
  if (tmp___3) {
#line 59
    j = 2;
    {
#line 59
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 60
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"<%d>",
              j);
#line 61
      tmp___2 = view_find((char const   *)new);
      }
#line 61
      if (! tmp___2) {
#line 62
        goto while_break___0;
      }
#line 59
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 65
  reallocate((void const   *)view->name, (size_t )0);
#line 65
  view->name = (char *)((void *)0);
#line 66
  view->name = new;
  }
#line 67
  return;
}
}
#line 69 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
struct view *view_create(struct text *text ) 
{ 
  struct view *view ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 71
  tmp = allocate0(sizeof(*view));
#line 71
  view = (struct view *)tmp;
#line 72
  view->loci = 2U;
#line 73
  tmp___0 = reallocate((void const   *)((void *)0), (unsigned long )view->loci * sizeof(*(view->locus)));
#line 73
  view->locus = (position_t *)tmp___0;
#line 74
  memset((void *)view->locus, ~ 0, (unsigned long )view->loci * sizeof(*(view->locus)));
#line 75
  *(view->locus + 0) = (position_t )0;
#line 76
  view->text = text;
#line 77
  view->next = text->views;
#line 78
  text->views = view;
  }
#line 79
  if (text->buffer) {
    {
#line 79
    tmp___1 = buffer_bytes(text->buffer);
#line 79
    view->bytes = tmp___1;
    }
  } else {
#line 79
    if (text->clean) {
#line 79
      tmp___2 = text->clean_bytes;
    } else {
#line 79
      tmp___2 = (size_t )0;
    }
#line 79
    view->bytes = tmp___2;
  }
  {
#line 81
  view->mode = mode_default();
#line 82
  view->shell_std_in = -1;
#line 83
  view->shell_pg = -1;
#line 84
  view->shell_out_locus = ~ 0U;
#line 85
  view_name(view);
  }
#line 86
  return (view);
}
}
#line 89 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
struct view *text_create(char const   *path , unsigned int flags ) 
{ 
  struct text *text ;
  void *tmp ;
  struct text *prev ;
  struct text *bp ;
  struct view *tmp___0 ;

  {
  {
#line 91
  tmp = allocate0(sizeof(*text));
#line 91
  text = (struct text *)tmp;
#line 93
  text->fd = -1;
#line 94
  text->flags = flags;
#line 95
  text->path = strdup(path);
  }
#line 96
  if ((unsigned int )utf8_mode == 0U) {
#line 97
    text->flags |= (unsigned int )(1 << 6);
  }
#line 98
  if (default_no_tabs) {
#line 99
    text->flags |= (unsigned int )(1 << 5);
  }
  {
#line 100
  text->tabstop = default_tab_stop;
#line 101
  keyword_init(text);
#line 103
  prev = (struct text *)((void *)0);
#line 103
  bp = text_list;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! bp) {
#line 103
      goto while_break;
    }
#line 103
    prev = bp;
#line 103
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (prev) {
#line 106
    prev->next = text;
  } else {
#line 108
    text_list = text;
  }
  {
#line 109
  tmp___0 = view_create(text);
  }
#line 109
  return (tmp___0);
}
}
#line 112 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
static void text_close(struct text *text ) 
{ 
  struct text *prev ;
  struct text *bp ;

  {
#line 114
  prev = (struct text *)((void *)0);
#line 116
  bp = text_list;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! bp) {
#line 116
      goto while_break;
    }
#line 117
    if ((unsigned long )bp == (unsigned long )text) {
#line 118
      if (prev) {
#line 119
        prev->next = text->next;
      } else {
#line 121
        text_list = text->next;
      }
#line 122
      goto while_break;
    }
#line 116
    prev = bp;
#line 116
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if (text->clean) {
    {
#line 126
    munmap((void *)text->clean, text->clean_bytes);
    }
  }
  {
#line 127
  buffer_destroy(text->buffer);
#line 128
  text_forget_undo(text);
  }
#line 129
  if (text->fd >= 0) {
    {
#line 130
    close(text->fd);
    }
  }
#line 131
  if (text->flags & (unsigned int )((1 << 4) | (1 << 3))) {
    {
#line 132
    unlink((char const   *)text->path);
    }
  }
  {
#line 133
  reallocate((void const   *)text->path, (size_t )0);
#line 133
  text->path = (char *)((void *)0);
#line 134
  reallocate((void const   *)text, (size_t )0);
#line 134
  text = (struct text *)((void *)0);
  }
#line 135
  return;
}
}
#line 137 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
void view_close(struct view *view ) 
{ 
  struct view *vp ;
  struct view *prev ;
  struct text *text ;
  struct view *tmp ;

  {
#line 139
  prev = (struct view *)((void *)0);
#line 142
  if (! view) {
#line 143
    return;
  }
  {
#line 144
  text = view->text;
#line 145
  window_destroy(view->window);
#line 146
  demultiplex_view(view);
#line 147
  bookmark_unset_view(view);
  }
#line 149
  if (text) {
#line 150
    vp = text->views;
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 150
      if (! vp) {
#line 150
        goto while_break;
      }
#line 151
      if ((unsigned long )vp == (unsigned long )view) {
#line 152
        if (prev) {
#line 153
          prev->next = vp->next;
        } else {
#line 154
          tmp = vp->next;
#line 154
          text->views = tmp;
#line 154
          if (! tmp) {
            {
#line 155
            text_close(text);
            }
          }
        }
#line 156
        goto while_break;
      }
#line 150
      prev = vp;
#line 150
      vp = vp->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 159
  reallocate((void const   *)view->name, (size_t )0);
#line 159
  view->name = (char *)((void *)0);
#line 160
  reallocate((void const   *)view, (size_t )0);
#line 160
  view = (struct view *)((void *)0);
  }
#line 161
  return;
}
}
#line 163 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
struct view *view_selection(struct view *current , position_t offset , size_t bytes ) 
{ 
  struct view *view ;

  {
#line 168
  if (! current) {
#line 169
    return ((struct view *)((void *)0));
  }
  {
#line 170
  view = view_create(current->text);
  }
#line 172
  if (offset > current->bytes) {
#line 173
    offset = current->bytes;
  }
#line 174
  if (offset + bytes > current->bytes) {
#line 175
    bytes = current->bytes - offset;
  }
  {
#line 176
  view->start = current->start + offset;
#line 177
  view->bytes = bytes;
#line 178
  locus_set(view, (locus_t )0, (position_t )0);
  }
#line 179
  return (view);
}
}
#line 182 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
void text_adjust_loci(struct text *text , position_t offset , int delta ) 
{ 
  struct view *view ;
  position_t limit ;
  size_t loss ;
  size_t loss___0 ;

  {
#line 186
  if (! delta) {
#line 187
    return;
  }
#line 189
  if (delta < 0) {
#line 190
    limit = offset - (position_t )delta;
#line 191
    view = text->views;
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      if (! view) {
#line 191
        goto while_break;
      }
#line 192
      if (limit < view->start) {
#line 193
        view->start += (position_t )delta;
      } else
#line 194
      if (offset < view->start) {
#line 195
        loss = limit - view->start;
#line 196
        if (loss > view->bytes) {
#line 197
          loss = view->bytes;
        }
        {
#line 198
        view->start = offset;
#line 199
        view->bytes -= loss;
#line 200
        loci_adjust(view, (position_t )0, (int )(- loss));
        }
      } else
#line 201
      if (offset < view->start + view->bytes) {
#line 202
        loss___0 = (view->start + view->bytes) - offset;
#line 204
        if (loss___0 > (size_t )(- delta)) {
#line 205
          loss___0 = (size_t )(- delta);
        }
        {
#line 206
        view->bytes -= loss___0;
#line 207
        loci_adjust(view, offset - view->start, (int )(- loss___0));
        }
      }
#line 191
      view = view->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 210
    view = text->views;
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 210
      if (! view) {
#line 210
        goto while_break___0;
      }
#line 211
      if (offset < view->start) {
#line 212
        view->start += (position_t )delta;
      } else
#line 213
      if (offset <= view->start + view->bytes) {
        {
#line 214
        view->bytes += (size_t )delta;
#line 215
        loci_adjust(view, offset - view->start, delta);
        }
      }
#line 210
      view = view->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 217
  return;
}
}
#line 219 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
static size_t text_get(struct text *text , void *out___1 , position_t offset , size_t bytes ) 
{ 
  size_t tmp ;

  {
#line 222
  if (text->buffer) {
    {
#line 223
    tmp = buffer_get(text->buffer, out___1, offset, bytes);
    }
#line 223
    return (tmp);
  }
#line 224
  if (! text->clean) {
#line 225
    return ((size_t )0);
  } else
#line 224
  if (offset >= text->clean_bytes) {
#line 225
    return ((size_t )0);
  }
#line 226
  if (offset + bytes > text->clean_bytes) {
#line 227
    bytes = text->clean_bytes - offset;
  }
  {
#line 228
  memcpy((void */* __restrict  */)out___1, (void const   */* __restrict  */)(text->clean + offset),
         bytes);
  }
#line 229
  return (bytes);
}
}
#line 232 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
size_t view_get(struct view *view , void *out___1 , position_t offset , size_t bytes ) 
{ 
  size_t tmp ;

  {
#line 234
  if (offset >= view->bytes) {
#line 235
    return ((size_t )0);
  }
#line 236
  if (offset + bytes > view->bytes) {
#line 237
    bytes = view->bytes - offset;
  }
  {
#line 238
  tmp = text_get(view->text, out___1, view->start + offset, bytes);
  }
#line 238
  return (tmp);
}
}
#line 241 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
static size_t text_raw(struct text *text , char **out___1 , position_t offset , size_t bytes ) 
{ 
  size_t tmp ;

  {
#line 244
  if (text->buffer) {
    {
#line 245
    tmp = buffer_raw(text->buffer, out___1, offset, bytes);
    }
#line 245
    return (tmp);
  }
#line 246
  if (! text->clean) {
#line 247
    *out___1 = (char *)((void *)0);
#line 248
    return ((size_t )0);
  }
#line 250
  if (offset + bytes > text->clean_bytes) {
#line 251
    bytes = text->clean_bytes - offset;
  }
#line 252
  if (bytes) {
#line 252
    *out___1 = text->clean + offset;
  } else {
#line 252
    *out___1 = (char *)((void *)0);
  }
#line 253
  return (bytes);
}
}
#line 256 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
size_t view_raw(struct view *view , char **out___1 , position_t offset , size_t bytes ) 
{ 
  size_t tmp ;

  {
#line 258
  if (offset >= view->bytes) {
#line 259
    *out___1 = (char *)((void *)0);
#line 260
    return ((size_t )0);
  }
#line 262
  if (offset + bytes > view->bytes) {
#line 263
    bytes = view->bytes - offset;
  }
  {
#line 264
  tmp = text_raw(view->text, out___1, view->start + offset, bytes);
  }
#line 264
  return (tmp);
}
}
#line 267 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
size_t view_delete(struct view *view , position_t offset , size_t bytes ) 
{ 
  size_t tmp ;

  {
  {
#line 269
  tmp = text_delete(view->text, view->start + offset, bytes);
  }
#line 269
  return (tmp);
}
}
#line 272 "/home/june/collector/temp/aoeui-1.6~dfsg/text.c"
size_t view_insert(struct view *view , void const   *in , position_t offset , ssize_t bytes ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 275
  if (bytes < 0L) {
#line 276
    if (in) {
      {
#line 276
      tmp = strlen((char const   *)in);
#line 276
      bytes = (ssize_t )tmp;
      }
    } else {
#line 276
      bytes = (ssize_t )0;
    }
  }
  {
#line 277
  tmp___0 = text_insert(view->text, in, view->start + offset, (size_t )bytes);
  }
#line 277
  return (tmp___0);
}
}
#line 35 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.h"
__inline static size_t buffer_gap_bytes(struct buffer *buffer ) 
{ 


  {
#line 37
  return (buffer->mapped - buffer->payload);
}
}
#line 40 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.h"
__inline static int buffer_byte(struct buffer *buffer , size_t offset ) 
{ 
  size_t tmp ;

  {
#line 42
  if (! buffer) {
#line 43
    return (-1);
  } else
#line 42
  if (offset >= buffer->payload) {
#line 43
    return (-1);
  }
#line 44
  if (offset >= buffer->gap) {
    {
#line 45
    tmp = buffer_gap_bytes(buffer);
#line 45
    offset += tmp;
    }
  }
#line 46
  return ((int )*((Byte_t *)buffer->data + offset));
}
}
#line 87 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
__inline static Unicode_t text_byte(struct text *text , position_t offset ) 
{ 
  int tmp ;

  {
#line 89
  if (text->buffer) {
    {
#line 90
    tmp = buffer_byte(text->buffer, offset);
    }
#line 90
    return ((Unicode_t )tmp);
  }
#line 91
  if (text->clean) {
#line 92
    return ((Unicode_t )((Byte_t )*(text->clean + offset)));
  }
#line 93
  return (1U << 31);
}
}
#line 96 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
__inline static Unicode_t view_byte(struct view *view , position_t offset ) 
{ 
  Unicode_t tmp ;

  {
#line 98
  if (offset >= view->bytes) {
#line 99
    return (1U << 31);
  }
  {
#line 100
  tmp = text_byte(view->text, view->start + offset);
  }
#line 100
  return (tmp);
}
}
#line 39 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
ssize_t view_vprintf(struct view *view , char const   *msg , va_list ap ) ;
#line 40
ssize_t view_printf(struct view *view , char const   *msg  , ...) ;
#line 48
Unicode_t view_unicode_prior(struct view *view , position_t offset , position_t *prev ) ;
#line 51
Boolean_t is_open_bracket(char const   *brackets , Unicode_t ch ) ;
#line 52
Boolean_t is_close_bracket(char const   *brackets , Unicode_t ch ) ;
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
ssize_t view_vprintf(struct view *view , char const   *msg , va_list ap ) 
{ 
  char buff[1024] ;
  size_t tmp ;

  {
  {
#line 7
  vsnprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)msg,
            ap);
#line 8
  tmp = view_insert(view, (void const   *)(buff), view->bytes, (ssize_t )-1);
  }
#line 8
  return ((ssize_t )tmp);
}
}
#line 11 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
ssize_t view_printf(struct view *view , char const   *msg  , ...) 
{ 
  va_list ap ;
  int result ;
  ssize_t tmp ;

  {
  {
#line 16
  __builtin_va_start(ap, msg);
#line 17
  tmp = view_vprintf(view, msg, ap);
#line 17
  result = (int )tmp;
#line 18
  __builtin_va_end(ap);
  }
#line 19
  return ((ssize_t )result);
}
}
#line 22 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
size_t view_get_selection(struct view *view , position_t *offset , Boolean_t *append ) 
{ 
  position_t cursor ;
  position_t tmp ;
  position_t mark ;
  position_t tmp___0 ;
  position_t tmp___1 ;
  position_t tmp___2 ;

  {
  {
#line 25
  tmp = locus_get(view, (locus_t )0);
#line 25
  cursor = tmp;
#line 26
  tmp___0 = locus_get(view, (locus_t )1);
#line 26
  mark = tmp___0;
  }
#line 28
  if (mark == 0xffffffffffffffffUL) {
#line 29
    mark = cursor;
#line 29
    if (mark < view->bytes) {
      {
#line 30
      view_char(view, mark, & mark);
      }
    }
  }
#line 31
  if (append) {
#line 32
    *append = (Boolean_t )(cursor >= mark);
  }
#line 33
  if (mark <= cursor) {
#line 34
    tmp___1 = mark;
#line 34
    *offset = tmp___1;
#line 34
    return (cursor - tmp___1);
  }
#line 35
  tmp___2 = cursor;
#line 35
  *offset = tmp___2;
#line 35
  return (mark - tmp___2);
}
}
#line 38 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
char *view_extract(struct view *view , position_t offset , unsigned int bytes ) 
{ 
  char *str ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 42
  if (! view) {
#line 43
    return ((char *)((void *)0));
  }
#line 44
  if (offset > view->bytes) {
#line 45
    return ((char *)((void *)0));
  }
#line 46
  if (offset + (position_t )bytes > view->bytes) {
#line 47
    bytes = (unsigned int )(view->bytes - offset);
  }
#line 48
  if (! bytes) {
#line 49
    return ((char *)((void *)0));
  }
  {
#line 50
  tmp = reallocate((void const   *)((void *)0), (size_t )(bytes + 1U));
#line 50
  str = (char *)tmp;
#line 51
  tmp___0 = view_get(view, (void *)str, offset, (size_t )bytes);
#line 51
  *(str + tmp___0) = (char )'\000';
  }
#line 52
  return (str);
}
}
#line 55 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
char *view_extract_selection(struct view *view ) 
{ 
  position_t offset ;
  size_t bytes ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 58
  tmp = view_get_selection(view, & offset, (Boolean_t *)((void *)0));
#line 58
  bytes = tmp;
#line 59
  tmp___0 = view_extract(view, offset, (unsigned int )bytes);
  }
#line 59
  return (tmp___0);
}
}
#line 62 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
size_t view_delete_selection(struct view *view ) 
{ 
  position_t offset ;
  size_t bytes ;
  size_t tmp ;

  {
  {
#line 65
  tmp = view_get_selection(view, & offset, (Boolean_t *)((void *)0));
#line 65
  bytes = tmp;
#line 66
  view_delete(view, offset, bytes);
#line 67
  locus_set(view, (locus_t )1, (position_t )(~ 0));
  }
#line 68
  return (bytes);
}
}
#line 71 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
struct view *view_next(struct view *view ) 
{ 
  struct view *new ;
  struct view *tmp ;
  struct view *tmp___0 ;

  {
#line 73
  new = view;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (new->next) {
#line 76
      new = new->next;
    } else
#line 77
    if ((new->text)->next) {
#line 78
      new = ((new->text)->next)->views;
    } else {
#line 80
      new = text_list->views;
    }
#line 74
    if ((unsigned long )new != (unsigned long )view) {
#line 74
      if (! new->window) {
#line 74
        goto while_break;
      }
    } else {
#line 74
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if ((unsigned long )new == (unsigned long )view) {
    {
#line 82
    tmp = text_new();
#line 82
    tmp___0 = tmp;
    }
  } else {
#line 82
    tmp___0 = new;
  }
#line 82
  return (tmp___0);
}
}
#line 85 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
Unicode_t view_unicode(struct view *view , position_t offset , size_t *next ) 
{ 
  Unicode_t ch ;
  Unicode_t tmp ;
  char *raw ;
  size_t length ;
  Unicode_t tmp___0 ;
  Unicode_t tmp___1 ;

  {
  {
#line 87
  tmp = view_byte(view, offset);
#line 87
  ch = tmp;
  }
#line 91
  if (! (ch < 1U << 31)) {
#line 91
    goto _L;
  } else
#line 91
  if (ch < 128U) {
#line 91
    goto _L;
  } else
#line 91
  if ((view->text)->flags & (unsigned int )(1 << 6)) {
    _L: /* CIL Label */ 
#line 94
    if (ch == 13U) {
#line 94
      if ((view->text)->flags & (unsigned int )(1 << 7)) {
        {
#line 94
        tmp___0 = view_byte(view, offset + 1UL);
        }
#line 94
        if (tmp___0 == 10U) {
#line 97
          if (next) {
#line 98
            *next = offset + 2UL;
          }
#line 99
          return ((Unicode_t )'\n');
        }
      }
    }
#line 101
    if (next) {
#line 102
      *next = offset + (position_t )(ch < 1U << 31);
    }
#line 103
    return (ch);
  }
  {
#line 106
  length = view_raw(view, & raw, offset, (size_t )8);
#line 107
  length = utf8_length((char const   *)raw, length);
  }
#line 108
  if (next) {
#line 109
    *next = offset + length;
  }
  {
#line 110
  tmp___1 = utf8_unicode((char const   *)raw, length);
  }
#line 110
  return (tmp___1);
}
}
#line 113 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
Unicode_t view_unicode_prior(struct view *view , position_t offset , position_t *prev ) 
{ 
  Unicode_t ch ;
  char *raw ;
  unsigned int at ;
  position_t tmp ;
  size_t tmp___0 ;
  Unicode_t tmp___1 ;

  {
#line 116
  ch = 1U << 31;
#line 119
  if (offset) {
    {
#line 120
    offset --;
#line 120
    ch = view_byte(view, offset);
    }
#line 121
    if (ch < 1U << 31) {
#line 121
      if (ch >= 128U) {
#line 121
        if (! ((view->text)->flags & (unsigned int )(1 << 6))) {
#line 124
          if (offset >= 7UL) {
#line 124
            tmp = offset - 7UL;
          } else {
#line 124
            tmp = (position_t )0;
          }
          {
#line 124
          at = (unsigned int )tmp;
#line 125
          view_raw(view, & raw, (position_t )at, (offset - (position_t )at) + 1UL);
#line 126
          tmp___0 = utf8_length_backwards((char const   *)((raw + offset) - at), (offset - (position_t )at) + 1UL);
#line 126
          offset -= tmp___0 - 1UL;
#line 128
          ch = view_unicode(view, offset, (size_t *)((void *)0));
          }
        } else {
#line 121
          goto _L___0;
        }
      } else {
#line 121
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 129
    if (ch == 10U) {
#line 129
      if ((view->text)->flags & (unsigned int )(1 << 7)) {
#line 129
        if (offset) {
          {
#line 129
          tmp___1 = view_byte(view, offset - 1UL);
          }
#line 129
          if (tmp___1 == 13U) {
#line 133
            offset --;
          }
        }
      }
    }
  }
#line 135
  if (prev) {
#line 136
    *prev = offset;
  }
#line 137
  return (ch);
}
}
#line 140 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
Unicode_t view_char(struct view *view , position_t offset , size_t *next ) 
{ 
  position_t next0 ;
  Unicode_t ch ;
  Unicode_t tmp ;
  size_t fbytes ;
  position_t next2 ;
  Unicode_t tmp___0 ;

  {
  {
#line 143
  tmp = view_unicode(view, offset, & next0);
#line 143
  ch = tmp;
  }
#line 145
  if (! next) {
#line 146
    return (ch);
  }
#line 147
  *next = next0;
#line 148
  if (ch - 1073741824U < 536870912U) {
    {
#line 149
    fbytes = (size_t )(ch & 536870911U);
#line 151
    tmp___0 = view_unicode(view, next0 + fbytes, & next2);
    }
#line 151
    if ((size_t )tmp___0 == 1610612736UL + fbytes) {
#line 153
      *next = next2;
    }
  }
#line 155
  return (ch);
}
}
#line 158 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
Unicode_t view_char_prior(struct view *view , position_t offset , position_t *prev ) 
{ 
  Unicode_t ch ;
  Unicode_t tmp ;
  Unicode_t ch0 ;
  size_t fbytes ;
  position_t offset0 ;

  {
  {
#line 161
  tmp = view_unicode_prior(view, offset, & offset);
#line 161
  ch = tmp;
  }
#line 165
  if (ch >= 1610612736U) {
#line 165
    fbytes = (size_t )(ch & 536870911U);
#line 165
    if (fbytes <= offset) {
      {
#line 165
      ch0 = view_unicode_prior(view, offset - fbytes, & offset0);
      }
#line 165
      if (ch0 - 1073741824U < 536870912U) {
#line 165
        if ((size_t )(ch0 & 536870911U) == fbytes) {
#line 170
          ch = ch0;
#line 171
          offset = offset0;
        }
      }
    }
  }
#line 173
  if (prev) {
#line 174
    *prev = offset;
  }
#line 175
  return (ch);
}
}
#line 178 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
Boolean_t is_open_bracket(char const   *brackets , Unicode_t ch ) 
{ 


  {
#line 180
  if (ch >= 128U) {
#line 181
    return ((Boolean_t )0);
  }
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! *brackets) {
#line 182
      goto while_break;
    }
#line 183
    if ((Unicode_t )*brackets == ch) {
#line 184
      return ((Boolean_t )1);
    }
#line 182
    brackets += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return ((Boolean_t )0);
}
}
#line 188 "/home/june/collector/temp/aoeui-1.6~dfsg/util.c"
Boolean_t is_close_bracket(char const   *brackets , Unicode_t ch ) 
{ 


  {
#line 190
  if (ch >= 128U) {
#line 191
    return ((Boolean_t )0);
  }
#line 192
  brackets ++;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! *brackets) {
#line 192
      goto while_break;
    }
#line 193
    if ((Unicode_t )*brackets == ch) {
#line 194
      return ((Boolean_t )1);
    }
#line 192
    brackets += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return ((Boolean_t )0);
}
}
#line 64 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
Boolean_t no_keywords  ;
#line 23 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
position_t find_id_end(struct view *view , position_t offset ) ;
#line 6 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static char const   *C_keyword_list[43]  = 
#line 6 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
  {      "#define",      "#elif",      "#else",      "#endif", 
        "#if",      "#ifdef",      "#ifndef",      "#include", 
        "#pragma",      "#undef",      "asm",      "auto", 
        "break",      "case",      "char",      "const", 
        "continue",      "default",      "do",      "double", 
        "else",      "enum",      "extern",      "float", 
        "for",      "goto",      "if",      "int", 
        "long",      "register",      "return",      "short", 
        "signed",      "sizeof",      "static",      "struct", 
        "switch",      "typedef",      "union",      "unsigned", 
        "void",      "volatile",      "while"};
#line 16 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static char const   *Cpp_keyword_list[73]  = 
#line 16
  {      "#define",      "#elif",      "#else",      "#endif", 
        "#if",      "#ifdef",      "#ifndef",      "#include", 
        "#pragma",      "#undef",      "asm",      "auto", 
        "bool",      "break",      "case",      "catch", 
        "char",      "class",      "const",      "const_cast", 
        "continue",      "default",      "delete",      "do", 
        "double",      "dynamic_cast",      "else",      "enum", 
        "explicit",      "export",      "extern",      "false", 
        "float",      "for",      "friend",      "goto", 
        "if",      "inline",      "int",      "long", 
        "mutable",      "namespace",      "new",      "operator", 
        "private",      "protected",      "public",      "register", 
        "reinterpret_cast",      "return",      "short",      "signed", 
        "sizeof",      "static",      "static_cast",      "struct", 
        "switch",      "template",      "this",      "throw", 
        "true",      "try",      "typedef",      "typeid", 
        "typename",      "union",      "unsigned",      "using", 
        "virtual",      "void",      "volatile",      "wchar_t", 
        "while"};
#line 31 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static char const   *Haskell_keyword_list[23]  = 
#line 31
  {      "_",      "case",      "class",      "data", 
        "default",      "deriving",      "do",      "else", 
        "foreign",      "if",      "import",      "in", 
        "infix",      "infixl",      "infixr",      "instance", 
        "let",      "module",      "newtype",      "of", 
        "then",      "type",      "where"};
#line 38 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static sposition_t C_comment_start(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;
  Unicode_t nch ;
  int newlines ;
  int tmp ;

  {
#line 40
  nch = (Unicode_t )0;
#line 41
  newlines = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 43
    ch = view_char_prior(view, offset, & offset);
    }
#line 43
    if (! (ch < 1U << 31)) {
#line 43
      goto while_break;
    }
#line 44
    if (ch == 10U) {
#line 45
      tmp = newlines;
#line 45
      newlines ++;
#line 45
      if (tmp == 100) {
#line 46
        goto while_break;
      }
    } else
#line 47
    if (ch == 47U) {
#line 48
      if (nch == 42U) {
#line 49
        return ((sposition_t )offset);
      }
#line 50
      if (! newlines) {
#line 50
        if (nch == 47U) {
#line 51
          return ((sposition_t )offset);
        }
      }
    } else
#line 52
    if (ch == 42U) {
#line 52
      if (nch == 47U) {
#line 53
        goto while_break;
      }
    }
#line 54
    nch = ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return ((sposition_t )-1);
}
}
#line 59 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static sposition_t C_comment_end(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;
  Unicode_t lch ;
  position_t next ;
  Unicode_t tmp ;
  position_t tmp___0 ;

  {
  {
#line 61
  lch = (Unicode_t )0;
#line 64
  tmp = view_char(view, offset, & offset);
  }
#line 64
  if (tmp != 47U) {
#line 65
    return ((sposition_t )-1);
  }
  {
#line 66
  ch = view_char(view, offset, & offset);
  }
#line 67
  if (ch == 47U) {
    {
#line 68
    tmp___0 = find_line_end(view, offset);
    }
#line 68
    return ((sposition_t )tmp___0);
  }
#line 69
  if (ch != 42U) {
#line 70
    return ((sposition_t )-1);
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    ch = view_char(view, offset, & next);
    }
#line 71
    if (! (ch < 1U << 31)) {
#line 71
      goto while_break;
    }
#line 72
    if (lch == 42U) {
#line 72
      if (ch == 47U) {
#line 73
        return ((sposition_t )offset);
      }
    }
#line 74
    lch = ch;
#line 75
    offset = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return ((sposition_t )-1);
}
}
#line 80 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static sposition_t C_string_end(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;
  Unicode_t lch ;
  Unicode_t ch0 ;
  Unicode_t tmp ;
  position_t next ;

  {
  {
#line 82
  lch = (Unicode_t )0;
#line 82
  tmp = view_char(view, offset, & offset);
#line 82
  ch0 = tmp;
  }
#line 85
  if (ch0 != 39U) {
#line 85
    if (ch0 != 34U) {
#line 86
      return ((sposition_t )-1);
    }
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    ch = view_char(view, offset, & next);
    }
#line 87
    if (! (ch < 1U << 31)) {
#line 87
      goto while_break;
    }
#line 88
    if (ch == ch0) {
#line 88
      if (lch != 92U) {
#line 89
        return ((sposition_t )offset);
      }
    }
#line 90
    if (ch == 10U) {
#line 91
      goto while_break;
    }
#line 92
    if (ch == 92U) {
#line 92
      if (lch == 92U) {
#line 93
        lch = (Unicode_t )0;
      } else {
#line 95
        lch = ch;
      }
    } else {
#line 95
      lch = ch;
    }
#line 96
    offset = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return ((sposition_t )-1);
}
}
#line 101 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static sposition_t Haskell_comment_start(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;
  Unicode_t nch ;
  int newlines ;
  int tmp ;

  {
#line 103
  nch = (Unicode_t )0;
#line 104
  newlines = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    ch = view_char_prior(view, offset, & offset);
    }
#line 106
    if (! (ch < 1U << 31)) {
#line 106
      goto while_break;
    }
#line 107
    if (ch == 10U) {
#line 108
      tmp = newlines;
#line 108
      newlines ++;
#line 108
      if (tmp == 100) {
#line 109
        goto while_break;
      }
    } else
#line 110
    if (ch == 123U) {
#line 110
      if (nch == 45U) {
#line 111
        return ((sposition_t )offset);
      } else {
#line 110
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 112
    if (ch == 45U) {
#line 113
      if (! newlines) {
#line 113
        if (nch == 45U) {
#line 114
          return ((sposition_t )offset);
        }
      }
#line 115
      if (nch == 125U) {
#line 116
        goto while_break;
      }
    }
#line 118
    nch = ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return ((sposition_t )-1);
}
}
#line 123 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static sposition_t Haskell_comment_end(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;
  Unicode_t lch ;
  position_t next ;
  Unicode_t tmp ;
  position_t tmp___0 ;

  {
  {
#line 125
  lch = (Unicode_t )0;
#line 128
  ch = view_char(view, offset, & offset);
  }
#line 129
  if (ch != 45U) {
#line 129
    if (ch != 123U) {
#line 130
      return ((sposition_t )-1);
    }
  }
  {
#line 131
  tmp = view_char(view, offset, & offset);
  }
#line 131
  if (tmp != 45U) {
#line 132
    return ((sposition_t )-1);
  }
#line 133
  if (ch == 45U) {
    {
#line 134
    tmp___0 = find_line_end(view, offset);
    }
#line 134
    return ((sposition_t )tmp___0);
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    ch = view_char(view, offset, & next);
    }
#line 135
    if (! (ch < 1U << 31)) {
#line 135
      goto while_break;
    }
#line 136
    if (lch == 45U) {
#line 136
      if (ch == 125U) {
#line 137
        return ((sposition_t )offset);
      }
    }
#line 138
    lch = ch;
#line 139
    offset = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return ((sposition_t )-1);
}
}
#line 144 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static sposition_t Haskell_string_end(struct view *view , position_t offset ) 
{ 
  position_t next ;
  Unicode_t ch ;
  Unicode_t lch ;
  Unicode_t ch0 ;
  Unicode_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 147
  lch = (Unicode_t )0;
#line 147
  tmp = view_char(view, offset, & next);
#line 147
  ch0 = tmp;
  }
#line 149
  if (ch0 == 39U) {
    {
#line 150
    ch = view_char_prior(view, offset, (position_t *)((void *)0));
#line 151
    tmp___0 = __ctype_b_loc();
    }
#line 151
    if ((int const   )*(*tmp___0 + (int )ch) & 8) {
#line 152
      return ((sposition_t )-1);
    } else
#line 151
    if (ch == 95U) {
#line 152
      return ((sposition_t )-1);
    } else
#line 151
    if (ch == 39U) {
#line 152
      return ((sposition_t )-1);
    }
  } else
#line 153
  if (ch0 != 34U) {
#line 154
    return ((sposition_t )-1);
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 155
    offset = next;
#line 155
    ch = view_char(view, offset, & next);
    }
#line 155
    if (! (ch < 1U << 31)) {
#line 155
      goto while_break;
    }
#line 156
    if (ch == ch0) {
#line 156
      if (lch != 92U) {
#line 157
        return ((sposition_t )offset);
      }
    }
#line 158
    if (ch == 10U) {
#line 159
      goto while_break;
    }
#line 160
    if (ch == 92U) {
#line 160
      if (lch == 92U) {
#line 161
        lch = (Unicode_t )0;
      } else {
#line 163
        lch = ch;
      }
    } else {
#line 163
      lch = ch;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return ((sposition_t )-1);
}
}
#line 171 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
static struct file_keywords kwmap[9]  = 
#line 171
  {      {".c", {(int )(sizeof(C_keyword_list) / sizeof(C_keyword_list[0])), C_keyword_list},
      "()[]{}", & C_comment_start, & C_comment_end, & C_string_end}, 
        {".C", {(int )(sizeof(C_keyword_list) / sizeof(C_keyword_list[0])), C_keyword_list},
      "()[]{}", & C_comment_start, & C_comment_end, & C_string_end}, 
        {".cc", {(int )(sizeof(Cpp_keyword_list) / sizeof(Cpp_keyword_list[0])), Cpp_keyword_list},
      "()[]{}", & C_comment_start, & C_comment_end, & C_string_end}, 
        {".cpp", {(int )(sizeof(Cpp_keyword_list) / sizeof(Cpp_keyword_list[0])), Cpp_keyword_list},
      "()[]{}", & C_comment_start, & C_comment_end, & C_string_end}, 
        {".cxx", {(int )(sizeof(Cpp_keyword_list) / sizeof(Cpp_keyword_list[0])), Cpp_keyword_list},
      "()[]{}", & C_comment_start, & C_comment_end, & C_string_end}, 
        {".h", {(int )(sizeof(Cpp_keyword_list) / sizeof(Cpp_keyword_list[0])), Cpp_keyword_list},
      "()[]{}", & C_comment_start, & C_comment_end, & C_string_end}, 
        {".hs", {(int )(sizeof(Haskell_keyword_list) / sizeof(Haskell_keyword_list[0])),
              Haskell_keyword_list}, "()[]{}", & Haskell_comment_start, & Haskell_comment_end,
      & Haskell_string_end}, 
        {".html", {0, (char const   **)((void *)0)}, "<>", (sposition_t (*)(struct view * ,
                                                                         position_t  ))0,
      (sposition_t (*)(struct view * , position_t  ))0, (sposition_t (*)(struct view * ,
                                                                         position_t  ))0}, 
        {(char const   *)0,
      {0, (char const   **)0}, (char const   *)0, (sposition_t (*)(struct view * ,
                                                                   position_t  ))0,
      (sposition_t (*)(struct view * , position_t  ))0, (sposition_t (*)(struct view * ,
                                                                         position_t  ))0}};
#line 191 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
void keyword_init(struct text *text ) 
{ 
  size_t pathlen ;
  size_t tmp ;
  int j ;
  size_t suffixlen ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 193
  if (text->path) {
    {
#line 194
    tmp = strlen((char const   *)text->path);
#line 194
    pathlen = tmp;
#line 196
    j = 0;
    }
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! kwmap[j].suffix) {
#line 196
        goto while_break;
      }
      {
#line 197
      tmp___0 = strlen(kwmap[j].suffix);
#line 197
      suffixlen = tmp___0;
      }
#line 198
      if (pathlen > suffixlen) {
        {
#line 198
        tmp___1 = strcmp((char const   *)((text->path + pathlen) - suffixlen), kwmap[j].suffix);
        }
#line 198
        if (! tmp___1) {
#line 201
          text->brackets = kwmap[j].brackets;
#line 202
          if (! no_keywords) {
#line 203
            text->keywords = & kwmap[j].keywords;
#line 204
            text->comment_start = kwmap[j].comment_start;
#line 205
            text->comment_end = kwmap[j].comment_end;
#line 206
            text->string_end = kwmap[j].string_end;
          }
#line 208
          return;
        }
      }
#line 196
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 212
  text->brackets = "()[]{}";
#line 213
  text->keywords = (struct keywords *)((void *)0);
#line 214
  return;
}
}
#line 216 "/home/june/collector/temp/aoeui-1.6~dfsg/keyword.c"
Boolean_t is_keyword(struct view *view , position_t offset ) 
{ 
  unsigned int n ;
  char const   **tab ;
  char *word ;
  size_t bytes ;
  position_t tmp ;
  size_t tmp___0 ;
  unsigned int mid ;
  int cmp ;
  int tmp___1 ;

  {
#line 223
  if (! (view->text)->keywords) {
#line 224
    return ((Boolean_t )0);
  }
  {
#line 225
  tmp = find_id_end(view, offset);
#line 225
  bytes = tmp - offset;
#line 226
  tmp___0 = view_raw(view, & word, offset, bytes);
  }
#line 226
  if (tmp___0 < bytes) {
#line 227
    return ((Boolean_t )0);
  }
#line 228
  n = (unsigned int )((view->text)->keywords)->count;
#line 228
  tab = ((view->text)->keywords)->word;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! n) {
#line 228
      goto while_break;
    }
    {
#line 230
    mid = n / 2U;
#line 231
    tmp___1 = strncmp((char const   *)word, *(tab + mid), bytes);
#line 231
    cmp = tmp___1;
    }
#line 232
    if (! cmp) {
#line 233
      if (*(*(tab + mid) + bytes)) {
#line 234
        cmp = -1;
      } else {
#line 236
        return ((Boolean_t )1);
      }
    }
#line 237
    if (cmp < 0) {
#line 238
      n = mid;
    } else {
#line 240
      n -= mid + 1U;
#line 241
      tab += mid + 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return ((Boolean_t )0);
}
}
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/help.c"
static char const   *help[2]  = {      "Welcome to aoeui 1.6!  Here are some clues to help you use the editor.\n\n- The up/down/left/right \"arrow\" keys, page up/down keys, and Delete key\n  all work fine.  You can use aoeui as a simple notepad if you like.\n- To insert text into a document, just type it.\n- In this documentation, the notation ^A means the command A, which you\n  access by holding down Control or Alt while hitting A, or by pressing\n  Escape and then A.  All of these modifiers mean the same thing in aoeui.\n- The space bar, when used as a command (^Sp), is a prefix that distinguishes\n  command variants and numeric arguments.\n\nCommand summary:\n\n^Sp?   display this help again\n   ^Q  pause the editor and return to the shell; return with \"fg\"\n^Sp^Q  save all files and quit\n^Sp^\\  quit immediately without saving\n   ^U  undo                        ^Sp^U  redo\n   ^K  save all files              ^Sp^K  save one file\n\n   ^H  backward                       ^T  forward\n^Sp^H  up                          ^Sp^T  down\n   ^N  previous word                  ^S  next word\n^Sp^N  previous sentence           ^Sp^S  next sentence\n   ^G  previous beginning of line     ^C  next end of line\n^Sp^G  paragraph start             ^Sp^C  paragraph end\n   ^R  previous page                  ^L  next page\n^Sp^R  go to beginning             ^Sp^L  go to end\n   ^]  go to nearest ([{bracket}]), or to corresponding bracket\n^Sp n ^Z  go to line number n\n\n   ^V  begin a selection if none, forgets selection otherwise\n^Sp^V  go to opposite end of selection, or select whole line if none\n   ^D  cut, replacing clip buffer\n         (typing new text at the start of the selection also cuts)\n^Sp^D  with selection: cut, adding to clip buffer\n^Sp^D  without selection: select all white space surrounding cursor\n   ^F  copy, replacing clip buffer\n^Sp^F  copy, adding to clip buffer\n   ^B  exchange clip buffer with selection, if any; else paste\n\n   ^J  insert new line with automatic alignment (^Return may also work)\n   Tab and ^I attempt tab completion if no selection is present\n^SpTab align current line (^Sp^I also works)\n   ^^  insert next character as raw or control character\n^Sp n ^^  insert Unicode character n -- use leading 0x for hexadecimal\n\n   ^_  incremental search mode (^-, ^/, and ^A may also work)\n^Sp^_  incremental regular expression search mode with POSIX regexps.\n         In search mode, use ^H and ^T to move from one\n         instance of the search target to another and any other command,\n         or Return, to resume editing.\n\n   ^X  open file named by selection in new window\n         insert current path as selection if none\n^Sp^X  rename current text with path in selection\n   ^W  display another open view in this window\n^Sp^W  close this window and its text\n   ^Y  split current window horizontally\n^Sp^Y  split current window vertically\n   ^P  switch to another window\n^Sp^P  close current window\n\n^Sp^O  begin recording default macro (end with ^O)\n   ^O  run default macro, or end macro/function key recording\n^SpF1-F12  begin recording function key macro (end with ^O)\n   F1-F12  execute function key macro\n\n   ^E  run shell command in selection with clip buffer as input,\n         or open new shell interaction window if no selection\n^Sp^E  cancel all pending background commands\n\nParting words:\n- Many commands support a repeat count; ^Sp9^T advances nine characters.\n- aoeui has bookmarks, registers, tags, folding, and other features.\n  Read the manual page for the full story and lots of useful tips.\n- Send me a note at pmk@google.com and say hi!\n",      "Welcome to asdfg 1.6!  Here are some clues to help you use the editor.\n\n- The up/down/left/right \"arrow\" keys, page up/down keys, and Delete key\n  all work fine.  You can use asdfg as a simple notepad if you like.\n- To insert text into a document, just type it.\n- In this documentation, the notation ^A means the command A, which you\n  access by holding down Control or Alt while hitting A, or by pressing\n  Escape and then A.  All of these modifiers mean the same thing in asdfg.\n- The space bar, when used as a command (^Sp), is a prefix that distinguishes\n  command variants and numeric arguments.\n\nCommand summary:\n\n^Sp?   display this help again\n   ^Q  pause the editor and return to the shell; return with \"fg\"\n^Sp^Q  save all files and quit\n^Sp^\\  quit immediately without saving\n   ^Z  undo                        ^Sp^Z  redo\n   ^W  save all files              ^Sp^W  save one file\n\n   ^G  backward                       ^H  forward\n^Sp^G  up                          ^Sp^H  down\n   ^K  previous word                  ^L  next word\n^Sp^K  previous sentence           ^Sp^L  next sentence\n   ^T  previous beginning of line     ^Y  next end of line\n^Sp^T  paragraph start             ^Sp^Y  paragraph end\n   ^O  previous page                  ^P  next page\n^Sp^O  go to beginning             ^Sp^P  go to end\n   ^]  go to nearest ([{bracket}]), or to corresponding bracket\n^Sp n ^N  go to line number n\n\n   ^U  begin a selection if none, forgets selection otherwise\n^Sp^U  go to opposite end of selection, or select whole line if none\n   ^X  cut, replacing clip buffer\n         (typing new text at the start of the selection also cuts)\n^Sp^X  with selection: cut, adding to clip buffer\n^Sp^X  without selection: select all white space surrounding cursor\n   ^C  copy, replacing clip buffer\n^Sp^C  copy, adding to clip buffer\n   ^V  exchange clip buffer with selection, if any; else paste\n\n   ^J  insert new line with automatic alignment (^Return may also work)\n   Tab and ^I attempt tab completion if no selection is present\n^SpTab align current line (^Sp^I also works)\n   ^^  insert next character as raw or control character\n^Sp n ^^  insert Unicode character n -- use leading 0x for hexadecimal\n\n   ^_  incremental search mode (^-, ^/, and ^A may also work)\n^Sp^_  incremental regular expression search mode with POSIX regexps.\n         In search mode, use ^G and ^H to move from one\n         instance of the search target to another and any other command,\n         or Return, to resume editing.\n\n   ^E  open file named by selection in new window\n         insert current path as selection if none\n^Sp^E  rename current text with path in selection\n   ^F  display another open view in this window\n^Sp^F  close this window and its text\n   ^D  split current window horizontally\n^Sp^D  split current window vertically\n   ^S  switch to another window\n^Sp^S  close current window\n\n^Sp^B  begin recording default macro (end with ^B)\n   ^B  run default macro, or end macro/function key recording\n^SpF1-F12  begin recording function key macro (end with ^B)\n   F1-F12  execute function key macro\n\n   ^R  run shell command in selection with clip buffer as input,\n         or open new shell interaction window if no selection\n^Sp^R  cancel all pending background commands\n\nParting words:\n- Many commands support a repeat count; ^Sp9^H advances nine characters.\n- asdfg has bookmarks, registers, tags, folding, and other features.\n  Read the manual page for the full story and lots of useful tips.\n- Send me a note at pmk@google.com and say hi!\n"};
#line 10 "/home/june/collector/temp/aoeui-1.6~dfsg/help.c"
struct view *view_help(void) 
{ 
  struct view *view ;
  struct view *tmp ;
  size_t tmp___0 ;

  {
  {
#line 12
  tmp = text_create("* Help *", (unsigned int )(1 << 2));
#line 12
  view = tmp;
#line 13
  tmp___0 = strlen(help[is_asdfg]);
#line 13
  view_insert(view, (void const   *)help[is_asdfg], (position_t )0, (ssize_t )tmp___0);
#line 14
  locus_set(view, (locus_t )0, (position_t )0);
#line 15
  (view->text)->flags |= (unsigned int )(1 << 1);
  }
#line 16
  return (view);
}
}
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/clip.c"
static struct buffer **clip_buffer  ;
#line 5 "/home/june/collector/temp/aoeui-1.6~dfsg/clip.c"
static unsigned int clip_buffers  ;
#line 7 "/home/june/collector/temp/aoeui-1.6~dfsg/clip.c"
void clip_init(unsigned int reg ) 
{ 


  {
#line 9
  if (reg < clip_buffers) {
    {
#line 10
    buffer_delete(*(clip_buffer + reg), (position_t )0, (size_t )(~ 0));
    }
  }
#line 11
  return;
}
}
#line 13 "/home/june/collector/temp/aoeui-1.6~dfsg/clip.c"
size_t clip(unsigned int reg , struct view *view , position_t offset , size_t bytes ,
            Boolean_t append ) 
{ 
  char *raw ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 18
  if (reg >= clip_buffers) {
    {
#line 19
    tmp = reallocate((void const   *)clip_buffer, (unsigned long )(reg + 1U) * sizeof(*clip_buffer));
#line 19
    clip_buffer = (struct buffer **)tmp;
#line 21
    memset((void *)(clip_buffer + clip_buffers), 0, (unsigned long )((reg + 1U) - clip_buffers) * sizeof(*clip_buffer));
#line 23
    clip_buffers = reg + 1U;
    }
  }
#line 26
  if (! *(clip_buffer + reg)) {
    {
#line 27
    *(clip_buffer + reg) = buffer_create((char *)((void *)0));
    }
  }
  {
#line 28
  bytes = view_raw(view, & raw, offset, bytes);
  }
#line 29
  if (append) {
    {
#line 29
    tmp___0 = buffer_bytes(*(clip_buffer + reg));
#line 29
    tmp___1 = tmp___0;
    }
  } else {
#line 29
    tmp___1 = (size_t )0;
  }
  {
#line 29
  tmp___2 = buffer_insert(*(clip_buffer + reg), (void const   *)raw, tmp___1, bytes);
  }
#line 29
  return (tmp___2);
}
}
#line 34 "/home/june/collector/temp/aoeui-1.6~dfsg/clip.c"
size_t clip_paste(struct view *view , position_t offset , unsigned int reg ) 
{ 
  char *raw ;
  size_t bytes ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 39
  if (reg >= clip_buffers) {
#line 40
    return ((size_t )0);
  }
  {
#line 41
  tmp = buffer_bytes(*(clip_buffer + reg));
#line 41
  bytes = buffer_raw(*(clip_buffer + reg), & raw, (position_t )0, tmp);
#line 43
  tmp___0 = view_insert(view, (void const   *)raw, offset, (ssize_t )bytes);
  }
#line 43
  return (tmp___0);
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 20 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
static Boolean_t match_char(Unicode_t x , Unicode_t y ) 
{ 


  {
#line 22
  if (! (x < 1U << 31)) {
#line 23
    return ((Boolean_t )0);
  } else
#line 22
  if (! (y < 1U << 31)) {
#line 23
    return ((Boolean_t )0);
  }
#line 24
  if (x >= 97U) {
#line 24
    if (x <= 122U) {
#line 25
      x += 4294967264U;
    }
  }
#line 26
  if (y >= 97U) {
#line 26
    if (y <= 122U) {
#line 27
      y += 4294967264U;
    }
  }
#line 28
  return ((Boolean_t )(x == y));
}
}
#line 31 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
static size_t match_pattern(struct view *view , position_t offset ) 
{ 
  struct mode_search *mode ;
  size_t j ;
  position_t tmp ;
  Unicode_t tmp___0 ;
  Boolean_t tmp___1 ;

  {
#line 33
  mode = (struct mode_search *)view->mode;
#line 36
  j = (size_t )0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (j < mode->bytes)) {
#line 36
      goto while_break;
    }
    {
#line 37
    tmp = offset;
#line 37
    offset ++;
#line 37
    tmp___0 = view_byte(view, tmp);
#line 37
    tmp___1 = match_char((Unicode_t )*(mode->pattern + j), tmp___0);
    }
#line 37
    if (! tmp___1) {
#line 39
      return ((size_t )0);
    }
#line 36
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return (mode->bytes);
}
}
#line 43 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
static int match_regex(struct view *view , position_t *offset , Boolean_t advance ) 
{ 
  int j ;
  int err ;
  char *raw ;
  size_t bytes ;
  size_t tmp ;
  unsigned int flags ;
  regmatch_t match[10] ;
  struct mode_search *mode ;
  Unicode_t tmp___0 ;

  {
  {
#line 47
  tmp = view_raw(view, & raw, *offset, (size_t )(~ 0));
#line 47
  bytes = tmp;
#line 48
  flags = 0U;
#line 50
  mode = (struct mode_search *)view->mode;
#line 52
  tmp___0 = view_char_prior(view, *offset, (position_t *)((void *)0));
  }
#line 52
  if (tmp___0 != 10U) {
#line 53
    flags |= 1U;
  }
  {
#line 54
  err = regexec((regex_t const   */* __restrict  */)mode->regex, (char const   */* __restrict  */)raw,
                (size_t )10, (regmatch_t */* __restrict  */)(match), (int )flags);
  }
#line 55
  if (err) {
#line 55
    if (err != 1) {
      {
#line 56
      window_beep(view);
      }
    }
  }
#line 57
  if (err) {
#line 58
    return (0);
  }
#line 59
  if (! advance) {
#line 59
    if (match[0].rm_so) {
#line 60
      return (0);
    }
  }
#line 61
  if ((size_t )match[0].rm_so >= bytes) {
#line 62
    return (0);
  }
#line 63
  if ((size_t )match[0].rm_eo > bytes) {
#line 64
    match[0].rm_eo = (regoff_t )bytes;
  }
#line 65
  j = 1;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (j < 10)) {
#line 65
      goto while_break;
    }
#line 66
    if (match[j].rm_so < 0) {
#line 68
      goto __Cont;
    } else
#line 66
    if ((size_t )match[j].rm_so >= bytes) {
#line 68
      goto __Cont;
    }
#line 69
    if ((size_t )match[j].rm_eo > bytes) {
#line 70
      match[j].rm_eo = (regoff_t )bytes;
    }
    {
#line 71
    clip_init((unsigned int )j);
#line 72
    clip((unsigned int )j, view, *offset + (position_t )match[j].rm_so, (size_t )(match[j].rm_eo - match[j].rm_so),
         (Boolean_t )0);
    }
    __Cont: /* CIL Label */ 
#line 65
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  *offset += (position_t )match[0].rm_so;
#line 76
  return (match[0].rm_eo - match[0].rm_so);
}
}
#line 79 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
static int scan_forward(struct view *view , size_t *length , position_t offset , position_t max_offset ) 
{ 
  struct mode_search *mode ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 82
  mode = (struct mode_search *)view->mode;
#line 84
  if (mode->bytes > view->bytes) {
#line 85
    return (-1);
  }
#line 86
  if (max_offset > view->bytes - mode->bytes) {
#line 87
    max_offset = view->bytes - mode->bytes;
  }
#line 88
  if (offset + mode->bytes > max_offset) {
#line 89
    return (-1);
  }
#line 90
  if (mode->regex) {
    {
#line 91
    tmp___0 = match_regex(view, & offset, (Boolean_t )1);
#line 91
    tmp = (size_t )tmp___0;
#line 91
    *length = tmp;
    }
#line 91
    if (tmp) {
#line 91
      if (offset < max_offset) {
#line 93
        return ((int )offset);
      }
    }
  } else {
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! (offset < max_offset)) {
#line 95
        goto while_break;
      }
      {
#line 96
      tmp___1 = match_pattern(view, offset);
#line 96
      *length = tmp___1;
      }
#line 96
      if (tmp___1) {
#line 97
        return ((int )offset);
      }
#line 95
      offset ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 98
  return (-1);
}
}
#line 101 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
static int scan_backward(struct view *view , size_t *length , position_t offset ,
                         position_t min_offset ) 
{ 
  struct mode_search *mode ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 104
  mode = (struct mode_search *)view->mode;
#line 106
  if (min_offset + mode->bytes > view->bytes) {
#line 107
    return (-1);
  }
#line 108
  if (offset + mode->bytes > view->bytes) {
#line 109
    offset = view->bytes - mode->bytes;
  }
#line 110
  if (mode->regex) {
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! (offset + 1UL > min_offset)) {
#line 111
        goto while_break;
      }
      {
#line 112
      tmp___0 = match_regex(view, & offset, (Boolean_t )0);
#line 112
      tmp = (size_t )tmp___0;
#line 112
      *length = tmp;
      }
#line 112
      if (tmp) {
#line 113
        return ((int )offset);
      }
#line 111
      offset --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! (offset + 1UL > min_offset)) {
#line 115
        goto while_break___0;
      }
      {
#line 116
      tmp___1 = match_pattern(view, offset);
#line 116
      *length = tmp___1;
      }
#line 116
      if (tmp___1) {
#line 117
        return ((int )offset);
      }
#line 115
      offset --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 118
  return (-1);
}
}
#line 121 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
static Boolean_t search(struct view *view , int backward , int new ) 
{ 
  struct mode_search *mode ;
  position_t mark ;
  size_t length ;
  int at ;
  int err ;

  {
#line 123
  mode = (struct mode_search *)view->mode;
#line 125
  length = (size_t )0;
#line 128
  if (! mode->bytes) {
    {
#line 129
    locus_set(view, (locus_t )0, mode->start);
#line 130
    locus_set(view, (locus_t )1, (position_t )(~ 0));
    }
#line 131
    return ((Boolean_t )1);
  }
#line 134
  if (mode->regex) {
#line 136
    if (new) {
#line 136
      if (mode->regex_ready) {
        {
#line 137
        regfree(mode->regex);
#line 138
        mode->regex_ready = (Boolean_t )0;
        }
      }
    }
#line 140
    if (! mode->regex_ready) {
      {
#line 141
      *(mode->pattern + mode->bytes) = (Byte_t )'\000';
#line 142
      status("regular expression: %s", mode->pattern);
#line 143
      err = regcomp((regex_t */* __restrict  */)mode->regex, (char const   */* __restrict  */)((char *)mode->pattern),
                    (1 | (1 << 1)) | ((1 << 1) << 1));
      }
#line 145
      if (err) {
#line 146
        return ((Boolean_t )0);
      }
#line 147
      mode->regex_ready = (Boolean_t )1;
    }
  }
  {
#line 151
  mark = locus_get(view, (locus_t )1);
  }
#line 152
  if (mark == 0xffffffffffffffffUL) {
    {
#line 153
    mark = locus_get(view, (locus_t )0);
    }
  }
#line 155
  if (backward) {
    {
#line 156
    at = scan_backward(view, & length, mark - (position_t )(! new), (position_t )0);
    }
#line 157
    if (at < 0) {
      {
#line 158
      at = scan_backward(view, & length, view->bytes, mark + 1UL);
      }
    }
  } else {
    {
#line 161
    at = scan_forward(view, & length, mark + (position_t )(! new), view->bytes);
    }
#line 163
    if (at < 0) {
      {
#line 164
      at = scan_forward(view, & length, (position_t )0, mark - 1UL);
      }
    }
  }
#line 166
  if (at < 0) {
    {
#line 167
    window_beep(view);
#line 168
    macros_abort();
    }
#line 169
    return ((Boolean_t )0);
  }
  {
#line 173
  locus_set(view, (locus_t )1, (position_t )at);
#line 174
  locus_set(view, (locus_t )0, (size_t )at + length);
#line 175
  mode->last_bytes = mode->bytes;
  }
#line 176
  return ((Boolean_t )1);
}
}
#line 182
static void command_handler___0(struct view *view , Unicode_t ch ) ;
#line 182 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
static char cmdchar[3][2]  = { {        (char)8,        (char)7}, 
   {        (char)20,        (char)8}, 
   {        (char)22,        (char)21}};
#line 188 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
static char *last_search  ;
#line 179 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
static void command_handler___0(struct view *view , Unicode_t ch ) 
{ 
  struct mode_search *mode ;
  size_t new ;
  void *tmp ;
  Boolean_t tmp___0 ;
  Boolean_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 181
  mode = (struct mode_search *)view->mode;
#line 193
  if (ch == 127U) {
#line 194
    if (! mode->bytes) {
      {
#line 195
      window_beep(view);
      }
#line 196
      goto done;
    } else {
      {
#line 198
      (mode->bytes) --;
#line 199
      search(view, ! mode->backward, 1);
      }
#line 200
      return;
    }
  }
#line 207
  if (ch >= 32U) {
#line 207
    goto _L;
  } else
#line 207
  if (ch == 9U) {
    _L: /* CIL Label */ 
#line 209
    if (mode->bytes + 8UL > mode->alloc) {
      {
#line 210
      mode->alloc = mode->bytes + 64UL;
#line 211
      tmp = reallocate((void const   *)mode->pattern, mode->alloc);
#line 211
      mode->pattern = (Byte_t *)tmp;
      }
    }
    {
#line 213
    new = unicode_utf8((char *)mode->pattern + mode->bytes, ch);
#line 213
    mode->bytes += new;
#line 215
    *(mode->pattern + mode->bytes) = (Byte_t )'\000';
#line 216
    tmp___0 = search(view, (int )mode->backward, (int )new);
    }
#line 216
    if (! tmp___0) {
#line 216
      if (! mode->regex) {
#line 218
        mode->bytes -= new;
      }
    }
#line 219
    return;
  }
#line 225
  if (mode->last_bytes) {
#line 225
    if (ch == (Unicode_t )cmdchar[0][is_asdfg]) {
      {
#line 230
      mode->bytes = mode->last_bytes;
#line 231
      tmp___1 = (Boolean_t )(ch == (Unicode_t )cmdchar[0][is_asdfg]);
#line 231
      mode->backward = tmp___1;
#line 231
      search(view, (int )tmp___1, 0);
      }
#line 232
      return;
    } else
#line 225
    if (ch == (Unicode_t )cmdchar[1][is_asdfg]) {
      {
#line 230
      mode->bytes = mode->last_bytes;
#line 231
      tmp___1 = (Boolean_t )(ch == (Unicode_t )cmdchar[0][is_asdfg]);
#line 231
      mode->backward = tmp___1;
#line 231
      search(view, (int )tmp___1, 0);
      }
#line 232
      return;
    } else
#line 225
    if (ch == 1U) {
      {
#line 230
      mode->bytes = mode->last_bytes;
#line 231
      tmp___1 = (Boolean_t )(ch == (Unicode_t )cmdchar[0][is_asdfg]);
#line 231
      mode->backward = tmp___1;
#line 231
      search(view, (int )tmp___1, 0);
      }
#line 232
      return;
    } else
#line 225
    if (ch == 31U) {
      {
#line 230
      mode->bytes = mode->last_bytes;
#line 231
      tmp___1 = (Boolean_t )(ch == (Unicode_t )cmdchar[0][is_asdfg]);
#line 231
      mode->backward = tmp___1;
#line 231
      search(view, (int )tmp___1, 0);
      }
#line 232
      return;
    }
  }
#line 238
  if (ch == (Unicode_t )cmdchar[0][is_asdfg]) {
#line 238
    goto _L___0;
  } else
#line 238
  if (ch == (Unicode_t )cmdchar[1][is_asdfg]) {
#line 238
    goto _L___0;
  } else
#line 238
  if (ch == 1U) {
#line 238
    goto _L___0;
  } else
#line 238
  if (ch == 31U) {
    _L___0: /* CIL Label */ 
#line 238
    if (! mode->bytes) {
#line 238
      if (last_search) {
        {
#line 243
        mode->bytes = strlen((char const   *)last_search);
#line 244
        mode->alloc = mode->bytes + 8UL;
#line 245
        tmp___2 = reallocate((void const   *)mode->pattern, mode->alloc);
#line 245
        mode->pattern = (Byte_t *)tmp___2;
#line 246
        memcpy((void */* __restrict  */)mode->pattern, (void const   */* __restrict  */)last_search,
               mode->bytes + 1UL);
        }
#line 247
        if (ch == (Unicode_t )cmdchar[0][is_asdfg]) {
#line 248
          mode->backward = (Boolean_t )1;
        } else
#line 249
        if (ch == (Unicode_t )cmdchar[1][is_asdfg]) {
#line 250
          mode->backward = (Boolean_t )0;
        }
        {
#line 251
        search(view, (int )mode->backward, 0);
        }
#line 252
        return;
      }
    }
  }
  done: 
#line 256
  if (mode->bytes) {
    {
#line 257
    tmp___3 = reallocate((void const   *)last_search, mode->bytes + 1UL);
#line 257
    last_search = (char *)tmp___3;
#line 258
    memcpy((void */* __restrict  */)last_search, (void const   */* __restrict  */)mode->pattern,
           mode->bytes);
#line 259
    *(last_search + mode->bytes) = (char )'\000';
    }
  }
  {
#line 262
  view->mode = mode->previous;
#line 263
  status_hide();
  }
#line 265
  if (! (ch == (Unicode_t )cmdchar[2][is_asdfg])) {
    {
#line 269
    locus_set(view, (locus_t )1, mode->mark);
    }
#line 270
    if (ch != 13U) {
#line 270
      if (ch != 1U) {
#line 270
        if (ch != 31U) {
#line 270
          if (ch != 127U) {
            {
#line 274
            (*((view->mode)->command))(view, ch);
            }
          }
        }
      }
    }
  }
  {
#line 278
  reallocate((void const   *)mode->pattern, (size_t )0);
#line 278
  mode->pattern = (Byte_t *)((void *)0);
  }
#line 279
  if (mode->regex_ready) {
    {
#line 280
    regfree(mode->regex);
    }
  }
  {
#line 281
  reallocate((void const   *)mode->regex, (size_t )0);
#line 281
  mode->regex = (regex_t *)((void *)0);
#line 282
  reallocate((void const   *)mode, (size_t )0);
#line 282
  mode = (struct mode_search *)((void *)0);
  }
#line 283
  return;
}
}
#line 285 "/home/june/collector/temp/aoeui-1.6~dfsg/search.c"
void mode_search(struct view *view , Boolean_t regex ) 
{ 
  struct mode_search *mode ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 287
  tmp = allocate0(sizeof(*mode));
#line 287
  mode = (struct mode_search *)tmp;
#line 288
  mode->previous = view->mode;
#line 289
  mode->command = & command_handler___0;
#line 290
  mode->selection_bgrgba = 4294901760U;
#line 291
  mode->start = locus_get(view, (locus_t )0);
#line 292
  mode->mark = locus_get(view, (locus_t )1);
  }
#line 293
  if (regex) {
    {
#line 294
    tmp___0 = allocate0(sizeof(*(mode->regex)));
#line 294
    mode->regex = (regex_t *)tmp___0;
    }
  }
#line 295
  view->mode = (struct mode *)mode;
#line 296
  return;
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 128 "/home/june/collector/temp/aoeui-1.6~dfsg/text.h"
char *tab_complete(char const   *string , Boolean_t selection ) ;
#line 33 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
sposition_t find_string(struct view *view , char const   *string , position_t offset ) ;
#line 4 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
static char *path_complete(char const   *string ) 
{ 
  char const   *home ;
  size_t length ;
  char *new ;
  char *p ;
  DIR *dir ;
  char *freestring ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  struct dirent *dent ;
  size_t prefix_len ;
  size_t best_len ;
  size_t dent_len ;
  size_t tmp___7 ;
  int tmp___8 ;
  unsigned int old_best_len ;

  {
#line 8
  new = (char *)((void *)0);
#line 10
  freestring = (char *)((void *)0);
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 12
    tmp = __ctype_b_loc();
    }
#line 12
    if (! ((int const   )*(*tmp + (int )*string) & 8192)) {
#line 12
      goto while_break;
    }
#line 13
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 14
  tmp___3 = strncmp(string, "~/", (size_t )2);
  }
#line 14
  if (! tmp___3) {
    {
#line 14
    tmp___4 = getenv("HOME");
#line 14
    home = (char const   *)tmp___4;
    }
#line 14
    if (home) {
      {
#line 16
      tmp___0 = strlen(home);
#line 16
      tmp___1 = strlen(string);
#line 16
      tmp___2 = reallocate((void const   *)((void *)0), tmp___0 + tmp___1);
#line 16
      freestring = (char *)tmp___2;
#line 17
      sprintf((char */* __restrict  */)freestring, (char const   */* __restrict  */)"%s%s",
              home, string + 1);
#line 18
      string = (char const   *)freestring;
      }
    }
  }
  {
#line 21
  length = strlen(string);
#line 22
  tmp___5 = reallocate((void const   *)((void *)0), length + 255UL);
#line 22
  new = (char *)tmp___5;
#line 23
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)string, length + 1UL);
#line 24
  p = strrchr((char const   *)new, '/');
  }
#line 25
  if (p) {
    {
#line 26
    *p = (char )'\000';
#line 27
    dir = opendir((char const   *)new);
#line 28
    tmp___6 = p;
#line 28
    p ++;
#line 28
    *tmp___6 = (char )'/';
    }
  } else {
    {
#line 30
    dir = opendir(".");
#line 31
    p = new;
    }
  }
#line 33
  if (dir) {
#line 35
    prefix_len = (size_t )((new + length) - p);
#line 36
    best_len = (size_t )0;
    {
#line 37
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 37
      dent = readdir(dir);
      }
#line 37
      if (! dent) {
#line 37
        goto while_break___0;
      }
      {
#line 38
      tmp___7 = strlen((char const   *)(dent->d_name));
#line 38
      dent_len = tmp___7;
      }
#line 39
      if (dent_len <= prefix_len) {
#line 40
        goto while_continue___0;
      }
      {
#line 41
      tmp___8 = strncmp((char const   *)p, (char const   *)(dent->d_name), prefix_len);
      }
#line 41
      if (tmp___8) {
#line 42
        goto while_continue___0;
      }
#line 43
      if (! best_len) {
        {
#line 44
        strcpy((char */* __restrict  */)(new + length), (char const   */* __restrict  */)(dent->d_name + prefix_len));
#line 45
        best_len = dent_len - prefix_len;
        }
      } else {
#line 47
        old_best_len = (unsigned int )best_len;
#line 48
        best_len = (size_t )0;
        {
#line 48
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 48
          if (! (best_len < (size_t )old_best_len)) {
#line 48
            goto while_break___1;
          }
#line 51
          if ((int )*(new + (length + best_len)) != (int )dent->d_name[prefix_len + best_len]) {
#line 53
            goto while_break___1;
          }
#line 48
          best_len ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 54
        if (! best_len) {
#line 55
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 58
    *(new + (length + best_len)) = (char )'\000';
#line 59
    closedir(dir);
    }
#line 60
    if (best_len) {
#line 61
      goto done;
    }
  }
  {
#line 64
  reallocate((void const   *)new, (size_t )0);
#line 64
  new = (char *)((void *)0);
  }
  done: 
  {
#line 65
  reallocate((void const   *)freestring, (size_t )0);
#line 65
  freestring = (char *)((void *)0);
  }
#line 66
  return (new);
}
}
#line 69 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
static char *word_complete(char const   *string ) 
{ 
  struct text *text ;
  struct view *hit_view ;
  size_t hit_offset ;
  size_t hit_length ;
  size_t length ;
  size_t tmp ;
  struct view *view ;
  sposition_t offset ;
  size_t old_hit_length ;
  position_t last ;
  size_t this_length ;
  position_t tmp___0 ;
  Unicode_t tmp___1 ;
  Unicode_t tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 72
  hit_view = (struct view *)((void *)0);
#line 73
  hit_offset = (size_t )0;
#line 73
  hit_length = (size_t )0;
#line 74
  tmp = strlen(string);
#line 74
  length = tmp;
  }
#line 76
  if (! length) {
#line 77
    return ((char *)((void *)0));
  }
#line 78
  text = text_list;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! text) {
#line 78
      goto while_break;
    }
#line 79
    view = text->views;
#line 81
    if (! view) {
#line 82
      goto __Cont;
    }
#line 83
    offset = (sposition_t )0;
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 83
      offset = find_string(view, string, (position_t )offset);
      }
#line 83
      if (! (offset >= 0L)) {
#line 83
        goto while_break___0;
      }
      {
#line 87
      last = ((size_t )offset + length) - 1UL;
#line 88
      tmp___0 = find_word_end(view, last);
#line 88
      this_length = (tmp___0 - last) - 1UL;
      }
#line 90
      if (! this_length) {
#line 91
        goto __Cont___0;
      }
#line 92
      old_hit_length = hit_length;
#line 92
      if (old_hit_length) {
#line 97
        hit_length = (size_t )0;
        {
#line 97
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 97
          if (! (hit_length < old_hit_length)) {
#line 97
            goto while_break___1;
          }
          {
#line 100
          tmp___1 = view_byte(hit_view, (hit_offset + length) + hit_length);
#line 100
          tmp___2 = view_byte(view, ((size_t )offset + length) + hit_length);
          }
#line 100
          if (tmp___1 != tmp___2) {
#line 105
            goto while_break___1;
          }
#line 97
          hit_length ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 106
        if (! hit_length) {
#line 107
          return ((char *)((void *)0));
        }
      } else {
#line 93
        hit_view = view;
#line 94
        hit_offset = (size_t )offset;
#line 95
        hit_length = this_length;
      }
      __Cont___0: /* CIL Label */ 
#line 83
      offset ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 78
    text = text->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  if (! hit_length) {
#line 113
    return ((char *)((void *)0));
  }
  {
#line 114
  tmp___3 = view_extract(hit_view, hit_offset, (unsigned int )(length + hit_length));
  }
#line 114
  return (tmp___3);
}
}
#line 117 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
char *tab_complete(char const   *string , Boolean_t selection ) 
{ 
  char *new ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 119
  new = (char *)((void *)0);
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp = __ctype_b_loc();
    }
#line 120
    if (! ((int const   )*(*tmp + (int )*string) & 8192)) {
#line 120
      goto while_break;
    }
#line 121
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if (! *string) {
#line 123
    return ((char *)((void *)0));
  }
#line 124
  if (selection) {
    {
#line 125
    new = path_complete(string);
    }
  }
#line 126
  if (! new) {
    {
#line 127
    new = word_complete(string);
    }
  }
#line 128
  if (new) {
    {
#line 128
    tmp___0 = strcmp((char const   *)new, string);
    }
#line 128
    if (! tmp___0) {
      {
#line 129
      reallocate((void const   *)new, (size_t )0);
#line 129
      new = (char *)((void *)0);
      }
    }
  }
#line 130
  return (new);
}
}
#line 133 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
Boolean_t tab_completion_command(struct view *view ) 
{ 
  position_t cursor ;
  position_t tmp ;
  position_t mark ;
  position_t tmp___0 ;
  char *completed ;
  char *select___0 ;
  Boolean_t selection ;
  Unicode_t ch ;
  Boolean_t result ;
  unsigned short const   **tmp___1 ;
  position_t tmp___2 ;

  {
  {
#line 135
  tmp = locus_get(view, (locus_t )0);
#line 135
  cursor = tmp;
#line 136
  tmp___0 = locus_get(view, (locus_t )1);
#line 136
  mark = tmp___0;
#line 137
  completed = (char *)((void *)0);
#line 137
  select___0 = (char *)((void *)0);
#line 138
  selection = (Boolean_t )(mark < cursor);
#line 140
  result = (Boolean_t )0;
  }
#line 142
  if (selection) {
    {
#line 143
    select___0 = view_extract_selection(view);
    }
  } else
#line 144
  if (mark == 0xffffffffffffffffUL) {
    {
#line 144
    ch = view_char_prior(view, cursor, (position_t *)((void *)0));
    }
#line 144
    if (ch < 65536U) {
      {
#line 144
      tmp___1 = __ctype_b_loc();
      }
#line 144
      if ((int const   )*(*tmp___1 + (int )ch) & 8) {
#line 144
        goto _L;
      } else
#line 144
      if (ch == 95U) {
        _L: /* CIL Label */ 
        {
#line 147
        mark = find_word_start(view, cursor);
        }
#line 148
        if (mark < cursor) {
          {
#line 149
          select___0 = view_extract(view, mark, (unsigned int )(cursor - mark));
          }
        }
      }
    }
  }
#line 151
  if (select___0) {
    {
#line 151
    completed = tab_complete((char const   *)select___0, selection);
    }
#line 151
    if (completed) {
      {
#line 152
      view_delete(view, mark, cursor - mark);
#line 153
      tmp___2 = locus_get(view, (locus_t )0);
#line 153
      view_insert(view, (void const   *)completed, tmp___2, (ssize_t )-1);
      }
#line 154
      if (! selection) {
#line 155
        mark = cursor;
      }
      {
#line 156
      locus_set(view, (locus_t )1, mark);
#line 157
      reallocate((void const   *)completed, (size_t )0);
#line 157
      completed = (char *)((void *)0);
#line 158
      result = (Boolean_t )1;
      }
    }
  }
  {
#line 160
  reallocate((void const   *)select___0, (size_t )0);
#line 160
  select___0 = (char *)((void *)0);
  }
#line 161
  return (result);
}
}
#line 164 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
void insert_tab(struct view *view ) 
{ 
  position_t cursor ;
  position_t tmp ;
  position_t mark ;
  position_t tmp___0 ;
  int tabstop ;
  sposition_t offset ;
  position_t at ;
  position_t tmp___1 ;
  Unicode_t ch ;
  Unicode_t tmp___2 ;
  sposition_t tmp___3 ;

  {
  {
#line 166
  tmp = locus_get(view, (locus_t )0);
#line 166
  cursor = tmp;
#line 167
  tmp___0 = locus_get(view, (locus_t )1);
#line 167
  mark = tmp___0;
  }
#line 169
  if (mark != 0xffffffffffffffffUL) {
#line 169
    if (mark > cursor) {
      {
#line 170
      view_delete(view, cursor, mark - cursor);
#line 171
      mark = (position_t )(~ 0);
#line 171
      locus_set(view, (locus_t )1, mark);
      }
    }
  }
#line 173
  if ((view->text)->flags & (unsigned int )(1 << 5)) {
    {
#line 174
    tabstop = (int )(view->text)->tabstop;
#line 175
    offset = (sposition_t )0;
#line 176
    tmp___1 = find_line_start(view, cursor);
#line 176
    at = tmp___1;
    }
#line 177
    if (at) {
      {
#line 178
      while (1) {
        while_continue: /* CIL Label */ ;
#line 178
        if (! (at != cursor)) {
#line 178
          goto while_break;
        }
        {
#line 179
        tmp___2 = view_char(view, at, & at);
#line 179
        ch = tmp___2;
        }
#line 180
        if (ch == 9U) {
#line 181
          offset = (offset / (sposition_t )tabstop + 1L) * (sposition_t )tabstop;
        } else {
#line 184
          offset ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 186
    offset %= (long )tabstop;
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      tmp___3 = offset;
#line 186
      offset ++;
#line 186
      if (! (tmp___3 < (sposition_t )tabstop)) {
#line 186
        goto while_break___0;
      }
      {
#line 187
      view_insert(view, (void const   *)" ", cursor, (ssize_t )1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 189
    view_insert(view, (void const   *)"\t", cursor, (ssize_t )1);
    }
  }
#line 190
  if (mark == cursor) {
    {
#line 191
    locus_set(view, (locus_t )1, cursor);
    }
  }
#line 192
  return;
}
}
#line 194 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
static void indent_line(struct view *view , position_t lnstart , unsigned int indentation___0 ,
                        Boolean_t no_blank_line ) 
{ 
  char *indent ;
  unsigned int indent_bytes ;
  position_t nonspace ;
  position_t next ;
  Unicode_t ch ;
  unsigned short const   **tmp ;
  void *tmp___0 ;
  unsigned int tabstop ;
  void *tmp___1 ;

  {
#line 204
  nonspace = lnstart;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 204
    ch = view_char(view, nonspace, & next);
    }
#line 204
    if (! (ch < 1U << 31)) {
#line 204
      goto while_break;
    }
#line 207
    if (ch == 10U) {
#line 208
      goto while_break;
    } else
#line 207
    if (! (ch < 65536U)) {
#line 208
      goto while_break;
    } else {
      {
#line 207
      tmp = __ctype_b_loc();
      }
#line 207
      if (! ((int const   )*(*tmp + (int )ch) & 8192)) {
#line 208
        goto while_break;
      }
    }
#line 204
    nonspace = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  view_delete(view, lnstart, nonspace - lnstart);
  }
#line 210
  if (no_blank_line) {
#line 210
    if (ch == 10U) {
#line 211
      return;
    }
  }
#line 213
  if ((view->text)->flags & (unsigned int )(1 << 5)) {
    {
#line 214
    indent_bytes = indentation___0;
#line 215
    tmp___0 = reallocate((void const   *)((void *)0), (size_t )indent_bytes);
#line 215
    indent = (char *)tmp___0;
#line 216
    memset((void *)indent, ' ', (size_t )indentation___0);
    }
  } else {
    {
#line 218
    tabstop = (view->text)->tabstop;
#line 219
    tabstop |= (unsigned int )(! tabstop);
#line 220
    indent_bytes = indentation___0 / tabstop + indentation___0 % tabstop;
#line 221
    tmp___1 = reallocate((void const   *)((void *)0), (size_t )indent_bytes);
#line 221
    indent = (char *)tmp___1;
#line 222
    memset((void *)indent, '\t', (size_t )(indentation___0 / tabstop));
#line 223
    memset((void *)(indent + indentation___0 / tabstop), ' ', (size_t )(indentation___0 % tabstop));
    }
  }
  {
#line 227
  view_insert(view, (void const   *)indent, lnstart, (ssize_t )indent_bytes);
#line 228
  reallocate((void const   *)indent, (size_t )0);
#line 228
  indent = (char *)((void *)0);
  }
#line 229
  return;
}
}
#line 231 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
static int current_line_indentation(struct view *view , position_t *at ) 
{ 
  int indent ;
  int spaces ;
  int chars ;
  position_t offset ;
  Unicode_t ch ;
  unsigned int tabstop ;

  {
#line 233
  indent = 0;
#line 233
  spaces = 0;
#line 233
  chars = 0;
#line 234
  offset = *at;
#line 236
  tabstop = (view->text)->tabstop;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 238
    ch = view_char(view, offset, & offset);
    }
#line 238
    if (ch < 1U << 31) {
#line 238
      if (! (ch != 10U)) {
#line 238
        goto while_break;
      }
    } else {
#line 238
      goto while_break;
    }
#line 239
    if (ch == 32U) {
#line 240
      spaces += ! chars;
    } else
#line 241
    if (ch == 9U) {
#line 242
      indent = (int )(((unsigned int )((indent + spaces) + chars) / tabstop + 1U) * tabstop);
#line 244
      chars = 0;
#line 244
      spaces = chars;
#line 245
      *at = offset;
    } else {
#line 247
      chars ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  *at += (position_t )spaces;
#line 249
  return (indent + spaces);
}
}
#line 252 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
static int line_alignment(struct view *view , position_t lnstart0 ) 
{ 
  position_t lnstart ;
  position_t offset ;
  position_t at ;
  position_t corr ;
  Unicode_t ch ;
  unsigned int indent ;
  unsigned int brindent ;
  unsigned int tabstop ;
  Boolean_t is_nested ;
  Unicode_t tmp ;
  int tmp___0 ;
  sposition_t tmp___1 ;
  sposition_t tmp___2 ;

  {
#line 257
  tabstop = (view->text)->tabstop;
#line 260
  if (! lnstart0) {
#line 261
    return (0);
  }
#line 262
  lnstart = lnstart0 - 1UL;
#line 263
  tabstop |= (unsigned int )(! tabstop);
  again: 
  {
#line 266
  lnstart = find_line_start(view, lnstart);
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (lnstart) {
      {
#line 267
      tmp = view_char(view, lnstart, (size_t *)((void *)0));
      }
#line 267
      if (! (tmp == 10U)) {
#line 267
        goto while_break;
      }
    } else {
#line 267
      goto while_break;
    }
    {
#line 268
    lnstart = find_line_start(view, lnstart - 1UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  at = lnstart;
#line 272
  tmp___0 = current_line_indentation(view, & at);
#line 272
  indent = (unsigned int )tmp___0;
#line 275
  brindent = indent + 1U;
#line 276
  is_nested = (Boolean_t )0;
#line 277
  ch = view_char(view, at, & offset);
  }
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 277
    if (ch < 1U << 31) {
#line 277
      if (! (ch != 10U)) {
#line 277
        goto while_break___0;
      }
    } else {
#line 277
      goto while_break___0;
    }
    {
#line 282
    if (ch == 91U) {
#line 282
      goto case_91;
    }
#line 282
    if (ch == 40U) {
#line 282
      goto case_91;
    }
#line 290
    if (ch == 93U) {
#line 290
      goto case_93;
    }
#line 290
    if (ch == 41U) {
#line 290
      goto case_93;
    }
#line 297
    if (ch == 9U) {
#line 297
      goto case_9;
    }
#line 280
    goto switch_break;
    case_91: /* CIL Label */ 
    case_40: /* CIL Label */ 
    {
#line 283
    tmp___1 = find_corresponding_bracket(view, at);
#line 283
    corr = (position_t )tmp___1;
    }
#line 284
    if (corr >= lnstart0) {
#line 285
      indent = brindent;
#line 286
      is_nested = (Boolean_t )1;
    }
#line 288
    goto switch_break;
    case_93: /* CIL Label */ 
    case_41: /* CIL Label */ 
    {
#line 291
    tmp___2 = find_corresponding_bracket(view, at);
#line 291
    corr = (position_t )tmp___2;
    }
#line 292
    if (corr < lnstart) {
#line 293
      lnstart = corr;
#line 294
      goto again;
    }
#line 296
    goto switch_break;
    case_9: /* CIL Label */ 
#line 298
    brindent = (brindent / tabstop + 1U) * tabstop;
#line 299
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 277
    at = offset;
#line 277
    ch = view_char(view, at, & offset);
#line 277
    brindent ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 304
  if (! is_nested) {
#line 304
    if (lnstart0) {
      {
#line 305
      ch = view_char_prior(view, lnstart0 - 1UL, (position_t *)((void *)0));
      }
#line 306
      if (ch == 123U) {
#line 307
        indent = (indent / tabstop + 1U) * tabstop;
      } else
#line 306
      if (ch == 41U) {
#line 307
        indent = (indent / tabstop + 1U) * tabstop;
      } else
#line 306
      if (ch == 58U) {
#line 307
        indent = (indent / tabstop + 1U) * tabstop;
      } else
#line 306
      if (ch == 101U) {
#line 307
        indent = (indent / tabstop + 1U) * tabstop;
      } else
#line 308
      if (indent >= tabstop) {
#line 309
        offset = lnstart;
        {
#line 310
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 310
          ch = view_char_prior(view, offset, & offset);
          }
#line 310
          if (! (ch == 32U)) {
#line 310
            if (! (ch == 9U)) {
#line 310
              if (! (ch == 10U)) {
#line 310
                goto while_break___1;
              }
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 312
        if (ch == 41U) {
#line 313
          indent = (indent / tabstop - 1U) * tabstop;
        }
      }
    }
  }
#line 318
  if (indent) {
#line 319
    offset = lnstart0;
    {
#line 320
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 320
      ch = view_char(view, offset, & offset);
      }
#line 320
      if (! (ch == 32U)) {
#line 320
        if (! (ch == 9U)) {
#line 320
          goto while_break___2;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 322
    if (ch == 125U) {
#line 323
      indent = (indent / tabstop - 1U) * tabstop;
    }
  }
#line 326
  return ((int )indent);
}
}
#line 329 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
void align(struct view *view ) 
{ 
  position_t cursor ;
  position_t tmp ;
  position_t mark ;
  position_t tmp___0 ;
  position_t line_start ;
  position_t tmp___1 ;
  int tmp___2 ;
  position_t top ;
  position_t bottom ;
  position_t line_start___0 ;
  locus_t end ;
  int align___0 ;
  int tmp___3 ;
  position_t tmp___4 ;
  position_t tmp___5 ;

  {
  {
#line 331
  tmp = locus_get(view, (locus_t )0);
#line 331
  cursor = tmp;
#line 332
  tmp___0 = locus_get(view, (locus_t )1);
#line 332
  mark = tmp___0;
  }
#line 333
  if (mark == 0xffffffffffffffffUL) {
    {
#line 334
    tmp___1 = find_line_start(view, cursor);
#line 334
    line_start = tmp___1;
#line 335
    tmp___2 = line_alignment(view, line_start);
#line 335
    indent_line(view, line_start, (unsigned int )tmp___2, (Boolean_t )0);
    }
  } else {
#line 340
    if (cursor <= mark) {
#line 341
      top = cursor;
#line 341
      bottom = mark;
    } else {
#line 343
      top = mark;
#line 343
      bottom = cursor;
    }
    {
#line 344
    end = locus_create(view, bottom);
#line 345
    line_start___0 = find_line_start(view, top);
    }
    {
#line 346
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 347
      tmp___3 = line_alignment(view, line_start___0);
#line 347
      align___0 = tmp___3;
#line 348
      indent_line(view, line_start___0, (unsigned int )align___0, (Boolean_t )1);
#line 349
      tmp___4 = find_line_end(view, line_start___0);
#line 349
      line_start___0 = tmp___4 + 1UL;
#line 346
      tmp___5 = locus_get(view, end);
      }
#line 346
      if (! (line_start___0 < tmp___5)) {
#line 346
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 351
    locus_destroy(view, end);
    }
  }
#line 353
  return;
}
}
#line 355 "/home/june/collector/temp/aoeui-1.6~dfsg/tab.c"
void insert_newline(struct view *view ) 
{ 
  sposition_t cursor ;
  position_t tmp ;
  position_t mark ;
  position_t tmp___0 ;
  position_t at ;
  int la ;
  int cla ;
  int tmp___1 ;
  Unicode_t tmp___2 ;
  Unicode_t tmp___3 ;

  {
  {
#line 357
  tmp = locus_get(view, (locus_t )0);
#line 357
  cursor = (sposition_t )tmp;
#line 358
  tmp___0 = locus_get(view, (locus_t )1);
#line 358
  mark = tmp___0;
  }
#line 359
  if (mark != 0xffffffffffffffffUL) {
#line 359
    if (mark > (position_t )cursor) {
      {
#line 360
      view_delete(view, (position_t )cursor, mark - (position_t )cursor);
#line 361
      mark = (position_t )(~ 0);
#line 361
      locus_set(view, (locus_t )1, mark);
      }
    }
  }
  {
#line 363
  view_insert(view, (void const   *)"\n", (position_t )cursor, (ssize_t )1);
#line 364
  cursor ++;
#line 364
  locus_set(view, (locus_t )0, (position_t )cursor);
#line 365
  tmp___3 = view_byte(view, (position_t )(cursor - 2L));
  }
#line 365
  if (tmp___3 == 123U) {
#line 366
    at = (position_t )(cursor + 1L);
#line 368
    if ((size_t )cursor == view->bytes) {
      {
#line 373
      view_insert(view, (void const   *)"}\n", (position_t )cursor, (ssize_t )(1 + ((size_t )cursor == view->bytes)));
#line 375
      align(view);
#line 376
      view_insert(view, (void const   *)"\n", (position_t )cursor, (ssize_t )1);
#line 377
      locus_set(view, (locus_t )0, (position_t )cursor);
      }
    } else {
      {
#line 368
      la = line_alignment(view, (position_t )cursor);
#line 368
      tmp___1 = current_line_indentation(view, & at);
#line 368
      cla = (int )((unsigned int )tmp___1 + (view->text)->tabstop);
      }
#line 368
      if (la > cla) {
        {
#line 373
        view_insert(view, (void const   *)"}\n", (position_t )cursor, (ssize_t )(1 + ((size_t )cursor == view->bytes)));
#line 375
        align(view);
#line 376
        view_insert(view, (void const   *)"\n", (position_t )cursor, (ssize_t )1);
#line 377
        locus_set(view, (locus_t )0, (position_t )cursor);
        }
      } else
#line 368
      if (la == cla) {
        {
#line 368
        tmp___2 = view_byte(view, at);
        }
#line 368
        if (tmp___2 != 125U) {
          {
#line 373
          view_insert(view, (void const   *)"}\n", (position_t )cursor, (ssize_t )(1 + ((size_t )cursor == view->bytes)));
#line 375
          align(view);
#line 376
          view_insert(view, (void const   *)"\n", (position_t )cursor, (ssize_t )1);
#line 377
          locus_set(view, (locus_t )0, (position_t )cursor);
          }
        }
      }
    }
  }
  {
#line 380
  align(view);
  }
#line 381
  return;
}
}
#line 82 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static struct display *display_list___0  ;
#line 83 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void (*old_sigwinch___0)(int  , siginfo_t * , void * )  ;
#line 84 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static FILE *debug_file___0  ;
#line 86 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void emit___0(char const   *str , size_t bytes ) 
{ 
  size_t wrote ;
  ssize_t chunk ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 91
  if (debug_file___0) {
#line 91
    if (bytes) {
      {
#line 92
      fprintf((FILE */* __restrict  */)debug_file___0, (char const   */* __restrict  */)"emit %d:",
              (int )bytes);
#line 93
      fwrite((void const   */* __restrict  */)str, bytes, (size_t )1, (FILE */* __restrict  */)debug_file___0);
#line 94
      fputc('\n', debug_file___0);
      }
    }
  }
#line 97
  wrote = (size_t )0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (wrote < bytes)) {
#line 97
      goto while_break;
    }
    {
#line 98
    tmp = __errno_location();
#line 98
    *tmp = 0;
#line 99
    chunk = write(1, (void const   *)(str + wrote), bytes - wrote);
    }
#line 100
    if (chunk < 0L) {
      {
#line 101
      tmp___0 = __errno_location();
      }
#line 101
      if (*tmp___0 == 4) {
#line 102
        goto __Cont;
      } else {
        {
#line 101
        tmp___1 = __errno_location();
        }
#line 101
        if (*tmp___1 == 11) {
#line 102
          goto __Cont;
        }
      }
      {
#line 103
      die("write of %d bytes failed", bytes);
      }
    }
    __Cont: /* CIL Label */ 
#line 97
    wrote += (size_t )chunk;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void flush___0(struct display *display___0 ) 
{ 


  {
  {
#line 110
  emit___0((char const   *)(display___0->outbuf), display___0->outbuf_bytes);
#line 111
  display___0->outbuf_bytes = (size_t )0;
  }
#line 112
  return;
}
}
#line 114 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void out___0(struct display *display___0 , char const   *str , size_t bytes ) 
{ 


  {
#line 116
  if (display___0->outbuf_bytes + bytes > sizeof(display___0->outbuf)) {
    {
#line 117
    flush___0(display___0);
    }
  }
#line 118
  if (bytes > sizeof(display___0->outbuf)) {
    {
#line 119
    emit___0(str, bytes);
    }
  } else {
    {
#line 121
    memcpy((void */* __restrict  */)(display___0->outbuf + display___0->outbuf_bytes),
           (void const   */* __restrict  */)str, bytes);
#line 122
    display___0->outbuf_bytes += bytes;
    }
  }
#line 124
  return;
}
}
#line 126 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void outs___0(struct display *display___0 , char const   *str ) 
{ 
  size_t tmp ;

  {
  {
#line 128
  tmp = strlen(str);
#line 128
  out___0(display___0, str, tmp);
  }
#line 129
  return;
}
}
#line 131 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void outf___0(struct display *display___0 , char const   *msg  , ...) 
{ 
  char buf[128] ;
  va_list ap ;

  {
  {
#line 135
  __builtin_va_start(ap, msg);
#line 136
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)msg,
            ap);
#line 137
  __builtin_va_end(ap);
#line 138
  outs___0(display___0, (char const   *)(buf));
  }
#line 139
  return;
}
}
#line 141 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void force_moveto___0(struct display *display___0 , int row , int column ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 143
  tmp = column;
#line 143
  display___0->at_column = tmp;
#line 143
  tmp___0 = row;
#line 143
  display___0->at_row = tmp___0;
#line 143
  outf___0(display___0, "\033[%d;%df", tmp___0 + 1, tmp + 1);
  }
#line 145
  return;
}
}
#line 147 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void moveto___0(struct display *display___0 , int row , int column ) 
{ 


  {
#line 149
  if (row == display___0->at_row) {
#line 149
    if (column == display___0->at_column) {
#line 150
      return;
    }
  }
#line 151
  if (row == display___0->at_row + 1) {
#line 152
    if (column == display___0->at_column) {
      {
#line 153
      outs___0(display___0, "\n");
#line 154
      (display___0->at_row) ++;
      }
#line 155
      return;
    }
#line 157
    if (! column) {
      {
#line 158
      outs___0(display___0, "\n\r");
#line 159
      (display___0->at_row) ++;
#line 160
      display___0->at_column = 0;
      }
#line 161
      return;
    }
  }
  {
#line 164
  force_moveto___0(display___0, row, column);
  }
#line 165
  return;
}
}
#line 173 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static unsigned int linux_colormap___0(rgba_t rgba ) 
{ 
  unsigned int bgr1 ;

  {
#line 176
  if (rgba & 255U) {
#line 177
    return (9U);
  }
#line 178
  bgr1 = (unsigned int )(! (! (rgba >> 24)));
#line 179
  bgr1 |= (unsigned int )(! (! ((rgba >> 16) & 255U)) << 1);
#line 180
  bgr1 |= (unsigned int )(! (! ((rgba >> 8) & 255U)) << 2);
#line 181
  return (bgr1);
}
}
#line 184 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static unsigned int color_delta___0(rgba_t rgba1 , rgba_t rgba2 ) 
{ 
  unsigned int delta ;
  unsigned int j ;
  Byte_t c1 ;
  Byte_t c2 ;
  int cd ;
  int tmp ;

  {
#line 186
  delta = 1U;
#line 187
  if (rgba1 >> 8 == rgba2 >> 8) {
#line 188
    return (0U);
  }
#line 189
  j = 8U;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (j < 32U)) {
#line 189
      goto while_break;
    }
#line 190
    c1 = (Byte_t )(rgba1 >> j);
#line 190
    c2 = (Byte_t )(rgba2 >> j);
#line 191
    cd = (int )c1 - (int )c2;
#line 192
    if (cd < 0) {
#line 192
      tmp = - cd;
    } else {
#line 192
      tmp = cd;
    }
#line 192
    delta *= (unsigned int )(tmp + 1);
#line 189
    j += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (delta);
}
}
#line 197 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static rgba_t color_mean___0(rgba_t rgba1 , rgba_t rgba2 ) 
{ 
  rgba_t mean ;
  int j ;
  Byte_t c1 ;
  Byte_t c2 ;

  {
#line 199
  mean = (rgba_t )0;
#line 201
  j = 0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (j < 32)) {
#line 201
      goto while_break;
    }
#line 202
    c1 = (Byte_t )(rgba1 >> j);
#line 202
    c2 = (Byte_t )(rgba2 >> j);
#line 203
    mean |= (unsigned int )((((int )c1 + (int )c2) >> 1) << j);
#line 201
    j += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (mean);
}
}
#line 210
static unsigned int colormap___0(struct display *display___0 , rgba_t rgba ) ;
#line 210 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static rgba_t basic___0[8]  = 
#line 210
  {      (rgba_t )0,      2130706432U,      (rgba_t )8323072,      2139029504U, 
        (rgba_t )32512,      2130738944U,      (rgba_t )8355584,      2139062016U};
#line 216 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static rgba_t bright___0[8]  = 
#line 216
  {      (rgba_t )0,      4278190080U,      (rgba_t )16711680,      4294901760U, 
        (rgba_t )65280,      4278255360U,      (rgba_t )16776960,      4294967040U};
#line 208 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static unsigned int colormap___0(struct display *display___0 , rgba_t rgba ) 
{ 
  unsigned int idx ;
  unsigned int best ;
  unsigned int bestdelta ;
  unsigned int delta ;
  unsigned int tmp ;

  {
#line 223
  if (rgba & 255U) {
#line 224
    return (9U);
  }
#line 225
  idx = 0U;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (idx < 8U)) {
#line 225
      goto while_break;
    }
#line 226
    if (rgba == basic___0[idx]) {
#line 227
      return (idx);
    }
#line 225
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  idx = 0U;
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    if (! (idx < 8U)) {
#line 228
      goto while_break___0;
    }
#line 229
    if (rgba == bright___0[idx]) {
#line 230
      return (idx + 10U);
    }
#line 228
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  idx = 0U;
  {
#line 231
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 231
    if (! (idx < display___0->colors)) {
#line 231
      goto while_break___1;
    }
#line 232
    if (display___0->color[idx] == rgba) {
#line 233
      return (idx + 18U);
    }
#line 231
    idx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 234
  if (idx < 8U) {
#line 235
    tmp = display___0->colors;
#line 235
    (display___0->colors) ++;
#line 235
    best = tmp;
#line 235
    display___0->color[best] = rgba;
  } else {
#line 237
    best = 0U;
#line 238
    bestdelta = (unsigned int )(~ 0);
#line 239
    idx = 0U;
    {
#line 239
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 239
      if (! (idx < display___0->colors)) {
#line 239
        goto while_break___2;
      }
      {
#line 240
      delta = color_delta___0(display___0->color[idx], rgba);
      }
#line 241
      if (delta < bestdelta) {
#line 242
        best = idx;
#line 243
        bestdelta = delta;
      }
#line 239
      idx ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 246
    display___0->color[best] = color_mean___0(display___0->color[best], rgba);
    }
  }
  {
#line 248
  best += 18U;
#line 249
  outf___0(display___0, "\033]4;%d;rgb:%02x/%02x/%02x\a", best, rgba >> 24, (rgba >> 16) & 255U,
           (rgba >> 8) & 255U);
  }
#line 251
  return (best);
}
}
#line 254 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void set_color___0(struct display *display___0 , rgba_t rgba , unsigned int magic ) 
{ 
  unsigned int tmp ;
  unsigned int c ;
  unsigned int tmp___0 ;

  {
#line 256
  if (display___0->is_linux) {
    {
#line 257
    tmp = linux_colormap___0(rgba);
#line 257
    outf___0(display___0, "\033[%dm", tmp + magic);
    }
  } else {
    {
#line 259
    tmp___0 = colormap___0(display___0, rgba);
#line 259
    c = tmp___0;
    }
#line 260
    if (c >= 18U) {
      {
#line 261
      outf___0(display___0, "\033[%d;5;%dm", magic + 8U, c);
      }
    } else
#line 262
    if (c >= 10U) {
      {
#line 263
      outf___0(display___0, "\033[%dm", ((c - 10U) + magic) + 60U);
      }
    } else {
      {
#line 265
      outf___0(display___0, "\033[%dm", c + magic);
      }
    }
  }
#line 267
  return;
}
}
#line 269 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void background_color___0(struct display *display___0 , rgba_t rgba ) 
{ 


  {
#line 271
  if (rgba != display___0->bgrgba) {
    {
#line 272
    set_color___0(display___0, rgba, 40U);
#line 273
    display___0->bgrgba = rgba;
    }
  }
#line 275
  return;
}
}
#line 277 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void foreground_color___0(struct display *display___0 , rgba_t rgba ) 
{ 


  {
#line 279
  if (rgba != display___0->fgrgba) {
    {
#line 280
    set_color___0(display___0, rgba, 30U);
#line 281
    display___0->fgrgba = rgba;
    }
  }
#line 283
  return;
}
}
#line 313 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void color_fill___0(struct display *display___0 , int row , int rows___0 ,
                           int column , int columns___0 , rgba_t fgrgba , rgba_t bgrgba ) 
{ 
  int r ;
  int c ;
  struct cell *cell ;

  {
#line 318
  r = 0;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (r < rows___0)) {
#line 318
      goto while_break;
    }
#line 319
    cell = display___0->image + ((row + r) * display___0->columns + column);
#line 321
    c = 0;
    {
#line 321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 321
      if (! (c < columns___0)) {
#line 321
        goto while_break___0;
      }
#line 322
      cell->fgrgba = fgrgba;
#line 323
      cell->bgrgba = bgrgba;
#line 321
      c ++;
#line 321
      cell ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 318
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return;
}
}
#line 334 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void space_fill___0(struct display *display___0 , int row , int rows___0 ,
                           int column , int columns___0 ) 
{ 
  int r ;
  int c ;
  struct cell *cell ;

  {
#line 338
  r = 0;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (r < rows___0)) {
#line 338
      goto while_break;
    }
#line 339
    cell = display___0->image + ((row + r) * display___0->columns + column);
#line 341
    c = 0;
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (c < columns___0)) {
#line 341
        goto while_break___0;
      }
#line 342
      cell->unicode = (Unicode_t )' ';
#line 341
      c ++;
#line 341
      cell ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 338
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  if (display___0->is_apple) {
    {
#line 346
    color_fill___0(display___0, row, rows___0, column, columns___0, (rgba_t )255,
                   (rgba_t )(~ 0));
    }
  } else {
    {
#line 349
    color_fill___0(display___0, row, rows___0, column, columns___0, display___0->fgrgba,
                   display___0->bgrgba);
    }
  }
#line 351
  return;
}
}
#line 440 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static Boolean_t validate___0(struct display *display___0 , int row , int column ,
                              int *rows___0 , int *columns___0 , int *lines ) 
{ 
  int tmp ;

  {
#line 443
  if (row < 0) {
#line 445
    return ((Boolean_t )0);
  } else
#line 443
  if (row >= display___0->rows) {
#line 445
    return ((Boolean_t )0);
  } else
#line 443
  if (column < 0) {
#line 445
    return ((Boolean_t )0);
  } else
#line 443
  if (column >= display___0->columns) {
#line 445
    return ((Boolean_t )0);
  }
#line 446
  if (row + *rows___0 > display___0->rows) {
#line 447
    *rows___0 = display___0->rows - row;
  }
#line 448
  if (*lines > *rows___0) {
#line 449
    *lines = *rows___0;
  }
#line 450
  if (column + *columns___0 > display___0->columns) {
#line 451
    *columns___0 = display___0->columns - column;
  }
#line 452
  if (*lines > 0) {
#line 452
    if (*columns___0 > 0) {
#line 452
      tmp = 1;
    } else {
#line 452
      tmp = 0;
    }
  } else {
#line 452
    tmp = 0;
  }
#line 452
  return ((Boolean_t )tmp);
}
}
#line 497 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static struct cell *resize___0(struct display *display___0 , struct cell *old , int old_rows ,
                               int old_columns , int new_rows , int new_columns ) 
{ 
  int cells ;
  size_t bytes ;
  struct cell *new ;
  void *tmp ;
  int min_rows ;
  int tmp___0 ;
  int min_columns ;
  int tmp___1 ;
  int j ;
  int k ;
  struct cell *cell ;
  struct cell *tmp___2 ;
  struct cell *tmp___3 ;
  struct cell *cell___0 ;
  struct cell *tmp___4 ;

  {
  {
#line 501
  cells = new_rows * new_columns;
#line 502
  bytes = (unsigned long )cells * sizeof(*old);
#line 503
  tmp = reallocate((void const   *)((void *)0), bytes);
#line 503
  new = (struct cell *)tmp;
  }
#line 504
  if (new_rows < old_rows) {
#line 504
    tmp___0 = new_rows;
  } else {
#line 504
    tmp___0 = old_rows;
  }
#line 504
  min_rows = tmp___0;
#line 505
  if (new_columns < old_columns) {
#line 505
    tmp___1 = new_columns;
  } else {
#line 505
    tmp___1 = old_columns;
  }
#line 505
  min_columns = tmp___1;
#line 508
  if (! old) {
    {
#line 509
    memset((void *)new, 0, bytes);
#line 510
    j = 0;
    }
    {
#line 510
    while (1) {
      while_continue: /* CIL Label */ ;
#line 510
      if (! (j < cells)) {
#line 510
        goto while_break;
      }
#line 511
      (new + j)->unicode = (Unicode_t )' ';
#line 512
      (new + j)->bgrgba = display___0->bgrgba;
#line 513
      (new + j)->fgrgba = display___0->fgrgba;
#line 510
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 515
    return (new);
  }
#line 518
  j = 0;
  {
#line 518
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 518
    if (! (j < min_rows)) {
#line 518
      goto while_break___0;
    }
#line 519
    cell = new + j * new_columns;
#line 520
    k = 0;
    {
#line 520
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 520
      if (! (k < min_columns)) {
#line 520
        goto while_break___1;
      }
#line 521
      tmp___2 = cell;
#line 521
      cell ++;
#line 521
      *tmp___2 = *(old + (j * old_columns + k));
#line 520
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 522
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 522
      if (! (k < new_columns)) {
#line 522
        goto while_break___2;
      }
#line 523
      *cell = *(cell + -1);
#line 524
      tmp___3 = cell;
#line 524
      cell ++;
#line 524
      tmp___3->unicode = (Unicode_t )' ';
#line 522
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 518
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 527
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 527
    if (! (j < new_rows)) {
#line 527
      goto while_break___3;
    }
#line 528
    cell___0 = new + j * new_columns;
#line 529
    k = 0;
    {
#line 529
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 529
      if (! (k < new_columns)) {
#line 529
        goto while_break___4;
      }
#line 530
      *cell___0 = *(cell___0 - display___0->columns);
#line 531
      tmp___4 = cell___0;
#line 531
      cell___0 ++;
#line 531
      tmp___4->unicode = (Unicode_t )' ';
#line 529
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 527
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 535
  reallocate((void const   *)old, (size_t )0);
#line 535
  old = (struct cell *)((void *)0);
  }
#line 536
  return (new);
}
}
#line 539 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void set_geometry___0(struct display *display___0 , int rows___0 , int columns___0 ) 
{ 


  {
#line 541
  if (display___0->image) {
#line 541
    if (display___0->rows == rows___0) {
#line 541
      if (display___0->columns == columns___0) {
#line 544
        return;
      }
    }
  }
  {
#line 546
  display___0->image = resize___0(display___0, display___0->image, display___0->rows,
                                  display___0->columns, rows___0, columns___0);
#line 549
  display___0->rows = rows___0;
#line 550
  display___0->columns = columns___0;
#line 551
  display___0->size_changed = (Boolean_t )1;
#line 552
  display_erase(display___0, 0, rows___0, 0, columns___0);
#line 553
  display_cursor(display___0, display___0->cursor_row, display___0->cursor_column);
  }
#line 554
  if ((unsigned int )display___0->get_initial_cursor_position == 2U) {
#line 555
    display___0->get_initial_cursor_position = (enum cursor_position_knowledge )3;
  }
#line 556
  return;
}
}
#line 558 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void geometry___0(struct display *display___0 ) 
{ 
  int rows___0 ;
  int columns___0 ;
  struct winsize ws ;
  char const   *p ;
  unsigned int n ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 560
  rows___0 = 0;
#line 560
  columns___0 = 0;
#line 566
  tmp = ioctl(1, 21523UL, & ws);
  }
#line 566
  if (! tmp) {
#line 567
    rows___0 = (int )ws.ws_row;
#line 568
    columns___0 = (int )ws.ws_col;
  }
#line 571
  if (! rows___0) {
    {
#line 571
    tmp___0 = getenv("ROWS");
#line 571
    p = (char const   *)tmp___0;
    }
#line 571
    if (p) {
      {
#line 571
      tmp___1 = atoi(p);
#line 571
      n = (unsigned int )tmp___1;
      }
#line 571
      if (n) {
#line 571
        if (n <= 100U) {
#line 575
          rows___0 = (int )n;
        }
      }
    }
  }
#line 576
  if (! columns___0) {
    {
#line 576
    tmp___2 = getenv("COLUMNS");
#line 576
    p = (char const   *)tmp___2;
    }
#line 576
    if (p) {
      {
#line 576
      tmp___3 = atoi(p);
#line 576
      n = (unsigned int )tmp___3;
      }
#line 576
      if (n) {
#line 576
        if (n <= 200U) {
#line 580
          columns___0 = (int )n;
        }
      }
    }
  }
#line 581
  if (! rows___0) {
#line 581
    goto _L;
  } else
#line 581
  if (! columns___0) {
    _L: /* CIL Label */ 
#line 582
    if (! rows___0) {
#line 583
      rows___0 = 24;
    }
#line 584
    if (! columns___0) {
#line 585
      columns___0 = 80;
    }
    {
#line 586
    force_moveto___0(display___0, 666, 666);
#line 587
    outs___0(display___0, "\033[6n");
    }
  }
  {
#line 589
  set_geometry___0(display___0, rows___0, columns___0);
  }
#line 590
  return;
}
}
#line 627 "/home/june/collector/temp/aoeui-1.6~dfsg/display.c"
static void sigwinch___0(int signo , siginfo_t *info , void *data ) 
{ 
  struct display *display___0 ;

  {
#line 630
  display___0 = display_list___0;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! display___0) {
#line 630
      goto while_break;
    }
    {
#line 631
    geometry___0(display___0);
#line 630
    display___0 = display___0->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if (old_sigwinch___0) {
    {
#line 633
    (*old_sigwinch___0)(signo, info, data);
    }
  }
#line 634
  return;
}
}
#line 16 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
position_t find_space(struct view *view , position_t offset ) ;
#line 17
position_t find_space_prior(struct view *view , position_t offset ) ;
#line 22
position_t find_id_start(struct view *view , position_t offset ) ;
#line 67 "/home/june/collector/temp/aoeui-1.6~dfsg/util.h"
__inline static unsigned int char_columns(Unicode_t ch , unsigned int column , unsigned int tabstop ) 
{ 


  {
#line 69
  if (ch == 9U) {
#line 70
    return (tabstop - column % tabstop);
  }
#line 71
  if (ch < 32U) {
#line 72
    return (2U);
  } else
#line 71
  if (ch == 127U) {
#line 72
    return (2U);
  } else
#line 71
  if (ch - 1073741824U < 536870912U) {
#line 72
    return (2U);
  }
#line 73
  return (1U);
}
}
#line 6 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_line_start(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;
  position_t prev ;

  {
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 11
    ch = view_char_prior(view, offset, & prev);
    }
#line 11
    if (ch < 1U << 31) {
#line 11
      if (! (ch != 10U)) {
#line 11
        goto while_break;
      }
    } else {
#line 11
      goto while_break;
    }
#line 13
    offset = prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 14
  return (offset);
}
}
#line 17 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_line_end(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;
  position_t next ;

  {
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 22
    ch = view_char(view, offset, & next);
    }
#line 22
    if (ch < 1U << 31) {
#line 22
      if (! (ch != 10U)) {
#line 22
        goto while_break;
      }
    } else {
#line 22
      goto while_break;
    }
#line 24
    offset = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 25
  return (offset);
}
}
#line 28 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_paragraph_start(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;
  Unicode_t nch ;
  Unicode_t nnch ;
  position_t prev ;

  {
#line 30
  nch = 1U << 31;
#line 30
  nnch = 1U << 31;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 33
    ch = view_char_prior(view, offset, & prev);
    }
#line 33
    if (! (ch < 1U << 31)) {
#line 33
      goto while_break;
    }
#line 34
    if (ch == 10U) {
#line 34
      if (nch == 10U) {
#line 34
        if (nnch < 1U << 31) {
#line 35
          return (offset + 1UL);
        }
      }
    }
#line 36
    offset = prev;
#line 36
    nnch = nch;
#line 36
    nch = ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (offset);
}
}
#line 41 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_paragraph_end(struct view *view , position_t offset ) 
{ 
  Unicode_t ch ;
  Unicode_t pch ;
  Unicode_t ppch ;
  position_t next ;

  {
#line 43
  pch = 1U << 31;
#line 43
  ppch = 1U << 31;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 46
    ch = view_char(view, offset, & next);
    }
#line 46
    if (ch < 1U << 31) {
#line 46
      if (! (ch == 10U)) {
#line 46
        if (! (pch != 10U)) {
#line 46
          if (! (ppch != 10U)) {
#line 46
            goto while_break;
          }
        }
      }
    } else {
#line 46
      goto while_break;
    }
#line 48
    offset = next;
#line 48
    ppch = pch;
#line 48
    pch = ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return (offset);
}
}
#line 52 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static void updown_goal(struct view *view , position_t at ) 
{ 
  position_t tmp ;
  Unicode_t tmp___0 ;

  {
#line 54
  if (! (at == view->goal.cursor)) {
    {
#line 56
    tmp___0 = view_byte(view, at);
    }
#line 56
    if (tmp___0 == 10U) {
#line 57
      view->goal.row = (unsigned int )(~ 0);
    } else {
      {
#line 59
      view->goal.row = 0U;
#line 60
      tmp = find_line_start(view, at);
#line 60
      view->goal.column = find_column(& view->goal.row, view, tmp, at, 0U);
      }
    }
  }
#line 64
  return;
}
}
#line 66 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static position_t same_column(struct view *view , position_t at , position_t fail ) 
{ 
  unsigned int r ;
  unsigned int c ;
  unsigned int tabstop ;
  unsigned int columns___0 ;
  unsigned int tmp ;
  position_t next ;
  Unicode_t ch ;
  unsigned int tmp___0 ;
  position_t tmp___1 ;

  {
  {
#line 68
  r = 0U;
#line 68
  c = 0U;
#line 69
  tabstop = (view->text)->tabstop;
#line 70
  tmp = window_columns(view->window);
#line 70
  columns___0 = tmp;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (r < view->goal.row)) {
#line 73
      if (! (c < view->goal.column)) {
#line 73
        goto while_break;
      }
    }
    {
#line 75
    ch = view_char(view, at, & next);
    }
#line 76
    if (! (ch < 1U << 31)) {
#line 77
      at = fail;
#line 78
      goto while_break;
    } else
#line 76
    if (ch == 10U) {
#line 77
      at = fail;
#line 78
      goto while_break;
    }
    {
#line 80
    tmp___0 = char_columns(ch, c, tabstop);
#line 80
    c += tmp___0;
    }
#line 80
    if (c > view->goal.column) {
#line 80
      if (r == view->goal.row) {
#line 82
        goto while_break;
      }
    }
#line 83
    if (c > columns___0) {
      {
#line 84
      r ++;
#line 84
      c = char_columns(ch, 0U, tabstop);
      }
    }
#line 73
    at = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  tmp___1 = at;
#line 86
  view->goal.cursor = tmp___1;
#line 86
  return (tmp___1);
}
}
#line 89 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_line_up(struct view *view , position_t at ) 
{ 
  position_t linestart ;
  position_t tmp ;
  position_t tmp___0 ;
  position_t tmp___1 ;

  {
  {
#line 91
  tmp = find_line_start(view, at);
#line 91
  linestart = tmp;
#line 93
  updown_goal(view, at);
  }
#line 94
  if (! linestart) {
#line 95
    return ((position_t )0);
  }
  {
#line 96
  tmp___0 = find_line_start(view, linestart - 1UL);
#line 96
  tmp___1 = same_column(view, tmp___0, linestart - 1UL);
  }
#line 96
  return (tmp___1);
}
}
#line 100 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_line_down(struct view *view , position_t at ) 
{ 
  position_t nextstart ;
  position_t tmp ;
  position_t tmp___0 ;
  position_t tmp___1 ;

  {
  {
#line 102
  tmp = find_line_end(view, at);
#line 102
  nextstart = tmp + 1UL;
#line 104
  updown_goal(view, at);
  }
#line 105
  if (nextstart >= view->bytes) {
#line 106
    return (view->bytes);
  }
  {
#line 107
  tmp___0 = find_line_end(view, nextstart);
#line 107
  tmp___1 = same_column(view, nextstart, tmp___0);
  }
#line 107
  return (tmp___1);
}
}
#line 112 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static position_t find_not(struct view *view , position_t offset , Unicode_t (*stepper)(struct view * ,
                                                                                        position_t  ,
                                                                                        position_t * ) ,
                           Boolean_t (*test)(Unicode_t  ) ) 
{ 
  position_t next ;
  Unicode_t tmp ;
  Boolean_t tmp___0 ;

  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    tmp = (*stepper)(view, offset, & next);
#line 118
    tmp___0 = (*test)(tmp);
    }
#line 118
    if (! tmp___0) {
#line 118
      goto while_break;
    }
#line 119
    offset = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (offset);
}
}
#line 123 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static Boolean_t space_test(Unicode_t ch ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 125
  if (ch < 65536U) {
    {
#line 125
    tmp = __ctype_b_loc();
    }
#line 125
    if ((int const   )*(*tmp + (int )ch) & 8192) {
#line 125
      tmp___0 = 1;
    } else {
#line 125
      tmp___0 = 0;
    }
  } else {
#line 125
    tmp___0 = 0;
  }
#line 125
  return ((Boolean_t )tmp___0);
}
}
#line 128 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static Boolean_t nonspace_test(Unicode_t ch ) 
{ 
  Boolean_t tmp ;
  int tmp___0 ;

  {
#line 130
  if (ch < 1U << 31) {
    {
#line 130
    tmp = space_test(ch);
    }
#line 130
    if (tmp) {
#line 130
      tmp___0 = 0;
    } else {
#line 130
      tmp___0 = 1;
    }
  } else {
#line 130
    tmp___0 = 0;
  }
#line 130
  return ((Boolean_t )tmp___0);
}
}
#line 133 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_space(struct view *view , position_t offset ) 
{ 
  position_t tmp ;

  {
  {
#line 135
  tmp = find_not(view, offset, & view_char, & nonspace_test);
  }
#line 135
  return (tmp);
}
}
#line 138 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_space_prior(struct view *view , position_t offset ) 
{ 
  position_t tmp ;

  {
  {
#line 140
  tmp = find_not(view, offset, & view_char_prior, & nonspace_test);
  }
#line 140
  return (tmp);
}
}
#line 143 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_nonspace(struct view *view , position_t offset ) 
{ 
  position_t tmp ;

  {
  {
#line 145
  tmp = find_not(view, offset, & view_char, & space_test);
  }
#line 145
  return (tmp);
}
}
#line 148 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_nonspace_prior(struct view *view , position_t offset ) 
{ 
  position_t tmp ;

  {
  {
#line 150
  tmp = find_not(view, offset, & view_char_prior, & space_test);
  }
#line 150
  return (tmp);
}
}
#line 154 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static position_t find_contiguous(struct view *view , position_t offset , Unicode_t (*stepper)(struct view * ,
                                                                                               position_t  ,
                                                                                               position_t * ) ,
                                  Boolean_t (*test)(Unicode_t  , struct view * , position_t * ,
                                                    Unicode_t (*)(struct view * ,
                                                                  position_t  , position_t * ) ) ) 
{ 
  Unicode_t ch ;
  position_t next ;
  Boolean_t in_region ;
  Boolean_t tmp ;

  {
#line 161
  in_region = (Boolean_t )0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 163
    ch = (*stepper)(view, offset, & next);
    }
#line 163
    if (! (ch < 1U << 31)) {
#line 163
      goto while_break;
    }
    {
#line 164
    tmp = (*test)(ch, view, & next, stepper);
    }
#line 164
    if (tmp) {
#line 165
      in_region = (Boolean_t )1;
    } else
#line 166
    if (in_region) {
#line 167
      goto while_break;
    }
#line 163
    offset = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return (offset);
}
}
#line 171 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static Boolean_t word_test(Unicode_t ch , struct view *view , position_t *next , Unicode_t (*stepper)(struct view * ,
                                                                                                      position_t  ,
                                                                                                      position_t * ) ) 
{ 
  Boolean_t tmp ;

  {
  {
#line 174
  tmp = is_wordch(ch);
  }
#line 174
  return (tmp);
}
}
#line 177 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_word_start(struct view *view , position_t offset ) 
{ 
  position_t tmp ;

  {
  {
#line 179
  tmp = find_contiguous(view, offset, & view_char_prior, & word_test);
  }
#line 179
  return (tmp);
}
}
#line 182 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_word_end(struct view *view , position_t offset ) 
{ 
  position_t tmp ;

  {
  {
#line 184
  tmp = find_contiguous(view, offset, & view_char, & word_test);
  }
#line 184
  return (tmp);
}
}
#line 187 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static Boolean_t id_test(Unicode_t ch , struct view *view , position_t *next , Unicode_t (*stepper)(struct view * ,
                                                                                                    position_t  ,
                                                                                                    position_t * ) ) 
{ 
  Boolean_t tmp ;
  Unicode_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 190
  tmp = is_idch(ch);
  }
#line 190
  if (tmp) {
#line 190
    tmp___1 = 1;
  } else
#line 190
  if (ch == 58U) {
    {
#line 190
    tmp___0 = (*stepper)(view, *next, next);
    }
#line 190
    if (tmp___0 == 58U) {
#line 190
      tmp___1 = 1;
    } else {
#line 190
      tmp___1 = 0;
    }
  } else {
#line 190
    tmp___1 = 0;
  }
#line 190
  return ((Boolean_t )tmp___1);
}
}
#line 194 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_id_start(struct view *view , position_t offset ) 
{ 
  position_t tmp ;

  {
  {
#line 196
  tmp = find_contiguous(view, offset, & view_char_prior, & id_test);
  }
#line 196
  return (tmp);
}
}
#line 199 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_id_end(struct view *view , position_t offset ) 
{ 
  position_t tmp ;

  {
  {
#line 201
  tmp = find_contiguous(view, offset, & view_char, & id_test);
  }
#line 201
  return (tmp);
}
}
#line 204 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_sentence_start(struct view *view , position_t offset ) 
{ 
  position_t prev ;
  Unicode_t ch ;
  Unicode_t next ;
  Unicode_t tmp ;

  {
  {
#line 207
  tmp = view_char_prior(view, offset, & prev);
#line 207
  next = tmp;
  }
#line 209
  if (! (next < 1U << 31)) {
#line 210
    return (offset);
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 211
    offset = prev;
#line 211
    ch = view_char_prior(view, offset, & prev);
    }
#line 211
    if (ch < 1U << 31) {
#line 211
      if (ch != 46U) {
#line 211
        if (ch != 44U) {
#line 211
          if (ch != 59U) {
#line 211
            if (ch != 58U) {
#line 211
              if (ch != 33U) {
#line 211
                if (ch != 63U) {
#line 211
                  if (ch != 40U) {
#line 211
                    if (ch != 91U) {
#line 211
                      if (ch != 123U) {
#line 211
                        if (! (ch != 10U)) {
#line 211
                          if (! (ch != next)) {
#line 211
                            goto while_break;
                          }
                        }
                      } else {
#line 211
                        goto while_break;
                      }
                    } else {
#line 211
                      goto while_break;
                    }
                  } else {
#line 211
                    goto while_break;
                  }
                } else {
#line 211
                  goto while_break;
                }
              } else {
#line 211
                goto while_break;
              }
            } else {
#line 211
              goto while_break;
            }
          } else {
#line 211
            goto while_break;
          }
        } else {
#line 211
          goto while_break;
        }
      } else {
#line 211
        goto while_break;
      }
    } else {
#line 211
      goto while_break;
    }
#line 216
    next = ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return (offset);
}
}
#line 220 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_sentence_end(struct view *view , position_t offset ) 
{ 
  position_t next ;
  Unicode_t ch ;
  Unicode_t last ;
  Unicode_t tmp ;

  {
  {
#line 223
  tmp = view_char(view, offset, & next);
#line 223
  last = tmp;
  }
#line 225
  if (! (last < 1U << 31)) {
#line 226
    return (offset);
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 227
    offset = next;
#line 227
    ch = view_char(view, offset, & next);
    }
#line 227
    if (ch < 1U << 31) {
#line 227
      if (ch != 46U) {
#line 227
        if (ch != 44U) {
#line 227
          if (ch != 59U) {
#line 227
            if (ch != 58U) {
#line 227
              if (ch != 33U) {
#line 227
                if (ch != 63U) {
#line 227
                  if (ch != 41U) {
#line 227
                    if (ch != 93U) {
#line 227
                      if (ch != 125U) {
#line 227
                        if (! (ch != 10U)) {
#line 227
                          if (! (ch != last)) {
#line 227
                            goto while_break;
                          }
                        }
                      } else {
#line 227
                        goto while_break;
                      }
                    } else {
#line 227
                      goto while_break;
                    }
                  } else {
#line 227
                    goto while_break;
                  }
                } else {
#line 227
                  goto while_break;
                }
              } else {
#line 227
                goto while_break;
              }
            } else {
#line 227
              goto while_break;
            }
          } else {
#line 227
            goto while_break;
          }
        } else {
#line 227
          goto while_break;
        }
      } else {
#line 227
        goto while_break;
      }
    } else {
#line 227
      goto while_break;
    }
#line 232
    last = ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (offset);
}
}
#line 238 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static signed char peer[256]  ;
#line 238 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
static signed char updown[256]  ;
#line 236 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
sposition_t find_corresponding_bracket(struct view *view , position_t offset ) 
{ 
  char const   *p ;
  position_t next ;
  Unicode_t ch ;
  Unicode_t tmp ;
  Byte_t stack[32] ;
  int stackptr ;
  int dir ;
  int L ;
  int R ;
  position_t back ;
  position_t ahead ;
  position_t next___0 ;
  int tmp___0 ;
  int tmp___1 ;
  position_t tmp___2 ;
  int tmp___3 ;
  Unicode_t (*tmp___4)(struct view * , position_t  , size_t * ) ;
  int tmp___5 ;

  {
  {
#line 239
  p = (view->text)->brackets;
#line 241
  tmp = view_char(view, offset, & next);
#line 241
  ch = tmp;
#line 243
  stackptr = 0;
  }
#line 245
  if (! p) {
#line 246
    return ((sposition_t )-1);
  }
  {
#line 247
  memset((void *)(peer), 0, sizeof(peer));
#line 248
  memset((void *)(updown), 0, sizeof(updown));
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! *p) {
#line 249
      goto while_break;
    }
#line 250
    L = (int )((unsigned char )*(p + 0));
#line 250
    R = (int )((unsigned char )*(p + 1));
#line 251
    peer[L] = (signed char )R;
#line 252
    peer[R] = (signed char )L;
#line 253
    updown[L] = (signed char)1;
#line 254
    updown[R] = (signed char)-1;
#line 249
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  if ((unsigned long )ch >= sizeof(updown)) {
#line 257
    goto _L;
  } else {
#line 257
    dir = (int )updown[ch];
#line 257
    if (! dir) {
      _L: /* CIL Label */ 
#line 258
      back = offset;
#line 258
      next___0 = offset;
      {
#line 259
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 259
        ch = view_char_prior(view, back, & back);
        }
#line 259
        if (! (ch < 1U << 31)) {
#line 259
          goto while_break___0;
        }
#line 260
        if ((unsigned long )ch >= sizeof(updown)) {
#line 261
          goto while_continue___0;
        }
#line 262
        if ((int )updown[ch] < 0) {
#line 263
          if ((unsigned long )stackptr == sizeof(stack)) {
#line 264
            goto while_break___0;
          } else {
#line 266
            tmp___0 = stackptr;
#line 266
            stackptr ++;
#line 266
            stack[tmp___0] = (Byte_t )ch;
          }
        } else
#line 267
        if ((int )updown[ch] > 0) {
#line 267
          if (! stackptr) {
#line 269
            goto while_break___0;
          } else {
#line 267
            stackptr --;
#line 267
            if (ch != (Unicode_t )peer[stack[stackptr]]) {
#line 269
              goto while_break___0;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 271
      if (! (ch < 1U << 31)) {
#line 272
        back = offset + 1UL;
      }
      {
#line 273
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 273
        ahead = next___0;
#line 273
        ch = view_char(view, ahead, & next___0);
        }
#line 273
        if (! (ch < 1U << 31)) {
#line 273
          goto while_break___1;
        }
#line 274
        if ((unsigned long )ch >= sizeof(updown)) {
#line 275
          goto while_continue___1;
        }
#line 276
        if ((int )updown[ch] > 0) {
#line 277
          if ((unsigned long )stackptr == sizeof(stack)) {
#line 278
            goto while_break___1;
          } else {
#line 280
            tmp___1 = stackptr;
#line 280
            stackptr ++;
#line 280
            stack[tmp___1] = (Byte_t )ch;
          }
        } else
#line 281
        if ((int )updown[ch] < 0) {
#line 281
          if (! stackptr) {
#line 283
            goto while_break___1;
          } else {
#line 281
            stackptr --;
#line 281
            if (ch != (Unicode_t )peer[stack[stackptr]]) {
#line 283
              goto while_break___1;
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 285
      if (back < offset) {
#line 285
        if (offset - back <= ahead - offset) {
#line 287
          return ((sposition_t )back);
        } else
#line 285
        if (! (ch < 1U << 31)) {
#line 287
          return ((sposition_t )back);
        }
      }
#line 288
      if (ch < 1U << 31) {
#line 288
        tmp___2 = ahead;
      } else {
#line 288
        tmp___2 = (position_t )-1;
      }
#line 288
      return ((sposition_t )tmp___2);
    }
  }
#line 291
  tmp___3 = stackptr;
#line 291
  stackptr ++;
#line 291
  stack[tmp___3] = (Byte_t )ch;
#line 292
  if (dir > 0) {
#line 293
    offset = next;
  }
  {
#line 294
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 294
    if (! stackptr) {
#line 294
      goto while_break___2;
    }
#line 295
    if (dir > 0) {
#line 295
      tmp___4 = & view_char;
    } else {
#line 295
      tmp___4 = & view_char_prior;
    }
    {
#line 295
    ch = (*tmp___4)(view, offset, & next);
    }
#line 297
    if ((unsigned long )ch >= sizeof(updown)) {
#line 298
      return ((sposition_t )-1);
    }
#line 299
    if ((int )updown[ch] == dir) {
#line 300
      if ((unsigned long )stackptr == sizeof(stack)) {
#line 301
        return ((sposition_t )-1);
      }
#line 302
      tmp___5 = stackptr;
#line 302
      stackptr ++;
#line 302
      stack[tmp___5] = (Byte_t )ch;
    } else
#line 303
    if ((int )updown[ch] == - dir) {
#line 304
      stackptr --;
#line 304
      if (ch != (Unicode_t )peer[stack[stackptr]]) {
#line 306
        goto while_break___2;
      } else
#line 304
      if (! stackptr) {
#line 304
        if (dir > 0) {
#line 306
          goto while_break___2;
        }
      }
    }
#line 307
    offset = next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 310
  return ((sposition_t )offset);
}
}
#line 313 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_line_number(struct view *view , unsigned int line ) 
{ 
  position_t offset ;
  position_t next ;
  position_t next2 ;
  sposition_t fold_start ;
  sposition_t fold_end ;
  unsigned int tmp ;
  Unicode_t ch ;
  Unicode_t tmp___0 ;
  size_t fbytes ;
  Unicode_t tmp___1 ;

  {
#line 316
  fold_start = (sposition_t )-1;
#line 316
  fold_end = (sposition_t )-1;
#line 318
  tmp = line;
#line 318
  line --;
#line 318
  if (tmp <= 1U) {
#line 319
    return ((position_t )0);
  }
#line 320
  offset = (position_t )0;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! (offset < view->bytes)) {
#line 320
      goto while_break;
    }
    {
#line 321
    tmp___0 = view_unicode(view, offset, & next);
#line 321
    ch = tmp___0;
    }
#line 322
    if (offset >= (position_t )fold_end) {
#line 323
      fold_end = (sposition_t )-1;
    }
#line 324
    if (ch == 10U) {
#line 324
      line --;
#line 324
      if (! line) {
#line 325
        goto while_break;
      }
    }
#line 326
    if (fold_end < 0L) {
#line 326
      if (ch - 1073741824U < 536870912U) {
        {
#line 327
        fbytes = (size_t )(ch & 536870911U);
#line 328
        tmp___1 = view_unicode(view, next + fbytes, & next2);
        }
#line 328
        if ((size_t )tmp___1 == 1610612736UL + fbytes) {
#line 330
          fold_start = (sposition_t )offset;
#line 331
          fold_end = (sposition_t )next2;
        }
      }
    }
#line 320
    offset = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  if (fold_end >= 0L) {
#line 336
    return ((position_t )fold_start);
  }
#line 337
  return (offset + 1UL);
}
}
#line 340 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
unsigned int current_line_number(struct view *view , position_t offset ) 
{ 
  int line ;
  position_t at ;
  unsigned int last ;

  {
#line 342
  line = 1;
#line 344
  last = (unsigned int )'\n';
#line 346
  if (offset >= view->bytes) {
#line 347
    offset = view->bytes;
  }
#line 348
  at = (position_t )0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (at < offset)) {
#line 348
      goto while_break;
    }
    {
#line 349
    last = view_byte(view, at);
    }
#line 350
    if (last == 10U) {
#line 351
      line ++;
    }
#line 348
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  if (at == view->bytes) {
#line 353
    if (last == 10U) {
#line 354
      line --;
    }
  }
#line 355
  return ((unsigned int )line);
}
}
#line 358 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
position_t find_row_bytes(struct view *view , position_t offset0 , unsigned int column ,
                          unsigned int columns___0 ) 
{ 
  position_t offset ;
  position_t next ;
  unsigned int tabstop ;
  Unicode_t ch ;
  int charcols ;
  unsigned int tmp ;
  position_t tmp___0 ;
  Unicode_t tmp___1 ;

  {
#line 361
  offset = offset0;
#line 362
  tabstop = (view->text)->tabstop;
#line 363
  ch = (Unicode_t )0;
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! (column < columns___0)) {
#line 366
      goto while_break;
    }
    {
#line 367
    ch = view_char(view, offset, & next);
    }
#line 367
    if (! (ch < 1U << 31)) {
#line 368
      goto while_break;
    }
#line 369
    if (ch == 10U) {
#line 370
      offset = next;
#line 371
      goto while_break;
    }
    {
#line 373
    tmp = char_columns(ch, column, tabstop);
#line 373
    charcols = (int )tmp;
    }
#line 374
    if (column + (unsigned int )charcols > columns___0) {
#line 375
      goto while_break;
    }
#line 376
    column += (unsigned int )charcols;
#line 377
    offset = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  if (column == columns___0) {
    {
#line 380
    tmp___0 = locus_get(view, (locus_t )0);
    }
#line 380
    if (offset != tmp___0) {
      {
#line 380
      tmp___1 = view_char(view, offset, (size_t *)((void *)0));
      }
#line 380
      if (tmp___1 == 10U) {
#line 383
        offset ++;
      }
    }
  }
#line 384
  return (offset - offset0);
}
}
#line 387 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
unsigned int find_column(unsigned int *row , struct view *view , position_t at , position_t offset ,
                         unsigned int column ) 
{ 
  unsigned int tabstop ;
  unsigned int columns___0 ;
  unsigned int tmp ;
  position_t next ;
  Unicode_t ch ;
  Unicode_t tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 390
  tabstop = (view->text)->tabstop;
#line 391
  tmp = window_columns(view->window);
#line 391
  columns___0 = tmp;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (at < offset)) {
#line 394
      goto while_break;
    }
    {
#line 395
    tmp___0 = view_char(view, at, & next);
#line 395
    ch = tmp___0;
    }
#line 396
    if (! (ch < 1U << 31)) {
#line 397
      goto while_break;
    }
#line 398
    if (ch == 10U) {
#line 399
      if (row) {
#line 400
        (*row) ++;
      }
#line 401
      column = 0U;
    } else {
      {
#line 403
      tmp___1 = char_columns(ch, column, tabstop);
#line 403
      column += tmp___1;
      }
#line 404
      if (column >= columns___0) {
#line 405
        if (row) {
#line 406
          (*row) ++;
        }
        {
#line 407
        column = char_columns(ch, 0U, tabstop);
        }
      }
    }
#line 394
    at = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return (column);
}
}
#line 414 "/home/june/collector/temp/aoeui-1.6~dfsg/find.c"
sposition_t find_string(struct view *view , char const   *string , position_t offset ) 
{ 
  Byte_t const   *ustring ;
  unsigned int first ;
  unsigned int j ;
  Unicode_t ch ;
  Unicode_t tmp ;

  {
#line 417
  ustring = (Byte_t const   *)string;
#line 418
  first = (unsigned int )*ustring;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 421
    ch = view_byte(view, offset);
    }
#line 421
    if (! (ch < 1U << 31)) {
#line 421
      goto while_break;
    }
#line 422
    if (ch != first) {
#line 423
      goto __Cont;
    }
#line 424
    j = 1U;
    {
#line 424
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 424
      ch = (Unicode_t )*(ustring + j);
#line 424
      if (! ch) {
#line 424
        goto while_break___0;
      }
      {
#line 425
      tmp = view_byte(view, offset + (position_t )j);
      }
#line 425
      if (ch != tmp) {
#line 426
        goto while_break___0;
      }
#line 424
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 427
    if (! ch) {
#line 428
      return ((sposition_t )offset);
    }
    __Cont: /* CIL Label */ 
#line 421
    offset ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  return ((sposition_t )-1);
}
}
#line 133 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mremap)(void *__addr ,
                                                                               size_t __old_len ,
                                                                               size_t __new_len ,
                                                                               int __flags 
                                                                               , ...) ;
#line 36 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
struct buffer *buffer_create(char *path ) 
{ 
  struct buffer *buffer ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 38
  tmp = allocate0(sizeof(*buffer));
#line 38
  buffer = (struct buffer *)tmp;
  }
#line 39
  if (path) {
#line 39
    if (*path) {
      {
#line 40
      tmp___0 = strlen((char const   *)path);
#line 40
      tmp___1 = reallocate((void const   *)((void *)0), tmp___0 + 2UL);
#line 40
      buffer->path = (char *)tmp___1;
#line 41
      sprintf((char */* __restrict  */)buffer->path, (char const   */* __restrict  */)"%s#",
              path);
#line 42
      tmp___2 = __errno_location();
#line 42
      *tmp___2 = 0;
#line 43
      buffer->fd = open((char const   *)buffer->path, 578, 384);
      }
#line 45
      if (buffer->fd < 0) {
        {
#line 46
        message("could not create temporary file %s", buffer->path);
        }
      }
    } else {
#line 49
      buffer->fd = -1;
    }
  } else {
#line 49
    buffer->fd = -1;
  }
#line 50
  return (buffer);
}
}
#line 53 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
void buffer_destroy(struct buffer *buffer ) 
{ 


  {
#line 55
  if (buffer) {
    {
#line 56
    munmap((void *)buffer->data, buffer->mapped);
    }
#line 57
    if (buffer->fd >= 0) {
      {
#line 58
      close(buffer->fd);
#line 59
      unlink((char const   *)buffer->path);
      }
    }
    {
#line 61
    reallocate((void const   *)buffer->path, (size_t )0);
#line 61
    buffer->path = (char *)((void *)0);
#line 62
    reallocate((void const   *)buffer, (size_t )0);
#line 62
    buffer = (struct buffer *)((void *)0);
    }
  }
#line 64
  return;
}
}
#line 66 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
static void place_gap(struct buffer *buffer , position_t offset ) 
{ 
  size_t gapsize ;
  size_t tmp ;

  {
  {
#line 68
  tmp = buffer_gap_bytes(buffer);
#line 68
  gapsize = tmp;
  }
#line 70
  if (offset > buffer->payload) {
#line 71
    offset = buffer->payload;
  }
#line 72
  if (offset <= buffer->gap) {
    {
#line 73
    memmove((void *)((buffer->data + offset) + gapsize), (void const   *)(buffer->data + offset),
            buffer->gap - offset);
    }
  } else {
    {
#line 76
    memmove((void *)(buffer->data + buffer->gap), (void const   *)((buffer->data + buffer->gap) + gapsize),
            offset - buffer->gap);
    }
  }
#line 79
  buffer->gap = offset;
#line 80
  if (buffer->fd >= 0) {
#line 80
    if (gapsize) {
      {
#line 81
      memset((void *)(buffer->data + buffer->gap), ' ', gapsize);
      }
    }
  }
#line 82
  return;
}
}
#line 92 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
static size_t pagesize  ;
#line 84 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
static void resize___1(struct buffer *buffer , size_t payload_bytes ) 
{ 
  void *p ;
  char *old ;
  fd_t fd ;
  int mapflags ;
  size_t map_bytes ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 87
  old = buffer->data;
#line 89
  mapflags = 0;
#line 90
  map_bytes = payload_bytes;
#line 93
  if (! pagesize) {
    {
#line 94
    tmp = getpagesize();
#line 94
    pagesize = (size_t )tmp;
    }
  }
#line 97
  map_bytes += pagesize - 1UL;
#line 98
  map_bytes /= pagesize;
#line 99
  map_bytes *= 11UL;
#line 100
  map_bytes /= 10UL;
#line 101
  map_bytes *= pagesize;
#line 103
  if (map_bytes < buffer->mapped) {
    {
#line 104
    munmap((void *)(old + map_bytes), buffer->mapped - map_bytes);
    }
  }
#line 105
  if (buffer->fd >= 0) {
#line 105
    if (map_bytes != buffer->mapped) {
      {
#line 106
      tmp___0 = __errno_location();
#line 106
      *tmp___0 = 0;
#line 107
      tmp___1 = ftruncate(buffer->fd, (__off_t )map_bytes);
      }
#line 107
      if (tmp___1) {
        {
#line 108
        die("could not adjust %s from %lu to %lu bytes", buffer->path, (long )buffer->mapped,
            (long )map_bytes);
        }
      }
    }
  }
#line 112
  if (map_bytes <= buffer->mapped) {
#line 113
    buffer->mapped = map_bytes;
#line 114
    return;
  }
#line 117
  if (old) {
    {
#line 119
    tmp___2 = __errno_location();
#line 119
    *tmp___2 = 0;
#line 120
    p = mremap((void *)old, buffer->mapped, map_bytes, 1);
    }
#line 121
    if ((unsigned long )p != (unsigned long )((void *)-1)) {
#line 122
      goto done;
    }
  }
#line 128
  fd = buffer->fd;
#line 128
  if (fd >= 0) {
#line 129
    mapflags |= 1;
#line 130
    if (old) {
      {
#line 131
      munmap((void *)old, buffer->mapped);
#line 132
      old = (char *)((void *)0);
      }
    }
  } else {
#line 136
    mapflags |= 32;
#line 150
    mapflags |= 2;
  }
  {
#line 153
  tmp___3 = __errno_location();
#line 153
  *tmp___3 = 0;
#line 154
  p = mmap((void *)0, map_bytes, 3, mapflags, fd, (__off_t )0);
  }
#line 155
  if ((unsigned long )p == (unsigned long )((void *)-1)) {
    {
#line 156
    die("mmap(%lu bytes, fd %d) failed", (long )map_bytes, fd);
    }
  }
#line 158
  if (old) {
    {
#line 159
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)old, buffer->payload);
#line 160
    munmap((void *)old, buffer->mapped);
    }
  }
  done: 
#line 166
  buffer->data = (char *)p;
#line 167
  buffer->mapped = map_bytes;
#line 168
  return;
}
}
#line 170 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
size_t buffer_raw(struct buffer *buffer , char **out___1 , position_t offset , size_t bytes ) 
{ 
  size_t tmp ;

  {
#line 173
  if (! buffer) {
#line 174
    *out___1 = (char *)((void *)0);
#line 175
    return ((size_t )0);
  }
#line 177
  if (offset >= buffer->payload) {
#line 178
    offset = buffer->payload;
  }
#line 179
  if (offset + bytes > buffer->payload) {
#line 180
    bytes = buffer->payload - offset;
  }
#line 181
  if (! bytes) {
#line 182
    *out___1 = (char *)((void *)0);
#line 183
    return ((size_t )0);
  }
#line 186
  if (offset < buffer->gap) {
#line 186
    if (offset + bytes > buffer->gap) {
      {
#line 187
      place_gap(buffer, offset + bytes);
      }
    }
  }
#line 188
  *out___1 = buffer->data + offset;
#line 189
  if (offset >= buffer->gap) {
    {
#line 190
    tmp = buffer_gap_bytes(buffer);
#line 190
    *out___1 += tmp;
    }
  }
#line 191
  return (bytes);
}
}
#line 194 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
size_t buffer_get(struct buffer *buffer , void *out___1 , position_t offset , size_t bytes ) 
{ 
  size_t left ;
  unsigned int before ;
  size_t tmp ;

  {
#line 199
  if (! buffer) {
#line 200
    return ((size_t )0);
  }
#line 201
  if (offset >= buffer->payload) {
#line 202
    offset = buffer->payload;
  }
#line 203
  if (offset + bytes > buffer->payload) {
#line 204
    bytes = buffer->payload - offset;
  }
#line 205
  if (! bytes) {
#line 206
    return ((size_t )0);
  }
#line 207
  left = bytes;
#line 208
  if (offset < buffer->gap) {
#line 209
    before = (unsigned int )(buffer->gap - offset);
#line 210
    if ((size_t )before > bytes) {
#line 211
      before = (unsigned int )bytes;
    }
    {
#line 212
    memcpy((void */* __restrict  */)out___1, (void const   */* __restrict  */)(buffer->data + offset),
           (size_t )before);
#line 213
    out___1 = (void *)((char *)out___1 + before);
#line 214
    offset += (position_t )before;
#line 215
    left -= (size_t )before;
    }
#line 216
    if (! left) {
#line 217
      return (bytes);
    }
  }
  {
#line 219
  tmp = buffer_gap_bytes(buffer);
#line 219
  offset += tmp;
#line 220
  memcpy((void */* __restrict  */)out___1, (void const   */* __restrict  */)(buffer->data + offset),
         left);
  }
#line 221
  return (bytes);
}
}
#line 224 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
size_t buffer_delete(struct buffer *buffer , position_t offset , size_t bytes ) 
{ 


  {
#line 227
  if (! buffer) {
#line 228
    return ((size_t )0);
  }
#line 229
  if (offset > buffer->payload) {
#line 230
    offset = buffer->payload;
  }
#line 231
  if (offset + bytes > buffer->payload) {
#line 232
    bytes = buffer->payload - offset;
  }
  {
#line 233
  place_gap(buffer, offset);
#line 234
  buffer->payload -= bytes;
  }
#line 235
  return (bytes);
}
}
#line 238 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
size_t buffer_insert(struct buffer *buffer , void const   *in , position_t offset ,
                     size_t bytes ) 
{ 
  size_t tmp ;

  {
#line 241
  if (! buffer) {
#line 242
    return ((size_t )0);
  }
#line 243
  if (offset > buffer->payload) {
#line 244
    offset = buffer->payload;
  }
  {
#line 245
  tmp = buffer_gap_bytes(buffer);
  }
#line 245
  if (bytes > tmp) {
    {
#line 246
    place_gap(buffer, buffer->payload);
#line 247
    resize___1(buffer, buffer->payload + bytes);
    }
  }
  {
#line 249
  place_gap(buffer, offset);
  }
#line 250
  if (in) {
    {
#line 251
    memcpy((void */* __restrict  */)(buffer->data + offset), (void const   */* __restrict  */)in,
           bytes);
    }
  } else {
    {
#line 253
    memset((void *)(buffer->data + offset), 0, bytes);
    }
  }
#line 254
  buffer->gap += bytes;
#line 255
  buffer->payload += bytes;
#line 256
  return (bytes);
}
}
#line 259 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
size_t buffer_move(struct buffer *to , position_t to_offset , struct buffer *from ,
                   position_t from_offset , size_t bytes ) 
{ 
  char *raw ;
  size_t tmp ;

  {
  {
#line 263
  raw = (char *)((void *)0);
#line 264
  bytes = buffer_raw(from, & raw, from_offset, bytes);
#line 265
  buffer_insert(to, (void const   *)raw, to_offset, bytes);
#line 266
  tmp = buffer_delete(from, from_offset, bytes);
  }
#line 266
  return (tmp);
}
}
#line 269 "/home/june/collector/temp/aoeui-1.6~dfsg/buffer.c"
void buffer_snap(struct buffer *buffer ) 
{ 


  {
#line 271
  if (buffer) {
#line 271
    if (buffer->fd >= 0) {
      {
#line 272
      place_gap(buffer, buffer->payload);
#line 273
      ftruncate(buffer->fd, (__off_t )buffer->payload);
      }
    }
  }
#line 277
  return;
}
}
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 22 "/home/june/collector/temp/aoeui-1.6~dfsg/die.c"
void message(char const   *msg  , ...) 
{ 
  int err ;
  int *tmp ;
  va_list ap ;
  struct view *view ;
  struct view *tmp___0 ;
  position_t start ;
  char *tmp___1 ;

  {
  {
#line 24
  tmp = __errno_location();
#line 24
  err = *tmp;
#line 26
  tmp___0 = view_find("* ATTENTION *");
#line 26
  view = tmp___0;
  }
#line 29
  if (! view) {
    {
#line 30
    view = text_create("* ATTENTION *", (unsigned int )(1 << 2));
    }
  }
  {
#line 31
  (view->text)->flags &= (unsigned int )(~ (1 << 1));
#line 32
  view_insert(view, (void const   *)"\n", view->bytes, (ssize_t )1);
#line 33
  start = view->bytes;
#line 34
  __builtin_va_start(ap, msg);
#line 35
  view_vprintf(view, msg, ap);
#line 36
  __builtin_va_end(ap);
  }
#line 37
  if (err) {
    {
#line 38
    tmp___1 = strerror(err);
#line 38
    view_printf(view, "\n(System error code: %s)", tmp___1);
    }
  }
  {
#line 39
  view_insert(view, (void const   *)" ", view->bytes, (ssize_t )1);
#line 40
  (view->text)->flags |= (unsigned int )(1 << 1);
#line 41
  locus_set(view, (locus_t )0, start);
#line 42
  window_below((struct view *)((void *)0), view, (unsigned int )(3 + ! (! err)));
  }
#line 43
  return;
}
}
#line 45 "/home/june/collector/temp/aoeui-1.6~dfsg/die.c"
static struct view *status_view  ;
#line 47 "/home/june/collector/temp/aoeui-1.6~dfsg/die.c"
void status(char const   *msg  , ...) 
{ 
  va_list ap ;

  {
#line 51
  if (! status_view) {
    {
#line 52
    status_view = text_create("* STATUS *", (unsigned int )(1 << 2));
    }
  }
  {
#line 53
  (status_view->text)->flags &= (unsigned int )(~ (1 << 1));
#line 54
  view_delete(status_view, (position_t )0, status_view->bytes);
#line 55
  __builtin_va_start(ap, msg);
#line 56
  view_vprintf(status_view, msg, ap);
#line 57
  __builtin_va_end(ap);
#line 58
  view_insert(status_view, (void const   *)" ", status_view->bytes, (ssize_t )1);
#line 59
  locus_set(status_view, (locus_t )0, status_view->bytes - 1UL);
#line 60
  (status_view->text)->flags |= (unsigned int )(1 << 1);
#line 61
  window_below((struct view *)((void *)0), status_view, 3U);
  }
#line 62
  return;
}
}
#line 64 "/home/june/collector/temp/aoeui-1.6~dfsg/die.c"
void status_hide(void) 
{ 


  {
#line 66
  if (status_view) {
    {
#line 67
    window_destroy(status_view->window);
    }
  }
#line 68
  return;
}
}
#line 6 "/home/june/collector/temp/aoeui-1.6~dfsg/tags.c"
static char *extract_id(struct view *view ) 
{ 
  Unicode_t ch ;
  position_t at ;
  position_t tmp ;
  position_t next ;
  char *id ;
  Boolean_t tmp___0 ;
  Unicode_t tmp___1 ;
  position_t tmp___2 ;

  {
  {
#line 9
  tmp = locus_get(view, (locus_t )0);
#line 9
  at = tmp;
#line 12
  ch = view_char(view, at, & next);
#line 12
  tmp___0 = is_idch(ch);
  }
#line 12
  if (tmp___0) {
    {
#line 14
    at = find_id_end(view, at);
#line 14
    locus_set(view, (locus_t )0, at);
    }
  } else
#line 12
  if (ch == 58U) {
    {
#line 12
    tmp___1 = view_char(view, next, (size_t *)((void *)0));
    }
#line 12
    if (tmp___1 == 58U) {
      {
#line 14
      at = find_id_end(view, at);
#line 14
      locus_set(view, (locus_t )0, at);
      }
    }
  }
  {
#line 15
  tmp___2 = find_id_start(view, at);
#line 15
  locus_set(view, (locus_t )1, tmp___2);
#line 16
  id = view_extract_selection(view);
#line 17
  locus_set(view, (locus_t )1, (position_t )(~ 0));
  }
#line 18
  return (id);
}
}
#line 21 "/home/june/collector/temp/aoeui-1.6~dfsg/tags.c"
static struct view *find_TAGS(struct view *view , struct view *tags ) 
{ 
  char const   *currpath ;
  struct view *tmp ;
  char *path ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *slash ;
  int tmp___2 ;

  {
#line 23
  if (tags) {
#line 23
    tmp = tags;
  } else {
#line 23
    tmp = view;
  }
  {
#line 23
  currpath = (char const   *)(tmp->text)->path;
#line 24
  tmp___0 = strlen(currpath);
#line 24
  tmp___1 = reallocate((void const   *)((void *)0), tmp___0 + 8UL);
#line 24
  path = (char *)tmp___1;
#line 27
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)currpath);
  }
#line 28
  if (tags) {
    {
#line 29
    view_close(tags);
#line 30
    slash = strrchr((char const   *)path, '/');
    }
#line 31
    if (slash) {
#line 32
      *slash = (char )'\000';
    }
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 34
    slash = strrchr((char const   *)path, '/');
    }
#line 34
    if (! slash) {
#line 34
      goto while_break;
    }
    {
#line 35
    strcpy((char */* __restrict  */)(slash + 1), (char const   */* __restrict  */)"TAGS");
#line 36
    tmp___2 = access((char const   *)path, 4);
    }
#line 36
    if (! tmp___2) {
      {
#line 37
      tags = view_open((char const   *)path);
      }
#line 38
      if (tags) {
#line 38
        if (! ((tags->text)->flags & (unsigned int )(1 << 3))) {
          {
#line 39
          reallocate((void const   *)path, (size_t )0);
#line 39
          path = (char *)((void *)0);
          }
#line 40
          return (tags);
        }
      }
      {
#line 42
      view_close(tags);
      }
    }
#line 34
    *slash = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  reallocate((void const   *)path, (size_t )0);
#line 45
  path = (char *)((void *)0);
  }
#line 46
  return ((struct view *)((void *)0));
}
}
#line 49 "/home/june/collector/temp/aoeui-1.6~dfsg/tags.c"
static sposition_t find_id_in_TAGS(struct view *tags , char const   *id ) 
{ 
  position_t first ;
  position_t last ;
  position_t at ;
  position_t wordstart ;
  position_t wordend ;
  sposition_t result ;
  char *this ;
  int cmp ;
  position_t tmp ;
  position_t tmp___0 ;

  {
#line 51
  first = (position_t )0;
#line 52
  last = tags->bytes;
#line 54
  result = (sposition_t )-1;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (first < last)) {
#line 58
      goto while_break;
    }
    {
#line 59
    at = find_line_start(tags, (first + last) >> 1);
    }
#line 60
    if (at < first) {
      {
#line 61
      tmp = find_line_end(tags, at);
#line 61
      at = tmp + 1UL;
      }
    }
#line 62
    if (at >= last) {
#line 63
      goto while_break;
    }
    {
#line 64
    wordstart = find_nonspace(tags, at);
#line 65
    wordend = find_space(tags, wordstart);
#line 66
    this = view_extract(tags, wordstart, (unsigned int )(wordend - wordstart));
    }
#line 67
    if (! this) {
#line 68
      goto while_break;
    }
    {
#line 69
    cmp = strcmp(id, (char const   *)this);
#line 70
    reallocate((void const   *)this, (size_t )0);
#line 70
    this = (char *)((void *)0);
    }
#line 71
    if (! cmp) {
#line 72
      result = (sposition_t )wordend;
    }
#line 73
    if (cmp <= 0) {
#line 74
      last = at;
    } else {
      {
#line 76
      tmp___0 = find_line_end(tags, at);
#line 76
      first = tmp___0 + 1UL;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (result);
}
}
#line 81 "/home/june/collector/temp/aoeui-1.6~dfsg/tags.c"
static sposition_t find_next_id_in_TAGS(struct view *tags , char const   *id , position_t prevend ) 
{ 
  position_t wordstart ;
  position_t tmp ;
  position_t tmp___0 ;
  position_t wordend ;
  position_t tmp___1 ;
  char *this ;
  char *tmp___2 ;
  int cmp ;
  position_t tmp___3 ;

  {
  {
#line 84
  tmp = find_line_end(tags, prevend);
#line 84
  tmp___0 = find_nonspace(tags, tmp + 1UL);
#line 84
  wordstart = tmp___0;
#line 86
  tmp___1 = find_space(tags, wordstart);
#line 86
  wordend = tmp___1;
#line 87
  tmp___2 = view_extract(tags, wordstart, (unsigned int )(wordend - wordstart));
#line 87
  this = tmp___2;
  }
#line 90
  if (! this) {
#line 91
    return ((sposition_t )-1);
  }
  {
#line 92
  cmp = strcmp(id, (char const   *)this);
#line 93
  reallocate((void const   *)this, (size_t )0);
#line 93
  this = (char *)((void *)0);
  }
#line 94
  if (cmp) {
#line 94
    tmp___3 = (position_t )-1;
  } else {
#line 94
    tmp___3 = wordend;
  }
#line 94
  return ((sposition_t )tmp___3);
}
}
#line 97 "/home/june/collector/temp/aoeui-1.6~dfsg/tags.c"
static struct view *show_tag(struct view *tags , sposition_t wordend , char const   *id ) 
{ 
  position_t wordstart ;
  position_t linestart ;
  char *this ;
  char *path ;
  char *slash ;
  int line ;
  struct view *view ;
  sposition_t at ;
  position_t tmp ;
  position_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  position_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 106
  if (wordend < 0L) {
#line 107
    return ((struct view *)((void *)0));
  }
  {
#line 108
  wordstart = find_nonspace(tags, (position_t )wordend);
#line 109
  tmp = find_space(tags, wordstart);
#line 109
  wordend = (sposition_t )tmp;
#line 110
  this = view_extract(tags, wordstart, (unsigned int )((position_t )wordend - wordstart));
#line 111
  tmp___2 = __ctype_b_loc();
  }
#line 111
  if (! ((int const   )*(*tmp___2 + (int )*this) & 2048)) {
    {
#line 113
    reallocate((void const   *)this, (size_t )0);
#line 113
    this = (char *)((void *)0);
#line 114
    wordstart = find_nonspace(tags, (position_t )wordend);
#line 115
    tmp___0 = find_space(tags, wordstart);
#line 115
    wordend = (sposition_t )tmp___0;
#line 116
    this = view_extract(tags, wordstart, (unsigned int )((position_t )wordend - wordstart));
#line 117
    tmp___1 = __ctype_b_loc();
    }
#line 117
    if (! ((int const   )*(*tmp___1 + (int )*this) & 2048)) {
      {
#line 118
      reallocate((void const   *)this, (size_t )0);
#line 118
      this = (char *)((void *)0);
      }
#line 119
      return ((struct view *)((void *)0));
    }
  }
  {
#line 122
  line = atoi((char const   *)this);
#line 123
  reallocate((void const   *)this, (size_t )0);
#line 123
  this = (char *)((void *)0);
#line 124
  wordstart = find_nonspace(tags, (position_t )wordend);
#line 125
  tmp___3 = find_space(tags, wordstart);
#line 125
  wordend = (sposition_t )tmp___3;
#line 126
  this = view_extract(tags, wordstart, (unsigned int )((position_t )wordend - wordstart));
  }
#line 128
  if ((int )*this == 47) {
#line 129
    path = this;
  } else {
    {
#line 131
    tmp___4 = strlen((char const   *)(tags->text)->path);
#line 131
    tmp___5 = strlen((char const   *)this);
#line 131
    tmp___6 = reallocate((void const   *)((void *)0), (tmp___4 + tmp___5) + 8UL);
#line 131
    path = (char *)tmp___6;
#line 132
    strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)(tags->text)->path);
#line 133
    slash = strrchr((char const   *)path, '/');
    }
#line 133
    if (! slash) {
      {
#line 134
      tmp___7 = strlen((char const   *)path);
#line 134
      slash = path + tmp___7;
#line 134
      *slash = (char )'/';
      }
    }
    {
#line 135
    strcpy((char */* __restrict  */)(slash + 1), (char const   */* __restrict  */)this);
#line 136
    reallocate((void const   *)this, (size_t )0);
#line 136
    this = (char *)((void *)0);
    }
  }
  {
#line 139
  view = view_open((char const   *)path);
  }
#line 140
  if (! view) {
    {
#line 141
    message("Could not open %s from TAGS", path);
    }
  }
  {
#line 142
  reallocate((void const   *)path, (size_t )0);
#line 142
  path = (char *)((void *)0);
  }
#line 143
  if (! view) {
    {
#line 144
    view_close(view);
    }
#line 145
    return ((struct view *)0);
  } else
#line 143
  if ((view->text)->flags & (unsigned int )(1 << 3)) {
    {
#line 144
    view_close(view);
    }
#line 145
    return ((struct view *)0);
  }
  {
#line 147
  linestart = find_line_number(view, (unsigned int )line);
#line 148
  at = find_string(view, id, linestart);
  }
#line 149
  if (at >= 0L) {
    {
#line 150
    locus_set(view, (locus_t )0, (position_t )at);
#line 151
    tmp___8 = strlen(id);
#line 151
    locus_set(view, (locus_t )1, (size_t )at + tmp___8);
    }
  } else {
    {
#line 153
    locus_set(view, (locus_t )0, linestart);
#line 154
    locus_set(view, (locus_t )1, (position_t )(~ 0));
    }
  }
#line 156
  return (view);
}
}
#line 159 "/home/june/collector/temp/aoeui-1.6~dfsg/tags.c"
static Boolean_t show_tags(struct view *tags , struct view *view , char const   *id ) 
{ 
  sposition_t wordend ;
  sposition_t tmp ;
  struct view *new_view ;
  struct view *tmp___0 ;
  struct view *top_view ;

  {
  {
#line 162
  tmp = find_id_in_TAGS(tags, id);
#line 162
  wordend = tmp;
#line 163
  tmp___0 = show_tag(tags, wordend, id);
#line 163
  new_view = tmp___0;
  }
#line 166
  if (! new_view) {
#line 167
    return ((Boolean_t )0);
  }
  {
#line 169
  top_view = new_view;
#line 169
  window_below(view, top_view, 4U);
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    wordend = find_next_id_in_TAGS(tags, id, (position_t )wordend);
    }
#line 170
    if (! (wordend >= 0L)) {
#line 170
      goto while_break;
    }
    {
#line 171
    new_view = show_tag(tags, wordend, id);
    }
#line 171
    if (new_view) {
      {
#line 172
      top_view = new_view;
#line 172
      window_below(view, top_view, 4U);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  window_activate(top_view);
  }
#line 174
  return ((Boolean_t )1);
}
}
#line 177 "/home/june/collector/temp/aoeui-1.6~dfsg/tags.c"
void find_tag(struct view *view ) 
{ 
  struct view *tags ;
  char *id ;
  position_t tmp ;
  Boolean_t tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 179
  tags = (struct view *)((void *)0);
#line 182
  tmp = locus_get(view, (locus_t )1);
  }
#line 182
  if (tmp != 0xffffffffffffffffUL) {
    {
#line 183
    id = view_extract_selection(view);
#line 184
    view_delete_selection(view);
    }
  } else {
    {
#line 186
    id = extract_id(view);
    }
  }
#line 187
  if (! id) {
    {
#line 188
    window_beep(view);
    }
#line 189
    return;
  }
  {
#line 192
  tags = find_TAGS(view, (struct view *)((void *)0));
  }
#line 192
  if (! tags) {
    {
#line 193
    message("No readable TAGS file found.");
#line 194
    reallocate((void const   *)id, (size_t )0);
#line 194
    id = (char *)((void *)0);
    }
#line 195
    return;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 199
    tmp___0 = show_tags(tags, view, (char const   *)id);
    }
#line 199
    if (tmp___0) {
      {
#line 200
      view_close(tags);
#line 201
      reallocate((void const   *)id, (size_t )0);
#line 201
      id = (char *)((void *)0);
      }
#line 202
      return;
    }
    {
#line 198
    tags = find_TAGS(view, tags);
    }
#line 198
    if (! tags) {
#line 198
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  tmp___1 = __errno_location();
#line 206
  *tmp___1 = 0;
#line 207
  message("couldn\'t find tag %s", id);
#line 208
  reallocate((void const   *)id, (size_t )0);
#line 208
  id = (char *)((void *)0);
  }
#line 209
  return;
}
}
