/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "./db.h"
struct __anonstruct_DBT_47 {
   void *data ;
   size_t size ;
};
#line 79 "./db.h"
typedef struct __anonstruct_DBT_47 DBT;
#line 97
enum __anonenum_DBTYPE_48 {
    DB_BTREE = 0,
    DB_HASH = 1,
    DB_RECNO = 2
} ;
#line 97 "./db.h"
typedef enum __anonenum_DBTYPE_48 DBTYPE;
#line 123 "./db.h"
struct __db {
   DBTYPE type ;
   int (*close)(struct __db * ) ;
   int (*del)(struct __db  const  * , DBT const   * , u_int  ) ;
   int (*get)(struct __db  const  * , DBT const   * , DBT * , u_int  ) ;
   int (*put)(struct __db  const  * , DBT * , DBT const   * , u_int  ) ;
   int (*seq)(struct __db  const  * , DBT * , DBT * , u_int  ) ;
   int (*sync)(struct __db  const  * , u_int  ) ;
   void *internal ;
   int (*fd)(struct __db  const  * ) ;
};
#line 123 "./db.h"
typedef struct __db DB;
#line 139 "./db.h"
struct __anonstruct_BTREEINFO_49 {
   u_long flags ;
   u_int cachesize ;
   int maxkeypage ;
   int minkeypage ;
   u_int psize ;
   int (*compare)(DBT const   * , DBT const   * ) ;
   size_t (*prefix)(DBT const   * , DBT const   * ) ;
   int lorder ;
};
#line 139 "./db.h"
typedef struct __anonstruct_BTREEINFO_49 BTREEINFO;
#line 168 "./db.h"
struct __anonstruct_RECNOINFO_51 {
   u_long flags ;
   u_int cachesize ;
   u_int psize ;
   int lorder ;
   size_t reclen ;
   u_char bval ;
   char *bfname ;
};
#line 168 "./db.h"
typedef struct __anonstruct_RECNOINFO_51 RECNOINFO;
#line 52 "./mpool.h"
struct __anonstruct_hq_52 {
   struct _bkt *cqe_next ;
   struct _bkt *cqe_prev ;
};
#line 52 "./mpool.h"
struct __anonstruct_q_53 {
   struct _bkt *cqe_next ;
   struct _bkt *cqe_prev ;
};
#line 52 "./mpool.h"
struct _bkt {
   struct __anonstruct_hq_52 hq ;
   struct __anonstruct_q_53 q ;
   void *page ;
   u_int32_t pgno ;
   u_int8_t flags ;
};
#line 63 "./mpool.h"
struct _lqh {
   struct _bkt *cqh_first ;
   struct _bkt *cqh_last ;
};
#line 63 "./mpool.h"
struct _hqh {
   struct _bkt *cqh_first ;
   struct _bkt *cqh_last ;
};
#line 63 "./mpool.h"
struct MPOOL {
   struct _lqh lqh ;
   struct _hqh hqh[128] ;
   u_int32_t curcache ;
   u_int32_t maxcache ;
   u_int32_t npages ;
   u_long pagesize ;
   int fd ;
   void (*pgin)(void * , u_int32_t  , void * ) ;
   void (*pgout)(void * , u_int32_t  , void * ) ;
   void *pgcookie ;
};
#line 63 "./mpool.h"
typedef struct MPOOL MPOOL;
#line 79 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
struct _page {
   u_int32_t pgno ;
   u_int32_t prevpg ;
   u_int32_t nextpg ;
   u_int32_t flags ;
   u_int16_t lower ;
   u_int16_t upper ;
   u_int16_t linp[1] ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
typedef struct _page PAGE;
#line 253 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
struct _epgno {
   u_int32_t pgno ;
   u_int16_t index ;
};
#line 253 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
typedef struct _epgno EPGNO;
#line 258 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
struct _epg {
   PAGE *page ;
   u_int16_t index ;
};
#line 258 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
typedef struct _epg EPG;
#line 287 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
struct _cursor {
   EPGNO pg ;
   DBT key ;
   u_int32_t rcursor ;
   u_int8_t flags ;
};
#line 287 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
typedef struct _cursor CURSOR;
#line 316
enum __anonenum_bt_order_54 {
    NOT = 0,
    BACK = 1,
    FORWARD = 2
} ;
#line 316 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
struct _btree {
   MPOOL *bt_mp ;
   DB *bt_dbp ;
   EPG bt_cur ;
   PAGE *bt_pinned ;
   CURSOR bt_cursor ;
   EPGNO bt_stack[50] ;
   EPGNO *bt_sp ;
   DBT bt_rkey ;
   DBT bt_rdata ;
   int bt_fd ;
   u_int32_t bt_free ;
   u_int32_t bt_psize ;
   u_int16_t bt_ovflsize ;
   int bt_lorder ;
   enum __anonenum_bt_order_54 bt_order ;
   EPGNO bt_last ;
   int (*bt_cmp)(DBT const   * , DBT const   * ) ;
   size_t (*bt_pfx)(DBT const   * , DBT const   * ) ;
   int (*bt_irec)(struct _btree * , u_int32_t  ) ;
   FILE *bt_rfp ;
   int bt_rfd ;
   caddr_t bt_cmap ;
   caddr_t bt_smap ;
   caddr_t bt_emap ;
   size_t bt_msize ;
   u_int32_t bt_nrecs ;
   size_t bt_reclen ;
   u_char bt_bval ;
   u_int32_t flags ;
};
#line 316 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
typedef struct _btree BTREE;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 157 "./db.h"
struct __anonstruct_HASHINFO_57 {
   u_int bsize ;
   u_int ffactor ;
   u_int nelem ;
   u_int cachesize ;
   u_int32_t (*hash)(void const   * , size_t  ) ;
   int lorder ;
};
#line 157 "./db.h"
typedef struct __anonstruct_HASHINFO_57 HASHINFO;
#line 40 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.h"
enum __anonenum_ACTION_59 {
    HASH_GET = 0,
    HASH_PUT = 1,
    HASH_PUTNEW = 2,
    HASH_DELETE = 3,
    HASH_FIRST = 4,
    HASH_NEXT = 5
} ;
#line 40 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.h"
typedef enum __anonenum_ACTION_59 ACTION;
#line 45
struct _bufhead;
#line 45 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.h"
typedef struct _bufhead BUFHEAD;
#line 47 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.h"
struct _bufhead {
   BUFHEAD *prev ;
   BUFHEAD *next ;
   BUFHEAD *ovfl ;
   u_int32_t addr ;
   char *page ;
   char flags ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.h"
typedef BUFHEAD **SEGMENT;
#line 65 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.h"
struct hashhdr {
   int magic ;
   int version ;
   u_int32_t lorder ;
   int bsize ;
   int bshift ;
   int dsize ;
   int ssize ;
   int sshift ;
   int ovfl_point ;
   int last_freed ;
   int max_bucket ;
   int high_mask ;
   int low_mask ;
   int ffactor ;
   int nkeys ;
   int hdrpages ;
   int h_charkey ;
   int spares[32] ;
   u_int16_t bitmaps[32] ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.h"
typedef struct hashhdr HASHHDR;
#line 92 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.h"
struct htab {
   HASHHDR hdr ;
   int nsegs ;
   int exsegs ;
   u_int32_t (*hash)(void const   * , size_t  ) ;
   int flags ;
   int fp ;
   char *tmp_buf ;
   char *tmp_key ;
   BUFHEAD *cpage ;
   int cbucket ;
   int cndx ;
   int errnum ;
   int new_file ;
   int save_file ;
   u_int32_t *mapp[32] ;
   int nmaps ;
   int nbufs ;
   BUFHEAD bufhead ;
   SEGMENT *dir ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.h"
typedef struct htab HTAB;
#line 36 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/recno.h"
enum SRCHOP {
    SDELETE = 0,
    SINSERT = 1,
    SEARCH = 2
} ;
#line 163 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
struct _rinternal {
   u_int32_t nrecs ;
   u_int32_t pgno ;
};
#line 163 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/btree.h"
typedef struct _rinternal RINTERNAL;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 87 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/page.h"
struct __anonstruct_SPLIT_RETURN_60 {
   BUFHEAD *newp ;
   BUFHEAD *oldp ;
   BUFHEAD *nextp ;
   u_int16_t next_addr ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/page.h"
typedef struct __anonstruct_SPLIT_RETURN_60 SPLIT_RETURN;
#line 132 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/btree.h"
struct _binternal {
   u_int32_t ksize ;
   u_int32_t pgno ;
   u_char flags ;
   char bytes[1] ;
};
#line 132 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/btree.h"
typedef struct _binternal BINTERNAL;
#line 304 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/btree.h"
struct _btmeta {
   u_int32_t magic ;
   u_int32_t version ;
   u_int32_t psize ;
   u_int32_t free ;
   u_int32_t nrecs ;
   u_int32_t flags ;
};
#line 304 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/btree.h"
typedef struct _btmeta BTMETA;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 184 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/btree.h"
struct _bleaf {
   u_int32_t ksize ;
   u_int32_t dsize ;
   u_char flags ;
   char bytes[1] ;
};
#line 184 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/btree.h"
typedef struct _bleaf BLEAF;
#line 217 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/btree.h"
struct _rleaf {
   u_int32_t dsize ;
   u_char flags ;
   char bytes[1] ;
};
#line 217 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/btree.h"
typedef struct _rleaf RLEAF;
#line 52 "./mpool.h"
typedef struct _bkt BKT;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 57 "./ndbm.h"
struct __anonstruct_datum_59 {
   char *dptr ;
   int dsize ;
};
#line 57 "./ndbm.h"
typedef struct __anonstruct_datum_59 datum;
#line 62 "./ndbm.h"
typedef DB DBM;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef long ptrdiff_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 27 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
struct hashhdr185 {
   int magic ;
   int version ;
   u_int32_t lorder ;
   int bsize ;
   int bshift ;
   int dsize ;
   int ssize ;
   int sshift ;
   int ovfl_point ;
   int last_freed ;
   int max_bucket ;
   int high_mask ;
   int low_mask ;
   int ffactor ;
   int nkeys ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
typedef struct hashhdr185 HASHHDR185;
#line 46 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
struct htab185 {
   HASHHDR185 hdr ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
typedef struct htab185 HTAB185;
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
struct hashhdr186 {
   int32_t magic ;
   int32_t version ;
   int32_t lorder ;
   int32_t bsize ;
   int32_t bshift ;
   int32_t ovfl_point ;
   int32_t last_freed ;
   int32_t max_bucket ;
   int32_t high_mask ;
   int32_t low_mask ;
   int32_t ffactor ;
   int32_t nkeys ;
   int32_t hdrpages ;
   int32_t h_charkey ;
   int32_t spares[32] ;
   u_int16_t bitmaps[32] ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
typedef struct hashhdr186 HASHHDR186;
#line 71 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
struct htab186 {
   void *unused[2] ;
   HASHHDR186 hdr ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
typedef struct htab186 HTAB186;
#line 81 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
struct _epg___0 {
   void *page ;
   u_int16_t index ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
typedef struct _epg___0 EPG___0;
#line 99
enum __anonenum_bt_order_31 {
    NOT___0 = 0,
    BACK___0 = 1,
    FORWARD___0 = 2
} ;
#line 99 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
struct _btree___0 {
   void *bt_mp ;
   void *bt_dbp ;
   EPG___0 bt_cur ;
   void *bt_pinned ;
   CURSOR bt_cursor ;
   EPGNO bt_stack[50] ;
   EPGNO *bt_sp ;
   DBT bt_rkey ;
   DBT bt_rdata ;
   int bt_fd ;
   u_int32_t bt_free ;
   u_int32_t bt_psize ;
   u_int16_t bt_ovflsize ;
   int bt_lorder ;
   enum __anonenum_bt_order_31 bt_order ;
   EPGNO bt_last ;
   int (*bt_cmp)(DBT * , DBT * ) ;
   size_t (*bt_pfx)(DBT * , DBT * ) ;
   int (*bt_irec)(struct _btree___0 * , u_int32_t  ) ;
   FILE *bt_rfp ;
   int bt_rfd ;
   void *bt_cmap ;
   void *bt_smap ;
   void *bt_emap ;
   size_t bt_msize ;
   u_int32_t bt_nrecs ;
   size_t bt_reclen ;
   u_char bt_bval ;
   u_int32_t flags ;
};
#line 99 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
typedef struct _btree___0 BTREE___0;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 236 "./db.h"
DB *__bt_open(char const   *fname , int flags , int mode , BTREEINFO const   *openinfo ,
              int dflags ) ;
#line 238
DB *__rec_open(char const   *fname , int flags , int mode , RECNOINFO const   *openinfo ,
               int dflags ) ;
#line 99 "./mpool.h"
void *__mpool_get(MPOOL *mp , u_int32_t pgno , u_int flags ) ;
#line 101
int __mpool_put(MPOOL *mp , void *page , u_int flags ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/extern.h"
int __bt_close(DB *dbp ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/extern.h"
int __rec_close(DB *dbp ) ;
#line 39
int __rec_delete(DB const   *dbp , DBT const   *key , u_int flags ) ;
#line 41
int __rec_fd(DB const   *dbp ) ;
#line 44
int __rec_fpipe(BTREE *t , u_int32_t top ) ;
#line 45
int __rec_get(DB const   *dbp , DBT const   *key , DBT *data , u_int flags ) ;
#line 47
int __rec_put(DB const   *dbp , DBT *key , DBT const   *data , u_int flags ) ;
#line 50
int __rec_seq(DB const   *dbp , DBT *key , DBT *data , u_int flags ) ;
#line 51
int __rec_sync(DB const   *dbp , u_int flags ) ;
#line 54
int __rec_vpipe(BTREE *t , u_int32_t top ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_open.c"
DB *__rec_open(char const   *fname , int flags , int mode , RECNOINFO const   *openinfo ,
               int dflags ) 
{ 
  BTREE *t ;
  BTREEINFO btopeninfo ;
  DB *dbp ;
  PAGE *h ;
  struct stat sb ;
  int rfd ;
  int sverrno ;
  int *tmp___1 ;
  FILE *tmp___2 ;
  int tmp___3 ;
  __off_t tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
#line 69
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
    {
#line 69
    rfd = open(fname, flags, mode);
    }
#line 69
    if (rfd < 0) {
#line 70
      return ((DB *)((void *)0));
    }
  }
#line 73
  dbp = (DB *)((void *)0);
#line 74
  if (openinfo) {
#line 75
    if (openinfo->flags & 0xfffffffffffffff8UL) {
#line 76
      goto einval;
    }
    {
#line 77
    btopeninfo.flags = (u_long )0;
#line 78
    btopeninfo.cachesize = (u_int )openinfo->cachesize;
#line 79
    btopeninfo.maxkeypage = 0;
#line 80
    btopeninfo.minkeypage = 0;
#line 81
    btopeninfo.psize = (u_int )openinfo->psize;
#line 82
    btopeninfo.compare = (int (*)(DBT const   * , DBT const   * ))((void *)0);
#line 83
    btopeninfo.prefix = (size_t (*)(DBT const   * , DBT const   * ))((void *)0);
#line 84
    btopeninfo.lorder = (int )openinfo->lorder;
#line 85
    dbp = __bt_open((char const   *)openinfo->bfname, 2, 384, (BTREEINFO const   *)(& btopeninfo),
                    dflags);
    }
  } else {
    {
#line 88
    dbp = __bt_open((char const   *)((void *)0), 2, 384, (BTREEINFO const   *)((void *)0),
                    dflags);
    }
  }
#line 89
  if ((unsigned long )dbp == (unsigned long )((void *)0)) {
#line 90
    goto err;
  }
#line 98
  t = (BTREE *)dbp->internal;
#line 99
  if (openinfo) {
#line 100
    if (openinfo->flags & 1UL) {
#line 101
      t->flags |= 512U;
#line 102
      t->bt_reclen = (size_t )openinfo->reclen;
#line 103
      if (t->bt_reclen == 0UL) {
#line 104
        goto einval;
      }
    }
#line 106
    t->bt_bval = (u_char )openinfo->bval;
  } else {
#line 108
    t->bt_bval = (u_char )'\n';
  }
#line 110
  t->flags |= 128U;
#line 111
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 112
    t->flags |= 2304U;
  } else {
#line 114
    t->bt_rfd = rfd;
  }
#line 116
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
    {
#line 122
    tmp___1 = __errno_location();
#line 122
    *tmp___1 = 0;
#line 123
    tmp___4 = lseek(rfd, (off_t )0, 1);
    }
#line 123
    if (tmp___4 == -1L) {
      {
#line 123
      tmp___5 = __errno_location();
      }
#line 123
      if (*tmp___5 == 29) {
        {
#line 125
        if ((flags & 3) == 0) {
#line 125
          goto case_0;
        }
#line 128
        goto switch_default;
        case_0: /* CIL Label */ 
#line 126
        t->flags |= 8192U;
#line 127
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 129
        goto einval;
        switch_break: /* CIL Label */ ;
        }
        slow: 
        {
#line 131
        tmp___2 = fdopen(rfd, "r");
#line 131
        t->bt_rfp = tmp___2;
        }
#line 131
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 132
          goto err;
        }
#line 133
        t->flags |= 64U;
#line 134
        if (t->flags & 512U) {
#line 134
          t->bt_irec = & __rec_fpipe;
        } else {
#line 134
          t->bt_irec = & __rec_vpipe;
        }
      } else {
#line 123
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 138
      if ((flags & 3) == 0) {
#line 138
        goto case_0___0;
      }
#line 141
      if ((flags & 3) == 2) {
#line 141
        goto case_2;
      }
#line 143
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
#line 139
      t->flags |= 8192U;
#line 140
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 142
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 144
      goto einval;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 147
      tmp___3 = fstat(rfd, & sb);
      }
#line 147
      if (tmp___3) {
#line 148
        goto err;
      }
#line 158
      if (sb.st_size == 0L) {
#line 159
        t->flags |= 256U;
      } else {
#line 180
        goto slow;
      }
    }
  }
  {
#line 187
  dbp->close = & __rec_close;
#line 188
  dbp->del = & __rec_delete;
#line 189
  dbp->fd = & __rec_fd;
#line 190
  dbp->get = & __rec_get;
#line 191
  dbp->put = & __rec_put;
#line 192
  dbp->seq = & __rec_seq;
#line 193
  dbp->sync = & __rec_sync;
#line 196
  tmp___6 = __mpool_get(t->bt_mp, (u_int32_t )1, (u_int )0);
#line 196
  h = (PAGE *)tmp___6;
  }
#line 196
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 197
    goto err;
  }
#line 198
  if ((h->flags & 31U) == 2U) {
    {
#line 199
    h->flags &= 4294967264U;
#line 200
    h->flags |= 16U;
#line 201
    __mpool_put(t->bt_mp, (void *)h, (u_int )1);
    }
  } else {
    {
#line 203
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
  }
#line 205
  if (openinfo) {
#line 205
    if (openinfo->flags & 4UL) {
#line 205
      if (! (t->flags & 2304U)) {
        {
#line 205
        tmp___7 = (*(t->bt_irec))(t, 4294967295U);
        }
#line 205
        if (tmp___7 == -1) {
#line 208
          goto err;
        }
      }
    }
  }
#line 209
  return (dbp);
  einval: 
  {
#line 211
  tmp___8 = __errno_location();
#line 211
  *tmp___8 = 22;
  }
  err: 
  {
#line 212
  tmp___9 = __errno_location();
#line 212
  sverrno = *tmp___9;
  }
#line 213
  if ((unsigned long )dbp != (unsigned long )((void *)0)) {
    {
#line 214
    __bt_close(dbp);
    }
  }
#line 215
  if ((unsigned long )fname != (unsigned long )((void *)0)) {
    {
#line 216
    close(rfd);
    }
  }
  {
#line 217
  tmp___10 = __errno_location();
#line 217
  *tmp___10 = sverrno;
  }
#line 218
  return ((DB *)((void *)0));
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_open.c"
int __rec_fd(DB const   *dbp ) 
{ 
  BTREE *t ;
  int *tmp___1 ;

  {
#line 227
  t = (BTREE *)dbp->internal;
#line 230
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 231
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 232
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
#line 236
  if (t->flags & 2048U) {
    {
#line 237
    tmp___1 = __errno_location();
#line 237
    *tmp___1 = 2;
    }
#line 238
    return (-1);
  }
#line 240
  return (t->bt_rfd);
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 237 "./db.h"
extern DB *__hash_open(char const   *file , int flags , int mode , HASHINFO const   *info ,
                       int dflags ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/extern.h"
extern int __addel(HTAB *hashp , BUFHEAD *bufp , DBT const   *key , DBT const   *val ) ;
#line 40
extern int __big_keydata(HTAB *hashp , BUFHEAD *bufp , DBT *key , DBT *val , int set ) ;
#line 41
extern int __big_return(HTAB *hashp , BUFHEAD *bufp , int ndx , DBT *val , int set_current ) ;
#line 44
extern int __buf_free(HTAB *hashp , int do_free , int to_disk ) ;
#line 45
extern void __buf_init(HTAB *hashp , int nbytes ) ;
#line 46
extern u_int32_t __call_hash(HTAB *hashp , char *k , int len ) ;
#line 47
extern int __delpair(HTAB *hashp , BUFHEAD *bufp , int ndx ) ;
#line 48
extern int __expand_table(HTAB *hashp ) ;
#line 49
extern int __find_bigpair(HTAB *hashp , BUFHEAD *bufp , int ndx , char *key , int size ) ;
#line 50
extern u_int16_t __find_last_page(HTAB *hashp , BUFHEAD **bpp ) ;
#line 52
extern BUFHEAD *__get_buf(HTAB *hashp , u_int32_t addr , BUFHEAD *prev_bp , int newpage ) ;
#line 54
extern int __ibitmap(HTAB *hashp , int pnum , int nbits , int ndx ) ;
#line 55
u_int32_t __hash_log2(u_int32_t num ) ;
#line 56
extern int __put_page(HTAB *hashp , char *p , u_int32_t bucket , int is_bucket , int is_bitmap ) ;
#line 58
extern int __split_page(HTAB *hashp , u_int32_t obucket , u_int32_t nbucket ) ;
#line 61
u_int32_t (*__default_hash)(void const   * , size_t  ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int alloc_segs(HTAB *hashp , int nsegs ) ;
#line 60
static int flush_meta(HTAB *hashp ) ;
#line 61
static int hash_access(HTAB *hashp , ACTION action , DBT *key , DBT *val ) ;
#line 62
static int hash_close(DB *dbp ) ;
#line 63
static int hash_delete(DB const   *dbp , DBT const   *key , u_int32_t flag ) ;
#line 64
static int hash_fd(DB const   *dbp ) ;
#line 65
static int hash_get(DB const   *dbp , DBT const   *key , DBT *data , u_int32_t flag ) ;
#line 66
static int hash_put(DB const   *dbp , DBT *key , DBT const   *data , u_int32_t flag ) ;
#line 67
static void *hash_realloc(SEGMENT **p_ptr , int oldsize , int newsize ) ;
#line 68
static int hash_seq(DB const   *dbp , DBT *key , DBT *data , u_int32_t flag ) ;
#line 69
static int hash_sync(DB const   *dbp , u_int32_t flags ) ;
#line 70
static int hdestroy(HTAB *hashp ) ;
#line 71
static HTAB *init_hash(HTAB *hashp , char const   *file , HASHINFO *info ) ;
#line 72
static int init_htab(HTAB *hashp , int nelem ) ;
#line 74
static void swap_header(HTAB *hashp ) ;
#line 75
static void swap_header_copy(HASHHDR *srcp , HASHHDR *destp ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
extern DB *__hash_open(char const   *file , int flags , int mode , HASHINFO const   *info ,
                       int dflags ) 
{ 
  HTAB *hashp ;
  struct stat statbuf ;
  DB *dbp ;
  int bpages ;
  int hdrsize ;
  int new_table ;
  int nsegs ;
  int save_errno ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  ssize_t tmp___10 ;
  int *tmp___11 ;
  u_int32_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  void *tmp___17 ;
  int *tmp___18 ;

  {
#line 106
  if ((flags & 3) == 1) {
    {
#line 107
    tmp___1 = __errno_location();
#line 107
    *tmp___1 = 22;
    }
#line 108
    return ((DB *)((void *)0));
  }
  {
#line 111
  tmp___2 = calloc((size_t )1, sizeof(HTAB ));
#line 111
  hashp = (HTAB *)tmp___2;
  }
#line 111
  if (! hashp) {
#line 112
    return ((DB *)((void *)0));
  }
#line 113
  hashp->fp = -1;
#line 121
  hashp->flags = flags;
#line 123
  new_table = 0;
#line 124
  if (! file) {
#line 124
    goto _L;
  } else
#line 124
  if (flags & 512) {
#line 124
    goto _L;
  } else {
    {
#line 124
    tmp___5 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& statbuf));
    }
#line 124
    if (tmp___5) {
      {
#line 124
      tmp___6 = __errno_location();
      }
#line 124
      if (*tmp___6 == 2) {
        _L: /* CIL Label */ 
        {
#line 126
        tmp___4 = __errno_location();
        }
#line 126
        if (*tmp___4 == 2) {
          {
#line 127
          tmp___3 = __errno_location();
#line 127
          *tmp___3 = 0;
          }
        }
#line 128
        new_table = 1;
      }
    }
  }
#line 130
  if (file) {
    {
#line 131
    tmp___8 = open(file, flags, mode);
#line 131
    hashp->fp = tmp___8;
    }
#line 131
    if (tmp___8 == -1) {
      {
#line 132
      tmp___7 = __errno_location();
#line 132
      save_errno = *tmp___7;
      }
#line 132
      goto error0;
    }
    {
#line 133
    fcntl(hashp->fp, 2, 1);
    }
  }
#line 135
  if (new_table) {
    {
#line 136
    hashp = init_hash(hashp, file, (HASHINFO *)info);
    }
#line 136
    if (! hashp) {
      {
#line 137
      tmp___9 = __errno_location();
#line 137
      save_errno = *tmp___9;
      }
#line 137
      goto error1;
    }
  } else {
#line 140
    if (info) {
#line 140
      if (info->hash) {
#line 141
        hashp->hash = (u_int32_t (*)(void const   * , size_t  ))info->hash;
      } else {
#line 143
        hashp->hash = __default_hash;
      }
    } else {
#line 143
      hashp->hash = __default_hash;
    }
    {
#line 145
    tmp___10 = read(hashp->fp, (void *)(& hashp->hdr), sizeof(HASHHDR ));
#line 145
    hdrsize = (int )tmp___10;
#line 147
    swap_header(hashp);
    }
#line 149
    if (hdrsize == -1) {
      {
#line 150
      tmp___11 = __errno_location();
#line 150
      save_errno = *tmp___11;
      }
#line 150
      goto error1;
    }
#line 151
    if ((unsigned long )hdrsize != sizeof(HASHHDR )) {
#line 152
      save_errno = 22;
#line 152
      goto error1;
    }
#line 154
    if (hashp->hdr.magic != 398689) {
#line 155
      save_errno = 22;
#line 155
      goto error1;
    }
#line 157
    if (hashp->hdr.version != 2) {
#line 157
      if (hashp->hdr.version != 1) {
#line 159
        save_errno = 22;
#line 159
        goto error1;
      }
    }
    {
#line 160
    tmp___12 = (*(hashp->hash))((void const   *)"%$sniglet^&", sizeof("%$sniglet^&"));
    }
#line 160
    if (tmp___12 != (u_int32_t )hashp->hdr.h_charkey) {
#line 162
      save_errno = 22;
#line 162
      goto error1;
    }
    {
#line 168
    nsegs = (((hashp->hdr.max_bucket + 1) + hashp->hdr.ssize) - 1) / hashp->hdr.ssize;
#line 170
    hashp->nsegs = 0;
#line 171
    tmp___13 = alloc_segs(hashp, nsegs);
    }
#line 171
    if (tmp___13) {
#line 176
      return ((DB *)((void *)0));
    }
    {
#line 178
    bpages = ((hashp->hdr.spares[hashp->hdr.ovfl_point] + (hashp->hdr.bsize << 3)) - 1) >> (hashp->hdr.bshift + 3);
#line 182
    hashp->nmaps = bpages;
#line 183
    memset((void *)(& hashp->mapp[0]), 0, (unsigned long )bpages * sizeof(u_int32_t *));
    }
  }
#line 187
  if (info) {
#line 187
    if (info->cachesize) {
      {
#line 188
      __buf_init(hashp, (int )info->cachesize);
      }
    } else {
      {
#line 190
      __buf_init(hashp, 65536);
      }
    }
  } else {
    {
#line 190
    __buf_init(hashp, 65536);
    }
  }
#line 192
  hashp->new_file = new_table;
#line 193
  if (file) {
#line 193
    if ((hashp->flags & 3) != 0) {
#line 193
      tmp___14 = 1;
    } else {
#line 193
      tmp___14 = 0;
    }
  } else {
#line 193
    tmp___14 = 0;
  }
  {
#line 193
  hashp->save_file = tmp___14;
#line 194
  hashp->cbucket = -1;
#line 195
  tmp___17 = malloc(sizeof(DB ));
#line 195
  dbp = (DB *)tmp___17;
  }
#line 195
  if (! dbp) {
    {
#line 196
    tmp___15 = __errno_location();
#line 196
    save_errno = *tmp___15;
#line 197
    hdestroy(hashp);
#line 198
    tmp___16 = __errno_location();
#line 198
    *tmp___16 = save_errno;
    }
#line 199
    return ((DB *)((void *)0));
  }
#line 201
  dbp->internal = (void *)hashp;
#line 202
  dbp->close = & hash_close;
#line 203
  dbp->del = & hash_delete;
#line 204
  dbp->fd = & hash_fd;
#line 205
  dbp->get = & hash_get;
#line 206
  dbp->put = & hash_put;
#line 207
  dbp->seq = & hash_seq;
#line 208
  dbp->sync = & hash_sync;
#line 209
  dbp->type = (DBTYPE )1;
#line 233
  return (dbp);
  error1: 
#line 236
  if ((unsigned long )hashp != (unsigned long )((void *)0)) {
    {
#line 237
    close(hashp->fp);
    }
  }
  error0: 
  {
#line 240
  free((void *)hashp);
#line 241
  tmp___18 = __errno_location();
#line 241
  *tmp___18 = save_errno;
  }
#line 242
  return ((DB *)((void *)0));
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_close(DB *dbp ) 
{ 
  HTAB *hashp ;
  int retval ;

  {
#line 252
  if (! dbp) {
#line 253
    return (-1);
  }
  {
#line 255
  hashp = (HTAB *)dbp->internal;
#line 256
  retval = hdestroy(hashp);
#line 257
  free((void *)dbp);
  }
#line 258
  return (retval);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_fd(DB const   *dbp ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;

  {
#line 267
  if (! dbp) {
#line 268
    return (-1);
  }
#line 270
  hashp = (HTAB *)dbp->internal;
#line 271
  if (hashp->fp == -1) {
    {
#line 272
    tmp___1 = __errno_location();
#line 272
    *tmp___1 = 2;
    }
#line 273
    return (-1);
  }
#line 275
  return (hashp->fp);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static HTAB *init_hash(HTAB *hashp , char const   *file , HASHINFO *info ) 
{ 
  struct stat statbuf ;
  int nelem ;
  int tmp___1 ;
  u_int32_t tmp___2 ;
  u_int32_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 290
  nelem = 1;
#line 291
  hashp->hdr.nkeys = 0;
#line 292
  hashp->hdr.lorder = (u_int32_t )1234;
#line 293
  hashp->hdr.bsize = 4096;
#line 294
  hashp->hdr.bshift = 12;
#line 295
  hashp->hdr.ssize = 256;
#line 296
  hashp->hdr.sshift = 8;
#line 297
  hashp->hdr.dsize = 256;
#line 298
  hashp->hdr.ffactor = 65536;
#line 299
  hashp->hash = __default_hash;
#line 300
  memset((void *)(hashp->hdr.spares), 0, sizeof(hashp->hdr.spares));
#line 301
  memset((void *)(hashp->hdr.bitmaps), 0, sizeof(hashp->hdr.bitmaps));
  }
#line 305
  if ((unsigned long )file != (unsigned long )((void *)0)) {
    {
#line 306
    tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& statbuf));
    }
#line 306
    if (tmp___1) {
#line 307
      return ((HTAB *)((void *)0));
    }
    {
#line 308
    hashp->hdr.bsize = (int )statbuf.st_blksize;
#line 309
    tmp___2 = __hash_log2((u_int32_t )hashp->hdr.bsize);
#line 309
    hashp->hdr.bshift = (int )tmp___2;
    }
  }
#line 313
  if (info) {
#line 314
    if (info->bsize) {
      {
#line 316
      tmp___3 = __hash_log2(info->bsize);
#line 316
      hashp->hdr.bshift = (int )tmp___3;
#line 317
      hashp->hdr.bsize = 1 << hashp->hdr.bshift;
      }
#line 318
      if (hashp->hdr.bsize > 65536) {
        {
#line 319
        tmp___4 = __errno_location();
#line 319
        *tmp___4 = 22;
        }
#line 320
        return ((HTAB *)((void *)0));
      }
    }
#line 323
    if (info->ffactor) {
#line 324
      hashp->hdr.ffactor = (int )info->ffactor;
    }
#line 325
    if (info->hash) {
#line 326
      hashp->hash = info->hash;
    }
#line 327
    if (info->nelem) {
#line 328
      nelem = (int )info->nelem;
    }
#line 329
    if (info->lorder) {
#line 330
      if (info->lorder != 4321) {
#line 330
        if (info->lorder != 1234) {
          {
#line 332
          tmp___5 = __errno_location();
#line 332
          *tmp___5 = 22;
          }
#line 333
          return ((HTAB *)((void *)0));
        }
      }
#line 335
      hashp->hdr.lorder = (u_int32_t )info->lorder;
    }
  }
  {
#line 339
  tmp___6 = init_htab(hashp, nelem);
  }
#line 339
  if (tmp___6) {
#line 340
    return ((HTAB *)((void *)0));
  } else {
#line 342
    return (hashp);
  }
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int init_htab(HTAB *hashp , int nelem ) 
{ 
  register int nbuckets ;
  register int nsegs ;
  int l2 ;
  int tmp___1 ;
  u_int32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  u_int32_t tmp___6 ;
  int tmp___7 ;

  {
#line 363
  nelem = (nelem - 1) / hashp->hdr.ffactor + 1;
#line 365
  if (nelem > 2) {
#line 365
    tmp___1 = nelem;
  } else {
#line 365
    tmp___1 = 2;
  }
  {
#line 365
  tmp___2 = __hash_log2((u_int32_t )tmp___1);
#line 365
  l2 = (int )tmp___2;
#line 366
  nbuckets = 1 << l2;
#line 368
  hashp->hdr.spares[l2] = l2 + 1;
#line 369
  hashp->hdr.spares[l2 + 1] = l2 + 1;
#line 370
  hashp->hdr.ovfl_point = l2;
#line 371
  hashp->hdr.last_freed = 2;
#line 374
  tmp___3 = __ibitmap(hashp, (int )(((u_int32_t )l2 << 11) + 1U), l2 + 1, 0);
  }
#line 374
  if (tmp___3) {
#line 375
    return (-1);
  }
#line 377
  tmp___4 = nbuckets - 1;
#line 377
  hashp->hdr.low_mask = tmp___4;
#line 377
  hashp->hdr.max_bucket = tmp___4;
#line 378
  hashp->hdr.high_mask = (nbuckets << 1) - 1;
#line 379
  if (sizeof(HASHHDR ) > 512UL) {
#line 379
    tmp___5 = sizeof(HASHHDR );
  } else {
#line 379
    tmp___5 = 512UL;
  }
  {
#line 379
  hashp->hdr.hdrpages = (int )(((tmp___5 - 1UL) >> hashp->hdr.bshift) + 1UL);
#line 382
  nsegs = (nbuckets - 1) / hashp->hdr.ssize + 1;
#line 383
  tmp___6 = __hash_log2((u_int32_t )nsegs);
#line 383
  nsegs = 1 << tmp___6;
  }
#line 385
  if (nsegs > hashp->hdr.dsize) {
#line 386
    hashp->hdr.dsize = nsegs;
  }
  {
#line 387
  tmp___7 = alloc_segs(hashp, nsegs);
  }
#line 387
  return (tmp___7);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hdestroy(HTAB *hashp ) 
{ 
  int i ;
  int save_errno ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 402
  save_errno = 0;
#line 422
  tmp___2 = __buf_free(hashp, 1, hashp->save_file);
  }
#line 422
  if (tmp___2) {
    {
#line 423
    tmp___1 = __errno_location();
#line 423
    save_errno = *tmp___1;
    }
  }
#line 424
  if (hashp->dir) {
    {
#line 425
    free((void *)*(hashp->dir));
    }
    {
#line 427
    while (1) {
      while_continue: /* CIL Label */ ;
#line 427
      tmp___3 = hashp->exsegs;
#line 427
      (hashp->exsegs) --;
#line 427
      if (! tmp___3) {
#line 427
        goto while_break;
      }
      {
#line 428
      (hashp->nsegs) --;
#line 428
      free((void *)*(hashp->dir + hashp->nsegs));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 429
    free((void *)hashp->dir);
    }
  }
  {
#line 431
  tmp___5 = flush_meta(hashp);
  }
#line 431
  if (tmp___5) {
#line 431
    if (! save_errno) {
      {
#line 432
      tmp___4 = __errno_location();
#line 432
      save_errno = *tmp___4;
      }
    }
  }
#line 434
  i = 0;
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    if (! (i < hashp->nmaps)) {
#line 434
      goto while_break___0;
    }
#line 435
    if (hashp->mapp[i]) {
      {
#line 436
      free((void *)hashp->mapp[i]);
      }
    }
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 438
  if (hashp->fp != -1) {
    {
#line 439
    close(hashp->fp);
    }
  }
  {
#line 441
  free((void *)hashp);
  }
#line 443
  if (save_errno) {
    {
#line 444
    tmp___6 = __errno_location();
#line 444
    *tmp___6 = save_errno;
    }
#line 445
    return (-1);
  }
#line 447
  return (0);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_sync(DB const   *dbp , u_int32_t flags ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 463
  if (flags != 0U) {
    {
#line 464
    tmp___1 = __errno_location();
#line 464
    *tmp___1 = 22;
    }
#line 465
    return (-1);
  }
#line 468
  if (! dbp) {
#line 469
    return (-1);
  }
#line 471
  hashp = (HTAB *)dbp->internal;
#line 472
  if (! hashp->save_file) {
#line 473
    return (0);
  }
  {
#line 474
  tmp___2 = __buf_free(hashp, 0, 1);
  }
#line 474
  if (tmp___2) {
#line 475
    return (-1);
  } else {
    {
#line 474
    tmp___3 = flush_meta(hashp);
    }
#line 474
    if (tmp___3) {
#line 475
      return (-1);
    }
  }
#line 476
  hashp->new_file = 0;
#line 477
  return (0);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int flush_meta(HTAB *hashp ) 
{ 
  HASHHDR *whdrp ;
  HASHHDR whdr ;
  int fp ;
  int i ;
  int wsize ;
  u_int32_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  __off_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;

  {
#line 495
  if (! hashp->save_file) {
#line 496
    return (0);
  }
  {
#line 497
  hashp->hdr.magic = 398689;
#line 498
  hashp->hdr.version = 2;
#line 499
  tmp___1 = (*(hashp->hash))((void const   *)"%$sniglet^&", sizeof("%$sniglet^&"));
#line 499
  hashp->hdr.h_charkey = (int )tmp___1;
#line 501
  fp = hashp->fp;
#line 502
  whdrp = & hashp->hdr;
#line 504
  whdrp = & whdr;
#line 505
  swap_header_copy(& hashp->hdr, whdrp);
#line 507
  tmp___4 = lseek(fp, (off_t )0, 0);
  }
#line 507
  if (tmp___4 == -1L) {
#line 509
    return (-1);
  } else {
    {
#line 507
    tmp___5 = write(fp, (void const   *)whdrp, sizeof(HASHHDR ));
#line 507
    wsize = (int )tmp___5;
    }
#line 507
    if (wsize == -1) {
#line 509
      return (-1);
    } else
#line 511
    if ((unsigned long )wsize != sizeof(HASHHDR )) {
      {
#line 512
      tmp___2 = __errno_location();
#line 512
      *tmp___2 = 22;
#line 513
      tmp___3 = __errno_location();
#line 513
      hashp->errnum = *tmp___3;
      }
#line 514
      return (-1);
    }
  }
#line 516
  i = 0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (i < 32)) {
#line 516
      goto while_break;
    }
#line 517
    if (hashp->mapp[i]) {
      {
#line 518
      tmp___6 = __put_page(hashp, (char *)hashp->mapp[i], (u_int32_t )hashp->hdr.bitmaps[i],
                           0, 1);
      }
#line 518
      if (tmp___6) {
#line 520
        return (-1);
      }
    }
#line 516
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  return (0);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_get(DB const   *dbp , DBT const   *key , DBT *data , u_int32_t flag ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 542
  hashp = (HTAB *)dbp->internal;
#line 543
  if (flag) {
    {
#line 544
    tmp___1 = __errno_location();
#line 544
    tmp___2 = 22;
#line 544
    *tmp___1 = tmp___2;
#line 544
    hashp->errnum = tmp___2;
    }
#line 545
    return (-1);
  }
  {
#line 547
  tmp___3 = hash_access(hashp, (ACTION )0, (DBT *)key, data);
  }
#line 547
  return (tmp___3);
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_put(DB const   *dbp , DBT *key , DBT const   *data , u_int32_t flag ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 559
  hashp = (HTAB *)dbp->internal;
#line 560
  if (flag) {
#line 560
    if (flag != 8U) {
      {
#line 561
      tmp___1 = __errno_location();
#line 561
      tmp___2 = 22;
#line 561
      *tmp___1 = tmp___2;
#line 561
      hashp->errnum = tmp___2;
      }
#line 562
      return (-1);
    }
  }
#line 564
  if ((hashp->flags & 3) == 0) {
    {
#line 565
    tmp___3 = __errno_location();
#line 565
    tmp___4 = 1;
#line 565
    *tmp___3 = tmp___4;
#line 565
    hashp->errnum = tmp___4;
    }
#line 566
    return (-1);
  }
#line 568
  if (flag == 8U) {
#line 568
    tmp___5 = 2;
  } else {
#line 568
    tmp___5 = 1;
  }
  {
#line 568
  tmp___6 = hash_access(hashp, (ACTION )tmp___5, key, (DBT *)data);
  }
#line 568
  return (tmp___6);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_delete(DB const   *dbp , DBT const   *key , u_int32_t flag ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 580
  hashp = (HTAB *)dbp->internal;
#line 581
  if (flag) {
#line 581
    if (flag != 1U) {
      {
#line 582
      tmp___1 = __errno_location();
#line 582
      tmp___2 = 22;
#line 582
      *tmp___1 = tmp___2;
#line 582
      hashp->errnum = tmp___2;
      }
#line 583
      return (-1);
    }
  }
#line 585
  if ((hashp->flags & 3) == 0) {
    {
#line 586
    tmp___3 = __errno_location();
#line 586
    tmp___4 = 1;
#line 586
    *tmp___3 = tmp___4;
#line 586
    hashp->errnum = tmp___4;
    }
#line 587
    return (-1);
  }
  {
#line 589
  tmp___5 = hash_access(hashp, (ACTION )3, (DBT *)key, (DBT *)((void *)0));
  }
#line 589
  return (tmp___5);
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_access(HTAB *hashp , ACTION action , DBT *key , DBT *val ) 
{ 
  register BUFHEAD *rbufp ;
  BUFHEAD *bufp ;
  BUFHEAD *save_bufp ;
  register u_int16_t *bp ;
  register int n ;
  register int ndx ;
  register int off ;
  register int size ;
  register char *kp ;
  u_int16_t pageno ;
  u_int32_t tmp___1 ;
  u_int16_t *tmp___2 ;
  int tmp___3 ;
  u_int16_t *tmp___4 ;
  u_int16_t *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 612
  off = hashp->hdr.bsize;
#line 613
  size = (int )key->size;
#line 614
  kp = (char *)key->data;
#line 615
  tmp___1 = __call_hash(hashp, kp, size);
#line 615
  rbufp = __get_buf(hashp, tmp___1, (BUFHEAD *)((void *)0), 0);
  }
#line 616
  if (! rbufp) {
#line 617
    return (-1);
  }
#line 618
  save_bufp = rbufp;
#line 621
  rbufp->flags = (char )((int )rbufp->flags | 8);
#line 622
  bp = (u_int16_t *)rbufp->page;
#line 622
  tmp___2 = bp;
#line 622
  bp ++;
#line 622
  n = (int )*tmp___2;
#line 622
  ndx = 1;
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (ndx < n)) {
#line 622
      goto while_break;
    }
#line 623
    if ((int )*(bp + 1) >= 4) {
#line 625
      if (size == off - (int )*bp) {
        {
#line 625
        tmp___3 = memcmp((void const   *)kp, (void const   *)(rbufp->page + (int )*bp),
                         (size_t )size);
        }
#line 625
        if (tmp___3 == 0) {
#line 627
          goto found;
        }
      }
#line 628
      off = (int )*(bp + 1);
#line 632
      bp += 2;
#line 633
      ndx += 2;
    } else
#line 634
    if ((int )*(bp + 1) == 0) {
      {
#line 635
      rbufp = __get_buf(hashp, (u_int32_t )*bp, rbufp, 0);
      }
#line 636
      if (! rbufp) {
#line 637
        save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 638
        return (-1);
      }
#line 641
      bp = (u_int16_t *)rbufp->page;
#line 642
      tmp___4 = bp;
#line 642
      bp ++;
#line 642
      n = (int )*tmp___4;
#line 643
      ndx = 1;
#line 644
      off = hashp->hdr.bsize;
    } else
#line 645
    if ((int )*(bp + 1) < 4) {
      {
#line 646
      ndx = __find_bigpair(hashp, rbufp, ndx, kp, size);
      }
#line 646
      if (ndx > 0) {
#line 648
        goto found;
      }
#line 649
      if (ndx == -2) {
        {
#line 650
        bufp = rbufp;
#line 651
        pageno = __find_last_page(hashp, & bufp);
        }
#line 651
        if (! pageno) {
#line 653
          ndx = 0;
#line 654
          rbufp = bufp;
#line 655
          goto while_break;
        }
        {
#line 657
        rbufp = __get_buf(hashp, (u_int32_t )pageno, bufp, 0);
        }
#line 658
        if (! rbufp) {
#line 659
          save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 660
          return (-1);
        }
#line 663
        bp = (u_int16_t *)rbufp->page;
#line 664
        tmp___5 = bp;
#line 664
        bp ++;
#line 664
        n = (int )*tmp___5;
#line 665
        ndx = 1;
#line 666
        off = hashp->hdr.bsize;
      } else {
#line 668
        save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 669
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  if ((unsigned int )action == 2U) {
#line 676
    goto case_2;
  }
#line 676
  if ((unsigned int )action == 1U) {
#line 676
    goto case_2;
  }
#line 686
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 677
  tmp___6 = __addel(hashp, rbufp, (DBT const   *)key, (DBT const   *)val);
  }
#line 677
  if (tmp___6) {
#line 678
    save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 679
    return (-1);
  } else {
#line 681
    save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 682
    return (0);
  }
  switch_default: /* CIL Label */ 
#line 687
  save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 688
  return (1);
  switch_break: /* CIL Label */ ;
  }
  found: 
  {
#line 693
  if ((unsigned int )action == 2U) {
#line 693
    goto case_2___0;
  }
#line 696
  if ((unsigned int )action == 0U) {
#line 696
    goto case_0;
  }
#line 706
  if ((unsigned int )action == 1U) {
#line 706
    goto case_1___0;
  }
#line 713
  if ((unsigned int )action == 3U) {
#line 713
    goto case_3;
  }
#line 717
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
#line 694
  save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 695
  return (1);
  case_0: /* CIL Label */ 
#line 697
  bp = (u_int16_t *)rbufp->page;
#line 698
  if ((int )*(bp + (ndx + 1)) < 4) {
    {
#line 699
    tmp___7 = __big_return(hashp, rbufp, ndx, val, 0);
    }
#line 699
    if (tmp___7) {
#line 700
      return (-1);
    }
  } else {
#line 702
    val->data = (void *)((u_char *)rbufp->page + (int )*(bp + (ndx + 1)));
#line 703
    val->size = (size_t )((int )*(bp + ndx) - (int )*(bp + (ndx + 1)));
  }
#line 705
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 707
  tmp___8 = __delpair(hashp, rbufp, ndx);
  }
#line 707
  if (tmp___8) {
#line 709
    save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 710
    return (-1);
  } else {
    {
#line 707
    tmp___9 = __addel(hashp, rbufp, (DBT const   *)key, (DBT const   *)val);
    }
#line 707
    if (tmp___9) {
#line 709
      save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 710
      return (-1);
    }
  }
#line 712
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 714
  tmp___10 = __delpair(hashp, rbufp, ndx);
  }
#line 714
  if (tmp___10) {
#line 715
    return (-1);
  }
#line 716
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 718
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 720
  save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 721
  return (0);
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_seq(DB const   *dbp , DBT *key , DBT *data , u_int32_t flag ) 
{ 
  register u_int32_t bucket ;
  register BUFHEAD *bufp ;
  HTAB *hashp ;
  u_int16_t *bp ;
  u_int16_t ndx ;
  int *tmp___1 ;
  int tmp___2 ;
  BUFHEAD *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 735
  hashp = (HTAB *)dbp->internal;
#line 736
  if (flag) {
#line 736
    if (flag != 3U) {
#line 736
      if (flag != 7U) {
        {
#line 737
        tmp___1 = __errno_location();
#line 737
        tmp___2 = 22;
#line 737
        *tmp___1 = tmp___2;
#line 737
        hashp->errnum = tmp___2;
        }
#line 738
        return (-1);
      }
    }
  }
#line 743
  if (hashp->cbucket < 0) {
#line 744
    hashp->cbucket = 0;
#line 745
    hashp->cndx = 1;
#line 746
    hashp->cpage = (BUFHEAD *)((void *)0);
  } else
#line 743
  if (flag == 3U) {
#line 744
    hashp->cbucket = 0;
#line 745
    hashp->cndx = 1;
#line 746
    hashp->cpage = (BUFHEAD *)((void *)0);
  }
#line 749
  bp = (u_int16_t *)((void *)0);
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (! (! bp)) {
#line 749
      if (! (! *(bp + 0))) {
#line 749
        goto while_break;
      }
    }
#line 750
    bufp = hashp->cpage;
#line 750
    if (bufp) {
#line 768
      bp = (u_int16_t *)(hashp->cpage)->page;
    } else {
#line 751
      bucket = (u_int32_t )hashp->cbucket;
      {
#line 751
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 751
        if (! (bucket <= (u_int32_t )hashp->hdr.max_bucket)) {
#line 751
          goto while_break___0;
        }
        {
#line 754
        bufp = __get_buf(hashp, bucket, (BUFHEAD *)((void *)0), 0);
        }
#line 755
        if (! bufp) {
#line 756
          return (-1);
        }
#line 757
        hashp->cpage = bufp;
#line 758
        bp = (u_int16_t *)bufp->page;
#line 759
        if (*(bp + 0)) {
#line 760
          goto while_break___0;
        }
#line 751
        bucket ++;
#line 751
        hashp->cndx = 1;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 762
      hashp->cbucket = (int )bucket;
#line 763
      if (hashp->cbucket > hashp->hdr.max_bucket) {
#line 764
        hashp->cbucket = -1;
#line 765
        return (1);
      }
    }
    {
#line 774
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 774
      if (! ((int )*(bp + (hashp->cndx + 1)) == 0)) {
#line 774
        goto while_break___1;
      }
      {
#line 775
      tmp___3 = __get_buf(hashp, (u_int32_t )*(bp + hashp->cndx), bufp, 0);
#line 775
      hashp->cpage = tmp___3;
#line 775
      bufp = tmp___3;
      }
#line 777
      if (! bufp) {
#line 778
        return (-1);
      }
#line 779
      bp = (u_int16_t *)bufp->page;
#line 780
      hashp->cndx = 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 782
    if (! *(bp + 0)) {
#line 783
      hashp->cpage = (BUFHEAD *)((void *)0);
#line 784
      (hashp->cbucket) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  ndx = (u_int16_t )hashp->cndx;
#line 788
  if ((int )*(bp + ((int )ndx + 1)) < 4) {
    {
#line 789
    tmp___4 = __big_keydata(hashp, bufp, key, data, 1);
    }
#line 789
    if (tmp___4) {
#line 790
      return (-1);
    }
  } else {
#line 792
    key->data = (void *)((u_char *)(hashp->cpage)->page + (int )*(bp + ndx));
#line 793
    if ((int )ndx > 1) {
#line 793
      tmp___5 = (int )*(bp + ((int )ndx - 1));
    } else {
#line 793
      tmp___5 = hashp->hdr.bsize;
    }
#line 793
    key->size = (size_t )(tmp___5 - (int )*(bp + ndx));
#line 794
    data->data = (void *)((u_char *)(hashp->cpage)->page + (int )*(bp + ((int )ndx + 1)));
#line 795
    data->size = (size_t )((int )*(bp + ndx) - (int )*(bp + ((int )ndx + 1)));
#line 796
    ndx = (u_int16_t )((int )ndx + 2);
#line 797
    if ((int )ndx > (int )*(bp + 0)) {
#line 798
      hashp->cpage = (BUFHEAD *)((void *)0);
#line 799
      (hashp->cbucket) ++;
#line 800
      hashp->cndx = 1;
    } else {
#line 802
      hashp->cndx = (int )ndx;
    }
  }
#line 804
  return (0);
}
}
#line 814 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
extern int __expand_table(HTAB *hashp ) 
{ 
  u_int32_t old_bucket ;
  u_int32_t new_bucket ;
  int dirsize ;
  int new_segnum ;
  int spare_ndx ;
  void *tmp___1 ;
  SEGMENT tmp___2 ;
  void *tmp___3 ;
  u_int32_t tmp___4 ;
  int tmp___5 ;

  {
#line 824
  (hashp->hdr.max_bucket) ++;
#line 824
  new_bucket = (u_int32_t )hashp->hdr.max_bucket;
#line 825
  old_bucket = (u_int32_t )(hashp->hdr.max_bucket & hashp->hdr.low_mask);
#line 827
  new_segnum = (int )(new_bucket >> hashp->hdr.sshift);
#line 830
  if (new_segnum >= hashp->nsegs) {
#line 832
    if (new_segnum >= hashp->hdr.dsize) {
      {
#line 834
      dirsize = (int )((unsigned long )hashp->hdr.dsize * sizeof(SEGMENT *));
#line 835
      tmp___1 = hash_realloc(& hashp->dir, dirsize, dirsize << 1);
      }
#line 835
      if (! tmp___1) {
#line 836
        return (-1);
      }
#line 837
      hashp->hdr.dsize = dirsize << 1;
    }
    {
#line 839
    tmp___3 = calloc((size_t )hashp->hdr.ssize, sizeof(SEGMENT ));
#line 839
    tmp___2 = (SEGMENT )tmp___3;
#line 839
    *(hashp->dir + new_segnum) = tmp___2;
    }
#line 839
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 841
      return (-1);
    }
#line 842
    (hashp->exsegs) ++;
#line 843
    (hashp->nsegs) ++;
  }
  {
#line 850
  tmp___4 = __hash_log2((u_int32_t )(hashp->hdr.max_bucket + 1));
#line 850
  spare_ndx = (int )tmp___4;
  }
#line 851
  if (spare_ndx > hashp->hdr.ovfl_point) {
#line 852
    hashp->hdr.spares[spare_ndx] = hashp->hdr.spares[hashp->hdr.ovfl_point];
#line 853
    hashp->hdr.ovfl_point = spare_ndx;
  }
#line 856
  if (new_bucket > (u_int32_t )hashp->hdr.high_mask) {
#line 858
    hashp->hdr.low_mask = hashp->hdr.high_mask;
#line 859
    hashp->hdr.high_mask = (int )(new_bucket | (unsigned int )hashp->hdr.low_mask);
  }
  {
#line 862
  tmp___5 = __split_page(hashp, old_bucket, new_bucket);
  }
#line 862
  return (tmp___5);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static void *hash_realloc(SEGMENT **p_ptr , int oldsize , int newsize ) 
{ 
  register void *p ;

  {
  {
#line 876
  p = malloc((size_t )newsize);
  }
#line 876
  if (p) {
    {
#line 877
    memmove(p, (void const   *)*p_ptr, (size_t )oldsize);
#line 878
    memset((void *)((char *)p + oldsize), 0, (size_t )(newsize - oldsize));
#line 879
    free((void *)*p_ptr);
#line 880
    *p_ptr = (SEGMENT *)p;
    }
  }
#line 882
  return (p);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
extern u_int32_t __call_hash(HTAB *hashp , char *k , int len ) 
{ 
  int n ;
  int bucket ;
  u_int32_t tmp___1 ;

  {
  {
#line 893
  tmp___1 = (*(hashp->hash))((void const   *)k, (size_t )len);
#line 893
  n = (int )tmp___1;
#line 894
  bucket = n & hashp->hdr.high_mask;
  }
#line 895
  if (bucket > hashp->hdr.max_bucket) {
#line 896
    bucket &= hashp->hdr.low_mask;
  }
#line 897
  return ((u_int32_t )bucket);
}
}
#line 905 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int alloc_segs(HTAB *hashp , int nsegs ) 
{ 
  register int i ;
  register SEGMENT store ;
  int save_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  SEGMENT *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 915
  tmp___4 = calloc((size_t )hashp->hdr.dsize, sizeof(SEGMENT *));
#line 915
  tmp___3 = (SEGMENT *)tmp___4;
#line 915
  hashp->dir = tmp___3;
  }
#line 915
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 917
    tmp___1 = __errno_location();
#line 917
    save_errno = *tmp___1;
#line 918
    hdestroy(hashp);
#line 919
    tmp___2 = __errno_location();
#line 919
    *tmp___2 = save_errno;
    }
#line 920
    return (-1);
  }
  {
#line 923
  tmp___7 = calloc((size_t )(nsegs << hashp->hdr.sshift), sizeof(SEGMENT ));
#line 923
  store = (SEGMENT )tmp___7;
  }
#line 923
  if ((unsigned long )store == (unsigned long )((void *)0)) {
    {
#line 925
    tmp___5 = __errno_location();
#line 925
    save_errno = *tmp___5;
#line 926
    hdestroy(hashp);
#line 927
    tmp___6 = __errno_location();
#line 927
    *tmp___6 = save_errno;
    }
#line 928
    return (-1);
  }
#line 930
  i = 0;
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 930
    if (! (i < nsegs)) {
#line 930
      goto while_break;
    }
#line 931
    *(hashp->dir + i) = store + (i << hashp->hdr.sshift);
#line 930
    i ++;
#line 930
    (hashp->nsegs) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 932
  return (0);
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static void swap_header_copy(HASHHDR *srcp , HASHHDR *destp ) 
{ 
  int i ;

  {
#line 945
  *((char *)(& destp->magic) + 0) = *((char *)(& srcp->magic) + 3);
#line 945
  *((char *)(& destp->magic) + 1) = *((char *)(& srcp->magic) + 2);
#line 945
  *((char *)(& destp->magic) + 2) = *((char *)(& srcp->magic) + 1);
#line 945
  *((char *)(& destp->magic) + 3) = *((char *)(& srcp->magic) + 0);
#line 946
  *((char *)(& destp->version) + 0) = *((char *)(& srcp->version) + 3);
#line 946
  *((char *)(& destp->version) + 1) = *((char *)(& srcp->version) + 2);
#line 946
  *((char *)(& destp->version) + 2) = *((char *)(& srcp->version) + 1);
#line 946
  *((char *)(& destp->version) + 3) = *((char *)(& srcp->version) + 0);
#line 947
  *((char *)(& destp->lorder) + 0) = *((char *)(& srcp->lorder) + 3);
#line 947
  *((char *)(& destp->lorder) + 1) = *((char *)(& srcp->lorder) + 2);
#line 947
  *((char *)(& destp->lorder) + 2) = *((char *)(& srcp->lorder) + 1);
#line 947
  *((char *)(& destp->lorder) + 3) = *((char *)(& srcp->lorder) + 0);
#line 948
  *((char *)(& destp->bsize) + 0) = *((char *)(& srcp->bsize) + 3);
#line 948
  *((char *)(& destp->bsize) + 1) = *((char *)(& srcp->bsize) + 2);
#line 948
  *((char *)(& destp->bsize) + 2) = *((char *)(& srcp->bsize) + 1);
#line 948
  *((char *)(& destp->bsize) + 3) = *((char *)(& srcp->bsize) + 0);
#line 949
  *((char *)(& destp->bshift) + 0) = *((char *)(& srcp->bshift) + 3);
#line 949
  *((char *)(& destp->bshift) + 1) = *((char *)(& srcp->bshift) + 2);
#line 949
  *((char *)(& destp->bshift) + 2) = *((char *)(& srcp->bshift) + 1);
#line 949
  *((char *)(& destp->bshift) + 3) = *((char *)(& srcp->bshift) + 0);
#line 950
  *((char *)(& destp->dsize) + 0) = *((char *)(& srcp->dsize) + 3);
#line 950
  *((char *)(& destp->dsize) + 1) = *((char *)(& srcp->dsize) + 2);
#line 950
  *((char *)(& destp->dsize) + 2) = *((char *)(& srcp->dsize) + 1);
#line 950
  *((char *)(& destp->dsize) + 3) = *((char *)(& srcp->dsize) + 0);
#line 951
  *((char *)(& destp->ssize) + 0) = *((char *)(& srcp->ssize) + 3);
#line 951
  *((char *)(& destp->ssize) + 1) = *((char *)(& srcp->ssize) + 2);
#line 951
  *((char *)(& destp->ssize) + 2) = *((char *)(& srcp->ssize) + 1);
#line 951
  *((char *)(& destp->ssize) + 3) = *((char *)(& srcp->ssize) + 0);
#line 952
  *((char *)(& destp->sshift) + 0) = *((char *)(& srcp->sshift) + 3);
#line 952
  *((char *)(& destp->sshift) + 1) = *((char *)(& srcp->sshift) + 2);
#line 952
  *((char *)(& destp->sshift) + 2) = *((char *)(& srcp->sshift) + 1);
#line 952
  *((char *)(& destp->sshift) + 3) = *((char *)(& srcp->sshift) + 0);
#line 953
  *((char *)(& destp->ovfl_point) + 0) = *((char *)(& srcp->ovfl_point) + 3);
#line 953
  *((char *)(& destp->ovfl_point) + 1) = *((char *)(& srcp->ovfl_point) + 2);
#line 953
  *((char *)(& destp->ovfl_point) + 2) = *((char *)(& srcp->ovfl_point) + 1);
#line 953
  *((char *)(& destp->ovfl_point) + 3) = *((char *)(& srcp->ovfl_point) + 0);
#line 954
  *((char *)(& destp->last_freed) + 0) = *((char *)(& srcp->last_freed) + 3);
#line 954
  *((char *)(& destp->last_freed) + 1) = *((char *)(& srcp->last_freed) + 2);
#line 954
  *((char *)(& destp->last_freed) + 2) = *((char *)(& srcp->last_freed) + 1);
#line 954
  *((char *)(& destp->last_freed) + 3) = *((char *)(& srcp->last_freed) + 0);
#line 955
  *((char *)(& destp->max_bucket) + 0) = *((char *)(& srcp->max_bucket) + 3);
#line 955
  *((char *)(& destp->max_bucket) + 1) = *((char *)(& srcp->max_bucket) + 2);
#line 955
  *((char *)(& destp->max_bucket) + 2) = *((char *)(& srcp->max_bucket) + 1);
#line 955
  *((char *)(& destp->max_bucket) + 3) = *((char *)(& srcp->max_bucket) + 0);
#line 956
  *((char *)(& destp->high_mask) + 0) = *((char *)(& srcp->high_mask) + 3);
#line 956
  *((char *)(& destp->high_mask) + 1) = *((char *)(& srcp->high_mask) + 2);
#line 956
  *((char *)(& destp->high_mask) + 2) = *((char *)(& srcp->high_mask) + 1);
#line 956
  *((char *)(& destp->high_mask) + 3) = *((char *)(& srcp->high_mask) + 0);
#line 957
  *((char *)(& destp->low_mask) + 0) = *((char *)(& srcp->low_mask) + 3);
#line 957
  *((char *)(& destp->low_mask) + 1) = *((char *)(& srcp->low_mask) + 2);
#line 957
  *((char *)(& destp->low_mask) + 2) = *((char *)(& srcp->low_mask) + 1);
#line 957
  *((char *)(& destp->low_mask) + 3) = *((char *)(& srcp->low_mask) + 0);
#line 958
  *((char *)(& destp->ffactor) + 0) = *((char *)(& srcp->ffactor) + 3);
#line 958
  *((char *)(& destp->ffactor) + 1) = *((char *)(& srcp->ffactor) + 2);
#line 958
  *((char *)(& destp->ffactor) + 2) = *((char *)(& srcp->ffactor) + 1);
#line 958
  *((char *)(& destp->ffactor) + 3) = *((char *)(& srcp->ffactor) + 0);
#line 959
  *((char *)(& destp->nkeys) + 0) = *((char *)(& srcp->nkeys) + 3);
#line 959
  *((char *)(& destp->nkeys) + 1) = *((char *)(& srcp->nkeys) + 2);
#line 959
  *((char *)(& destp->nkeys) + 2) = *((char *)(& srcp->nkeys) + 1);
#line 959
  *((char *)(& destp->nkeys) + 3) = *((char *)(& srcp->nkeys) + 0);
#line 960
  *((char *)(& destp->hdrpages) + 0) = *((char *)(& srcp->hdrpages) + 3);
#line 960
  *((char *)(& destp->hdrpages) + 1) = *((char *)(& srcp->hdrpages) + 2);
#line 960
  *((char *)(& destp->hdrpages) + 2) = *((char *)(& srcp->hdrpages) + 1);
#line 960
  *((char *)(& destp->hdrpages) + 3) = *((char *)(& srcp->hdrpages) + 0);
#line 961
  *((char *)(& destp->h_charkey) + 0) = *((char *)(& srcp->h_charkey) + 3);
#line 961
  *((char *)(& destp->h_charkey) + 1) = *((char *)(& srcp->h_charkey) + 2);
#line 961
  *((char *)(& destp->h_charkey) + 2) = *((char *)(& srcp->h_charkey) + 1);
#line 961
  *((char *)(& destp->h_charkey) + 3) = *((char *)(& srcp->h_charkey) + 0);
#line 962
  i = 0;
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 962
    if (! (i < 32)) {
#line 962
      goto while_break;
    }
#line 963
    *((char *)(& destp->spares[i]) + 0) = *((char *)(& srcp->spares[i]) + 3);
#line 963
    *((char *)(& destp->spares[i]) + 1) = *((char *)(& srcp->spares[i]) + 2);
#line 963
    *((char *)(& destp->spares[i]) + 2) = *((char *)(& srcp->spares[i]) + 1);
#line 963
    *((char *)(& destp->spares[i]) + 3) = *((char *)(& srcp->spares[i]) + 0);
#line 964
    *((char *)(& destp->bitmaps[i]) + 0) = *((char *)(& srcp->bitmaps[i]) + 1);
#line 964
    *((char *)(& destp->bitmaps[i]) + 1) = *((char *)(& srcp->bitmaps[i]) + 0);
#line 962
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 966
  return;
}
}
#line 968 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static void swap_header(HTAB *hashp ) 
{ 
  HASHHDR *hdrp ;
  int i ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int32_t _tmp___4 ;
  u_int32_t _tmp___5 ;
  u_int32_t _tmp___6 ;
  u_int32_t _tmp___7 ;
  u_int32_t _tmp___8 ;
  u_int32_t _tmp___9 ;
  u_int32_t _tmp___10 ;
  u_int32_t _tmp___11 ;
  u_int32_t _tmp___12 ;
  u_int32_t _tmp___13 ;
  u_int32_t _tmp___14 ;
  u_int32_t _tmp___15 ;
  u_int32_t _tmp___16 ;
  u_int16_t _tmp___17 ;

  {
#line 975
  hdrp = & hashp->hdr;
#line 977
  _tmp = (u_int32_t )hdrp->magic;
#line 977
  *((char *)(& hdrp->magic) + 0) = *((char *)(& _tmp) + 3);
#line 977
  *((char *)(& hdrp->magic) + 1) = *((char *)(& _tmp) + 2);
#line 977
  *((char *)(& hdrp->magic) + 2) = *((char *)(& _tmp) + 1);
#line 977
  *((char *)(& hdrp->magic) + 3) = *((char *)(& _tmp) + 0);
#line 978
  _tmp___0 = (u_int32_t )hdrp->version;
#line 978
  *((char *)(& hdrp->version) + 0) = *((char *)(& _tmp___0) + 3);
#line 978
  *((char *)(& hdrp->version) + 1) = *((char *)(& _tmp___0) + 2);
#line 978
  *((char *)(& hdrp->version) + 2) = *((char *)(& _tmp___0) + 1);
#line 978
  *((char *)(& hdrp->version) + 3) = *((char *)(& _tmp___0) + 0);
#line 979
  _tmp___1 = hdrp->lorder;
#line 979
  *((char *)(& hdrp->lorder) + 0) = *((char *)(& _tmp___1) + 3);
#line 979
  *((char *)(& hdrp->lorder) + 1) = *((char *)(& _tmp___1) + 2);
#line 979
  *((char *)(& hdrp->lorder) + 2) = *((char *)(& _tmp___1) + 1);
#line 979
  *((char *)(& hdrp->lorder) + 3) = *((char *)(& _tmp___1) + 0);
#line 980
  _tmp___2 = (u_int32_t )hdrp->bsize;
#line 980
  *((char *)(& hdrp->bsize) + 0) = *((char *)(& _tmp___2) + 3);
#line 980
  *((char *)(& hdrp->bsize) + 1) = *((char *)(& _tmp___2) + 2);
#line 980
  *((char *)(& hdrp->bsize) + 2) = *((char *)(& _tmp___2) + 1);
#line 980
  *((char *)(& hdrp->bsize) + 3) = *((char *)(& _tmp___2) + 0);
#line 981
  _tmp___3 = (u_int32_t )hdrp->bshift;
#line 981
  *((char *)(& hdrp->bshift) + 0) = *((char *)(& _tmp___3) + 3);
#line 981
  *((char *)(& hdrp->bshift) + 1) = *((char *)(& _tmp___3) + 2);
#line 981
  *((char *)(& hdrp->bshift) + 2) = *((char *)(& _tmp___3) + 1);
#line 981
  *((char *)(& hdrp->bshift) + 3) = *((char *)(& _tmp___3) + 0);
#line 982
  _tmp___4 = (u_int32_t )hdrp->dsize;
#line 982
  *((char *)(& hdrp->dsize) + 0) = *((char *)(& _tmp___4) + 3);
#line 982
  *((char *)(& hdrp->dsize) + 1) = *((char *)(& _tmp___4) + 2);
#line 982
  *((char *)(& hdrp->dsize) + 2) = *((char *)(& _tmp___4) + 1);
#line 982
  *((char *)(& hdrp->dsize) + 3) = *((char *)(& _tmp___4) + 0);
#line 983
  _tmp___5 = (u_int32_t )hdrp->ssize;
#line 983
  *((char *)(& hdrp->ssize) + 0) = *((char *)(& _tmp___5) + 3);
#line 983
  *((char *)(& hdrp->ssize) + 1) = *((char *)(& _tmp___5) + 2);
#line 983
  *((char *)(& hdrp->ssize) + 2) = *((char *)(& _tmp___5) + 1);
#line 983
  *((char *)(& hdrp->ssize) + 3) = *((char *)(& _tmp___5) + 0);
#line 984
  _tmp___6 = (u_int32_t )hdrp->sshift;
#line 984
  *((char *)(& hdrp->sshift) + 0) = *((char *)(& _tmp___6) + 3);
#line 984
  *((char *)(& hdrp->sshift) + 1) = *((char *)(& _tmp___6) + 2);
#line 984
  *((char *)(& hdrp->sshift) + 2) = *((char *)(& _tmp___6) + 1);
#line 984
  *((char *)(& hdrp->sshift) + 3) = *((char *)(& _tmp___6) + 0);
#line 985
  _tmp___7 = (u_int32_t )hdrp->ovfl_point;
#line 985
  *((char *)(& hdrp->ovfl_point) + 0) = *((char *)(& _tmp___7) + 3);
#line 985
  *((char *)(& hdrp->ovfl_point) + 1) = *((char *)(& _tmp___7) + 2);
#line 985
  *((char *)(& hdrp->ovfl_point) + 2) = *((char *)(& _tmp___7) + 1);
#line 985
  *((char *)(& hdrp->ovfl_point) + 3) = *((char *)(& _tmp___7) + 0);
#line 986
  _tmp___8 = (u_int32_t )hdrp->last_freed;
#line 986
  *((char *)(& hdrp->last_freed) + 0) = *((char *)(& _tmp___8) + 3);
#line 986
  *((char *)(& hdrp->last_freed) + 1) = *((char *)(& _tmp___8) + 2);
#line 986
  *((char *)(& hdrp->last_freed) + 2) = *((char *)(& _tmp___8) + 1);
#line 986
  *((char *)(& hdrp->last_freed) + 3) = *((char *)(& _tmp___8) + 0);
#line 987
  _tmp___9 = (u_int32_t )hdrp->max_bucket;
#line 987
  *((char *)(& hdrp->max_bucket) + 0) = *((char *)(& _tmp___9) + 3);
#line 987
  *((char *)(& hdrp->max_bucket) + 1) = *((char *)(& _tmp___9) + 2);
#line 987
  *((char *)(& hdrp->max_bucket) + 2) = *((char *)(& _tmp___9) + 1);
#line 987
  *((char *)(& hdrp->max_bucket) + 3) = *((char *)(& _tmp___9) + 0);
#line 988
  _tmp___10 = (u_int32_t )hdrp->high_mask;
#line 988
  *((char *)(& hdrp->high_mask) + 0) = *((char *)(& _tmp___10) + 3);
#line 988
  *((char *)(& hdrp->high_mask) + 1) = *((char *)(& _tmp___10) + 2);
#line 988
  *((char *)(& hdrp->high_mask) + 2) = *((char *)(& _tmp___10) + 1);
#line 988
  *((char *)(& hdrp->high_mask) + 3) = *((char *)(& _tmp___10) + 0);
#line 989
  _tmp___11 = (u_int32_t )hdrp->low_mask;
#line 989
  *((char *)(& hdrp->low_mask) + 0) = *((char *)(& _tmp___11) + 3);
#line 989
  *((char *)(& hdrp->low_mask) + 1) = *((char *)(& _tmp___11) + 2);
#line 989
  *((char *)(& hdrp->low_mask) + 2) = *((char *)(& _tmp___11) + 1);
#line 989
  *((char *)(& hdrp->low_mask) + 3) = *((char *)(& _tmp___11) + 0);
#line 990
  _tmp___12 = (u_int32_t )hdrp->ffactor;
#line 990
  *((char *)(& hdrp->ffactor) + 0) = *((char *)(& _tmp___12) + 3);
#line 990
  *((char *)(& hdrp->ffactor) + 1) = *((char *)(& _tmp___12) + 2);
#line 990
  *((char *)(& hdrp->ffactor) + 2) = *((char *)(& _tmp___12) + 1);
#line 990
  *((char *)(& hdrp->ffactor) + 3) = *((char *)(& _tmp___12) + 0);
#line 991
  _tmp___13 = (u_int32_t )hdrp->nkeys;
#line 991
  *((char *)(& hdrp->nkeys) + 0) = *((char *)(& _tmp___13) + 3);
#line 991
  *((char *)(& hdrp->nkeys) + 1) = *((char *)(& _tmp___13) + 2);
#line 991
  *((char *)(& hdrp->nkeys) + 2) = *((char *)(& _tmp___13) + 1);
#line 991
  *((char *)(& hdrp->nkeys) + 3) = *((char *)(& _tmp___13) + 0);
#line 992
  _tmp___14 = (u_int32_t )hdrp->hdrpages;
#line 992
  *((char *)(& hdrp->hdrpages) + 0) = *((char *)(& _tmp___14) + 3);
#line 992
  *((char *)(& hdrp->hdrpages) + 1) = *((char *)(& _tmp___14) + 2);
#line 992
  *((char *)(& hdrp->hdrpages) + 2) = *((char *)(& _tmp___14) + 1);
#line 992
  *((char *)(& hdrp->hdrpages) + 3) = *((char *)(& _tmp___14) + 0);
#line 993
  _tmp___15 = (u_int32_t )hdrp->h_charkey;
#line 993
  *((char *)(& hdrp->h_charkey) + 0) = *((char *)(& _tmp___15) + 3);
#line 993
  *((char *)(& hdrp->h_charkey) + 1) = *((char *)(& _tmp___15) + 2);
#line 993
  *((char *)(& hdrp->h_charkey) + 2) = *((char *)(& _tmp___15) + 1);
#line 993
  *((char *)(& hdrp->h_charkey) + 3) = *((char *)(& _tmp___15) + 0);
#line 994
  i = 0;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! (i < 32)) {
#line 994
      goto while_break;
    }
#line 995
    _tmp___16 = (u_int32_t )hdrp->spares[i];
#line 995
    *((char *)(& hdrp->spares[i]) + 0) = *((char *)(& _tmp___16) + 3);
#line 995
    *((char *)(& hdrp->spares[i]) + 1) = *((char *)(& _tmp___16) + 2);
#line 995
    *((char *)(& hdrp->spares[i]) + 2) = *((char *)(& _tmp___16) + 1);
#line 995
    *((char *)(& hdrp->spares[i]) + 3) = *((char *)(& _tmp___16) + 0);
#line 996
    _tmp___17 = hdrp->bitmaps[i];
#line 996
    *((char *)(& hdrp->bitmaps[i]) + 0) = *((char *)(& _tmp___17) + 1);
#line 996
    *((char *)(& hdrp->bitmaps[i]) + 1) = *((char *)(& _tmp___17) + 0);
#line 994
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 998
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/extern.h"
EPG *__rec_search(BTREE *t , u_int32_t recno , enum SRCHOP op ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_search.c"
EPG *__rec_search(BTREE *t , u_int32_t recno , enum SRCHOP op ) 
{ 
  register u_int16_t index ;
  register PAGE *h ;
  EPGNO *parent ;
  RINTERNAL *r ;
  u_int32_t pg ;
  u_int16_t top ;
  u_int32_t total ;
  int sverrno ;
  void *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;

  {
#line 78
  t->bt_sp = t->bt_stack;
#line 79
  pg = (u_int32_t )1;
#line 79
  total = (u_int32_t )0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    tmp___1 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 80
    h = (PAGE *)tmp___1;
    }
#line 80
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 81
      goto err;
    }
#line 82
    if (h->flags & 16U) {
#line 83
      t->bt_cur.page = h;
#line 84
      t->bt_cur.index = (u_int16_t )(recno - total);
#line 85
      return (& t->bt_cur);
    }
#line 87
    index = (u_int16_t )0;
#line 87
    top = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
    {
#line 87
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      r = (RINTERNAL *)((char *)h + (int )h->linp[index]);
#line 89
      index = (u_int16_t )((int )index + 1);
#line 89
      if ((int )index == (int )top) {
#line 90
        goto while_break___0;
      } else
#line 89
      if (total + r->nrecs > recno) {
#line 90
        goto while_break___0;
      }
#line 91
      total += r->nrecs;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    (t->bt_sp)->pgno = pg;
#line 94
    (t->bt_sp)->index = (u_int16_t )((int )index - 1);
#line 94
    (t->bt_sp) ++;
#line 96
    pg = r->pgno;
    {
#line 98
    if ((unsigned int )op == 0U) {
#line 98
      goto case_0;
    }
#line 102
    if ((unsigned int )op == 1U) {
#line 102
      goto case_1;
    }
#line 106
    if ((unsigned int )op == 2U) {
#line 106
      goto case_2;
    }
#line 97
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 99
    (((RINTERNAL *)((char *)h + (int )h->linp[(int )index - 1]))->nrecs) --;
#line 100
    __mpool_put(t->bt_mp, (void *)h, (u_int )1);
    }
#line 101
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 103
    (((RINTERNAL *)((char *)h + (int )h->linp[(int )index - 1]))->nrecs) ++;
#line 104
    __mpool_put(t->bt_mp, (void *)h, (u_int )1);
    }
#line 105
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 107
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 108
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  err: 
  {
#line 113
  tmp___2 = __errno_location();
#line 113
  sverrno = *tmp___2;
  }
#line 114
  if ((unsigned int )op != 2U) {
    {
#line 115
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 115
      if ((unsigned long )t->bt_sp == (unsigned long )(t->bt_stack)) {
#line 115
        parent = (EPGNO *)((void *)0);
      } else {
#line 115
        (t->bt_sp) --;
#line 115
        parent = t->bt_sp;
      }
#line 115
      if (! ((unsigned long )parent != (unsigned long )((void *)0))) {
#line 115
        goto while_break___1;
      }
      {
#line 116
      tmp___3 = __mpool_get(t->bt_mp, parent->pgno, (u_int )0);
#line 116
      h = (PAGE *)tmp___3;
      }
#line 116
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 117
        goto while_break___1;
      }
#line 118
      if ((unsigned int )op == 1U) {
#line 119
        (((RINTERNAL *)((char *)h + (int )h->linp[parent->index]))->nrecs) --;
      } else {
#line 121
        (((RINTERNAL *)((char *)h + (int )h->linp[parent->index]))->nrecs) ++;
      }
      {
#line 122
      __mpool_put(t->bt_mp, (void *)h, (u_int )1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 124
  tmp___4 = __errno_location();
#line 124
  *tmp___4 = sverrno;
  }
#line 125
  return ((EPG *)((void *)0));
}
}
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 620 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/extern.h"
extern BUFHEAD *__add_ovflpage(HTAB *hashp , BUFHEAD *bufp ) ;
#line 38
extern int __big_delete(HTAB *hashp , BUFHEAD *bufp ) ;
#line 39
extern int __big_insert(HTAB *hashp , BUFHEAD *bufp , DBT const   *key , DBT const   *val ) ;
#line 42
extern int __big_split(HTAB *hashp , BUFHEAD *op , BUFHEAD *np , BUFHEAD *big_keyp ,
                       int addr , u_int32_t obucket , SPLIT_RETURN *ret ) ;
#line 51
extern void __free_ovflpage(HTAB *hashp , BUFHEAD *obufp ) ;
#line 53
extern int __get_page(HTAB *hashp , char *p , u_int32_t bucket , int is_bucket , int is_disk ,
                      int is_bitmap ) ;
#line 57
extern void __reclaim_buf(HTAB *hashp , BUFHEAD *bp ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static u_int32_t *fetch_bitmap(HTAB *hashp , int ndx ) ;
#line 76
static u_int32_t first_free(u_int32_t map ) ;
#line 77
static int open_temp(HTAB *hashp ) ;
#line 78
static u_int16_t overflow_page(HTAB *hashp ) ;
#line 79
static void putpair(char *p , DBT const   *key , DBT const   *val ) ;
#line 80
static void squeeze_key(u_int16_t *sp , DBT const   *key , DBT const   *val ) ;
#line 81
static int ugly_split(HTAB *hashp , u_int32_t obucket , BUFHEAD *old_bufp , BUFHEAD *new_bufp ,
                      int copyto , int moved ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static void putpair(char *p , DBT const   *key , DBT const   *val ) 
{ 
  register u_int16_t *bp ;
  register u_int16_t n ;
  register u_int16_t off ;

  {
  {
#line 102
  bp = (u_int16_t *)p;
#line 105
  n = *(bp + 0);
#line 107
  off = (u_int16_t )((size_t const   )*(bp + ((int )*(bp + 0) + 2)) - key->size);
#line 108
  memmove((void *)(p + (int )off), (void const   *)key->data, (size_t )key->size);
#line 109
  n = (u_int16_t )((int )n + 1);
#line 109
  *(bp + n) = off;
#line 112
  off = (u_int16_t )((size_t const   )off - val->size);
#line 113
  memmove((void *)(p + (int )off), (void const   *)val->data, (size_t )val->size);
#line 114
  n = (u_int16_t )((int )n + 1);
#line 114
  *(bp + n) = off;
#line 117
  *(bp + 0) = n;
#line 118
  *(bp + ((int )n + 1)) = (u_int16_t )((unsigned long )off - (unsigned long )((int )n + 3) * sizeof(u_int16_t ));
#line 119
  *(bp + ((int )n + 2)) = off;
  }
#line 120
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
extern int __delpair(HTAB *hashp , BUFHEAD *bufp , int ndx ) 
{ 
  register u_int16_t *bp ;
  register u_int16_t newoff ;
  register int n ;
  u_int16_t pairlen ;
  int tmp___1 ;
  register int i ;
  register char *src ;
  register char *dst ;

  {
#line 137
  bp = (u_int16_t *)bufp->page;
#line 138
  n = (int )*(bp + 0);
#line 140
  if ((int )*(bp + (ndx + 1)) < 4) {
    {
#line 141
    tmp___1 = __big_delete(hashp, bufp);
    }
#line 141
    return (tmp___1);
  }
#line 142
  if (ndx != 1) {
#line 143
    newoff = *(bp + (ndx - 1));
  } else {
#line 145
    newoff = (u_int16_t )hashp->hdr.bsize;
  }
#line 146
  pairlen = (u_int16_t )((int )newoff - (int )*(bp + (ndx + 1)));
#line 148
  if (ndx != n - 1) {
    {
#line 151
    src = bufp->page + (int )*(bp + ((int )*(bp + 0) + 2));
#line 152
    dst = src + (int )pairlen;
#line 153
    memmove((void *)dst, (void const   *)src, (size_t )((int )*(bp + (ndx + 1)) - (int )*(bp + ((int )*(bp + 0) + 2))));
#line 156
    i = ndx + 2;
    }
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! (i <= n)) {
#line 156
        goto while_break;
      }
#line 157
      if ((int )*(bp + (i + 1)) == 0) {
#line 158
        *(bp + (i - 2)) = *(bp + i);
#line 159
        *(bp + (i - 1)) = *(bp + (i + 1));
      } else {
#line 161
        *(bp + (i - 2)) = (u_int16_t )((int )*(bp + i) + (int )pairlen);
#line 162
        *(bp + (i - 1)) = (u_int16_t )((int )*(bp + (i + 1)) + (int )pairlen);
      }
#line 156
      i += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 167
  *(bp + n) = (u_int16_t )((int )*(bp + ((int )*(bp + 0) + 2)) + (int )pairlen);
#line 168
  *(bp + (n - 1)) = (u_int16_t )((unsigned long )((int )*(bp + (n + 1)) + (int )pairlen) + 2UL * sizeof(u_int16_t ));
#line 169
  *(bp + 0) = (u_int16_t )(n - 2);
#line 170
  (hashp->hdr.nkeys) --;
#line 172
  bufp->flags = (char )((int )bufp->flags | 1);
#line 173
  return (0);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
extern int __split_page(HTAB *hashp , u_int32_t obucket , u_int32_t nbucket ) 
{ 
  register BUFHEAD *new_bufp ;
  register BUFHEAD *old_bufp ;
  register u_int16_t *ino ;
  register char *np ;
  DBT key ;
  DBT val ;
  int n ;
  int ndx ;
  int retval ;
  u_int16_t copyto ;
  u_int16_t diff ;
  u_int16_t off ;
  u_int16_t moved ;
  char *op ;
  u_int32_t tmp___1 ;

  {
  {
#line 193
  copyto = (u_int16_t )hashp->hdr.bsize;
#line 194
  off = (u_int16_t )hashp->hdr.bsize;
#line 195
  old_bufp = __get_buf(hashp, obucket, (BUFHEAD *)((void *)0), 0);
  }
#line 196
  if ((unsigned long )old_bufp == (unsigned long )((void *)0)) {
#line 197
    return (-1);
  }
  {
#line 198
  new_bufp = __get_buf(hashp, nbucket, (BUFHEAD *)((void *)0), 0);
  }
#line 199
  if ((unsigned long )new_bufp == (unsigned long )((void *)0)) {
#line 200
    return (-1);
  }
#line 202
  old_bufp->flags = (char )((int )old_bufp->flags | 9);
#line 203
  new_bufp->flags = (char )((int )new_bufp->flags | 9);
#line 205
  op = old_bufp->page;
#line 205
  ino = (u_int16_t *)op;
#line 206
  np = new_bufp->page;
#line 208
  moved = (u_int16_t )0;
#line 210
  n = 1;
#line 210
  ndx = 1;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (n < (int )*(ino + 0))) {
#line 210
      goto while_break;
    }
#line 211
    if ((int )*(ino + (n + 1)) < 4) {
      {
#line 212
      retval = ugly_split(hashp, obucket, old_bufp, new_bufp, (int )copyto, (int )moved);
#line 214
      old_bufp->flags = (char )((int )old_bufp->flags & -9);
#line 215
      new_bufp->flags = (char )((int )new_bufp->flags & -9);
      }
#line 216
      return (retval);
    }
    {
#line 219
    key.data = (void *)((u_char *)op + (int )*(ino + n));
#line 220
    key.size = (size_t )((int )off - (int )*(ino + n));
#line 222
    tmp___1 = __call_hash(hashp, (char *)key.data, (int )key.size);
    }
#line 222
    if (tmp___1 == obucket) {
#line 224
      diff = (u_int16_t )((int )copyto - (int )off);
#line 225
      if (diff) {
        {
#line 226
        copyto = (u_int16_t )((int )*(ino + (n + 1)) + (int )diff);
#line 227
        memmove((void *)(op + (int )copyto), (void const   *)(op + (int )*(ino + (n + 1))),
                (size_t )((int )off - (int )*(ino + (n + 1))));
#line 229
        *(ino + ndx) = (u_int16_t )(((int )copyto + (int )*(ino + n)) - (int )*(ino + (n + 1)));
#line 230
        *(ino + (ndx + 1)) = copyto;
        }
      } else {
#line 232
        copyto = *(ino + (n + 1));
      }
#line 233
      ndx += 2;
    } else {
      {
#line 236
      val.data = (void *)((u_char *)op + (int )*(ino + (n + 1)));
#line 237
      val.size = (size_t )((int )*(ino + n) - (int )*(ino + (n + 1)));
#line 238
      putpair(np, (DBT const   *)(& key), (DBT const   *)(& val));
#line 239
      moved = (u_int16_t )((int )moved + 2);
      }
    }
#line 242
    off = *(ino + (n + 1));
#line 210
    n += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  *(ino + 0) = (u_int16_t )((int )*(ino + 0) - (int )moved);
#line 247
  *(ino + ((int )*(ino + 0) + 1)) = (u_int16_t )((unsigned long )copyto - sizeof(u_int16_t ) * (unsigned long )((int )*(ino + 0) + 3));
#line 248
  *(ino + ((int )*(ino + 0) + 2)) = copyto;
#line 256
  old_bufp->flags = (char )((int )old_bufp->flags & -9);
#line 257
  new_bufp->flags = (char )((int )new_bufp->flags & -9);
#line 258
  return (0);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static int ugly_split(HTAB *hashp , u_int32_t obucket , BUFHEAD *old_bufp , BUFHEAD *new_bufp ,
                      int copyto , int moved ) 
{ 
  register BUFHEAD *bufp ;
  register u_int16_t *ino ;
  register u_int16_t *np ;
  register u_int16_t *op ;
  BUFHEAD *last_bfp ;
  DBT key ;
  DBT val ;
  SPLIT_RETURN ret ;
  u_int16_t n ;
  u_int16_t off ;
  u_int16_t ov_addr ;
  u_int16_t scopyto ;
  char *cino ;
  int tmp___1 ;
  u_int32_t tmp___2 ;

  {
#line 295
  bufp = old_bufp;
#line 296
  ino = (u_int16_t *)old_bufp->page;
#line 297
  np = (u_int16_t *)new_bufp->page;
#line 298
  op = (u_int16_t *)old_bufp->page;
#line 299
  last_bfp = (BUFHEAD *)((void *)0);
#line 300
  scopyto = (u_int16_t )copyto;
#line 302
  n = (u_int16_t )((int )*(ino + 0) - 1);
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! ((int )n < (int )*(ino + 0))) {
#line 303
      goto while_break;
    }
#line 304
    if ((int )*(ino + 2) < 4) {
#line 304
      if ((int )*(ino + 2) != 0) {
        {
#line 305
        tmp___1 = __big_split(hashp, old_bufp, new_bufp, bufp, (int )bufp->addr, obucket,
                              & ret);
        }
#line 305
        if (tmp___1) {
#line 307
          return (-1);
        }
#line 308
        old_bufp = ret.oldp;
#line 309
        if (! old_bufp) {
#line 310
          return (-1);
        }
#line 311
        op = (u_int16_t *)old_bufp->page;
#line 312
        new_bufp = ret.newp;
#line 313
        if (! new_bufp) {
#line 314
          return (-1);
        }
#line 315
        np = (u_int16_t *)new_bufp->page;
#line 316
        bufp = ret.nextp;
#line 317
        if (! bufp) {
#line 318
          return (0);
        }
#line 319
        cino = bufp->page;
#line 320
        ino = (u_int16_t *)cino;
#line 321
        last_bfp = ret.nextp;
      } else {
#line 304
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 322
    if ((int )*(ino + ((int )n + 1)) == 0) {
      {
#line 323
      ov_addr = *(ino + n);
#line 328
      *(ino + 0) = (u_int16_t )((int )*(ino + 0) - (moved + 2));
#line 329
      *(ino + ((int )*(ino + 0) + 1)) = (u_int16_t )((unsigned long )scopyto - sizeof(u_int16_t ) * (unsigned long )((int )*(ino + 0) + 3));
#line 331
      *(ino + ((int )*(ino + 0) + 2)) = scopyto;
#line 333
      bufp = __get_buf(hashp, (u_int32_t )ov_addr, bufp, 0);
      }
#line 334
      if (! bufp) {
#line 335
        return (-1);
      }
#line 337
      ino = (u_int16_t *)bufp->page;
#line 338
      n = (u_int16_t )1;
#line 339
      scopyto = (u_int16_t )hashp->hdr.bsize;
#line 340
      moved = 0;
#line 342
      if (last_bfp) {
        {
#line 343
        __free_ovflpage(hashp, last_bfp);
        }
      }
#line 344
      last_bfp = bufp;
    }
#line 347
    off = (u_int16_t )hashp->hdr.bsize;
#line 348
    n = (u_int16_t )1;
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 348
      if ((int )n < (int )*(ino + 0)) {
#line 348
        if (! ((int )*(ino + ((int )n + 1)) >= 4)) {
#line 348
          goto while_break___0;
        }
      } else {
#line 348
        goto while_break___0;
      }
      {
#line 349
      cino = (char *)ino;
#line 350
      key.data = (void *)((u_char *)cino + (int )*(ino + n));
#line 351
      key.size = (size_t )((int )off - (int )*(ino + n));
#line 352
      val.data = (void *)((u_char *)cino + (int )*(ino + ((int )n + 1)));
#line 353
      val.size = (size_t )((int )*(ino + n) - (int )*(ino + ((int )n + 1)));
#line 354
      off = *(ino + ((int )n + 1));
#line 356
      tmp___2 = __call_hash(hashp, (char *)key.data, (int )key.size);
      }
#line 356
      if (tmp___2 == obucket) {
#line 358
        if ((int )*(op + 2) >= 4) {
#line 358
          if (((2UL * sizeof(u_int16_t ) + key.size) + val.size) + 2UL * sizeof(u_int16_t ) <= (unsigned long )*(op + ((int )*(op + 0) + 1))) {
            {
#line 359
            putpair((char *)op, (DBT const   *)(& key), (DBT const   *)(& val));
            }
          } else {
#line 358
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 361
          old_bufp = __add_ovflpage(hashp, old_bufp);
          }
#line 363
          if (! old_bufp) {
#line 364
            return (-1);
          }
          {
#line 365
          op = (u_int16_t *)old_bufp->page;
#line 366
          putpair((char *)op, (DBT const   *)(& key), (DBT const   *)(& val));
          }
        }
#line 368
        old_bufp->flags = (char )((int )old_bufp->flags | 1);
      } else {
#line 371
        if ((int )*(np + 2) >= 4) {
#line 371
          if (((2UL * sizeof(u_int16_t ) + key.size) + val.size) + 2UL * sizeof(u_int16_t ) <= (unsigned long )*(np + ((int )*(np + 0) + 1))) {
            {
#line 372
            putpair((char *)np, (DBT const   *)(& key), (DBT const   *)(& val));
            }
          } else {
#line 371
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 374
          new_bufp = __add_ovflpage(hashp, new_bufp);
          }
#line 376
          if (! new_bufp) {
#line 377
            return (-1);
          }
          {
#line 378
          np = (u_int16_t *)new_bufp->page;
#line 379
          putpair((char *)np, (DBT const   *)(& key), (DBT const   *)(& val));
          }
        }
#line 381
        new_bufp->flags = (char )((int )new_bufp->flags | 1);
      }
#line 348
      n = (u_int16_t )((int )n + 2);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (last_bfp) {
    {
#line 386
    __free_ovflpage(hashp, last_bfp);
    }
  }
#line 387
  return (0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
extern int __addel(HTAB *hashp , BUFHEAD *bufp , DBT const   *key , DBT const   *val ) 
{ 
  register u_int16_t *bp ;
  register u_int16_t *sop ;
  int do_expand ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 406
  bp = (u_int16_t *)bufp->page;
#line 407
  do_expand = 0;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (*(bp + 0)) {
#line 408
      if (! ((int )*(bp + 2) < 4)) {
#line 408
        if (! ((int )*(bp + *(bp + 0)) < 4)) {
#line 408
          goto while_break;
        }
      }
    } else {
#line 408
      goto while_break;
    }
#line 410
    if ((int )*(bp + 2) == 3) {
#line 410
      if ((int )*(bp + 0) == 2) {
#line 413
        goto while_break;
      } else {
#line 410
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 414
    if ((int )*(bp + 2) < 4) {
#line 414
      if ((int )*(bp + *(bp + 0)) != 0) {
        {
#line 415
        bufp = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)), bufp, 0);
        }
#line 416
        if (! bufp) {
#line 417
          return (-1);
        }
#line 418
        bp = (u_int16_t *)bufp->page;
      } else {
#line 414
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 421
    if ((unsigned long )*(bp + ((int )*(bp + 0) + 1)) > (2UL * sizeof(u_int16_t ) + (unsigned long )key->size) + (unsigned long )val->size) {
      {
#line 422
      squeeze_key(bp, key, val);
      }
#line 423
      return (0);
    } else {
      {
#line 425
      bufp = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)), bufp, 0);
      }
#line 426
      if (! bufp) {
#line 427
        return (-1);
      }
#line 428
      bp = (u_int16_t *)bufp->page;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  if ((int )*(bp + 2) >= 4) {
#line 431
    if (((2UL * sizeof(u_int16_t ) + (unsigned long )key->size) + (unsigned long )val->size) + 2UL * sizeof(u_int16_t ) <= (unsigned long )*(bp + ((int )*(bp + 0) + 1))) {
      {
#line 432
      putpair(bufp->page, key, val);
      }
    } else {
#line 431
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 434
    do_expand = 1;
#line 435
    bufp = __add_ovflpage(hashp, bufp);
    }
#line 436
    if (! bufp) {
#line 437
      return (-1);
    }
#line 438
    sop = (u_int16_t *)bufp->page;
#line 440
    if ((int )*(sop + 2) >= 4) {
#line 440
      if (((2UL * sizeof(u_int16_t ) + (unsigned long )key->size) + (unsigned long )val->size) + 2UL * sizeof(u_int16_t ) <= (unsigned long )*(sop + ((int )*(sop + 0) + 1))) {
        {
#line 441
        putpair((char *)sop, key, val);
        }
      } else {
#line 440
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 443
      tmp___1 = __big_insert(hashp, bufp, key, val);
      }
#line 443
      if (tmp___1) {
#line 444
        return (-1);
      }
    }
  }
#line 446
  bufp->flags = (char )((int )bufp->flags | 1);
#line 451
  (hashp->hdr.nkeys) ++;
#line 452
  if (do_expand) {
    {
#line 454
    tmp___2 = __expand_table(hashp);
    }
#line 454
    return (tmp___2);
  } else
#line 452
  if (hashp->hdr.nkeys / (hashp->hdr.max_bucket + 1) > hashp->hdr.ffactor) {
    {
#line 454
    tmp___2 = __expand_table(hashp);
    }
#line 454
    return (tmp___2);
  }
#line 455
  return (0);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
extern BUFHEAD *__add_ovflpage(HTAB *hashp , BUFHEAD *bufp ) 
{ 
  register u_int16_t *sp ;
  u_int16_t ndx ;
  u_int16_t ovfl_num ;
  BUFHEAD *tmp___1 ;

  {
#line 474
  sp = (u_int16_t *)bufp->page;
#line 477
  if (hashp->hdr.ffactor == 65536) {
#line 478
    hashp->hdr.ffactor = (int )*(sp + 0) >> 1;
#line 479
    if (hashp->hdr.ffactor < 4) {
#line 480
      hashp->hdr.ffactor = 4;
    }
  }
  {
#line 482
  bufp->flags = (char )((int )bufp->flags | 1);
#line 483
  ovfl_num = overflow_page(hashp);
  }
#line 488
  if (! ovfl_num) {
#line 489
    return ((BUFHEAD *)((void *)0));
  } else {
    {
#line 488
    tmp___1 = __get_buf(hashp, (u_int32_t )ovfl_num, bufp, 1);
#line 488
    bufp->ovfl = tmp___1;
    }
#line 488
    if (! tmp___1) {
#line 489
      return ((BUFHEAD *)((void *)0));
    }
  }
#line 490
  (bufp->ovfl)->flags = (char )((int )(bufp->ovfl)->flags | 1);
#line 495
  ndx = *(sp + 0);
#line 501
  *(sp + ((int )ndx + 4)) = *(sp + ((int )*(sp + 0) + 2));
#line 502
  *(sp + ((int )ndx + 3)) = (u_int16_t )((unsigned long )*(sp + ((int )*(sp + 0) + 1)) - 2UL * sizeof(u_int16_t ));
#line 503
  *(sp + ((int )ndx + 1)) = ovfl_num;
#line 504
  *(sp + ((int )ndx + 2)) = (u_int16_t )0;
#line 505
  *(sp + 0) = (u_int16_t )((int )ndx + 2);
#line 509
  return (bufp->ovfl);
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
extern int __get_page(HTAB *hashp , char *p , u_int32_t bucket , int is_bucket , int is_disk ,
                      int is_bitmap ) 
{ 
  register int fd ;
  register int page ;
  register int size ;
  int rsize ;
  u_int16_t *bp ;
  u_int32_t tmp___1 ;
  int tmp___2 ;
  u_int32_t tmp___3 ;
  int tmp___4 ;
  __off_t tmp___5 ;
  ssize_t tmp___6 ;
  int *tmp___7 ;
  register int i ;
  register int max ;
  u_int32_t _tmp ;
  u_int16_t _tmp___0 ;
  u_int16_t _tmp___1 ;

  {
#line 528
  fd = hashp->fp;
#line 529
  size = hashp->hdr.bsize;
#line 531
  if (fd == -1) {
#line 532
    *((u_int16_t *)p + 0) = (u_int16_t )0;
#line 532
    *((u_int16_t *)p + 1) = (u_int16_t )((unsigned long )hashp->hdr.bsize - 3UL * sizeof(u_int16_t ));
#line 532
    *((u_int16_t *)p + 2) = (u_int16_t )hashp->hdr.bsize;
#line 533
    return (0);
  } else
#line 531
  if (! is_disk) {
#line 532
    *((u_int16_t *)p + 0) = (u_int16_t )0;
#line 532
    *((u_int16_t *)p + 1) = (u_int16_t )((unsigned long )hashp->hdr.bsize - 3UL * sizeof(u_int16_t ));
#line 532
    *((u_int16_t *)p + 2) = (u_int16_t )hashp->hdr.bsize;
#line 533
    return (0);
  }
#line 535
  if (is_bucket) {
#line 536
    if (bucket) {
      {
#line 536
      tmp___1 = __hash_log2(bucket + 1U);
#line 536
      tmp___2 = hashp->hdr.spares[tmp___1 - 1U];
      }
    } else {
#line 536
      tmp___2 = 0;
    }
#line 536
    page = (int )((bucket + (u_int32_t )hashp->hdr.hdrpages) + (u_int32_t )tmp___2);
  } else {
#line 538
    if ((1 << (bucket >> 11)) - 1) {
      {
#line 538
      tmp___3 = __hash_log2((u_int32_t )(((1 << (bucket >> 11)) - 1) + 1));
#line 538
      tmp___4 = hashp->hdr.spares[tmp___3 - 1U];
      }
    } else {
#line 538
      tmp___4 = 0;
    }
#line 538
    page = (int )((unsigned int )((((1 << (bucket >> 11)) - 1) + hashp->hdr.hdrpages) + tmp___4) + (bucket & 2047U));
  }
  {
#line 539
  tmp___5 = lseek(fd, (off_t )page << hashp->hdr.bshift, 0);
  }
#line 539
  if (tmp___5 == -1L) {
#line 541
    return (-1);
  } else {
    {
#line 539
    tmp___6 = read(fd, (void *)p, (size_t )size);
#line 539
    rsize = (int )tmp___6;
    }
#line 539
    if (rsize == -1) {
#line 541
      return (-1);
    }
  }
#line 542
  bp = (u_int16_t *)p;
#line 543
  if (! rsize) {
#line 544
    *(bp + 0) = (u_int16_t )0;
  } else
#line 546
  if (rsize != size) {
    {
#line 547
    tmp___7 = __errno_location();
#line 547
    *tmp___7 = 22;
    }
#line 548
    return (-1);
  }
#line 550
  if (! is_bitmap) {
#line 550
    if (! *(bp + 0)) {
#line 551
      *((u_int16_t *)p + 0) = (u_int16_t )0;
#line 551
      *((u_int16_t *)p + 1) = (u_int16_t )((unsigned long )hashp->hdr.bsize - 3UL * sizeof(u_int16_t ));
#line 551
      *((u_int16_t *)p + 2) = (u_int16_t )hashp->hdr.bsize;
    } else {
#line 550
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 553
  if (hashp->hdr.lorder != 1234U) {
#line 556
    if (is_bitmap) {
#line 557
      max = hashp->hdr.bsize >> 2;
#line 558
      i = 0;
      {
#line 558
      while (1) {
        while_continue: /* CIL Label */ ;
#line 558
        if (! (i < max)) {
#line 558
          goto while_break;
        }
#line 559
        _tmp = (u_int32_t )*((int *)p + i);
#line 559
        *((char *)((int *)p + i) + 0) = *((char *)(& _tmp) + 3);
#line 559
        *((char *)((int *)p + i) + 1) = *((char *)(& _tmp) + 2);
#line 559
        *((char *)((int *)p + i) + 2) = *((char *)(& _tmp) + 1);
#line 559
        *((char *)((int *)p + i) + 3) = *((char *)(& _tmp) + 0);
#line 558
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 561
      _tmp___0 = *(bp + 0);
#line 561
      *((char *)(bp + 0) + 0) = *((char *)(& _tmp___0) + 1);
#line 561
      *((char *)(bp + 0) + 1) = *((char *)(& _tmp___0) + 0);
#line 562
      max = (int )*(bp + 0) + 2;
#line 563
      i = 1;
      {
#line 563
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 563
        if (! (i <= max)) {
#line 563
          goto while_break___0;
        }
#line 564
        _tmp___1 = *(bp + i);
#line 564
        *((char *)(bp + i) + 0) = *((char *)(& _tmp___1) + 1);
#line 564
        *((char *)(bp + i) + 1) = *((char *)(& _tmp___1) + 0);
#line 563
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 567
  return (0);
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
extern int __put_page(HTAB *hashp , char *p , u_int32_t bucket , int is_bucket , int is_bitmap ) 
{ 
  register int fd ;
  register int page ;
  register int size ;
  int wsize ;
  int tmp___1 ;
  register int i ;
  register int max ;
  u_int32_t _tmp ;
  u_int16_t _tmp___0 ;
  u_int32_t tmp___2 ;
  int tmp___3 ;
  u_int32_t tmp___4 ;
  int tmp___5 ;
  __off_t tmp___6 ;
  ssize_t tmp___7 ;
  int *tmp___8 ;

  {
#line 587
  size = hashp->hdr.bsize;
#line 588
  if (hashp->fp == -1) {
    {
#line 588
    tmp___1 = open_temp(hashp);
    }
#line 588
    if (tmp___1) {
#line 589
      return (-1);
    }
  }
#line 590
  fd = hashp->fp;
#line 592
  if (hashp->hdr.lorder != 1234U) {
#line 596
    if (is_bitmap) {
#line 597
      max = hashp->hdr.bsize >> 2;
#line 598
      i = 0;
      {
#line 598
      while (1) {
        while_continue: /* CIL Label */ ;
#line 598
        if (! (i < max)) {
#line 598
          goto while_break;
        }
#line 599
        _tmp = (u_int32_t )*((int *)p + i);
#line 599
        *((char *)((int *)p + i) + 0) = *((char *)(& _tmp) + 3);
#line 599
        *((char *)((int *)p + i) + 1) = *((char *)(& _tmp) + 2);
#line 599
        *((char *)((int *)p + i) + 2) = *((char *)(& _tmp) + 1);
#line 599
        *((char *)((int *)p + i) + 3) = *((char *)(& _tmp) + 0);
#line 598
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 601
      max = (int )*((u_int16_t *)p + 0) + 2;
#line 602
      i = 0;
      {
#line 602
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 602
        if (! (i <= max)) {
#line 602
          goto while_break___0;
        }
#line 603
        _tmp___0 = *((u_int16_t *)p + i);
#line 603
        *((char *)((u_int16_t *)p + i) + 0) = *((char *)(& _tmp___0) + 1);
#line 603
        *((char *)((u_int16_t *)p + i) + 1) = *((char *)(& _tmp___0) + 0);
#line 602
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 606
  if (is_bucket) {
#line 607
    if (bucket) {
      {
#line 607
      tmp___2 = __hash_log2(bucket + 1U);
#line 607
      tmp___3 = hashp->hdr.spares[tmp___2 - 1U];
      }
    } else {
#line 607
      tmp___3 = 0;
    }
#line 607
    page = (int )((bucket + (u_int32_t )hashp->hdr.hdrpages) + (u_int32_t )tmp___3);
  } else {
#line 609
    if ((1 << (bucket >> 11)) - 1) {
      {
#line 609
      tmp___4 = __hash_log2((u_int32_t )(((1 << (bucket >> 11)) - 1) + 1));
#line 609
      tmp___5 = hashp->hdr.spares[tmp___4 - 1U];
      }
    } else {
#line 609
      tmp___5 = 0;
    }
#line 609
    page = (int )((unsigned int )((((1 << (bucket >> 11)) - 1) + hashp->hdr.hdrpages) + tmp___5) + (bucket & 2047U));
  }
  {
#line 610
  tmp___6 = lseek(fd, (off_t )page << hashp->hdr.bshift, 0);
  }
#line 610
  if (tmp___6 == -1L) {
#line 613
    return (-1);
  } else {
    {
#line 610
    tmp___7 = write(fd, (void const   *)p, (size_t )size);
#line 610
    wsize = (int )tmp___7;
    }
#line 610
    if (wsize == -1) {
#line 613
      return (-1);
    }
  }
#line 614
  if (wsize != size) {
    {
#line 615
    tmp___8 = __errno_location();
#line 615
    *tmp___8 = 22;
    }
#line 616
    return (-1);
  }
#line 618
  return (0);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
extern int __ibitmap(HTAB *hashp , int pnum , int nbits , int ndx ) 
{ 
  u_int32_t *ip ;
  int clearbytes ;
  int clearints ;
  void *tmp___1 ;

  {
  {
#line 634
  tmp___1 = malloc((size_t )hashp->hdr.bsize);
#line 634
  ip = (u_int32_t *)tmp___1;
  }
#line 634
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 635
    return (1);
  }
  {
#line 636
  (hashp->nmaps) ++;
#line 637
  clearints = ((nbits - 1) >> 5) + 1;
#line 638
  clearbytes = clearints << 2;
#line 639
  memset((void *)((char *)ip), 0, (size_t )clearbytes);
#line 640
  memset((void *)((char *)ip + clearbytes), 255, (size_t )(hashp->hdr.bsize - clearbytes));
#line 642
  *(ip + (clearints - 1)) = 4294967295U << (nbits & ((1 << 5) - 1));
#line 643
  *(ip + 0) |= 1U;
#line 644
  hashp->hdr.bitmaps[ndx] = (u_int16_t )pnum;
#line 645
  hashp->mapp[ndx] = ip;
  }
#line 646
  return (0);
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static u_int32_t first_free(u_int32_t map ) 
{ 
  register u_int32_t i ;
  register u_int32_t mask ;

  {
#line 655
  mask = (u_int32_t )1;
#line 656
  i = (u_int32_t )0;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (! (i < 32U)) {
#line 656
      goto while_break;
    }
#line 657
    if (! (mask & map)) {
#line 658
      return (i);
    }
#line 659
    mask <<= 1;
#line 656
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 661
  return (i);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static u_int16_t overflow_page(HTAB *hashp ) 
{ 
  register u_int32_t *freep ;
  register int max_free ;
  register int offset ;
  register int splitnum ;
  u_int16_t addr ;
  int bit ;
  int first_page ;
  int free_bit ;
  int free_page ;
  int i ;
  int in_use_bits ;
  int j ;
  int tmp___1 ;
  int tmp___2 ;
  u_int32_t tmp___3 ;

  {
#line 675
  splitnum = hashp->hdr.ovfl_point;
#line 676
  max_free = hashp->hdr.spares[splitnum];
#line 678
  free_page = (max_free - 1) >> (hashp->hdr.bshift + 3);
#line 679
  free_bit = (max_free - 1) & ((hashp->hdr.bsize << 3) - 1);
#line 682
  first_page = hashp->hdr.last_freed >> (hashp->hdr.bshift + 3);
#line 683
  i = first_page;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (i <= free_page)) {
#line 683
      goto while_break;
    }
#line 684
    freep = hashp->mapp[i];
#line 684
    if (! freep) {
      {
#line 684
      freep = fetch_bitmap(hashp, i);
      }
#line 684
      if (! freep) {
#line 686
        return ((u_int16_t )0);
      }
    }
#line 687
    if (i == free_page) {
#line 688
      in_use_bits = free_bit;
    } else {
#line 690
      in_use_bits = (hashp->hdr.bsize << 3) - 1;
    }
#line 692
    if (i == first_page) {
#line 693
      bit = hashp->hdr.last_freed & ((hashp->hdr.bsize << 3) - 1);
#line 695
      j = bit / 32;
#line 696
      bit &= -32;
    } else {
#line 698
      bit = 0;
#line 699
      j = 0;
    }
    {
#line 701
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 701
      if (! (bit <= in_use_bits)) {
#line 701
        goto while_break___0;
      }
#line 702
      if (*(freep + j) != 4294967295U) {
#line 703
        goto found;
      }
#line 701
      j ++;
#line 701
      bit += 32;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 683
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  hashp->hdr.last_freed = hashp->hdr.spares[splitnum];
#line 708
  (hashp->hdr.spares[splitnum]) ++;
#line 709
  if (splitnum) {
#line 709
    tmp___1 = hashp->hdr.spares[splitnum - 1];
  } else {
#line 709
    tmp___1 = 0;
  }
#line 709
  offset = hashp->hdr.spares[splitnum] - tmp___1;
#line 713
  if (offset > 2047) {
#line 714
    splitnum ++;
#line 714
    if (splitnum >= 32) {
      {
#line 715
      write(2, (void const   *)"HASH: Out of overflow pages.  Increase page size\n",
            sizeof("HASH: Out of overflow pages.  Increase page size\n") - 1UL);
      }
#line 716
      return ((u_int16_t )0);
    }
#line 718
    hashp->hdr.ovfl_point = splitnum;
#line 719
    hashp->hdr.spares[splitnum] = hashp->hdr.spares[splitnum - 1];
#line 720
    (hashp->hdr.spares[splitnum - 1]) --;
#line 721
    offset = 1;
  }
#line 725
  if (free_bit == (hashp->hdr.bsize << 3) - 1) {
#line 726
    free_page ++;
#line 727
    if (free_page >= 32) {
      {
#line 728
      write(2, (void const   *)"HASH: Out of overflow pages.  Increase page size\n",
            sizeof("HASH: Out of overflow pages.  Increase page size\n") - 1UL);
      }
#line 729
      return ((u_int16_t )0);
    }
    {
#line 742
    tmp___2 = __ibitmap(hashp, (int )(((u_int32_t )splitnum << 11) + (u_int32_t )offset),
                        1, free_page);
    }
#line 742
    if (tmp___2) {
#line 744
      return ((u_int16_t )0);
    }
#line 745
    (hashp->hdr.spares[splitnum]) ++;
#line 749
    offset ++;
#line 750
    if (offset > 2047) {
#line 751
      splitnum ++;
#line 751
      if (splitnum >= 32) {
        {
#line 752
        write(2, (void const   *)"HASH: Out of overflow pages.  Increase page size\n",
              sizeof("HASH: Out of overflow pages.  Increase page size\n") - 1UL);
        }
#line 754
        return ((u_int16_t )0);
      }
#line 756
      hashp->hdr.ovfl_point = splitnum;
#line 757
      hashp->hdr.spares[splitnum] = hashp->hdr.spares[splitnum - 1];
#line 758
      (hashp->hdr.spares[splitnum - 1]) --;
#line 759
      offset = 0;
    }
  } else {
#line 766
    free_bit ++;
#line 767
    *(freep + free_bit / 32) |= (unsigned int )(1 << free_bit % 32);
  }
#line 771
  addr = (u_int16_t )(((u_int32_t )splitnum << 11) + (u_int32_t )offset);
#line 776
  return (addr);
  found: 
  {
#line 779
  tmp___3 = first_free(*(freep + j));
#line 779
  bit = (int )((u_int32_t )bit + tmp___3);
#line 780
  *(freep + bit / 32) |= (unsigned int )(1 << bit % 32);
#line 790
  bit = (1 + bit) + i * (hashp->hdr.bsize << 3);
  }
#line 791
  if (bit >= hashp->hdr.last_freed) {
#line 792
    hashp->hdr.last_freed = bit - 1;
  }
#line 795
  i = 0;
  {
#line 795
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 795
    if (i < splitnum) {
#line 795
      if (! (bit > hashp->hdr.spares[i])) {
#line 795
        goto while_break___1;
      }
    } else {
#line 795
      goto while_break___1;
    }
#line 795
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 796
  if (i) {
#line 796
    offset = bit - hashp->hdr.spares[i - 1];
  } else {
#line 796
    offset = bit;
  }
#line 797
  if (offset >= 2047) {
#line 798
    return ((u_int16_t )0);
  }
#line 799
  addr = (u_int16_t )(((u_int32_t )i << 11) + (u_int32_t )offset);
#line 806
  return (addr);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
extern void __free_ovflpage(HTAB *hashp , BUFHEAD *obufp ) 
{ 
  register u_int16_t addr ;
  u_int32_t *freep ;
  int bit_address ;
  int free_page ;
  int free_bit ;
  u_int16_t ndx ;
  int tmp___1 ;

  {
#line 822
  addr = (u_int16_t )obufp->addr;
#line 826
  ndx = (u_int16_t )((int )addr >> 11);
#line 827
  if (ndx) {
#line 827
    tmp___1 = hashp->hdr.spares[(int )ndx - 1];
  } else {
#line 827
    tmp___1 = 0;
  }
#line 827
  bit_address = (tmp___1 + ((int )addr & 2047)) - 1;
#line 829
  if (bit_address < hashp->hdr.last_freed) {
#line 830
    hashp->hdr.last_freed = bit_address;
  }
#line 831
  free_page = bit_address >> (hashp->hdr.bshift + 3);
#line 832
  free_bit = bit_address & ((hashp->hdr.bsize << 3) - 1);
#line 834
  freep = hashp->mapp[free_page];
#line 834
  if (! freep) {
    {
#line 835
    freep = fetch_bitmap(hashp, free_page);
    }
  }
  {
#line 845
  *(freep + free_bit / 32) &= (unsigned int )(~ (1 << free_bit % 32));
#line 850
  __reclaim_buf(hashp, obufp);
  }
#line 851
  return;
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static char namestr[12]  = 
#line 863
  {      (char )'_',      (char )'h',      (char )'a',      (char )'s', 
        (char )'h',      (char )'X',      (char )'X',      (char )'X', 
        (char )'X',      (char )'X',      (char )'X',      (char )'\000'};
#line 858 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static int open_temp(HTAB *hashp ) 
{ 
  sigset_t set ;
  sigset_t oset ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 866
  sigfillset(& set);
#line 867
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)(& oset));
#line 868
  tmp___1 = mkstemp(namestr);
#line 868
  hashp->fp = tmp___1;
  }
#line 868
  if (tmp___1 != -1) {
    {
#line 869
    unlink((char const   *)(namestr));
#line 870
    fcntl(hashp->fp, 2, 1);
    }
  }
  {
#line 872
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& oset), (sigset_t */* __restrict  */)((sigset_t *)((void *)0)));
  }
#line 873
  if (hashp->fp != -1) {
#line 873
    tmp___2 = 0;
  } else {
#line 873
    tmp___2 = -1;
  }
#line 873
  return (tmp___2);
}
}
#line 880 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static void squeeze_key(u_int16_t *sp , DBT const   *key , DBT const   *val ) 
{ 
  register char *p ;
  u_int16_t free_space ;
  u_int16_t n ;
  u_int16_t off ;
  u_int16_t pageno ;

  {
  {
#line 888
  p = (char *)sp;
#line 889
  n = *(sp + 0);
#line 890
  free_space = *(sp + ((int )*(sp + 0) + 1));
#line 891
  off = *(sp + ((int )*(sp + 0) + 2));
#line 893
  pageno = *(sp + ((int )n - 1));
#line 894
  off = (u_int16_t )((size_t const   )off - key->size);
#line 895
  *(sp + ((int )n - 1)) = off;
#line 896
  memmove((void *)(p + (int )off), (void const   *)key->data, (size_t )key->size);
#line 897
  off = (u_int16_t )((size_t const   )off - val->size);
#line 898
  *(sp + n) = off;
#line 899
  memmove((void *)(p + (int )off), (void const   *)val->data, (size_t )val->size);
#line 900
  *(sp + 0) = (u_int16_t )((int )n + 2);
#line 901
  *(sp + ((int )n + 1)) = pageno;
#line 902
  *(sp + ((int )n + 2)) = (u_int16_t )0;
#line 903
  *(sp + ((int )*(sp + 0) + 1)) = (u_int16_t )((unsigned long )free_space - ((2UL * sizeof(u_int16_t ) + (unsigned long )key->size) + (unsigned long )val->size));
#line 904
  *(sp + ((int )*(sp + 0) + 2)) = off;
  }
#line 905
  return;
}
}
#line 907 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static u_int32_t *fetch_bitmap(HTAB *hashp , int ndx ) 
{ 
  u_int32_t *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 912
  if (ndx >= hashp->nmaps) {
#line 913
    return ((u_int32_t *)((void *)0));
  }
  {
#line 914
  tmp___2 = malloc((size_t )hashp->hdr.bsize);
#line 914
  tmp___1 = (u_int32_t *)tmp___2;
#line 914
  hashp->mapp[ndx] = tmp___1;
  }
#line 914
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 915
    return ((u_int32_t *)((void *)0));
  }
  {
#line 916
  tmp___3 = __get_page(hashp, (char *)hashp->mapp[ndx], (u_int32_t )hashp->hdr.bitmaps[ndx],
                       0, 1, 1);
  }
#line 916
  if (tmp___3) {
    {
#line 918
    free((void *)hashp->mapp[ndx]);
    }
#line 919
    return ((u_int32_t *)((void *)0));
  }
#line 921
  return (hashp->mapp[ndx]);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_log2.c"
u_int32_t __hash_log2(u_int32_t num ) 
{ 
  register u_int32_t i ;
  register u_int32_t limit ;

  {
#line 53
  limit = (u_int32_t )1;
#line 54
  i = (u_int32_t )0;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (limit < num)) {
#line 54
      goto while_break;
    }
#line 54
    limit <<= 1;
#line 54
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (i);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/extern.h"
int __bt_cmp(BTREE *t , DBT const   *k1 , EPG *e ) ;
#line 52
EPG *__bt_search(BTREE *t , DBT const   *key , int *exactp ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_search.c"
static int __bt_snext(BTREE *t , PAGE *h , DBT const   *key , int *exactp ) ;
#line 49
static int __bt_sprev(BTREE *t , PAGE *h , DBT const   *key , int *exactp ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_search.c"
EPG *__bt_search(BTREE *t , DBT const   *key , int *exactp ) 
{ 
  PAGE *h ;
  u_int16_t base ;
  u_int16_t index ;
  u_int16_t lim ;
  u_int32_t pg ;
  int cmp ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 76
  t->bt_sp = t->bt_stack;
#line 77
  pg = (u_int32_t )1;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    tmp___1 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 78
    h = (PAGE *)tmp___1;
    }
#line 78
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 79
      return ((EPG *)((void *)0));
    }
#line 82
    t->bt_cur.page = h;
#line 83
    base = (u_int16_t )0;
#line 83
    lim = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      if (! lim) {
#line 83
        goto while_break___0;
      }
      {
#line 84
      index = (u_int16_t )((int )base + ((int )lim >> 1));
#line 84
      t->bt_cur.index = index;
#line 85
      cmp = __bt_cmp(t, key, & t->bt_cur);
      }
#line 85
      if (cmp == 0) {
#line 86
        if (h->flags & 2U) {
#line 87
          *exactp = 1;
#line 88
          return (& t->bt_cur);
        }
#line 90
        goto next;
      }
#line 92
      if (cmp > 0) {
#line 93
        base = (u_int16_t )((int )index + 1);
#line 94
        lim = (u_int16_t )((int )lim - 1);
      }
#line 83
      lim = (u_int16_t )((int )lim >> 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 106
    if (h->flags & 2U) {
#line 107
      if (! (t->flags & 32U)) {
#line 108
        if ((int )base == 0) {
#line 108
          if (h->prevpg != 0U) {
            {
#line 108
            tmp___2 = __bt_sprev(t, h, key, exactp);
            }
#line 108
            if (tmp___2) {
#line 111
              return (& t->bt_cur);
            }
          }
        }
#line 112
        if ((unsigned long )base == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
#line 112
          if (h->nextpg != 0U) {
            {
#line 112
            tmp___3 = __bt_snext(t, h, key, exactp);
            }
#line 112
            if (tmp___3) {
#line 115
              return (& t->bt_cur);
            }
          }
        }
      }
#line 117
      *exactp = 0;
#line 118
      t->bt_cur.index = base;
#line 119
      return (& t->bt_cur);
    }
#line 129
    if (base) {
#line 129
      index = (u_int16_t )((int )base - 1);
    } else {
#line 129
      index = base;
    }
    next: 
    {
#line 131
    (t->bt_sp)->pgno = h->pgno;
#line 131
    (t->bt_sp)->index = index;
#line 131
    (t->bt_sp) ++;
#line 132
    pg = ((BINTERNAL *)((char *)h + (int )h->linp[index]))->pgno;
#line 133
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_search.c"
static int __bt_snext(BTREE *t , PAGE *h , DBT const   *key , int *exactp ) 
{ 
  EPG e ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 163
  tmp___1 = __mpool_get(t->bt_mp, h->nextpg, (u_int )0);
#line 163
  e.page = (PAGE *)tmp___1;
  }
#line 163
  if ((unsigned long )e.page == (unsigned long )((void *)0)) {
#line 164
    return (0);
  }
  {
#line 165
  e.index = (u_int16_t )0;
#line 166
  tmp___2 = __bt_cmp(t, key, & e);
  }
#line 166
  if (tmp___2 == 0) {
    {
#line 167
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 168
    t->bt_cur = e;
#line 169
    *exactp = 1;
    }
#line 170
    return (1);
  }
  {
#line 172
  __mpool_put(t->bt_mp, (void *)e.page, (u_int )0);
  }
#line 173
  return (0);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_search.c"
static int __bt_sprev(BTREE *t , PAGE *h , DBT const   *key , int *exactp ) 
{ 
  EPG e ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 202
  tmp___1 = __mpool_get(t->bt_mp, h->prevpg, (u_int )0);
#line 202
  e.page = (PAGE *)tmp___1;
  }
#line 202
  if ((unsigned long )e.page == (unsigned long )((void *)0)) {
#line 203
    return (0);
  }
  {
#line 204
  e.index = (u_int16_t )(((unsigned long )(e.page)->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
#line 205
  tmp___2 = __bt_cmp(t, key, & e);
  }
#line 205
  if (tmp___2 == 0) {
    {
#line 206
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 207
    t->bt_cur = e;
#line 208
    *exactp = 1;
    }
#line 209
    return (1);
  }
  {
#line 211
  __mpool_put(t->bt_mp, (void *)e.page, (u_int )0);
  }
#line 212
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 91 "./mpool.h"
MPOOL *__mpool_open(void *key , int fd , u_int32_t pagesize , u_int32_t maxcache ) ;
#line 93
void __mpool_filter(MPOOL *mp , void (*pgin)(void * , u_int32_t  , void * ) , void (*pgout)(void * ,
                                                                                            u_int32_t  ,
                                                                                            void * ) ,
                    void *pgcookie ) ;
#line 97
void *__mpool_new(MPOOL *mp , u_int32_t *pgnoaddr ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/extern.h"
int __bt_defcmp(DBT const   *a , DBT const   *b ) ;
#line 40
size_t __bt_defpfx(DBT const   *a , DBT const   *b ) ;
#line 41
int __bt_delete(DB const   *dbp , DBT const   *key , u_int flags ) ;
#line 43
int __bt_fd(DB const   *dbp ) ;
#line 45
int __bt_get(DB const   *dbp , DBT const   *key , DBT *data , u_int flags ) ;
#line 47
void __bt_pgin(void *t , u_int32_t pg , void *pp ) ;
#line 48
void __bt_pgout(void *t , u_int32_t pg , void *pp ) ;
#line 50
int __bt_put(DB const   *dbp , DBT *key , DBT const   *data , u_int flags ) ;
#line 53
int __bt_seq(DB const   *dbp , DBT *key , DBT *data , u_int flags ) ;
#line 57
int __bt_sync(DB const   *dbp , u_int flags ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static int byteorder(void) ;
#line 70
static int nroot(BTREE *t ) ;
#line 71
static int tmp(void) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
DB *__bt_open(char const   *fname , int flags , int mode , BTREEINFO const   *openinfo ,
              int dflags ) 
{ 
  struct stat sb ;
  BTMETA m ;
  BTREE *t ;
  BTREEINFO b ;
  DB *dbp ;
  u_int32_t ncache ;
  ssize_t nr ;
  int machine_lorder ;
  void *tmp___1 ;
  DB *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int32_t _tmp___4 ;
  MPOOL *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
  {
#line 104
  t = (BTREE *)((void *)0);
#line 113
  machine_lorder = byteorder();
  }
#line 114
  if (openinfo) {
#line 115
    b = (BTREEINFO )*openinfo;
#line 118
    if (b.flags & 0xfffffffffffffffeUL) {
#line 119
      goto einval;
    }
#line 126
    if (b.psize) {
#line 126
      if (b.psize < 512U) {
#line 129
        goto einval;
      } else
#line 126
      if (b.psize > 65536U) {
#line 129
        goto einval;
      } else
#line 126
      if ((unsigned long )b.psize & (sizeof(u_int16_t ) - 1UL)) {
#line 129
        goto einval;
      }
    }
#line 132
    if (b.minkeypage) {
#line 133
      if (b.minkeypage < 2) {
#line 134
        goto einval;
      }
    } else {
#line 136
      b.minkeypage = 2;
    }
#line 139
    if ((unsigned long )b.compare == (unsigned long )((void *)0)) {
#line 140
      b.compare = & __bt_defcmp;
#line 141
      if ((unsigned long )b.prefix == (unsigned long )((void *)0)) {
#line 142
        b.prefix = & __bt_defpfx;
      }
    }
#line 145
    if (b.lorder == 0) {
#line 146
      b.lorder = machine_lorder;
    }
  } else {
#line 148
    b.compare = & __bt_defcmp;
#line 149
    b.cachesize = (u_int )0;
#line 150
    b.flags = (u_long )0;
#line 151
    b.lorder = machine_lorder;
#line 152
    b.minkeypage = 2;
#line 153
    b.prefix = & __bt_defpfx;
#line 154
    b.psize = (u_int )0;
  }
#line 158
  if (b.lorder != 4321) {
#line 158
    if (b.lorder != 1234) {
#line 159
      goto einval;
    }
  }
  {
#line 162
  tmp___1 = malloc(sizeof(BTREE ));
#line 162
  t = (BTREE *)tmp___1;
  }
#line 162
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 163
    goto err;
  }
  {
#line 164
  memset((void *)t, 0, sizeof(BTREE ));
#line 165
  t->bt_fd = -1;
#line 166
  t->bt_lorder = b.lorder;
#line 167
  t->bt_order = (enum __anonenum_bt_order_54 )0;
#line 168
  t->bt_cmp = b.compare;
#line 169
  t->bt_pfx = b.prefix;
#line 170
  t->bt_rfd = -1;
#line 172
  tmp___3 = malloc(sizeof(DB ));
#line 172
  dbp = (DB *)tmp___3;
#line 172
  tmp___2 = dbp;
#line 172
  t->bt_dbp = tmp___2;
  }
#line 172
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 173
    goto err;
  }
  {
#line 174
  memset((void *)t->bt_dbp, 0, sizeof(DB ));
  }
#line 175
  if (t->bt_lorder != machine_lorder) {
#line 176
    t->flags |= 8U;
  }
#line 178
  dbp->type = (DBTYPE )0;
#line 179
  dbp->internal = (void *)t;
#line 180
  dbp->close = & __bt_close;
#line 181
  dbp->del = & __bt_delete;
#line 182
  dbp->fd = & __bt_fd;
#line 183
  dbp->get = & __bt_get;
#line 184
  dbp->put = & __bt_put;
#line 185
  dbp->seq = & __bt_seq;
#line 186
  dbp->sync = & __bt_sync;
#line 192
  if (fname) {
    {
#line 194
    if ((flags & 3) == 0) {
#line 194
      goto case_0;
    }
#line 197
    if ((flags & 3) == 2) {
#line 197
      goto case_2;
    }
#line 200
    goto switch_default;
    case_0: /* CIL Label */ 
#line 195
    t->flags |= 16U;
#line 196
    goto switch_break;
    case_2: /* CIL Label */ 
#line 198
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 201
    goto einval;
    switch_break: /* CIL Label */ ;
    }
    {
#line 204
    tmp___4 = open(fname, flags, mode);
#line 204
    t->bt_fd = tmp___4;
    }
#line 204
    if (tmp___4 < 0) {
#line 205
      goto err;
    }
  } else {
#line 208
    if ((flags & 3) != 2) {
#line 209
      goto einval;
    }
    {
#line 210
    tmp___5 = tmp();
#line 210
    t->bt_fd = tmp___5;
    }
#line 210
    if (tmp___5 == -1) {
#line 211
      goto err;
    }
#line 212
    t->flags |= 1U;
  }
  {
#line 215
  tmp___6 = fcntl(t->bt_fd, 2, 1);
  }
#line 215
  if (tmp___6 == -1) {
#line 216
    goto err;
  }
  {
#line 218
  tmp___7 = fstat(t->bt_fd, & sb);
  }
#line 218
  if (tmp___7) {
#line 219
    goto err;
  }
#line 220
  if (sb.st_size) {
    {
#line 221
    nr = read(t->bt_fd, (void *)(& m), sizeof(BTMETA ));
    }
#line 221
    if (nr < 0L) {
#line 222
      goto err;
    }
#line 223
    if ((unsigned long )nr != sizeof(BTMETA )) {
#line 224
      goto eftype;
    }
#line 234
    if (m.magic == 340322U) {
#line 235
      t->flags &= 4294967287U;
    } else {
#line 237
      t->flags |= 8U;
#line 238
      _tmp = m.magic;
#line 238
      *((char *)(& m.magic) + 0) = *((char *)(& _tmp) + 3);
#line 238
      *((char *)(& m.magic) + 1) = *((char *)(& _tmp) + 2);
#line 238
      *((char *)(& m.magic) + 2) = *((char *)(& _tmp) + 1);
#line 238
      *((char *)(& m.magic) + 3) = *((char *)(& _tmp) + 0);
#line 239
      _tmp___0 = m.version;
#line 239
      *((char *)(& m.version) + 0) = *((char *)(& _tmp___0) + 3);
#line 239
      *((char *)(& m.version) + 1) = *((char *)(& _tmp___0) + 2);
#line 239
      *((char *)(& m.version) + 2) = *((char *)(& _tmp___0) + 1);
#line 239
      *((char *)(& m.version) + 3) = *((char *)(& _tmp___0) + 0);
#line 240
      _tmp___1 = m.psize;
#line 240
      *((char *)(& m.psize) + 0) = *((char *)(& _tmp___1) + 3);
#line 240
      *((char *)(& m.psize) + 1) = *((char *)(& _tmp___1) + 2);
#line 240
      *((char *)(& m.psize) + 2) = *((char *)(& _tmp___1) + 1);
#line 240
      *((char *)(& m.psize) + 3) = *((char *)(& _tmp___1) + 0);
#line 241
      _tmp___2 = m.free;
#line 241
      *((char *)(& m.free) + 0) = *((char *)(& _tmp___2) + 3);
#line 241
      *((char *)(& m.free) + 1) = *((char *)(& _tmp___2) + 2);
#line 241
      *((char *)(& m.free) + 2) = *((char *)(& _tmp___2) + 1);
#line 241
      *((char *)(& m.free) + 3) = *((char *)(& _tmp___2) + 0);
#line 242
      _tmp___3 = m.nrecs;
#line 242
      *((char *)(& m.nrecs) + 0) = *((char *)(& _tmp___3) + 3);
#line 242
      *((char *)(& m.nrecs) + 1) = *((char *)(& _tmp___3) + 2);
#line 242
      *((char *)(& m.nrecs) + 2) = *((char *)(& _tmp___3) + 1);
#line 242
      *((char *)(& m.nrecs) + 3) = *((char *)(& _tmp___3) + 0);
#line 243
      _tmp___4 = m.flags;
#line 243
      *((char *)(& m.flags) + 0) = *((char *)(& _tmp___4) + 3);
#line 243
      *((char *)(& m.flags) + 1) = *((char *)(& _tmp___4) + 2);
#line 243
      *((char *)(& m.flags) + 2) = *((char *)(& _tmp___4) + 1);
#line 243
      *((char *)(& m.flags) + 3) = *((char *)(& _tmp___4) + 0);
    }
#line 245
    if (m.magic != 340322U) {
#line 246
      goto eftype;
    } else
#line 245
    if (m.version != 3U) {
#line 246
      goto eftype;
    }
#line 247
    if (m.psize < 512U) {
#line 249
      goto eftype;
    } else
#line 247
    if (m.psize > 65536U) {
#line 249
      goto eftype;
    } else
#line 247
    if ((unsigned long )m.psize & (sizeof(u_int16_t ) - 1UL)) {
#line 249
      goto eftype;
    }
#line 250
    if (m.flags & 4294967135U) {
#line 251
      goto eftype;
    }
#line 252
    b.psize = m.psize;
#line 253
    t->flags |= m.flags;
#line 254
    t->bt_free = m.free;
#line 255
    t->bt_nrecs = m.nrecs;
  } else {
#line 261
    if (b.psize == 0U) {
#line 263
      b.psize = (u_int )sb.st_blksize;
#line 265
      if (b.psize < 512U) {
#line 266
        b.psize = (u_int )512;
      }
#line 267
      if (b.psize > 65536U) {
#line 268
        b.psize = (u_int )65536;
      }
    }
#line 272
    if (! (b.flags & 1UL)) {
#line 273
      t->flags |= 32U;
    }
#line 275
    t->bt_free = (u_int32_t )0;
#line 276
    t->bt_nrecs = (u_int32_t )0;
#line 277
    t->flags |= 2U;
  }
#line 280
  t->bt_psize = b.psize;
#line 283
  if (b.cachesize) {
#line 283
    if (b.cachesize & (b.psize - 1U)) {
#line 284
      b.cachesize += (~ b.cachesize & (b.psize - 1U)) + 1U;
    }
  }
#line 285
  if (b.cachesize < b.psize * 5U) {
#line 286
    b.cachesize = b.psize * 5U;
  }
#line 289
  ncache = ((b.cachesize + t->bt_psize) - 1U) / t->bt_psize;
#line 302
  t->bt_ovflsize = (u_int16_t )(((unsigned long )t->bt_psize - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / (unsigned long )b.minkeypage - (sizeof(u_int16_t ) + (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL))));
#line 304
  if ((unsigned long )t->bt_ovflsize < (((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (sizeof(u_int32_t ) + sizeof(u_int32_t ))) + (sizeof(u_int32_t ) + sizeof(u_int32_t ))) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL)) + sizeof(u_int16_t )) {
#line 305
    t->bt_ovflsize = (u_int16_t )((((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (sizeof(u_int32_t ) + sizeof(u_int32_t ))) + (sizeof(u_int32_t ) + sizeof(u_int32_t ))) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL)) + sizeof(u_int16_t ));
  }
  {
#line 309
  tmp___8 = __mpool_open((void *)0, t->bt_fd, t->bt_psize, ncache);
#line 309
  t->bt_mp = tmp___8;
  }
#line 309
  if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 311
    goto err;
  }
#line 312
  if (! (t->flags & 1U)) {
    {
#line 313
    __mpool_filter(t->bt_mp, & __bt_pgin, & __bt_pgout, (void *)t);
    }
  }
  {
#line 316
  tmp___9 = nroot(t);
  }
#line 316
  if (tmp___9 == -1) {
#line 317
    goto err;
  }
#line 320
  if (dflags & 536870912) {
#line 321
    t->flags |= 16384U;
  }
#line 322
  if (dflags & 1073741824) {
#line 323
    t->flags |= 32768U;
  }
#line 324
  if ((unsigned int )dflags & 2147483648U) {
#line 325
    t->flags |= 65536U;
  }
#line 327
  return (dbp);
  einval: 
  {
#line 329
  tmp___10 = __errno_location();
#line 329
  *tmp___10 = 22;
  }
#line 330
  goto err;
  eftype: 
  {
#line 332
  tmp___11 = __errno_location();
#line 332
  *tmp___11 = 22;
  }
#line 333
  goto err;
  err: 
#line 335
  if (t) {
#line 336
    if (t->bt_dbp) {
      {
#line 337
      free((void *)t->bt_dbp);
      }
    }
#line 338
    if (t->bt_fd != -1) {
      {
#line 339
      close(t->bt_fd);
      }
    }
    {
#line 340
    free((void *)t);
    }
  }
#line 342
  return ((DB *)((void *)0));
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static int nroot(BTREE *t ) 
{ 
  PAGE *meta ;
  PAGE *root ;
  u_int32_t npg ;
  void *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int32_t tmp___6 ;

  {
  {
#line 361
  tmp___1 = __mpool_get(t->bt_mp, (u_int32_t )0, (u_int )0);
#line 361
  meta = (PAGE *)tmp___1;
  }
#line 361
  if ((unsigned long )meta != (unsigned long )((void *)0)) {
    {
#line 362
    __mpool_put(t->bt_mp, (void *)meta, (u_int )0);
    }
#line 363
    return (0);
  }
  {
#line 365
  tmp___2 = __errno_location();
  }
#line 365
  if (*tmp___2 != 22) {
#line 366
    return (-1);
  }
  {
#line 367
  tmp___3 = __errno_location();
#line 367
  *tmp___3 = 0;
#line 369
  tmp___4 = __mpool_new(t->bt_mp, & npg);
#line 369
  meta = (PAGE *)tmp___4;
  }
#line 369
  if ((unsigned long )meta == (unsigned long )((void *)0)) {
#line 370
    return (-1);
  }
  {
#line 372
  tmp___5 = __mpool_new(t->bt_mp, & npg);
#line 372
  root = (PAGE *)tmp___5;
  }
#line 372
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 373
    return (-1);
  }
#line 375
  if (npg != 1U) {
#line 376
    return (-1);
  }
  {
#line 377
  root->pgno = npg;
#line 378
  tmp___6 = (u_int32_t )0;
#line 378
  root->nextpg = tmp___6;
#line 378
  root->prevpg = tmp___6;
#line 379
  root->lower = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 380
  root->upper = (u_int16_t )t->bt_psize;
#line 381
  root->flags = (u_int32_t )2;
#line 382
  memset((void *)meta, 0, (size_t )t->bt_psize);
#line 383
  __mpool_put(t->bt_mp, (void *)meta, (u_int )1);
#line 384
  __mpool_put(t->bt_mp, (void *)root, (u_int )1);
  }
#line 385
  return (0);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static char const   fmt[13]  = 
#line 395
  {      (char const   )'%',      (char const   )'s',      (char const   )'/',      (char const   )'b', 
        (char const   )'t',      (char const   )'.',      (char const   )'X',      (char const   )'X', 
        (char const   )'X',      (char const   )'X',      (char const   )'X',      (char const   )'X', 
        (char const   )'\000'};
#line 388 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static int tmp(void) 
{ 
  sigset_t set ;
  sigset_t oset ;
  int fd ;
  char const   *envtmp ;
  char *path ;
  size_t n ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 398
  tmp___1 = getenv("TMPDIR");
#line 398
  envtmp = (char const   *)tmp___1;
  }
#line 399
  if (! envtmp) {
#line 400
    envtmp = "/tmp";
  }
  {
#line 401
  tmp___2 = strlen(envtmp);
#line 401
  n = tmp___2 + sizeof(fmt);
#line 403
  tmp___3 = __builtin_alloca(n);
#line 403
  path = (char *)tmp___3;
  }
#line 407
  if (envtmp) {
#line 407
    tmp___4 = envtmp;
  } else {
#line 407
    tmp___4 = "/tmp";
  }
  {
#line 407
  snprintf((char */* __restrict  */)path, n, (char const   */* __restrict  */)(fmt),
           tmp___4);
#line 409
  sigfillset(& set);
#line 410
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)(& oset));
#line 411
  fd = mkstemp(path);
  }
#line 411
  if (fd != -1) {
    {
#line 412
    unlink((char const   *)path);
    }
  }
  {
#line 413
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& oset), (sigset_t */* __restrict  */)((void *)0));
  }
#line 417
  return (fd);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static int byteorder(void) 
{ 
  u_int32_t x ;
  u_char *p ;

  {
#line 426
  x = (u_int32_t )16909060;
#line 427
  p = (u_char *)(& x);
  {
#line 429
  if ((int )*p == 1) {
#line 429
    goto case_1;
  }
#line 431
  if ((int )*p == 4) {
#line 431
    goto case_4;
  }
#line 433
  goto switch_default;
  case_1: /* CIL Label */ 
#line 430
  return (4321);
  case_4: /* CIL Label */ 
#line 432
  return (1234);
  switch_default: /* CIL Label */ 
#line 434
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
int __bt_fd(DB const   *dbp ) 
{ 
  BTREE *t ;
  int *tmp___1 ;

  {
#line 444
  t = (BTREE *)dbp->internal;
#line 447
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 448
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 449
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
#line 453
  if (t->flags & 1U) {
    {
#line 454
    tmp___1 = __errno_location();
#line 454
    *tmp___1 = 2;
    }
#line 455
    return (-1);
  }
#line 457
  return (t->bt_fd);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 76 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 1016 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_close.c"
int __rec_close(DB *dbp ) 
{ 
  BTREE *t ;
  int status ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 66
  t = (BTREE *)dbp->internal;
#line 69
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 70
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 71
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
  {
#line 74
  tmp___1 = __rec_sync((DB const   *)dbp, (u_int )0);
  }
#line 74
  if (tmp___1 == -1) {
#line 75
    return (-1);
  }
#line 78
  status = 0;
#line 79
  if (t->flags & 1024U) {
    {
#line 79
    tmp___2 = munmap((void *)t->bt_smap, t->bt_msize);
    }
#line 79
    if (tmp___2) {
#line 80
      status = -1;
    }
  }
#line 82
  if (! (t->flags & 2048U)) {
#line 83
    if (t->flags & 64U) {
      {
#line 84
      tmp___3 = fclose(t->bt_rfp);
      }
#line 84
      if (tmp___3) {
#line 85
        status = -1;
      }
    } else {
      {
#line 87
      tmp___4 = close(t->bt_rfd);
      }
#line 87
      if (tmp___4) {
#line 88
        status = -1;
      }
    }
  }
  {
#line 91
  tmp___5 = __bt_close(dbp);
  }
#line 91
  if (tmp___5 == -1) {
#line 92
    status = -1;
  }
#line 94
  return (status);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_close.c"
int __rec_sync(DB const   *dbp , u_int flags ) 
{ 
  struct iovec iov[2] ;
  BTREE *t ;
  DBT data ;
  DBT key ;
  off_t off ;
  u_int32_t scursor ;
  u_int32_t trec ;
  int status ;
  int tmp___1 ;
  int tmp___2 ;
  __off_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;

  {
#line 118
  t = (BTREE *)dbp->internal;
#line 121
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 122
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 123
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
#line 126
  if (flags == 11U) {
    {
#line 127
    tmp___1 = __bt_sync(dbp, (u_int )0);
    }
#line 127
    return (tmp___1);
  }
#line 129
  if (t->flags & 10240U) {
#line 130
    return (0);
  } else
#line 129
  if (! (t->flags & 4096U)) {
#line 130
    return (0);
  }
#line 133
  if (! (t->flags & 256U)) {
    {
#line 133
    tmp___2 = (*(t->bt_irec))(t, 4294967295U);
    }
#line 133
    if (tmp___2 == -1) {
#line 134
      return (-1);
    }
  }
  {
#line 137
  tmp___3 = lseek(t->bt_rfd, (off_t )0, 0);
  }
#line 137
  if (tmp___3 != 0L) {
#line 138
    return (-1);
  }
#line 141
  scursor = t->bt_cursor.rcursor;
#line 143
  key.size = sizeof(u_int32_t );
#line 144
  key.data = (void *)(& trec);
#line 146
  if (t->flags & 512U) {
    {
#line 152
    status = (*(dbp->seq))(dbp, & key, & data, (u_int )3);
    }
    {
#line 153
    while (1) {
      while_continue: /* CIL Label */ ;
#line 153
      if (! (status == 0)) {
#line 153
        goto while_break;
      }
      {
#line 154
      tmp___4 = write(t->bt_rfd, (void const   *)data.data, data.size);
      }
#line 154
      if ((size_t )tmp___4 != data.size) {
#line 155
        return (-1);
      }
      {
#line 156
      status = (*(dbp->seq))(dbp, & key, & data, (u_int )7);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 159
    iov[1].iov_base = (void *)(& t->bt_bval);
#line 160
    iov[1].iov_len = (size_t )1;
#line 162
    status = (*(dbp->seq))(dbp, & key, & data, (u_int )3);
    }
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 163
      if (! (status == 0)) {
#line 163
        goto while_break___0;
      }
      {
#line 164
      iov[0].iov_base = data.data;
#line 165
      iov[0].iov_len = data.size;
#line 166
      tmp___5 = writev(t->bt_rfd, (struct iovec  const  *)(iov), 2);
      }
#line 166
      if ((size_t )tmp___5 != data.size + 1UL) {
#line 167
        return (-1);
      }
      {
#line 168
      status = (*(dbp->seq))(dbp, & key, & data, (u_int )7);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 173
  t->bt_cursor.rcursor = scursor;
#line 175
  if (status == -1) {
#line 176
    return (-1);
  }
  {
#line 177
  off = lseek(t->bt_rfd, (off_t )0, 1);
  }
#line 177
  if (off == -1L) {
#line 178
    return (-1);
  }
  {
#line 179
  tmp___6 = ftruncate(t->bt_rfd, off);
  }
#line 179
  if (tmp___6) {
#line 180
    return (-1);
  }
#line 181
  t->flags &= 4294963199U;
#line 182
  return (0);
}
}
#line 232 "./db.h"
DB *__dbopen(char const   *fname , int flags , int mode , DBTYPE type , void const   *openinfo ) ;
#line 233
extern DB *dbopen(char const   *fname , int flags , int mode , DBTYPE type , void const   *openinfo )  __attribute__((__weak__)) ;
#line 239
void __dbpanic(DB *dbp ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db/db.c"
DB *__dbopen(char const   *fname , int flags , int mode , DBTYPE type , void const   *openinfo ) 
{ 
  DB *tmp___1 ;
  DB *tmp___2 ;
  DB *tmp___3 ;
  int *tmp___4 ;

  {
#line 66
  if (((unsigned int )flags & 536868157U) == 0U) {
    {
#line 68
    if ((unsigned int )type == 0U) {
#line 68
      goto case_0;
    }
#line 71
    if ((unsigned int )type == 1U) {
#line 71
      goto case_1;
    }
#line 74
    if ((unsigned int )type == 2U) {
#line 74
      goto case_2;
    }
#line 67
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 69
    tmp___1 = __bt_open(fname, flags & 2754, mode, (BTREEINFO const   *)openinfo,
                        (int )((unsigned int )flags & 3758096384U));
    }
#line 69
    return (tmp___1);
    case_1: /* CIL Label */ 
    {
#line 72
    tmp___2 = __hash_open(fname, flags & 2754, mode, (HASHINFO const   *)openinfo,
                          (int )((unsigned int )flags & 3758096384U));
    }
#line 72
    return (tmp___2);
    case_2: /* CIL Label */ 
    {
#line 75
    tmp___3 = __rec_open(fname, flags & 2754, mode, (RECNOINFO const   *)openinfo,
                         (int )((unsigned int )flags & 3758096384U));
    }
#line 75
    return (tmp___3);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 78
  tmp___4 = __errno_location();
#line 78
  *tmp___4 = 22;
  }
#line 79
  return ((DB *)((void *)0));
}
}
#line 83
extern DB *dbopen(char const   *fname , int flags , int mode , DBTYPE type , void const   *openinfo )  __attribute__((__weak__)) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db/db.c"
extern DB *dbopen(char const   *fname , int flags , int mode , DBTYPE type , void const   *openinfo ) 
{ 
  DB *tmp___1 ;

  {
  {
#line 83
  tmp___1 = __dbopen(fname, flags, mode, type, openinfo);
  }
#line 83
  return (tmp___1);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db/db.c"
static int __dberr(void) 
{ 


  {
#line 89
  return (-1);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db/db.c"
void __dbpanic(DB *dbp ) 
{ 


  {
#line 103
  dbp->del = (int (*)(struct __db  const  * , DBT const   * , u_int  ))(& __dberr);
#line 105
  dbp->get = (int (*)(struct __db  const  * , DBT const   * , DBT * , u_int  ))(& __dberr);
#line 107
  dbp->put = (int (*)(struct __db  const  * , DBT * , DBT const   * , u_int  ))(& __dberr);
#line 109
  dbp->seq = (int (*)(struct __db  const  * , DBT * , DBT * , u_int  ))(& __dberr);
#line 111
  dbp->sync = (int (*)(struct __db  const  * , u_int  ))(& __dberr);
#line 112
  dbp->fd = (int (*)(struct __db  const  * ))(& __dberr);
#line 113
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/extern.h"
PAGE *__bt_new(BTREE *t , u_int32_t *npg ) ;
#line 55
int __bt_split(BTREE *t , PAGE *sp , DBT const   *key , DBT const   *data , int flags ,
               size_t ilen , u_int32_t argskip ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static int bt_broot(BTREE *t , PAGE *h , PAGE *l , PAGE *r ) ;
#line 52
static PAGE *bt_page(BTREE *t , PAGE *h , PAGE **lp , PAGE **rp , u_int16_t *skip ,
                     size_t ilen ) ;
#line 54
static int bt_preserve(BTREE *t , u_int32_t pg ) ;
#line 55
static PAGE *bt_psplit(BTREE *t , PAGE *h , PAGE *l , PAGE *r , u_int16_t *pskip ,
                       size_t ilen ) ;
#line 57
static PAGE *bt_root(BTREE *t , PAGE *h , PAGE **lp , PAGE **rp , u_int16_t *skip ,
                     size_t ilen ) ;
#line 59
static int bt_rroot(BTREE *t , PAGE *h , PAGE *l , PAGE *r ) ;
#line 60
static u_int32_t rec_total(PAGE *h ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
int __bt_split(BTREE *t , PAGE *sp , DBT const   *key , DBT const   *data , int flags ,
               size_t ilen , u_int32_t argskip ) 
{ 
  BINTERNAL *bi ;
  BLEAF *bl ;
  BLEAF *tbl ;
  DBT a ;
  DBT b ;
  EPGNO *parent ;
  PAGE *h ;
  PAGE *l ;
  PAGE *r ;
  PAGE *lchild ;
  PAGE *rchild ;
  u_int16_t nxtindex ;
  u_int16_t skip ;
  u_int32_t n ;
  u_int32_t nbytes ;
  u_int32_t nksize ;
  int parentsplit ;
  char *dest ;
  PAGE *tmp___1 ;
  PAGE *tmp___2 ;
  u_int16_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  PAGE *tmp___9 ;
  PAGE *tmp___10 ;
  u_int16_t tmp___11 ;
  u_int16_t tmp___12 ;
  u_int32_t tmp___13 ;
  int tmp___14 ;
  u_int16_t tmp___15 ;
  u_int16_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 107
  skip = (u_int16_t )argskip;
#line 108
  if (sp->pgno == 1U) {
    {
#line 108
    tmp___1 = bt_root(t, sp, & l, & r, & skip, ilen);
#line 108
    h = tmp___1;
    }
  } else {
    {
#line 108
    tmp___2 = bt_page(t, sp, & l, & r, & skip, ilen);
#line 108
    h = tmp___2;
    }
  }
#line 111
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 112
    return (-1);
  }
#line 118
  tmp___3 = (u_int16_t )((size_t )h->upper - ilen);
#line 118
  h->upper = tmp___3;
#line 118
  h->linp[skip] = tmp___3;
#line 119
  dest = (char *)h + (int )h->upper;
#line 120
  if (t->flags & 128U) {
    {
#line 121
    *((u_int32_t *)dest) = (u_int32_t )data->size;
#line 121
    dest += sizeof(u_int32_t );
#line 121
    *((u_char *)dest) = (u_char )flags;
#line 121
    dest += sizeof(u_char );
#line 121
    memmove((void *)dest, (void const   *)data->data, (size_t )data->size);
    }
  } else {
    {
#line 123
    *((u_int32_t *)dest) = (u_int32_t )key->size;
#line 123
    dest += sizeof(u_int32_t );
#line 123
    *((u_int32_t *)dest) = (u_int32_t )data->size;
#line 123
    dest += sizeof(u_int32_t );
#line 123
    *((u_char *)dest) = (u_char )flags;
#line 123
    dest += sizeof(u_char );
#line 123
    memmove((void *)dest, (void const   *)key->data, (size_t )key->size);
#line 123
    dest += key->size;
#line 123
    memmove((void *)dest, (void const   *)data->data, (size_t )data->size);
    }
  }
#line 126
  if (sp->pgno == 1U) {
#line 126
    if (t->flags & 128U) {
      {
#line 126
      tmp___4 = bt_rroot(t, sp, l, r);
#line 126
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 126
      tmp___5 = bt_broot(t, sp, l, r);
#line 126
      tmp___6 = tmp___5;
      }
    }
#line 126
    if (tmp___6 == -1) {
#line 129
      goto err2;
    }
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if ((unsigned long )t->bt_sp == (unsigned long )(t->bt_stack)) {
#line 154
      parent = (EPGNO *)((void *)0);
    } else {
#line 154
      (t->bt_sp) --;
#line 154
      parent = t->bt_sp;
    }
#line 154
    if (! ((unsigned long )parent != (unsigned long )((void *)0))) {
#line 154
      goto while_break;
    }
    {
#line 155
    lchild = l;
#line 156
    rchild = r;
#line 159
    tmp___7 = __mpool_get(t->bt_mp, parent->pgno, (u_int )0);
#line 159
    h = (PAGE *)tmp___7;
    }
#line 159
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 160
      goto err2;
    }
#line 166
    skip = (u_int16_t )((int )parent->index + 1);
    {
#line 183
    if ((rchild->flags & 31U) == 1U) {
#line 183
      goto case_1;
    }
#line 187
    if ((rchild->flags & 31U) == 2U) {
#line 187
      goto case_2;
    }
#line 210
    if ((rchild->flags & 31U) == 16U) {
#line 210
      goto case_16;
    }
#line 210
    if ((rchild->flags & 31U) == 8U) {
#line 210
      goto case_16;
    }
#line 213
    goto switch_default;
    case_1: /* CIL Label */ 
#line 184
    bi = (BINTERNAL *)((char *)rchild + (int )rchild->linp[0]);
#line 185
    nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bi->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 186
    goto switch_break;
    case_2: /* CIL Label */ 
#line 188
    bl = (BLEAF *)((char *)rchild + (int )rchild->linp[0]);
#line 189
    nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bl->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 190
    if (t->bt_pfx) {
#line 190
      if (! ((int )bl->flags & 2)) {
#line 190
        if (h->prevpg != 0U) {
#line 190
          goto _L;
        } else
#line 190
        if ((int )skip > 1) {
          _L: /* CIL Label */ 
          {
#line 192
          tbl = (BLEAF *)((char *)lchild + (int )lchild->linp[((unsigned long )lchild->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL]);
#line 193
          a.size = (size_t )tbl->ksize;
#line 194
          a.data = (void *)(tbl->bytes);
#line 195
          b.size = (size_t )bl->ksize;
#line 196
          b.data = (void *)(bl->bytes);
#line 197
          tmp___8 = (*(t->bt_pfx))((DBT const   *)(& a), (DBT const   *)(& b));
#line 197
          nksize = (u_int32_t )tmp___8;
#line 198
          n = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )nksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
          }
#line 199
          if (n < nbytes) {
#line 203
            nbytes = n;
          } else {
#line 205
            nksize = (u_int32_t )0;
          }
        } else {
#line 207
          nksize = (u_int32_t )0;
        }
      } else {
#line 207
        nksize = (u_int32_t )0;
      }
    } else {
#line 207
      nksize = (u_int32_t )0;
    }
#line 208
    goto switch_break;
    case_16: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 211
    nbytes = (u_int32_t )((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 212
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 214
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 218
    if ((unsigned long )((u_int32_t )((int )h->upper - (int )h->lower)) < (unsigned long )nbytes + sizeof(u_int16_t )) {
#line 220
      sp = h;
#line 221
      if (h->pgno == 1U) {
        {
#line 221
        tmp___9 = bt_root(t, h, & l, & r, & skip, (size_t )nbytes);
#line 221
        h = tmp___9;
        }
      } else {
        {
#line 221
        tmp___10 = bt_page(t, h, & l, & r, & skip, (size_t )nbytes);
#line 221
        h = tmp___10;
        }
      }
#line 224
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 225
        goto err1;
      }
#line 226
      parentsplit = 1;
    } else {
#line 228
      nxtindex = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
#line 228
      if ((int )skip < (int )nxtindex) {
        {
#line 229
        memmove((void *)((h->linp + (int )skip) + 1), (void const   *)(h->linp + (int )skip),
                (unsigned long )((int )nxtindex - (int )skip) * sizeof(u_int16_t ));
        }
      }
#line 231
      h->lower = (u_int16_t )((unsigned long )h->lower + sizeof(u_int16_t ));
#line 232
      parentsplit = 0;
    }
    {
#line 237
    if ((rchild->flags & 31U) == 1U) {
#line 237
      goto case_1___0;
    }
#line 243
    if ((rchild->flags & 31U) == 2U) {
#line 243
      goto case_2___0;
    }
#line 253
    if ((rchild->flags & 31U) == 8U) {
#line 253
      goto case_8___0;
    }
#line 271
    if ((rchild->flags & 31U) == 16U) {
#line 271
      goto case_16___0;
    }
#line 289
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 238
    tmp___11 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 238
    h->upper = tmp___11;
#line 238
    h->linp[skip] = tmp___11;
#line 239
    dest = (char *)h + (int )h->linp[skip];
#line 240
    memmove((void *)dest, (void const   *)bi, (size_t )nbytes);
#line 241
    ((BINTERNAL *)dest)->pgno = rchild->pgno;
    }
#line 242
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 244
    tmp___12 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 244
    h->upper = tmp___12;
#line 244
    h->linp[skip] = tmp___12;
#line 245
    dest = (char *)h + (int )h->linp[skip];
#line 246
    if (nksize) {
#line 246
      *((u_int32_t *)dest) = nksize;
    } else {
#line 246
      *((u_int32_t *)dest) = bl->ksize;
    }
#line 246
    dest += sizeof(u_int32_t );
#line 246
    *((u_int32_t *)dest) = rchild->pgno;
#line 246
    dest += sizeof(u_int32_t );
#line 246
    *((u_char *)dest) = (u_char )((int )bl->flags & 2);
#line 246
    dest += sizeof(u_char );
#line 248
    if (nksize) {
#line 248
      tmp___13 = nksize;
    } else {
#line 248
      tmp___13 = bl->ksize;
    }
    {
#line 248
    memmove((void *)dest, (void const   *)(bl->bytes), (size_t )tmp___13);
    }
#line 249
    if ((int )bl->flags & 2) {
      {
#line 249
      tmp___14 = bt_preserve(t, *((u_int32_t *)(bl->bytes)));
      }
#line 249
      if (tmp___14 == -1) {
#line 251
        goto err1;
      }
    }
#line 252
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 258
    if ((int )skip > 0) {
#line 259
      dest = (char *)h + (int )h->linp[(int )skip - 1];
    } else {
#line 261
      dest = (char *)l + (int )l->linp[((unsigned long )l->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL];
    }
    {
#line 262
    ((RINTERNAL *)dest)->nrecs = rec_total(lchild);
#line 263
    ((RINTERNAL *)dest)->pgno = lchild->pgno;
#line 266
    tmp___15 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 266
    h->upper = tmp___15;
#line 266
    h->linp[skip] = tmp___15;
#line 267
    dest = (char *)h + (int )h->linp[skip];
#line 268
    ((RINTERNAL *)dest)->nrecs = rec_total(rchild);
#line 269
    ((RINTERNAL *)dest)->pgno = rchild->pgno;
    }
#line 270
    goto switch_break___0;
    case_16___0: /* CIL Label */ 
#line 276
    if ((int )skip > 0) {
#line 277
      dest = (char *)h + (int )h->linp[(int )skip - 1];
    } else {
#line 279
      dest = (char *)l + (int )l->linp[((unsigned long )l->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL];
    }
#line 280
    ((RINTERNAL *)dest)->nrecs = (u_int32_t )(((unsigned long )lchild->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
#line 281
    ((RINTERNAL *)dest)->pgno = lchild->pgno;
#line 284
    tmp___16 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 284
    h->upper = tmp___16;
#line 284
    h->linp[skip] = tmp___16;
#line 285
    dest = (char *)h + (int )h->linp[skip];
#line 286
    ((RINTERNAL *)dest)->nrecs = (u_int32_t )(((unsigned long )rchild->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
#line 287
    ((RINTERNAL *)dest)->pgno = rchild->pgno;
#line 288
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 290
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 294
    if (! parentsplit) {
      {
#line 295
      __mpool_put(t->bt_mp, (void *)h, (u_int )1);
      }
#line 296
      goto while_break;
    }
#line 300
    if (sp->pgno == 1U) {
#line 300
      if (t->flags & 128U) {
        {
#line 300
        tmp___17 = bt_rroot(t, sp, l, r);
#line 300
        tmp___19 = tmp___17;
        }
      } else {
        {
#line 300
        tmp___18 = bt_broot(t, sp, l, r);
#line 300
        tmp___19 = tmp___18;
        }
      }
#line 300
      if (tmp___19 == -1) {
#line 303
        goto err1;
      }
    }
    {
#line 305
    __mpool_put(t->bt_mp, (void *)lchild, (u_int )1);
#line 306
    __mpool_put(t->bt_mp, (void *)rchild, (u_int )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  __mpool_put(t->bt_mp, (void *)l, (u_int )1);
#line 311
  __mpool_put(t->bt_mp, (void *)r, (u_int )1);
  }
#line 314
  return (0);
  err1: 
  {
#line 321
  __mpool_put(t->bt_mp, (void *)lchild, (u_int )1);
#line 322
  __mpool_put(t->bt_mp, (void *)rchild, (u_int )1);
  }
  err2: 
  {
#line 324
  __mpool_put(t->bt_mp, (void *)l, (u_int )0);
#line 325
  __mpool_put(t->bt_mp, (void *)r, (u_int )0);
#line 326
  __dbpanic(t->bt_dbp);
  }
#line 327
  return (-1);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static PAGE *bt_page(BTREE *t , PAGE *h , PAGE **lp , PAGE **rp , u_int16_t *skip ,
                     size_t ilen ) 
{ 
  PAGE *l ;
  PAGE *r ;
  PAGE *tp ;
  u_int32_t npg ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 358
  r = __bt_new(t, & npg);
  }
#line 358
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 359
    return ((PAGE *)((void *)0));
  }
#line 360
  r->pgno = npg;
#line 361
  r->lower = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 362
  r->upper = (u_int16_t )t->bt_psize;
#line 363
  r->nextpg = h->nextpg;
#line 364
  r->prevpg = h->pgno;
#line 365
  r->flags = h->flags & 31U;
#line 377
  if (h->nextpg == 0U) {
#line 377
    if ((unsigned long )*skip == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
#line 381
      h->nextpg = r->pgno;
#line 382
      r->lower = (u_int16_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 383
      *skip = (u_int16_t )0;
#line 384
      *lp = h;
#line 385
      *rp = r;
#line 386
      return (r);
    }
  }
  {
#line 390
  tmp___1 = malloc((size_t )t->bt_psize);
#line 390
  l = (PAGE *)tmp___1;
  }
#line 390
  if ((unsigned long )l == (unsigned long )((void *)0)) {
    {
#line 391
    __mpool_put(t->bt_mp, (void *)r, (u_int )0);
    }
#line 392
    return ((PAGE *)((void *)0));
  }
#line 397
  l->pgno = h->pgno;
#line 398
  l->nextpg = r->pgno;
#line 399
  l->prevpg = h->prevpg;
#line 400
  l->lower = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 401
  l->upper = (u_int16_t )t->bt_psize;
#line 402
  l->flags = h->flags & 31U;
#line 405
  if (h->nextpg != 0U) {
    {
#line 406
    tmp___2 = __mpool_get(t->bt_mp, h->nextpg, (u_int )0);
#line 406
    tp = (PAGE *)tmp___2;
    }
#line 406
    if ((unsigned long )tp == (unsigned long )((void *)0)) {
      {
#line 407
      free((void *)l);
      }
#line 409
      return ((PAGE *)((void *)0));
    }
    {
#line 411
    tp->prevpg = r->pgno;
#line 412
    __mpool_put(t->bt_mp, (void *)tp, (u_int )1);
    }
  }
  {
#line 422
  tp = bt_psplit(t, h, l, r, skip, ilen);
#line 425
  memmove((void *)h, (void const   *)l, (size_t )t->bt_psize);
  }
#line 426
  if ((unsigned long )tp == (unsigned long )l) {
#line 427
    tp = h;
  }
  {
#line 428
  free((void *)l);
#line 430
  *lp = h;
#line 431
  *rp = r;
  }
#line 432
  return (tp);
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static PAGE *bt_root(BTREE *t , PAGE *h , PAGE **lp , PAGE **rp , u_int16_t *skip ,
                     size_t ilen ) 
{ 
  PAGE *l ;
  PAGE *r ;
  PAGE *tp ;
  u_int32_t lnpg ;
  u_int32_t rnpg ;
  u_int32_t tmp___1 ;
  u_int16_t tmp___2 ;
  u_int16_t tmp___3 ;
  u_int32_t tmp___4 ;

  {
  {
#line 464
  l = __bt_new(t, & lnpg);
  }
#line 464
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 466
    return ((PAGE *)((void *)0));
  } else {
    {
#line 464
    r = __bt_new(t, & rnpg);
    }
#line 464
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 466
      return ((PAGE *)((void *)0));
    }
  }
  {
#line 467
  l->pgno = lnpg;
#line 468
  r->pgno = rnpg;
#line 469
  l->nextpg = r->pgno;
#line 470
  r->prevpg = l->pgno;
#line 471
  tmp___1 = (u_int32_t )0;
#line 471
  r->nextpg = tmp___1;
#line 471
  l->prevpg = tmp___1;
#line 472
  tmp___2 = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 472
  r->lower = tmp___2;
#line 472
  l->lower = tmp___2;
#line 473
  tmp___3 = (u_int16_t )t->bt_psize;
#line 473
  r->upper = tmp___3;
#line 473
  l->upper = tmp___3;
#line 474
  tmp___4 = h->flags & 31U;
#line 474
  r->flags = tmp___4;
#line 474
  l->flags = tmp___4;
#line 477
  tp = bt_psplit(t, h, l, r, skip, ilen);
#line 479
  *lp = l;
#line 480
  *rp = r;
  }
#line 481
  return (tp);
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static int bt_rroot(BTREE *t , PAGE *h , PAGE *l , PAGE *r ) 
{ 
  char *dest ;
  u_int16_t tmp___1 ;
  u_int32_t tmp___2 ;
  u_int16_t tmp___3 ;
  u_int32_t tmp___4 ;

  {
#line 504
  tmp___1 = (u_int16_t )((unsigned long )t->bt_psize - ((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL)));
#line 504
  h->upper = tmp___1;
#line 504
  h->linp[0] = tmp___1;
#line 505
  dest = (char *)h + (int )h->upper;
#line 506
  if (l->flags & 16U) {
#line 506
    *((u_int32_t *)dest) = (u_int32_t )(((unsigned long )l->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
  } else {
    {
#line 506
    tmp___2 = rec_total(l);
#line 506
    *((u_int32_t *)dest) = tmp___2;
    }
  }
#line 506
  dest += sizeof(u_int32_t );
#line 506
  *((u_int32_t *)dest) = l->pgno;
#line 509
  tmp___3 = (u_int16_t )((unsigned long )h->upper - ((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL)));
#line 509
  h->upper = tmp___3;
#line 509
  h->linp[1] = tmp___3;
#line 510
  dest = (char *)h + (int )h->upper;
#line 511
  if (r->flags & 16U) {
#line 511
    *((u_int32_t *)dest) = (u_int32_t )(((unsigned long )r->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
  } else {
    {
#line 511
    tmp___4 = rec_total(r);
#line 511
    *((u_int32_t *)dest) = tmp___4;
    }
  }
  {
#line 511
  dest += sizeof(u_int32_t );
#line 511
  *((u_int32_t *)dest) = r->pgno;
#line 514
  h->lower = (u_int16_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t )) + 2UL * sizeof(u_int16_t ));
#line 517
  h->flags &= 4294967264U;
#line 518
  h->flags |= 8U;
#line 519
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 521
  return (0);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static int bt_broot(BTREE *t , PAGE *h , PAGE *l , PAGE *r ) 
{ 
  BINTERNAL *bi ;
  BLEAF *bl ;
  u_int32_t nbytes ;
  char *dest ;
  u_int16_t tmp___1 ;
  u_int16_t tmp___2 ;
  int tmp___3 ;
  u_int16_t tmp___4 ;

  {
#line 554
  nbytes = (u_int32_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 555
  tmp___1 = (u_int16_t )(t->bt_psize - nbytes);
#line 555
  h->upper = tmp___1;
#line 555
  h->linp[0] = tmp___1;
#line 556
  dest = (char *)h + (int )h->upper;
#line 557
  *((u_int32_t *)dest) = (u_int32_t )0;
#line 557
  dest += sizeof(u_int32_t );
#line 557
  *((u_int32_t *)dest) = l->pgno;
#line 557
  dest += sizeof(u_int32_t );
#line 557
  *((u_char *)dest) = (u_char )0;
#line 557
  dest += sizeof(u_char );
  {
#line 560
  if ((h->flags & 31U) == 2U) {
#line 560
    goto case_2;
  }
#line 576
  if ((h->flags & 31U) == 1U) {
#line 576
    goto case_1;
  }
#line 584
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 561
  bl = (BLEAF *)((char *)r + (int )r->linp[0]);
#line 562
  nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bl->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 563
  tmp___2 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 563
  h->upper = tmp___2;
#line 563
  h->linp[1] = tmp___2;
#line 564
  dest = (char *)h + (int )h->upper;
#line 565
  *((u_int32_t *)dest) = bl->ksize;
#line 565
  dest += sizeof(u_int32_t );
#line 565
  *((u_int32_t *)dest) = r->pgno;
#line 565
  dest += sizeof(u_int32_t );
#line 565
  *((u_char *)dest) = (u_char )0;
#line 565
  dest += sizeof(u_char );
#line 566
  memmove((void *)dest, (void const   *)(bl->bytes), (size_t )bl->ksize);
  }
#line 572
  if ((int )bl->flags & 2) {
    {
#line 572
    tmp___3 = bt_preserve(t, *((u_int32_t *)(bl->bytes)));
    }
#line 572
    if (tmp___3 == -1) {
#line 574
      return (-1);
    }
  }
#line 575
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 577
  bi = (BINTERNAL *)((char *)r + (int )r->linp[0]);
#line 578
  nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bi->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 579
  tmp___4 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 579
  h->upper = tmp___4;
#line 579
  h->linp[1] = tmp___4;
#line 580
  dest = (char *)h + (int )h->upper;
#line 581
  memmove((void *)dest, (void const   *)bi, (size_t )nbytes);
#line 582
  ((BINTERNAL *)dest)->pgno = r->pgno;
  }
#line 583
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 585
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 589
  h->lower = (u_int16_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t )) + 2UL * sizeof(u_int16_t ));
#line 592
  h->flags &= 4294967264U;
#line 593
  h->flags |= 1U;
#line 594
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 596
  return (0);
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static PAGE *bt_psplit(BTREE *t , PAGE *h , PAGE *l , PAGE *r , u_int16_t *pskip ,
                       size_t ilen ) 
{ 
  BINTERNAL *bi ;
  BLEAF *bl ;
  CURSOR *c ;
  RLEAF *rl ;
  PAGE *rval ;
  void *src ;
  u_int16_t full ;
  u_int16_t half ;
  u_int16_t nxt ;
  u_int16_t off ;
  u_int16_t skip ;
  u_int16_t top ;
  u_int16_t used ;
  u_int32_t nbytes ;
  int bigkeycnt ;
  int isbigkey ;
  u_int16_t tmp___1 ;
  u_int16_t tmp___2 ;

  {
#line 636
  bigkeycnt = 0;
#line 637
  skip = *pskip;
#line 638
  full = (u_int16_t )((unsigned long )t->bt_psize - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t )));
#line 639
  half = (u_int16_t )((int )full / 2);
#line 640
  used = (u_int16_t )0;
#line 641
  off = (u_int16_t )0;
#line 641
  nxt = off;
#line 641
  top = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! ((int )nxt < (int )top)) {
#line 641
      goto while_break;
    }
#line 642
    if ((int )skip == (int )off) {
#line 643
      nbytes = (u_int32_t )ilen;
#line 644
      isbigkey = 0;
    } else {
      {
#line 647
      if ((h->flags & 31U) == 1U) {
#line 647
        goto case_1;
      }
#line 652
      if ((h->flags & 31U) == 2U) {
#line 652
        goto case_2;
      }
#line 657
      if ((h->flags & 31U) == 8U) {
#line 657
        goto case_8;
      }
#line 662
      if ((h->flags & 31U) == 16U) {
#line 662
        goto case_16;
      }
#line 667
      goto switch_default;
      case_1: /* CIL Label */ 
#line 648
      bi = (BINTERNAL *)((char *)h + (int )h->linp[nxt]);
#line 648
      src = (void *)bi;
#line 649
      nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bi->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 650
      isbigkey = (int )bi->flags & 2;
#line 651
      goto switch_break;
      case_2: /* CIL Label */ 
#line 653
      bl = (BLEAF *)((char *)h + (int )h->linp[nxt]);
#line 653
      src = (void *)bl;
#line 654
      nbytes = (u_int32_t )(((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bl->ksize) + (unsigned long )bl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 655
      isbigkey = (int )bl->flags & 2;
#line 656
      goto switch_break;
      case_8: /* CIL Label */ 
#line 658
      src = (void *)((RINTERNAL *)((char *)h + (int )h->linp[nxt]));
#line 659
      nbytes = (u_int32_t )((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 660
      isbigkey = 0;
#line 661
      goto switch_break;
      case_16: /* CIL Label */ 
#line 663
      rl = (RLEAF *)((char *)h + (int )h->linp[nxt]);
#line 663
      src = (void *)rl;
#line 664
      nbytes = (u_int32_t )(((((sizeof(u_int32_t ) + sizeof(u_char )) + (unsigned long )rl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 665
      isbigkey = 0;
#line 666
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 668
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 677
    if ((int )skip <= (int )off) {
#line 677
      if ((unsigned long )((u_int32_t )used + nbytes) + sizeof(u_int16_t ) >= (unsigned long )full) {
#line 679
        off = (u_int16_t )((int )off - 1);
#line 680
        goto while_break;
      } else {
#line 677
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 677
    if ((int )nxt == (int )top - 1) {
#line 679
      off = (u_int16_t )((int )off - 1);
#line 680
      goto while_break;
    }
#line 684
    if ((int )skip != (int )off) {
      {
#line 685
      nxt = (u_int16_t )((int )nxt + 1);
#line 687
      tmp___1 = (u_int16_t )((u_int32_t )l->upper - nbytes);
#line 687
      l->upper = tmp___1;
#line 687
      l->linp[off] = tmp___1;
#line 688
      memmove((void *)((char *)l + (int )l->upper), (void const   *)src, (size_t )nbytes);
      }
    }
#line 691
    used = (u_int16_t )((unsigned long )used + ((unsigned long )nbytes + sizeof(u_int16_t )));
#line 692
    if ((int )used >= (int )half) {
#line 693
      if (! isbigkey) {
#line 694
        goto while_break;
      } else
#line 693
      if (bigkeycnt == 3) {
#line 694
        goto while_break;
      } else {
#line 696
        bigkeycnt ++;
      }
    }
#line 641
    off = (u_int16_t )((int )off + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  l->lower = (u_int16_t )((unsigned long )l->lower + (unsigned long )((int )off + 1) * sizeof(u_int16_t ));
#line 713
  c = & t->bt_cursor;
#line 714
  if ((int )c->flags & 8) {
#line 714
    if (c->pg.pgno == h->pgno) {
#line 715
      if ((int )c->pg.index >= (int )skip) {
#line 716
        c->pg.index = (u_int16_t )((int )c->pg.index + 1);
      }
#line 717
      if ((int )c->pg.index < (int )nxt) {
#line 718
        c->pg.pgno = l->pgno;
      } else {
#line 720
        c->pg.pgno = r->pgno;
#line 721
        c->pg.index = (u_int16_t )((int )c->pg.index - (int )nxt);
      }
    }
  }
#line 730
  if ((int )skip <= (int )off) {
#line 731
    skip = (u_int16_t )0;
#line 732
    rval = l;
  } else {
#line 734
    rval = r;
#line 735
    *pskip = (u_int16_t )((int )*pskip - (int )nxt);
  }
#line 738
  off = (u_int16_t )0;
  {
#line 738
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 738
    if (! ((int )nxt < (int )top)) {
#line 738
      goto while_break___0;
    }
#line 739
    if ((int )skip == (int )nxt) {
#line 740
      off = (u_int16_t )((int )off + 1);
#line 741
      skip = (u_int16_t )0;
    }
    {
#line 744
    if ((h->flags & 31U) == 1U) {
#line 744
      goto case_1___0;
    }
#line 748
    if ((h->flags & 31U) == 2U) {
#line 748
      goto case_2___0;
    }
#line 752
    if ((h->flags & 31U) == 8U) {
#line 752
      goto case_8___0;
    }
#line 756
    if ((h->flags & 31U) == 16U) {
#line 756
      goto case_16___0;
    }
#line 760
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 745
    bi = (BINTERNAL *)((char *)h + (int )h->linp[nxt]);
#line 745
    src = (void *)bi;
#line 746
    nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bi->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 747
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 749
    bl = (BLEAF *)((char *)h + (int )h->linp[nxt]);
#line 749
    src = (void *)bl;
#line 750
    nbytes = (u_int32_t )(((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bl->ksize) + (unsigned long )bl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 751
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 753
    src = (void *)((RINTERNAL *)((char *)h + (int )h->linp[nxt]));
#line 754
    nbytes = (u_int32_t )((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 755
    goto switch_break___0;
    case_16___0: /* CIL Label */ 
#line 757
    rl = (RLEAF *)((char *)h + (int )h->linp[nxt]);
#line 757
    src = (void *)rl;
#line 758
    nbytes = (u_int32_t )(((((sizeof(u_int32_t ) + sizeof(u_char )) + (unsigned long )rl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 759
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 761
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 763
    nxt = (u_int16_t )((int )nxt + 1);
#line 764
    tmp___2 = (u_int16_t )((u_int32_t )r->upper - nbytes);
#line 764
    r->upper = tmp___2;
#line 764
    r->linp[off] = tmp___2;
#line 765
    memmove((void *)((char *)r + (int )r->upper), (void const   *)src, (size_t )nbytes);
#line 738
    off = (u_int16_t )((int )off + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 767
  r->lower = (u_int16_t )((unsigned long )r->lower + (unsigned long )off * sizeof(u_int16_t ));
#line 770
  if ((int )skip == (int )top) {
#line 771
    r->lower = (u_int16_t )((unsigned long )r->lower + sizeof(u_int16_t ));
  }
#line 773
  return (rval);
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static int bt_preserve(BTREE *t , u_int32_t pg ) 
{ 
  PAGE *h ;
  void *tmp___1 ;

  {
  {
#line 798
  tmp___1 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 798
  h = (PAGE *)tmp___1;
  }
#line 798
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 799
    return (-1);
  }
  {
#line 800
  h->flags |= 32U;
#line 801
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 802
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static u_int32_t rec_total(PAGE *h ) 
{ 
  u_int32_t recs ;
  u_int16_t nxt ;
  u_int16_t top ;

  {
#line 826
  recs = (u_int32_t )0;
#line 826
  nxt = (u_int16_t )0;
#line 826
  top = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! ((int )nxt < (int )top)) {
#line 826
      goto while_break;
    }
#line 827
    recs += ((RINTERNAL *)((char *)h + (int )h->linp[nxt]))->nrecs;
#line 826
    nxt = (u_int16_t )((int )nxt + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  return (recs);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/extern.h"
int __bt_free(BTREE *t , PAGE *h ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_page.c"
int __bt_free(BTREE *t , PAGE *h ) 
{ 
  int tmp___1 ;

  {
  {
#line 65
  h->prevpg = (u_int32_t )0;
#line 66
  h->nextpg = t->bt_free;
#line 67
  t->bt_free = h->pgno;
#line 68
  t->flags |= 2U;
#line 71
  tmp___1 = __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 71
  return (tmp___1);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_page.c"
PAGE *__bt_new(BTREE *t , u_int32_t *npg ) 
{ 
  PAGE *h ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 92
  if (t->bt_free != 0U) {
    {
#line 92
    tmp___1 = __mpool_get(t->bt_mp, t->bt_free, (u_int )0);
#line 92
    h = (PAGE *)tmp___1;
    }
#line 92
    if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 94
      *npg = t->bt_free;
#line 95
      t->bt_free = h->nextpg;
#line 96
      t->flags |= 2U;
#line 97
      return (h);
    }
  }
  {
#line 99
  tmp___2 = __mpool_new(t->bt_mp, npg);
  }
#line 99
  return ((PAGE *)tmp___2);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/extern.h"
int __ovfl_put(BTREE *t , DBT const   *dbt , u_int32_t *pg ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/extern.h"
int __rec_dleaf(BTREE *t , PAGE *h , u_int32_t index___0 ) ;
#line 46
int __rec_iput(BTREE *t , u_int32_t nrec , DBT const   *data , u_int flags ) ;
#line 48
int __rec_ret(BTREE *t , EPG *e , u_int32_t nrec , DBT *key , DBT *data ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_put.c"
int __rec_put(DB const   *dbp , DBT *key , DBT const   *data , u_int flags ) 
{ 
  BTREE *t ;
  DBT fdata ;
  DBT tdata ;
  u_int32_t nrec ;
  int status ;
  void *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 73
  t = (BTREE *)dbp->internal;
#line 76
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 77
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 78
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
#line 86
  if (t->flags & 512U) {
#line 86
    if (data->size != (size_t const   )t->bt_reclen) {
#line 87
      if (data->size > (size_t const   )t->bt_reclen) {
#line 88
        goto einval;
      }
#line 90
      if (t->bt_rdata.size < t->bt_reclen) {
#line 91
        if ((unsigned long )t->bt_rdata.data == (unsigned long )((void *)0)) {
          {
#line 91
          tmp___1 = malloc(t->bt_reclen);
#line 91
          t->bt_rdata.data = tmp___1;
          }
        } else {
          {
#line 91
          tmp___2 = realloc(t->bt_rdata.data, t->bt_reclen);
#line 91
          t->bt_rdata.data = tmp___2;
          }
        }
#line 94
        if ((unsigned long )t->bt_rdata.data == (unsigned long )((void *)0)) {
#line 95
          return (-1);
        }
#line 96
        t->bt_rdata.size = t->bt_reclen;
      }
      {
#line 98
      memmove(t->bt_rdata.data, (void const   *)data->data, (size_t )data->size);
#line 99
      memset((void *)((char *)t->bt_rdata.data + data->size), (int )t->bt_bval, t->bt_reclen - (size_t )data->size);
#line 101
      fdata.data = t->bt_rdata.data;
#line 102
      fdata.size = t->bt_reclen;
      }
    } else {
#line 104
      fdata.data = (void *)data->data;
#line 105
      fdata.size = (size_t )data->size;
    }
  } else {
#line 104
    fdata.data = (void *)data->data;
#line 105
    fdata.size = (size_t )data->size;
  }
  {
#line 109
  if (flags == 1U) {
#line 109
    goto case_1;
  }
#line 114
  if (flags == 10U) {
#line 114
    goto case_10;
  }
#line 118
  if (flags == 4U) {
#line 118
    goto case_4;
  }
#line 125
  if (flags == 5U) {
#line 125
    goto case_5;
  }
#line 125
  if (flags == 0U) {
#line 125
    goto case_5;
  }
#line 129
  if (flags == 8U) {
#line 129
    goto case_8;
  }
#line 135
  goto einval;
  case_1: /* CIL Label */ 
#line 110
  if (! ((int )t->bt_cursor.flags & 8)) {
#line 111
    goto einval;
  }
#line 112
  nrec = t->bt_cursor.rcursor;
#line 113
  goto switch_break;
  case_10: /* CIL Label */ 
#line 115
  nrec = *((u_int32_t *)key->data);
#line 115
  if (nrec == 0U) {
#line 116
    goto einval;
  }
#line 117
  goto switch_break;
  case_4: /* CIL Label */ 
#line 119
  nrec = *((u_int32_t *)key->data);
#line 119
  if (nrec == 0U) {
#line 120
    nrec = (u_int32_t )1;
#line 121
    flags = (u_int )5;
  }
#line 123
  goto switch_break;
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 126
  nrec = *((u_int32_t *)key->data);
#line 126
  if (nrec == 0U) {
#line 127
    goto einval;
  }
#line 128
  goto switch_break;
  case_8: /* CIL Label */ 
#line 130
  nrec = *((u_int32_t *)key->data);
#line 130
  if (nrec == 0U) {
#line 131
    goto einval;
  }
#line 132
  if (nrec <= t->bt_nrecs) {
#line 133
    return (1);
  }
#line 134
  goto switch_break;
  einval: 
  switch_default: /* CIL Label */ 
  {
#line 136
  tmp___3 = __errno_location();
#line 136
  *tmp___3 = 22;
  }
#line 137
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 144
  if (nrec > t->bt_nrecs) {
#line 145
    if (! (t->flags & 2304U)) {
      {
#line 145
      tmp___4 = (*(t->bt_irec))(t, nrec);
      }
#line 145
      if (tmp___4 == -1) {
#line 147
        return (-1);
      }
    }
#line 148
    if (nrec > t->bt_nrecs + 1U) {
#line 149
      if (t->flags & 512U) {
        {
#line 150
        tmp___5 = malloc(t->bt_reclen);
#line 150
        tdata.data = tmp___5;
        }
#line 150
        if ((unsigned long )tdata.data == (unsigned long )((void *)0)) {
#line 152
          return (-1);
        }
        {
#line 153
        tdata.size = t->bt_reclen;
#line 154
        memset(tdata.data, (int )t->bt_bval, tdata.size);
        }
      } else {
#line 156
        tdata.data = (void *)0;
#line 157
        tdata.size = (size_t )0;
      }
      {
#line 159
      while (1) {
        while_continue: /* CIL Label */ ;
#line 159
        if (! (nrec > t->bt_nrecs + 1U)) {
#line 159
          goto while_break;
        }
        {
#line 160
        tmp___6 = __rec_iput(t, t->bt_nrecs, (DBT const   *)(& tdata), (u_int )0);
        }
#line 160
        if (tmp___6 != 0) {
#line 162
          return (-1);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 163
      if (t->flags & 512U) {
        {
#line 164
        free(tdata.data);
        }
      }
    }
  }
  {
#line 168
  status = __rec_iput(t, nrec - 1U, (DBT const   *)(& fdata), flags);
  }
#line 168
  if (status != 0) {
#line 169
    return (status);
  }
#line 171
  if (flags == 10U) {
#line 172
    t->bt_cursor.rcursor = nrec;
  }
  {
#line 174
  t->flags |= 4096U;
#line 175
  tmp___7 = __rec_ret(t, (EPG *)((void *)0), nrec, key, (DBT *)((void *)0));
  }
#line 175
  return (tmp___7);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_put.c"
int __rec_iput(BTREE *t , u_int32_t nrec , DBT const   *data , u_int flags ) 
{ 
  DBT tdata ;
  EPG *e ;
  PAGE *h ;
  u_int16_t index___0 ;
  u_int16_t nxtindex ;
  u_int32_t pg ;
  u_int32_t nbytes ;
  int dflags ;
  int status ;
  char *dest ;
  char db[sizeof(u_int32_t ) + sizeof(u_int32_t )] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int16_t tmp___4 ;

  {
#line 211
  if (data->size > (size_t const   )t->bt_ovflsize) {
    {
#line 212
    tmp___1 = __ovfl_put(t, data, & pg);
    }
#line 212
    if (tmp___1 == -1) {
#line 213
      return (-1);
    }
#line 214
    tdata.data = (void *)(db);
#line 215
    tdata.size = sizeof(u_int32_t ) + sizeof(u_int32_t );
#line 216
    *((u_int32_t *)(db)) = pg;
#line 217
    *((u_int32_t *)(db + sizeof(u_int32_t ))) = (u_int32_t )data->size;
#line 218
    dflags = 1;
#line 219
    data = (DBT const   *)(& tdata);
  } else {
#line 221
    dflags = 0;
  }
#line 224
  if (nrec > t->bt_nrecs) {
#line 224
    tmp___2 = 1;
  } else
#line 224
  if (flags == 4U) {
#line 224
    tmp___2 = 1;
  } else
#line 224
  if (flags == 5U) {
#line 224
    tmp___2 = 1;
  } else {
#line 224
    tmp___2 = 2;
  }
  {
#line 224
  e = __rec_search(t, nrec, (enum SRCHOP )tmp___2);
  }
#line 224
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 227
    return (-1);
  }
#line 229
  h = e->page;
#line 230
  index___0 = e->index;
  {
#line 239
  if (flags == 4U) {
#line 239
    goto case_4;
  }
#line 242
  if (flags == 5U) {
#line 242
    goto case_5;
  }
#line 244
  goto switch_default;
  case_4: /* CIL Label */ 
#line 240
  index___0 = (u_int16_t )((int )index___0 + 1);
#line 241
  goto switch_break;
  case_5: /* CIL Label */ 
#line 243
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 245
  if (nrec < t->bt_nrecs) {
    {
#line 245
    tmp___3 = __rec_dleaf(t, h, (u_int32_t )index___0);
    }
#line 245
    if (tmp___3 == -1) {
      {
#line 247
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
#line 248
      return (-1);
    }
  }
#line 250
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 258
  nbytes = (u_int32_t )(((((sizeof(u_int32_t ) + sizeof(u_char )) + (unsigned long )data->size) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 259
  if ((unsigned long )((u_int32_t )((int )h->upper - (int )h->lower)) < (unsigned long )nbytes + sizeof(u_int16_t )) {
    {
#line 260
    status = __bt_split(t, h, (DBT const   *)((void *)0), data, dflags, (size_t )nbytes,
                        (u_int32_t )index___0);
    }
#line 261
    if (status == 0) {
#line 262
      (t->bt_nrecs) ++;
    }
#line 263
    return (status);
  }
#line 266
  nxtindex = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
#line 266
  if ((int )index___0 < (int )nxtindex) {
    {
#line 267
    memmove((void *)((h->linp + (int )index___0) + 1), (void const   *)(h->linp + (int )index___0),
            (unsigned long )((int )nxtindex - (int )index___0) * sizeof(u_int16_t ));
    }
  }
  {
#line 269
  h->lower = (u_int16_t )((unsigned long )h->lower + sizeof(u_int16_t ));
#line 271
  tmp___4 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 271
  h->upper = tmp___4;
#line 271
  h->linp[index___0] = tmp___4;
#line 272
  dest = (char *)h + (int )h->upper;
#line 273
  *((u_int32_t *)dest) = (u_int32_t )data->size;
#line 273
  dest += sizeof(u_int32_t );
#line 273
  *((u_char *)dest) = (u_char )dflags;
#line 273
  dest += sizeof(u_char );
#line 273
  memmove((void *)dest, (void const   *)data->data, (size_t )data->size);
#line 275
  (t->bt_nrecs) ++;
#line 276
  t->flags |= 4U;
#line 277
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 279
  return (0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_seq.c"
int __rec_seq(DB const   *dbp , DBT *key , DBT *data , u_int flags ) 
{ 
  BTREE *t ;
  EPG *e ;
  u_int32_t nrec ;
  int status ;
  int tmp___1 ;
  int *tmp___2 ;

  {
#line 71
  t = (BTREE *)dbp->internal;
#line 74
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 75
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 76
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
  {
#line 80
  if (flags == 1U) {
#line 80
    goto case_1;
  }
#line 84
  if (flags == 7U) {
#line 84
    goto case_7;
  }
#line 90
  if (flags == 3U) {
#line 90
    goto case_3;
  }
#line 93
  if (flags == 9U) {
#line 93
    goto case_9;
  }
#line 100
  if (flags == 6U) {
#line 100
    goto case_6;
  }
#line 106
  goto einval;
  case_1: /* CIL Label */ 
#line 81
  nrec = *((u_int32_t *)key->data);
#line 81
  if (nrec == 0U) {
#line 82
    goto einval;
  }
#line 83
  goto switch_break;
  case_7: /* CIL Label */ 
#line 85
  if ((int )t->bt_cursor.flags & 8) {
#line 86
    nrec = t->bt_cursor.rcursor + 1U;
#line 87
    goto switch_break;
  }
  case_3: /* CIL Label */ 
#line 91
  nrec = (u_int32_t )1;
#line 92
  goto switch_break;
  case_9: /* CIL Label */ 
#line 94
  if ((int )t->bt_cursor.flags & 8) {
#line 95
    nrec = t->bt_cursor.rcursor - 1U;
#line 95
    if (nrec == 0U) {
#line 96
      return (1);
    }
#line 97
    goto switch_break;
  }
  case_6: /* CIL Label */ 
#line 101
  if (! (t->flags & 2304U)) {
    {
#line 101
    tmp___1 = (*(t->bt_irec))(t, 4294967295U);
    }
#line 101
    if (tmp___1 == -1) {
#line 103
      return (-1);
    }
  }
#line 104
  nrec = t->bt_nrecs;
#line 105
  goto switch_break;
  einval: 
  switch_default: /* CIL Label */ 
  {
#line 107
  tmp___2 = __errno_location();
#line 107
  *tmp___2 = 22;
  }
#line 108
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 111
  if (t->bt_nrecs == 0U) {
#line 111
    goto _L;
  } else
#line 111
  if (nrec > t->bt_nrecs) {
    _L: /* CIL Label */ 
#line 112
    if (! (t->flags & 2304U)) {
      {
#line 112
      status = (*(t->bt_irec))(t, nrec);
      }
#line 112
      if (status != 0) {
#line 114
        return (status);
      }
    }
#line 115
    if (t->bt_nrecs == 0U) {
#line 116
      return (1);
    } else
#line 115
    if (nrec > t->bt_nrecs) {
#line 116
      return (1);
    }
  }
  {
#line 119
  e = __rec_search(t, nrec - 1U, (enum SRCHOP )2);
  }
#line 119
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 120
    return (-1);
  }
  {
#line 122
  t->bt_cursor.flags = (u_int8_t )((int )t->bt_cursor.flags | 8);
#line 123
  t->bt_cursor.rcursor = nrec;
#line 125
  status = __rec_ret(t, e, nrec, key, data);
  }
#line 126
  if (t->flags & 16384U) {
    {
#line 127
    __mpool_put(t->bt_mp, (void *)e->page, (u_int )0);
    }
  } else {
#line 129
    t->bt_pinned = e->page;
  }
#line 130
  return (status);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 92 "./mpool.h"
extern MPOOL *mpool_open(void *key , int fd , u_int32_t pagesize , u_int32_t maxcache )  __attribute__((__weak__)) ;
#line 95
extern void mpool_filter(MPOOL *mp , void (*pgin)(void * , u_int32_t  , void * ) ,
                         void (*pgout)(void * , u_int32_t  , void * ) , void *pgcookie )  __attribute__((__weak__)) ;
#line 98
extern void *mpool_new(MPOOL *mp , u_int32_t *pgnoaddr )  __attribute__((__weak__)) ;
#line 100
extern void *mpool_get(MPOOL *mp , u_int32_t pgno , u_int flags )  __attribute__((__weak__)) ;
#line 102
extern int mpool_put(MPOOL *mp , void *page , u_int flags )  __attribute__((__weak__)) ;
#line 103
int __mpool_sync(MPOOL *mp ) ;
#line 104
extern int mpool_sync(MPOOL *mp )  __attribute__((__weak__)) ;
#line 105
int __mpool_close(MPOOL *mp ) ;
#line 106
extern int mpool_close(MPOOL *mp )  __attribute__((__weak__)) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
static BKT *mpool_bkt(MPOOL *mp ) ;
#line 66
static BKT *mpool_look(MPOOL *mp , u_int32_t pgno ) ;
#line 67
static int mpool_write(MPOOL *mp , BKT *bp ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
MPOOL *__mpool_open(void *key , int fd , u_int32_t pagesize , u_int32_t maxcache ) 
{ 
  struct stat sb ;
  MPOOL *mp ;
  int entry ;
  int tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 89
  tmp___1 = fstat(fd, & sb);
  }
#line 89
  if (tmp___1) {
#line 90
    return ((MPOOL *)((void *)0));
  }
#line 91
  if (! ((sb.st_mode & 61440U) == 32768U)) {
    {
#line 92
    tmp___2 = __errno_location();
#line 92
    *tmp___2 = 29;
    }
#line 93
    return ((MPOOL *)((void *)0));
  }
  {
#line 97
  tmp___3 = calloc((size_t )1, sizeof(MPOOL ));
#line 97
  mp = (MPOOL *)tmp___3;
  }
#line 97
  if ((unsigned long )mp == (unsigned long )((void *)0)) {
#line 98
    return ((MPOOL *)((void *)0));
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    mp->lqh.cqh_first = (struct _bkt *)((void *)(& mp->lqh));
#line 99
    mp->lqh.cqh_last = (struct _bkt *)((void *)(& mp->lqh));
#line 99
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  entry = 0;
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (! (entry < 128)) {
#line 100
      goto while_break___0;
    }
    {
#line 101
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      mp->hqh[entry].cqh_first = (struct _bkt *)((void *)(& mp->hqh[entry]));
#line 101
      mp->hqh[entry].cqh_last = (struct _bkt *)((void *)(& mp->hqh[entry]));
#line 101
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 100
    entry ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 102
  mp->maxcache = maxcache;
#line 103
  mp->npages = (u_int32_t )(sb.st_size / (__off_t )pagesize);
#line 104
  mp->pagesize = (u_long )pagesize;
#line 105
  mp->fd = fd;
#line 106
  return (mp);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
void __mpool_filter(MPOOL *mp , void (*pgin)(void * , u_int32_t  , void * ) , void (*pgout)(void * ,
                                                                                            u_int32_t  ,
                                                                                            void * ) ,
                    void *pgcookie ) 
{ 


  {
#line 120
  mp->pgin = pgin;
#line 121
  mp->pgout = pgout;
#line 122
  mp->pgcookie = pgcookie;
#line 123
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
void *__mpool_new(MPOOL *mp , u_int32_t *pgnoaddr ) 
{ 
  struct _hqh *head ;
  BKT *bp ;
  u_int32_t tmp___1 ;
  u_int32_t tmp___2 ;

  {
#line 137
  if (mp->npages == 4294967295U) {
    {
#line 138
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mpool_new: page allocation overflow.\n");
#line 139
    abort();
    }
  }
  {
#line 149
  bp = mpool_bkt(mp);
  }
#line 149
  if ((unsigned long )bp == (unsigned long )((void *)0)) {
#line 150
    return ((void *)0);
  }
#line 151
  tmp___2 = mp->npages;
#line 151
  (mp->npages) ++;
#line 151
  tmp___1 = tmp___2;
#line 151
  bp->pgno = tmp___1;
#line 151
  *pgnoaddr = tmp___1;
#line 152
  bp->flags = (u_int8_t )2;
#line 154
  head = & mp->hqh[(bp->pgno - 1U) % 128U];
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    bp->hq.cqe_next = head->cqh_first;
#line 155
    bp->hq.cqe_prev = (struct _bkt *)((void *)head);
#line 155
    if ((unsigned long )head->cqh_last == (unsigned long )((void *)head)) {
#line 155
      head->cqh_last = bp;
    } else {
#line 155
      (head->cqh_first)->hq.cqe_prev = bp;
    }
#line 155
    head->cqh_first = bp;
#line 155
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 156
    bp->q.cqe_next = (struct _bkt *)((void *)(& mp->lqh));
#line 156
    bp->q.cqe_prev = mp->lqh.cqh_last;
#line 156
    if ((unsigned long )mp->lqh.cqh_first == (unsigned long )((void *)(& mp->lqh))) {
#line 156
      mp->lqh.cqh_first = bp;
    } else {
#line 156
      (mp->lqh.cqh_last)->q.cqe_next = bp;
    }
#line 156
    mp->lqh.cqh_last = bp;
#line 156
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 157
  return (bp->page);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
void *__mpool_get(MPOOL *mp , u_int32_t pgno , u_int flags ) 
{ 
  struct _hqh *head ;
  BKT *bp ;
  off_t off ;
  int nr ;
  int *tmp___1 ;
  __off_t tmp___2 ;
  int *tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 176
  if (pgno >= mp->npages) {
    {
#line 177
    tmp___1 = __errno_location();
#line 177
    *tmp___1 = 22;
    }
#line 178
    return ((void *)0);
  }
  {
#line 186
  bp = mpool_look(mp, pgno);
  }
#line 186
  if ((unsigned long )bp != (unsigned long )((void *)0)) {
#line 198
    head = & mp->hqh[(bp->pgno - 1U) % 128U];
    {
#line 199
    while (1) {
      while_continue: /* CIL Label */ ;
#line 199
      if ((unsigned long )bp->hq.cqe_next == (unsigned long )((void *)head)) {
#line 199
        head->cqh_last = bp->hq.cqe_prev;
      } else {
#line 199
        (bp->hq.cqe_next)->hq.cqe_prev = bp->hq.cqe_prev;
      }
#line 199
      if ((unsigned long )bp->hq.cqe_prev == (unsigned long )((void *)head)) {
#line 199
        head->cqh_first = bp->hq.cqe_next;
      } else {
#line 199
        (bp->hq.cqe_prev)->hq.cqe_next = bp->hq.cqe_next;
      }
#line 199
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 200
      bp->hq.cqe_next = head->cqh_first;
#line 200
      bp->hq.cqe_prev = (struct _bkt *)((void *)head);
#line 200
      if ((unsigned long )head->cqh_last == (unsigned long )((void *)head)) {
#line 200
        head->cqh_last = bp;
      } else {
#line 200
        (head->cqh_first)->hq.cqe_prev = bp;
      }
#line 200
      head->cqh_first = bp;
#line 200
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 201
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 201
      if ((unsigned long )bp->q.cqe_next == (unsigned long )((void *)(& mp->lqh))) {
#line 201
        mp->lqh.cqh_last = bp->q.cqe_prev;
      } else {
#line 201
        (bp->q.cqe_next)->q.cqe_prev = bp->q.cqe_prev;
      }
#line 201
      if ((unsigned long )bp->q.cqe_prev == (unsigned long )((void *)(& mp->lqh))) {
#line 201
        mp->lqh.cqh_first = bp->q.cqe_next;
      } else {
#line 201
        (bp->q.cqe_prev)->q.cqe_next = bp->q.cqe_next;
      }
#line 201
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 202
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 202
      bp->q.cqe_next = (struct _bkt *)((void *)(& mp->lqh));
#line 202
      bp->q.cqe_prev = mp->lqh.cqh_last;
#line 202
      if ((unsigned long )mp->lqh.cqh_first == (unsigned long )((void *)(& mp->lqh))) {
#line 202
        mp->lqh.cqh_first = bp;
      } else {
#line 202
        (mp->lqh.cqh_last)->q.cqe_next = bp;
      }
#line 202
      mp->lqh.cqh_last = bp;
#line 202
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 205
    bp->flags = (u_int8_t )((int )bp->flags | 2);
#line 206
    return (bp->page);
  }
  {
#line 210
  bp = mpool_bkt(mp);
  }
#line 210
  if ((unsigned long )bp == (unsigned long )((void *)0)) {
#line 211
    return ((void *)0);
  }
  {
#line 217
  off = (off_t )(mp->pagesize * (u_long )pgno);
#line 218
  tmp___2 = lseek(mp->fd, off, 0);
  }
#line 218
  if (tmp___2 != off) {
#line 219
    return ((void *)0);
  }
  {
#line 220
  tmp___4 = read(mp->fd, bp->page, mp->pagesize);
#line 220
  nr = (int )tmp___4;
  }
#line 220
  if ((u_long )nr != mp->pagesize) {
#line 222
    if (nr >= 0) {
      {
#line 223
      tmp___3 = __errno_location();
#line 223
      *tmp___3 = 22;
      }
    }
#line 224
    return ((void *)0);
  }
#line 228
  bp->pgno = pgno;
#line 229
  bp->flags = (u_int8_t )2;
#line 235
  head = & mp->hqh[(bp->pgno - 1U) % 128U];
  {
#line 236
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 236
    bp->hq.cqe_next = head->cqh_first;
#line 236
    bp->hq.cqe_prev = (struct _bkt *)((void *)head);
#line 236
    if ((unsigned long )head->cqh_last == (unsigned long )((void *)head)) {
#line 236
      head->cqh_last = bp;
    } else {
#line 236
      (head->cqh_first)->hq.cqe_prev = bp;
    }
#line 236
    head->cqh_first = bp;
#line 236
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 237
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 237
    bp->q.cqe_next = (struct _bkt *)((void *)(& mp->lqh));
#line 237
    bp->q.cqe_prev = mp->lqh.cqh_last;
#line 237
    if ((unsigned long )mp->lqh.cqh_first == (unsigned long )((void *)(& mp->lqh))) {
#line 237
      mp->lqh.cqh_first = bp;
    } else {
#line 237
      (mp->lqh.cqh_last)->q.cqe_next = bp;
    }
#line 237
    mp->lqh.cqh_last = bp;
#line 237
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 240
  if ((unsigned long )mp->pgin != (unsigned long )((void *)0)) {
    {
#line 241
    (*(mp->pgin))(mp->pgcookie, bp->pgno, bp->page);
    }
  }
#line 243
  return (bp->page);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
int __mpool_put(MPOOL *mp , void *page , u_int flags ) 
{ 
  BKT *bp ;

  {
#line 261
  bp = (BKT *)((char *)page - sizeof(BKT ));
#line 269
  bp->flags = (u_int8_t )((int )bp->flags & -3);
#line 270
  bp->flags = (u_int8_t )((unsigned int )bp->flags | (flags & 1U));
#line 271
  return (0);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
int __mpool_close(MPOOL *mp ) 
{ 
  BKT *bp ;

  {
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    bp = mp->lqh.cqh_first;
#line 285
    if (! ((unsigned long )bp != (unsigned long )((void *)(& mp->lqh)))) {
#line 285
      goto while_break;
    }
    {
#line 286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 286
      if ((unsigned long )(mp->lqh.cqh_first)->q.cqe_next == (unsigned long )((void *)(& mp->lqh))) {
#line 286
        mp->lqh.cqh_last = (mp->lqh.cqh_first)->q.cqe_prev;
      } else {
#line 286
        ((mp->lqh.cqh_first)->q.cqe_next)->q.cqe_prev = (mp->lqh.cqh_first)->q.cqe_prev;
      }
#line 286
      if ((unsigned long )(mp->lqh.cqh_first)->q.cqe_prev == (unsigned long )((void *)(& mp->lqh))) {
#line 286
        mp->lqh.cqh_first = (mp->lqh.cqh_first)->q.cqe_next;
      } else {
#line 286
        ((mp->lqh.cqh_first)->q.cqe_prev)->q.cqe_next = (mp->lqh.cqh_first)->q.cqe_next;
      }
#line 286
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 287
    free((void *)bp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  free((void *)mp);
  }
#line 292
  return (0);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
int __mpool_sync(MPOOL *mp ) 
{ 
  BKT *bp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 306
  bp = mp->lqh.cqh_first;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! ((unsigned long )bp != (unsigned long )((void *)(& mp->lqh)))) {
#line 306
      goto while_break;
    }
#line 308
    if ((int )bp->flags & 1) {
      {
#line 308
      tmp___1 = mpool_write(mp, bp);
      }
#line 308
      if (tmp___1 == -1) {
#line 310
        return (-1);
      }
    }
#line 306
    bp = bp->q.cqe_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 313
  tmp___3 = fsync(mp->fd);
  }
#line 313
  if (tmp___3) {
#line 313
    tmp___2 = -1;
  } else {
#line 313
    tmp___2 = 0;
  }
#line 313
  return (tmp___2);
}
}
#line 324
extern MPOOL *mpool_open(void *key , int fd , u_int32_t pagesize , u_int32_t maxcache )  __attribute__((__weak__)) ;
#line 324 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
extern MPOOL *mpool_open(void *key , int fd , u_int32_t pagesize , u_int32_t maxcache ) 
{ 
  MPOOL *tmp___1 ;

  {
  {
#line 324
  tmp___1 = __mpool_open(key, fd, pagesize, maxcache);
  }
#line 324
  return (tmp___1);
}
}
#line 325
extern void mpool_filter(MPOOL *mp , void (*pgin)(void * , u_int32_t  , void * ) ,
                         void (*pgout)(void * , u_int32_t  , void * ) , void *pgcookie )  __attribute__((__weak__)) ;
#line 325 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
extern void mpool_filter(MPOOL *mp , void (*pgin)(void * , u_int32_t  , void * ) ,
                         void (*pgout)(void * , u_int32_t  , void * ) , void *pgcookie ) 
{ 


  {
  {
#line 325
  __mpool_filter(mp, pgin, pgout, pgcookie);
  }
#line 325
  return;
}
}
#line 326
extern void *mpool_new(MPOOL *mp , u_int32_t *pgnoaddr )  __attribute__((__weak__)) ;
#line 326 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
extern void *mpool_new(MPOOL *mp , u_int32_t *pgnoaddr ) 
{ 
  void *tmp___1 ;

  {
  {
#line 326
  tmp___1 = __mpool_new(mp, pgnoaddr);
  }
#line 326
  return (tmp___1);
}
}
#line 327
extern void *mpool_get(MPOOL *mp , u_int32_t pgno , u_int flags )  __attribute__((__weak__)) ;
#line 327 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
extern void *mpool_get(MPOOL *mp , u_int32_t pgno , u_int flags ) 
{ 
  void *tmp___1 ;

  {
  {
#line 327
  tmp___1 = __mpool_get(mp, pgno, flags);
  }
#line 327
  return (tmp___1);
}
}
#line 328
extern int mpool_put(MPOOL *mp , void *page , u_int flags )  __attribute__((__weak__)) ;
#line 328 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
extern int mpool_put(MPOOL *mp , void *page , u_int flags ) 
{ 
  int tmp___1 ;

  {
  {
#line 328
  tmp___1 = __mpool_put(mp, page, flags);
  }
#line 328
  return (tmp___1);
}
}
#line 329
extern int mpool_close(MPOOL *mp )  __attribute__((__weak__)) ;
#line 329 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
extern int mpool_close(MPOOL *mp ) 
{ 
  int tmp___1 ;

  {
  {
#line 329
  tmp___1 = __mpool_close(mp);
  }
#line 329
  return (tmp___1);
}
}
#line 330
extern int mpool_sync(MPOOL *mp )  __attribute__((__weak__)) ;
#line 330 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
extern int mpool_sync(MPOOL *mp ) 
{ 
  int tmp___1 ;

  {
  {
#line 330
  tmp___1 = __mpool_sync(mp);
  }
#line 330
  return (tmp___1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
static BKT *mpool_bkt(MPOOL *mp ) 
{ 
  struct _hqh *head ;
  BKT *bp ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 345
  if (mp->curcache < mp->maxcache) {
#line 346
    goto new;
  }
#line 354
  bp = mp->lqh.cqh_first;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! ((unsigned long )bp != (unsigned long )((void *)(& mp->lqh)))) {
#line 354
      goto while_break;
    }
#line 356
    if (! ((int )bp->flags & 2)) {
#line 358
      if ((int )bp->flags & 1) {
        {
#line 358
        tmp___1 = mpool_write(mp, bp);
        }
#line 358
        if (tmp___1 == -1) {
#line 360
          return ((BKT *)((void *)0));
        }
      }
#line 365
      head = & mp->hqh[(bp->pgno - 1U) % 128U];
      {
#line 366
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 366
        if ((unsigned long )bp->hq.cqe_next == (unsigned long )((void *)head)) {
#line 366
          head->cqh_last = bp->hq.cqe_prev;
        } else {
#line 366
          (bp->hq.cqe_next)->hq.cqe_prev = bp->hq.cqe_prev;
        }
#line 366
        if ((unsigned long )bp->hq.cqe_prev == (unsigned long )((void *)head)) {
#line 366
          head->cqh_first = bp->hq.cqe_next;
        } else {
#line 366
          (bp->hq.cqe_prev)->hq.cqe_next = bp->hq.cqe_next;
        }
#line 366
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 367
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 367
        if ((unsigned long )bp->q.cqe_next == (unsigned long )((void *)(& mp->lqh))) {
#line 367
          mp->lqh.cqh_last = bp->q.cqe_prev;
        } else {
#line 367
          (bp->q.cqe_next)->q.cqe_prev = bp->q.cqe_prev;
        }
#line 367
        if ((unsigned long )bp->q.cqe_prev == (unsigned long )((void *)(& mp->lqh))) {
#line 367
          mp->lqh.cqh_first = bp->q.cqe_next;
        } else {
#line 367
          (bp->q.cqe_prev)->q.cqe_next = bp->q.cqe_next;
        }
#line 367
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 375
      return (bp);
    }
#line 354
    bp = bp->q.cqe_next;
  }
  while_break: /* CIL Label */ ;
  }
  new: 
  {
#line 378
  tmp___2 = malloc(sizeof(BKT ) + mp->pagesize);
#line 378
  bp = (BKT *)tmp___2;
  }
#line 378
  if ((unsigned long )bp == (unsigned long )((void *)0)) {
#line 379
    return ((BKT *)((void *)0));
  }
#line 386
  bp->page = (void *)((char *)bp + sizeof(BKT ));
#line 387
  (mp->curcache) ++;
#line 388
  return (bp);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
static int mpool_write(MPOOL *mp , BKT *bp ) 
{ 
  off_t off ;
  __off_t tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 407
  if (mp->pgout) {
    {
#line 408
    (*(mp->pgout))(mp->pgcookie, bp->pgno, bp->page);
    }
  }
  {
#line 410
  off = (off_t )(mp->pagesize * (u_long )bp->pgno);
#line 411
  tmp___1 = lseek(mp->fd, off, 0);
  }
#line 411
  if (tmp___1 != off) {
#line 412
    return (-1);
  }
  {
#line 413
  tmp___2 = write(mp->fd, (void const   *)bp->page, mp->pagesize);
  }
#line 413
  if ((u_long )tmp___2 != mp->pagesize) {
#line 414
    return (-1);
  }
#line 416
  bp->flags = (u_int8_t )((int )bp->flags & -2);
#line 417
  return (0);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
static BKT *mpool_look(MPOOL *mp , u_int32_t pgno ) 
{ 
  struct _hqh *head ;
  BKT *bp ;

  {
#line 432
  head = & mp->hqh[(pgno - 1U) % 128U];
#line 433
  bp = head->cqh_first;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! ((unsigned long )bp != (unsigned long )((void *)head))) {
#line 433
      goto while_break;
    }
#line 434
    if (bp->pgno == pgno) {
#line 438
      return (bp);
    }
#line 433
    bp = bp->hq.cqe_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return ((BKT *)((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/extern.h"
int __bt_ret(BTREE *t , EPG *e , DBT *key , DBT *rkey , DBT *data , DBT *rdata , int copy ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_get.c"
int __bt_get(DB const   *dbp , DBT const   *key , DBT *data , u_int flags ) 
{ 
  BTREE *t ;
  EPG *e ;
  int exact ;
  int status ;
  int *tmp___1 ;

  {
#line 73
  t = (BTREE *)dbp->internal;
#line 76
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 77
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 78
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
#line 82
  if (flags) {
    {
#line 83
    tmp___1 = __errno_location();
#line 83
    *tmp___1 = 22;
    }
#line 84
    return (-1);
  }
  {
#line 87
  e = __bt_search(t, key, & exact);
  }
#line 87
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 88
    return (-1);
  }
#line 89
  if (! exact) {
    {
#line 90
    __mpool_put(t->bt_mp, (void *)e->page, (u_int )0);
    }
#line 91
    return (1);
  }
  {
#line 94
  status = __bt_ret(t, e, (DBT *)((void *)0), (DBT *)((void *)0), data, & t->bt_rdata,
                    0);
  }
#line 100
  if (t->flags & 16384U) {
    {
#line 101
    __mpool_put(t->bt_mp, (void *)e->page, (u_int )0);
    }
  } else {
#line 103
    t->bt_pinned = e->page;
  }
#line 104
  return (status);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_conv.c"
static void mswap(PAGE *pg ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_conv.c"
void __bt_pgin(void *t , u_int32_t pg , void *pp ) 
{ 
  PAGE *h ;
  u_int16_t i ;
  u_int16_t top ;
  u_char flags ;
  char *p ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int16_t _tmp___3 ;
  u_int16_t _tmp___4 ;
  u_int16_t _tmp___5 ;
  u_int32_t _tmp___6 ;
  u_int32_t _tmp___7 ;
  u_int32_t _tmp___8 ;
  u_int32_t _tmp___9 ;
  u_int16_t _tmp___10 ;
  u_int32_t _tmp___11 ;
  u_int32_t _tmp___12 ;
  u_int32_t _tmp___13 ;
  u_int32_t _tmp___14 ;
  u_int32_t _tmp___15 ;
  u_int32_t _tmp___16 ;

  {
#line 71
  if (! (((BTREE *)t)->flags & 8U)) {
#line 72
    return;
  }
#line 73
  if (pg == 0U) {
    {
#line 74
    mswap((PAGE *)pp);
    }
#line 75
    return;
  }
#line 78
  h = (PAGE *)pp;
#line 79
  _tmp = h->pgno;
#line 79
  *((char *)(& h->pgno) + 0) = *((char *)(& _tmp) + 3);
#line 79
  *((char *)(& h->pgno) + 1) = *((char *)(& _tmp) + 2);
#line 79
  *((char *)(& h->pgno) + 2) = *((char *)(& _tmp) + 1);
#line 79
  *((char *)(& h->pgno) + 3) = *((char *)(& _tmp) + 0);
#line 80
  _tmp___0 = h->prevpg;
#line 80
  *((char *)(& h->prevpg) + 0) = *((char *)(& _tmp___0) + 3);
#line 80
  *((char *)(& h->prevpg) + 1) = *((char *)(& _tmp___0) + 2);
#line 80
  *((char *)(& h->prevpg) + 2) = *((char *)(& _tmp___0) + 1);
#line 80
  *((char *)(& h->prevpg) + 3) = *((char *)(& _tmp___0) + 0);
#line 81
  _tmp___1 = h->nextpg;
#line 81
  *((char *)(& h->nextpg) + 0) = *((char *)(& _tmp___1) + 3);
#line 81
  *((char *)(& h->nextpg) + 1) = *((char *)(& _tmp___1) + 2);
#line 81
  *((char *)(& h->nextpg) + 2) = *((char *)(& _tmp___1) + 1);
#line 81
  *((char *)(& h->nextpg) + 3) = *((char *)(& _tmp___1) + 0);
#line 82
  _tmp___2 = h->flags;
#line 82
  *((char *)(& h->flags) + 0) = *((char *)(& _tmp___2) + 3);
#line 82
  *((char *)(& h->flags) + 1) = *((char *)(& _tmp___2) + 2);
#line 82
  *((char *)(& h->flags) + 2) = *((char *)(& _tmp___2) + 1);
#line 82
  *((char *)(& h->flags) + 3) = *((char *)(& _tmp___2) + 0);
#line 83
  _tmp___3 = h->lower;
#line 83
  *((char *)(& h->lower) + 0) = *((char *)(& _tmp___3) + 1);
#line 83
  *((char *)(& h->lower) + 1) = *((char *)(& _tmp___3) + 0);
#line 84
  _tmp___4 = h->upper;
#line 84
  *((char *)(& h->upper) + 0) = *((char *)(& _tmp___4) + 1);
#line 84
  *((char *)(& h->upper) + 1) = *((char *)(& _tmp___4) + 0);
#line 86
  top = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
#line 87
  if ((h->flags & 31U) == 1U) {
#line 88
    i = (u_int16_t )0;
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! ((int )i < (int )top)) {
#line 88
        goto while_break;
      }
#line 89
      _tmp___5 = h->linp[i];
#line 89
      *((char *)(& h->linp[i]) + 0) = *((char *)(& _tmp___5) + 1);
#line 89
      *((char *)(& h->linp[i]) + 1) = *((char *)(& _tmp___5) + 0);
#line 90
      p = (char *)((BINTERNAL *)((char *)h + (int )h->linp[i]));
#line 91
      _tmp___6 = *((u_int32_t *)p);
#line 91
      *(p + 0) = *((char *)(& _tmp___6) + 3);
#line 91
      *(p + 1) = *((char *)(& _tmp___6) + 2);
#line 91
      *(p + 2) = *((char *)(& _tmp___6) + 1);
#line 91
      *(p + 3) = *((char *)(& _tmp___6) + 0);
#line 92
      p += sizeof(u_int32_t );
#line 93
      _tmp___7 = *((u_int32_t *)p);
#line 93
      *(p + 0) = *((char *)(& _tmp___7) + 3);
#line 93
      *(p + 1) = *((char *)(& _tmp___7) + 2);
#line 93
      *(p + 2) = *((char *)(& _tmp___7) + 1);
#line 93
      *(p + 3) = *((char *)(& _tmp___7) + 0);
#line 94
      p += sizeof(u_int32_t );
#line 95
      if ((int )*((u_char *)p) & 2) {
#line 96
        p += sizeof(u_char );
#line 97
        _tmp___8 = *((u_int32_t *)p);
#line 97
        *(p + 0) = *((char *)(& _tmp___8) + 3);
#line 97
        *(p + 1) = *((char *)(& _tmp___8) + 2);
#line 97
        *(p + 2) = *((char *)(& _tmp___8) + 1);
#line 97
        *(p + 3) = *((char *)(& _tmp___8) + 0);
#line 98
        p += sizeof(u_int32_t );
#line 99
        _tmp___9 = *((u_int32_t *)p);
#line 99
        *(p + 0) = *((char *)(& _tmp___9) + 3);
#line 99
        *(p + 1) = *((char *)(& _tmp___9) + 2);
#line 99
        *(p + 2) = *((char *)(& _tmp___9) + 1);
#line 99
        *(p + 3) = *((char *)(& _tmp___9) + 0);
      }
#line 88
      i = (u_int16_t )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 102
  if ((h->flags & 31U) == 2U) {
#line 103
    i = (u_int16_t )0;
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (! ((int )i < (int )top)) {
#line 103
        goto while_break___0;
      }
#line 104
      _tmp___10 = h->linp[i];
#line 104
      *((char *)(& h->linp[i]) + 0) = *((char *)(& _tmp___10) + 1);
#line 104
      *((char *)(& h->linp[i]) + 1) = *((char *)(& _tmp___10) + 0);
#line 105
      p = (char *)((BLEAF *)((char *)h + (int )h->linp[i]));
#line 106
      _tmp___11 = *((u_int32_t *)p);
#line 106
      *(p + 0) = *((char *)(& _tmp___11) + 3);
#line 106
      *(p + 1) = *((char *)(& _tmp___11) + 2);
#line 106
      *(p + 2) = *((char *)(& _tmp___11) + 1);
#line 106
      *(p + 3) = *((char *)(& _tmp___11) + 0);
#line 107
      p += sizeof(u_int32_t );
#line 108
      _tmp___12 = *((u_int32_t *)p);
#line 108
      *(p + 0) = *((char *)(& _tmp___12) + 3);
#line 108
      *(p + 1) = *((char *)(& _tmp___12) + 2);
#line 108
      *(p + 2) = *((char *)(& _tmp___12) + 1);
#line 108
      *(p + 3) = *((char *)(& _tmp___12) + 0);
#line 109
      p += sizeof(u_int32_t );
#line 110
      flags = *((u_char *)p);
#line 111
      if ((int )flags & 3) {
#line 112
        p += sizeof(u_char );
#line 113
        if ((int )flags & 2) {
#line 114
          _tmp___13 = *((u_int32_t *)p);
#line 114
          *(p + 0) = *((char *)(& _tmp___13) + 3);
#line 114
          *(p + 1) = *((char *)(& _tmp___13) + 2);
#line 114
          *(p + 2) = *((char *)(& _tmp___13) + 1);
#line 114
          *(p + 3) = *((char *)(& _tmp___13) + 0);
#line 115
          p += sizeof(u_int32_t );
#line 116
          _tmp___14 = *((u_int32_t *)p);
#line 116
          *(p + 0) = *((char *)(& _tmp___14) + 3);
#line 116
          *(p + 1) = *((char *)(& _tmp___14) + 2);
#line 116
          *(p + 2) = *((char *)(& _tmp___14) + 1);
#line 116
          *(p + 3) = *((char *)(& _tmp___14) + 0);
        }
#line 118
        if ((int )flags & 1) {
#line 119
          p += sizeof(u_int32_t );
#line 120
          _tmp___15 = *((u_int32_t *)p);
#line 120
          *(p + 0) = *((char *)(& _tmp___15) + 3);
#line 120
          *(p + 1) = *((char *)(& _tmp___15) + 2);
#line 120
          *(p + 2) = *((char *)(& _tmp___15) + 1);
#line 120
          *(p + 3) = *((char *)(& _tmp___15) + 0);
#line 121
          p += sizeof(u_int32_t );
#line 122
          _tmp___16 = *((u_int32_t *)p);
#line 122
          *(p + 0) = *((char *)(& _tmp___16) + 3);
#line 122
          *(p + 1) = *((char *)(& _tmp___16) + 2);
#line 122
          *(p + 2) = *((char *)(& _tmp___16) + 1);
#line 122
          *(p + 3) = *((char *)(& _tmp___16) + 0);
        }
      }
#line 103
      i = (u_int16_t )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_conv.c"
void __bt_pgout(void *t , u_int32_t pg , void *pp ) 
{ 
  PAGE *h ;
  u_int16_t i ;
  u_int16_t top ;
  u_char flags ;
  char *p ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int16_t _tmp___3 ;
  u_int32_t _tmp___4 ;
  u_int32_t _tmp___5 ;
  u_int32_t _tmp___6 ;
  u_int32_t _tmp___7 ;
  u_int32_t _tmp___8 ;
  u_int32_t _tmp___9 ;
  u_int16_t _tmp___10 ;
  u_int32_t _tmp___11 ;
  u_int32_t _tmp___12 ;
  u_int32_t _tmp___13 ;
  u_int32_t _tmp___14 ;
  u_int16_t _tmp___15 ;
  u_int16_t _tmp___16 ;

  {
#line 139
  if (! (((BTREE *)t)->flags & 8U)) {
#line 140
    return;
  }
#line 141
  if (pg == 0U) {
    {
#line 142
    mswap((PAGE *)pp);
    }
#line 143
    return;
  }
#line 146
  h = (PAGE *)pp;
#line 147
  top = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
#line 148
  if ((h->flags & 31U) == 1U) {
#line 149
    i = (u_int16_t )0;
    {
#line 149
    while (1) {
      while_continue: /* CIL Label */ ;
#line 149
      if (! ((int )i < (int )top)) {
#line 149
        goto while_break;
      }
#line 150
      p = (char *)((BINTERNAL *)((char *)h + (int )h->linp[i]));
#line 151
      _tmp = *((u_int32_t *)p);
#line 151
      *(p + 0) = *((char *)(& _tmp) + 3);
#line 151
      *(p + 1) = *((char *)(& _tmp) + 2);
#line 151
      *(p + 2) = *((char *)(& _tmp) + 1);
#line 151
      *(p + 3) = *((char *)(& _tmp) + 0);
#line 152
      p += sizeof(u_int32_t );
#line 153
      _tmp___0 = *((u_int32_t *)p);
#line 153
      *(p + 0) = *((char *)(& _tmp___0) + 3);
#line 153
      *(p + 1) = *((char *)(& _tmp___0) + 2);
#line 153
      *(p + 2) = *((char *)(& _tmp___0) + 1);
#line 153
      *(p + 3) = *((char *)(& _tmp___0) + 0);
#line 154
      p += sizeof(u_int32_t );
#line 155
      if ((int )*((u_char *)p) & 2) {
#line 156
        p += sizeof(u_char );
#line 157
        _tmp___1 = *((u_int32_t *)p);
#line 157
        *(p + 0) = *((char *)(& _tmp___1) + 3);
#line 157
        *(p + 1) = *((char *)(& _tmp___1) + 2);
#line 157
        *(p + 2) = *((char *)(& _tmp___1) + 1);
#line 157
        *(p + 3) = *((char *)(& _tmp___1) + 0);
#line 158
        p += sizeof(u_int32_t );
#line 159
        _tmp___2 = *((u_int32_t *)p);
#line 159
        *(p + 0) = *((char *)(& _tmp___2) + 3);
#line 159
        *(p + 1) = *((char *)(& _tmp___2) + 2);
#line 159
        *(p + 2) = *((char *)(& _tmp___2) + 1);
#line 159
        *(p + 3) = *((char *)(& _tmp___2) + 0);
      }
#line 161
      _tmp___3 = h->linp[i];
#line 161
      *((char *)(& h->linp[i]) + 0) = *((char *)(& _tmp___3) + 1);
#line 161
      *((char *)(& h->linp[i]) + 1) = *((char *)(& _tmp___3) + 0);
#line 149
      i = (u_int16_t )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 163
  if ((h->flags & 31U) == 2U) {
#line 164
    i = (u_int16_t )0;
    {
#line 164
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 164
      if (! ((int )i < (int )top)) {
#line 164
        goto while_break___0;
      }
#line 165
      p = (char *)((BLEAF *)((char *)h + (int )h->linp[i]));
#line 166
      _tmp___4 = *((u_int32_t *)p);
#line 166
      *(p + 0) = *((char *)(& _tmp___4) + 3);
#line 166
      *(p + 1) = *((char *)(& _tmp___4) + 2);
#line 166
      *(p + 2) = *((char *)(& _tmp___4) + 1);
#line 166
      *(p + 3) = *((char *)(& _tmp___4) + 0);
#line 167
      p += sizeof(u_int32_t );
#line 168
      _tmp___5 = *((u_int32_t *)p);
#line 168
      *(p + 0) = *((char *)(& _tmp___5) + 3);
#line 168
      *(p + 1) = *((char *)(& _tmp___5) + 2);
#line 168
      *(p + 2) = *((char *)(& _tmp___5) + 1);
#line 168
      *(p + 3) = *((char *)(& _tmp___5) + 0);
#line 169
      p += sizeof(u_int32_t );
#line 170
      flags = *((u_char *)p);
#line 171
      if ((int )flags & 3) {
#line 172
        p += sizeof(u_char );
#line 173
        if ((int )flags & 2) {
#line 174
          _tmp___6 = *((u_int32_t *)p);
#line 174
          *(p + 0) = *((char *)(& _tmp___6) + 3);
#line 174
          *(p + 1) = *((char *)(& _tmp___6) + 2);
#line 174
          *(p + 2) = *((char *)(& _tmp___6) + 1);
#line 174
          *(p + 3) = *((char *)(& _tmp___6) + 0);
#line 175
          p += sizeof(u_int32_t );
#line 176
          _tmp___7 = *((u_int32_t *)p);
#line 176
          *(p + 0) = *((char *)(& _tmp___7) + 3);
#line 176
          *(p + 1) = *((char *)(& _tmp___7) + 2);
#line 176
          *(p + 2) = *((char *)(& _tmp___7) + 1);
#line 176
          *(p + 3) = *((char *)(& _tmp___7) + 0);
        }
#line 178
        if ((int )flags & 1) {
#line 179
          p += sizeof(u_int32_t );
#line 180
          _tmp___8 = *((u_int32_t *)p);
#line 180
          *(p + 0) = *((char *)(& _tmp___8) + 3);
#line 180
          *(p + 1) = *((char *)(& _tmp___8) + 2);
#line 180
          *(p + 2) = *((char *)(& _tmp___8) + 1);
#line 180
          *(p + 3) = *((char *)(& _tmp___8) + 0);
#line 181
          p += sizeof(u_int32_t );
#line 182
          _tmp___9 = *((u_int32_t *)p);
#line 182
          *(p + 0) = *((char *)(& _tmp___9) + 3);
#line 182
          *(p + 1) = *((char *)(& _tmp___9) + 2);
#line 182
          *(p + 2) = *((char *)(& _tmp___9) + 1);
#line 182
          *(p + 3) = *((char *)(& _tmp___9) + 0);
        }
      }
#line 185
      _tmp___10 = h->linp[i];
#line 185
      *((char *)(& h->linp[i]) + 0) = *((char *)(& _tmp___10) + 1);
#line 185
      *((char *)(& h->linp[i]) + 1) = *((char *)(& _tmp___10) + 0);
#line 164
      i = (u_int16_t )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 188
  _tmp___11 = h->pgno;
#line 188
  *((char *)(& h->pgno) + 0) = *((char *)(& _tmp___11) + 3);
#line 188
  *((char *)(& h->pgno) + 1) = *((char *)(& _tmp___11) + 2);
#line 188
  *((char *)(& h->pgno) + 2) = *((char *)(& _tmp___11) + 1);
#line 188
  *((char *)(& h->pgno) + 3) = *((char *)(& _tmp___11) + 0);
#line 189
  _tmp___12 = h->prevpg;
#line 189
  *((char *)(& h->prevpg) + 0) = *((char *)(& _tmp___12) + 3);
#line 189
  *((char *)(& h->prevpg) + 1) = *((char *)(& _tmp___12) + 2);
#line 189
  *((char *)(& h->prevpg) + 2) = *((char *)(& _tmp___12) + 1);
#line 189
  *((char *)(& h->prevpg) + 3) = *((char *)(& _tmp___12) + 0);
#line 190
  _tmp___13 = h->nextpg;
#line 190
  *((char *)(& h->nextpg) + 0) = *((char *)(& _tmp___13) + 3);
#line 190
  *((char *)(& h->nextpg) + 1) = *((char *)(& _tmp___13) + 2);
#line 190
  *((char *)(& h->nextpg) + 2) = *((char *)(& _tmp___13) + 1);
#line 190
  *((char *)(& h->nextpg) + 3) = *((char *)(& _tmp___13) + 0);
#line 191
  _tmp___14 = h->flags;
#line 191
  *((char *)(& h->flags) + 0) = *((char *)(& _tmp___14) + 3);
#line 191
  *((char *)(& h->flags) + 1) = *((char *)(& _tmp___14) + 2);
#line 191
  *((char *)(& h->flags) + 2) = *((char *)(& _tmp___14) + 1);
#line 191
  *((char *)(& h->flags) + 3) = *((char *)(& _tmp___14) + 0);
#line 192
  _tmp___15 = h->lower;
#line 192
  *((char *)(& h->lower) + 0) = *((char *)(& _tmp___15) + 1);
#line 192
  *((char *)(& h->lower) + 1) = *((char *)(& _tmp___15) + 0);
#line 193
  _tmp___16 = h->upper;
#line 193
  *((char *)(& h->upper) + 0) = *((char *)(& _tmp___16) + 1);
#line 193
  *((char *)(& h->upper) + 1) = *((char *)(& _tmp___16) + 0);
#line 194
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_conv.c"
static void mswap(PAGE *pg ) 
{ 
  char *p ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int32_t _tmp___4 ;

  {
#line 208
  p = (char *)pg;
#line 209
  _tmp = *((u_int32_t *)p);
#line 209
  *(p + 0) = *((char *)(& _tmp) + 3);
#line 209
  *(p + 1) = *((char *)(& _tmp) + 2);
#line 209
  *(p + 2) = *((char *)(& _tmp) + 1);
#line 209
  *(p + 3) = *((char *)(& _tmp) + 0);
#line 210
  p += sizeof(u_int32_t );
#line 211
  _tmp___0 = *((u_int32_t *)p);
#line 211
  *(p + 0) = *((char *)(& _tmp___0) + 3);
#line 211
  *(p + 1) = *((char *)(& _tmp___0) + 2);
#line 211
  *(p + 2) = *((char *)(& _tmp___0) + 1);
#line 211
  *(p + 3) = *((char *)(& _tmp___0) + 0);
#line 212
  p += sizeof(u_int32_t );
#line 213
  _tmp___1 = *((u_int32_t *)p);
#line 213
  *(p + 0) = *((char *)(& _tmp___1) + 3);
#line 213
  *(p + 1) = *((char *)(& _tmp___1) + 2);
#line 213
  *(p + 2) = *((char *)(& _tmp___1) + 1);
#line 213
  *(p + 3) = *((char *)(& _tmp___1) + 0);
#line 214
  p += sizeof(u_int32_t );
#line 215
  _tmp___2 = *((u_int32_t *)p);
#line 215
  *(p + 0) = *((char *)(& _tmp___2) + 3);
#line 215
  *(p + 1) = *((char *)(& _tmp___2) + 2);
#line 215
  *(p + 2) = *((char *)(& _tmp___2) + 1);
#line 215
  *(p + 3) = *((char *)(& _tmp___2) + 0);
#line 216
  p += sizeof(u_int32_t );
#line 217
  _tmp___3 = *((u_int32_t *)p);
#line 217
  *(p + 0) = *((char *)(& _tmp___3) + 3);
#line 217
  *(p + 1) = *((char *)(& _tmp___3) + 2);
#line 217
  *(p + 2) = *((char *)(& _tmp___3) + 1);
#line 217
  *(p + 3) = *((char *)(& _tmp___3) + 0);
#line 218
  p += sizeof(u_int32_t );
#line 219
  _tmp___4 = *((u_int32_t *)p);
#line 219
  *(p + 0) = *((char *)(& _tmp___4) + 3);
#line 219
  *(p + 1) = *((char *)(& _tmp___4) + 2);
#line 219
  *(p + 2) = *((char *)(& _tmp___4) + 1);
#line 219
  *(p + 3) = *((char *)(& _tmp___4) + 0);
#line 220
  p += sizeof(u_int32_t );
#line 221
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_close.c"
static int bt_meta(BTREE *t ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_close.c"
int __bt_close(DB *dbp ) 
{ 
  BTREE *t ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 70
  t = (BTREE *)dbp->internal;
#line 73
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 74
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 75
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
  {
#line 79
  tmp___1 = __bt_sync((DB const   *)dbp, (u_int )0);
  }
#line 79
  if (tmp___1 == -1) {
#line 80
    return (-1);
  }
  {
#line 83
  tmp___2 = __mpool_close(t->bt_mp);
  }
#line 83
  if (tmp___2 == -1) {
#line 84
    return (-1);
  }
#line 87
  if ((unsigned long )t->bt_cursor.key.data != (unsigned long )((void *)0)) {
    {
#line 88
    free(t->bt_cursor.key.data);
#line 89
    t->bt_cursor.key.size = (size_t )0;
#line 90
    t->bt_cursor.key.data = (void *)0;
    }
  }
#line 92
  if (t->bt_rkey.data) {
    {
#line 93
    free(t->bt_rkey.data);
#line 94
    t->bt_rkey.size = (size_t )0;
#line 95
    t->bt_rkey.data = (void *)0;
    }
  }
#line 97
  if (t->bt_rdata.data) {
    {
#line 98
    free(t->bt_rdata.data);
#line 99
    t->bt_rdata.size = (size_t )0;
#line 100
    t->bt_rdata.data = (void *)0;
    }
  }
  {
#line 103
  fd = t->bt_fd;
#line 104
  free((void *)t);
#line 105
  free((void *)dbp);
#line 106
  tmp___4 = close(fd);
  }
#line 106
  if (tmp___4) {
#line 106
    tmp___3 = -1;
  } else {
#line 106
    tmp___3 = 0;
  }
#line 106
  return (tmp___3);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_close.c"
int __bt_sync(DB const   *dbp , u_int flags ) 
{ 
  BTREE *t ;
  int status ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 126
  t = (BTREE *)dbp->internal;
#line 129
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 130
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 131
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
#line 135
  if (flags != 0U) {
    {
#line 136
    tmp___1 = __errno_location();
#line 136
    *tmp___1 = 22;
    }
#line 137
    return (-1);
  }
#line 140
  if (t->flags & 17U) {
#line 141
    return (0);
  } else
#line 140
  if (! (t->flags & 4U)) {
#line 141
    return (0);
  }
#line 143
  if (t->flags & 2U) {
    {
#line 143
    tmp___2 = bt_meta(t);
    }
#line 143
    if (tmp___2 == -1) {
#line 144
      return (-1);
    }
  }
  {
#line 146
  status = __mpool_sync(t->bt_mp);
  }
#line 146
  if (status == 0) {
#line 147
    t->flags &= 4294967291U;
  }
#line 149
  return (status);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_close.c"
static int bt_meta(BTREE *t ) 
{ 
  BTMETA m ;
  void *p ;

  {
  {
#line 168
  p = __mpool_get(t->bt_mp, (u_int32_t )0, (u_int )0);
  }
#line 168
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 169
    return (-1);
  }
  {
#line 172
  m.magic = (u_int32_t )340322;
#line 173
  m.version = (u_int32_t )3;
#line 174
  m.psize = t->bt_psize;
#line 175
  m.free = t->bt_free;
#line 176
  m.nrecs = t->bt_nrecs;
#line 177
  m.flags = t->flags & 160U;
#line 179
  memmove(p, (void const   *)(& m), sizeof(BTMETA ));
#line 180
  __mpool_put(t->bt_mp, p, (u_int )1);
  }
#line 181
  return (0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/extern.h"
int __bt_dleaf(BTREE *t , DBT const   *key , PAGE *h , u_int index___0 ) ;
#line 54
void __bt_setcur(BTREE *t , u_int32_t pgno , u_int index ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_put.c"
static EPG *bt_fast(BTREE *t , DBT const   *key , DBT const   *data , int *exactp ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_put.c"
int __bt_put(DB const   *dbp , DBT *key , DBT const   *data , u_int flags ) 
{ 
  BTREE *t ;
  DBT tkey ;
  DBT tdata ;
  EPG *e ;
  PAGE *h ;
  u_int16_t index___0 ;
  u_int16_t nxtindex ;
  u_int32_t pg ;
  u_int32_t nbytes ;
  int dflags ;
  int exact ;
  int status ;
  char *dest ;
  char db[sizeof(u_int32_t ) + sizeof(u_int32_t )] ;
  char kb[sizeof(u_int32_t ) + sizeof(u_int32_t )] ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int16_t tmp___7 ;

  {
#line 83
  t = (BTREE *)dbp->internal;
#line 86
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 87
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 88
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
#line 92
  if (t->flags & 16U) {
    {
#line 93
    tmp___1 = __errno_location();
#line 93
    *tmp___1 = 1;
    }
#line 94
    return (-1);
  }
  {
#line 99
  if (flags == 8U) {
#line 99
    goto case_8;
  }
#line 99
  if (flags == 0U) {
#line 99
    goto case_8;
  }
#line 101
  if (flags == 1U) {
#line 101
    goto case_1;
  }
#line 111
  goto switch_default;
  case_8: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 100
  goto switch_break;
  case_1: /* CIL Label */ 
#line 106
  if ((int )t->bt_cursor.flags & 8) {
#line 106
    if (! ((int )t->bt_cursor.flags & 7)) {
#line 109
      goto switch_break;
    }
  }
  switch_default: /* CIL Label */ 
  {
#line 112
  tmp___2 = __errno_location();
#line 112
  *tmp___2 = 22;
  }
#line 113
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 124
  dflags = 0;
#line 125
  if (key->size + (size_t )data->size > (size_t )t->bt_ovflsize) {
#line 126
    if (key->size > (size_t )t->bt_ovflsize) {
      storekey: 
      {
#line 127
      tmp___3 = __ovfl_put(t, (DBT const   *)key, & pg);
      }
#line 127
      if (tmp___3 == -1) {
#line 128
        return (-1);
      }
      {
#line 129
      tkey.data = (void *)(kb);
#line 130
      tkey.size = sizeof(u_int32_t ) + sizeof(u_int32_t );
#line 131
      memmove((void *)(kb), (void const   *)(& pg), sizeof(u_int32_t ));
#line 132
      memmove((void *)(kb + sizeof(u_int32_t )), (void const   *)(& key->size), sizeof(u_int32_t ));
#line 134
      dflags |= 2;
#line 135
      key = & tkey;
      }
    }
#line 137
    if (key->size + (size_t )data->size > (size_t )t->bt_ovflsize) {
      {
#line 138
      tmp___4 = __ovfl_put(t, data, & pg);
      }
#line 138
      if (tmp___4 == -1) {
#line 139
        return (-1);
      }
      {
#line 140
      tdata.data = (void *)(db);
#line 141
      tdata.size = sizeof(u_int32_t ) + sizeof(u_int32_t );
#line 142
      memmove((void *)(db), (void const   *)(& pg), sizeof(u_int32_t ));
#line 143
      memmove((void *)(db + sizeof(u_int32_t )), (void const   *)(& data->size), sizeof(u_int32_t ));
#line 145
      dflags |= 1;
#line 146
      data = (DBT const   *)(& tdata);
      }
    }
#line 148
    if (key->size + (size_t )data->size > (size_t )t->bt_ovflsize) {
#line 149
      goto storekey;
    }
  }
#line 153
  if (flags == 1U) {
    {
#line 154
    tmp___5 = __mpool_get(t->bt_mp, t->bt_cursor.pg.pgno, (u_int )0);
#line 154
    h = (PAGE *)tmp___5;
    }
#line 154
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 155
      return (-1);
    }
#line 156
    index___0 = t->bt_cursor.pg.index;
#line 157
    goto delete;
  }
#line 164
  if ((unsigned int )t->bt_order == 0U) {
#line 164
    goto _L;
  } else {
    {
#line 164
    e = bt_fast(t, (DBT const   *)key, data, & exact);
    }
#line 164
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 165
      e = __bt_search(t, (DBT const   *)key, & exact);
      }
#line 165
      if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 166
        return (-1);
      }
    }
  }
#line 167
  h = e->page;
#line 168
  index___0 = e->index;
  {
#line 177
  if (flags == 8U) {
#line 177
    goto case_8___0;
  }
#line 182
  goto switch_default___0;
  case_8___0: /* CIL Label */ 
#line 178
  if (! exact) {
#line 179
    goto switch_break___0;
  }
  {
#line 180
  __mpool_put(t->bt_mp, (void *)h, (u_int )0);
  }
#line 181
  return (1);
  switch_default___0: /* CIL Label */ 
#line 183
  if (! exact) {
#line 184
    goto switch_break___0;
  } else
#line 183
  if (! (t->flags & 32U)) {
#line 184
    goto switch_break___0;
  }
  delete: 
  {
#line 190
  tmp___6 = __bt_dleaf(t, (DBT const   *)key, h, (u_int )index___0);
  }
#line 190
  if (tmp___6 == -1) {
    {
#line 191
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 192
    return (-1);
  }
#line 194
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 203
  nbytes = (u_int32_t )(((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + key->size) + (unsigned long )data->size) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 204
  if ((unsigned long )((u_int32_t )((int )h->upper - (int )h->lower)) < (unsigned long )nbytes + sizeof(u_int16_t )) {
    {
#line 205
    status = __bt_split(t, h, (DBT const   *)key, data, dflags, (size_t )nbytes, (u_int32_t )index___0);
    }
#line 205
    if (status != 0) {
#line 207
      return (status);
    }
#line 208
    goto success;
  }
#line 211
  nxtindex = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
#line 211
  if ((int )index___0 < (int )nxtindex) {
    {
#line 212
    memmove((void *)((h->linp + (int )index___0) + 1), (void const   *)(h->linp + (int )index___0),
            (unsigned long )((int )nxtindex - (int )index___0) * sizeof(u_int16_t ));
    }
  }
  {
#line 214
  h->lower = (u_int16_t )((unsigned long )h->lower + sizeof(u_int16_t ));
#line 216
  tmp___7 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 216
  h->upper = tmp___7;
#line 216
  h->linp[index___0] = tmp___7;
#line 217
  dest = (char *)h + (int )h->upper;
#line 218
  *((u_int32_t *)dest) = (u_int32_t )key->size;
#line 218
  dest += sizeof(u_int32_t );
#line 218
  *((u_int32_t *)dest) = (u_int32_t )data->size;
#line 218
  dest += sizeof(u_int32_t );
#line 218
  *((u_char *)dest) = (u_char )dflags;
#line 218
  dest += sizeof(u_char );
#line 218
  memmove((void *)dest, (void const   *)key->data, key->size);
#line 218
  dest += key->size;
#line 218
  memmove((void *)dest, (void const   *)data->data, (size_t )data->size);
  }
#line 221
  if ((int )t->bt_cursor.flags & 8) {
#line 221
    if (! ((int )t->bt_cursor.flags & 1)) {
#line 221
      if (t->bt_cursor.pg.pgno == h->pgno) {
#line 221
        if ((int )t->bt_cursor.pg.index >= (int )index___0) {
#line 224
          t->bt_cursor.pg.index = (u_int16_t )((int )t->bt_cursor.pg.index + 1);
        }
      }
    }
  }
#line 226
  if ((unsigned int )t->bt_order == 0U) {
#line 227
    if (h->nextpg == 0U) {
#line 228
      if ((unsigned long )index___0 == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL) {
#line 229
        t->bt_order = (enum __anonenum_bt_order_54 )2;
#line 230
        t->bt_last.index = index___0;
#line 231
        t->bt_last.pgno = h->pgno;
      }
    } else
#line 233
    if (h->prevpg == 0U) {
#line 234
      if ((int )index___0 == 0) {
#line 235
        t->bt_order = (enum __anonenum_bt_order_54 )1;
#line 236
        t->bt_last.index = (u_int16_t )0;
#line 237
        t->bt_last.pgno = h->pgno;
      }
    }
  }
  {
#line 242
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
  success: 
#line 245
  if (flags == 10U) {
    {
#line 246
    __bt_setcur(t, (e->page)->pgno, (u_int )e->index);
    }
  }
#line 248
  t->flags |= 4U;
#line 249
  return (0);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_put.c"
static EPG *bt_fast(BTREE *t , DBT const   *key , DBT const   *data , int *exactp ) 
{ 
  PAGE *h ;
  u_int32_t nbytes ;
  int cmp ;
  void *tmp___1 ;

  {
  {
#line 276
  tmp___1 = __mpool_get(t->bt_mp, t->bt_last.pgno, (u_int )0);
#line 276
  h = (PAGE *)tmp___1;
  }
#line 276
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 277
    t->bt_order = (enum __anonenum_bt_order_54 )0;
#line 278
    return ((EPG *)((void *)0));
  }
#line 280
  t->bt_cur.page = h;
#line 281
  t->bt_cur.index = t->bt_last.index;
#line 287
  nbytes = (u_int32_t )(((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )key->size) + (unsigned long )data->size) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 288
  if ((unsigned long )((u_int32_t )((int )h->upper - (int )h->lower)) < (unsigned long )nbytes + sizeof(u_int16_t )) {
#line 289
    goto miss;
  }
#line 291
  if ((unsigned int )t->bt_order == 2U) {
#line 292
    if ((t->bt_cur.page)->nextpg != 0U) {
#line 293
      goto miss;
    }
#line 294
    if ((unsigned long )t->bt_cur.index != ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL) {
#line 295
      goto miss;
    }
    {
#line 296
    cmp = __bt_cmp(t, key, & t->bt_cur);
    }
#line 296
    if (cmp < 0) {
#line 297
      goto miss;
    }
#line 298
    if (cmp) {
#line 298
      t->bt_cur.index = (u_int16_t )((int )t->bt_cur.index + 1);
#line 298
      t->bt_last.index = t->bt_cur.index;
    } else {
#line 298
      t->bt_last.index = t->bt_cur.index;
    }
  } else {
#line 300
    if ((t->bt_cur.page)->prevpg != 0U) {
#line 301
      goto miss;
    }
#line 302
    if ((int )t->bt_cur.index != 0) {
#line 303
      goto miss;
    }
    {
#line 304
    cmp = __bt_cmp(t, key, & t->bt_cur);
    }
#line 304
    if (cmp > 0) {
#line 305
      goto miss;
    }
#line 306
    t->bt_last.index = (u_int16_t )0;
  }
#line 308
  *exactp = cmp == 0;
#line 312
  return (& t->bt_cur);
  miss: 
  {
#line 318
  t->bt_order = (enum __anonenum_bt_order_54 )0;
#line 319
  __mpool_put(t->bt_mp, (void *)h, (u_int )0);
  }
#line 320
  return ((EPG *)((void *)0));
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/extern.h"
int __rec_fmap(BTREE *t , u_int32_t top ) ;
#line 52
int __rec_vmap(BTREE *t , u_int32_t top ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_get.c"
int __rec_get(DB const   *dbp , DBT const   *key , DBT *data , u_int flags ) 
{ 
  BTREE *t ;
  EPG *e ;
  u_int32_t nrec ;
  int status ;
  int *tmp___1 ;

  {
#line 74
  t = (BTREE *)dbp->internal;
#line 77
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 78
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 79
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
#line 83
  if (flags) {
    {
#line 84
    tmp___1 = __errno_location();
#line 84
    *tmp___1 = 22;
    }
#line 85
    return (-1);
  } else {
#line 83
    nrec = *((u_int32_t *)key->data);
#line 83
    if (nrec == 0U) {
      {
#line 84
      tmp___1 = __errno_location();
#line 84
      *tmp___1 = 22;
      }
#line 85
      return (-1);
    }
  }
#line 92
  if (nrec > t->bt_nrecs) {
#line 93
    if (t->flags & 2304U) {
#line 94
      return (1);
    }
    {
#line 95
    status = (*(t->bt_irec))(t, nrec);
    }
#line 95
    if (status != 0) {
#line 96
      return (status);
    }
  }
  {
#line 99
  nrec --;
#line 100
  e = __rec_search(t, nrec, (enum SRCHOP )2);
  }
#line 100
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 101
    return (-1);
  }
  {
#line 103
  status = __rec_ret(t, e, (u_int32_t )0, (DBT *)((void *)0), data);
  }
#line 104
  if (t->flags & 16384U) {
    {
#line 105
    __mpool_put(t->bt_mp, (void *)e->page, (u_int )0);
    }
  } else {
#line 107
    t->bt_pinned = e->page;
  }
#line 108
  return (status);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_get.c"
int __rec_fpipe(BTREE *t , u_int32_t top ) 
{ 
  DBT data ;
  u_int32_t nrec ;
  size_t len ;
  int ch ;
  u_char *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  int tmp___4 ;

  {
#line 132
  if (t->bt_rdata.size < t->bt_reclen) {
#line 133
    if ((unsigned long )t->bt_rdata.data == (unsigned long )((void *)0)) {
      {
#line 133
      tmp___1 = malloc(t->bt_reclen);
#line 133
      t->bt_rdata.data = tmp___1;
      }
    } else {
      {
#line 133
      tmp___2 = realloc(t->bt_rdata.data, t->bt_reclen);
#line 133
      t->bt_rdata.data = tmp___2;
      }
    }
#line 136
    if ((unsigned long )t->bt_rdata.data == (unsigned long )((void *)0)) {
#line 137
      return (-1);
    }
#line 138
    t->bt_rdata.size = t->bt_reclen;
  }
#line 140
  data.data = t->bt_rdata.data;
#line 141
  data.size = t->bt_reclen;
#line 143
  nrec = t->bt_nrecs;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (nrec < top)) {
#line 143
      goto while_break;
    }
#line 144
    len = t->bt_reclen;
#line 145
    p = (u_char *)t->bt_rdata.data;
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 146
      ch = _IO_getc(t->bt_rfp);
      }
#line 146
      if (ch == -1) {
#line 146
        goto _L;
      } else {
#line 146
        len --;
#line 146
        if (! len) {
          _L: /* CIL Label */ 
#line 147
          if (ch != -1) {
#line 148
            *p = (u_char )ch;
          }
#line 149
          if (len != 0UL) {
            {
#line 150
            memset((void *)p, (int )t->bt_bval, len);
            }
          }
          {
#line 151
          tmp___4 = __rec_iput(t, nrec, (DBT const   *)(& data), (u_int )0);
          }
#line 151
          if (tmp___4 != 0) {
#line 153
            return (-1);
          }
#line 154
          nrec ++;
#line 155
          goto while_break___0;
        }
      }
#line 145
      tmp___3 = p;
#line 145
      p ++;
#line 145
      *tmp___3 = (u_char )ch;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 157
    if (ch == -1) {
#line 158
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if (nrec < top) {
#line 161
    t->flags |= 256U;
#line 162
    return (1);
  }
#line 164
  return (0);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_get.c"
int __rec_vpipe(BTREE *t , u_int32_t top ) 
{ 
  DBT data ;
  u_int32_t nrec ;
  u_int16_t len ;
  size_t sz ;
  int bval ;
  int ch ;
  u_char *p ;
  u_char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 189
  bval = (int )t->bt_bval;
#line 190
  nrec = t->bt_nrecs;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (nrec < top)) {
#line 190
      goto while_break;
    }
#line 191
    p = (u_char *)t->bt_rdata.data;
#line 191
    sz = t->bt_rdata.size;
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 193
      ch = _IO_getc(t->bt_rfp);
      }
#line 193
      if (ch == -1) {
#line 193
        goto _L;
      } else
#line 193
      if (ch == bval) {
        _L: /* CIL Label */ 
#line 194
        data.data = t->bt_rdata.data;
#line 195
        data.size = (size_t )(p - (u_char *)t->bt_rdata.data);
#line 196
        if (ch == -1) {
#line 196
          if (data.size == 0UL) {
#line 197
            goto while_break___0;
          }
        }
        {
#line 198
        tmp___2 = __rec_iput(t, nrec, (DBT const   *)(& data), (u_int )0);
        }
#line 198
        if (tmp___2 != 0) {
#line 200
          return (-1);
        }
#line 201
        goto while_break___0;
      }
#line 203
      if (sz == 0UL) {
#line 204
        len = (u_int16_t )(p - (u_char *)t->bt_rdata.data);
#line 205
        sz = (size_t )256;
#line 205
        t->bt_rdata.size += sz;
#line 206
        if ((unsigned long )t->bt_rdata.data == (unsigned long )((void *)0)) {
          {
#line 206
          tmp___3 = malloc(t->bt_rdata.size);
#line 206
          t->bt_rdata.data = tmp___3;
          }
        } else {
          {
#line 206
          tmp___4 = realloc(t->bt_rdata.data, t->bt_rdata.size);
#line 206
          t->bt_rdata.data = tmp___4;
          }
        }
#line 209
        if ((unsigned long )t->bt_rdata.data == (unsigned long )((void *)0)) {
#line 210
          return (-1);
        }
#line 211
        p = (u_char *)t->bt_rdata.data + (int )len;
      }
#line 191
      tmp___1 = p;
#line 191
      p ++;
#line 191
      *tmp___1 = (u_char )ch;
#line 191
      sz --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 214
    if (ch == -1) {
#line 215
      goto while_break;
    }
#line 190
    nrec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  if (nrec < top) {
#line 218
    t->flags |= 256U;
#line 219
    return (1);
  }
#line 221
  return (0);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_get.c"
int __rec_fmap(BTREE *t , u_int32_t top ) 
{ 
  DBT data ;
  u_int32_t nrec ;
  u_char *sp ;
  u_char *ep ;
  u_char *p ;
  size_t len ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  int tmp___5 ;

  {
#line 244
  if (t->bt_rdata.size < t->bt_reclen) {
#line 245
    if ((unsigned long )t->bt_rdata.data == (unsigned long )((void *)0)) {
      {
#line 245
      tmp___1 = malloc(t->bt_reclen);
#line 245
      t->bt_rdata.data = tmp___1;
      }
    } else {
      {
#line 245
      tmp___2 = realloc(t->bt_rdata.data, t->bt_reclen);
#line 245
      t->bt_rdata.data = tmp___2;
      }
    }
#line 248
    if ((unsigned long )t->bt_rdata.data == (unsigned long )((void *)0)) {
#line 249
      return (-1);
    }
#line 250
    t->bt_rdata.size = t->bt_reclen;
  }
#line 252
  data.data = t->bt_rdata.data;
#line 253
  data.size = t->bt_reclen;
#line 255
  sp = (u_char *)t->bt_cmap;
#line 256
  ep = (u_char *)t->bt_emap;
#line 257
  nrec = t->bt_nrecs;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (nrec < top)) {
#line 257
      goto while_break;
    }
#line 258
    if ((unsigned long )sp >= (unsigned long )ep) {
#line 259
      t->flags |= 256U;
#line 260
      return (1);
    }
#line 262
    len = t->bt_reclen;
#line 263
    p = (u_char *)t->bt_rdata.data;
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 263
      if ((unsigned long )sp < (unsigned long )ep) {
#line 263
        if (! (len > 0UL)) {
#line 263
          goto while_break___0;
        }
      } else {
#line 263
        goto while_break___0;
      }
#line 263
      tmp___3 = p;
#line 263
      p ++;
#line 263
      tmp___4 = sp;
#line 263
      sp ++;
#line 263
      *tmp___3 = *tmp___4;
#line 263
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 265
    if (len != 0UL) {
      {
#line 266
      memset((void *)p, (int )t->bt_bval, len);
      }
    }
    {
#line 267
    tmp___5 = __rec_iput(t, nrec, (DBT const   *)(& data), (u_int )0);
    }
#line 267
    if (tmp___5 != 0) {
#line 268
      return (-1);
    }
#line 257
    nrec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  t->bt_cmap = (caddr_t )sp;
#line 271
  return (0);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_get.c"
int __rec_vmap(BTREE *t , u_int32_t top ) 
{ 
  DBT data ;
  u_char *sp ;
  u_char *ep ;
  u_int32_t nrec ;
  int bval ;
  int tmp___1 ;

  {
#line 294
  sp = (u_char *)t->bt_cmap;
#line 295
  ep = (u_char *)t->bt_emap;
#line 296
  bval = (int )t->bt_bval;
#line 298
  nrec = t->bt_nrecs;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (nrec < top)) {
#line 298
      goto while_break;
    }
#line 299
    if ((unsigned long )sp >= (unsigned long )ep) {
#line 300
      t->flags |= 256U;
#line 301
      return (1);
    }
#line 303
    data.data = (void *)sp;
    {
#line 303
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 303
      if ((unsigned long )sp < (unsigned long )ep) {
#line 303
        if (! ((int )*sp != bval)) {
#line 303
          goto while_break___0;
        }
      } else {
#line 303
        goto while_break___0;
      }
#line 303
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 304
    data.size = (size_t )(sp - (u_char *)data.data);
#line 305
    tmp___1 = __rec_iput(t, nrec, (DBT const   *)(& data), (u_int )0);
    }
#line 305
    if (tmp___1 != 0) {
#line 306
      return (-1);
    }
#line 307
    sp ++;
#line 298
    nrec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  t->bt_cmap = (caddr_t )sp;
#line 310
  return (0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/../btree/extern.h"
int __ovfl_get(BTREE *t , void *p , size_t *ssz , void **buf , size_t *bufsz ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_utils.c"
int __rec_ret(BTREE *t , EPG *e , u_int32_t nrec , DBT *key , DBT *data ) 
{ 
  RLEAF *rl ;
  void *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 71
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 72
    goto dataonly;
  }
#line 75
  if (sizeof(u_int32_t ) > t->bt_rkey.size) {
#line 76
    if ((unsigned long )t->bt_rkey.data == (unsigned long )((void *)0)) {
      {
#line 76
      tmp___1 = malloc(sizeof(u_int32_t ));
#line 76
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 76
      tmp___2 = realloc(t->bt_rkey.data, sizeof(u_int32_t ));
#line 76
      tmp___3 = tmp___2;
      }
    }
#line 76
    p = tmp___3;
#line 79
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 80
      return (-1);
    }
#line 81
    t->bt_rkey.data = p;
#line 82
    t->bt_rkey.size = sizeof(u_int32_t );
  }
  {
#line 84
  memmove(t->bt_rkey.data, (void const   *)(& nrec), sizeof(u_int32_t ));
#line 85
  key->size = sizeof(u_int32_t );
#line 86
  key->data = t->bt_rkey.data;
  }
  dataonly: 
#line 89
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 90
    return (0);
  }
#line 97
  rl = (RLEAF *)((char *)e->page + (int )(e->page)->linp[e->index]);
#line 98
  if ((int )rl->flags & 1) {
    {
#line 99
    tmp___4 = __ovfl_get(t, (void *)(rl->bytes), & data->size, & t->bt_rdata.data,
                         & t->bt_rdata.size);
    }
#line 99
    if (tmp___4) {
#line 101
      return (-1);
    }
#line 102
    data->data = t->bt_rdata.data;
  } else
#line 103
  if (t->flags & 16384U) {
#line 105
    if ((size_t )(rl->dsize + 1U) > t->bt_rdata.size) {
#line 106
      if ((unsigned long )t->bt_rdata.data == (unsigned long )((void *)0)) {
        {
#line 106
        tmp___5 = malloc((size_t )(rl->dsize + 1U));
#line 106
        tmp___7 = tmp___5;
        }
      } else {
        {
#line 106
        tmp___6 = realloc(t->bt_rdata.data, (size_t )(rl->dsize + 1U));
#line 106
        tmp___7 = tmp___6;
        }
      }
#line 106
      p = tmp___7;
#line 109
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 110
        return (-1);
      }
#line 111
      t->bt_rdata.data = p;
#line 112
      t->bt_rdata.size = (size_t )(rl->dsize + 1U);
    }
    {
#line 114
    memmove(t->bt_rdata.data, (void const   *)(rl->bytes), (size_t )rl->dsize);
#line 115
    data->size = (size_t )rl->dsize;
#line 116
    data->data = t->bt_rdata.data;
    }
  } else {
#line 118
    data->size = (size_t )rl->dsize;
#line 119
    data->data = (void *)(rl->bytes);
  }
#line 121
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_func.c"
static u_int32_t hash4(void const   *keyarg , size_t len ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_func.c"
u_int32_t (*__default_hash)(void const   * , size_t  )  =    & hash4;
#line 165 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_func.c"
static u_int32_t hash4(void const   *keyarg , size_t len ) 
{ 
  register u_char const   *key ;
  register size_t loop ;
  register u_int32_t h ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char const   *tmp___3 ;
  u_char const   *tmp___4 ;
  u_char const   *tmp___5 ;
  u_char const   *tmp___6 ;
  u_char const   *tmp___7 ;
  u_char const   *tmp___8 ;

  {
#line 178
  h = (u_int32_t )0;
#line 179
  key = (u_char const   *)keyarg;
#line 180
  if (len > 0UL) {
#line 181
    loop = ((len + 8UL) - 1UL) >> 3;
    {
#line 184
    if ((len & 7UL) == 0UL) {
#line 184
      goto case_0;
    }
#line 188
    if ((len & 7UL) == 7UL) {
#line 188
      goto case_7;
    }
#line 191
    if ((len & 7UL) == 6UL) {
#line 191
      goto case_6;
    }
#line 194
    if ((len & 7UL) == 5UL) {
#line 194
      goto case_5;
    }
#line 197
    if ((len & 7UL) == 4UL) {
#line 197
      goto case_4;
    }
#line 200
    if ((len & 7UL) == 3UL) {
#line 200
      goto case_3;
    }
#line 203
    if ((len & 7UL) == 2UL) {
#line 203
      goto case_2;
    }
#line 206
    if ((len & 7UL) == 1UL) {
#line 206
      goto case_1;
    }
#line 183
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 186
      tmp___1 = key;
#line 186
      key ++;
#line 186
      h = ((h << 5) + h) + (u_int32_t )*tmp___1;
      case_7: /* CIL Label */ 
#line 189
      tmp___2 = key;
#line 189
      key ++;
#line 189
      h = ((h << 5) + h) + (u_int32_t )*tmp___2;
      case_6: /* CIL Label */ 
#line 192
      tmp___3 = key;
#line 192
      key ++;
#line 192
      h = ((h << 5) + h) + (u_int32_t )*tmp___3;
      case_5: /* CIL Label */ 
#line 195
      tmp___4 = key;
#line 195
      key ++;
#line 195
      h = ((h << 5) + h) + (u_int32_t )*tmp___4;
      case_4: /* CIL Label */ 
#line 198
      tmp___5 = key;
#line 198
      key ++;
#line 198
      h = ((h << 5) + h) + (u_int32_t )*tmp___5;
      case_3: /* CIL Label */ 
#line 201
      tmp___6 = key;
#line 201
      key ++;
#line 201
      h = ((h << 5) + h) + (u_int32_t )*tmp___6;
      case_2: /* CIL Label */ 
#line 204
      tmp___7 = key;
#line 204
      key ++;
#line 204
      h = ((h << 5) + h) + (u_int32_t )*tmp___7;
      case_1: /* CIL Label */ 
#line 207
      tmp___8 = key;
#line 207
      key ++;
#line 207
      h = ((h << 5) + h) + (u_int32_t )*tmp___8;
#line 185
      loop --;
#line 185
      if (! loop) {
#line 185
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 211
  return (h);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
static int __bt_first(BTREE *t , DBT const   *key , EPG *erval , int *exactp ) ;
#line 52
static int __bt_seqadv(BTREE *t , EPG *ep , int flags ) ;
#line 53
static int __bt_seqset(BTREE *t , EPG *ep , DBT *key , int flags ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
int __bt_seq(DB const   *dbp , DBT *key , DBT *data , u_int flags ) 
{ 
  BTREE *t ;
  EPG e ;
  int status ;
  int *tmp___1 ;

  {
#line 86
  t = (BTREE *)dbp->internal;
#line 89
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 90
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 91
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
  {
#line 101
  if (flags == 9U) {
#line 101
    goto case_9;
  }
#line 101
  if (flags == 7U) {
#line 101
    goto case_9;
  }
#line 109
  if (flags == 1U) {
#line 109
    goto case_1;
  }
#line 109
  if (flags == 6U) {
#line 109
    goto case_1;
  }
#line 109
  if (flags == 3U) {
#line 109
    goto case_1;
  }
#line 112
  goto switch_default;
  case_9: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 102
  if ((int )t->bt_cursor.flags & 8) {
    {
#line 103
    status = __bt_seqadv(t, & e, (int )flags);
    }
#line 104
    goto switch_break;
  }
  case_1: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 110
  status = __bt_seqset(t, & e, key, (int )flags);
  }
#line 111
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 113
  tmp___1 = __errno_location();
#line 113
  *tmp___1 = 22;
  }
#line 114
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 117
  if (status == 0) {
    {
#line 118
    __bt_setcur(t, (e.page)->pgno, (u_int )e.index);
#line 120
    status = __bt_ret(t, & e, key, & t->bt_rkey, data, & t->bt_rdata, 0);
    }
#line 127
    if (t->flags & 16384U) {
      {
#line 128
      __mpool_put(t->bt_mp, (void *)e.page, (u_int )0);
      }
    } else {
#line 130
      t->bt_pinned = e.page;
    }
  }
#line 132
  return (status);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
static int __bt_seqset(BTREE *t , EPG *ep , DBT *key , int flags ) 
{ 
  PAGE *h ;
  u_int32_t pg ;
  int exact ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 168
  if (flags == 1) {
#line 168
    goto case_1;
  }
#line 179
  if (flags == 7) {
#line 179
    goto case_7;
  }
#line 179
  if (flags == 3) {
#line 179
    goto case_7;
  }
#line 200
  if (flags == 9) {
#line 200
    goto case_9;
  }
#line 200
  if (flags == 6) {
#line 200
    goto case_9;
  }
#line 167
  goto switch_break;
  case_1: /* CIL Label */ 
#line 173
  if ((unsigned long )key->data == (unsigned long )((void *)0)) {
    {
#line 174
    tmp___1 = __errno_location();
#line 174
    *tmp___1 = 22;
    }
#line 175
    return (-1);
  } else
#line 173
  if (key->size == 0UL) {
    {
#line 174
    tmp___1 = __errno_location();
#line 174
    *tmp___1 = 22;
    }
#line 175
    return (-1);
  }
  {
#line 177
  tmp___2 = __bt_first(t, (DBT const   *)key, ep, & exact);
  }
#line 177
  return (tmp___2);
  case_7: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 181
  pg = (u_int32_t )1;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 182
    tmp___3 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 182
    h = (PAGE *)tmp___3;
    }
#line 182
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 183
      return (-1);
    }
#line 186
    if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 0UL) {
      {
#line 187
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
#line 188
      return (1);
    }
#line 191
    if (h->flags & 18U) {
#line 192
      goto while_break;
    }
    {
#line 193
    pg = ((BINTERNAL *)((char *)h + (int )h->linp[0]))->pgno;
#line 194
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  ep->page = h;
#line 197
  ep->index = (u_int16_t )0;
#line 198
  goto switch_break;
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 202
  pg = (u_int32_t )1;
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 203
    tmp___4 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 203
    h = (PAGE *)tmp___4;
    }
#line 203
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 204
      return (-1);
    }
#line 207
    if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 0UL) {
      {
#line 208
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
#line 209
      return (1);
    }
#line 212
    if (h->flags & 18U) {
#line 213
      goto while_break___0;
    }
    {
#line 214
    pg = ((BINTERNAL *)((char *)h + (int )h->linp[((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL]))->pgno;
#line 215
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 218
  ep->page = h;
#line 219
  ep->index = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
#line 220
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 222
  return (0);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
static int __bt_seqadv(BTREE *t , EPG *ep , int flags ) 
{ 
  CURSOR *c ;
  PAGE *h ;
  u_int16_t index ;
  u_int32_t pg ;
  int exact ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 255
  c = & t->bt_cursor;
#line 265
  if ((int )c->flags & 1) {
    {
#line 266
    tmp___1 = __bt_first(t, (DBT const   *)(& c->key), ep, & exact);
    }
#line 266
    return (tmp___1);
  }
  {
#line 269
  tmp___2 = __mpool_get(t->bt_mp, c->pg.pgno, (u_int )0);
#line 269
  h = (PAGE *)tmp___2;
  }
#line 269
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 270
    return (-1);
  }
  {
#line 277
  if (flags == 7) {
#line 277
    goto case_7;
  }
#line 296
  if (flags == 9) {
#line 296
    goto case_9;
  }
#line 276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 283
  if ((int )c->flags & 2) {
#line 284
    goto usecurrent;
  }
#line 285
  index = c->pg.index;
#line 286
  index = (u_int16_t )((int )index + 1);
#line 286
  if ((unsigned long )index == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
    {
#line 287
    pg = h->nextpg;
#line 288
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 289
    if (pg == 0U) {
#line 290
      return (1);
    }
    {
#line 291
    tmp___3 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 291
    h = (PAGE *)tmp___3;
    }
#line 291
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 292
      return (-1);
    }
#line 293
    index = (u_int16_t )0;
  }
#line 295
  goto switch_break;
  case_9: /* CIL Label */ 
#line 302
  if ((int )c->flags & 4) {
    usecurrent: 
#line 303
    c->flags = (u_int8_t )((int )c->flags & -7);
#line 304
    ep->page = h;
#line 305
    ep->index = c->pg.index;
#line 306
    return (0);
  }
#line 308
  index = c->pg.index;
#line 309
  if ((int )index == 0) {
    {
#line 310
    pg = h->prevpg;
#line 311
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 312
    if (pg == 0U) {
#line 313
      return (1);
    }
    {
#line 314
    tmp___4 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 314
    h = (PAGE *)tmp___4;
    }
#line 314
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 315
      return (-1);
    }
#line 316
    index = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
  } else {
#line 318
    index = (u_int16_t )((int )index - 1);
  }
#line 319
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 322
  ep->page = h;
#line 323
  ep->index = index;
#line 324
  return (0);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
static int __bt_first(BTREE *t , DBT const   *key , EPG *erval , int *exactp ) 
{ 
  PAGE *h ;
  EPG *ep ;
  EPG save ;
  u_int32_t pg ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 360
  ep = __bt_search(t, key, exactp);
  }
#line 360
  if ((unsigned long )ep == (unsigned long )((void *)0)) {
#line 361
    return (1);
  }
#line 362
  if (*exactp) {
#line 363
    if (t->flags & 32U) {
#line 364
      *erval = *ep;
#line 365
      return (0);
    }
#line 373
    save = *ep;
#line 374
    h = ep->page;
    {
#line 375
    while (1) {
      while_continue: /* CIL Label */ ;
#line 376
      if ((save.page)->pgno != (ep->page)->pgno) {
        {
#line 377
        __mpool_put(t->bt_mp, (void *)save.page, (u_int )0);
#line 378
        save = *ep;
        }
      } else {
#line 380
        save.index = ep->index;
      }
#line 387
      if ((int )ep->index == 0) {
#line 388
        if (h->prevpg == 0U) {
#line 389
          goto while_break;
        }
#line 390
        if (h->pgno != (save.page)->pgno) {
          {
#line 391
          __mpool_put(t->bt_mp, (void *)h, (u_int )0);
          }
        }
        {
#line 392
        tmp___1 = __mpool_get(t->bt_mp, h->prevpg, (u_int )0);
#line 392
        h = (PAGE *)tmp___1;
        }
#line 392
        if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 394
          if (h->pgno == (save.page)->pgno) {
            {
#line 395
            __mpool_put(t->bt_mp, (void *)save.page, (u_int )0);
            }
          }
#line 397
          return (-1);
        }
#line 399
        ep->page = h;
#line 400
        ep->index = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
      }
      {
#line 402
      ep->index = (u_int16_t )((int )ep->index - 1);
#line 375
      tmp___2 = __bt_cmp(t, key, ep);
      }
#line 375
      if (! (tmp___2 == 0)) {
#line 375
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 410
    if (h->pgno != (save.page)->pgno) {
      {
#line 411
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
    }
#line 413
    *erval = save;
#line 414
    return (0);
  }
#line 418
  if ((unsigned long )ep->index == ((unsigned long )(ep->page)->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
    {
#line 419
    h = ep->page;
#line 420
    pg = h->nextpg;
#line 421
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 422
    if (pg == 0U) {
#line 423
      return (1);
    }
    {
#line 424
    tmp___3 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 424
    h = (PAGE *)tmp___3;
    }
#line 424
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 425
      return (-1);
    }
#line 426
    ep->index = (u_int16_t )0;
#line 427
    ep->page = h;
  }
#line 429
  *erval = *ep;
#line 430
  return (0);
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
void __bt_setcur(BTREE *t , u_int32_t pgno , u_int index ) 
{ 


  {
#line 449
  if ((unsigned long )t->bt_cursor.key.data != (unsigned long )((void *)0)) {
    {
#line 450
    free(t->bt_cursor.key.data);
#line 451
    t->bt_cursor.key.size = (size_t )0;
#line 452
    t->bt_cursor.key.data = (void *)0;
    }
  }
#line 454
  t->bt_cursor.flags = (u_int8_t )((int )t->bt_cursor.flags & -8);
#line 457
  t->bt_cursor.pg.pgno = pgno;
#line 458
  t->bt_cursor.pg.index = (u_int16_t )index;
#line 459
  t->bt_cursor.flags = (u_int8_t )((int )t->bt_cursor.flags | 8);
#line 460
  return;
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 66 "./ndbm.h"
extern void dbm_close(DBM *db ) ;
#line 67
extern int dbm_delete(DBM *db , datum key ) ;
#line 68
extern datum dbm_fetch(DBM *db , datum key ) ;
#line 69
extern datum dbm_firstkey(DBM *db ) ;
#line 71
extern datum dbm_nextkey(DBM *db ) ;
#line 72
extern DBM *dbm_open(char const   *file , int flags , int mode ) ;
#line 73
extern int dbm_store(DBM *db , datum key , datum content , int flags ) ;
#line 74
extern int dbm_dirfno(DBM *db ) ;
#line 75
extern int dbm_error(DBM *db ) ;
#line 76
extern int dbm_clearerr(DBM *db ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern DBM *dbm_open(char const   *file , int flags , int mode ) 
{ 
  DBM *db ;
  HASHINFO info ;
  size_t len ;
  size_t tmp___1 ;
  char *path ;
  unsigned long __lengthofpath ;
  void *tmp___2 ;
  DB *tmp___3 ;

  {
  {
#line 67
  tmp___1 = strlen(file);
#line 67
  len = tmp___1 + sizeof(".db");
#line 69
  __lengthofpath = len;
#line 69
  tmp___2 = __builtin_alloca(sizeof(*path) * __lengthofpath);
#line 69
  path = (char *)tmp___2;
#line 76
  info.bsize = (u_int )4096;
#line 77
  info.ffactor = (u_int )40;
#line 78
  info.nelem = (u_int )1;
#line 79
  info.cachesize = (u_int )0;
#line 80
  info.hash = (u_int32_t (*)(void const   * , size_t  ))((void *)0);
#line 81
  info.lorder = 0;
#line 82
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)file);
#line 83
  strcat((char */* __restrict  */)path, (char const   */* __restrict  */)".db");
#line 84
  tmp___3 = __hash_open((char const   *)path, flags, mode, (HASHINFO const   *)(& info),
                        0);
#line 84
  db = tmp___3;
  }
#line 88
  return (db);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern void dbm_close(DBM *db ) 
{ 


  {
  {
#line 95
  (*(db->close))(db);
  }
#line 96
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern datum dbm_fetch(DBM *db , datum key ) 
{ 
  datum retval ;
  int status ;

  {
  {
#line 111
  status = (*(db->get))((struct __db  const  *)db, (DBT const   *)((DBT *)(& key)),
                        (DBT *)(& retval), (u_int )0);
  }
#line 112
  if (status) {
#line 113
    retval.dptr = (char *)((void *)0);
#line 114
    retval.dsize = 0;
  }
#line 116
  return (retval);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern datum dbm_firstkey(DBM *db ) 
{ 
  int status ;
  datum retdata ;
  datum retkey ;

  {
  {
#line 131
  status = (*(db->seq))((struct __db  const  *)db, (DBT *)(& retkey), (DBT *)(& retdata),
                        (u_int )3);
  }
#line 132
  if (status) {
#line 133
    retkey.dptr = (char *)((void *)0);
  }
#line 134
  return (retkey);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern datum dbm_nextkey(DBM *db ) 
{ 
  int status ;
  datum retdata ;
  datum retkey ;

  {
  {
#line 149
  status = (*(db->seq))((struct __db  const  *)db, (DBT *)(& retkey), (DBT *)(& retdata),
                        (u_int )7);
  }
#line 150
  if (status) {
#line 151
    retkey.dptr = (char *)((void *)0);
  }
#line 152
  return (retkey);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern int dbm_delete(DBM *db , datum key ) 
{ 
  int status ;

  {
  {
#line 166
  status = (*(db->del))((struct __db  const  *)db, (DBT const   *)((DBT *)(& key)),
                        (u_int )0);
  }
#line 167
  if (status) {
#line 168
    return (-1);
  } else {
#line 170
    return (0);
  }
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern int dbm_store(DBM *db , datum key , datum content , int flags ) 
{ 
  int tmp___1 ;
  int tmp___2 ;

  {
#line 185
  if (flags == 0) {
#line 185
    tmp___1 = 8;
  } else {
#line 185
    tmp___1 = 0;
  }
  {
#line 185
  tmp___2 = (*(db->put))((struct __db  const  *)db, (DBT *)(& key), (DBT const   *)((DBT *)(& content)),
                         (u_int )tmp___1);
  }
#line 185
  return (tmp___2);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern int dbm_error(DBM *db ) 
{ 
  HTAB *hp ;

  {
#line 195
  hp = (HTAB *)db->internal;
#line 196
  return (hp->errnum);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern int dbm_clearerr(DBM *db ) 
{ 
  HTAB *hp ;

  {
#line 205
  hp = (HTAB *)db->internal;
#line 206
  hp->errnum = 0;
#line 207
  return (0);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/ndbm.c"
extern int dbm_dirfno(DBM *db ) 
{ 


  {
#line 214
  return (((HTAB *)db->internal)->fp);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_utils.c"
int __bt_ret(BTREE *t , EPG *e , DBT *key , DBT *rkey , DBT *data , DBT *rdata , int copy ) 
{ 
  BLEAF *bl ;
  void *p ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 76
  bl = (BLEAF *)((char *)e->page + (int )(e->page)->linp[e->index]);
#line 83
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 84
    goto dataonly;
  }
#line 86
  if ((int )bl->flags & 2) {
    {
#line 87
    tmp___1 = __ovfl_get(t, (void *)(bl->bytes), & key->size, & rkey->data, & rkey->size);
    }
#line 87
    if (tmp___1) {
#line 89
      return (-1);
    }
#line 90
    key->data = rkey->data;
  } else
#line 91
  if (copy) {
#line 91
    goto _L;
  } else
#line 91
  if (t->flags & 16384U) {
    _L: /* CIL Label */ 
#line 92
    if ((size_t )bl->ksize > rkey->size) {
#line 93
      if ((unsigned long )rkey->data == (unsigned long )((void *)0)) {
        {
#line 93
        tmp___2 = malloc((size_t )bl->ksize);
#line 93
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 93
        tmp___3 = realloc(rkey->data, (size_t )bl->ksize);
#line 93
        tmp___4 = tmp___3;
        }
      }
#line 93
      p = tmp___4;
#line 95
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 96
        return (-1);
      }
#line 97
      rkey->data = p;
#line 98
      rkey->size = (size_t )bl->ksize;
    }
    {
#line 100
    memmove(rkey->data, (void const   *)(bl->bytes), (size_t )bl->ksize);
#line 101
    key->size = (size_t )bl->ksize;
#line 102
    key->data = rkey->data;
    }
  } else {
#line 104
    key->size = (size_t )bl->ksize;
#line 105
    key->data = (void *)(bl->bytes);
  }
  dataonly: 
#line 109
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 110
    return (0);
  }
#line 112
  if ((int )bl->flags & 1) {
    {
#line 113
    tmp___5 = __ovfl_get(t, (void *)(bl->bytes + bl->ksize), & data->size, & rdata->data,
                         & rdata->size);
    }
#line 113
    if (tmp___5) {
#line 115
      return (-1);
    }
#line 116
    data->data = rdata->data;
  } else
#line 117
  if (copy) {
#line 117
    goto _L___0;
  } else
#line 117
  if (t->flags & 16384U) {
    _L___0: /* CIL Label */ 
#line 119
    if ((size_t )(bl->dsize + 1U) > rdata->size) {
#line 120
      if ((unsigned long )rdata->data == (unsigned long )((void *)0)) {
        {
#line 120
        tmp___6 = malloc((size_t )(bl->dsize + 1U));
#line 120
        tmp___8 = tmp___6;
        }
      } else {
        {
#line 120
        tmp___7 = realloc(rdata->data, (size_t )(bl->dsize + 1U));
#line 120
        tmp___8 = tmp___7;
        }
      }
#line 120
      p = tmp___8;
#line 123
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 124
        return (-1);
      }
#line 125
      rdata->data = p;
#line 126
      rdata->size = (size_t )(bl->dsize + 1U);
    }
    {
#line 128
    memmove(rdata->data, (void const   *)(bl->bytes + bl->ksize), (size_t )bl->dsize);
#line 129
    data->size = (size_t )bl->dsize;
#line 130
    data->data = rdata->data;
    }
  } else {
#line 132
    data->size = (size_t )bl->dsize;
#line 133
    data->data = (void *)(bl->bytes + bl->ksize);
  }
#line 136
  return (0);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_utils.c"
int __bt_cmp(BTREE *t , DBT const   *k1 , EPG *e ) 
{ 
  BINTERNAL *bi ;
  BLEAF *bl ;
  DBT k2 ;
  PAGE *h ;
  void *bigkey ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 171
  h = e->page;
#line 172
  if ((int )e->index == 0) {
#line 172
    if (h->prevpg == 0U) {
#line 172
      if (! (h->flags & 2U)) {
#line 173
        return (1);
      }
    }
  }
#line 175
  bigkey = (void *)0;
#line 176
  if (h->flags & 2U) {
#line 177
    bl = (BLEAF *)((char *)h + (int )h->linp[e->index]);
#line 178
    if ((int )bl->flags & 2) {
#line 179
      bigkey = (void *)(bl->bytes);
    } else {
#line 181
      k2.data = (void *)(bl->bytes);
#line 182
      k2.size = (size_t )bl->ksize;
    }
  } else {
#line 185
    bi = (BINTERNAL *)((char *)h + (int )h->linp[e->index]);
#line 186
    if ((int )bi->flags & 2) {
#line 187
      bigkey = (void *)(bi->bytes);
    } else {
#line 189
      k2.data = (void *)(bi->bytes);
#line 190
      k2.size = (size_t )bi->ksize;
    }
  }
#line 194
  if (bigkey) {
    {
#line 195
    tmp___1 = __ovfl_get(t, bigkey, & k2.size, & t->bt_rdata.data, & t->bt_rdata.size);
    }
#line 195
    if (tmp___1) {
#line 197
      return (-1);
    }
#line 198
    k2.data = t->bt_rdata.data;
  }
  {
#line 200
  tmp___2 = (*(t->bt_cmp))(k1, (DBT const   *)(& k2));
  }
#line 200
  return (tmp___2);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_utils.c"
int __bt_defcmp(DBT const   *a , DBT const   *b ) 
{ 
  register size_t len ;
  register u_char *p1 ;
  register u_char *p2 ;
  size_t tmp___1 ;

  {
#line 228
  if (a->size < b->size) {
#line 228
    len = (size_t )a->size;
  } else {
#line 228
    len = (size_t )b->size;
  }
#line 229
  p1 = (u_char *)a->data;
#line 229
  p2 = (u_char *)b->data;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    tmp___1 = len;
#line 229
    len --;
#line 229
    if (! tmp___1) {
#line 229
      goto while_break;
    }
#line 230
    if ((int )*p1 != (int )*p2) {
#line 231
      return ((int )*p1 - (int )*p2);
    }
#line 229
    p1 ++;
#line 229
    p2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  return ((int )a->size - (int )b->size);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_utils.c"
size_t __bt_defpfx(DBT const   *a , DBT const   *b ) 
{ 
  register u_char *p1 ;
  register u_char *p2 ;
  register size_t cnt ;
  register size_t len ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 252
  cnt = (size_t )1;
#line 253
  if (a->size < b->size) {
#line 253
    len = (size_t )a->size;
  } else {
#line 253
    len = (size_t )b->size;
  }
#line 254
  p1 = (u_char *)a->data;
#line 254
  p2 = (u_char *)b->data;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    tmp___1 = len;
#line 254
    len --;
#line 254
    if (! tmp___1) {
#line 254
      goto while_break;
    }
#line 255
    if ((int )*p1 != (int )*p2) {
#line 256
      return (cnt);
    }
#line 254
    p1 ++;
#line 254
    p2 ++;
#line 254
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  if (a->size < b->size) {
#line 259
    tmp___2 = a->size + 1UL;
  } else {
#line 259
    tmp___2 = a->size;
  }
#line 259
  return ((size_t )tmp___2);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/extern.h"
int __ovfl_delete(BTREE *t , void *p ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_bdelete(BTREE *t , DBT const   *key ) ;
#line 51
static int __bt_curdel(BTREE *t , DBT const   *key , PAGE *h , u_int index___0 ) ;
#line 52
static int __bt_pdelete(BTREE *t , PAGE *h ) ;
#line 53
static int __bt_relink(BTREE *t , PAGE *h ) ;
#line 54
static int __bt_stkacq(BTREE *t , PAGE **hp , CURSOR *c ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
int __bt_delete(DB const   *dbp , DBT const   *key , u_int flags ) 
{ 
  BTREE *t ;
  CURSOR *c ;
  PAGE *h ;
  int status ;
  int *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
#line 73
  t = (BTREE *)dbp->internal;
#line 76
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 77
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 78
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
#line 82
  if (t->flags & 16U) {
    {
#line 83
    tmp___1 = __errno_location();
#line 83
    *tmp___1 = 1;
    }
#line 84
    return (-1);
  }
  {
#line 88
  if (flags == 0U) {
#line 88
    goto case_0;
  }
#line 91
  if (flags == 1U) {
#line 91
    goto case_1;
  }
#line 122
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 89
  status = __bt_bdelete(t, key);
  }
#line 90
  goto switch_break;
  case_1: /* CIL Label */ 
#line 96
  c = & t->bt_cursor;
#line 97
  if ((int )c->flags & 8) {
#line 98
    if ((int )c->flags & 7) {
#line 99
      return (1);
    }
    {
#line 100
    tmp___2 = __mpool_get(t->bt_mp, c->pg.pgno, (u_int )0);
#line 100
    h = (PAGE *)tmp___2;
    }
#line 100
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 101
      return (-1);
    }
#line 107
    if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 1UL) {
      {
#line 108
      tmp___3 = __bt_stkacq(t, & h, & t->bt_cursor);
      }
#line 108
      if (tmp___3) {
#line 109
        return (-1);
      }
    }
    {
#line 111
    status = __bt_dleaf(t, (DBT const   *)((void *)0), h, (u_int )c->pg.index);
    }
#line 113
    if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 0UL) {
#line 113
      if (status == 0) {
        {
#line 114
        tmp___4 = __bt_pdelete(t, h);
        }
#line 114
        if (tmp___4) {
#line 115
          return (-1);
        }
      } else {
#line 113
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 117
      if (status == 0) {
#line 117
        tmp___5 = 1;
      } else {
#line 117
        tmp___5 = 0;
      }
      {
#line 117
      __mpool_put(t->bt_mp, (void *)h, (u_int )tmp___5);
      }
    }
#line 119
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 123
  tmp___6 = __errno_location();
#line 123
  *tmp___6 = 22;
  }
#line 124
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 126
  if (status == 0) {
#line 127
    t->flags |= 4U;
  }
#line 128
  return (status);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_stkacq(BTREE *t , PAGE **hp , CURSOR *c ) 
{ 
  BINTERNAL *bi ;
  EPG *e ;
  EPGNO *parent ;
  PAGE *h ;
  u_int16_t index___0 ;
  u_int32_t pgno ;
  u_int32_t nextpg ;
  u_int32_t prevpg ;
  int exact ;
  int level ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  PAGE *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 162
  h = *hp;
#line 163
  __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 164
  e = __bt_search(t, (DBT const   *)(& c->key), & exact);
  }
#line 164
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 165
    return (1);
  }
#line 166
  h = e->page;
#line 169
  if (h->pgno == c->pg.pgno) {
#line 170
    goto ret;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (h->pgno != c->pg.pgno)) {
#line 178
      goto while_break;
    }
#line 179
    nextpg = h->nextpg;
#line 179
    if (nextpg == 0U) {
#line 180
      goto while_break;
    }
    {
#line 181
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 184
    level = 0;
    }
    {
#line 184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 184
      if ((unsigned long )t->bt_sp == (unsigned long )(t->bt_stack)) {
#line 184
        parent = (EPGNO *)((void *)0);
      } else {
#line 184
        (t->bt_sp) --;
#line 184
        parent = t->bt_sp;
      }
#line 184
      if (! ((unsigned long )parent != (unsigned long )((void *)0))) {
#line 184
        goto while_break___0;
      }
      {
#line 186
      tmp___1 = __mpool_get(t->bt_mp, parent->pgno, (u_int )0);
#line 186
      h = (PAGE *)tmp___1;
      }
#line 186
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 187
        return (1);
      }
#line 190
      if ((unsigned long )parent->index != ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL) {
#line 191
        index___0 = (u_int16_t )((int )parent->index + 1);
#line 192
        (t->bt_sp)->pgno = h->pgno;
#line 192
        (t->bt_sp)->index = index___0;
#line 192
        (t->bt_sp) ++;
#line 193
        goto while_break___0;
      }
      {
#line 195
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 184
      level ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 199
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 199
      tmp___3 = level;
#line 199
      level --;
#line 199
      if (! tmp___3) {
#line 199
        goto while_break___1;
      }
      {
#line 201
      bi = (BINTERNAL *)((char *)h + (int )h->linp[index___0]);
#line 202
      pgno = bi->pgno;
#line 203
      (t->bt_sp)->pgno = pgno;
#line 203
      (t->bt_sp)->index = (u_int16_t )0;
#line 203
      (t->bt_sp) ++;
#line 206
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 209
      tmp___2 = __mpool_get(t->bt_mp, pgno, (u_int )0);
#line 209
      h = (PAGE *)tmp___2;
      }
#line 209
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 210
        return (1);
      }
#line 211
      index___0 = (u_int16_t )0;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 213
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 214
    tmp___4 = __mpool_get(t->bt_mp, nextpg, (u_int )0);
#line 214
    h = (PAGE *)tmp___4;
    }
#line 214
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 215
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if (h->pgno == c->pg.pgno) {
#line 219
    goto ret;
  }
  {
#line 222
  __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 223
  e = __bt_search(t, (DBT const   *)(& c->key), & exact);
  }
#line 223
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 224
    return (1);
  }
#line 225
  h = e->page;
  {
#line 233
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 233
    if (! (h->pgno != c->pg.pgno)) {
#line 233
      goto while_break___2;
    }
#line 234
    prevpg = h->prevpg;
#line 234
    if (prevpg == 0U) {
#line 235
      goto while_break___2;
    }
    {
#line 236
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 239
    level = 0;
    }
    {
#line 239
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 239
      if ((unsigned long )t->bt_sp == (unsigned long )(t->bt_stack)) {
#line 239
        parent = (EPGNO *)((void *)0);
      } else {
#line 239
        (t->bt_sp) --;
#line 239
        parent = t->bt_sp;
      }
#line 239
      if (! ((unsigned long )parent != (unsigned long )((void *)0))) {
#line 239
        goto while_break___3;
      }
      {
#line 241
      tmp___5 = __mpool_get(t->bt_mp, parent->pgno, (u_int )0);
#line 241
      h = (PAGE *)tmp___5;
      }
#line 241
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 242
        return (1);
      }
#line 245
      if ((int )parent->index != 0) {
#line 246
        index___0 = (u_int16_t )((int )parent->index - 1);
#line 247
        (t->bt_sp)->pgno = h->pgno;
#line 247
        (t->bt_sp)->index = index___0;
#line 247
        (t->bt_sp) ++;
#line 248
        goto while_break___3;
      }
      {
#line 250
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 239
      level ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 254
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 254
      tmp___7 = level;
#line 254
      level --;
#line 254
      if (! tmp___7) {
#line 254
        goto while_break___4;
      }
      {
#line 256
      bi = (BINTERNAL *)((char *)h + (int )h->linp[index___0]);
#line 257
      pgno = bi->pgno;
#line 260
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 263
      tmp___6 = __mpool_get(t->bt_mp, pgno, (u_int )0);
#line 263
      h = (PAGE *)tmp___6;
      }
#line 263
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 264
        return (1);
      }
#line 266
      index___0 = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
#line 267
      (t->bt_sp)->pgno = pgno;
#line 267
      (t->bt_sp)->index = index___0;
#line 267
      (t->bt_sp) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 269
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 270
    tmp___8 = __mpool_get(t->bt_mp, prevpg, (u_int )0);
#line 270
    h = (PAGE *)tmp___8;
    }
#line 270
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 271
      return (1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  ret: 
  {
#line 275
  __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 276
  tmp___10 = __mpool_get(t->bt_mp, c->pg.pgno, (u_int )0);
#line 276
  tmp___9 = (PAGE *)tmp___10;
#line 276
  *hp = tmp___9;
  }
#line 276
  return ((unsigned long )tmp___9 == (unsigned long )((void *)0));
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_bdelete(BTREE *t , DBT const   *key ) 
{ 
  EPG *e ;
  PAGE *h ;
  int deleted ;
  int exact ;
  int redo ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  u_int16_t tmp___8 ;
  int tmp___9 ;

  {
#line 299
  deleted = 0;
  loop: 
  {
#line 302
  e = __bt_search(t, key, & exact);
  }
#line 302
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 303
    if (deleted) {
#line 303
      tmp___1 = 0;
    } else {
#line 303
      tmp___1 = -1;
    }
#line 303
    return (tmp___1);
  }
#line 304
  if (! exact) {
    {
#line 305
    __mpool_put(t->bt_mp, (void *)e->page, (u_int )0);
    }
#line 306
    if (deleted) {
#line 306
      tmp___2 = 0;
    } else {
#line 306
      tmp___2 = 1;
    }
#line 306
    return (tmp___2);
  }
#line 314
  redo = 0;
#line 315
  h = e->page;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 317
    tmp___3 = __bt_dleaf(t, key, h, (u_int )e->index);
    }
#line 317
    if (tmp___3) {
      {
#line 318
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
#line 319
      return (-1);
    }
#line 321
    if (t->flags & 32U) {
#line 322
      if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 0UL) {
        {
#line 323
        tmp___4 = __bt_pdelete(t, h);
        }
#line 323
        if (tmp___4) {
#line 324
          return (-1);
        }
      } else {
        {
#line 326
        __mpool_put(t->bt_mp, (void *)h, (u_int )1);
        }
      }
#line 327
      return (0);
    }
#line 329
    deleted = 1;
#line 316
    if ((unsigned long )e->index < ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
      {
#line 316
      tmp___5 = __bt_cmp(t, key, e);
      }
#line 316
      if (! (tmp___5 == 0)) {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  if ((unsigned long )e->index == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
#line 334
    redo = 1;
  }
  {
#line 337
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 337
    tmp___8 = e->index;
#line 337
    e->index = (u_int16_t )((int )e->index - 1);
#line 337
    if (! ((int )tmp___8 > 0)) {
#line 337
      goto while_break___0;
    }
    {
#line 338
    tmp___6 = __bt_cmp(t, key, e);
    }
#line 338
    if (tmp___6 != 0) {
#line 339
      goto while_break___0;
    }
    {
#line 340
    tmp___7 = __bt_dleaf(t, key, h, (u_int )e->index);
    }
#line 340
    if (tmp___7 == -1) {
      {
#line 341
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
#line 342
      return (-1);
    }
#line 344
    if ((int )e->index == 0) {
#line 345
      redo = 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 349
  if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 0UL) {
    {
#line 350
    tmp___9 = __bt_pdelete(t, h);
    }
#line 350
    if (tmp___9) {
#line 351
      return (-1);
    }
#line 352
    goto loop;
  }
  {
#line 356
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 358
  if (redo) {
#line 359
    goto loop;
  }
#line 360
  return (0);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_pdelete(BTREE *t , PAGE *h ) 
{ 
  BINTERNAL *bi ;
  PAGE *pg ;
  EPGNO *parent ;
  u_int16_t cnt ;
  u_int16_t index___0 ;
  u_int16_t *ip ;
  u_int16_t offset ;
  u_int32_t nksize ;
  char *from ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u_int16_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if ((unsigned long )t->bt_sp == (unsigned long )(t->bt_stack)) {
#line 401
      parent = (EPGNO *)((void *)0);
    } else {
#line 401
      (t->bt_sp) --;
#line 401
      parent = t->bt_sp;
    }
#line 401
    if (! ((unsigned long )parent != (unsigned long )((void *)0))) {
#line 401
      goto while_break;
    }
    {
#line 403
    tmp___1 = __mpool_get(t->bt_mp, parent->pgno, (u_int )0);
#line 403
    pg = (PAGE *)tmp___1;
    }
#line 403
    if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 404
      return (-1);
    }
#line 406
    index___0 = parent->index;
#line 407
    bi = (BINTERNAL *)((char *)pg + (int )pg->linp[index___0]);
#line 410
    if ((int )bi->flags & 2) {
      {
#line 410
      tmp___2 = __ovfl_delete(t, (void *)(bi->bytes));
      }
#line 410
      if (tmp___2 == -1) {
        {
#line 412
        __mpool_put(t->bt_mp, (void *)pg, (u_int )0);
        }
#line 413
        return (-1);
      }
    }
#line 421
    if (((unsigned long )pg->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 1UL) {
#line 422
      if (pg->pgno == 1U) {
#line 423
        pg->lower = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 424
        pg->upper = (u_int16_t )t->bt_psize;
#line 425
        pg->flags = (u_int32_t )2;
      } else {
        {
#line 427
        tmp___3 = __bt_relink(t, pg);
        }
#line 427
        if (tmp___3) {
#line 428
          return (-1);
        } else {
          {
#line 427
          tmp___4 = __bt_free(t, pg);
          }
#line 427
          if (tmp___4) {
#line 428
            return (-1);
          }
        }
#line 429
        goto while_continue;
      }
    } else {
      {
#line 433
      nksize = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bi->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 434
      from = (char *)pg + (int )pg->upper;
#line 435
      memmove((void *)(from + nksize), (void const   *)from, (size_t )((char *)bi - from));
#line 436
      pg->upper = (u_int16_t )((u_int32_t )pg->upper + nksize);
#line 439
      offset = pg->linp[index___0];
#line 440
      cnt = index___0;
#line 440
      ip = & pg->linp[0];
      }
      {
#line 440
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 440
        tmp___5 = cnt;
#line 440
        cnt = (u_int16_t )((int )cnt - 1);
#line 440
        if (! tmp___5) {
#line 440
          goto while_break___0;
        }
#line 441
        if ((int )*(ip + 0) < (int )offset) {
#line 442
          *(ip + 0) = (u_int16_t )((u_int32_t )*(ip + 0) + nksize);
        }
#line 440
        ip ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 443
      cnt = (u_int16_t )(((unsigned long )pg->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - (unsigned long )index___0);
      {
#line 443
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 443
        cnt = (u_int16_t )((int )cnt - 1);
#line 443
        if (! cnt) {
#line 443
          goto while_break___1;
        }
#line 444
        if ((int )*(ip + 1) < (int )offset) {
#line 444
          *(ip + 0) = (u_int16_t )((u_int32_t )*(ip + 1) + nksize);
        } else {
#line 444
          *(ip + 0) = *(ip + 1);
        }
#line 443
        ip ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 445
      pg->lower = (u_int16_t )((unsigned long )pg->lower - sizeof(u_int16_t ));
    }
    {
#line 448
    __mpool_put(t->bt_mp, (void *)pg, (u_int )1);
    }
#line 449
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  if (h->pgno == 1U) {
    {
#line 454
    __mpool_put(t->bt_mp, (void *)h, (u_int )1);
    }
#line 455
    return (0);
  }
  {
#line 457
  tmp___6 = __bt_relink(t, h);
  }
#line 457
  if (tmp___6) {
#line 457
    tmp___8 = 1;
  } else {
    {
#line 457
    tmp___7 = __bt_free(t, h);
    }
#line 457
    if (tmp___7) {
#line 457
      tmp___8 = 1;
    } else {
#line 457
      tmp___8 = 0;
    }
  }
#line 457
  return (tmp___8);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
int __bt_dleaf(BTREE *t , DBT const   *key , PAGE *h , u_int index___0 ) 
{ 
  BLEAF *bl ;
  u_int16_t cnt ;
  u_int16_t *ip ;
  u_int16_t offset ;
  u_int32_t nbytes ;
  void *to ;
  char *from ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int16_t tmp___4 ;

  {
#line 487
  if ((int )t->bt_cursor.flags & 8) {
#line 487
    if (! ((int )t->bt_cursor.flags & 1)) {
#line 487
      if (t->bt_cursor.pg.pgno == h->pgno) {
#line 487
        if ((u_int )t->bt_cursor.pg.index == index___0) {
          {
#line 487
          tmp___1 = __bt_curdel(t, key, h, index___0);
          }
#line 487
          if (tmp___1) {
#line 491
            return (-1);
          }
        }
      }
    }
  }
#line 494
  bl = (BLEAF *)((char *)h + (int )h->linp[index___0]);
#line 494
  to = (void *)bl;
#line 495
  if ((int )bl->flags & 2) {
    {
#line 495
    tmp___2 = __ovfl_delete(t, (void *)(bl->bytes));
    }
#line 495
    if (tmp___2 == -1) {
#line 496
      return (-1);
    }
  }
#line 497
  if ((int )bl->flags & 1) {
    {
#line 497
    tmp___3 = __ovfl_delete(t, (void *)(bl->bytes + bl->ksize));
    }
#line 497
    if (tmp___3 == -1) {
#line 499
      return (-1);
    }
  }
  {
#line 502
  nbytes = (u_int32_t )(((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bl->ksize) + (unsigned long )bl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 503
  from = (char *)h + (int )h->upper;
#line 504
  memmove((void *)(from + nbytes), (void const   *)from, (size_t )((char *)to - from));
#line 505
  h->upper = (u_int16_t )((u_int32_t )h->upper + nbytes);
#line 508
  offset = h->linp[index___0];
#line 509
  cnt = (u_int16_t )index___0;
#line 509
  ip = & h->linp[0];
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    tmp___4 = cnt;
#line 509
    cnt = (u_int16_t )((int )cnt - 1);
#line 509
    if (! tmp___4) {
#line 509
      goto while_break;
    }
#line 510
    if ((int )*(ip + 0) < (int )offset) {
#line 511
      *(ip + 0) = (u_int16_t )((u_int32_t )*(ip + 0) + nbytes);
    }
#line 509
    ip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  cnt = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - (unsigned long )index___0);
  {
#line 512
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 512
    cnt = (u_int16_t )((int )cnt - 1);
#line 512
    if (! cnt) {
#line 512
      goto while_break___0;
    }
#line 513
    if ((int )*(ip + 1) < (int )offset) {
#line 513
      *(ip + 0) = (u_int16_t )((u_int32_t )*(ip + 1) + nbytes);
    } else {
#line 513
      *(ip + 0) = *(ip + 1);
    }
#line 512
    ip ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 514
  h->lower = (u_int16_t )((unsigned long )h->lower - sizeof(u_int16_t ));
#line 517
  if ((int )t->bt_cursor.flags & 8) {
#line 517
    if (! ((int )t->bt_cursor.flags & 1)) {
#line 517
      if (t->bt_cursor.pg.pgno == h->pgno) {
#line 517
        if ((u_int )t->bt_cursor.pg.index > index___0) {
#line 520
          t->bt_cursor.pg.index = (u_int16_t )((int )t->bt_cursor.pg.index - 1);
        }
      }
    }
  }
#line 522
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_curdel(BTREE *t , DBT const   *key , PAGE *h , u_int index___0 ) 
{ 
  CURSOR *c ;
  EPG e ;
  PAGE *pg ;
  int curcopy ;
  int status ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
#line 554
  c = & t->bt_cursor;
#line 555
  c->flags = (u_int8_t )((int )c->flags & -8);
#line 557
  curcopy = 0;
#line 558
  if (! (t->flags & 32U)) {
#line 564
    if ((unsigned long )key == (unsigned long )((void *)0)) {
      {
#line 565
      e.page = h;
#line 566
      e.index = (u_int16_t )index___0;
#line 567
      status = __bt_ret(t, & e, & c->key, & c->key, (DBT *)((void *)0), (DBT *)((void *)0),
                        1);
      }
#line 567
      if (status != 0) {
#line 569
        return (status);
      }
#line 570
      curcopy = 1;
#line 571
      key = (DBT const   *)(& c->key);
    }
#line 574
    if (index___0 > 0U) {
      {
#line 575
      e.page = h;
#line 576
      e.index = (u_int16_t )(index___0 - 1U);
#line 577
      tmp___1 = __bt_cmp(t, key, & e);
      }
#line 577
      if (tmp___1 == 0) {
#line 578
        c->flags = (u_int8_t )((int )c->flags | 4);
#line 579
        goto dup2;
      }
    }
#line 583
    if ((unsigned long )index___0 < ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL) {
      {
#line 584
      e.page = h;
#line 585
      e.index = (u_int16_t )(index___0 + 1U);
#line 586
      tmp___2 = __bt_cmp(t, key, & e);
      }
#line 586
      if (tmp___2 == 0) {
#line 587
        c->flags = (u_int8_t )((int )c->flags | 2);
#line 588
        goto dup2;
      }
    }
#line 592
    if (index___0 == 0U) {
#line 592
      if (h->prevpg != 0U) {
        {
#line 593
        tmp___3 = __mpool_get(t->bt_mp, h->prevpg, (u_int )0);
#line 593
        pg = (PAGE *)tmp___3;
        }
#line 593
        if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 594
          return (-1);
        }
        {
#line 595
        e.page = pg;
#line 596
        e.index = (u_int16_t )(((unsigned long )pg->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
#line 597
        tmp___4 = __bt_cmp(t, key, & e);
        }
#line 597
        if (tmp___4 == 0) {
#line 598
          c->flags = (u_int8_t )((int )c->flags | 4);
#line 599
          goto dup1;
        }
        {
#line 601
        __mpool_put(t->bt_mp, (void *)pg, (u_int )0);
        }
      }
    }
#line 604
    if ((unsigned long )index___0 == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL) {
#line 604
      if (h->nextpg != 0U) {
        {
#line 605
        tmp___5 = __mpool_get(t->bt_mp, h->nextpg, (u_int )0);
#line 605
        pg = (PAGE *)tmp___5;
        }
#line 605
        if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 606
          return (-1);
        }
        {
#line 607
        e.page = pg;
#line 608
        e.index = (u_int16_t )0;
#line 609
        tmp___6 = __bt_cmp(t, key, & e);
        }
#line 609
        if (tmp___6 == 0) {
#line 610
          c->flags = (u_int8_t )((int )c->flags | 2);
          dup1: 
          {
#line 611
          __mpool_put(t->bt_mp, (void *)pg, (u_int )0);
          }
          dup2: 
#line 612
          c->pg.pgno = (e.page)->pgno;
#line 613
          c->pg.index = e.index;
#line 614
          return (0);
        }
        {
#line 616
        __mpool_put(t->bt_mp, (void *)pg, (u_int )0);
        }
      }
    }
  }
#line 619
  e.page = h;
#line 620
  e.index = (u_int16_t )index___0;
#line 621
  if (curcopy) {
#line 623
    c->flags = (u_int8_t )((int )c->flags | 1);
#line 624
    return (0);
  } else {
    {
#line 621
    status = __bt_ret(t, & e, & c->key, & c->key, (DBT *)((void *)0), (DBT *)((void *)0),
                      1);
    }
#line 621
    if (status == 0) {
#line 623
      c->flags = (u_int8_t )((int )c->flags | 1);
#line 624
      return (0);
    }
  }
#line 626
  return (status);
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_relink(BTREE *t , PAGE *h ) 
{ 
  PAGE *pg ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 644
  if (h->nextpg != 0U) {
    {
#line 645
    tmp___1 = __mpool_get(t->bt_mp, h->nextpg, (u_int )0);
#line 645
    pg = (PAGE *)tmp___1;
    }
#line 645
    if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 646
      return (-1);
    }
    {
#line 647
    pg->prevpg = h->prevpg;
#line 648
    __mpool_put(t->bt_mp, (void *)pg, (u_int )1);
    }
  }
#line 650
  if (h->prevpg != 0U) {
    {
#line 651
    tmp___2 = __mpool_get(t->bt_mp, h->prevpg, (u_int )0);
#line 651
    pg = (PAGE *)tmp___2;
    }
#line 651
    if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 652
      return (-1);
    }
    {
#line 653
    pg->nextpg = h->nextpg;
#line 654
    __mpool_put(t->bt_mp, (void *)pg, (u_int )1);
    }
  }
#line 656
  return (0);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_overflow.c"
int __ovfl_get(BTREE *t , void *p , size_t *ssz , void **buf , size_t *bufsz ) 
{ 
  PAGE *h ;
  u_int32_t pg ;
  size_t nb ;
  size_t plen ;
  u_int32_t sz ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 92
  memmove((void *)(& pg), (void const   *)p, sizeof(u_int32_t ));
#line 93
  memmove((void *)(& sz), (void const   *)((char *)p + sizeof(u_int32_t )), sizeof(u_int32_t ));
#line 94
  *ssz = (size_t )sz;
  }
#line 101
  if (*bufsz < (size_t )sz) {
#line 102
    if ((unsigned long )*buf == (unsigned long )((void *)0)) {
      {
#line 102
      tmp___1 = malloc((size_t )sz);
#line 102
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 102
      tmp___2 = realloc(*buf, (size_t )sz);
#line 102
      tmp___3 = tmp___2;
      }
    }
#line 102
    *buf = (void *)((char *)tmp___3);
#line 103
    if ((unsigned long )*buf == (unsigned long )((void *)0)) {
#line 104
      return (-1);
    }
#line 105
    *bufsz = (size_t )sz;
  }
#line 112
  plen = (unsigned long )t->bt_psize - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 113
  p = *buf;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 114
    tmp___4 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 114
    h = (PAGE *)tmp___4;
    }
#line 114
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 115
      return (-1);
    }
#line 117
    if ((size_t )sz < plen) {
#line 117
      nb = (size_t )sz;
    } else {
#line 117
      nb = plen;
    }
    {
#line 118
    memmove(p, (void const   *)((char *)h + (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))),
            nb);
#line 119
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 121
    sz = (u_int32_t )((size_t )sz - nb);
    }
#line 121
    if (sz == 0U) {
#line 122
      goto while_break;
    }
#line 113
    p = (void *)((char *)p + nb);
#line 113
    pg = h->nextpg;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (0);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_overflow.c"
int __ovfl_put(BTREE *t , DBT const   *dbt , u_int32_t *pg ) 
{ 
  PAGE *h ;
  PAGE *last ;
  void *p ;
  u_int32_t npg ;
  size_t nb ;
  size_t plen ;
  u_int32_t sz ;
  u_int32_t tmp___1 ;
  u_int16_t tmp___2 ;

  {
#line 154
  plen = (unsigned long )t->bt_psize - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 155
  last = (PAGE *)((void *)0);
#line 155
  p = (void *)dbt->data;
#line 155
  sz = (u_int32_t )dbt->size;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    h = __bt_new(t, & npg);
    }
#line 157
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 158
      return (-1);
    }
#line 160
    h->pgno = npg;
#line 161
    tmp___1 = (u_int32_t )0;
#line 161
    h->prevpg = tmp___1;
#line 161
    h->nextpg = tmp___1;
#line 162
    h->flags = (u_int32_t )4;
#line 163
    tmp___2 = (u_int16_t )0;
#line 163
    h->upper = tmp___2;
#line 163
    h->lower = tmp___2;
#line 165
    if ((size_t )sz < plen) {
#line 165
      nb = (size_t )sz;
    } else {
#line 165
      nb = plen;
    }
    {
#line 166
    memmove((void *)((char *)h + (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))),
            (void const   *)p, nb);
    }
#line 168
    if (last) {
      {
#line 169
      last->nextpg = h->pgno;
#line 170
      __mpool_put(t->bt_mp, (void *)last, (u_int )1);
      }
    } else {
#line 172
      *pg = h->pgno;
    }
#line 174
    sz = (u_int32_t )((size_t )sz - nb);
#line 174
    if (sz == 0U) {
      {
#line 175
      __mpool_put(t->bt_mp, (void *)h, (u_int )1);
      }
#line 176
      goto while_break;
    }
#line 155
    p = (void *)((char *)p + plen);
#line 155
    last = h;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return (0);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_overflow.c"
int __ovfl_delete(BTREE *t , void *p ) 
{ 
  PAGE *h ;
  u_int32_t pg ;
  size_t plen ;
  u_int32_t sz ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 202
  memmove((void *)(& pg), (void const   *)p, sizeof(u_int32_t ));
#line 203
  memmove((void *)(& sz), (void const   *)((char *)p + sizeof(u_int32_t )), sizeof(u_int32_t ));
#line 209
  tmp___1 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 209
  h = (PAGE *)tmp___1;
  }
#line 209
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 210
    return (-1);
  }
#line 213
  if (h->flags & 32U) {
    {
#line 214
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 215
    return (0);
  }
#line 219
  plen = (unsigned long )t->bt_psize - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 220
    pg = h->nextpg;
#line 221
    __bt_free(t, h);
    }
#line 222
    if ((size_t )sz <= plen) {
#line 223
      goto while_break;
    }
    {
#line 224
    tmp___2 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 224
    h = (PAGE *)tmp___2;
    }
#line 224
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 225
      return (-1);
    }
#line 219
    sz = (u_int32_t )((size_t )sz - plen);
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (0);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
static int collect_key(HTAB *hashp , BUFHEAD *bufp , int len , DBT *val , int set ) ;
#line 76
static int collect_data(HTAB *hashp , BUFHEAD *bufp , int len , int set ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
extern int __big_insert(HTAB *hashp , BUFHEAD *bufp , DBT const   *key , DBT const   *val ) 
{ 
  register u_int16_t *p ;
  int key_size ;
  int n ;
  int val_size ;
  u_int16_t space ;
  u_int16_t move_bytes ;
  u_int16_t off ;
  char *cp ;
  char *key_data ;
  char *val_data ;

  {
#line 98
  cp = bufp->page;
#line 99
  p = (u_int16_t *)cp;
#line 101
  key_data = (char *)key->data;
#line 102
  key_size = (int )key->size;
#line 103
  val_data = (char *)val->data;
#line 104
  val_size = (int )val->size;
#line 107
  space = (u_int16_t )((unsigned long )*(p + ((int )*(p + 0) + 1)) - 4UL * sizeof(u_int16_t ));
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! key_size) {
#line 107
      goto while_break;
    }
#line 109
    if ((int )space < key_size) {
#line 109
      move_bytes = space;
    } else {
#line 109
      move_bytes = (u_int16_t )key_size;
    }
    {
#line 110
    off = (u_int16_t )((int )*(p + ((int )*(p + 0) + 2)) - (int )move_bytes);
#line 111
    memmove((void *)(cp + (int )off), (void const   *)key_data, (size_t )move_bytes);
#line 112
    key_size -= (int )move_bytes;
#line 113
    key_data += (int )move_bytes;
#line 114
    n = (int )*(p + 0);
#line 115
    n ++;
#line 115
    *(p + n) = off;
#line 116
    n ++;
#line 116
    *(p + 0) = (u_int16_t )n;
#line 117
    *(p + ((int )*(p + 0) + 1)) = (u_int16_t )((unsigned long )off - (unsigned long )(n + 3) * sizeof(u_int16_t ));
#line 118
    *(p + ((int )*(p + 0) + 2)) = off;
#line 119
    *(p + n) = (u_int16_t )1;
#line 120
    bufp = __add_ovflpage(hashp, bufp);
    }
#line 121
    if (! bufp) {
#line 122
      return (-1);
    }
#line 123
    n = (int )*(p + 0);
#line 124
    if (! key_size) {
#line 125
      if (*(p + ((int )*(p + 0) + 1))) {
#line 126
        if ((int )*(p + ((int )*(p + 0) + 1)) < val_size) {
#line 126
          move_bytes = *(p + ((int )*(p + 0) + 1));
        } else {
#line 126
          move_bytes = (u_int16_t )val_size;
        }
        {
#line 127
        off = (u_int16_t )((int )*(p + ((int )*(p + 0) + 2)) - (int )move_bytes);
#line 128
        *(p + n) = off;
#line 129
        memmove((void *)(cp + (int )off), (void const   *)val_data, (size_t )move_bytes);
#line 130
        val_data += (int )move_bytes;
#line 131
        val_size -= (int )move_bytes;
#line 132
        *(p + (n - 2)) = (u_int16_t )3;
#line 133
        *(p + ((int )*(p + 0) + 1)) = (u_int16_t )((int )*(p + ((int )*(p + 0) + 1)) - (int )move_bytes);
#line 134
        *(p + ((int )*(p + 0) + 2)) = off;
        }
      } else {
#line 136
        *(p + (n - 2)) = (u_int16_t )2;
      }
    }
#line 138
    p = (u_int16_t *)bufp->page;
#line 139
    cp = bufp->page;
#line 140
    bufp->flags = (char )((int )bufp->flags | 1);
#line 107
    space = (u_int16_t )((unsigned long )*(p + ((int )*(p + 0) + 1)) - 4UL * sizeof(u_int16_t ));
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  space = (u_int16_t )((unsigned long )*(p + ((int )*(p + 0) + 1)) - 4UL * sizeof(u_int16_t ));
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (! val_size) {
#line 144
      goto while_break___0;
    }
#line 146
    if ((int )space < val_size) {
#line 146
      move_bytes = space;
    } else {
#line 146
      move_bytes = (u_int16_t )val_size;
    }
#line 151
    if ((int )space == val_size) {
#line 151
      if ((size_t )val_size == (size_t )val->size) {
#line 152
        move_bytes = (u_int16_t )((int )move_bytes - 1);
      }
    }
    {
#line 153
    off = (u_int16_t )((int )*(p + ((int )*(p + 0) + 2)) - (int )move_bytes);
#line 154
    memmove((void *)(cp + (int )off), (void const   *)val_data, (size_t )move_bytes);
#line 155
    val_size -= (int )move_bytes;
#line 156
    val_data += (int )move_bytes;
#line 157
    n = (int )*(p + 0);
#line 158
    n ++;
#line 158
    *(p + n) = off;
#line 159
    n ++;
#line 159
    *(p + 0) = (u_int16_t )n;
#line 160
    *(p + ((int )*(p + 0) + 1)) = (u_int16_t )((unsigned long )off - (unsigned long )(n + 3) * sizeof(u_int16_t ));
#line 161
    *(p + ((int )*(p + 0) + 2)) = off;
    }
#line 162
    if (val_size) {
      {
#line 163
      *(p + n) = (u_int16_t )2;
#line 164
      bufp = __add_ovflpage(hashp, bufp);
      }
#line 165
      if (! bufp) {
#line 166
        return (-1);
      }
#line 167
      cp = bufp->page;
#line 168
      p = (u_int16_t *)cp;
    } else {
#line 170
      *(p + n) = (u_int16_t )3;
    }
#line 171
    bufp->flags = (char )((int )bufp->flags | 1);
#line 144
    space = (u_int16_t )((unsigned long )*(p + ((int )*(p + 0) + 1)) - 4UL * sizeof(u_int16_t ));
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  return (0);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
extern int __big_delete(HTAB *hashp , BUFHEAD *bufp ) 
{ 
  register BUFHEAD *last_bfp ;
  register BUFHEAD *rbufp ;
  u_int16_t *bp ;
  u_int16_t pageno ;
  int key_done ;
  int n ;

  {
#line 196
  rbufp = bufp;
#line 197
  last_bfp = (BUFHEAD *)((void *)0);
#line 198
  bp = (u_int16_t *)bufp->page;
#line 199
  pageno = (u_int16_t )0;
#line 200
  key_done = 0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (! key_done)) {
#line 202
      if (! ((int )*(bp + 2) != 3)) {
#line 202
        goto while_break;
      }
    }
#line 203
    if ((int )*(bp + 2) == 2) {
#line 204
      key_done = 1;
    } else
#line 203
    if ((int )*(bp + 2) == 3) {
#line 204
      key_done = 1;
    }
#line 211
    if ((int )*(bp + 2) == 3) {
#line 211
      if (*(bp + ((int )*(bp + 0) + 1))) {
#line 212
        goto while_break;
      }
    }
    {
#line 213
    pageno = *(bp + ((int )*(bp + 0) - 1));
#line 214
    rbufp->flags = (char )((int )rbufp->flags | 1);
#line 215
    rbufp = __get_buf(hashp, (u_int32_t )pageno, rbufp, 0);
    }
#line 216
    if (last_bfp) {
      {
#line 217
      __free_ovflpage(hashp, last_bfp);
      }
    }
#line 218
    last_bfp = rbufp;
#line 219
    if (! rbufp) {
#line 220
      return (-1);
    }
#line 221
    bp = (u_int16_t *)rbufp->page;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  n = (int )*(bp + 0);
#line 233
  pageno = *(bp + (n - 1));
#line 236
  bp = (u_int16_t *)bufp->page;
#line 237
  if (n > 2) {
#line 239
    *(bp + 1) = pageno;
#line 240
    *(bp + 2) = (u_int16_t )0;
#line 241
    bufp->ovfl = rbufp->ovfl;
  } else {
#line 244
    bufp->ovfl = (BUFHEAD *)((void *)0);
  }
#line 245
  n -= 2;
#line 246
  *(bp + 0) = (u_int16_t )n;
#line 247
  *(bp + ((int )*(bp + 0) + 1)) = (u_int16_t )((unsigned long )hashp->hdr.bsize - (unsigned long )(n + 3) * sizeof(u_int16_t ));
#line 248
  *(bp + ((int )*(bp + 0) + 2)) = (u_int16_t )(hashp->hdr.bsize - 1);
#line 250
  bufp->flags = (char )((int )bufp->flags | 1);
#line 251
  if (rbufp) {
    {
#line 252
    __free_ovflpage(hashp, rbufp);
    }
  }
#line 253
  if (last_bfp) {
#line 253
    if ((unsigned long )last_bfp != (unsigned long )rbufp) {
      {
#line 254
      __free_ovflpage(hashp, last_bfp);
      }
    }
  }
#line 256
  (hashp->hdr.nkeys) --;
#line 257
  return (0);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
extern int __find_bigpair(HTAB *hashp , BUFHEAD *bufp , int ndx , char *key , int size ) 
{ 
  register u_int16_t *bp ;
  register char *p ;
  int ksize ;
  u_int16_t bytes ;
  char *kkey ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 280
  bp = (u_int16_t *)bufp->page;
#line 281
  p = bufp->page;
#line 282
  ksize = size;
#line 283
  kkey = key;
#line 285
  bytes = (u_int16_t )(hashp->hdr.bsize - (int )*(bp + ndx));
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if ((int )bytes <= size) {
#line 285
      if (! ((int )*(bp + (ndx + 1)) == 1)) {
#line 285
        goto while_break;
      }
    } else {
#line 285
      goto while_break;
    }
    {
#line 288
    tmp___1 = memcmp((void const   *)(p + (int )*(bp + ndx)), (void const   *)kkey,
                     (size_t )bytes);
    }
#line 288
    if (tmp___1) {
#line 289
      return (-2);
    }
    {
#line 290
    kkey += (int )bytes;
#line 291
    ksize -= (int )bytes;
#line 292
    bufp = __get_buf(hashp, (u_int32_t )*(bp + (ndx + 2)), bufp, 0);
    }
#line 293
    if (! bufp) {
#line 294
      return (-3);
    }
#line 295
    p = bufp->page;
#line 296
    bp = (u_int16_t *)p;
#line 297
    ndx = 1;
#line 285
    bytes = (u_int16_t )(hashp->hdr.bsize - (int )*(bp + ndx));
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  if ((int )bytes != ksize) {
#line 304
    return (-2);
  } else {
    {
#line 300
    tmp___2 = memcmp((void const   *)(p + (int )*(bp + ndx)), (void const   *)kkey,
                     (size_t )bytes);
    }
#line 300
    if (tmp___2) {
#line 304
      return (-2);
    } else {
#line 306
      return (ndx);
    }
  }
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
extern u_int16_t __find_last_page(HTAB *hashp , BUFHEAD **bpp ) 
{ 
  BUFHEAD *bufp ;
  u_int16_t *bp ;
  u_int16_t pageno ;
  int n ;

  {
#line 327
  bufp = *bpp;
#line 328
  bp = (u_int16_t *)bufp->page;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    n = (int )*(bp + 0);
#line 337
    if ((int )*(bp + 2) == 3) {
#line 337
      if (n == 2) {
#line 339
        goto while_break;
      } else
#line 337
      if ((int )*(bp + n) == 0) {
#line 339
        goto while_break;
      } else
#line 337
      if (*(bp + ((int )*(bp + 0) + 1))) {
#line 339
        goto while_break;
      }
    }
    {
#line 341
    pageno = *(bp + (n - 1));
#line 342
    bufp = __get_buf(hashp, (u_int32_t )pageno, bufp, 0);
    }
#line 343
    if (! bufp) {
#line 344
      return ((u_int16_t )0);
    }
#line 345
    bp = (u_int16_t *)bufp->page;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  *bpp = bufp;
#line 349
  if ((int )*(bp + 0) > 2) {
#line 350
    return (*(bp + 3));
  } else {
#line 352
    return ((u_int16_t )0);
  }
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
extern int __big_return(HTAB *hashp , BUFHEAD *bufp , int ndx , DBT *val , int set_current ) 
{ 
  BUFHEAD *save_p ;
  u_int16_t *bp ;
  u_int16_t len ;
  u_int16_t off ;
  u_int16_t save_addr ;
  char *tp ;
  int tmp___1 ;
  int *tmp___2 ;

  {
#line 371
  bp = (u_int16_t *)bufp->page;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! ((int )*(bp + (ndx + 1)) == 1)) {
#line 372
      goto while_break;
    }
    {
#line 373
    bufp = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)), bufp, 0);
    }
#line 374
    if (! bufp) {
#line 375
      return (-1);
    }
#line 376
    bp = (u_int16_t *)bufp->page;
#line 377
    ndx = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  if ((int )*(bp + (ndx + 1)) == 2) {
    {
#line 381
    bufp = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)), bufp, 0);
    }
#line 382
    if (! bufp) {
#line 383
      return (-1);
    }
#line 384
    bp = (u_int16_t *)bufp->page;
#line 385
    save_p = bufp;
#line 386
    save_addr = (u_int16_t )save_p->addr;
#line 387
    off = *(bp + 1);
#line 388
    len = (u_int16_t )0;
  } else
#line 390
  if (! *(bp + ((int )*(bp + 0) + 1))) {
    {
#line 398
    off = *(bp + *(bp + 0));
#line 399
    len = (u_int16_t )((int )*(bp + 1) - (int )off);
#line 400
    save_p = bufp;
#line 401
    save_addr = (u_int16_t )bufp->addr;
#line 402
    bufp = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)), bufp, 0);
    }
#line 403
    if (! bufp) {
#line 404
      return (-1);
    }
#line 405
    bp = (u_int16_t *)bufp->page;
  } else {
#line 408
    tp = (char *)bp;
#line 409
    off = *(bp + *(bp + 0));
#line 410
    val->data = (void *)((u_char *)tp + (int )off);
#line 411
    val->size = (size_t )((int )*(bp + 1) - (int )off);
#line 412
    if (set_current) {
#line 413
      if ((int )*(bp + 0) == 2) {
#line 415
        hashp->cpage = (BUFHEAD *)((void *)0);
#line 416
        (hashp->cbucket) ++;
#line 417
        hashp->cndx = 1;
      } else {
        {
#line 419
        hashp->cpage = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)),
                                 bufp, 0);
        }
#line 421
        if (! hashp->cpage) {
#line 422
          return (-1);
        }
#line 423
        hashp->cndx = 1;
#line 424
        if (! *((u_int16_t *)(hashp->cpage)->page + 0)) {
#line 426
          (hashp->cbucket) ++;
#line 427
          hashp->cpage = (BUFHEAD *)((void *)0);
        }
      }
    }
#line 431
    return (0);
  }
  {
#line 434
  tmp___1 = collect_data(hashp, bufp, (int )len, set_current);
#line 434
  val->size = (size_t )tmp___1;
  }
#line 435
  if (val->size == 0xffffffffffffffffUL) {
#line 436
    return (-1);
  }
#line 437
  if (save_p->addr != (u_int32_t )save_addr) {
    {
#line 439
    tmp___2 = __errno_location();
#line 439
    *tmp___2 = 22;
    }
#line 440
    return (-1);
  }
  {
#line 442
  memmove((void *)hashp->tmp_buf, (void const   *)(save_p->page + (int )off), (size_t )len);
#line 443
  val->data = (void *)((u_char *)hashp->tmp_buf);
  }
#line 444
  return (0);
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
static int collect_data(HTAB *hashp , BUFHEAD *bufp , int len , int set ) 
{ 
  register u_int16_t *bp ;
  register char *p ;
  BUFHEAD *xbp ;
  u_int16_t save_addr ;
  int mylen ;
  int totlen ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;

  {
#line 462
  p = bufp->page;
#line 463
  bp = (u_int16_t *)p;
#line 464
  mylen = hashp->hdr.bsize - (int )*(bp + 1);
#line 465
  save_addr = (u_int16_t )bufp->addr;
#line 467
  if ((int )*(bp + 2) == 3) {
#line 468
    totlen = len + mylen;
#line 469
    if (hashp->tmp_buf) {
      {
#line 470
      free((void *)hashp->tmp_buf);
      }
    }
    {
#line 471
    tmp___2 = malloc((size_t )totlen);
#line 471
    tmp___1 = (char *)tmp___2;
#line 471
    hashp->tmp_buf = tmp___1;
    }
#line 471
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 472
      return (-1);
    }
#line 473
    if (set) {
#line 474
      hashp->cndx = 1;
#line 475
      if ((int )*(bp + 0) == 2) {
#line 476
        hashp->cpage = (BUFHEAD *)((void *)0);
#line 477
        (hashp->cbucket) ++;
      } else {
        {
#line 479
        hashp->cpage = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)),
                                 bufp, 0);
        }
#line 481
        if (! hashp->cpage) {
#line 482
          return (-1);
        } else
#line 483
        if (! *((u_int16_t *)(hashp->cpage)->page + 0)) {
#line 484
          (hashp->cbucket) ++;
#line 485
          hashp->cpage = (BUFHEAD *)((void *)0);
        }
      }
    }
  } else {
    {
#line 490
    xbp = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)), bufp, 0);
    }
#line 491
    if (! xbp) {
#line 493
      return (-1);
    } else {
      {
#line 491
      totlen = collect_data(hashp, xbp, len + mylen, set);
      }
#line 491
      if (totlen < 1) {
#line 493
        return (-1);
      }
    }
  }
#line 495
  if (bufp->addr != (u_int32_t )save_addr) {
    {
#line 496
    tmp___3 = __errno_location();
#line 496
    *tmp___3 = 22;
    }
#line 497
    return (-1);
  }
  {
#line 499
  memmove((void *)(hashp->tmp_buf + len), (void const   *)(bufp->page + (int )*(bp + 1)),
          (size_t )mylen);
  }
#line 500
  return (totlen);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
extern int __big_keydata(HTAB *hashp , BUFHEAD *bufp , DBT *key , DBT *val , int set ) 
{ 
  int tmp___1 ;

  {
  {
#line 513
  tmp___1 = collect_key(hashp, bufp, 0, val, set);
#line 513
  key->size = (size_t )tmp___1;
  }
#line 514
  if (key->size == 0xffffffffffffffffUL) {
#line 515
    return (-1);
  }
#line 516
  key->data = (void *)((u_char *)hashp->tmp_key);
#line 517
  return (0);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
static int collect_key(HTAB *hashp , BUFHEAD *bufp , int len , DBT *val , int set ) 
{ 
  BUFHEAD *xbp ;
  char *p ;
  int mylen ;
  int totlen ;
  u_int16_t *bp ;
  u_int16_t save_addr ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 537
  p = bufp->page;
#line 538
  bp = (u_int16_t *)p;
#line 539
  mylen = hashp->hdr.bsize - (int )*(bp + 1);
#line 541
  save_addr = (u_int16_t )bufp->addr;
#line 542
  totlen = len + mylen;
#line 543
  if ((int )*(bp + 2) == 2) {
#line 543
    goto _L;
  } else
#line 543
  if ((int )*(bp + 2) == 3) {
    _L: /* CIL Label */ 
#line 544
    if ((unsigned long )hashp->tmp_key != (unsigned long )((void *)0)) {
      {
#line 545
      free((void *)hashp->tmp_key);
      }
    }
    {
#line 546
    tmp___2 = malloc((size_t )totlen);
#line 546
    tmp___1 = (char *)tmp___2;
#line 546
    hashp->tmp_key = tmp___1;
    }
#line 546
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 547
      return (-1);
    }
    {
#line 548
    tmp___3 = __big_return(hashp, bufp, 1, val, set);
    }
#line 548
    if (tmp___3) {
#line 549
      return (-1);
    }
  } else {
    {
#line 551
    xbp = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)), bufp, 0);
    }
#line 552
    if (! xbp) {
#line 554
      return (-1);
    } else {
      {
#line 552
      totlen = collect_key(hashp, xbp, totlen, val, set);
      }
#line 552
      if (totlen < 1) {
#line 554
        return (-1);
      }
    }
  }
#line 556
  if (bufp->addr != (u_int32_t )save_addr) {
    {
#line 557
    tmp___4 = __errno_location();
#line 557
    *tmp___4 = 22;
    }
#line 558
    return (-1);
  }
  {
#line 560
  memmove((void *)(hashp->tmp_key + len), (void const   *)(bufp->page + (int )*(bp + 1)),
          (size_t )mylen);
  }
#line 561
  return (totlen);
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
extern int __big_split(HTAB *hashp , BUFHEAD *op , BUFHEAD *np , BUFHEAD *big_keyp ,
                       int addr , u_int32_t obucket , SPLIT_RETURN *ret ) 
{ 
  register BUFHEAD *tmpp ;
  register u_int16_t *tp ;
  BUFHEAD *bp ;
  DBT key ;
  DBT val ;
  u_int32_t change ;
  u_int16_t free_space ;
  u_int16_t n ;
  u_int16_t off ;
  int tmp___1 ;
  u_int32_t tmp___2 ;
  BUFHEAD *tmp___3 ;
  u_int16_t tmp___4 ;

  {
  {
#line 587
  bp = big_keyp;
#line 590
  tmp___1 = __big_keydata(hashp, big_keyp, & key, & val, 0);
  }
#line 590
  if (tmp___1) {
#line 591
    return (-1);
  }
  {
#line 592
  tmp___2 = __call_hash(hashp, (char *)key.data, (int )key.size);
#line 592
  change = (u_int32_t )(tmp___2 != obucket);
#line 594
  tmp___4 = __find_last_page(hashp, & big_keyp);
#line 594
  ret->next_addr = tmp___4;
  }
#line 594
  if (tmp___4) {
    {
#line 595
    tmp___3 = __get_buf(hashp, (u_int32_t )ret->next_addr, big_keyp, 0);
#line 595
    ret->nextp = tmp___3;
    }
#line 595
    if (! tmp___3) {
#line 597
      return (-1);
    }
  } else {
#line 599
    ret->nextp = (BUFHEAD *)((void *)0);
  }
#line 605
  if (change) {
#line 606
    tmpp = np;
  } else {
#line 608
    tmpp = op;
  }
#line 610
  tmpp->flags = (char )((int )tmpp->flags | 1);
#line 616
  tmpp->ovfl = bp;
#line 617
  tp = (u_int16_t *)tmpp->page;
#line 621
  n = *(tp + 0);
#line 622
  off = *(tp + ((int )*(tp + 0) + 2));
#line 623
  free_space = *(tp + ((int )*(tp + 0) + 1));
#line 624
  n = (u_int16_t )((int )n + 1);
#line 624
  *(tp + n) = (u_int16_t )addr;
#line 625
  n = (u_int16_t )((int )n + 1);
#line 625
  *(tp + n) = (u_int16_t )0;
#line 626
  *(tp + 0) = n;
#line 627
  *(tp + ((int )*(tp + 0) + 2)) = off;
#line 628
  *(tp + ((int )*(tp + 0) + 1)) = (u_int16_t )((unsigned long )free_space - 2UL * sizeof(u_int16_t ));
#line 637
  ret->newp = np;
#line 638
  ret->oldp = op;
#line 640
  tp = (u_int16_t *)big_keyp->page;
#line 641
  big_keyp->flags = (char )((int )big_keyp->flags | 1);
#line 642
  if ((int )*(tp + 0) > 2) {
    {
#line 650
    n = *(tp + 4);
#line 651
    free_space = *(tp + ((int )*(tp + 0) + 1));
#line 652
    off = *(tp + ((int )*(tp + 0) + 2));
#line 653
    *(tp + 0) = (u_int16_t )((int )*(tp + 0) - 2);
#line 654
    *(tp + ((int )*(tp + 0) + 1)) = (u_int16_t )((unsigned long )free_space + 2UL * sizeof(u_int16_t ));
#line 655
    *(tp + ((int )*(tp + 0) + 2)) = off;
#line 656
    tmpp = __add_ovflpage(hashp, big_keyp);
    }
#line 657
    if (! tmpp) {
#line 658
      return (-1);
    }
#line 659
    *(tp + 4) = n;
  } else {
#line 661
    tmpp = big_keyp;
  }
#line 663
  if (change) {
#line 664
    ret->newp = tmpp;
  } else {
#line 666
    ret->oldp = tmpp;
  }
#line 667
  return (0);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_buf.c"
static BUFHEAD *newbuf(HTAB *hashp , u_int32_t addr , BUFHEAD *prev_bp ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_buf.c"
extern BUFHEAD *__get_buf(HTAB *hashp , u_int32_t addr , BUFHEAD *prev_bp , int newpage ) 
{ 
  register BUFHEAD *bp ;
  register u_int32_t is_disk_mask ;
  register int is_disk ;
  register int segment_ndx ;
  SEGMENT segp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 116
  is_disk = 0;
#line 117
  is_disk_mask = (u_int32_t )0;
#line 118
  if (prev_bp) {
#line 119
    bp = prev_bp->ovfl;
#line 120
    if (! bp) {
#line 121
      bp = (BUFHEAD *)((void *)0);
    } else
#line 120
    if (bp->addr != addr) {
#line 121
      bp = (BUFHEAD *)((void *)0);
    }
#line 122
    if (! newpage) {
#line 123
      is_disk = 2;
    }
  } else {
#line 126
    segment_ndx = (int )(addr & (unsigned int )(hashp->hdr.ssize - 1));
#line 129
    segp = *(hashp->dir + (addr >> hashp->hdr.sshift));
#line 133
    bp = (BUFHEAD *)((ptrdiff_t )*(segp + segment_ndx) & -4L);
#line 134
    is_disk_mask = (u_int32_t )((ptrdiff_t )*(segp + segment_ndx)) & 2U;
#line 135
    if (is_disk_mask) {
#line 135
      tmp___1 = 1;
    } else
#line 135
    if (! hashp->new_file) {
#line 135
      tmp___1 = 1;
    } else {
#line 135
      tmp___1 = 0;
    }
#line 135
    is_disk = tmp___1;
  }
#line 138
  if (! bp) {
    {
#line 139
    bp = newbuf(hashp, addr, prev_bp);
    }
#line 140
    if (! bp) {
#line 142
      return ((BUFHEAD *)((void *)0));
    } else {
      {
#line 140
      tmp___2 = __get_page(hashp, bp->page, addr, ! prev_bp, is_disk, 0);
      }
#line 140
      if (tmp___2) {
#line 142
        return ((BUFHEAD *)((void *)0));
      }
    }
#line 143
    if (! prev_bp) {
#line 144
      *(segp + segment_ndx) = (BUFHEAD *)((ptrdiff_t )bp | (long )is_disk_mask);
    }
  } else {
#line 147
    (bp->prev)->next = bp->next;
#line 147
    (bp->next)->prev = bp->prev;
#line 148
    bp->next = hashp->bufhead.next;
#line 148
    bp->prev = & hashp->bufhead;
#line 148
    hashp->bufhead.next = bp;
#line 148
    (bp->next)->prev = bp;
  }
#line 150
  return (bp);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_buf.c"
static BUFHEAD *newbuf(HTAB *hashp , u_int32_t addr , BUFHEAD *prev_bp ) 
{ 
  register BUFHEAD *bp ;
  register BUFHEAD *xbp ;
  register BUFHEAD *next_xbp ;
  SEGMENT segp ;
  int segment_ndx ;
  u_int16_t oaddr ;
  u_int16_t *shortp ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 172
  oaddr = (u_int16_t )0;
#line 173
  bp = hashp->bufhead.prev;
#line 178
  if (hashp->nbufs) {
#line 178
    goto _L___0;
  } else
#line 178
  if ((int )bp->flags & 8) {
    _L___0: /* CIL Label */ 
    {
#line 180
    tmp___1 = malloc(sizeof(BUFHEAD ));
#line 180
    bp = (BUFHEAD *)tmp___1;
    }
#line 180
    if ((unsigned long )bp == (unsigned long )((void *)0)) {
#line 181
      return ((BUFHEAD *)((void *)0));
    }
    {
#line 185
    tmp___3 = malloc((size_t )hashp->hdr.bsize);
#line 185
    tmp___2 = (char *)tmp___3;
#line 185
    bp->page = tmp___2;
    }
#line 185
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 186
      free((void *)bp);
      }
#line 187
      return ((BUFHEAD *)((void *)0));
    }
#line 192
    if (hashp->nbufs) {
#line 193
      (hashp->nbufs) --;
    }
  } else {
#line 196
    (bp->prev)->next = bp->next;
#line 196
    (bp->next)->prev = bp->prev;
#line 201
    if (bp->addr != 0U) {
#line 201
      goto _L;
    } else
#line 201
    if ((int )bp->flags & 4) {
      _L: /* CIL Label */ 
#line 206
      shortp = (u_int16_t *)bp->page;
#line 207
      if (*(shortp + 0)) {
#line 208
        oaddr = *(shortp + ((int )*(shortp + 0) - 1));
      }
#line 209
      if ((int )bp->flags & 1) {
        {
#line 209
        tmp___4 = __put_page(hashp, bp->page, bp->addr, (int )bp->flags & 4, 0);
        }
#line 209
        if (tmp___4) {
#line 211
          return ((BUFHEAD *)((void *)0));
        }
      }
#line 220
      if ((int )bp->flags & 4) {
#line 221
        segment_ndx = (int )(bp->addr & (unsigned int )(hashp->hdr.ssize - 1));
#line 222
        segp = *(hashp->dir + (bp->addr >> hashp->hdr.sshift));
#line 227
        if (hashp->new_file) {
#line 227
          if ((int )bp->flags & 1) {
#line 230
            *(segp + segment_ndx) = (BUFHEAD *)2;
          } else
#line 227
          if ((u_int32_t )((ptrdiff_t )*(segp + segment_ndx)) & 2U) {
#line 230
            *(segp + segment_ndx) = (BUFHEAD *)2;
          } else {
#line 232
            *(segp + segment_ndx) = (BUFHEAD *)((void *)0);
          }
        } else {
#line 232
          *(segp + segment_ndx) = (BUFHEAD *)((void *)0);
        }
      }
#line 239
      xbp = bp;
      {
#line 239
      while (1) {
        while_continue: /* CIL Label */ ;
#line 239
        if (! xbp->ovfl) {
#line 239
          goto while_break;
        }
#line 240
        next_xbp = xbp->ovfl;
#line 241
        xbp->ovfl = (BUFHEAD *)0;
#line 242
        xbp = next_xbp;
#line 245
        if ((int )xbp->flags & 4) {
#line 247
          goto while_break;
        } else
#line 245
        if ((u_int32_t )oaddr != xbp->addr) {
#line 247
          goto while_break;
        }
#line 249
        shortp = (u_int16_t *)xbp->page;
#line 250
        if (*(shortp + 0)) {
#line 252
          oaddr = *(shortp + ((int )*(shortp + 0) - 1));
        }
#line 253
        if ((int )xbp->flags & 1) {
          {
#line 253
          tmp___5 = __put_page(hashp, xbp->page, xbp->addr, 0, 0);
          }
#line 253
          if (tmp___5) {
#line 255
            return ((BUFHEAD *)((void *)0));
          }
        }
#line 256
        xbp->addr = (u_int32_t )0;
#line 257
        xbp->flags = (char)0;
#line 258
        (xbp->prev)->next = xbp->next;
#line 258
        (xbp->next)->prev = xbp->prev;
#line 259
        xbp->next = (hashp->bufhead.prev)->next;
#line 259
        xbp->prev = hashp->bufhead.prev;
#line 259
        (hashp->bufhead.prev)->next = xbp;
#line 259
        (xbp->next)->prev = xbp;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 265
  bp->addr = addr;
#line 270
  bp->ovfl = (BUFHEAD *)((void *)0);
#line 271
  if (prev_bp) {
#line 281
    prev_bp->ovfl = bp;
#line 282
    bp->flags = (char)0;
  } else {
#line 284
    bp->flags = (char)4;
  }
#line 285
  bp->next = hashp->bufhead.next;
#line 285
  bp->prev = & hashp->bufhead;
#line 285
  hashp->bufhead.next = bp;
#line 285
  (bp->next)->prev = bp;
#line 286
  return (bp);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_buf.c"
extern void __buf_init(HTAB *hashp , int nbytes ) 
{ 
  BUFHEAD *bfp ;
  int npages ;

  {
#line 297
  bfp = & hashp->bufhead;
#line 298
  npages = ((nbytes + hashp->hdr.bsize) - 1) >> hashp->hdr.bshift;
#line 299
  if (npages > 6) {
#line 299
    npages = npages;
  } else {
#line 299
    npages = 6;
  }
#line 301
  hashp->nbufs = npages;
#line 302
  bfp->next = bfp;
#line 303
  bfp->prev = bfp;
#line 312
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_buf.c"
extern int __buf_free(HTAB *hashp , int do_free , int to_disk ) 
{ 
  BUFHEAD *bp ;
  int tmp___1 ;

  {
#line 322
  if (! hashp->bufhead.prev) {
#line 323
    return (0);
  }
#line 324
  bp = hashp->bufhead.prev;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! ((unsigned long )bp != (unsigned long )(& hashp->bufhead))) {
#line 324
      goto while_break;
    }
#line 326
    if (bp->addr) {
#line 326
      goto _L;
    } else
#line 326
    if ((int )bp->flags & 4) {
      _L: /* CIL Label */ 
#line 327
      if (to_disk) {
#line 327
        if ((int )bp->flags & 1) {
          {
#line 327
          tmp___1 = __put_page(hashp, bp->page, bp->addr, (int )bp->flags & 4, 0);
          }
#line 327
          if (tmp___1) {
#line 330
            return (-1);
          }
        }
      }
    }
#line 333
    if (do_free) {
#line 334
      if (bp->page) {
        {
#line 335
        free((void *)bp->page);
        }
      }
      {
#line 336
      (bp->prev)->next = bp->next;
#line 336
      (bp->next)->prev = bp->prev;
#line 337
      free((void *)bp);
#line 338
      bp = hashp->bufhead.prev;
      }
    } else {
#line 340
      bp = bp->prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return (0);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_buf.c"
extern void __reclaim_buf(HTAB *hashp , BUFHEAD *bp ) 
{ 


  {
#line 350
  bp->ovfl = (BUFHEAD *)0;
#line 351
  bp->addr = (u_int32_t )0;
#line 352
  bp->flags = (char)0;
#line 353
  (bp->prev)->next = bp->next;
#line 353
  (bp->next)->prev = bp->prev;
#line 354
  bp->next = (hashp->bufhead.prev)->next;
#line 354
  bp->prev = hashp->bufhead.prev;
#line 354
  (hashp->bufhead.prev)->next = bp;
#line 354
  (bp->next)->prev = bp;
#line 355
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_delete.c"
static int rec_rdelete(BTREE *t , u_int32_t nrec ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_delete.c"
int __rec_delete(DB const   *dbp , DBT const   *key , u_int flags ) 
{ 
  BTREE *t ;
  u_int32_t nrec ;
  int status ;
  int *tmp___1 ;

  {
#line 73
  t = (BTREE *)dbp->internal;
#line 76
  if ((unsigned long )t->bt_pinned != (unsigned long )((void *)0)) {
    {
#line 77
    __mpool_put(t->bt_mp, (void *)t->bt_pinned, (u_int )0);
#line 78
    t->bt_pinned = (PAGE *)((void *)0);
    }
  }
  {
#line 82
  if (flags == 0U) {
#line 82
    goto case_0;
  }
#line 90
  if (flags == 1U) {
#line 90
    goto case_1;
  }
#line 99
  goto einval;
  case_0: /* CIL Label */ 
#line 83
  nrec = *((u_int32_t *)key->data);
#line 83
  if (nrec == 0U) {
#line 84
    goto einval;
  }
#line 85
  if (nrec > t->bt_nrecs) {
#line 86
    return (1);
  }
  {
#line 87
  nrec --;
#line 88
  status = rec_rdelete(t, nrec);
  }
#line 89
  goto switch_break;
  case_1: /* CIL Label */ 
#line 91
  if (! ((int )t->bt_cursor.flags & 8)) {
#line 92
    goto einval;
  }
#line 93
  if (t->bt_nrecs == 0U) {
#line 94
    return (1);
  }
  {
#line 95
  status = rec_rdelete(t, t->bt_cursor.rcursor - 1U);
  }
#line 96
  if (status == 0) {
#line 97
    (t->bt_cursor.rcursor) --;
  }
#line 98
  goto switch_break;
  einval: 
  switch_default: /* CIL Label */ 
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 22;
  }
#line 101
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 104
  if (status == 0) {
#line 105
    t->flags |= 4100U;
  }
#line 106
  return (status);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_delete.c"
static int rec_rdelete(BTREE *t , u_int32_t nrec ) 
{ 
  EPG *e ;
  PAGE *h ;
  int status ;

  {
  {
#line 129
  e = __rec_search(t, nrec, (enum SRCHOP )0);
  }
#line 129
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 130
    return (-1);
  }
  {
#line 133
  h = e->page;
#line 134
  status = __rec_dleaf(t, h, (u_int32_t )e->index);
  }
#line 135
  if (status != 0) {
    {
#line 136
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 137
    return (status);
  }
  {
#line 139
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 140
  return (0);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_delete.c"
int __rec_dleaf(BTREE *t , PAGE *h , u_int32_t index___0 ) 
{ 
  RLEAF *rl ;
  u_int16_t *ip ;
  u_int16_t cnt ;
  u_int16_t offset ;
  u_int32_t nbytes ;
  char *from ;
  void *to ;
  int tmp___1 ;
  u_int16_t tmp___2 ;

  {
#line 175
  rl = (RLEAF *)((char *)h + (int )h->linp[index___0]);
#line 175
  to = (void *)rl;
#line 176
  if ((int )rl->flags & 1) {
    {
#line 176
    tmp___1 = __ovfl_delete(t, (void *)(rl->bytes));
    }
#line 176
    if (tmp___1 == -1) {
#line 177
      return (-1);
    }
  }
  {
#line 178
  nbytes = (u_int32_t )(((((sizeof(u_int32_t ) + sizeof(u_char )) + (unsigned long )rl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 184
  from = (char *)h + (int )h->upper;
#line 185
  memmove((void *)(from + nbytes), (void const   *)from, (size_t )((char *)to - from));
#line 186
  h->upper = (u_int16_t )((u_int32_t )h->upper + nbytes);
#line 188
  offset = h->linp[index___0];
#line 189
  ip = & h->linp[0];
#line 189
  cnt = (u_int16_t )(& h->linp[index___0] - ip);
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    tmp___2 = cnt;
#line 189
    cnt = (u_int16_t )((int )cnt - 1);
#line 189
    if (! tmp___2) {
#line 189
      goto while_break;
    }
#line 190
    if ((int )*(ip + 0) < (int )offset) {
#line 191
      *(ip + 0) = (u_int16_t )((u_int32_t )*(ip + 0) + nbytes);
    }
#line 189
    ip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  cnt = (u_int16_t )(& h->linp[((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )] - ip);
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    cnt = (u_int16_t )((int )cnt - 1);
#line 192
    if (! cnt) {
#line 192
      goto while_break___0;
    }
#line 193
    if ((int )*(ip + 1) < (int )offset) {
#line 193
      *(ip + 0) = (u_int16_t )((u_int32_t )*(ip + 1) + nbytes);
    } else {
#line 193
      *(ip + 0) = *(ip + 1);
    }
#line 192
    ip ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 194
  h->lower = (u_int16_t )((unsigned long )h->lower - sizeof(u_int16_t ));
#line 195
  (t->bt_nrecs) --;
#line 196
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_put.c"
static EPG *bt_fast___0(BTREE *t , DBT const   *key , DBT const   *data , int *exactp ) ;
#line 266 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_put.c"
static EPG *bt_fast___0(BTREE *t , DBT const   *key , DBT const   *data , int *exactp ) 
{ 
  PAGE *h ;
  u_int32_t nbytes ;
  int cmp ;
  void *tmp___1 ;

  {
  {
#line 276
  tmp___1 = __mpool_get(t->bt_mp, t->bt_last.pgno, (u_int )0);
#line 276
  h = (PAGE *)tmp___1;
  }
#line 276
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 277
    t->bt_order = (enum __anonenum_bt_order_54 )0;
#line 278
    return ((EPG *)((void *)0));
  }
#line 280
  t->bt_cur.page = h;
#line 281
  t->bt_cur.index = t->bt_last.index;
#line 287
  nbytes = (u_int32_t )(((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )key->size) + (unsigned long )data->size) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 288
  if ((unsigned long )((u_int32_t )((int )h->upper - (int )h->lower)) < (unsigned long )nbytes + sizeof(u_int16_t )) {
#line 289
    goto miss;
  }
#line 291
  if ((unsigned int )t->bt_order == 2U) {
#line 292
    if ((t->bt_cur.page)->nextpg != 0U) {
#line 293
      goto miss;
    }
#line 294
    if ((unsigned long )t->bt_cur.index != ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL) {
#line 295
      goto miss;
    }
    {
#line 296
    cmp = __bt_cmp(t, key, & t->bt_cur);
    }
#line 296
    if (cmp < 0) {
#line 297
      goto miss;
    }
#line 298
    if (cmp) {
#line 298
      t->bt_cur.index = (u_int16_t )((int )t->bt_cur.index + 1);
#line 298
      t->bt_last.index = t->bt_cur.index;
    } else {
#line 298
      t->bt_last.index = t->bt_cur.index;
    }
  } else {
#line 300
    if ((t->bt_cur.page)->prevpg != 0U) {
#line 301
      goto miss;
    }
#line 302
    if ((int )t->bt_cur.index != 0) {
#line 303
      goto miss;
    }
    {
#line 304
    cmp = __bt_cmp(t, key, & t->bt_cur);
    }
#line 304
    if (cmp > 0) {
#line 305
      goto miss;
    }
#line 306
    t->bt_last.index = (u_int16_t )0;
  }
#line 308
  *exactp = cmp == 0;
#line 312
  return (& t->bt_cur);
  miss: 
  {
#line 318
  t->bt_order = (enum __anonenum_bt_order_54 )0;
#line 319
  __mpool_put(t->bt_mp, (void *)h, (u_int )0);
  }
#line 320
  return ((EPG *)((void *)0));
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db/db.c"
static int __dberr___0(void) 
{ 


  {
#line 89
  return (-1);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static u_int32_t *fetch_bitmap___0(HTAB *hashp , int ndx ) ;
#line 76
static u_int32_t first_free___0(u_int32_t map ) ;
#line 77
static int open_temp___0(HTAB *hashp ) ;
#line 78
static u_int16_t overflow_page___0(HTAB *hashp ) ;
#line 79
static void putpair___0(char *p , DBT const   *key , DBT const   *val ) ;
#line 80
static void squeeze_key___0(u_int16_t *sp , DBT const   *key , DBT const   *val ) ;
#line 81
static int ugly_split___0(HTAB *hashp , u_int32_t obucket , BUFHEAD *old_bufp , BUFHEAD *new_bufp ,
                          int copyto , int moved ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static void putpair___0(char *p , DBT const   *key , DBT const   *val ) 
{ 
  register u_int16_t *bp ;
  register u_int16_t n ;
  register u_int16_t off ;

  {
  {
#line 102
  bp = (u_int16_t *)p;
#line 105
  n = *(bp + 0);
#line 107
  off = (u_int16_t )((size_t const   )*(bp + ((int )*(bp + 0) + 2)) - key->size);
#line 108
  memmove((void *)(p + (int )off), (void const   *)key->data, (size_t )key->size);
#line 109
  n = (u_int16_t )((int )n + 1);
#line 109
  *(bp + n) = off;
#line 112
  off = (u_int16_t )((size_t const   )off - val->size);
#line 113
  memmove((void *)(p + (int )off), (void const   *)val->data, (size_t )val->size);
#line 114
  n = (u_int16_t )((int )n + 1);
#line 114
  *(bp + n) = off;
#line 117
  *(bp + 0) = n;
#line 118
  *(bp + ((int )n + 1)) = (u_int16_t )((unsigned long )off - (unsigned long )((int )n + 3) * sizeof(u_int16_t ));
#line 119
  *(bp + ((int )n + 2)) = off;
  }
#line 120
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static int ugly_split___0(HTAB *hashp , u_int32_t obucket , BUFHEAD *old_bufp , BUFHEAD *new_bufp ,
                          int copyto , int moved ) 
{ 
  register BUFHEAD *bufp ;
  register u_int16_t *ino ;
  register u_int16_t *np ;
  register u_int16_t *op ;
  BUFHEAD *last_bfp ;
  DBT key ;
  DBT val ;
  SPLIT_RETURN ret ;
  u_int16_t n ;
  u_int16_t off ;
  u_int16_t ov_addr ;
  u_int16_t scopyto ;
  char *cino ;
  int tmp___1 ;
  u_int32_t tmp___2 ;

  {
#line 295
  bufp = old_bufp;
#line 296
  ino = (u_int16_t *)old_bufp->page;
#line 297
  np = (u_int16_t *)new_bufp->page;
#line 298
  op = (u_int16_t *)old_bufp->page;
#line 299
  last_bfp = (BUFHEAD *)((void *)0);
#line 300
  scopyto = (u_int16_t )copyto;
#line 302
  n = (u_int16_t )((int )*(ino + 0) - 1);
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! ((int )n < (int )*(ino + 0))) {
#line 303
      goto while_break;
    }
#line 304
    if ((int )*(ino + 2) < 4) {
#line 304
      if ((int )*(ino + 2) != 0) {
        {
#line 305
        tmp___1 = __big_split(hashp, old_bufp, new_bufp, bufp, (int )bufp->addr, obucket,
                              & ret);
        }
#line 305
        if (tmp___1) {
#line 307
          return (-1);
        }
#line 308
        old_bufp = ret.oldp;
#line 309
        if (! old_bufp) {
#line 310
          return (-1);
        }
#line 311
        op = (u_int16_t *)old_bufp->page;
#line 312
        new_bufp = ret.newp;
#line 313
        if (! new_bufp) {
#line 314
          return (-1);
        }
#line 315
        np = (u_int16_t *)new_bufp->page;
#line 316
        bufp = ret.nextp;
#line 317
        if (! bufp) {
#line 318
          return (0);
        }
#line 319
        cino = bufp->page;
#line 320
        ino = (u_int16_t *)cino;
#line 321
        last_bfp = ret.nextp;
      } else {
#line 304
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 322
    if ((int )*(ino + ((int )n + 1)) == 0) {
      {
#line 323
      ov_addr = *(ino + n);
#line 328
      *(ino + 0) = (u_int16_t )((int )*(ino + 0) - (moved + 2));
#line 329
      *(ino + ((int )*(ino + 0) + 1)) = (u_int16_t )((unsigned long )scopyto - sizeof(u_int16_t ) * (unsigned long )((int )*(ino + 0) + 3));
#line 331
      *(ino + ((int )*(ino + 0) + 2)) = scopyto;
#line 333
      bufp = __get_buf(hashp, (u_int32_t )ov_addr, bufp, 0);
      }
#line 334
      if (! bufp) {
#line 335
        return (-1);
      }
#line 337
      ino = (u_int16_t *)bufp->page;
#line 338
      n = (u_int16_t )1;
#line 339
      scopyto = (u_int16_t )hashp->hdr.bsize;
#line 340
      moved = 0;
#line 342
      if (last_bfp) {
        {
#line 343
        __free_ovflpage(hashp, last_bfp);
        }
      }
#line 344
      last_bfp = bufp;
    }
#line 347
    off = (u_int16_t )hashp->hdr.bsize;
#line 348
    n = (u_int16_t )1;
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 348
      if ((int )n < (int )*(ino + 0)) {
#line 348
        if (! ((int )*(ino + ((int )n + 1)) >= 4)) {
#line 348
          goto while_break___0;
        }
      } else {
#line 348
        goto while_break___0;
      }
      {
#line 349
      cino = (char *)ino;
#line 350
      key.data = (void *)((u_char *)cino + (int )*(ino + n));
#line 351
      key.size = (size_t )((int )off - (int )*(ino + n));
#line 352
      val.data = (void *)((u_char *)cino + (int )*(ino + ((int )n + 1)));
#line 353
      val.size = (size_t )((int )*(ino + n) - (int )*(ino + ((int )n + 1)));
#line 354
      off = *(ino + ((int )n + 1));
#line 356
      tmp___2 = __call_hash(hashp, (char *)key.data, (int )key.size);
      }
#line 356
      if (tmp___2 == obucket) {
#line 358
        if ((int )*(op + 2) >= 4) {
#line 358
          if (((2UL * sizeof(u_int16_t ) + key.size) + val.size) + 2UL * sizeof(u_int16_t ) <= (unsigned long )*(op + ((int )*(op + 0) + 1))) {
            {
#line 359
            putpair___0((char *)op, (DBT const   *)(& key), (DBT const   *)(& val));
            }
          } else {
#line 358
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 361
          old_bufp = __add_ovflpage(hashp, old_bufp);
          }
#line 363
          if (! old_bufp) {
#line 364
            return (-1);
          }
          {
#line 365
          op = (u_int16_t *)old_bufp->page;
#line 366
          putpair___0((char *)op, (DBT const   *)(& key), (DBT const   *)(& val));
          }
        }
#line 368
        old_bufp->flags = (char )((int )old_bufp->flags | 1);
      } else {
#line 371
        if ((int )*(np + 2) >= 4) {
#line 371
          if (((2UL * sizeof(u_int16_t ) + key.size) + val.size) + 2UL * sizeof(u_int16_t ) <= (unsigned long )*(np + ((int )*(np + 0) + 1))) {
            {
#line 372
            putpair___0((char *)np, (DBT const   *)(& key), (DBT const   *)(& val));
            }
          } else {
#line 371
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 374
          new_bufp = __add_ovflpage(hashp, new_bufp);
          }
#line 376
          if (! new_bufp) {
#line 377
            return (-1);
          }
          {
#line 378
          np = (u_int16_t *)new_bufp->page;
#line 379
          putpair___0((char *)np, (DBT const   *)(& key), (DBT const   *)(& val));
          }
        }
#line 381
        new_bufp->flags = (char )((int )new_bufp->flags | 1);
      }
#line 348
      n = (u_int16_t )((int )n + 2);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (last_bfp) {
    {
#line 386
    __free_ovflpage(hashp, last_bfp);
    }
  }
#line 387
  return (0);
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static u_int32_t first_free___0(u_int32_t map ) 
{ 
  register u_int32_t i ;
  register u_int32_t mask ;

  {
#line 655
  mask = (u_int32_t )1;
#line 656
  i = (u_int32_t )0;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (! (i < 32U)) {
#line 656
      goto while_break;
    }
#line 657
    if (! (mask & map)) {
#line 658
      return (i);
    }
#line 659
    mask <<= 1;
#line 656
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 661
  return (i);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static u_int16_t overflow_page___0(HTAB *hashp ) 
{ 
  register u_int32_t *freep ;
  register int max_free ;
  register int offset ;
  register int splitnum ;
  u_int16_t addr ;
  int bit ;
  int first_page ;
  int free_bit ;
  int free_page ;
  int i ;
  int in_use_bits ;
  int j ;
  int tmp___1 ;
  int tmp___2 ;
  u_int32_t tmp___3 ;

  {
#line 675
  splitnum = hashp->hdr.ovfl_point;
#line 676
  max_free = hashp->hdr.spares[splitnum];
#line 678
  free_page = (max_free - 1) >> (hashp->hdr.bshift + 3);
#line 679
  free_bit = (max_free - 1) & ((hashp->hdr.bsize << 3) - 1);
#line 682
  first_page = hashp->hdr.last_freed >> (hashp->hdr.bshift + 3);
#line 683
  i = first_page;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (i <= free_page)) {
#line 683
      goto while_break;
    }
#line 684
    freep = hashp->mapp[i];
#line 684
    if (! freep) {
      {
#line 684
      freep = fetch_bitmap___0(hashp, i);
      }
#line 684
      if (! freep) {
#line 686
        return ((u_int16_t )0);
      }
    }
#line 687
    if (i == free_page) {
#line 688
      in_use_bits = free_bit;
    } else {
#line 690
      in_use_bits = (hashp->hdr.bsize << 3) - 1;
    }
#line 692
    if (i == first_page) {
#line 693
      bit = hashp->hdr.last_freed & ((hashp->hdr.bsize << 3) - 1);
#line 695
      j = bit / 32;
#line 696
      bit &= -32;
    } else {
#line 698
      bit = 0;
#line 699
      j = 0;
    }
    {
#line 701
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 701
      if (! (bit <= in_use_bits)) {
#line 701
        goto while_break___0;
      }
#line 702
      if (*(freep + j) != 4294967295U) {
#line 703
        goto found;
      }
#line 701
      j ++;
#line 701
      bit += 32;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 683
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  hashp->hdr.last_freed = hashp->hdr.spares[splitnum];
#line 708
  (hashp->hdr.spares[splitnum]) ++;
#line 709
  if (splitnum) {
#line 709
    tmp___1 = hashp->hdr.spares[splitnum - 1];
  } else {
#line 709
    tmp___1 = 0;
  }
#line 709
  offset = hashp->hdr.spares[splitnum] - tmp___1;
#line 713
  if (offset > 2047) {
#line 714
    splitnum ++;
#line 714
    if (splitnum >= 32) {
      {
#line 715
      write(2, (void const   *)"HASH: Out of overflow pages.  Increase page size\n",
            sizeof("HASH: Out of overflow pages.  Increase page size\n") - 1UL);
      }
#line 716
      return ((u_int16_t )0);
    }
#line 718
    hashp->hdr.ovfl_point = splitnum;
#line 719
    hashp->hdr.spares[splitnum] = hashp->hdr.spares[splitnum - 1];
#line 720
    (hashp->hdr.spares[splitnum - 1]) --;
#line 721
    offset = 1;
  }
#line 725
  if (free_bit == (hashp->hdr.bsize << 3) - 1) {
#line 726
    free_page ++;
#line 727
    if (free_page >= 32) {
      {
#line 728
      write(2, (void const   *)"HASH: Out of overflow pages.  Increase page size\n",
            sizeof("HASH: Out of overflow pages.  Increase page size\n") - 1UL);
      }
#line 729
      return ((u_int16_t )0);
    }
    {
#line 742
    tmp___2 = __ibitmap(hashp, (int )(((u_int32_t )splitnum << 11) + (u_int32_t )offset),
                        1, free_page);
    }
#line 742
    if (tmp___2) {
#line 744
      return ((u_int16_t )0);
    }
#line 745
    (hashp->hdr.spares[splitnum]) ++;
#line 749
    offset ++;
#line 750
    if (offset > 2047) {
#line 751
      splitnum ++;
#line 751
      if (splitnum >= 32) {
        {
#line 752
        write(2, (void const   *)"HASH: Out of overflow pages.  Increase page size\n",
              sizeof("HASH: Out of overflow pages.  Increase page size\n") - 1UL);
        }
#line 754
        return ((u_int16_t )0);
      }
#line 756
      hashp->hdr.ovfl_point = splitnum;
#line 757
      hashp->hdr.spares[splitnum] = hashp->hdr.spares[splitnum - 1];
#line 758
      (hashp->hdr.spares[splitnum - 1]) --;
#line 759
      offset = 0;
    }
  } else {
#line 766
    free_bit ++;
#line 767
    *(freep + free_bit / 32) |= (unsigned int )(1 << free_bit % 32);
  }
#line 771
  addr = (u_int16_t )(((u_int32_t )splitnum << 11) + (u_int32_t )offset);
#line 776
  return (addr);
  found: 
  {
#line 779
  tmp___3 = first_free___0(*(freep + j));
#line 779
  bit = (int )((u_int32_t )bit + tmp___3);
#line 780
  *(freep + bit / 32) |= (unsigned int )(1 << bit % 32);
#line 790
  bit = (1 + bit) + i * (hashp->hdr.bsize << 3);
  }
#line 791
  if (bit >= hashp->hdr.last_freed) {
#line 792
    hashp->hdr.last_freed = bit - 1;
  }
#line 795
  i = 0;
  {
#line 795
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 795
    if (i < splitnum) {
#line 795
      if (! (bit > hashp->hdr.spares[i])) {
#line 795
        goto while_break___1;
      }
    } else {
#line 795
      goto while_break___1;
    }
#line 795
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 796
  if (i) {
#line 796
    offset = bit - hashp->hdr.spares[i - 1];
  } else {
#line 796
    offset = bit;
  }
#line 797
  if (offset >= 2047) {
#line 798
    return ((u_int16_t )0);
  }
#line 799
  addr = (u_int16_t )(((u_int32_t )i << 11) + (u_int32_t )offset);
#line 806
  return (addr);
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static char namestr___0[12]  = 
#line 863
  {      (char )'_',      (char )'h',      (char )'a',      (char )'s', 
        (char )'h',      (char )'X',      (char )'X',      (char )'X', 
        (char )'X',      (char )'X',      (char )'X',      (char )'\000'};
#line 858 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static int open_temp___0(HTAB *hashp ) 
{ 
  sigset_t set ;
  sigset_t oset ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 866
  sigfillset(& set);
#line 867
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)(& oset));
#line 868
  tmp___1 = mkstemp(namestr___0);
#line 868
  hashp->fp = tmp___1;
  }
#line 868
  if (tmp___1 != -1) {
    {
#line 869
    unlink((char const   *)(namestr___0));
#line 870
    fcntl(hashp->fp, 2, 1);
    }
  }
  {
#line 872
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& oset), (sigset_t */* __restrict  */)((sigset_t *)((void *)0)));
  }
#line 873
  if (hashp->fp != -1) {
#line 873
    tmp___2 = 0;
  } else {
#line 873
    tmp___2 = -1;
  }
#line 873
  return (tmp___2);
}
}
#line 880 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static void squeeze_key___0(u_int16_t *sp , DBT const   *key , DBT const   *val ) 
{ 
  register char *p ;
  u_int16_t free_space ;
  u_int16_t n ;
  u_int16_t off ;
  u_int16_t pageno ;

  {
  {
#line 888
  p = (char *)sp;
#line 889
  n = *(sp + 0);
#line 890
  free_space = *(sp + ((int )*(sp + 0) + 1));
#line 891
  off = *(sp + ((int )*(sp + 0) + 2));
#line 893
  pageno = *(sp + ((int )n - 1));
#line 894
  off = (u_int16_t )((size_t const   )off - key->size);
#line 895
  *(sp + ((int )n - 1)) = off;
#line 896
  memmove((void *)(p + (int )off), (void const   *)key->data, (size_t )key->size);
#line 897
  off = (u_int16_t )((size_t const   )off - val->size);
#line 898
  *(sp + n) = off;
#line 899
  memmove((void *)(p + (int )off), (void const   *)val->data, (size_t )val->size);
#line 900
  *(sp + 0) = (u_int16_t )((int )n + 2);
#line 901
  *(sp + ((int )n + 1)) = pageno;
#line 902
  *(sp + ((int )n + 2)) = (u_int16_t )0;
#line 903
  *(sp + ((int )*(sp + 0) + 1)) = (u_int16_t )((unsigned long )free_space - ((2UL * sizeof(u_int16_t ) + (unsigned long )key->size) + (unsigned long )val->size));
#line 904
  *(sp + ((int )*(sp + 0) + 2)) = off;
  }
#line 905
  return;
}
}
#line 907 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_page.c"
static u_int32_t *fetch_bitmap___0(HTAB *hashp , int ndx ) 
{ 
  u_int32_t *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 912
  if (ndx >= hashp->nmaps) {
#line 913
    return ((u_int32_t *)((void *)0));
  }
  {
#line 914
  tmp___2 = malloc((size_t )hashp->hdr.bsize);
#line 914
  tmp___1 = (u_int32_t *)tmp___2;
#line 914
  hashp->mapp[ndx] = tmp___1;
  }
#line 914
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 915
    return ((u_int32_t *)((void *)0));
  }
  {
#line 916
  tmp___3 = __get_page(hashp, (char *)hashp->mapp[ndx], (u_int32_t )hashp->hdr.bitmaps[ndx],
                       0, 1, 1);
  }
#line 916
  if (tmp___3) {
    {
#line 918
    free((void *)hashp->mapp[ndx]);
    }
#line 919
    return ((u_int32_t *)((void *)0));
  }
#line 921
  return (hashp->mapp[ndx]);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
static int collect_key___0(HTAB *hashp , BUFHEAD *bufp , int len , DBT *val , int set ) ;
#line 76
static int collect_data___0(HTAB *hashp , BUFHEAD *bufp , int len , int set ) ;
#line 450 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
static int collect_data___0(HTAB *hashp , BUFHEAD *bufp , int len , int set ) 
{ 
  register u_int16_t *bp ;
  register char *p ;
  BUFHEAD *xbp ;
  u_int16_t save_addr ;
  int mylen ;
  int totlen ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;

  {
#line 462
  p = bufp->page;
#line 463
  bp = (u_int16_t *)p;
#line 464
  mylen = hashp->hdr.bsize - (int )*(bp + 1);
#line 465
  save_addr = (u_int16_t )bufp->addr;
#line 467
  if ((int )*(bp + 2) == 3) {
#line 468
    totlen = len + mylen;
#line 469
    if (hashp->tmp_buf) {
      {
#line 470
      free((void *)hashp->tmp_buf);
      }
    }
    {
#line 471
    tmp___2 = malloc((size_t )totlen);
#line 471
    tmp___1 = (char *)tmp___2;
#line 471
    hashp->tmp_buf = tmp___1;
    }
#line 471
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 472
      return (-1);
    }
#line 473
    if (set) {
#line 474
      hashp->cndx = 1;
#line 475
      if ((int )*(bp + 0) == 2) {
#line 476
        hashp->cpage = (BUFHEAD *)((void *)0);
#line 477
        (hashp->cbucket) ++;
      } else {
        {
#line 479
        hashp->cpage = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)),
                                 bufp, 0);
        }
#line 481
        if (! hashp->cpage) {
#line 482
          return (-1);
        } else
#line 483
        if (! *((u_int16_t *)(hashp->cpage)->page + 0)) {
#line 484
          (hashp->cbucket) ++;
#line 485
          hashp->cpage = (BUFHEAD *)((void *)0);
        }
      }
    }
  } else {
    {
#line 490
    xbp = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)), bufp, 0);
    }
#line 491
    if (! xbp) {
#line 493
      return (-1);
    } else {
      {
#line 491
      totlen = collect_data___0(hashp, xbp, len + mylen, set);
      }
#line 491
      if (totlen < 1) {
#line 493
        return (-1);
      }
    }
  }
#line 495
  if (bufp->addr != (u_int32_t )save_addr) {
    {
#line 496
    tmp___3 = __errno_location();
#line 496
    *tmp___3 = 22;
    }
#line 497
    return (-1);
  }
  {
#line 499
  memmove((void *)(hashp->tmp_buf + len), (void const   *)(bufp->page + (int )*(bp + 1)),
          (size_t )mylen);
  }
#line 500
  return (totlen);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_bigkey.c"
static int collect_key___0(HTAB *hashp , BUFHEAD *bufp , int len , DBT *val , int set ) 
{ 
  BUFHEAD *xbp ;
  char *p ;
  int mylen ;
  int totlen ;
  u_int16_t *bp ;
  u_int16_t save_addr ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 537
  p = bufp->page;
#line 538
  bp = (u_int16_t *)p;
#line 539
  mylen = hashp->hdr.bsize - (int )*(bp + 1);
#line 541
  save_addr = (u_int16_t )bufp->addr;
#line 542
  totlen = len + mylen;
#line 543
  if ((int )*(bp + 2) == 2) {
#line 543
    goto _L;
  } else
#line 543
  if ((int )*(bp + 2) == 3) {
    _L: /* CIL Label */ 
#line 544
    if ((unsigned long )hashp->tmp_key != (unsigned long )((void *)0)) {
      {
#line 545
      free((void *)hashp->tmp_key);
      }
    }
    {
#line 546
    tmp___2 = malloc((size_t )totlen);
#line 546
    tmp___1 = (char *)tmp___2;
#line 546
    hashp->tmp_key = tmp___1;
    }
#line 546
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 547
      return (-1);
    }
    {
#line 548
    tmp___3 = __big_return(hashp, bufp, 1, val, set);
    }
#line 548
    if (tmp___3) {
#line 549
      return (-1);
    }
  } else {
    {
#line 551
    xbp = __get_buf(hashp, (u_int32_t )*(bp + ((int )*(bp + 0) - 1)), bufp, 0);
    }
#line 552
    if (! xbp) {
#line 554
      return (-1);
    } else {
      {
#line 552
      totlen = collect_key___0(hashp, xbp, totlen, val, set);
      }
#line 552
      if (totlen < 1) {
#line 554
        return (-1);
      }
    }
  }
#line 556
  if (bufp->addr != (u_int32_t )save_addr) {
    {
#line 557
    tmp___4 = __errno_location();
#line 557
    *tmp___4 = 22;
    }
#line 558
    return (-1);
  }
  {
#line 560
  memmove((void *)(hashp->tmp_key + len), (void const   *)(bufp->page + (int )*(bp + 1)),
          (size_t )mylen);
  }
#line 561
  return (totlen);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static int bt_broot___0(BTREE *t , PAGE *h , PAGE *l , PAGE *r ) ;
#line 52
static PAGE *bt_page___0(BTREE *t , PAGE *h , PAGE **lp , PAGE **rp , u_int16_t *skip ,
                         size_t ilen ) ;
#line 54
static int bt_preserve___0(BTREE *t , u_int32_t pg ) ;
#line 55
static PAGE *bt_psplit___0(BTREE *t , PAGE *h , PAGE *l , PAGE *r , u_int16_t *pskip ,
                           size_t ilen ) ;
#line 57
static PAGE *bt_root___0(BTREE *t , PAGE *h , PAGE **lp , PAGE **rp , u_int16_t *skip ,
                         size_t ilen ) ;
#line 59
static int bt_rroot___0(BTREE *t , PAGE *h , PAGE *l , PAGE *r ) ;
#line 60
static u_int32_t rec_total___0(PAGE *h ) ;
#line 344 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static PAGE *bt_page___0(BTREE *t , PAGE *h , PAGE **lp , PAGE **rp , u_int16_t *skip ,
                         size_t ilen ) 
{ 
  PAGE *l ;
  PAGE *r ;
  PAGE *tp ;
  u_int32_t npg ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 358
  r = __bt_new(t, & npg);
  }
#line 358
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 359
    return ((PAGE *)((void *)0));
  }
#line 360
  r->pgno = npg;
#line 361
  r->lower = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 362
  r->upper = (u_int16_t )t->bt_psize;
#line 363
  r->nextpg = h->nextpg;
#line 364
  r->prevpg = h->pgno;
#line 365
  r->flags = h->flags & 31U;
#line 377
  if (h->nextpg == 0U) {
#line 377
    if ((unsigned long )*skip == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
#line 381
      h->nextpg = r->pgno;
#line 382
      r->lower = (u_int16_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 383
      *skip = (u_int16_t )0;
#line 384
      *lp = h;
#line 385
      *rp = r;
#line 386
      return (r);
    }
  }
  {
#line 390
  tmp___1 = malloc((size_t )t->bt_psize);
#line 390
  l = (PAGE *)tmp___1;
  }
#line 390
  if ((unsigned long )l == (unsigned long )((void *)0)) {
    {
#line 391
    __mpool_put(t->bt_mp, (void *)r, (u_int )0);
    }
#line 392
    return ((PAGE *)((void *)0));
  }
#line 397
  l->pgno = h->pgno;
#line 398
  l->nextpg = r->pgno;
#line 399
  l->prevpg = h->prevpg;
#line 400
  l->lower = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 401
  l->upper = (u_int16_t )t->bt_psize;
#line 402
  l->flags = h->flags & 31U;
#line 405
  if (h->nextpg != 0U) {
    {
#line 406
    tmp___2 = __mpool_get(t->bt_mp, h->nextpg, (u_int )0);
#line 406
    tp = (PAGE *)tmp___2;
    }
#line 406
    if ((unsigned long )tp == (unsigned long )((void *)0)) {
      {
#line 407
      free((void *)l);
      }
#line 409
      return ((PAGE *)((void *)0));
    }
    {
#line 411
    tp->prevpg = r->pgno;
#line 412
    __mpool_put(t->bt_mp, (void *)tp, (u_int )1);
    }
  }
  {
#line 422
  tp = bt_psplit___0(t, h, l, r, skip, ilen);
#line 425
  memmove((void *)h, (void const   *)l, (size_t )t->bt_psize);
  }
#line 426
  if ((unsigned long )tp == (unsigned long )l) {
#line 427
    tp = h;
  }
  {
#line 428
  free((void *)l);
#line 430
  *lp = h;
#line 431
  *rp = r;
  }
#line 432
  return (tp);
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static PAGE *bt_root___0(BTREE *t , PAGE *h , PAGE **lp , PAGE **rp , u_int16_t *skip ,
                         size_t ilen ) 
{ 
  PAGE *l ;
  PAGE *r ;
  PAGE *tp ;
  u_int32_t lnpg ;
  u_int32_t rnpg ;
  u_int32_t tmp___1 ;
  u_int16_t tmp___2 ;
  u_int16_t tmp___3 ;
  u_int32_t tmp___4 ;

  {
  {
#line 464
  l = __bt_new(t, & lnpg);
  }
#line 464
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 466
    return ((PAGE *)((void *)0));
  } else {
    {
#line 464
    r = __bt_new(t, & rnpg);
    }
#line 464
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 466
      return ((PAGE *)((void *)0));
    }
  }
  {
#line 467
  l->pgno = lnpg;
#line 468
  r->pgno = rnpg;
#line 469
  l->nextpg = r->pgno;
#line 470
  r->prevpg = l->pgno;
#line 471
  tmp___1 = (u_int32_t )0;
#line 471
  r->nextpg = tmp___1;
#line 471
  l->prevpg = tmp___1;
#line 472
  tmp___2 = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 472
  r->lower = tmp___2;
#line 472
  l->lower = tmp___2;
#line 473
  tmp___3 = (u_int16_t )t->bt_psize;
#line 473
  r->upper = tmp___3;
#line 473
  l->upper = tmp___3;
#line 474
  tmp___4 = h->flags & 31U;
#line 474
  r->flags = tmp___4;
#line 474
  l->flags = tmp___4;
#line 477
  tp = bt_psplit___0(t, h, l, r, skip, ilen);
#line 479
  *lp = l;
#line 480
  *rp = r;
  }
#line 481
  return (tp);
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static int bt_rroot___0(BTREE *t , PAGE *h , PAGE *l , PAGE *r ) 
{ 
  char *dest ;
  u_int16_t tmp___1 ;
  u_int32_t tmp___2 ;
  u_int16_t tmp___3 ;
  u_int32_t tmp___4 ;

  {
#line 504
  tmp___1 = (u_int16_t )((unsigned long )t->bt_psize - ((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL)));
#line 504
  h->upper = tmp___1;
#line 504
  h->linp[0] = tmp___1;
#line 505
  dest = (char *)h + (int )h->upper;
#line 506
  if (l->flags & 16U) {
#line 506
    *((u_int32_t *)dest) = (u_int32_t )(((unsigned long )l->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
  } else {
    {
#line 506
    tmp___2 = rec_total___0(l);
#line 506
    *((u_int32_t *)dest) = tmp___2;
    }
  }
#line 506
  dest += sizeof(u_int32_t );
#line 506
  *((u_int32_t *)dest) = l->pgno;
#line 509
  tmp___3 = (u_int16_t )((unsigned long )h->upper - ((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL)));
#line 509
  h->upper = tmp___3;
#line 509
  h->linp[1] = tmp___3;
#line 510
  dest = (char *)h + (int )h->upper;
#line 511
  if (r->flags & 16U) {
#line 511
    *((u_int32_t *)dest) = (u_int32_t )(((unsigned long )r->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
  } else {
    {
#line 511
    tmp___4 = rec_total___0(r);
#line 511
    *((u_int32_t *)dest) = tmp___4;
    }
  }
  {
#line 511
  dest += sizeof(u_int32_t );
#line 511
  *((u_int32_t *)dest) = r->pgno;
#line 514
  h->lower = (u_int16_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t )) + 2UL * sizeof(u_int16_t ));
#line 517
  h->flags &= 4294967264U;
#line 518
  h->flags |= 8U;
#line 519
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 521
  return (0);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static int bt_broot___0(BTREE *t , PAGE *h , PAGE *l , PAGE *r ) 
{ 
  BINTERNAL *bi ;
  BLEAF *bl ;
  u_int32_t nbytes ;
  char *dest ;
  u_int16_t tmp___1 ;
  u_int16_t tmp___2 ;
  int tmp___3 ;
  u_int16_t tmp___4 ;

  {
#line 554
  nbytes = (u_int32_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 555
  tmp___1 = (u_int16_t )(t->bt_psize - nbytes);
#line 555
  h->upper = tmp___1;
#line 555
  h->linp[0] = tmp___1;
#line 556
  dest = (char *)h + (int )h->upper;
#line 557
  *((u_int32_t *)dest) = (u_int32_t )0;
#line 557
  dest += sizeof(u_int32_t );
#line 557
  *((u_int32_t *)dest) = l->pgno;
#line 557
  dest += sizeof(u_int32_t );
#line 557
  *((u_char *)dest) = (u_char )0;
#line 557
  dest += sizeof(u_char );
  {
#line 560
  if ((h->flags & 31U) == 2U) {
#line 560
    goto case_2;
  }
#line 576
  if ((h->flags & 31U) == 1U) {
#line 576
    goto case_1;
  }
#line 584
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 561
  bl = (BLEAF *)((char *)r + (int )r->linp[0]);
#line 562
  nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bl->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 563
  tmp___2 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 563
  h->upper = tmp___2;
#line 563
  h->linp[1] = tmp___2;
#line 564
  dest = (char *)h + (int )h->upper;
#line 565
  *((u_int32_t *)dest) = bl->ksize;
#line 565
  dest += sizeof(u_int32_t );
#line 565
  *((u_int32_t *)dest) = r->pgno;
#line 565
  dest += sizeof(u_int32_t );
#line 565
  *((u_char *)dest) = (u_char )0;
#line 565
  dest += sizeof(u_char );
#line 566
  memmove((void *)dest, (void const   *)(bl->bytes), (size_t )bl->ksize);
  }
#line 572
  if ((int )bl->flags & 2) {
    {
#line 572
    tmp___3 = bt_preserve___0(t, *((u_int32_t *)(bl->bytes)));
    }
#line 572
    if (tmp___3 == -1) {
#line 574
      return (-1);
    }
  }
#line 575
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 577
  bi = (BINTERNAL *)((char *)r + (int )r->linp[0]);
#line 578
  nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bi->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 579
  tmp___4 = (u_int16_t )((u_int32_t )h->upper - nbytes);
#line 579
  h->upper = tmp___4;
#line 579
  h->linp[1] = tmp___4;
#line 580
  dest = (char *)h + (int )h->upper;
#line 581
  memmove((void *)dest, (void const   *)bi, (size_t )nbytes);
#line 582
  ((BINTERNAL *)dest)->pgno = r->pgno;
  }
#line 583
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 585
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 589
  h->lower = (u_int16_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t )) + 2UL * sizeof(u_int16_t ));
#line 592
  h->flags &= 4294967264U;
#line 593
  h->flags |= 1U;
#line 594
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 596
  return (0);
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static PAGE *bt_psplit___0(BTREE *t , PAGE *h , PAGE *l , PAGE *r , u_int16_t *pskip ,
                           size_t ilen ) 
{ 
  BINTERNAL *bi ;
  BLEAF *bl ;
  CURSOR *c ;
  RLEAF *rl ;
  PAGE *rval ;
  void *src ;
  u_int16_t full ;
  u_int16_t half ;
  u_int16_t nxt ;
  u_int16_t off ;
  u_int16_t skip ;
  u_int16_t top ;
  u_int16_t used ;
  u_int32_t nbytes ;
  int bigkeycnt ;
  int isbigkey ;
  u_int16_t tmp___1 ;
  u_int16_t tmp___2 ;

  {
#line 636
  bigkeycnt = 0;
#line 637
  skip = *pskip;
#line 638
  full = (u_int16_t )((unsigned long )t->bt_psize - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t )));
#line 639
  half = (u_int16_t )((int )full / 2);
#line 640
  used = (u_int16_t )0;
#line 641
  off = (u_int16_t )0;
#line 641
  nxt = off;
#line 641
  top = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! ((int )nxt < (int )top)) {
#line 641
      goto while_break;
    }
#line 642
    if ((int )skip == (int )off) {
#line 643
      nbytes = (u_int32_t )ilen;
#line 644
      isbigkey = 0;
    } else {
      {
#line 647
      if ((h->flags & 31U) == 1U) {
#line 647
        goto case_1;
      }
#line 652
      if ((h->flags & 31U) == 2U) {
#line 652
        goto case_2;
      }
#line 657
      if ((h->flags & 31U) == 8U) {
#line 657
        goto case_8;
      }
#line 662
      if ((h->flags & 31U) == 16U) {
#line 662
        goto case_16;
      }
#line 667
      goto switch_default;
      case_1: /* CIL Label */ 
#line 648
      bi = (BINTERNAL *)((char *)h + (int )h->linp[nxt]);
#line 648
      src = (void *)bi;
#line 649
      nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bi->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 650
      isbigkey = (int )bi->flags & 2;
#line 651
      goto switch_break;
      case_2: /* CIL Label */ 
#line 653
      bl = (BLEAF *)((char *)h + (int )h->linp[nxt]);
#line 653
      src = (void *)bl;
#line 654
      nbytes = (u_int32_t )(((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bl->ksize) + (unsigned long )bl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 655
      isbigkey = (int )bl->flags & 2;
#line 656
      goto switch_break;
      case_8: /* CIL Label */ 
#line 658
      src = (void *)((RINTERNAL *)((char *)h + (int )h->linp[nxt]));
#line 659
      nbytes = (u_int32_t )((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 660
      isbigkey = 0;
#line 661
      goto switch_break;
      case_16: /* CIL Label */ 
#line 663
      rl = (RLEAF *)((char *)h + (int )h->linp[nxt]);
#line 663
      src = (void *)rl;
#line 664
      nbytes = (u_int32_t )(((((sizeof(u_int32_t ) + sizeof(u_char )) + (unsigned long )rl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 665
      isbigkey = 0;
#line 666
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 668
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 677
    if ((int )skip <= (int )off) {
#line 677
      if ((unsigned long )((u_int32_t )used + nbytes) + sizeof(u_int16_t ) >= (unsigned long )full) {
#line 679
        off = (u_int16_t )((int )off - 1);
#line 680
        goto while_break;
      } else {
#line 677
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 677
    if ((int )nxt == (int )top - 1) {
#line 679
      off = (u_int16_t )((int )off - 1);
#line 680
      goto while_break;
    }
#line 684
    if ((int )skip != (int )off) {
      {
#line 685
      nxt = (u_int16_t )((int )nxt + 1);
#line 687
      tmp___1 = (u_int16_t )((u_int32_t )l->upper - nbytes);
#line 687
      l->upper = tmp___1;
#line 687
      l->linp[off] = tmp___1;
#line 688
      memmove((void *)((char *)l + (int )l->upper), (void const   *)src, (size_t )nbytes);
      }
    }
#line 691
    used = (u_int16_t )((unsigned long )used + ((unsigned long )nbytes + sizeof(u_int16_t )));
#line 692
    if ((int )used >= (int )half) {
#line 693
      if (! isbigkey) {
#line 694
        goto while_break;
      } else
#line 693
      if (bigkeycnt == 3) {
#line 694
        goto while_break;
      } else {
#line 696
        bigkeycnt ++;
      }
    }
#line 641
    off = (u_int16_t )((int )off + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  l->lower = (u_int16_t )((unsigned long )l->lower + (unsigned long )((int )off + 1) * sizeof(u_int16_t ));
#line 713
  c = & t->bt_cursor;
#line 714
  if ((int )c->flags & 8) {
#line 714
    if (c->pg.pgno == h->pgno) {
#line 715
      if ((int )c->pg.index >= (int )skip) {
#line 716
        c->pg.index = (u_int16_t )((int )c->pg.index + 1);
      }
#line 717
      if ((int )c->pg.index < (int )nxt) {
#line 718
        c->pg.pgno = l->pgno;
      } else {
#line 720
        c->pg.pgno = r->pgno;
#line 721
        c->pg.index = (u_int16_t )((int )c->pg.index - (int )nxt);
      }
    }
  }
#line 730
  if ((int )skip <= (int )off) {
#line 731
    skip = (u_int16_t )0;
#line 732
    rval = l;
  } else {
#line 734
    rval = r;
#line 735
    *pskip = (u_int16_t )((int )*pskip - (int )nxt);
  }
#line 738
  off = (u_int16_t )0;
  {
#line 738
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 738
    if (! ((int )nxt < (int )top)) {
#line 738
      goto while_break___0;
    }
#line 739
    if ((int )skip == (int )nxt) {
#line 740
      off = (u_int16_t )((int )off + 1);
#line 741
      skip = (u_int16_t )0;
    }
    {
#line 744
    if ((h->flags & 31U) == 1U) {
#line 744
      goto case_1___0;
    }
#line 748
    if ((h->flags & 31U) == 2U) {
#line 748
      goto case_2___0;
    }
#line 752
    if ((h->flags & 31U) == 8U) {
#line 752
      goto case_8___0;
    }
#line 756
    if ((h->flags & 31U) == 16U) {
#line 756
      goto case_16___0;
    }
#line 760
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 745
    bi = (BINTERNAL *)((char *)h + (int )h->linp[nxt]);
#line 745
    src = (void *)bi;
#line 746
    nbytes = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bi->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 747
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 749
    bl = (BLEAF *)((char *)h + (int )h->linp[nxt]);
#line 749
    src = (void *)bl;
#line 750
    nbytes = (u_int32_t )(((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bl->ksize) + (unsigned long )bl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 751
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 753
    src = (void *)((RINTERNAL *)((char *)h + (int )h->linp[nxt]));
#line 754
    nbytes = (u_int32_t )((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 755
    goto switch_break___0;
    case_16___0: /* CIL Label */ 
#line 757
    rl = (RLEAF *)((char *)h + (int )h->linp[nxt]);
#line 757
    src = (void *)rl;
#line 758
    nbytes = (u_int32_t )(((((sizeof(u_int32_t ) + sizeof(u_char )) + (unsigned long )rl->dsize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 759
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 761
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 763
    nxt = (u_int16_t )((int )nxt + 1);
#line 764
    tmp___2 = (u_int16_t )((u_int32_t )r->upper - nbytes);
#line 764
    r->upper = tmp___2;
#line 764
    r->linp[off] = tmp___2;
#line 765
    memmove((void *)((char *)r + (int )r->upper), (void const   *)src, (size_t )nbytes);
#line 738
    off = (u_int16_t )((int )off + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 767
  r->lower = (u_int16_t )((unsigned long )r->lower + (unsigned long )off * sizeof(u_int16_t ));
#line 770
  if ((int )skip == (int )top) {
#line 771
    r->lower = (u_int16_t )((unsigned long )r->lower + sizeof(u_int16_t ));
  }
#line 773
  return (rval);
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static int bt_preserve___0(BTREE *t , u_int32_t pg ) 
{ 
  PAGE *h ;
  void *tmp___1 ;

  {
  {
#line 798
  tmp___1 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 798
  h = (PAGE *)tmp___1;
  }
#line 798
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 799
    return (-1);
  }
  {
#line 800
  h->flags |= 32U;
#line 801
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 802
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_split.c"
static u_int32_t rec_total___0(PAGE *h ) 
{ 
  u_int32_t recs ;
  u_int16_t nxt ;
  u_int16_t top ;

  {
#line 826
  recs = (u_int32_t )0;
#line 826
  nxt = (u_int16_t )0;
#line 826
  top = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! ((int )nxt < (int )top)) {
#line 826
      goto while_break;
    }
#line 827
    recs += ((RINTERNAL *)((char *)h + (int )h->linp[nxt]))->nrecs;
#line 826
    nxt = (u_int16_t )((int )nxt + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  return (recs);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_delete.c"
static int rec_rdelete___0(BTREE *t , u_int32_t nrec ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/recno/rec_delete.c"
static int rec_rdelete___0(BTREE *t , u_int32_t nrec ) 
{ 
  EPG *e ;
  PAGE *h ;
  int status ;

  {
  {
#line 129
  e = __rec_search(t, nrec, (enum SRCHOP )0);
  }
#line 129
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 130
    return (-1);
  }
  {
#line 133
  h = e->page;
#line 134
  status = __rec_dleaf(t, h, (u_int32_t )e->index);
  }
#line 135
  if (status != 0) {
    {
#line 136
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 137
    return (status);
  }
  {
#line 139
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 140
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_func.c"
static u_int32_t hash4___0(void const   *keyarg , size_t len ) ;
#line 165 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_func.c"
static u_int32_t hash4___0(void const   *keyarg , size_t len ) 
{ 
  register u_char const   *key ;
  register size_t loop ;
  register u_int32_t h ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char const   *tmp___3 ;
  u_char const   *tmp___4 ;
  u_char const   *tmp___5 ;
  u_char const   *tmp___6 ;
  u_char const   *tmp___7 ;
  u_char const   *tmp___8 ;

  {
#line 178
  h = (u_int32_t )0;
#line 179
  key = (u_char const   *)keyarg;
#line 180
  if (len > 0UL) {
#line 181
    loop = ((len + 8UL) - 1UL) >> 3;
    {
#line 184
    if ((len & 7UL) == 0UL) {
#line 184
      goto case_0;
    }
#line 188
    if ((len & 7UL) == 7UL) {
#line 188
      goto case_7;
    }
#line 191
    if ((len & 7UL) == 6UL) {
#line 191
      goto case_6;
    }
#line 194
    if ((len & 7UL) == 5UL) {
#line 194
      goto case_5;
    }
#line 197
    if ((len & 7UL) == 4UL) {
#line 197
      goto case_4;
    }
#line 200
    if ((len & 7UL) == 3UL) {
#line 200
      goto case_3;
    }
#line 203
    if ((len & 7UL) == 2UL) {
#line 203
      goto case_2;
    }
#line 206
    if ((len & 7UL) == 1UL) {
#line 206
      goto case_1;
    }
#line 183
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 186
      tmp___1 = key;
#line 186
      key ++;
#line 186
      h = ((h << 5) + h) + (u_int32_t )*tmp___1;
      case_7: /* CIL Label */ 
#line 189
      tmp___2 = key;
#line 189
      key ++;
#line 189
      h = ((h << 5) + h) + (u_int32_t )*tmp___2;
      case_6: /* CIL Label */ 
#line 192
      tmp___3 = key;
#line 192
      key ++;
#line 192
      h = ((h << 5) + h) + (u_int32_t )*tmp___3;
      case_5: /* CIL Label */ 
#line 195
      tmp___4 = key;
#line 195
      key ++;
#line 195
      h = ((h << 5) + h) + (u_int32_t )*tmp___4;
      case_4: /* CIL Label */ 
#line 198
      tmp___5 = key;
#line 198
      key ++;
#line 198
      h = ((h << 5) + h) + (u_int32_t )*tmp___5;
      case_3: /* CIL Label */ 
#line 201
      tmp___6 = key;
#line 201
      key ++;
#line 201
      h = ((h << 5) + h) + (u_int32_t )*tmp___6;
      case_2: /* CIL Label */ 
#line 204
      tmp___7 = key;
#line 204
      key ++;
#line 204
      h = ((h << 5) + h) + (u_int32_t )*tmp___7;
      case_1: /* CIL Label */ 
#line 207
      tmp___8 = key;
#line 207
      key ++;
#line 207
      h = ((h << 5) + h) + (u_int32_t )*tmp___8;
#line 185
      loop --;
#line 185
      if (! loop) {
#line 185
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 211
  return (h);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_buf.c"
static BUFHEAD *newbuf___0(HTAB *hashp , u_int32_t addr , BUFHEAD *prev_bp ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash_buf.c"
static BUFHEAD *newbuf___0(HTAB *hashp , u_int32_t addr , BUFHEAD *prev_bp ) 
{ 
  register BUFHEAD *bp ;
  register BUFHEAD *xbp ;
  register BUFHEAD *next_xbp ;
  SEGMENT segp ;
  int segment_ndx ;
  u_int16_t oaddr ;
  u_int16_t *shortp ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 172
  oaddr = (u_int16_t )0;
#line 173
  bp = hashp->bufhead.prev;
#line 178
  if (hashp->nbufs) {
#line 178
    goto _L___0;
  } else
#line 178
  if ((int )bp->flags & 8) {
    _L___0: /* CIL Label */ 
    {
#line 180
    tmp___1 = malloc(sizeof(BUFHEAD ));
#line 180
    bp = (BUFHEAD *)tmp___1;
    }
#line 180
    if ((unsigned long )bp == (unsigned long )((void *)0)) {
#line 181
      return ((BUFHEAD *)((void *)0));
    }
    {
#line 185
    tmp___3 = malloc((size_t )hashp->hdr.bsize);
#line 185
    tmp___2 = (char *)tmp___3;
#line 185
    bp->page = tmp___2;
    }
#line 185
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 186
      free((void *)bp);
      }
#line 187
      return ((BUFHEAD *)((void *)0));
    }
#line 192
    if (hashp->nbufs) {
#line 193
      (hashp->nbufs) --;
    }
  } else {
#line 196
    (bp->prev)->next = bp->next;
#line 196
    (bp->next)->prev = bp->prev;
#line 201
    if (bp->addr != 0U) {
#line 201
      goto _L;
    } else
#line 201
    if ((int )bp->flags & 4) {
      _L: /* CIL Label */ 
#line 206
      shortp = (u_int16_t *)bp->page;
#line 207
      if (*(shortp + 0)) {
#line 208
        oaddr = *(shortp + ((int )*(shortp + 0) - 1));
      }
#line 209
      if ((int )bp->flags & 1) {
        {
#line 209
        tmp___4 = __put_page(hashp, bp->page, bp->addr, (int )bp->flags & 4, 0);
        }
#line 209
        if (tmp___4) {
#line 211
          return ((BUFHEAD *)((void *)0));
        }
      }
#line 220
      if ((int )bp->flags & 4) {
#line 221
        segment_ndx = (int )(bp->addr & (unsigned int )(hashp->hdr.ssize - 1));
#line 222
        segp = *(hashp->dir + (bp->addr >> hashp->hdr.sshift));
#line 227
        if (hashp->new_file) {
#line 227
          if ((int )bp->flags & 1) {
#line 230
            *(segp + segment_ndx) = (BUFHEAD *)2;
          } else
#line 227
          if ((u_int32_t )((ptrdiff_t )*(segp + segment_ndx)) & 2U) {
#line 230
            *(segp + segment_ndx) = (BUFHEAD *)2;
          } else {
#line 232
            *(segp + segment_ndx) = (BUFHEAD *)((void *)0);
          }
        } else {
#line 232
          *(segp + segment_ndx) = (BUFHEAD *)((void *)0);
        }
      }
#line 239
      xbp = bp;
      {
#line 239
      while (1) {
        while_continue: /* CIL Label */ ;
#line 239
        if (! xbp->ovfl) {
#line 239
          goto while_break;
        }
#line 240
        next_xbp = xbp->ovfl;
#line 241
        xbp->ovfl = (BUFHEAD *)0;
#line 242
        xbp = next_xbp;
#line 245
        if ((int )xbp->flags & 4) {
#line 247
          goto while_break;
        } else
#line 245
        if ((u_int32_t )oaddr != xbp->addr) {
#line 247
          goto while_break;
        }
#line 249
        shortp = (u_int16_t *)xbp->page;
#line 250
        if (*(shortp + 0)) {
#line 252
          oaddr = *(shortp + ((int )*(shortp + 0) - 1));
        }
#line 253
        if ((int )xbp->flags & 1) {
          {
#line 253
          tmp___5 = __put_page(hashp, xbp->page, xbp->addr, 0, 0);
          }
#line 253
          if (tmp___5) {
#line 255
            return ((BUFHEAD *)((void *)0));
          }
        }
#line 256
        xbp->addr = (u_int32_t )0;
#line 257
        xbp->flags = (char)0;
#line 258
        (xbp->prev)->next = xbp->next;
#line 258
        (xbp->next)->prev = xbp->prev;
#line 259
        xbp->next = (hashp->bufhead.prev)->next;
#line 259
        xbp->prev = hashp->bufhead.prev;
#line 259
        (hashp->bufhead.prev)->next = xbp;
#line 259
        (xbp->next)->prev = xbp;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 265
  bp->addr = addr;
#line 270
  bp->ovfl = (BUFHEAD *)((void *)0);
#line 271
  if (prev_bp) {
#line 281
    prev_bp->ovfl = bp;
#line 282
    bp->flags = (char)0;
  } else {
#line 284
    bp->flags = (char)4;
  }
#line 285
  bp->next = hashp->bufhead.next;
#line 285
  bp->prev = & hashp->bufhead;
#line 285
  hashp->bufhead.next = bp;
#line 285
  (bp->next)->prev = bp;
#line 286
  return (bp);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
static int __bt_first___0(BTREE *t , DBT const   *key , EPG *erval , int *exactp ) ;
#line 52
static int __bt_seqadv___0(BTREE *t , EPG *ep , int flags ) ;
#line 53
static int __bt_seqset___0(BTREE *t , EPG *ep , DBT *key , int flags ) ;
#line 151 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
static int __bt_seqset___0(BTREE *t , EPG *ep , DBT *key , int flags ) 
{ 
  PAGE *h ;
  u_int32_t pg ;
  int exact ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 168
  if (flags == 1) {
#line 168
    goto case_1;
  }
#line 179
  if (flags == 7) {
#line 179
    goto case_7;
  }
#line 179
  if (flags == 3) {
#line 179
    goto case_7;
  }
#line 200
  if (flags == 9) {
#line 200
    goto case_9;
  }
#line 200
  if (flags == 6) {
#line 200
    goto case_9;
  }
#line 167
  goto switch_break;
  case_1: /* CIL Label */ 
#line 173
  if ((unsigned long )key->data == (unsigned long )((void *)0)) {
    {
#line 174
    tmp___1 = __errno_location();
#line 174
    *tmp___1 = 22;
    }
#line 175
    return (-1);
  } else
#line 173
  if (key->size == 0UL) {
    {
#line 174
    tmp___1 = __errno_location();
#line 174
    *tmp___1 = 22;
    }
#line 175
    return (-1);
  }
  {
#line 177
  tmp___2 = __bt_first___0(t, (DBT const   *)key, ep, & exact);
  }
#line 177
  return (tmp___2);
  case_7: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 181
  pg = (u_int32_t )1;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 182
    tmp___3 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 182
    h = (PAGE *)tmp___3;
    }
#line 182
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 183
      return (-1);
    }
#line 186
    if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 0UL) {
      {
#line 187
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
#line 188
      return (1);
    }
#line 191
    if (h->flags & 18U) {
#line 192
      goto while_break;
    }
    {
#line 193
    pg = ((BINTERNAL *)((char *)h + (int )h->linp[0]))->pgno;
#line 194
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  ep->page = h;
#line 197
  ep->index = (u_int16_t )0;
#line 198
  goto switch_break;
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 202
  pg = (u_int32_t )1;
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 203
    tmp___4 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 203
    h = (PAGE *)tmp___4;
    }
#line 203
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 204
      return (-1);
    }
#line 207
    if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 0UL) {
      {
#line 208
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
#line 209
      return (1);
    }
#line 212
    if (h->flags & 18U) {
#line 213
      goto while_break___0;
    }
    {
#line 214
    pg = ((BINTERNAL *)((char *)h + (int )h->linp[((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL]))->pgno;
#line 215
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 218
  ep->page = h;
#line 219
  ep->index = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
#line 220
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 222
  return (0);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
static int __bt_seqadv___0(BTREE *t , EPG *ep , int flags ) 
{ 
  CURSOR *c ;
  PAGE *h ;
  u_int16_t index ;
  u_int32_t pg ;
  int exact ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 255
  c = & t->bt_cursor;
#line 265
  if ((int )c->flags & 1) {
    {
#line 266
    tmp___1 = __bt_first___0(t, (DBT const   *)(& c->key), ep, & exact);
    }
#line 266
    return (tmp___1);
  }
  {
#line 269
  tmp___2 = __mpool_get(t->bt_mp, c->pg.pgno, (u_int )0);
#line 269
  h = (PAGE *)tmp___2;
  }
#line 269
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 270
    return (-1);
  }
  {
#line 277
  if (flags == 7) {
#line 277
    goto case_7;
  }
#line 296
  if (flags == 9) {
#line 296
    goto case_9;
  }
#line 276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 283
  if ((int )c->flags & 2) {
#line 284
    goto usecurrent;
  }
#line 285
  index = c->pg.index;
#line 286
  index = (u_int16_t )((int )index + 1);
#line 286
  if ((unsigned long )index == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
    {
#line 287
    pg = h->nextpg;
#line 288
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 289
    if (pg == 0U) {
#line 290
      return (1);
    }
    {
#line 291
    tmp___3 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 291
    h = (PAGE *)tmp___3;
    }
#line 291
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 292
      return (-1);
    }
#line 293
    index = (u_int16_t )0;
  }
#line 295
  goto switch_break;
  case_9: /* CIL Label */ 
#line 302
  if ((int )c->flags & 4) {
    usecurrent: 
#line 303
    c->flags = (u_int8_t )((int )c->flags & -7);
#line 304
    ep->page = h;
#line 305
    ep->index = c->pg.index;
#line 306
    return (0);
  }
#line 308
  index = c->pg.index;
#line 309
  if ((int )index == 0) {
    {
#line 310
    pg = h->prevpg;
#line 311
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 312
    if (pg == 0U) {
#line 313
      return (1);
    }
    {
#line 314
    tmp___4 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 314
    h = (PAGE *)tmp___4;
    }
#line 314
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 315
      return (-1);
    }
#line 316
    index = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
  } else {
#line 318
    index = (u_int16_t )((int )index - 1);
  }
#line 319
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 322
  ep->page = h;
#line 323
  ep->index = index;
#line 324
  return (0);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_seq.c"
static int __bt_first___0(BTREE *t , DBT const   *key , EPG *erval , int *exactp ) 
{ 
  PAGE *h ;
  EPG *ep ;
  EPG save ;
  u_int32_t pg ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 360
  ep = __bt_search(t, key, exactp);
  }
#line 360
  if ((unsigned long )ep == (unsigned long )((void *)0)) {
#line 361
    return (1);
  }
#line 362
  if (*exactp) {
#line 363
    if (t->flags & 32U) {
#line 364
      *erval = *ep;
#line 365
      return (0);
    }
#line 373
    save = *ep;
#line 374
    h = ep->page;
    {
#line 375
    while (1) {
      while_continue: /* CIL Label */ ;
#line 376
      if ((save.page)->pgno != (ep->page)->pgno) {
        {
#line 377
        __mpool_put(t->bt_mp, (void *)save.page, (u_int )0);
#line 378
        save = *ep;
        }
      } else {
#line 380
        save.index = ep->index;
      }
#line 387
      if ((int )ep->index == 0) {
#line 388
        if (h->prevpg == 0U) {
#line 389
          goto while_break;
        }
#line 390
        if (h->pgno != (save.page)->pgno) {
          {
#line 391
          __mpool_put(t->bt_mp, (void *)h, (u_int )0);
          }
        }
        {
#line 392
        tmp___1 = __mpool_get(t->bt_mp, h->prevpg, (u_int )0);
#line 392
        h = (PAGE *)tmp___1;
        }
#line 392
        if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 394
          if (h->pgno == (save.page)->pgno) {
            {
#line 395
            __mpool_put(t->bt_mp, (void *)save.page, (u_int )0);
            }
          }
#line 397
          return (-1);
        }
#line 399
        ep->page = h;
#line 400
        ep->index = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ));
      }
      {
#line 402
      ep->index = (u_int16_t )((int )ep->index - 1);
#line 375
      tmp___2 = __bt_cmp(t, key, ep);
      }
#line 375
      if (! (tmp___2 == 0)) {
#line 375
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 410
    if (h->pgno != (save.page)->pgno) {
      {
#line 411
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
    }
#line 413
    *erval = save;
#line 414
    return (0);
  }
#line 418
  if ((unsigned long )ep->index == ((unsigned long )(ep->page)->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
    {
#line 419
    h = ep->page;
#line 420
    pg = h->nextpg;
#line 421
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
    }
#line 422
    if (pg == 0U) {
#line 423
      return (1);
    }
    {
#line 424
    tmp___3 = __mpool_get(t->bt_mp, pg, (u_int )0);
#line 424
    h = (PAGE *)tmp___3;
    }
#line 424
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 425
      return (-1);
    }
#line 426
    ep->index = (u_int16_t )0;
#line 427
    ep->page = h;
  }
#line 429
  *erval = *ep;
#line 430
  return (0);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_search.c"
static int __bt_snext___0(BTREE *t , PAGE *h , DBT const   *key , int *exactp ) ;
#line 49
static int __bt_sprev___0(BTREE *t , PAGE *h , DBT const   *key , int *exactp ) ;
#line 150 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_search.c"
static int __bt_snext___0(BTREE *t , PAGE *h , DBT const   *key , int *exactp ) 
{ 
  EPG e ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 163
  tmp___1 = __mpool_get(t->bt_mp, h->nextpg, (u_int )0);
#line 163
  e.page = (PAGE *)tmp___1;
  }
#line 163
  if ((unsigned long )e.page == (unsigned long )((void *)0)) {
#line 164
    return (0);
  }
  {
#line 165
  e.index = (u_int16_t )0;
#line 166
  tmp___2 = __bt_cmp(t, key, & e);
  }
#line 166
  if (tmp___2 == 0) {
    {
#line 167
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 168
    t->bt_cur = e;
#line 169
    *exactp = 1;
    }
#line 170
    return (1);
  }
  {
#line 172
  __mpool_put(t->bt_mp, (void *)e.page, (u_int )0);
  }
#line 173
  return (0);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_search.c"
static int __bt_sprev___0(BTREE *t , PAGE *h , DBT const   *key , int *exactp ) 
{ 
  EPG e ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 202
  tmp___1 = __mpool_get(t->bt_mp, h->prevpg, (u_int )0);
#line 202
  e.page = (PAGE *)tmp___1;
  }
#line 202
  if ((unsigned long )e.page == (unsigned long )((void *)0)) {
#line 203
    return (0);
  }
  {
#line 204
  e.index = (u_int16_t )(((unsigned long )(e.page)->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
#line 205
  tmp___2 = __bt_cmp(t, key, & e);
  }
#line 205
  if (tmp___2 == 0) {
    {
#line 206
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 207
    t->bt_cur = e;
#line 208
    *exactp = 1;
    }
#line 209
    return (1);
  }
  {
#line 211
  __mpool_put(t->bt_mp, (void *)e.page, (u_int )0);
  }
#line 212
  return (0);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_conv.c"
static void mswap___0(PAGE *pg ) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_conv.c"
static void mswap___0(PAGE *pg ) 
{ 
  char *p ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int32_t _tmp___4 ;

  {
#line 208
  p = (char *)pg;
#line 209
  _tmp = *((u_int32_t *)p);
#line 209
  *(p + 0) = *((char *)(& _tmp) + 3);
#line 209
  *(p + 1) = *((char *)(& _tmp) + 2);
#line 209
  *(p + 2) = *((char *)(& _tmp) + 1);
#line 209
  *(p + 3) = *((char *)(& _tmp) + 0);
#line 210
  p += sizeof(u_int32_t );
#line 211
  _tmp___0 = *((u_int32_t *)p);
#line 211
  *(p + 0) = *((char *)(& _tmp___0) + 3);
#line 211
  *(p + 1) = *((char *)(& _tmp___0) + 2);
#line 211
  *(p + 2) = *((char *)(& _tmp___0) + 1);
#line 211
  *(p + 3) = *((char *)(& _tmp___0) + 0);
#line 212
  p += sizeof(u_int32_t );
#line 213
  _tmp___1 = *((u_int32_t *)p);
#line 213
  *(p + 0) = *((char *)(& _tmp___1) + 3);
#line 213
  *(p + 1) = *((char *)(& _tmp___1) + 2);
#line 213
  *(p + 2) = *((char *)(& _tmp___1) + 1);
#line 213
  *(p + 3) = *((char *)(& _tmp___1) + 0);
#line 214
  p += sizeof(u_int32_t );
#line 215
  _tmp___2 = *((u_int32_t *)p);
#line 215
  *(p + 0) = *((char *)(& _tmp___2) + 3);
#line 215
  *(p + 1) = *((char *)(& _tmp___2) + 2);
#line 215
  *(p + 2) = *((char *)(& _tmp___2) + 1);
#line 215
  *(p + 3) = *((char *)(& _tmp___2) + 0);
#line 216
  p += sizeof(u_int32_t );
#line 217
  _tmp___3 = *((u_int32_t *)p);
#line 217
  *(p + 0) = *((char *)(& _tmp___3) + 3);
#line 217
  *(p + 1) = *((char *)(& _tmp___3) + 2);
#line 217
  *(p + 2) = *((char *)(& _tmp___3) + 1);
#line 217
  *(p + 3) = *((char *)(& _tmp___3) + 0);
#line 218
  p += sizeof(u_int32_t );
#line 219
  _tmp___4 = *((u_int32_t *)p);
#line 219
  *(p + 0) = *((char *)(& _tmp___4) + 3);
#line 219
  *(p + 1) = *((char *)(& _tmp___4) + 2);
#line 219
  *(p + 2) = *((char *)(& _tmp___4) + 1);
#line 219
  *(p + 3) = *((char *)(& _tmp___4) + 0);
#line 220
  p += sizeof(u_int32_t );
#line 221
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_bdelete___0(BTREE *t , DBT const   *key ) ;
#line 51
static int __bt_curdel___0(BTREE *t , DBT const   *key , PAGE *h , u_int index___0 ) ;
#line 52
static int __bt_pdelete___0(BTREE *t , PAGE *h ) ;
#line 53
static int __bt_relink___0(BTREE *t , PAGE *h ) ;
#line 54
static int __bt_stkacq___0(BTREE *t , PAGE **hp , CURSOR *c ) ;
#line 143 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_stkacq___0(BTREE *t , PAGE **hp , CURSOR *c ) 
{ 
  BINTERNAL *bi ;
  EPG *e ;
  EPGNO *parent ;
  PAGE *h ;
  u_int16_t index___0 ;
  u_int32_t pgno ;
  u_int32_t nextpg ;
  u_int32_t prevpg ;
  int exact ;
  int level ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  PAGE *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 162
  h = *hp;
#line 163
  __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 164
  e = __bt_search(t, (DBT const   *)(& c->key), & exact);
  }
#line 164
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 165
    return (1);
  }
#line 166
  h = e->page;
#line 169
  if (h->pgno == c->pg.pgno) {
#line 170
    goto ret;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (h->pgno != c->pg.pgno)) {
#line 178
      goto while_break;
    }
#line 179
    nextpg = h->nextpg;
#line 179
    if (nextpg == 0U) {
#line 180
      goto while_break;
    }
    {
#line 181
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 184
    level = 0;
    }
    {
#line 184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 184
      if ((unsigned long )t->bt_sp == (unsigned long )(t->bt_stack)) {
#line 184
        parent = (EPGNO *)((void *)0);
      } else {
#line 184
        (t->bt_sp) --;
#line 184
        parent = t->bt_sp;
      }
#line 184
      if (! ((unsigned long )parent != (unsigned long )((void *)0))) {
#line 184
        goto while_break___0;
      }
      {
#line 186
      tmp___1 = __mpool_get(t->bt_mp, parent->pgno, (u_int )0);
#line 186
      h = (PAGE *)tmp___1;
      }
#line 186
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 187
        return (1);
      }
#line 190
      if ((unsigned long )parent->index != ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL) {
#line 191
        index___0 = (u_int16_t )((int )parent->index + 1);
#line 192
        (t->bt_sp)->pgno = h->pgno;
#line 192
        (t->bt_sp)->index = index___0;
#line 192
        (t->bt_sp) ++;
#line 193
        goto while_break___0;
      }
      {
#line 195
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 184
      level ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 199
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 199
      tmp___3 = level;
#line 199
      level --;
#line 199
      if (! tmp___3) {
#line 199
        goto while_break___1;
      }
      {
#line 201
      bi = (BINTERNAL *)((char *)h + (int )h->linp[index___0]);
#line 202
      pgno = bi->pgno;
#line 203
      (t->bt_sp)->pgno = pgno;
#line 203
      (t->bt_sp)->index = (u_int16_t )0;
#line 203
      (t->bt_sp) ++;
#line 206
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 209
      tmp___2 = __mpool_get(t->bt_mp, pgno, (u_int )0);
#line 209
      h = (PAGE *)tmp___2;
      }
#line 209
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 210
        return (1);
      }
#line 211
      index___0 = (u_int16_t )0;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 213
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 214
    tmp___4 = __mpool_get(t->bt_mp, nextpg, (u_int )0);
#line 214
    h = (PAGE *)tmp___4;
    }
#line 214
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 215
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if (h->pgno == c->pg.pgno) {
#line 219
    goto ret;
  }
  {
#line 222
  __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 223
  e = __bt_search(t, (DBT const   *)(& c->key), & exact);
  }
#line 223
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 224
    return (1);
  }
#line 225
  h = e->page;
  {
#line 233
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 233
    if (! (h->pgno != c->pg.pgno)) {
#line 233
      goto while_break___2;
    }
#line 234
    prevpg = h->prevpg;
#line 234
    if (prevpg == 0U) {
#line 235
      goto while_break___2;
    }
    {
#line 236
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 239
    level = 0;
    }
    {
#line 239
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 239
      if ((unsigned long )t->bt_sp == (unsigned long )(t->bt_stack)) {
#line 239
        parent = (EPGNO *)((void *)0);
      } else {
#line 239
        (t->bt_sp) --;
#line 239
        parent = t->bt_sp;
      }
#line 239
      if (! ((unsigned long )parent != (unsigned long )((void *)0))) {
#line 239
        goto while_break___3;
      }
      {
#line 241
      tmp___5 = __mpool_get(t->bt_mp, parent->pgno, (u_int )0);
#line 241
      h = (PAGE *)tmp___5;
      }
#line 241
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 242
        return (1);
      }
#line 245
      if ((int )parent->index != 0) {
#line 246
        index___0 = (u_int16_t )((int )parent->index - 1);
#line 247
        (t->bt_sp)->pgno = h->pgno;
#line 247
        (t->bt_sp)->index = index___0;
#line 247
        (t->bt_sp) ++;
#line 248
        goto while_break___3;
      }
      {
#line 250
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 239
      level ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 254
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 254
      tmp___7 = level;
#line 254
      level --;
#line 254
      if (! tmp___7) {
#line 254
        goto while_break___4;
      }
      {
#line 256
      bi = (BINTERNAL *)((char *)h + (int )h->linp[index___0]);
#line 257
      pgno = bi->pgno;
#line 260
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 263
      tmp___6 = __mpool_get(t->bt_mp, pgno, (u_int )0);
#line 263
      h = (PAGE *)tmp___6;
      }
#line 263
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 264
        return (1);
      }
#line 266
      index___0 = (u_int16_t )(((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
#line 267
      (t->bt_sp)->pgno = pgno;
#line 267
      (t->bt_sp)->index = index___0;
#line 267
      (t->bt_sp) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 269
    __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 270
    tmp___8 = __mpool_get(t->bt_mp, prevpg, (u_int )0);
#line 270
    h = (PAGE *)tmp___8;
    }
#line 270
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 271
      return (1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  ret: 
  {
#line 275
  __mpool_put(t->bt_mp, (void *)h, (u_int )0);
#line 276
  tmp___10 = __mpool_get(t->bt_mp, c->pg.pgno, (u_int )0);
#line 276
  tmp___9 = (PAGE *)tmp___10;
#line 276
  *hp = tmp___9;
  }
#line 276
  return ((unsigned long )tmp___9 == (unsigned long )((void *)0));
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_bdelete___0(BTREE *t , DBT const   *key ) 
{ 
  EPG *e ;
  PAGE *h ;
  int deleted ;
  int exact ;
  int redo ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  u_int16_t tmp___8 ;
  int tmp___9 ;

  {
#line 299
  deleted = 0;
  loop: 
  {
#line 302
  e = __bt_search(t, key, & exact);
  }
#line 302
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 303
    if (deleted) {
#line 303
      tmp___1 = 0;
    } else {
#line 303
      tmp___1 = -1;
    }
#line 303
    return (tmp___1);
  }
#line 304
  if (! exact) {
    {
#line 305
    __mpool_put(t->bt_mp, (void *)e->page, (u_int )0);
    }
#line 306
    if (deleted) {
#line 306
      tmp___2 = 0;
    } else {
#line 306
      tmp___2 = 1;
    }
#line 306
    return (tmp___2);
  }
#line 314
  redo = 0;
#line 315
  h = e->page;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 317
    tmp___3 = __bt_dleaf(t, key, h, (u_int )e->index);
    }
#line 317
    if (tmp___3) {
      {
#line 318
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
#line 319
      return (-1);
    }
#line 321
    if (t->flags & 32U) {
#line 322
      if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 0UL) {
        {
#line 323
        tmp___4 = __bt_pdelete___0(t, h);
        }
#line 323
        if (tmp___4) {
#line 324
          return (-1);
        }
      } else {
        {
#line 326
        __mpool_put(t->bt_mp, (void *)h, (u_int )1);
        }
      }
#line 327
      return (0);
    }
#line 329
    deleted = 1;
#line 316
    if ((unsigned long )e->index < ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
      {
#line 316
      tmp___5 = __bt_cmp(t, key, e);
      }
#line 316
      if (! (tmp___5 == 0)) {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  if ((unsigned long )e->index == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t )) {
#line 334
    redo = 1;
  }
  {
#line 337
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 337
    tmp___8 = e->index;
#line 337
    e->index = (u_int16_t )((int )e->index - 1);
#line 337
    if (! ((int )tmp___8 > 0)) {
#line 337
      goto while_break___0;
    }
    {
#line 338
    tmp___6 = __bt_cmp(t, key, e);
    }
#line 338
    if (tmp___6 != 0) {
#line 339
      goto while_break___0;
    }
    {
#line 340
    tmp___7 = __bt_dleaf(t, key, h, (u_int )e->index);
    }
#line 340
    if (tmp___7 == -1) {
      {
#line 341
      __mpool_put(t->bt_mp, (void *)h, (u_int )0);
      }
#line 342
      return (-1);
    }
#line 344
    if ((int )e->index == 0) {
#line 345
      redo = 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 349
  if (((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 0UL) {
    {
#line 350
    tmp___9 = __bt_pdelete___0(t, h);
    }
#line 350
    if (tmp___9) {
#line 351
      return (-1);
    }
#line 352
    goto loop;
  }
  {
#line 356
  __mpool_put(t->bt_mp, (void *)h, (u_int )1);
  }
#line 358
  if (redo) {
#line 359
    goto loop;
  }
#line 360
  return (0);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_pdelete___0(BTREE *t , PAGE *h ) 
{ 
  BINTERNAL *bi ;
  PAGE *pg ;
  EPGNO *parent ;
  u_int16_t cnt ;
  u_int16_t index___0 ;
  u_int16_t *ip ;
  u_int16_t offset ;
  u_int32_t nksize ;
  char *from ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u_int16_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if ((unsigned long )t->bt_sp == (unsigned long )(t->bt_stack)) {
#line 401
      parent = (EPGNO *)((void *)0);
    } else {
#line 401
      (t->bt_sp) --;
#line 401
      parent = t->bt_sp;
    }
#line 401
    if (! ((unsigned long )parent != (unsigned long )((void *)0))) {
#line 401
      goto while_break;
    }
    {
#line 403
    tmp___1 = __mpool_get(t->bt_mp, parent->pgno, (u_int )0);
#line 403
    pg = (PAGE *)tmp___1;
    }
#line 403
    if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 404
      return (-1);
    }
#line 406
    index___0 = parent->index;
#line 407
    bi = (BINTERNAL *)((char *)pg + (int )pg->linp[index___0]);
#line 410
    if ((int )bi->flags & 2) {
      {
#line 410
      tmp___2 = __ovfl_delete(t, (void *)(bi->bytes));
      }
#line 410
      if (tmp___2 == -1) {
        {
#line 412
        __mpool_put(t->bt_mp, (void *)pg, (u_int )0);
        }
#line 413
        return (-1);
      }
    }
#line 421
    if (((unsigned long )pg->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) == 1UL) {
#line 422
      if (pg->pgno == 1U) {
#line 423
        pg->lower = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 424
        pg->upper = (u_int16_t )t->bt_psize;
#line 425
        pg->flags = (u_int32_t )2;
      } else {
        {
#line 427
        tmp___3 = __bt_relink___0(t, pg);
        }
#line 427
        if (tmp___3) {
#line 428
          return (-1);
        } else {
          {
#line 427
          tmp___4 = __bt_free(t, pg);
          }
#line 427
          if (tmp___4) {
#line 428
            return (-1);
          }
        }
#line 429
        goto while_continue;
      }
    } else {
      {
#line 433
      nksize = (u_int32_t )((((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_char )) + (unsigned long )bi->ksize) + sizeof(u_int32_t )) - 1UL) & ~ (sizeof(u_int32_t ) - 1UL));
#line 434
      from = (char *)pg + (int )pg->upper;
#line 435
      memmove((void *)(from + nksize), (void const   *)from, (size_t )((char *)bi - from));
#line 436
      pg->upper = (u_int16_t )((u_int32_t )pg->upper + nksize);
#line 439
      offset = pg->linp[index___0];
#line 440
      cnt = index___0;
#line 440
      ip = & pg->linp[0];
      }
      {
#line 440
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 440
        tmp___5 = cnt;
#line 440
        cnt = (u_int16_t )((int )cnt - 1);
#line 440
        if (! tmp___5) {
#line 440
          goto while_break___0;
        }
#line 441
        if ((int )*(ip + 0) < (int )offset) {
#line 442
          *(ip + 0) = (u_int16_t )((u_int32_t )*(ip + 0) + nksize);
        }
#line 440
        ip ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 443
      cnt = (u_int16_t )(((unsigned long )pg->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - (unsigned long )index___0);
      {
#line 443
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 443
        cnt = (u_int16_t )((int )cnt - 1);
#line 443
        if (! cnt) {
#line 443
          goto while_break___1;
        }
#line 444
        if ((int )*(ip + 1) < (int )offset) {
#line 444
          *(ip + 0) = (u_int16_t )((u_int32_t )*(ip + 1) + nksize);
        } else {
#line 444
          *(ip + 0) = *(ip + 1);
        }
#line 443
        ip ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 445
      pg->lower = (u_int16_t )((unsigned long )pg->lower - sizeof(u_int16_t ));
    }
    {
#line 448
    __mpool_put(t->bt_mp, (void *)pg, (u_int )1);
    }
#line 449
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  if (h->pgno == 1U) {
    {
#line 454
    __mpool_put(t->bt_mp, (void *)h, (u_int )1);
    }
#line 455
    return (0);
  }
  {
#line 457
  tmp___6 = __bt_relink___0(t, h);
  }
#line 457
  if (tmp___6) {
#line 457
    tmp___8 = 1;
  } else {
    {
#line 457
    tmp___7 = __bt_free(t, h);
    }
#line 457
    if (tmp___7) {
#line 457
      tmp___8 = 1;
    } else {
#line 457
      tmp___8 = 0;
    }
  }
#line 457
  return (tmp___8);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_curdel___0(BTREE *t , DBT const   *key , PAGE *h , u_int index___0 ) 
{ 
  CURSOR *c ;
  EPG e ;
  PAGE *pg ;
  int curcopy ;
  int status ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
#line 554
  c = & t->bt_cursor;
#line 555
  c->flags = (u_int8_t )((int )c->flags & -8);
#line 557
  curcopy = 0;
#line 558
  if (! (t->flags & 32U)) {
#line 564
    if ((unsigned long )key == (unsigned long )((void *)0)) {
      {
#line 565
      e.page = h;
#line 566
      e.index = (u_int16_t )index___0;
#line 567
      status = __bt_ret(t, & e, & c->key, & c->key, (DBT *)((void *)0), (DBT *)((void *)0),
                        1);
      }
#line 567
      if (status != 0) {
#line 569
        return (status);
      }
#line 570
      curcopy = 1;
#line 571
      key = (DBT const   *)(& c->key);
    }
#line 574
    if (index___0 > 0U) {
      {
#line 575
      e.page = h;
#line 576
      e.index = (u_int16_t )(index___0 - 1U);
#line 577
      tmp___1 = __bt_cmp(t, key, & e);
      }
#line 577
      if (tmp___1 == 0) {
#line 578
        c->flags = (u_int8_t )((int )c->flags | 4);
#line 579
        goto dup2;
      }
    }
#line 583
    if ((unsigned long )index___0 < ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL) {
      {
#line 584
      e.page = h;
#line 585
      e.index = (u_int16_t )(index___0 + 1U);
#line 586
      tmp___2 = __bt_cmp(t, key, & e);
      }
#line 586
      if (tmp___2 == 0) {
#line 587
        c->flags = (u_int8_t )((int )c->flags | 2);
#line 588
        goto dup2;
      }
    }
#line 592
    if (index___0 == 0U) {
#line 592
      if (h->prevpg != 0U) {
        {
#line 593
        tmp___3 = __mpool_get(t->bt_mp, h->prevpg, (u_int )0);
#line 593
        pg = (PAGE *)tmp___3;
        }
#line 593
        if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 594
          return (-1);
        }
        {
#line 595
        e.page = pg;
#line 596
        e.index = (u_int16_t )(((unsigned long )pg->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL);
#line 597
        tmp___4 = __bt_cmp(t, key, & e);
        }
#line 597
        if (tmp___4 == 0) {
#line 598
          c->flags = (u_int8_t )((int )c->flags | 4);
#line 599
          goto dup1;
        }
        {
#line 601
        __mpool_put(t->bt_mp, (void *)pg, (u_int )0);
        }
      }
    }
#line 604
    if ((unsigned long )index___0 == ((unsigned long )h->lower - (((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ))) / sizeof(u_int16_t ) - 1UL) {
#line 604
      if (h->nextpg != 0U) {
        {
#line 605
        tmp___5 = __mpool_get(t->bt_mp, h->nextpg, (u_int )0);
#line 605
        pg = (PAGE *)tmp___5;
        }
#line 605
        if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 606
          return (-1);
        }
        {
#line 607
        e.page = pg;
#line 608
        e.index = (u_int16_t )0;
#line 609
        tmp___6 = __bt_cmp(t, key, & e);
        }
#line 609
        if (tmp___6 == 0) {
#line 610
          c->flags = (u_int8_t )((int )c->flags | 2);
          dup1: 
          {
#line 611
          __mpool_put(t->bt_mp, (void *)pg, (u_int )0);
          }
          dup2: 
#line 612
          c->pg.pgno = (e.page)->pgno;
#line 613
          c->pg.index = e.index;
#line 614
          return (0);
        }
        {
#line 616
        __mpool_put(t->bt_mp, (void *)pg, (u_int )0);
        }
      }
    }
  }
#line 619
  e.page = h;
#line 620
  e.index = (u_int16_t )index___0;
#line 621
  if (curcopy) {
#line 623
    c->flags = (u_int8_t )((int )c->flags | 1);
#line 624
    return (0);
  } else {
    {
#line 621
    status = __bt_ret(t, & e, & c->key, & c->key, (DBT *)((void *)0), (DBT *)((void *)0),
                      1);
    }
#line 621
    if (status == 0) {
#line 623
      c->flags = (u_int8_t )((int )c->flags | 1);
#line 624
      return (0);
    }
  }
#line 626
  return (status);
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_delete.c"
static int __bt_relink___0(BTREE *t , PAGE *h ) 
{ 
  PAGE *pg ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 644
  if (h->nextpg != 0U) {
    {
#line 645
    tmp___1 = __mpool_get(t->bt_mp, h->nextpg, (u_int )0);
#line 645
    pg = (PAGE *)tmp___1;
    }
#line 645
    if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 646
      return (-1);
    }
    {
#line 647
    pg->prevpg = h->prevpg;
#line 648
    __mpool_put(t->bt_mp, (void *)pg, (u_int )1);
    }
  }
#line 650
  if (h->prevpg != 0U) {
    {
#line 651
    tmp___2 = __mpool_get(t->bt_mp, h->prevpg, (u_int )0);
#line 651
    pg = (PAGE *)tmp___2;
    }
#line 651
    if ((unsigned long )pg == (unsigned long )((void *)0)) {
#line 652
      return (-1);
    }
    {
#line 653
    pg->nextpg = h->nextpg;
#line 654
    __mpool_put(t->bt_mp, (void *)pg, (u_int )1);
    }
  }
#line 656
  return (0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 171 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
void db_btree(DB *dbp , int pflag ) ;
#line 172
void db_hash(DB *dbp , int pflag ) ;
#line 173
void dbt_dump(DBT *dbtp ) ;
#line 174
void dbt_print(DBT *dbtp ) ;
#line 175
int main(int argc , char **argv ) ;
#line 176
int usage(void) ;
#line 183
extern char *optarg ;
#line 184
extern int optind ;
#line 190
extern int ( /* missing proto */  getopt)() ;
#line 178 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
int main(int argc , char **argv ) 
{ 
  DB *dbp ;
  DBT key ;
  DBT data ;
  int ch ;
  int pflag ;
  int rval ;
  int *tmp___1 ;
  char *tmp___2 ;
  FILE *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 189
  pflag = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 190
    ch = getopt(argc, argv, "f:p");
    }
#line 190
    if (! (ch != -1)) {
#line 190
      goto while_break;
    }
    {
#line 192
    if (ch == 102) {
#line 192
      goto case_102;
    }
#line 199
    if (ch == 112) {
#line 199
      goto case_112;
    }
#line 203
    goto switch_default;
    case_102: /* CIL Label */ 
    {
#line 193
    tmp___3 = freopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"w",
                      (FILE */* __restrict  */)stdout);
    }
#line 193
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      {
#line 194
      tmp___1 = __errno_location();
#line 194
      tmp___2 = strerror(*tmp___1);
#line 194
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"db_dump185: %s: %s\n",
              optarg, tmp___2);
      }
#line 196
      return (1);
    }
#line 198
    goto switch_break;
    case_112: /* CIL Label */ 
#line 200
    pflag = 1;
#line 201
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 204
    tmp___4 = usage();
    }
#line 204
    return (tmp___4);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  argc -= optind;
#line 207
  argv += optind;
#line 209
  if (argc != 1) {
    {
#line 210
    tmp___5 = usage();
    }
#line 210
    return (tmp___5);
  }
  {
#line 212
  dbp = dbopen((char const   *)*(argv + 0), 0, 0, (DBTYPE )0, (void const   *)((void *)0));
  }
#line 212
  if ((unsigned long )dbp == (unsigned long )((void *)0)) {
    {
#line 213
    dbp = dbopen((char const   *)*(argv + 0), 0, 0, (DBTYPE )1, (void const   *)((void *)0));
    }
#line 213
    if ((unsigned long )dbp == (unsigned long )((void *)0)) {
      {
#line 215
      tmp___6 = __errno_location();
#line 215
      tmp___7 = strerror(*tmp___6);
#line 215
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"db_dump185: %s: %s\n",
              *(argv + 0), tmp___7);
      }
#line 217
      return (1);
    }
    {
#line 219
    db_hash(dbp, pflag);
    }
  } else {
    {
#line 221
    db_btree(dbp, pflag);
    }
  }
#line 228
  if (pflag) {
    {
#line 229
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 229
      rval = (*(dbp->seq))((struct __db  const  *)dbp, & key, & data, (u_int )7);
      }
#line 229
      if (rval) {
#line 229
        goto while_break___0;
      }
      {
#line 230
      dbt_print(& key);
#line 231
      dbt_print(& data);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 234
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 234
      rval = (*(dbp->seq))((struct __db  const  *)dbp, & key, & data, (u_int )7);
      }
#line 234
      if (rval) {
#line 234
        goto while_break___1;
      }
      {
#line 235
      dbt_dump(& key);
#line 236
      dbt_dump(& data);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 239
  if (rval == -1) {
    {
#line 240
    tmp___8 = __errno_location();
#line 240
    tmp___9 = strerror(*tmp___8);
#line 240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"db_dump185: seq: %s\n",
            tmp___9);
    }
#line 241
    return (1);
  }
#line 243
  return (0);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
void db_hash(DB *dbp , int pflag ) 
{ 
  HTAB185 *hash185p ;
  HTAB186 *hash186p ;
  char const   *tmp___1 ;

  {
#line 258
  if (pflag) {
#line 258
    tmp___1 = "print";
  } else {
#line 258
    tmp___1 = "bytevalue";
  }
  {
#line 258
  printf((char const   */* __restrict  */)"format=%s\n", tmp___1);
#line 259
  printf((char const   */* __restrict  */)"type=hash\n");
#line 262
  hash185p = (HTAB185 *)dbp->internal;
  }
#line 263
  if (hash185p->hdr.version > 2) {
    {
#line 264
    hash186p = (HTAB186 *)dbp->internal;
#line 265
    printf((char const   */* __restrict  */)"h_ffactor=%lu\n", (u_long )hash186p->hdr.ffactor);
    }
#line 266
    if (hash186p->hdr.lorder != 0) {
      {
#line 267
      printf((char const   */* __restrict  */)"db_lorder=%lu\n", (u_long )hash186p->hdr.lorder);
      }
    }
    {
#line 268
    printf((char const   */* __restrict  */)"db_pagesize=%lu\n", (u_long )hash186p->hdr.bsize);
    }
  } else {
    {
#line 270
    printf((char const   */* __restrict  */)"h_ffactor=%lu\n", (u_long )hash185p->hdr.ffactor);
    }
#line 271
    if (hash185p->hdr.lorder != 0U) {
      {
#line 272
      printf((char const   */* __restrict  */)"db_lorder=%lu\n", (u_long )hash185p->hdr.lorder);
      }
    }
    {
#line 273
    printf((char const   */* __restrict  */)"db_pagesize=%lu\n", (u_long )hash185p->hdr.bsize);
    }
  }
  {
#line 275
  printf((char const   */* __restrict  */)"HEADER=END\n");
  }
#line 276
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
void db_btree(DB *dbp , int pflag ) 
{ 
  BTREE___0 *btp ;
  char const   *tmp___1 ;

  {
#line 289
  btp = (BTREE___0 *)dbp->internal;
#line 291
  if (pflag) {
#line 291
    tmp___1 = "print";
  } else {
#line 291
    tmp___1 = "bytevalue";
  }
  {
#line 291
  printf((char const   */* __restrict  */)"format=%s\n", tmp___1);
#line 292
  printf((char const   */* __restrict  */)"type=btree\n");
  }
#line 297
  if (btp->bt_lorder != 0) {
    {
#line 298
    printf((char const   */* __restrict  */)"db_lorder=%lu\n", (u_long )btp->bt_lorder);
    }
  }
  {
#line 299
  printf((char const   */* __restrict  */)"db_pagesize=%lu\n", (u_long )btp->bt_psize);
  }
#line 300
  if (! (btp->flags & 32U)) {
    {
#line 301
    printf((char const   */* __restrict  */)"duplicates=1\n");
    }
  }
  {
#line 302
  printf((char const   */* __restrict  */)"HEADER=END\n");
  }
#line 303
  return;
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
static char hex[17]  = 
#line 305
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 311 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
void dbt_dump(DBT *dbtp ) 
{ 
  size_t len ;
  u_int8_t *p ;
  size_t tmp___1 ;

  {
#line 318
  len = dbtp->size;
#line 318
  p = (u_int8_t *)dbtp->data;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    tmp___1 = len;
#line 318
    len --;
#line 318
    if (! tmp___1) {
#line 318
      goto while_break;
    }
    {
#line 319
    printf((char const   */* __restrict  */)"%c%c", (int )hex[((int )*p & 240) >> 4],
           (int )hex[(int )*p & 15]);
#line 318
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  printf((char const   */* __restrict  */)"\n");
  }
#line 322
  return;
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
void dbt_print(DBT *dbtp ) 
{ 
  size_t len ;
  u_int8_t *p ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;

  {
#line 335
  len = dbtp->size;
#line 335
  p = (u_int8_t *)dbtp->data;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    tmp___2 = len;
#line 335
    len --;
#line 335
    if (! tmp___2) {
#line 335
      goto while_break;
    }
    {
#line 336
    tmp___1 = __ctype_b_loc();
    }
#line 336
    if ((int const   )*(*tmp___1 + (int )*p) & 16384) {
#line 337
      if ((int )*p == 92) {
        {
#line 338
        printf((char const   */* __restrict  */)"\\");
        }
      }
      {
#line 339
      printf((char const   */* __restrict  */)"%c", (int )*p);
      }
    } else {
      {
#line 341
      printf((char const   */* __restrict  */)"\\%c%c", (int )hex[((int )*p & 240) >> 4],
             (int )hex[(int )*p & 15]);
      }
    }
#line 335
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 343
  printf((char const   */* __restrict  */)"\n");
  }
#line 344
  return;
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/db_dump185/db_dump185.c"
int usage(void) 
{ 


  {
  {
#line 353
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: db_dump185 [-p] [-f file] db_file\n");
  }
#line 354
  return (1);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_close.c"
static int bt_meta___0(BTREE *t ) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_close.c"
static int bt_meta___0(BTREE *t ) 
{ 
  BTMETA m ;
  void *p ;

  {
  {
#line 168
  p = __mpool_get(t->bt_mp, (u_int32_t )0, (u_int )0);
  }
#line 168
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 169
    return (-1);
  }
  {
#line 172
  m.magic = (u_int32_t )340322;
#line 173
  m.version = (u_int32_t )3;
#line 174
  m.psize = t->bt_psize;
#line 175
  m.free = t->bt_free;
#line 176
  m.nrecs = t->bt_nrecs;
#line 177
  m.flags = t->flags & 160U;
#line 179
  memmove(p, (void const   *)(& m), sizeof(BTMETA ));
#line 180
  __mpool_put(t->bt_mp, p, (u_int )1);
  }
#line 181
  return (0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static int byteorder___0(void) ;
#line 70
static int nroot___0(BTREE *t ) ;
#line 71
static int tmp___0(void) ;
#line 354 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static int nroot___0(BTREE *t ) 
{ 
  PAGE *meta ;
  PAGE *root ;
  u_int32_t npg ;
  void *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int32_t tmp___6 ;

  {
  {
#line 361
  tmp___1 = __mpool_get(t->bt_mp, (u_int32_t )0, (u_int )0);
#line 361
  meta = (PAGE *)tmp___1;
  }
#line 361
  if ((unsigned long )meta != (unsigned long )((void *)0)) {
    {
#line 362
    __mpool_put(t->bt_mp, (void *)meta, (u_int )0);
    }
#line 363
    return (0);
  }
  {
#line 365
  tmp___2 = __errno_location();
  }
#line 365
  if (*tmp___2 != 22) {
#line 366
    return (-1);
  }
  {
#line 367
  tmp___3 = __errno_location();
#line 367
  *tmp___3 = 0;
#line 369
  tmp___4 = __mpool_new(t->bt_mp, & npg);
#line 369
  meta = (PAGE *)tmp___4;
  }
#line 369
  if ((unsigned long )meta == (unsigned long )((void *)0)) {
#line 370
    return (-1);
  }
  {
#line 372
  tmp___5 = __mpool_new(t->bt_mp, & npg);
#line 372
  root = (PAGE *)tmp___5;
  }
#line 372
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 373
    return (-1);
  }
#line 375
  if (npg != 1U) {
#line 376
    return (-1);
  }
  {
#line 377
  root->pgno = npg;
#line 378
  tmp___6 = (u_int32_t )0;
#line 378
  root->nextpg = tmp___6;
#line 378
  root->prevpg = tmp___6;
#line 379
  root->lower = (u_int16_t )(((((sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int16_t )) + sizeof(u_int16_t ));
#line 380
  root->upper = (u_int16_t )t->bt_psize;
#line 381
  root->flags = (u_int32_t )2;
#line 382
  memset((void *)meta, 0, (size_t )t->bt_psize);
#line 383
  __mpool_put(t->bt_mp, (void *)meta, (u_int )1);
#line 384
  __mpool_put(t->bt_mp, (void *)root, (u_int )1);
  }
#line 385
  return (0);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static char const   fmt___0[13]  = 
#line 395
  {      (char const   )'%',      (char const   )'s',      (char const   )'/',      (char const   )'b', 
        (char const   )'t',      (char const   )'.',      (char const   )'X',      (char const   )'X', 
        (char const   )'X',      (char const   )'X',      (char const   )'X',      (char const   )'X', 
        (char const   )'\000'};
#line 388 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static int tmp___0(void) 
{ 
  sigset_t set ;
  sigset_t oset ;
  int fd ;
  char const   *envtmp ;
  char *path ;
  size_t n ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 398
  tmp___1 = getenv("TMPDIR");
#line 398
  envtmp = (char const   *)tmp___1;
  }
#line 399
  if (! envtmp) {
#line 400
    envtmp = "/tmp";
  }
  {
#line 401
  tmp___2 = strlen(envtmp);
#line 401
  n = tmp___2 + sizeof(fmt___0);
#line 403
  tmp___3 = __builtin_alloca(n);
#line 403
  path = (char *)tmp___3;
  }
#line 407
  if (envtmp) {
#line 407
    tmp___4 = envtmp;
  } else {
#line 407
    tmp___4 = "/tmp";
  }
  {
#line 407
  snprintf((char */* __restrict  */)path, n, (char const   */* __restrict  */)(fmt___0),
           tmp___4);
#line 409
  sigfillset(& set);
#line 410
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)(& oset));
#line 411
  fd = mkstemp(path);
  }
#line 411
  if (fd != -1) {
    {
#line 412
    unlink((char const   *)path);
    }
  }
  {
#line 413
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& oset), (sigset_t */* __restrict  */)((void *)0));
  }
#line 417
  return (fd);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/btree/bt_open.c"
static int byteorder___0(void) 
{ 
  u_int32_t x ;
  u_char *p ;

  {
#line 426
  x = (u_int32_t )16909060;
#line 427
  p = (u_char *)(& x);
  {
#line 429
  if ((int )*p == 1) {
#line 429
    goto case_1;
  }
#line 431
  if ((int )*p == 4) {
#line 431
    goto case_4;
  }
#line 433
  goto switch_default;
  case_1: /* CIL Label */ 
#line 430
  return (4321);
  case_4: /* CIL Label */ 
#line 432
  return (1234);
  switch_default: /* CIL Label */ 
#line 434
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int alloc_segs___0(HTAB *hashp , int nsegs ) ;
#line 60
static int flush_meta___0(HTAB *hashp ) ;
#line 61
static int hash_access___0(HTAB *hashp , ACTION action , DBT *key , DBT *val ) ;
#line 62
static int hash_close___0(DB *dbp ) ;
#line 63
static int hash_delete___0(DB const   *dbp , DBT const   *key , u_int32_t flag ) ;
#line 64
static int hash_fd___0(DB const   *dbp ) ;
#line 65
static int hash_get___0(DB const   *dbp , DBT const   *key , DBT *data , u_int32_t flag ) ;
#line 66
static int hash_put___0(DB const   *dbp , DBT *key , DBT const   *data , u_int32_t flag ) ;
#line 67
static void *hash_realloc___0(SEGMENT **p_ptr , int oldsize , int newsize ) ;
#line 68
static int hash_seq___0(DB const   *dbp , DBT *key , DBT *data , u_int32_t flag ) ;
#line 69
static int hash_sync___0(DB const   *dbp , u_int32_t flags ) ;
#line 70
static int hdestroy___0(HTAB *hashp ) ;
#line 71
static HTAB *init_hash___0(HTAB *hashp , char const   *file , HASHINFO *info ) ;
#line 72
static int init_htab___0(HTAB *hashp , int nelem ) ;
#line 74
static void swap_header___0(HTAB *hashp ) ;
#line 75
static void swap_header_copy___0(HASHHDR *srcp , HASHHDR *destp ) ;
#line 245 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_close___0(DB *dbp ) 
{ 
  HTAB *hashp ;
  int retval ;

  {
#line 252
  if (! dbp) {
#line 253
    return (-1);
  }
  {
#line 255
  hashp = (HTAB *)dbp->internal;
#line 256
  retval = hdestroy___0(hashp);
#line 257
  free((void *)dbp);
  }
#line 258
  return (retval);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_fd___0(DB const   *dbp ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;

  {
#line 267
  if (! dbp) {
#line 268
    return (-1);
  }
#line 270
  hashp = (HTAB *)dbp->internal;
#line 271
  if (hashp->fp == -1) {
    {
#line 272
    tmp___1 = __errno_location();
#line 272
    *tmp___1 = 2;
    }
#line 273
    return (-1);
  }
#line 275
  return (hashp->fp);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static HTAB *init_hash___0(HTAB *hashp , char const   *file , HASHINFO *info ) 
{ 
  struct stat statbuf ;
  int nelem ;
  int tmp___1 ;
  u_int32_t tmp___2 ;
  u_int32_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 290
  nelem = 1;
#line 291
  hashp->hdr.nkeys = 0;
#line 292
  hashp->hdr.lorder = (u_int32_t )1234;
#line 293
  hashp->hdr.bsize = 4096;
#line 294
  hashp->hdr.bshift = 12;
#line 295
  hashp->hdr.ssize = 256;
#line 296
  hashp->hdr.sshift = 8;
#line 297
  hashp->hdr.dsize = 256;
#line 298
  hashp->hdr.ffactor = 65536;
#line 299
  hashp->hash = __default_hash;
#line 300
  memset((void *)(hashp->hdr.spares), 0, sizeof(hashp->hdr.spares));
#line 301
  memset((void *)(hashp->hdr.bitmaps), 0, sizeof(hashp->hdr.bitmaps));
  }
#line 305
  if ((unsigned long )file != (unsigned long )((void *)0)) {
    {
#line 306
    tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& statbuf));
    }
#line 306
    if (tmp___1) {
#line 307
      return ((HTAB *)((void *)0));
    }
    {
#line 308
    hashp->hdr.bsize = (int )statbuf.st_blksize;
#line 309
    tmp___2 = __hash_log2((u_int32_t )hashp->hdr.bsize);
#line 309
    hashp->hdr.bshift = (int )tmp___2;
    }
  }
#line 313
  if (info) {
#line 314
    if (info->bsize) {
      {
#line 316
      tmp___3 = __hash_log2(info->bsize);
#line 316
      hashp->hdr.bshift = (int )tmp___3;
#line 317
      hashp->hdr.bsize = 1 << hashp->hdr.bshift;
      }
#line 318
      if (hashp->hdr.bsize > 65536) {
        {
#line 319
        tmp___4 = __errno_location();
#line 319
        *tmp___4 = 22;
        }
#line 320
        return ((HTAB *)((void *)0));
      }
    }
#line 323
    if (info->ffactor) {
#line 324
      hashp->hdr.ffactor = (int )info->ffactor;
    }
#line 325
    if (info->hash) {
#line 326
      hashp->hash = info->hash;
    }
#line 327
    if (info->nelem) {
#line 328
      nelem = (int )info->nelem;
    }
#line 329
    if (info->lorder) {
#line 330
      if (info->lorder != 4321) {
#line 330
        if (info->lorder != 1234) {
          {
#line 332
          tmp___5 = __errno_location();
#line 332
          *tmp___5 = 22;
          }
#line 333
          return ((HTAB *)((void *)0));
        }
      }
#line 335
      hashp->hdr.lorder = (u_int32_t )info->lorder;
    }
  }
  {
#line 339
  tmp___6 = init_htab___0(hashp, nelem);
  }
#line 339
  if (tmp___6) {
#line 340
    return ((HTAB *)((void *)0));
  } else {
#line 342
    return (hashp);
  }
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int init_htab___0(HTAB *hashp , int nelem ) 
{ 
  register int nbuckets ;
  register int nsegs ;
  int l2 ;
  int tmp___1 ;
  u_int32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  u_int32_t tmp___6 ;
  int tmp___7 ;

  {
#line 363
  nelem = (nelem - 1) / hashp->hdr.ffactor + 1;
#line 365
  if (nelem > 2) {
#line 365
    tmp___1 = nelem;
  } else {
#line 365
    tmp___1 = 2;
  }
  {
#line 365
  tmp___2 = __hash_log2((u_int32_t )tmp___1);
#line 365
  l2 = (int )tmp___2;
#line 366
  nbuckets = 1 << l2;
#line 368
  hashp->hdr.spares[l2] = l2 + 1;
#line 369
  hashp->hdr.spares[l2 + 1] = l2 + 1;
#line 370
  hashp->hdr.ovfl_point = l2;
#line 371
  hashp->hdr.last_freed = 2;
#line 374
  tmp___3 = __ibitmap(hashp, (int )(((u_int32_t )l2 << 11) + 1U), l2 + 1, 0);
  }
#line 374
  if (tmp___3) {
#line 375
    return (-1);
  }
#line 377
  tmp___4 = nbuckets - 1;
#line 377
  hashp->hdr.low_mask = tmp___4;
#line 377
  hashp->hdr.max_bucket = tmp___4;
#line 378
  hashp->hdr.high_mask = (nbuckets << 1) - 1;
#line 379
  if (sizeof(HASHHDR ) > 512UL) {
#line 379
    tmp___5 = sizeof(HASHHDR );
  } else {
#line 379
    tmp___5 = 512UL;
  }
  {
#line 379
  hashp->hdr.hdrpages = (int )(((tmp___5 - 1UL) >> hashp->hdr.bshift) + 1UL);
#line 382
  nsegs = (nbuckets - 1) / hashp->hdr.ssize + 1;
#line 383
  tmp___6 = __hash_log2((u_int32_t )nsegs);
#line 383
  nsegs = 1 << tmp___6;
  }
#line 385
  if (nsegs > hashp->hdr.dsize) {
#line 386
    hashp->hdr.dsize = nsegs;
  }
  {
#line 387
  tmp___7 = alloc_segs___0(hashp, nsegs);
  }
#line 387
  return (tmp___7);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hdestroy___0(HTAB *hashp ) 
{ 
  int i ;
  int save_errno ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 402
  save_errno = 0;
#line 422
  tmp___2 = __buf_free(hashp, 1, hashp->save_file);
  }
#line 422
  if (tmp___2) {
    {
#line 423
    tmp___1 = __errno_location();
#line 423
    save_errno = *tmp___1;
    }
  }
#line 424
  if (hashp->dir) {
    {
#line 425
    free((void *)*(hashp->dir));
    }
    {
#line 427
    while (1) {
      while_continue: /* CIL Label */ ;
#line 427
      tmp___3 = hashp->exsegs;
#line 427
      (hashp->exsegs) --;
#line 427
      if (! tmp___3) {
#line 427
        goto while_break;
      }
      {
#line 428
      (hashp->nsegs) --;
#line 428
      free((void *)*(hashp->dir + hashp->nsegs));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 429
    free((void *)hashp->dir);
    }
  }
  {
#line 431
  tmp___5 = flush_meta___0(hashp);
  }
#line 431
  if (tmp___5) {
#line 431
    if (! save_errno) {
      {
#line 432
      tmp___4 = __errno_location();
#line 432
      save_errno = *tmp___4;
      }
    }
  }
#line 434
  i = 0;
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    if (! (i < hashp->nmaps)) {
#line 434
      goto while_break___0;
    }
#line 435
    if (hashp->mapp[i]) {
      {
#line 436
      free((void *)hashp->mapp[i]);
      }
    }
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 438
  if (hashp->fp != -1) {
    {
#line 439
    close(hashp->fp);
    }
  }
  {
#line 441
  free((void *)hashp);
  }
#line 443
  if (save_errno) {
    {
#line 444
    tmp___6 = __errno_location();
#line 444
    *tmp___6 = save_errno;
    }
#line 445
    return (-1);
  }
#line 447
  return (0);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_sync___0(DB const   *dbp , u_int32_t flags ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 463
  if (flags != 0U) {
    {
#line 464
    tmp___1 = __errno_location();
#line 464
    *tmp___1 = 22;
    }
#line 465
    return (-1);
  }
#line 468
  if (! dbp) {
#line 469
    return (-1);
  }
#line 471
  hashp = (HTAB *)dbp->internal;
#line 472
  if (! hashp->save_file) {
#line 473
    return (0);
  }
  {
#line 474
  tmp___2 = __buf_free(hashp, 0, 1);
  }
#line 474
  if (tmp___2) {
#line 475
    return (-1);
  } else {
    {
#line 474
    tmp___3 = flush_meta___0(hashp);
    }
#line 474
    if (tmp___3) {
#line 475
      return (-1);
    }
  }
#line 476
  hashp->new_file = 0;
#line 477
  return (0);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int flush_meta___0(HTAB *hashp ) 
{ 
  HASHHDR *whdrp ;
  HASHHDR whdr ;
  int fp ;
  int i ;
  int wsize ;
  u_int32_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  __off_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;

  {
#line 495
  if (! hashp->save_file) {
#line 496
    return (0);
  }
  {
#line 497
  hashp->hdr.magic = 398689;
#line 498
  hashp->hdr.version = 2;
#line 499
  tmp___1 = (*(hashp->hash))((void const   *)"%$sniglet^&", sizeof("%$sniglet^&"));
#line 499
  hashp->hdr.h_charkey = (int )tmp___1;
#line 501
  fp = hashp->fp;
#line 502
  whdrp = & hashp->hdr;
#line 504
  whdrp = & whdr;
#line 505
  swap_header_copy___0(& hashp->hdr, whdrp);
#line 507
  tmp___4 = lseek(fp, (off_t )0, 0);
  }
#line 507
  if (tmp___4 == -1L) {
#line 509
    return (-1);
  } else {
    {
#line 507
    tmp___5 = write(fp, (void const   *)whdrp, sizeof(HASHHDR ));
#line 507
    wsize = (int )tmp___5;
    }
#line 507
    if (wsize == -1) {
#line 509
      return (-1);
    } else
#line 511
    if ((unsigned long )wsize != sizeof(HASHHDR )) {
      {
#line 512
      tmp___2 = __errno_location();
#line 512
      *tmp___2 = 22;
#line 513
      tmp___3 = __errno_location();
#line 513
      hashp->errnum = *tmp___3;
      }
#line 514
      return (-1);
    }
  }
#line 516
  i = 0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (i < 32)) {
#line 516
      goto while_break;
    }
#line 517
    if (hashp->mapp[i]) {
      {
#line 518
      tmp___6 = __put_page(hashp, (char *)hashp->mapp[i], (u_int32_t )hashp->hdr.bitmaps[i],
                           0, 1);
      }
#line 518
      if (tmp___6) {
#line 520
        return (-1);
      }
    }
#line 516
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  return (0);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_get___0(DB const   *dbp , DBT const   *key , DBT *data , u_int32_t flag ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 542
  hashp = (HTAB *)dbp->internal;
#line 543
  if (flag) {
    {
#line 544
    tmp___1 = __errno_location();
#line 544
    tmp___2 = 22;
#line 544
    *tmp___1 = tmp___2;
#line 544
    hashp->errnum = tmp___2;
    }
#line 545
    return (-1);
  }
  {
#line 547
  tmp___3 = hash_access___0(hashp, (ACTION )0, (DBT *)key, data);
  }
#line 547
  return (tmp___3);
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_put___0(DB const   *dbp , DBT *key , DBT const   *data , u_int32_t flag ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 559
  hashp = (HTAB *)dbp->internal;
#line 560
  if (flag) {
#line 560
    if (flag != 8U) {
      {
#line 561
      tmp___1 = __errno_location();
#line 561
      tmp___2 = 22;
#line 561
      *tmp___1 = tmp___2;
#line 561
      hashp->errnum = tmp___2;
      }
#line 562
      return (-1);
    }
  }
#line 564
  if ((hashp->flags & 3) == 0) {
    {
#line 565
    tmp___3 = __errno_location();
#line 565
    tmp___4 = 1;
#line 565
    *tmp___3 = tmp___4;
#line 565
    hashp->errnum = tmp___4;
    }
#line 566
    return (-1);
  }
#line 568
  if (flag == 8U) {
#line 568
    tmp___5 = 2;
  } else {
#line 568
    tmp___5 = 1;
  }
  {
#line 568
  tmp___6 = hash_access___0(hashp, (ACTION )tmp___5, key, (DBT *)data);
  }
#line 568
  return (tmp___6);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_delete___0(DB const   *dbp , DBT const   *key , u_int32_t flag ) 
{ 
  HTAB *hashp ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 580
  hashp = (HTAB *)dbp->internal;
#line 581
  if (flag) {
#line 581
    if (flag != 1U) {
      {
#line 582
      tmp___1 = __errno_location();
#line 582
      tmp___2 = 22;
#line 582
      *tmp___1 = tmp___2;
#line 582
      hashp->errnum = tmp___2;
      }
#line 583
      return (-1);
    }
  }
#line 585
  if ((hashp->flags & 3) == 0) {
    {
#line 586
    tmp___3 = __errno_location();
#line 586
    tmp___4 = 1;
#line 586
    *tmp___3 = tmp___4;
#line 586
    hashp->errnum = tmp___4;
    }
#line 587
    return (-1);
  }
  {
#line 589
  tmp___5 = hash_access___0(hashp, (ACTION )3, (DBT *)key, (DBT *)((void *)0));
  }
#line 589
  return (tmp___5);
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_access___0(HTAB *hashp , ACTION action , DBT *key , DBT *val ) 
{ 
  register BUFHEAD *rbufp ;
  BUFHEAD *bufp ;
  BUFHEAD *save_bufp ;
  register u_int16_t *bp ;
  register int n ;
  register int ndx ;
  register int off ;
  register int size ;
  register char *kp ;
  u_int16_t pageno ;
  u_int32_t tmp___1 ;
  u_int16_t *tmp___2 ;
  int tmp___3 ;
  u_int16_t *tmp___4 ;
  u_int16_t *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 612
  off = hashp->hdr.bsize;
#line 613
  size = (int )key->size;
#line 614
  kp = (char *)key->data;
#line 615
  tmp___1 = __call_hash(hashp, kp, size);
#line 615
  rbufp = __get_buf(hashp, tmp___1, (BUFHEAD *)((void *)0), 0);
  }
#line 616
  if (! rbufp) {
#line 617
    return (-1);
  }
#line 618
  save_bufp = rbufp;
#line 621
  rbufp->flags = (char )((int )rbufp->flags | 8);
#line 622
  bp = (u_int16_t *)rbufp->page;
#line 622
  tmp___2 = bp;
#line 622
  bp ++;
#line 622
  n = (int )*tmp___2;
#line 622
  ndx = 1;
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (ndx < n)) {
#line 622
      goto while_break;
    }
#line 623
    if ((int )*(bp + 1) >= 4) {
#line 625
      if (size == off - (int )*bp) {
        {
#line 625
        tmp___3 = memcmp((void const   *)kp, (void const   *)(rbufp->page + (int )*bp),
                         (size_t )size);
        }
#line 625
        if (tmp___3 == 0) {
#line 627
          goto found;
        }
      }
#line 628
      off = (int )*(bp + 1);
#line 632
      bp += 2;
#line 633
      ndx += 2;
    } else
#line 634
    if ((int )*(bp + 1) == 0) {
      {
#line 635
      rbufp = __get_buf(hashp, (u_int32_t )*bp, rbufp, 0);
      }
#line 636
      if (! rbufp) {
#line 637
        save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 638
        return (-1);
      }
#line 641
      bp = (u_int16_t *)rbufp->page;
#line 642
      tmp___4 = bp;
#line 642
      bp ++;
#line 642
      n = (int )*tmp___4;
#line 643
      ndx = 1;
#line 644
      off = hashp->hdr.bsize;
    } else
#line 645
    if ((int )*(bp + 1) < 4) {
      {
#line 646
      ndx = __find_bigpair(hashp, rbufp, ndx, kp, size);
      }
#line 646
      if (ndx > 0) {
#line 648
        goto found;
      }
#line 649
      if (ndx == -2) {
        {
#line 650
        bufp = rbufp;
#line 651
        pageno = __find_last_page(hashp, & bufp);
        }
#line 651
        if (! pageno) {
#line 653
          ndx = 0;
#line 654
          rbufp = bufp;
#line 655
          goto while_break;
        }
        {
#line 657
        rbufp = __get_buf(hashp, (u_int32_t )pageno, bufp, 0);
        }
#line 658
        if (! rbufp) {
#line 659
          save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 660
          return (-1);
        }
#line 663
        bp = (u_int16_t *)rbufp->page;
#line 664
        tmp___5 = bp;
#line 664
        bp ++;
#line 664
        n = (int )*tmp___5;
#line 665
        ndx = 1;
#line 666
        off = hashp->hdr.bsize;
      } else {
#line 668
        save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 669
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  if ((unsigned int )action == 2U) {
#line 676
    goto case_2;
  }
#line 676
  if ((unsigned int )action == 1U) {
#line 676
    goto case_2;
  }
#line 686
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 677
  tmp___6 = __addel(hashp, rbufp, (DBT const   *)key, (DBT const   *)val);
  }
#line 677
  if (tmp___6) {
#line 678
    save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 679
    return (-1);
  } else {
#line 681
    save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 682
    return (0);
  }
  switch_default: /* CIL Label */ 
#line 687
  save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 688
  return (1);
  switch_break: /* CIL Label */ ;
  }
  found: 
  {
#line 693
  if ((unsigned int )action == 2U) {
#line 693
    goto case_2___0;
  }
#line 696
  if ((unsigned int )action == 0U) {
#line 696
    goto case_0;
  }
#line 706
  if ((unsigned int )action == 1U) {
#line 706
    goto case_1___0;
  }
#line 713
  if ((unsigned int )action == 3U) {
#line 713
    goto case_3;
  }
#line 717
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
#line 694
  save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 695
  return (1);
  case_0: /* CIL Label */ 
#line 697
  bp = (u_int16_t *)rbufp->page;
#line 698
  if ((int )*(bp + (ndx + 1)) < 4) {
    {
#line 699
    tmp___7 = __big_return(hashp, rbufp, ndx, val, 0);
    }
#line 699
    if (tmp___7) {
#line 700
      return (-1);
    }
  } else {
#line 702
    val->data = (void *)((u_char *)rbufp->page + (int )*(bp + (ndx + 1)));
#line 703
    val->size = (size_t )((int )*(bp + ndx) - (int )*(bp + (ndx + 1)));
  }
#line 705
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 707
  tmp___8 = __delpair(hashp, rbufp, ndx);
  }
#line 707
  if (tmp___8) {
#line 709
    save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 710
    return (-1);
  } else {
    {
#line 707
    tmp___9 = __addel(hashp, rbufp, (DBT const   *)key, (DBT const   *)val);
    }
#line 707
    if (tmp___9) {
#line 709
      save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 710
      return (-1);
    }
  }
#line 712
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 714
  tmp___10 = __delpair(hashp, rbufp, ndx);
  }
#line 714
  if (tmp___10) {
#line 715
    return (-1);
  }
#line 716
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 718
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 720
  save_bufp->flags = (char )((int )save_bufp->flags & -9);
#line 721
  return (0);
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int hash_seq___0(DB const   *dbp , DBT *key , DBT *data , u_int32_t flag ) 
{ 
  register u_int32_t bucket ;
  register BUFHEAD *bufp ;
  HTAB *hashp ;
  u_int16_t *bp ;
  u_int16_t ndx ;
  int *tmp___1 ;
  int tmp___2 ;
  BUFHEAD *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 735
  hashp = (HTAB *)dbp->internal;
#line 736
  if (flag) {
#line 736
    if (flag != 3U) {
#line 736
      if (flag != 7U) {
        {
#line 737
        tmp___1 = __errno_location();
#line 737
        tmp___2 = 22;
#line 737
        *tmp___1 = tmp___2;
#line 737
        hashp->errnum = tmp___2;
        }
#line 738
        return (-1);
      }
    }
  }
#line 743
  if (hashp->cbucket < 0) {
#line 744
    hashp->cbucket = 0;
#line 745
    hashp->cndx = 1;
#line 746
    hashp->cpage = (BUFHEAD *)((void *)0);
  } else
#line 743
  if (flag == 3U) {
#line 744
    hashp->cbucket = 0;
#line 745
    hashp->cndx = 1;
#line 746
    hashp->cpage = (BUFHEAD *)((void *)0);
  }
#line 749
  bp = (u_int16_t *)((void *)0);
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (! (! bp)) {
#line 749
      if (! (! *(bp + 0))) {
#line 749
        goto while_break;
      }
    }
#line 750
    bufp = hashp->cpage;
#line 750
    if (bufp) {
#line 768
      bp = (u_int16_t *)(hashp->cpage)->page;
    } else {
#line 751
      bucket = (u_int32_t )hashp->cbucket;
      {
#line 751
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 751
        if (! (bucket <= (u_int32_t )hashp->hdr.max_bucket)) {
#line 751
          goto while_break___0;
        }
        {
#line 754
        bufp = __get_buf(hashp, bucket, (BUFHEAD *)((void *)0), 0);
        }
#line 755
        if (! bufp) {
#line 756
          return (-1);
        }
#line 757
        hashp->cpage = bufp;
#line 758
        bp = (u_int16_t *)bufp->page;
#line 759
        if (*(bp + 0)) {
#line 760
          goto while_break___0;
        }
#line 751
        bucket ++;
#line 751
        hashp->cndx = 1;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 762
      hashp->cbucket = (int )bucket;
#line 763
      if (hashp->cbucket > hashp->hdr.max_bucket) {
#line 764
        hashp->cbucket = -1;
#line 765
        return (1);
      }
    }
    {
#line 774
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 774
      if (! ((int )*(bp + (hashp->cndx + 1)) == 0)) {
#line 774
        goto while_break___1;
      }
      {
#line 775
      tmp___3 = __get_buf(hashp, (u_int32_t )*(bp + hashp->cndx), bufp, 0);
#line 775
      hashp->cpage = tmp___3;
#line 775
      bufp = tmp___3;
      }
#line 777
      if (! bufp) {
#line 778
        return (-1);
      }
#line 779
      bp = (u_int16_t *)bufp->page;
#line 780
      hashp->cndx = 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 782
    if (! *(bp + 0)) {
#line 783
      hashp->cpage = (BUFHEAD *)((void *)0);
#line 784
      (hashp->cbucket) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  ndx = (u_int16_t )hashp->cndx;
#line 788
  if ((int )*(bp + ((int )ndx + 1)) < 4) {
    {
#line 789
    tmp___4 = __big_keydata(hashp, bufp, key, data, 1);
    }
#line 789
    if (tmp___4) {
#line 790
      return (-1);
    }
  } else {
#line 792
    key->data = (void *)((u_char *)(hashp->cpage)->page + (int )*(bp + ndx));
#line 793
    if ((int )ndx > 1) {
#line 793
      tmp___5 = (int )*(bp + ((int )ndx - 1));
    } else {
#line 793
      tmp___5 = hashp->hdr.bsize;
    }
#line 793
    key->size = (size_t )(tmp___5 - (int )*(bp + ndx));
#line 794
    data->data = (void *)((u_char *)(hashp->cpage)->page + (int )*(bp + ((int )ndx + 1)));
#line 795
    data->size = (size_t )((int )*(bp + ndx) - (int )*(bp + ((int )ndx + 1)));
#line 796
    ndx = (u_int16_t )((int )ndx + 2);
#line 797
    if ((int )ndx > (int )*(bp + 0)) {
#line 798
      hashp->cpage = (BUFHEAD *)((void *)0);
#line 799
      (hashp->cbucket) ++;
#line 800
      hashp->cndx = 1;
    } else {
#line 802
      hashp->cndx = (int )ndx;
    }
  }
#line 804
  return (0);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static void *hash_realloc___0(SEGMENT **p_ptr , int oldsize , int newsize ) 
{ 
  register void *p ;

  {
  {
#line 876
  p = malloc((size_t )newsize);
  }
#line 876
  if (p) {
    {
#line 877
    memmove(p, (void const   *)*p_ptr, (size_t )oldsize);
#line 878
    memset((void *)((char *)p + oldsize), 0, (size_t )(newsize - oldsize));
#line 879
    free((void *)*p_ptr);
#line 880
    *p_ptr = (SEGMENT *)p;
    }
  }
#line 882
  return (p);
}
}
#line 905 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static int alloc_segs___0(HTAB *hashp , int nsegs ) 
{ 
  register int i ;
  register SEGMENT store ;
  int save_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  SEGMENT *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 915
  tmp___4 = calloc((size_t )hashp->hdr.dsize, sizeof(SEGMENT *));
#line 915
  tmp___3 = (SEGMENT *)tmp___4;
#line 915
  hashp->dir = tmp___3;
  }
#line 915
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 917
    tmp___1 = __errno_location();
#line 917
    save_errno = *tmp___1;
#line 918
    hdestroy___0(hashp);
#line 919
    tmp___2 = __errno_location();
#line 919
    *tmp___2 = save_errno;
    }
#line 920
    return (-1);
  }
  {
#line 923
  tmp___7 = calloc((size_t )(nsegs << hashp->hdr.sshift), sizeof(SEGMENT ));
#line 923
  store = (SEGMENT )tmp___7;
  }
#line 923
  if ((unsigned long )store == (unsigned long )((void *)0)) {
    {
#line 925
    tmp___5 = __errno_location();
#line 925
    save_errno = *tmp___5;
#line 926
    hdestroy___0(hashp);
#line 927
    tmp___6 = __errno_location();
#line 927
    *tmp___6 = save_errno;
    }
#line 928
    return (-1);
  }
#line 930
  i = 0;
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 930
    if (! (i < nsegs)) {
#line 930
      goto while_break;
    }
#line 931
    *(hashp->dir + i) = store + (i << hashp->hdr.sshift);
#line 930
    i ++;
#line 930
    (hashp->nsegs) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 932
  return (0);
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static void swap_header_copy___0(HASHHDR *srcp , HASHHDR *destp ) 
{ 
  int i ;

  {
#line 945
  *((char *)(& destp->magic) + 0) = *((char *)(& srcp->magic) + 3);
#line 945
  *((char *)(& destp->magic) + 1) = *((char *)(& srcp->magic) + 2);
#line 945
  *((char *)(& destp->magic) + 2) = *((char *)(& srcp->magic) + 1);
#line 945
  *((char *)(& destp->magic) + 3) = *((char *)(& srcp->magic) + 0);
#line 946
  *((char *)(& destp->version) + 0) = *((char *)(& srcp->version) + 3);
#line 946
  *((char *)(& destp->version) + 1) = *((char *)(& srcp->version) + 2);
#line 946
  *((char *)(& destp->version) + 2) = *((char *)(& srcp->version) + 1);
#line 946
  *((char *)(& destp->version) + 3) = *((char *)(& srcp->version) + 0);
#line 947
  *((char *)(& destp->lorder) + 0) = *((char *)(& srcp->lorder) + 3);
#line 947
  *((char *)(& destp->lorder) + 1) = *((char *)(& srcp->lorder) + 2);
#line 947
  *((char *)(& destp->lorder) + 2) = *((char *)(& srcp->lorder) + 1);
#line 947
  *((char *)(& destp->lorder) + 3) = *((char *)(& srcp->lorder) + 0);
#line 948
  *((char *)(& destp->bsize) + 0) = *((char *)(& srcp->bsize) + 3);
#line 948
  *((char *)(& destp->bsize) + 1) = *((char *)(& srcp->bsize) + 2);
#line 948
  *((char *)(& destp->bsize) + 2) = *((char *)(& srcp->bsize) + 1);
#line 948
  *((char *)(& destp->bsize) + 3) = *((char *)(& srcp->bsize) + 0);
#line 949
  *((char *)(& destp->bshift) + 0) = *((char *)(& srcp->bshift) + 3);
#line 949
  *((char *)(& destp->bshift) + 1) = *((char *)(& srcp->bshift) + 2);
#line 949
  *((char *)(& destp->bshift) + 2) = *((char *)(& srcp->bshift) + 1);
#line 949
  *((char *)(& destp->bshift) + 3) = *((char *)(& srcp->bshift) + 0);
#line 950
  *((char *)(& destp->dsize) + 0) = *((char *)(& srcp->dsize) + 3);
#line 950
  *((char *)(& destp->dsize) + 1) = *((char *)(& srcp->dsize) + 2);
#line 950
  *((char *)(& destp->dsize) + 2) = *((char *)(& srcp->dsize) + 1);
#line 950
  *((char *)(& destp->dsize) + 3) = *((char *)(& srcp->dsize) + 0);
#line 951
  *((char *)(& destp->ssize) + 0) = *((char *)(& srcp->ssize) + 3);
#line 951
  *((char *)(& destp->ssize) + 1) = *((char *)(& srcp->ssize) + 2);
#line 951
  *((char *)(& destp->ssize) + 2) = *((char *)(& srcp->ssize) + 1);
#line 951
  *((char *)(& destp->ssize) + 3) = *((char *)(& srcp->ssize) + 0);
#line 952
  *((char *)(& destp->sshift) + 0) = *((char *)(& srcp->sshift) + 3);
#line 952
  *((char *)(& destp->sshift) + 1) = *((char *)(& srcp->sshift) + 2);
#line 952
  *((char *)(& destp->sshift) + 2) = *((char *)(& srcp->sshift) + 1);
#line 952
  *((char *)(& destp->sshift) + 3) = *((char *)(& srcp->sshift) + 0);
#line 953
  *((char *)(& destp->ovfl_point) + 0) = *((char *)(& srcp->ovfl_point) + 3);
#line 953
  *((char *)(& destp->ovfl_point) + 1) = *((char *)(& srcp->ovfl_point) + 2);
#line 953
  *((char *)(& destp->ovfl_point) + 2) = *((char *)(& srcp->ovfl_point) + 1);
#line 953
  *((char *)(& destp->ovfl_point) + 3) = *((char *)(& srcp->ovfl_point) + 0);
#line 954
  *((char *)(& destp->last_freed) + 0) = *((char *)(& srcp->last_freed) + 3);
#line 954
  *((char *)(& destp->last_freed) + 1) = *((char *)(& srcp->last_freed) + 2);
#line 954
  *((char *)(& destp->last_freed) + 2) = *((char *)(& srcp->last_freed) + 1);
#line 954
  *((char *)(& destp->last_freed) + 3) = *((char *)(& srcp->last_freed) + 0);
#line 955
  *((char *)(& destp->max_bucket) + 0) = *((char *)(& srcp->max_bucket) + 3);
#line 955
  *((char *)(& destp->max_bucket) + 1) = *((char *)(& srcp->max_bucket) + 2);
#line 955
  *((char *)(& destp->max_bucket) + 2) = *((char *)(& srcp->max_bucket) + 1);
#line 955
  *((char *)(& destp->max_bucket) + 3) = *((char *)(& srcp->max_bucket) + 0);
#line 956
  *((char *)(& destp->high_mask) + 0) = *((char *)(& srcp->high_mask) + 3);
#line 956
  *((char *)(& destp->high_mask) + 1) = *((char *)(& srcp->high_mask) + 2);
#line 956
  *((char *)(& destp->high_mask) + 2) = *((char *)(& srcp->high_mask) + 1);
#line 956
  *((char *)(& destp->high_mask) + 3) = *((char *)(& srcp->high_mask) + 0);
#line 957
  *((char *)(& destp->low_mask) + 0) = *((char *)(& srcp->low_mask) + 3);
#line 957
  *((char *)(& destp->low_mask) + 1) = *((char *)(& srcp->low_mask) + 2);
#line 957
  *((char *)(& destp->low_mask) + 2) = *((char *)(& srcp->low_mask) + 1);
#line 957
  *((char *)(& destp->low_mask) + 3) = *((char *)(& srcp->low_mask) + 0);
#line 958
  *((char *)(& destp->ffactor) + 0) = *((char *)(& srcp->ffactor) + 3);
#line 958
  *((char *)(& destp->ffactor) + 1) = *((char *)(& srcp->ffactor) + 2);
#line 958
  *((char *)(& destp->ffactor) + 2) = *((char *)(& srcp->ffactor) + 1);
#line 958
  *((char *)(& destp->ffactor) + 3) = *((char *)(& srcp->ffactor) + 0);
#line 959
  *((char *)(& destp->nkeys) + 0) = *((char *)(& srcp->nkeys) + 3);
#line 959
  *((char *)(& destp->nkeys) + 1) = *((char *)(& srcp->nkeys) + 2);
#line 959
  *((char *)(& destp->nkeys) + 2) = *((char *)(& srcp->nkeys) + 1);
#line 959
  *((char *)(& destp->nkeys) + 3) = *((char *)(& srcp->nkeys) + 0);
#line 960
  *((char *)(& destp->hdrpages) + 0) = *((char *)(& srcp->hdrpages) + 3);
#line 960
  *((char *)(& destp->hdrpages) + 1) = *((char *)(& srcp->hdrpages) + 2);
#line 960
  *((char *)(& destp->hdrpages) + 2) = *((char *)(& srcp->hdrpages) + 1);
#line 960
  *((char *)(& destp->hdrpages) + 3) = *((char *)(& srcp->hdrpages) + 0);
#line 961
  *((char *)(& destp->h_charkey) + 0) = *((char *)(& srcp->h_charkey) + 3);
#line 961
  *((char *)(& destp->h_charkey) + 1) = *((char *)(& srcp->h_charkey) + 2);
#line 961
  *((char *)(& destp->h_charkey) + 2) = *((char *)(& srcp->h_charkey) + 1);
#line 961
  *((char *)(& destp->h_charkey) + 3) = *((char *)(& srcp->h_charkey) + 0);
#line 962
  i = 0;
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 962
    if (! (i < 32)) {
#line 962
      goto while_break;
    }
#line 963
    *((char *)(& destp->spares[i]) + 0) = *((char *)(& srcp->spares[i]) + 3);
#line 963
    *((char *)(& destp->spares[i]) + 1) = *((char *)(& srcp->spares[i]) + 2);
#line 963
    *((char *)(& destp->spares[i]) + 2) = *((char *)(& srcp->spares[i]) + 1);
#line 963
    *((char *)(& destp->spares[i]) + 3) = *((char *)(& srcp->spares[i]) + 0);
#line 964
    *((char *)(& destp->bitmaps[i]) + 0) = *((char *)(& srcp->bitmaps[i]) + 1);
#line 964
    *((char *)(& destp->bitmaps[i]) + 1) = *((char *)(& srcp->bitmaps[i]) + 0);
#line 962
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 966
  return;
}
}
#line 968 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/hash/hash.c"
static void swap_header___0(HTAB *hashp ) 
{ 
  HASHHDR *hdrp ;
  int i ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int32_t _tmp___4 ;
  u_int32_t _tmp___5 ;
  u_int32_t _tmp___6 ;
  u_int32_t _tmp___7 ;
  u_int32_t _tmp___8 ;
  u_int32_t _tmp___9 ;
  u_int32_t _tmp___10 ;
  u_int32_t _tmp___11 ;
  u_int32_t _tmp___12 ;
  u_int32_t _tmp___13 ;
  u_int32_t _tmp___14 ;
  u_int32_t _tmp___15 ;
  u_int32_t _tmp___16 ;
  u_int16_t _tmp___17 ;

  {
#line 975
  hdrp = & hashp->hdr;
#line 977
  _tmp = (u_int32_t )hdrp->magic;
#line 977
  *((char *)(& hdrp->magic) + 0) = *((char *)(& _tmp) + 3);
#line 977
  *((char *)(& hdrp->magic) + 1) = *((char *)(& _tmp) + 2);
#line 977
  *((char *)(& hdrp->magic) + 2) = *((char *)(& _tmp) + 1);
#line 977
  *((char *)(& hdrp->magic) + 3) = *((char *)(& _tmp) + 0);
#line 978
  _tmp___0 = (u_int32_t )hdrp->version;
#line 978
  *((char *)(& hdrp->version) + 0) = *((char *)(& _tmp___0) + 3);
#line 978
  *((char *)(& hdrp->version) + 1) = *((char *)(& _tmp___0) + 2);
#line 978
  *((char *)(& hdrp->version) + 2) = *((char *)(& _tmp___0) + 1);
#line 978
  *((char *)(& hdrp->version) + 3) = *((char *)(& _tmp___0) + 0);
#line 979
  _tmp___1 = hdrp->lorder;
#line 979
  *((char *)(& hdrp->lorder) + 0) = *((char *)(& _tmp___1) + 3);
#line 979
  *((char *)(& hdrp->lorder) + 1) = *((char *)(& _tmp___1) + 2);
#line 979
  *((char *)(& hdrp->lorder) + 2) = *((char *)(& _tmp___1) + 1);
#line 979
  *((char *)(& hdrp->lorder) + 3) = *((char *)(& _tmp___1) + 0);
#line 980
  _tmp___2 = (u_int32_t )hdrp->bsize;
#line 980
  *((char *)(& hdrp->bsize) + 0) = *((char *)(& _tmp___2) + 3);
#line 980
  *((char *)(& hdrp->bsize) + 1) = *((char *)(& _tmp___2) + 2);
#line 980
  *((char *)(& hdrp->bsize) + 2) = *((char *)(& _tmp___2) + 1);
#line 980
  *((char *)(& hdrp->bsize) + 3) = *((char *)(& _tmp___2) + 0);
#line 981
  _tmp___3 = (u_int32_t )hdrp->bshift;
#line 981
  *((char *)(& hdrp->bshift) + 0) = *((char *)(& _tmp___3) + 3);
#line 981
  *((char *)(& hdrp->bshift) + 1) = *((char *)(& _tmp___3) + 2);
#line 981
  *((char *)(& hdrp->bshift) + 2) = *((char *)(& _tmp___3) + 1);
#line 981
  *((char *)(& hdrp->bshift) + 3) = *((char *)(& _tmp___3) + 0);
#line 982
  _tmp___4 = (u_int32_t )hdrp->dsize;
#line 982
  *((char *)(& hdrp->dsize) + 0) = *((char *)(& _tmp___4) + 3);
#line 982
  *((char *)(& hdrp->dsize) + 1) = *((char *)(& _tmp___4) + 2);
#line 982
  *((char *)(& hdrp->dsize) + 2) = *((char *)(& _tmp___4) + 1);
#line 982
  *((char *)(& hdrp->dsize) + 3) = *((char *)(& _tmp___4) + 0);
#line 983
  _tmp___5 = (u_int32_t )hdrp->ssize;
#line 983
  *((char *)(& hdrp->ssize) + 0) = *((char *)(& _tmp___5) + 3);
#line 983
  *((char *)(& hdrp->ssize) + 1) = *((char *)(& _tmp___5) + 2);
#line 983
  *((char *)(& hdrp->ssize) + 2) = *((char *)(& _tmp___5) + 1);
#line 983
  *((char *)(& hdrp->ssize) + 3) = *((char *)(& _tmp___5) + 0);
#line 984
  _tmp___6 = (u_int32_t )hdrp->sshift;
#line 984
  *((char *)(& hdrp->sshift) + 0) = *((char *)(& _tmp___6) + 3);
#line 984
  *((char *)(& hdrp->sshift) + 1) = *((char *)(& _tmp___6) + 2);
#line 984
  *((char *)(& hdrp->sshift) + 2) = *((char *)(& _tmp___6) + 1);
#line 984
  *((char *)(& hdrp->sshift) + 3) = *((char *)(& _tmp___6) + 0);
#line 985
  _tmp___7 = (u_int32_t )hdrp->ovfl_point;
#line 985
  *((char *)(& hdrp->ovfl_point) + 0) = *((char *)(& _tmp___7) + 3);
#line 985
  *((char *)(& hdrp->ovfl_point) + 1) = *((char *)(& _tmp___7) + 2);
#line 985
  *((char *)(& hdrp->ovfl_point) + 2) = *((char *)(& _tmp___7) + 1);
#line 985
  *((char *)(& hdrp->ovfl_point) + 3) = *((char *)(& _tmp___7) + 0);
#line 986
  _tmp___8 = (u_int32_t )hdrp->last_freed;
#line 986
  *((char *)(& hdrp->last_freed) + 0) = *((char *)(& _tmp___8) + 3);
#line 986
  *((char *)(& hdrp->last_freed) + 1) = *((char *)(& _tmp___8) + 2);
#line 986
  *((char *)(& hdrp->last_freed) + 2) = *((char *)(& _tmp___8) + 1);
#line 986
  *((char *)(& hdrp->last_freed) + 3) = *((char *)(& _tmp___8) + 0);
#line 987
  _tmp___9 = (u_int32_t )hdrp->max_bucket;
#line 987
  *((char *)(& hdrp->max_bucket) + 0) = *((char *)(& _tmp___9) + 3);
#line 987
  *((char *)(& hdrp->max_bucket) + 1) = *((char *)(& _tmp___9) + 2);
#line 987
  *((char *)(& hdrp->max_bucket) + 2) = *((char *)(& _tmp___9) + 1);
#line 987
  *((char *)(& hdrp->max_bucket) + 3) = *((char *)(& _tmp___9) + 0);
#line 988
  _tmp___10 = (u_int32_t )hdrp->high_mask;
#line 988
  *((char *)(& hdrp->high_mask) + 0) = *((char *)(& _tmp___10) + 3);
#line 988
  *((char *)(& hdrp->high_mask) + 1) = *((char *)(& _tmp___10) + 2);
#line 988
  *((char *)(& hdrp->high_mask) + 2) = *((char *)(& _tmp___10) + 1);
#line 988
  *((char *)(& hdrp->high_mask) + 3) = *((char *)(& _tmp___10) + 0);
#line 989
  _tmp___11 = (u_int32_t )hdrp->low_mask;
#line 989
  *((char *)(& hdrp->low_mask) + 0) = *((char *)(& _tmp___11) + 3);
#line 989
  *((char *)(& hdrp->low_mask) + 1) = *((char *)(& _tmp___11) + 2);
#line 989
  *((char *)(& hdrp->low_mask) + 2) = *((char *)(& _tmp___11) + 1);
#line 989
  *((char *)(& hdrp->low_mask) + 3) = *((char *)(& _tmp___11) + 0);
#line 990
  _tmp___12 = (u_int32_t )hdrp->ffactor;
#line 990
  *((char *)(& hdrp->ffactor) + 0) = *((char *)(& _tmp___12) + 3);
#line 990
  *((char *)(& hdrp->ffactor) + 1) = *((char *)(& _tmp___12) + 2);
#line 990
  *((char *)(& hdrp->ffactor) + 2) = *((char *)(& _tmp___12) + 1);
#line 990
  *((char *)(& hdrp->ffactor) + 3) = *((char *)(& _tmp___12) + 0);
#line 991
  _tmp___13 = (u_int32_t )hdrp->nkeys;
#line 991
  *((char *)(& hdrp->nkeys) + 0) = *((char *)(& _tmp___13) + 3);
#line 991
  *((char *)(& hdrp->nkeys) + 1) = *((char *)(& _tmp___13) + 2);
#line 991
  *((char *)(& hdrp->nkeys) + 2) = *((char *)(& _tmp___13) + 1);
#line 991
  *((char *)(& hdrp->nkeys) + 3) = *((char *)(& _tmp___13) + 0);
#line 992
  _tmp___14 = (u_int32_t )hdrp->hdrpages;
#line 992
  *((char *)(& hdrp->hdrpages) + 0) = *((char *)(& _tmp___14) + 3);
#line 992
  *((char *)(& hdrp->hdrpages) + 1) = *((char *)(& _tmp___14) + 2);
#line 992
  *((char *)(& hdrp->hdrpages) + 2) = *((char *)(& _tmp___14) + 1);
#line 992
  *((char *)(& hdrp->hdrpages) + 3) = *((char *)(& _tmp___14) + 0);
#line 993
  _tmp___15 = (u_int32_t )hdrp->h_charkey;
#line 993
  *((char *)(& hdrp->h_charkey) + 0) = *((char *)(& _tmp___15) + 3);
#line 993
  *((char *)(& hdrp->h_charkey) + 1) = *((char *)(& _tmp___15) + 2);
#line 993
  *((char *)(& hdrp->h_charkey) + 2) = *((char *)(& _tmp___15) + 1);
#line 993
  *((char *)(& hdrp->h_charkey) + 3) = *((char *)(& _tmp___15) + 0);
#line 994
  i = 0;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! (i < 32)) {
#line 994
      goto while_break;
    }
#line 995
    _tmp___16 = (u_int32_t )hdrp->spares[i];
#line 995
    *((char *)(& hdrp->spares[i]) + 0) = *((char *)(& _tmp___16) + 3);
#line 995
    *((char *)(& hdrp->spares[i]) + 1) = *((char *)(& _tmp___16) + 2);
#line 995
    *((char *)(& hdrp->spares[i]) + 2) = *((char *)(& _tmp___16) + 1);
#line 995
    *((char *)(& hdrp->spares[i]) + 3) = *((char *)(& _tmp___16) + 0);
#line 996
    _tmp___17 = hdrp->bitmaps[i];
#line 996
    *((char *)(& hdrp->bitmaps[i]) + 0) = *((char *)(& _tmp___17) + 1);
#line 996
    *((char *)(& hdrp->bitmaps[i]) + 1) = *((char *)(& _tmp___17) + 0);
#line 994
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 998
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
static BKT *mpool_bkt___0(MPOOL *mp ) ;
#line 66
static BKT *mpool_look___0(MPOOL *mp , u_int32_t pgno ) ;
#line 67
static int mpool_write___0(MPOOL *mp , BKT *bp ) ;
#line 337 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
static BKT *mpool_bkt___0(MPOOL *mp ) 
{ 
  struct _hqh *head ;
  BKT *bp ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 345
  if (mp->curcache < mp->maxcache) {
#line 346
    goto new;
  }
#line 354
  bp = mp->lqh.cqh_first;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! ((unsigned long )bp != (unsigned long )((void *)(& mp->lqh)))) {
#line 354
      goto while_break;
    }
#line 356
    if (! ((int )bp->flags & 2)) {
#line 358
      if ((int )bp->flags & 1) {
        {
#line 358
        tmp___1 = mpool_write___0(mp, bp);
        }
#line 358
        if (tmp___1 == -1) {
#line 360
          return ((BKT *)((void *)0));
        }
      }
#line 365
      head = & mp->hqh[(bp->pgno - 1U) % 128U];
      {
#line 366
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 366
        if ((unsigned long )bp->hq.cqe_next == (unsigned long )((void *)head)) {
#line 366
          head->cqh_last = bp->hq.cqe_prev;
        } else {
#line 366
          (bp->hq.cqe_next)->hq.cqe_prev = bp->hq.cqe_prev;
        }
#line 366
        if ((unsigned long )bp->hq.cqe_prev == (unsigned long )((void *)head)) {
#line 366
          head->cqh_first = bp->hq.cqe_next;
        } else {
#line 366
          (bp->hq.cqe_prev)->hq.cqe_next = bp->hq.cqe_next;
        }
#line 366
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 367
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 367
        if ((unsigned long )bp->q.cqe_next == (unsigned long )((void *)(& mp->lqh))) {
#line 367
          mp->lqh.cqh_last = bp->q.cqe_prev;
        } else {
#line 367
          (bp->q.cqe_next)->q.cqe_prev = bp->q.cqe_prev;
        }
#line 367
        if ((unsigned long )bp->q.cqe_prev == (unsigned long )((void *)(& mp->lqh))) {
#line 367
          mp->lqh.cqh_first = bp->q.cqe_next;
        } else {
#line 367
          (bp->q.cqe_prev)->q.cqe_next = bp->q.cqe_next;
        }
#line 367
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 375
      return (bp);
    }
#line 354
    bp = bp->q.cqe_next;
  }
  while_break: /* CIL Label */ ;
  }
  new: 
  {
#line 378
  tmp___2 = malloc(sizeof(BKT ) + mp->pagesize);
#line 378
  bp = (BKT *)tmp___2;
  }
#line 378
  if ((unsigned long )bp == (unsigned long )((void *)0)) {
#line 379
    return ((BKT *)((void *)0));
  }
#line 386
  bp->page = (void *)((char *)bp + sizeof(BKT ));
#line 387
  (mp->curcache) ++;
#line 388
  return (bp);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
static int mpool_write___0(MPOOL *mp , BKT *bp ) 
{ 
  off_t off ;
  __off_t tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 407
  if (mp->pgout) {
    {
#line 408
    (*(mp->pgout))(mp->pgcookie, bp->pgno, bp->page);
    }
  }
  {
#line 410
  off = (off_t )(mp->pagesize * (u_long )bp->pgno);
#line 411
  tmp___1 = lseek(mp->fd, off, 0);
  }
#line 411
  if (tmp___1 != off) {
#line 412
    return (-1);
  }
  {
#line 413
  tmp___2 = write(mp->fd, (void const   *)bp->page, mp->pagesize);
  }
#line 413
  if ((u_long )tmp___2 != mp->pagesize) {
#line 414
    return (-1);
  }
#line 416
  bp->flags = (u_int8_t )((int )bp->flags & -2);
#line 417
  return (0);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/db1-compat-2.1.3/mpool/mpool.c"
static BKT *mpool_look___0(MPOOL *mp , u_int32_t pgno ) 
{ 
  struct _hqh *head ;
  BKT *bp ;

  {
#line 432
  head = & mp->hqh[(pgno - 1U) % 128U];
#line 433
  bp = head->cqh_first;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! ((unsigned long )bp != (unsigned long )((void *)head))) {
#line 433
      goto while_break;
    }
#line 434
    if (bp->pgno == pgno) {
#line 438
      return (bp);
    }
#line 433
    bp = bp->hq.cqe_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return ((BKT *)((void *)0));
}
}
